  EvtDereference(pEventTimer->_pEvent);
        pEventTimer->_pEvent = NULL;
    }
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpRaiseToDpc
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ONLINE

void CXnIp::IpRaiseToDpc(BOOL fRaise)
{
    ICHECK(IP, USER|UDPC);

    Assert(KeGetCurrentIrql() == (fRaise ? PASSIVE_LEVEL : DISPATCH_LEVEL));

    if (fRaise)
        KeRaiseIrqlToDpcLevel();
    else
        KeLowerIrql(PASSIVE_LEVEL);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\ipdhcp.cpp ===
// ---------------------------------------------------------------------------------------
// ipdhcp.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

DefineTag(dhcp, 0);

#ifdef XNET_FEATURE_DHCP

//
// DHCP message format
// NOTE: default the options field to 64 bytes
// which is the size of BOOTP vendor-specified area
//

typedef struct _DhcpMessage {
    BYTE _op;                // message type
    BYTE _htype;             // hareware address type
    BYTE _hlen;              // hardware address length
    BYTE _hops;              // relay hops
    DWORD _xid;              // transaction ID
    WORD _secs;              // seconds since address acquisition process began
    WORD _flags;             // flags
    CIpAddr _ciaddr;          // client IP address
    CIpAddr _yiaddr;          // "your" (client) IP address
    CIpAddr _siaddr;          // server IP address
    CIpAddr _giaddr;          // relay agent IP address
    BYTE _chaddr[16];        // client hardware address
    BYTE _sname[64];         // optional server hostname
    BYTE _file[128];         // boot filename
    BYTE _options[64];       // optional parameters (variable length)
} DhcpMessage;

//
// Our default DHCP packet buffer is 576 bytes
//
#define BOOTP_MESSAGE_SIZE sizeof(DhcpMessage)
#define DEFAULT_DHCP_BUFSIZE 576
#define DHCPHDRLEN offsetof(DhcpMessage, _options)

//
// Minimum and maximum DHCP hardware address length
//
#define MIN_DHCP_HWADDRLEN 1
#define MAX_DHCP_HWADDRLEN 16

//
// BOOTP message type constants
//
#define BOOTREQUEST 1
#define BOOTREPLY   2

//
// Hardware type constants
//
#define HWTYPE_10MB_ETHERNET 1
#define HWTYPE_PPP           8

//
// Constants for DHCP_MESSAGE.flags
//
#define DHCP_BROADCAST 0x8000

//
// DHCP message type constants
//
#define DHCPDISCOVER    1
#define DHCPOFFER       2
#define DHCPREQUEST     3
#define DHCPDECLINE     4
#define DHCPACK         5
#define DHCPNAK         6
#define DHCPRELEASE     7
#define DHCPINFORM      8

//
// DHCP option tag constants
//

// Fixed-length options

#define DHCPOPT_PAD                     0
#define DHCPOPT_END                     255

// Standard options

#define DHCPOPT_SUBNET_MASK             1
#define DHCPOPT_TIME_OFFSET             2
#define DHCPOPT_ROUTERS                 3
#define DHCPOPT_TIME_SERVERS            4
#define DHCPOPT_IEN116_SERVERS          5
#define DHCPOPT_DNS_SERVERS             6
#define DHCPOPT_LOG_SERVERS             7
#define DHCPOPT_COOKIE_SERVERS          8
#define DHCPOPT_LPR_SERVERS             9
#define DHCPOPT_IMPRESS_SERVERS         10
#define DHCPOPT_RLP_SERVERS             11
#define DHCPOPT_HOST_NAME               12
#define DHCPOPT_BOOT_FILESIZE           13
#define DHCPOPT_DUMP_FILE               14
#define DHCPOPT_DOMAIN_NAME             15
#define DHCPOPT_SWAP_SERVER             16
#define DHCPOPT_ROOT_PATH               17
#define DHCPOPT_EXTENSIONS_PATH         18

// IP parameters (per host)

#define DHCPOPT_ENABLE_FORWARD          19
#define DHCPOPT_NONLOCAL_SRCROUTING     20
#define DHCPOPT_POLICY_FILTER           21
#define DHCPOPT_MAX_REASSEMBLY_SIZE     22
#define DHCPOPT_DEFAULT_IP_TTL          23
#define DHCPOPT_PMTU_AGING_TIMEOUT      24
#define DHCPOPT_PMTU_PLATEAU_TABLE      25

// IP parameters (per interface)

#define DHCPOPT_INTERFACE_MTU           26
#define DHCPOPT_ALL_SUBNETS_LOCAL       27
#define DHCPOPT_BROADCAST_ADDRESS       28
#define DHCPOPT_MASK_DISCOVERY          29
#define DHCPOPT_MASK_SUPPLIER           30
#define DHCPOPT_ROUTER_DISCOVERY        31
#define DHCPOPT_SOLICIT_ROUTER_ADDR     32
#define DHCPOPT_STATIC_ROUTES           33

// Link layer parameters

#define DHCPOPT_TRAILER_ENCAPS          34
#define DHCPOPT_ARP_CACHE_TIMEOUT       35
#define DHCPOPT_ETHERNET_ENCAPS         36

// TCP parameters

#define DHCPOPT_DEFAULT_TCP_TTL         37
#define DHCPOPT_KEEPALIVE_INTERVAL      38
#define DHCPOPT_KEEPALIVE_GARBAGE       39

// Application parameters

#define DHCPOPT_NIS_DOMAIN              40
#define DHCPOPT_NIS_SERVERS             41
#define DHCPOPT_NTP_SERVERS             42

// DHCP extensions

#define DHCPOPT_REQUESTED_CIpAddr        50
#define DHCPOPT_IPADDR_LEASE_TIME       51
#define DHCPOPT_FIELD_OVERLOAD          52
#define DHCPOPT_TFTP_SERVER_NAME        66
#define DHCPOPT_BOOT_FILENAME           67
#define DHCPOPT_DHCP_MESSAGE_TYPE       53
#define DHCPOPT_SERVERID                54
#define DHCPOPT_PARAM_REQUEST_LIST      55
#define DHCPOPT_MESSAGE                 56
#define DHCPOPT_MAX_DHCP_MESSAGESIZE    57
#define DHCPOPT_T1_INTERVAL             58
#define DHCPOPT_T2_INTERVAL             59
#define DHCPOPT_VENDOR_CLASSID          60
#define DHCPOPT_CLIENTID                61

// Vendor-specific information

#define DHCPOPT_VENDOR_INFO             43
#define DHCPOPT_NETBIOS_NAMESERVERS     44
#define DHCPOPT_NETBIOS_DATASERVERS     45
#define DHCPOPT_NETBIOS_NODETYPE        46
#define DHCPOPT_NETBIOS_SCOPE           47
#define DHCPOPT_X11_FONTSERVERS         48
#define DHCPOPT_X11_DISPLAYSERVERS      49
#define DHCPOPT_NIS2_DOMAIN             64
#define DHCPOPT_NIS2_SERVERS            65
#define DHCPOPT_MOBILEIP_HOME_AGENTS    68
#define DHCPOPT_SMTP_SERVERS            69
#define DHCPOPT_POP3_SERVERS            70
#define DHCPOPT_NNTP_SERVERS            71
#define DHCPOPT_WWW_SERVERS             72
#define DHCPOPT_FINGER_SERVERS          73
#define DHCPOPT_IRC_SERVERS             74
#define DHCPOPT_STREETTALK_SERVERS      75
#define DHCPOPT_STREETTALKDA_SERVERS    76

//
// DHCP magic cookie: 99, 130, 83, 99
//
//#define DHCPCOOKIELEN 4
//extern const BYTE DhcpMagicCookie[DHCPCOOKIELEN];

//
// DHCP time value (in seconds)
//
// NOTE: We use 32-bit unsigned interface to represent
// the number of seconds ellapsed since the start of 1/1/2000.
// This should last until year 2136 before overflowing.
//

#define DHCPTIME_INFINITE 0xffffffff

//
// Autonet address range: 169.254/16
//  don't use the first 256 and the last 256 addresses
//
#define AUTONET_ADDRMASK    0xffff0000
#define AUTONET_ADDRBASE    0xa9fe0100
#define AUTONET_ADDRRANGE   0x0000fcff

//
// States for an interface
//
enum {
    STATE_NONE,             // temporary wait state after startup
    STATE_STATIC_ADDR,      // statically assigned address
    STATE_INIT,             // sending discover
    STATE_REQUESTING,       // waiting for DHCPACK after selecting
    STATE_INIT_REBOOT,      // rebooting with valid lease
    STATE_BOUND,            // bound with valid address lease
    STATE_RENEWING,         // renewing after T1 expires
    STATE_REBINDING,        // rebinding after T2 expires
    STATE_DECLINING,        // temporary wait state after sending decline
    STATE_INIT_AUTOADDR,    // waiting for timer to kick off autonet
    STATE_SELECT_AUTOADDR   // checking autonet address conflicts
};

//
// Constants for the DhcpInfo.flags field:
//
#define FLAG_ACTIVE_DHCPADDR    0x00010000
#define FLAG_ACTIVE_AUTONETADDR 0x00020000
#define FLAG_ACTIVE_NOADDR      0x00040000
#define FLAG_ACTIVE_ADDRMASK    (FLAG_ACTIVE_DHCPADDR | FLAG_ACTIVE_AUTONETADDR | FLAG_ACTIVE_NOADDR)

BOOL CXnIp::ActiveDhcpAddr()
{
    return (_flags & FLAG_ACTIVE_DHCPADDR);
}

BOOL CXnIp::ActiveAutonetAddr()
{
    return (_flags & FLAG_ACTIVE_AUTONETADDR);
}

BOOL CXnIp::ActiveStaticAddr()
{
    return(_state == STATE_STATIC_ADDR);
}

BOOL CXnIp::ActiveNoAddr()
{
    return(_flags & FLAG_ACTIVE_NOADDR);
}

//
// Dump DHCP message in the debugger
//

#if DBG
VOID DhcpDumpMessage(DhcpMessage* msg, UINT msglen);
#else
#define DhcpDumpMessage(msg, msglen)
#endif

// ---------------------------------------------------------------------------------------

//
// First 4 bytes of the options field in a DHCP message
// must match the following magic cookie
//
const BYTE DhcpMagicCookie[] = { 99, 130, 83, 99 };

//
// Default address lease time requested:
//  let the server decide
//
//UINT cfgDefaultLeaseTime = 0;

//
// Minimum retransmission timeout while in
// RENEWING and REBINDING states: 60 seconds
//
//UINT cfgMinRenewTimeout = 60;

//
// Number of seconds to wait after reboot
// before we start sending out DHCPDISCOVER packets
//
// NOTE: RFC2131 recommends that we wait between 1 to 10 seconds.
// But we're only doing 1 seconds here for faster startup time.
//
//UINT cfgStartupWaitMin = 0;
//UINT cfgStartupWaitMax = 1;

//
// Number of times we'll attempt to resend
// DHCPDISCOVER and DHCPREQUEST packets
//
// NOTE: Non-standard behavior!!!
//  We're capping the timeout between retries to a maximum of 10 seconds.
//
//UINT cfgDhcpRetryCount = 3;
//UINT cfgDhcpRetryMaxTimeout = 10;

//
// Number of autonet addresses we'll attempt before giving up
//
//UINT cfgAutonetAddrRetries = 10;

//
// How frequently to look for DHCP server when in Autonet mode
//
//UINT cfgAutonetDhcpCheckInterval = 5*60;

//
// How many ARP requests to send
// when checking for address conflict
//
//UINT cfgConflictCheckRetries = 2;

// Check to see if we're forced to use autonet address
//  (without trying to find DHCP servers)
INLINE
BOOL CXnIp::DhcpForceAutonet(CIpAddr addr, CIpAddr mask)
{
    ICHECK(IP, USER|UDPC|SDPC);

    return (mask == HTONL(AUTONET_ADDRMASK)) && 
            (addr & mask) == (HTONL(AUTONET_ADDRBASE) & mask);
}

NTSTATUS CXnIp::DhcpInit()
{
    ICHECK(IP, USER);

    _state = STATE_NONE;
    _timerDhcp.Init((PFNTIMER)DhcpTimer);
    _dwXidNext = RandLong();

    return(NETERR_OK);
}

INT CXnIp::DhcpConfig(const XNetConfigParams * pxncp)
{
    ICHECK(IP, UDPC);

    //@@@ Cannot be reconfigured.  Need DHCP rewrite.

    _activeaddr = pxncp->ina.s_addr;

    if (_activeaddr != 0)
    {
        _activemask = pxncp->inaMask.s_addr;

        if (_activemask == 0 || !_activemask.IsValidMask())
            _activemask = _activeaddr.DefaultMask();

        _options._gatewayCount = 0;

        if (pxncp->inaGateway.s_addr != 0)
        {
            _options._gateways[_options._gatewayCount] = pxncp->inaGateway.s_addr;
            _options._gatewayCount += 1;
        }

        _options._dnsServerCount = 0;

        if (pxncp->inaDnsPrimary.s_addr != 0)
        {
            _options._dnsServers[_options._dnsServerCount] = pxncp->inaDnsPrimary.s_addr;
            _options._dnsServerCount += 1;
        }

        if (pxncp->inaDnsSecondary.s_addr != 0)
        {
            _options._dnsServers[_options._dnsServerCount] = pxncp->inaDnsSecondary.s_addr;
            _options._dnsServerCount += 1;
        }
    }

    if (!TestInitFlag(INITF_CONNECTED_BOOT))
    {
        TraceSz(Warning, "Ethernet cable not plugged in.  No IP address acquired.");
        _flags = (_flags & ~FLAG_ACTIVE_ADDRMASK) | FLAG_ACTIVE_NOADDR;
    }
#if defined(XNET_FEATURE_INSECURE) && !defined(XNET_FEATURE_SG)
    else if (!(cfgFlags & XNET_STARTUP_BYPASS_SECURITY))
    {
        // When operating in secure mode don't acquire an IP address so we behave
        // more like xnets.lib.

        _flags = (_flags & ~FLAG_ACTIVE_ADDRMASK) | FLAG_ACTIVE_NOADDR;
    }
#endif
    else if (_activeaddr != 0 && !DhcpForceAutonet(_activeaddr, _activemask))
    {
        // If we're using static address, inform the IP stack
        IpSetAddress(_activeaddr, _activemask);
        DhcpSetDefaultGateways();
        DhcpChangeState(STATE_STATIC_ADDR);
    }
    else if ((cfgFlags & XNET_STARTUP_BYPASS_DHCP) || _activeaddr != 0)
    {
        TraceSz(Warning, "Forcing autonet...");
        _activeaddr = _activemask = 0;
        DhcpChangeState(STATE_INIT_AUTOADDR);
    }
    else
    {
        // Obtain address via DHCP or Autonet.  Be quiet for a while after startup.
        DhcpTimerSetRelative(0, 0);
    }

    return(0);
}

void CXnIp::DhcpTerm()
{
    ICHECK(IP, UDPC);
    TimerSet(&_timerDhcp, TIMER_INFINITE);
}

void CXnIp::DhcpRecv(CPacket * ppkt, CUdpHdr * pUdpHdr, UINT msglen)
{
    ICHECK(IP, UDPC|SDPC);

    DhcpMessage * msg = (DhcpMessage *)(pUdpHdr + 1);
    CDhcpOptions * dhcpParams = NULL;
    BYTE* option;
    BYTE overload = 0;
    NTSTATUS status = NETERR_NOTIMPL;

    if (msglen < DHCPHDRLEN)
    {
        TraceSz1(pktRecv, "[DISCARD] DHCP packet is too short (%d)", msglen);
        return;
    }

    if (memcmp(msg->_chaddr, _ea._ab, sizeof(CEnetAddr)) != 0)
    {
        TraceSz(pktRecv, "[DISCARD] DHCP packet not meant for me");
        return;
    }

    if (    msg->_op != BOOTREPLY
        ||  msg->_htype != HWTYPE_10MB_ETHERNET
        ||  msg->_hlen != sizeof(CEnetAddr)
        ||  NTOHL(msg->_xid) != _xid)
    {
        TraceSz4(pktWarn, "[DISCARD] DHCP packet is invalid (%d,%d,%d,%d)",
                 msg->_op != BOOTREPLY,
                 msg->_htype != HWTYPE_10MB_ETHERNET,
                 msg->_hlen != sizeof(CEnetAddr),
                 NTOHL(msg->_xid) != _xid);
        return;
    }

    DhcpDumpMessage(msg, msglen);

    dhcpParams = (CDhcpOptions *)PoolAllocZ(sizeof(*dhcpParams), PTAG_CDhcpOptions);

    if (!dhcpParams)
    {
        TraceSz(pktWarn, "[DISCARD] Out of memory allocating CDhcpOptions");
        status = NETERR_MEMORY;
        goto exit;
    }

    //
    // Skip the DHCP magic cookie
    //
    option = msg->_options;
    msglen -= DHCPHDRLEN;
    if (    msglen < sizeof(DhcpMagicCookie)
        ||  memcmp(option, DhcpMagicCookie, sizeof(DhcpMagicCookie)) != 0)
    {
        TraceSz1(pktWarn, "[DISCARD] DHCP packet has invalid magic cookie (%d)", msglen);
        goto exit;
    }

    msglen -= sizeof(DhcpMagicCookie);
    option += sizeof(DhcpMagicCookie);

    //
    // Parse the regular options
    //
    status = DhcpParseOptionParams(dhcpParams, option, msglen, &overload);

    if (!NT_SUCCESS(status))
    {
        TraceSz(pktWarn, "[DISCARD] DHCP regular options are invalid");
        goto exit;
    }

    //
    // Parse overloaded options in the msg->_file field
    //
    if (overload & 1)
    {
        status = DhcpParseOptionParams(dhcpParams, msg->_file, sizeof(msg->_file), NULL);

        if (!NT_SUCCESS(status))
        {
            TraceSz(pktWarn, "[DISCARD] DHCP file options are invalid");
            goto exit;
        }
    }

    //
    // Parse overloaded options in the msg->_sname field
    //
    if (overload & 2)
    {
        status = DhcpParseOptionParams(dhcpParams, msg->_sname, sizeof(msg->_sname), NULL); 

        if (!NT_SUCCESS(status))
        {
            TraceSz(pktWarn, "[DISCARD] DHCP sname options are invalid");
            goto exit;
        }
    }

    //
    // The received packet must have a server identifier option
    //
    if (dhcpParams->_dhcpServer == 0)
    {
        TraceSz(pktWarn, "[DISCARD] DHCP packet lacks server identifier option");
        status = NETERR_PARAM;
        goto exit;
    }

    //
    // Now that we've parsed the option data,
    // use it appropriately
    //
    status = NETERR_NOTIMPL;

    switch (_state) {
    case STATE_INIT:
        // Expecting DHCPOFFER...
        if (dhcpParams->_recvMsgType == DHCPOFFER)
            status = DhcpProcessOffer(msg->_yiaddr, dhcpParams);
        break;

    case STATE_INIT_REBOOT:
    case STATE_REQUESTING:
    case STATE_RENEWING:
    case STATE_REBINDING:
        // Expecting DHCPACK or DHCPNAK...
        if (dhcpParams->_recvMsgType == DHCPACK)
            status = DhcpProcessAck(msg->_yiaddr, dhcpParams);
        else if (dhcpParams->_recvMsgType == DHCPNAK)
            status = DhcpProcessNak(dhcpParams->_dhcpServer);
        break;
    }

exit:

    if (!NT_SUCCESS(status) && status != NETERR_NOTIMPL)
    {
        TraceSz1(pktWarn, "[DISCARD] DhcpRecv failed: %08lX", status);
    }

    PoolFree(dhcpParams);
}

void CXnIp::DhcpNotifyAddressConflict()
{
    ICHECK(IP, UDPC|SDPC);

    if (_state == STATE_SELECT_AUTOADDR)
    {
        // the last autonet address we chose was no good
        // so we need to find another one
        DhcpSelectAutonetAddr();
    }
    else
    {
        TraceSz1(Warning, "!!! Address conflict: %s", _activeaddr.Str());
    }
}

//
// Number of seconds from start of 1601 to start of 2000
//
static const LONGLONG StartOf2000 = 0x2ee7dd480;

CXnIp::DHCPTIME CXnIp::DhcpTime()
{
    ICHECK(IP, UDPC|SDPC);

    LARGE_INTEGER currentTime;

    // Get the current UTC time
    //  = number of 100 nanoseconds since 1/1/1601
    KeQuerySystemTime(&currentTime);

    // Return the number of seconds since the start of 2000
    return (DHCPTIME) (currentTime.QuadPart / 10000000 - StartOf2000);
}


void CXnIp::DhcpTimerSetRelative(UINT minWait, UINT maxWait)
{
    ICHECK(IP, UDPC|SDPC);

    TimerSet(&_timerDhcp, TimerTick() + (minWait + RandScaled(maxWait - minWait)) * TICKS_PER_SECOND);
}

void CXnIp::DhcpTimerSetAbsolute(DHCPTIME dhcptime)
{
    ICHECK(IP, UDPC|SDPC);

    DWORD dwTick = TIMER_INFINITE;

    if (dhcptime != DHCPTIME_INFINITE)
    {
        DHCPTIME dhcptimeNow = DhcpTime();

        if (dhcptime > dhcptimeNow)
            dwTick = TimerTick() + (dhcptime - dhcptimeNow) * TICKS_PER_SECOND;
        else
            dwTick = TimerTick();
    }

    TimerSet(&_timerDhcp, dwTick);
}

void CXnIp::DhcpComputeTimeout()
{
    ICHECK(IP, UDPC|SDPC);

    UINT minWait, maxWait;

    switch (_state)
    {
    case STATE_INIT:
        if (ActiveAutonetAddr()) {
            //
            // Special case: we're currently using an Autonet address
            // and we're sending out periodic DHCPDISCOVER packets.
            //
            // DhcpSetIfTimerRelative(
            //     cfgAutonetDhcpCheckInterval,
            //     cfgAutonetDhcpCheckInterval);

            // NOTE: Non-standard behavior!!!
            //  We do not send out DHCPDISCOVER messages
            //  while we're using an active AutoNet address.
            DhcpTimerSetAbsolute(DHCPTIME_INFINITE);
            break;
        }

        // Fall through

    case STATE_REQUESTING:
    case STATE_INIT_REBOOT:
        //
        // timeout = 2**retry x 2 +/- 1, i.e.
        //  4 +/- 1
        //  8 +/- 1
        //  16 +/- 1
        //  32 +/- 1
        //

        minWait = 2 << _retries;
        if (minWait > cfgDhcpRetryMaxTimeoutInSeconds)
            minWait = cfgDhcpRetryMaxTimeoutInSeconds;

        minWait -= 1;
        maxWait = minWait + 2;
        DhcpTimerSetRelative(minWait, maxWait);
        break;

    case STATE_BOUND:
        //
        // timeout when T1 expires
        //
        DhcpTimerSetAbsolute(_options._t1time);
        break;

    case STATE_RENEWING:
    case STATE_REBINDING: {
        //
        // calculate retransmission timeout for
        // RENEWING and REBINDING states:
        //  1. half the time from now to T2 (renew) or expiration (rebind)
        //  2. make sure it's at least 60 seconds
        //

        DHCPTIME t1, t2;
        t1 = DhcpTime();
        t2 = (_state == STATE_RENEWING) ? _options._t2time : _options._exptime;

        if (t1 < t2) {
            minWait = (t2-t1) / 2;
            if (minWait >= cfgDhcpRenewMinTimeoutInSeconds)
                t1 += minWait;
            else {
                t1 += cfgDhcpRenewMinTimeoutInSeconds;
                if (t1 > t2) t1 = t2;
            }
        }

        DhcpTimerSetAbsolute(t1);
        }
        break;

    case STATE_DECLINING:
        //
        // Wait 10 seconds after sending DHCP decline
        //
        DhcpTimerSetRelative(cfgDhcpDeclineWaitInSeconds, cfgDhcpDeclineWaitInSeconds);
        break;
    
    case STATE_SELECT_AUTOADDR:
        //
        // Wait ~2 seconds for address conflict detection
        //
        DhcpTimerSetRelative(cfgAutoIpRexmitTimeoutInSeconds, cfgAutoIpRexmitTimeoutInSeconds);
        break;

    default:
        // Should not happen - shut off the timer just in case
        Assert(FALSE);

    case STATE_NONE:
    case STATE_STATIC_ADDR:
        DhcpTimerSetAbsolute(DHCPTIME_INFINITE);
        break;
    }
}

void CXnIp::DhcpTimer(CTimer * pt)
{
    ICHECK(IP, UDPC|SDPC);

    switch (_state) {
    case STATE_NONE:
        //
        // We got here because we just finished the quiet
        // period after startup
        //
        // If we had a valid lease before, start in
        // INIT-REBOOT state; otherwise, start in INIT state
        //
        DhcpChangeState(_dhcpaddr ? STATE_INIT_REBOOT : STATE_INIT);
        break;
    
    case STATE_INIT:
        //
        // We're sending DHCPDISCOVER messages
        //
        if (_retries >= cfgDhcpRetryCount && !ActiveAutonetAddr())
        {
            //
            // Too many retries, give up and
            // start Autonet address acquisition process
            //
            TraceSz(dhcp, "Couldn't discover DHCP server, trying autonet...");
            DhcpChangeState(STATE_SELECT_AUTOADDR);
        }
        else
        {
            //
            // Send out another DHCPDISCOVER packet
            //
            TraceSz(dhcp, "Retransmit DHCPDISCOVER");
            DhcpSendDiscover();
        }
        break;

    case STATE_INIT_REBOOT:
    case STATE_REQUESTING:
        //
        // We're sending DHCPREQUEST
        //
        if (_retries >= cfgDhcpRetryCount) {
            //
            // Too many retries, go back to INIT state
            //
            TraceSz(dhcp, _state == STATE_INIT_REBOOT ?
                        "Failed to reuse a prior lease" :
                        "No ack for an offered address");

            DhcpChangeState(STATE_INIT);
        } else {
            //
            // Send out another DHCPREQUEST packet
            //
            TraceSz(dhcp, "Retransmit DHCPREQUEST");
            DhcpSendRequest();
        }
        break;
    
    case STATE_DECLINING:
        //
        // We just finished waiting after sending DHCPDECLINE
        //
        DhcpChangeState(STATE_INIT);
        break;
    
    case STATE_BOUND:
        //
        // T1 expired, start the renewing process
        //
        TraceSz(dhcp, "Switching to RENEWING state");
        DhcpChangeState(STATE_RENEWING);
        break;

    case STATE_RENEWING:
        //
        // We're trying to renew a valid address.
        // If T2 expired, start the rebinding process.
        //
        if (DhcpTime() >= _options._t2time) {
            TraceSz(dhcp, "Switching to REBINDING state");
            DhcpChangeState(STATE_REBINDING);
        } else {
            // Send out another DHCPREQUEST
            TraceSz(dhcp, "Retransmit DHCPREQUEST");
            DhcpSendRequest();
        }
        break;

    case STATE_REBINDING:
        //
        // We're trying to rebind a valid lease
        //  did our lease expire?
        //
        if (DhcpTime() >= _options._exptime) {
            // Inform IP stack to discard the active address
            TraceSz(dhcp, "Address lease expired - start over");
            DhcpResetInterface();

            // Too bad, go back to INIT state
            DhcpChangeState(STATE_INIT);
        } else {
            // Send out another DHCPREQUEST
            TraceSz(dhcp, "Retransmit DHCPREQUEST");
            DhcpSendRequest();
        }
        break;

    case STATE_INIT_AUTOADDR:
        DhcpChangeState(STATE_SELECT_AUTOADDR);
        break;

    case STATE_SELECT_AUTOADDR:
        if (++_retries > cfgAutoIpRetriesPerAttempt)
        {
            // We've successfully picked an autonet address.
            TraceSz1(dhcp, "Selected autonet address: %s", _autonetaddr.Str());

            _activeaddr = _autonetaddr;
            _activemask = HTONL(AUTONET_ADDRMASK);
            _flags |= FLAG_ACTIVE_AUTONETADDR;
            IpSetAddress(_activeaddr, _activemask);

            // Switch to INIT state to continue looking
            // for a DHCP server
            _initRetryCount = 0;
            DhcpChangeState(STATE_INIT);
        }
        else
        {
            // No response to our previous ARP request.
            // Try again just to be sure.
            EnetXmitArp(_autonetaddr);
            DhcpComputeTimeout();
        }
        break;

    default:
        TraceSz(dhcp, "Unexpected timeout");
        DhcpTimerSetAbsolute(DHCPTIME_INFINITE);
        break;
    }
}


void CXnIp::DhcpChangeState(INT state)
{
    ICHECK(IP, UDPC|SDPC);

    INT oldstate = _state;

    _state = state;
    _retries = 0;

    // Assign a new transaction ID for the next outgoing message.

    _xid = _dwXidNext++;

    switch (state) {
    case STATE_INIT_REBOOT:
    case STATE_REQUESTING:
    case STATE_RENEWING:
    case STATE_REBINDING:
        // Send out DHCPREQUEST
        DhcpSendRequest();
        break;

    case STATE_INIT:
        if (oldstate == STATE_SELECT_AUTOADDR) {
            // We just selected an autonet address.
            // Continue to look for a DHCP server.
            DhcpComputeTimeout();
        }
        else if (++_initRetryCount > cfgDhcpRetryCount) {
            // We went through the INIT state too many times
            // without getting a valid address lease. Just give up.
            // We don't try Autonet because in this case there
            // is a DHCP server but somehow we can't work with it.
            TraceSz(Warning, "Couldn't get a valid DHCP address after many tries");
            DhcpChangeState(STATE_NONE);
            _flags = (_flags & ~FLAG_ACTIVE_ADDRMASK) | FLAG_ACTIVE_NOADDR;
        } else {
            // Send out DHCPDISCOVER
            DhcpSendDiscover();
        }
        break;

    case STATE_BOUND:
        DhcpComputeTimeout();
        TraceSz1(dhcp, "Sleep %d seconds till renewal...", _options._t1time - DhcpTime());
        break;

    case STATE_INIT_AUTOADDR:
        DhcpTimerSetAbsolute(0);
        break;

    case STATE_SELECT_AUTOADDR:
        _initRetryCount = 0;
        DhcpSelectAutonetAddr();
        break;

    case STATE_NONE:
    case STATE_STATIC_ADDR:
        DhcpTimerSetAbsolute(DHCPTIME_INFINITE);
        break;
    }
}

void CXnIp::DhcpResetInterface()
{
    ICHECK(IP, UDPC|SDPC);

    IpSetAddress(0, 0);
    _flags &= ~FLAG_ACTIVE_ADDRMASK;
    if (_state != STATE_STATIC_ADDR)
        _activeaddr = 0;
}


NTSTATUS CXnIp::DhcpSendMessage(CPacket * ppkt, UINT msglen, BOOL broadcast)
{
    ICHECK(IP, UDPC|SDPC);

    ppkt->SetCb(ppkt->GetCb() - DEFAULT_DHCP_BUFSIZE + msglen);

    CUdpHdr * pUdpHdr = ppkt->GetUdpHdr();
    DhcpMessage * msg = (DhcpMessage *)(pUdpHdr + 1);

    // Debug trace
    DhcpDumpMessage(msg, msglen);

    // Set broadcast flag if necessary
    if (!_activeaddr || ActiveAutonetAddr())
        msg->_flags |= HTONS(DHCP_BROADCAST);

    pUdpHdr->_ipportSrc = DHCP_CLIENT_PORT;
    pUdpHdr->_ipportDst = DHCP_SERVER_PORT;
    pUdpHdr->_wLen = HTONS(msglen + sizeof(CUdpHdr));

    // Call the IP layer to send out the packet
    IpFillAndXmit(ppkt, broadcast ? IPADDR_BROADCAST : _options._dhcpServer, IPPROTOCOL_UDP);

    // Calculate the timeout value
    _retries++;
    DhcpComputeTimeout();

    return(NETERR_OK);
}

//
// Append the 'parameter request list' option
//  !!! we assume the data buffer is large enough.
//
BYTE * DhcpAppendParamReqList(BYTE * option)
{
    *option++ = DHCPOPT_PARAM_REQUEST_LIST;
    *option++ = 4;
    *option++ = DHCPOPT_SUBNET_MASK;
    *option++ = DHCPOPT_ROUTERS;
    *option++ = DHCPOPT_DNS_SERVERS;
    *option++ = DHCPOPT_DOMAIN_NAME;
    return(option);
}

//
// Append an option whose value is a DWORD
//
BYTE * DhcpAppendDWordOption(BYTE * option, INT tag, DWORD val)
{
    option[0] = (BYTE) tag;
    option[1] = sizeof(DWORD);
    option += 2;

    memcpy(option, &val, sizeof(DWORD));
    return option + sizeof(DWORD);
}


//
// Append the 'address lease time' option
//
BYTE * CXnIp::DhcpAppendLeaseTimeOption(BYTE * option)
{
    ICHECK(IP, UDPC|SDPC);

    DWORD dwLeaseTime = cfgDhcpDefaultLeaseTimeInDays * (24 * 60 * 60);

    if (dwLeaseTime == 0)
        return option;

    return DhcpAppendDWordOption(option, DHCPOPT_IPADDR_LEASE_TIME, HTONL(dwLeaseTime));
}


BYTE * CXnIp::DhcpFillMessageHeader(BYTE * buf, INT msgtype)
{
    ICHECK(IP, UDPC|SDPC);

    DhcpMessage* msg = (DhcpMessage*) buf;
    BYTE* option = msg->_options;
    BYTE hwtype;

    memset(buf, 0, DEFAULT_DHCP_BUFSIZE);
    msg->_op = BOOTREQUEST;
    msg->_htype = hwtype = HWTYPE_10MB_ETHERNET;
    msg->_hlen = sizeof(CEnetAddr);
    memcpy(msg->_chaddr, _ea._ab, sizeof(CEnetAddr));

    //
    // Fill in the transaction ID field
    // NOTE: We reuse the same XID for retransmissions.
    //
    msg->_xid = HTONL(_xid);

    // Number of seconds since we started the address
    // acquisition process.
    msg->_secs = (WORD) HTONS((WORD)_secsSinceStart);

    // Start with the magic cookie
    memcpy(option, DhcpMagicCookie, sizeof(DhcpMagicCookie));
    option += sizeof(DhcpMagicCookie);

    // Append the message type option
    option[0] = DHCPOPT_DHCP_MESSAGE_TYPE;
    option[1] = 1;
    option[2] = (BYTE) msgtype;
    option += 3;

    // Append the client identifier option
    option[0] = DHCPOPT_CLIENTID;
    option[1] = (BYTE) (sizeof(CEnetAddr)+1);
    option[2] = hwtype;
    option += 3;
    memcpy(option, _ea._ab, sizeof(CEnetAddr));
    option += sizeof(CEnetAddr);

    return option;
}


void CXnIp::DhcpComputeSecsSinceStart()
{
    ICHECK(IP, UDPC|SDPC);

    DHCPTIME now = DhcpTime();

    if (_retries == 0)
        _acqtime = now;

    _secsSinceStart = now - _acqtime;
}

//
// Common prolog and epilog for SendDhcpXXX functions
//
#define SEND_DHCP_MESSAGE_PROLOG() \
        DhcpMessage* msg; \
        BYTE* buf; \
        BYTE* option; \
        CPacket * pkt = PacketAlloc(PTAG_CDhcpPacket, PKTF_TYPE_UDP|PKTF_XMIT_INSECURE|PKTF_POOLALLOC, DEFAULT_DHCP_BUFSIZE); \
        if (!pkt) return NETERR_MEMORY; \
        buf = (BYTE *)pkt->GetUdpHdr() + sizeof(CUdpHdr); \
        msg = (DhcpMessage*) buf

#define SEND_DHCP_MESSAGE_RETURN(_bcast) \
        return DhcpSendMessage(pkt, option - buf, _bcast)


NTSTATUS CXnIp::DhcpSendDiscover()
{
    ICHECK(IP, UDPC|SDPC);

    SEND_DHCP_MESSAGE_PROLOG();

    Assert(_state == STATE_INIT);

    DhcpComputeSecsSinceStart();

    // Fill in common header fields
    option = DhcpFillMessageHeader(buf, DHCPDISCOVER);

    // Fill in the parameter request list
    option = DhcpAppendParamReqList(option);

    // Fill in requested ip address and lease time option
    if (_dhcpaddr)
        option = DhcpAppendDWordOption(option, DHCPOPT_REQUESTED_CIpAddr, _dhcpaddr);

    // Fill in the lease time option
    option = DhcpAppendLeaseTimeOption(option);
    *option++ = DHCPOPT_END;

    // Emit the message
    SEND_DHCP_MESSAGE_RETURN(TRUE);
}


NTSTATUS CXnIp::DhcpSendRequest()
{
    ICHECK(IP, UDPC|SDPC);

    INT state = _state;
    SEND_DHCP_MESSAGE_PROLOG();

    Assert(state == STATE_REQUESTING ||
           state == STATE_RENEWING ||
           state == STATE_REBINDING ||
           state == STATE_INIT_REBOOT);

    //
    // If we're in REQUESTING state, then don't update
    // the secsSinceStart field. This is so that the
    // secs in DHCPREQUEST message will be the same as
    // what's in the original DHCPDISCOVER message.
    //
    if (state != STATE_REQUESTING) {
        DhcpComputeSecsSinceStart();
    }

    // Fill in common header fields
    option = DhcpFillMessageHeader(buf, DHCPREQUEST);

    // Fill in the ciaddr field and the 'requested ip addr' option
    if (state == STATE_RENEWING || state == STATE_REBINDING) {
        msg->_ciaddr = _dhcpaddr;
    } else if (_dhcpaddr) {
        // state == STATE_INIT_REBOOT || state == STATE_REQUESTING
        option = DhcpAppendDWordOption(option, DHCPOPT_REQUESTED_CIpAddr, _dhcpaddr);
    }

    // Fill in the parameter request list
    option = DhcpAppendParamReqList(option);

    // Fill in the lease time option
    option = DhcpAppendLeaseTimeOption(option);

    // Fill in the server identifier option
    if (state == STATE_REQUESTING)
        option = DhcpAppendDWordOption(option, DHCPOPT_SERVERID, _options._dhcpServer);

    *option++ = DHCPOPT_END;

    // Emit the message:
    //  unicast in RENEWING state, broadcast otherwise
    SEND_DHCP_MESSAGE_RETURN(state != STATE_RENEWING);
}

BOOL CXnIp::DhcpValidateOffer(CIpAddr yiaddr, CDhcpOptions* param)
{
    ICHECK(IP, UDPC|SDPC);

    if (    !yiaddr.IsValidUnicast()
        ||  !param->_dhcpServer.IsValidUnicast()
        ||  param->_exptime < (DHCPTIME)(8*cfgDhcpRenewMinTimeoutInSeconds))
        return FALSE;

    if (param->_dhcpmask == 0)
        param->_dhcpmask = yiaddr.DefaultMask();

    if (param->_t1time == 0 ||
        param->_t2time == 0 ||
        param->_t1time >= param->_t2time ||
        param->_t2time - param->_t1time < cfgDhcpRenewMinTimeoutInSeconds ||
        param->_t2time >= param->_exptime ||
        param->_exptime - param->_t2time < cfgDhcpRenewMinTimeoutInSeconds) {
        param->_t1time = param->_exptime / 2;
        param->_t2time = param->_exptime * 7 / 8;
    }

    return TRUE;
}


NTSTATUS CXnIp::DhcpProcessOffer(CIpAddr yiaddr, CDhcpOptions* param)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(_state == STATE_INIT);

    TraceSz3(dhcp, "Received DHCPOFFER %s from %s @ time %d", yiaddr.Str(), param->_dhcpServer.Str(), DhcpTime());

    // Simply sanity check of offered parameters
    if (!DhcpValidateOffer(yiaddr, param))
        return(NETERR_PARAM);

    _options._dhcpServer = param->_dhcpServer;
    _dhcpaddr = yiaddr;

    // Send DHCPREQUEST and ignore error
    DhcpChangeState(STATE_REQUESTING);

    return(NETERR_OK);
}


void CXnIp::DhcpAddOrRemoveGateways(BOOL fDelete)
{
    ICHECK(IP, UDPC|SDPC);

    CIpAddr ipa;
    UINT    i;

    for (i = 0; i < _options._gatewayCount; i++)
    {
        ipa = _options._gateways[i];

        TraceSz2(dhcp, "%s gateway: %s", fDelete ? "Remove" : "Add", ipa.Str());

        if (fDelete)
            RouteDelete(0, 0, ipa);
        else
            RouteAdd(0, 0, ipa, RTEF_DEFAULT, (WORD)(RTE_DEFAULT_METRIC + i));
    }
}

void CXnIp::DhcpSetDefaultGateways()
{
    ICHECK(IP, USER|UDPC|SDPC);

    RaiseToDpc();
    DhcpAddOrRemoveGateways(FALSE);
}


void CXnIp::DhcpUseOptionParams(CDhcpOptions* param)
{
    ICHECK(IP, UDPC|SDPC);

    BOOL resetGateways;

    //
    // Remember the originating server address and lease info
    //
    _options._dhcpServer = param->_dhcpServer;

    if (param->_exptime == DHCPTIME_INFINITE) {
        _options._t1time =
        _options._t2time =
        _options._exptime = DHCPTIME_INFINITE;
    } else {
        _options._t1time = _acqtime + param->_t1time;
        _options._t2time = _acqtime + param->_t2time;
        _options._exptime = _acqtime + param->_exptime;
    }

    //
    // Set gateways in the IP stack
    //
    if (param->_gatewayCount == 0 || _options._gatewayCount == 0) {
        resetGateways = TRUE;
    } else {
        UINT oldcnt = _options._gatewayCount;
        UINT newcnt = param->_gatewayCount;
        UINT i, j;

        for (i=0; i < newcnt; i++) {
            for (j=0; j < oldcnt; j++)
                if (param->_gateways[i] != _options._gateways[j]) break;
            if (j < oldcnt) break;
        }
        resetGateways = (i < newcnt);
    }

    if (resetGateways) {
        //
        // Reset gateways if anything has changed
        //  first delete existing gateways
        //  then set new gateways
        //
        // NOTE: should we ping the new gateways here?
        //
        DhcpAddOrRemoveGateways(TRUE);

        _options._gatewayCount = param->_gatewayCount;
        memcpy(_options._gateways,
                param->_gateways,
                param->_gatewayCount * sizeof(CIpAddr));

        DhcpAddOrRemoveGateways(FALSE);
    }

    _options._dnsServerCount = param->_dnsServerCount;
    memcpy(_options._dnsServers,
           param->_dnsServers,
           param->_dnsServerCount * sizeof(CIpAddr));

#if DBG
    UINT i;

    TraceSz2(dhcp, "%d gateway%s configured", _options._gatewayCount, _options._gatewayCount == 1 ? "" : "s");
    for (i = 0; i < _options._gatewayCount; ++i)
        TraceSz1(dhcp, "  %s", _options._gateways[i].Str());
    TraceSz2(dhcp, "%d DNS server%s configured", _options._dnsServerCount, _options._dnsServerCount == 1 ? "" : "s");
    for (i = 0; i < _options._dnsServerCount; ++i)
        TraceSz1(dhcp, "  %s", _options._dnsServers[i].Str());
#endif

}

NTSTATUS CXnIp::DhcpProcessAck(CIpAddr yiaddr, CDhcpOptions* param)
{
    ICHECK(IP, UDPC|SDPC);

    TraceSz2(dhcp, "Received DHCPACK %s from %s", yiaddr.Str(), param->_dhcpServer.Str());

    Assert(_state == STATE_INIT_REBOOT ||
           _state == STATE_REQUESTING ||
           _state == STATE_RENEWING ||
           _state == STATE_REBINDING);

    // Simply sanity check of offered parameters
    if (!DhcpValidateOffer(yiaddr, param))
        return NETERR_PARAM;

    // Note: We're not checking for address conflicts
    // and just assume the offered address is valid.

    // If we're currently using a different address, give it up
    if ((_activeaddr != 0) &&
        (_activeaddr != yiaddr ||
         _activemask != param->_dhcpmask) ||
         ActiveAutonetAddr())
    {
        TraceSz1(dhcp, "Giving up old IP address %s", _activeaddr.Str());
        DhcpResetInterface();
    }

    // If we got a new address, set it down in the IP stack
    if (_activeaddr == 0)
    {
        IpSetAddress(yiaddr, param->_dhcpmask);
        _activeaddr = _dhcpaddr = yiaddr;
        _activemask = _options._dhcpmask = param->_dhcpmask;
        _flags |= FLAG_ACTIVE_DHCPADDR;
    }

    TraceSz2(dhcp, "Accepted IP address: %s from %s", yiaddr.Str(), param->_dhcpServer.Str());
    TraceSz3(dhcp, "Lease time: %d / %d / %d", param->_t1time, param->_t2time, param->_exptime);

    //
    // Set other option parameters
    //
    _initRetryCount = 0;
    DhcpUseOptionParams(param);

    // We're now in bound state.
    // Set timer to expire at T1 time.
    DhcpChangeState(STATE_BOUND);
    return NETERR_OK;
}

NTSTATUS CXnIp::DhcpProcessNak(CIpAddr dhcpServer)
{
    ICHECK(IP, UDPC|SDPC);

    TraceSz1(dhcp, "Received DHCPNAK from %s", dhcpServer.Str());

    Assert(_state == STATE_INIT_REBOOT ||
           _state == STATE_REQUESTING ||
           _state == STATE_RENEWING ||
           _state == STATE_REBINDING);

    // Barf if we got DHCPNAK from an unexpected server
    if (_state != STATE_INIT_REBOOT && dhcpServer != _options._dhcpServer)
    {
        TraceSz1(Warning, "Random DHCPNAK from %s?", dhcpServer.Str());
    }

    // If we're using an address, give it up
    if (_activeaddr) {
        DhcpResetInterface();
    }

    //
    // Go to INIT state to start over again
    // Send DHCPDISCOVER and ignore error
    //
    DhcpChangeState(STATE_INIT);
    return NETERR_OK;
}


// NOTE: we're assuming little-endian machine here.
#define EXTRACT_DWORD_OPTION(_result) \
        if (len != 4) goto exit; \
        if (_result == 0) { \
            _result = (((DWORD) buf[0] << 24) | \
                       ((DWORD) buf[1] << 16) | \
                       ((DWORD) buf[2] <<  8) | \
                       ((DWORD) buf[3]      )); \
        }

#define EXTRACT_IPADDR_OPTION(_result) \
        if (len != 4) goto exit; \
        if (_result == 0) _result = *((CIpAddr*) buf)

NTSTATUS CXnIp::DhcpParseOptionParams(CDhcpOptions* param, const BYTE* buf, UINT buflen, BYTE* overload)
{
    ICHECK(IP, UDPC|SDPC);

    while (buflen) {
        UINT tag, len;

        // Stop after seeing the 'end' option
        if ((tag = buf[0]) == DHCPOPT_END) break;

        // Skip the 'pad' option
        if (tag == DHCPOPT_PAD) {
            buf++; buflen--;
            continue;
        }

        // Is the option length field valid?
        if (buflen < 2 || buflen-2 < (len = buf[1])) goto exit;
        buf += 2; buflen -= 2;
    
        // Interpret option data
        switch (tag) {
        case DHCPOPT_DHCP_MESSAGE_TYPE:
            if (len != 1) goto exit;
            if (param->_recvMsgType == 0)
                param->_recvMsgType = *buf;
            break;

        case DHCPOPT_SERVERID:
            EXTRACT_IPADDR_OPTION(param->_dhcpServer);
            break;

        case DHCPOPT_SUBNET_MASK:
            EXTRACT_IPADDR_OPTION(param->_dhcpmask);
            break;

        case DHCPOPT_ROUTERS:
        case DHCPOPT_DNS_SERVERS:
        {
            UINT* pcount;
            CIpAddr* parray;
            UINT n;

            if (len == 0 || len % sizeof(CIpAddr) != 0) goto exit;
            if (tag == DHCPOPT_ROUTERS)
            {
                pcount = &param->_gatewayCount;
                parray = param->_gateways;
                n = MAX_DEFAULT_GATEWAYS * sizeof(CIpAddr);
            }
            else
            {
                pcount = &param->_dnsServerCount;
                parray = param->_dnsServers;
                n = MAX_DEFAULT_DNSSERVERS * sizeof(CIpAddr);
            }
        
            if (n > len) n = len;
            if (*pcount == 0) {
                *pcount = n / sizeof(CIpAddr);
                memcpy(parray, buf, n);
            }
            break;
        }

        case DHCPOPT_IPADDR_LEASE_TIME:
            EXTRACT_DWORD_OPTION(param->_exptime);
            break;

        case DHCPOPT_T1_INTERVAL:
            EXTRACT_DWORD_OPTION(param->_t1time);
            break;

        case DHCPOPT_T2_INTERVAL:
            EXTRACT_DWORD_OPTION(param->_t2time);
            break;

        case DHCPOPT_FIELD_OVERLOAD:
            if (len != 1) goto exit;
            if (overload && *overload == 0) *overload = *buf;
            break;
        }

        buf += len; buflen -= len;
    }

    return NETERR_OK;

exit:
    TraceSz(Warning, "Invalid option data");
    return NETERR_PARAM;
}

void CXnIp::DhcpSelectAutonetAddr()
{
    ICHECK(IP, UDPC|SDPC);

    CIpAddr addr;

    Assert(_state == STATE_SELECT_AUTOADDR);

    if (++_initRetryCount > cfgAutoIpMaxAttempts) {
        //
        // We tried too many autonet addresses without success.
        // Just give up.
        //
        _initRetryCount = 0;
        DhcpChangeState(STATE_NONE);

        // Signal that Xnet initialization was completed abnormally
        _flags = (_flags & ~FLAG_ACTIVE_ADDRMASK) | FLAG_ACTIVE_NOADDR;
        TraceSz(Warning, "Failed to pick an autonet address.");
        return;
    }

    // Generate a random autonet address
    addr = AUTONET_ADDRBASE + RandScaled(AUTONET_ADDRRANGE);
    _autonetaddr = addr = HTONL(addr);

    TraceSz1(dhcp, "Trying autonet address: %s", addr.Str());

    EnetXmitArp(addr);
    _retries = 0;
    DhcpComputeTimeout();
}

#if DBG

DefineTag(dhcpDump, 0);

//
// Whether to dump incoming and outgoing DHCP messages
//
VOID DhcpDumpByteArray(const BYTE* buf, UINT buflen)

/*++

Routine Description:

    Dump a byte array in hexdecimal format

Arguments:

    buf - Points to the data buffer
    buflen - Buffer length

Return Value:

    NONE

--*/

{
    for ( ; buflen--; buf++) {
        TraceSz1(dhcpDump, "+%02x+", *buf);
    }
}


VOID DhcpDumpOption(IN const BYTE* buf, IN UINT buflen, OUT BYTE* overload)

/*++

Routine Description:

    Dump DHCP options

Arguments:

    buf - Points to the option data buffer
    buflen - Data buffer length
    overload - Returns the option overload flags

Return Value:

    NONE

--*/

{
    static PCSTR dhcpMessageTypeStrs[] = {
        "***",
        "DHCPDISCOVER",
        "DHCPOFFER",
        "DHCPREQUEST",
        "DHCPDECLINE",
        "DHCPACK",
        "DHCPNAK",
        "DHCPRELEASE",
        "DHCPINFORM"
    };

    UINT tag, len, val;

    while (buflen && *buf != DHCPOPT_END) {
        // Special case for DHCPOPT_PAD - single byte
        if (*buf == DHCPOPT_PAD) {
            TraceSz(dhcpDump, "+    PAD");
            buflen--, buf++;
            continue;
        }

        // Check option length
        if (buflen < 2 || buflen-2 < (len = buf[1])) goto badopt;

        switch (tag = buf[0]) {
        case DHCPOPT_DHCP_MESSAGE_TYPE:
            if (len != 1) goto badopt;
            val = buf[2];
            if (val > 0 && val < dimensionof(dhcpMessageTypeStrs)) {
                TraceSz1(dhcpDump, "+    %s+", dhcpMessageTypeStrs[val]);
            } else {
                TraceSz1(dhcpDump, "+    Unknown DHCP message type: %d+", val);
            }
            break;

        case DHCPOPT_FIELD_OVERLOAD:
            if (len != 1) goto badopt;
            TraceSz1(dhcpDump, "+    OVERLOAD: %d+", buf[2]);
            if (overload)
                *overload = buf[2];
            else
                TraceSz(dhcpDump, "+ !!!+");
            break;

        case DHCPOPT_REQUESTED_CIpAddr:
        case DHCPOPT_SERVERID:
            if (len != 4) goto badopt;
            TraceSz5(dhcpDump, "+    %s %d.%d.%d.%d+",
                     (tag == DHCPOPT_SERVERID) ? "SERVERID" : "REQUEST IP ADDR",
                     buf[2], buf[3], buf[4], buf[5]);
            break;

        default:
            TraceSz1(dhcpDump, "+    %d - +", tag);
            DhcpDumpByteArray(buf+2, len);
            break;
        }

        TraceSz(dhcpDump, "+ ");
        buf += len+2;
        buflen -= len+2;
    }

    if (buflen == 0) {
        TraceSz(dhcpDump, "!!! Missing 'end' option");
    } else {
        do {
            buflen--, buf++;
        } while (buflen && *buf == 0);

        if (buflen != 0)
        {
            TraceSz(dhcpDump, "!!! Extra data after 'end' option");
        }
    }
    return;

badopt:
    TraceSz(dhcpDump, "!!! Bad DHCP option data");
}


void DhcpDumpMessage(DhcpMessage* msg, UINT msglen)

/*++

Routine Description:

    Dump the content of a DHCP message

Arguments:

    msg - Points to the DHCP message
    msglen - Message length

Return Value:

    NONE

--*/

{
    const BYTE* option;
    BYTE overload = 0;

    if (!Tag(dhcpDump))
        return;

    //
    // Sanity check
    //
    if (msglen < DHCPHDRLEN) {
        TraceSz1(dhcpDump, "!!! DHCP message too small: %d bytes", msglen);
        return;
    }

    //
    // Dump out fixed header information
    //
    TraceSz(dhcpDump, "DHCP message: ");
    if (msg->_op == BOOTREQUEST)
        TraceSz(dhcpDump, "BOOTREQUEST");
    else if (msg->_op == BOOTREPLY)
        TraceSz(dhcpDump, "BOOTREPLY");
    else
        TraceSz1(dhcpDump, "%d", msg->_op);

    TraceSz1(dhcpDump, "  htype: %d", msg->_htype);
    if (msg->_hlen > sizeof(msg->_chaddr)) {
        TraceSz1(dhcpDump, "!!! Invalid hardware address length: %d\n", msg->_hlen);
    } else if (msg->_hlen) {
        TraceSz(dhcpDump, "  chaddr: +");
        DhcpDumpByteArray(msg->_chaddr, msg->_hlen);
        TraceSz(dhcpDump, "+ ");
    }

    TraceSz1(dhcpDump, "  hops: %d", msg->_hops);
    TraceSz1(dhcpDump, "  xid: 0x%08x", NTOHL(msg->_xid));
    TraceSz1(dhcpDump, "  secs: %d", NTOHS(msg->_secs));
    TraceSz1(dhcpDump, "  flags: 0x%04x", NTOHS(msg->_flags));
    TraceSz1(dhcpDump, "  ciaddr: %s", msg->_ciaddr.Str());
    TraceSz1(dhcpDump, "  yiaddr: %s", msg->_yiaddr.Str());
    TraceSz1(dhcpDump, "  siaddr: %s", msg->_siaddr.Str());
    TraceSz1(dhcpDump, "  giaddr: %s", msg->_giaddr.Str());

    //
    // Dump options
    //
    option = msg->_options;
    msglen -= DHCPHDRLEN;

    if (msglen < sizeof(DhcpMagicCookie) ||
        memcmp(option, DhcpMagicCookie, sizeof(DhcpMagicCookie)) != 0) {
        TraceSz(dhcpDump, "!!! Invalid DHCP magic cookie");
        return;
    }
    msglen -= sizeof(DhcpMagicCookie);
    option += sizeof(DhcpMagicCookie);

    TraceSz(dhcpDump, "  options:");
    DhcpDumpOption(option, msglen, &overload);

    if (overload & 1) {
        TraceSz(dhcpDump, "  overload options (file):");
        DhcpDumpOption(msg->_file, sizeof(msg->_file), NULL);
    }

    if (overload & 2) {
        TraceSz(dhcpDump, "  overload options (sname):");
        DhcpDumpOption(msg->_sname, sizeof(msg->_sname), NULL);
    }
}

#endif // DBG

void CXnIp::IpRecvArp(CEnetAddr * pea)
{
    ICHECK(IP, UDPC|SDPC);
    DhcpNotifyAddressConflict();
}

#endif // XNET_FEATURE_DHCP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\nicw.h ===
// ----------------------------------------------------------------------------
// nicw.h
//
// Software implementation of a NIC for simulating an Ethernet network
//
// Copyright (C) Microsoft Corporation
// ----------------------------------------------------------------------------

#ifndef __NICW_H__
#define __NICW_H__

// ---------------------------------------------------------------------------------------
// CXnNic
// ---------------------------------------------------------------------------------------

class NOVTABLE CXnNic : public CXnBase
{
    friend void WINAPI VLanRecv(BYTE *, UINT, void *);

    // Definitions -----------------------------------------------------------------------

    struct RecvDesc
    {
        DWORD       cbDat;
        BYTE        rgbBuf[ENET_LINK_MAXSIZE + ENET_DATA_MAXSIZE];
    };

    // External --------------------------------------------------------------------------

public:

    HAL_DECLARE_NEW_DELETE(CXnNic)

    BOOL            NicXmitReady();
    void            NicXmit(CPacket * ppkt);
    VIRTUAL void    NicTimer() {}

protected:

    NTSTATUS        NicInit(XNetInitParams * pxnip);
    INT             NicConfig(const XNetConfigParams * pxncp);
    void            NicStart();
    void            NicFlush();
    void            NicStop();
    void            NicTerm();

    VIRTUAL void    NicRecvFrame(void * pv, DWORD cbData);

    VIRTUAL void    EnetRecv(CPacket * ppkt, UINT uiType) VPURE;
    VIRTUAL void    EnetPush() VPURE;

    // Internal --------------------------------------------------------------------------

private:

    RecvDesc *      NextPrd(RecvDesc * prd);
    void            XmitPush();
    void            RecvPush();
    void            SetInterrupts(BOOL fEnable);
    static void     DpcCallback(struct _KDPC *, void * pthis, void *, void *);

    INT             NicVLanAttach();
    void            NicVLanDetach(BOOL fTerm);

    // Data ------------------------------------------------------------------------------

protected:

    CEnetAddr       _ea;

private:

    LIST_ENTRY      _le;
    KDPC            _dpcRecv;
    BOOL            _fIntr;
    BOOL            _fXmitFull;
    LONG            _cxdBusy;
    LONG            _cxdPool;
    CPacketQueue    _pqXmit;
    LONG            _crdBusy;
    LONG            _crdPool;
    RecvDesc *      _prdFirst;
    RecvDesc *      _prdRead;
    RecvDesc *      _prdWrite;
    RecvDesc *      _prdLast;
    BOOL            _fVLanInit;
    BOOL            _fVLanAttach;

};

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\nicw.cpp ===
// ----------------------------------------------------------------------------
// nicw.cpp
//
// Copyright (C) Microsoft Corporation
// ----------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

#ifdef XNET_FEATURE_WINDOWS

#include <vlan.h>

// ----------------------------------------------------------------------------
// CXnNic - External
// ----------------------------------------------------------------------------

NTSTATUS CXnNic::NicInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    NTSTATUS status = BaseInit(pxnip);
    if (!NT_SUCCESS(status))
        return(status);

    SetInitFlag(INITF_NIC_1);

    RecvDesc *  prd;
    BYTE *      pb;
    LONG        cb;

    prd = (RecvDesc *)SysAllocZ(cfgEnetReceiveQueueLength * sizeof(RecvDesc), PTAG_CXnNic);

    if (prd == NULL)
    {
        TraceSz(Warning, "NicInit: Unable to allocate memory");
        return(NETERR_MEMORY);
    }

    KeInitializeDpc(&_dpcRecv, DpcCallback, this);

    _cxdPool   = cfgEnetTransmitQueueLength;
    _crdPool   = cfgEnetReceiveQueueLength;
    _prdFirst  = prd;
    _prdRead   = prd;
    _prdWrite  = prd;
    _prdLast   = prd + cfgEnetReceiveQueueLength - 1;

    SetInitFlag(INITF_NIC|INITF_CONNECTED_BOOT);

    return(NETERR_OK);
}

INT CXnNic::NicVLanAttach()
{
    if (!_fVLanInit)
    {
        if (!VLanInit())
        {
            TraceSz(Warning, "NicVLanAttach: VLanInit failed");
            return(WSASYSCALLFAILURE);
        }

        _fVLanInit = TRUE;
    }

    Assert(!_fVLanAttach);

    if (!VLanAttach(_achXbox, _ea._ab, this))
    {
        TraceSz1(Warning, "NicVLanAttach: VLanAttach '%s' failed", _achXbox);
        return(WSASYSCALLFAILURE);
    }

    _fVLanAttach = TRUE;

    return(0);
}

void CXnNic::NicVLanDetach(BOOL fTerm)
{
    if (_fVLanAttach)
    {
        VLanDetach(_ea._ab);
        _fVLanAttach = FALSE;
    }

    if (fTerm && _fVLanInit)
    {
        VLanTerm();
        _fVLanInit = FALSE;
    }
}

INT CXnNic::NicConfig(const XNetConfigParams * pxncp)
{
    return(NicVLanAttach());
}

void CXnNic::NicStart()
{
    ICHECK(NIC, USER);

    BaseStart();

    Assert(!TestInitFlag(INITF_NIC_STOP));

    SetInterrupts(TRUE);
}

void CXnNic::NicFlush()
{
    if (!TestInitFlag(INITF_NIC) || TestInitFlag(INITF_NIC_STOP))
        return;

    // Wait up to half a second for packets queued for transmit to go

    EnetPush();

    for (UINT cTimeout = 500; cTimeout > 0; --cTimeout)
    {
        XmitPush();

        if (_pqXmit.IsEmpty())
            break;

        Sleep(1);
    }
}

void CXnNic::NicStop()
{
    TCHECK(UDPC);

    if (TestInitFlag(INITF_NIC) && !TestInitFlag(INITF_NIC_STOP))
    {
        SetInterrupts(FALSE);
        KeLowerIrql(PASSIVE_LEVEL);
        NicVLanDetach(FALSE);
        KeRaiseIrqlToDpcLevel();
        SetInitFlag(INITF_NIC_STOP);
    }

    BaseStop();
}

void CXnNic::NicTerm()
{
    TCHECK(UDPC);

    NicStop();

    SetInitFlag(INITF_NIC_TERM);

    NicVLanDetach(TRUE);

    if (TestInitFlag(INITF_NIC_1))
    {
        Assert(_dpcRecv.DpcListEntry.Flink == NULL);

        while (_cxdBusy > 0)
        {
            Assert((UINT)_pqXmit.Count() == (UINT)_cxdBusy);
            TraceSz1(Warning, "Nic shutdown with %d packet(s) queued for transmit", _cxdBusy);
            _pqXmit.Discard(this);
        }

        if (_prdFirst)
        {
            SysFree(_prdFirst);
        }
    }

    BaseTerm();
}

BOOL CXnNic::NicXmitReady()
{
    ICHECK(NIC, UDPC|SDPC);

    BOOL fReady = (_cxdBusy < _cxdPool);

    if (!fReady)
    {
        _fXmitFull = TRUE;
    }

    return(fReady);
}

void CXnNic::NicXmit(CPacket * ppkt)
{
    ICHECK(NIC, UDPC|SDPC);

    Assert(_cxdBusy < _cxdPool);
    Assert(ppkt->GetCb() <= ENET_DATA_MAXSIZE);

    _pqXmit.InsertTail(ppkt);
    _cxdBusy += 1;

    XmitPush();
}

// ---------------------------------------------------------------------------------------
// CXnNic - Internal
// ---------------------------------------------------------------------------------------

void CXnNic::XmitPush()
{
    ICHECK(NIC, UDPC|SDPC);

    if (!_fIntr)
    {
        TraceSz(Warning, "CXnNic::XmitPush - Interrupts are disabled");
        return;
    }

    while (_cxdBusy > 0)
    {
        CPacket * ppkt = _pqXmit.GetHead();

        if (!VLanXmit((BYTE *)ppkt->GetEnetHdr(), sizeof(CEnetHdr) + ppkt->GetCb()))
        {
            TraceSz(Warning, "CXnNic::XmitPush - VLanXmit failed");
        }

        _pqXmit.RemoveHead();
        _cxdBusy -= 1;
        ppkt->Complete(this);
    }

    if (_fXmitFull && _cxdBusy < _cxdPool)
    {
        _fXmitFull = FALSE;
        EnetPush();
    }
}

void CXnNic::NicRecvFrame(void * pv, DWORD cbDat)
{
    ICHECK(NIC, USER|UDPC|SDPC);

    Assert(cbDat >= sizeof(CEnetHdr));
    Assert(cbDat <= sizeof(CEnetHdr) + ENET_DATA_MAXSIZE);

    if (_crdBusy == _crdPool)
    {
        TraceSz(Warning, "CXnNic::NicRecvFrame - Receive queue is full");
    }
    else if (cbDat <  sizeof(CEnetHdr) || cbDat > sizeof(CIeeeHdr) + ENET_DATA_MAXSIZE)
    {
        TraceSz1(Warning, "CXnNic::NicRecvFrame - Invalid frame size (%ld bytes)", cbDat);
    }
    else
    {
        HalEnterDpc();

        if (_fIntr)
        {
            RecvDesc * prd = _prdWrite;
            _prdWrite = NextPrd(prd);
            prd->cbDat = cbDat;
            memcpy(prd->rgbBuf, pv, cbDat);
            _crdBusy += 1;

            KeInsertQueueDpc(&_dpcRecv, NULL, NULL);
        }

        HalLeaveDpc();
    }
}

void CXnNic::RecvPush()
{
    ICHECK(NIC, UDPC|SDPC);

    if (!_fIntr)
    {
        TraceSz(Warning, "CXnNic::RecvPush - Interrupts are disabled");
        return;
    }

    while (_crdBusy > 0)
    {
        CPacket     pkt;
        RecvDesc *  prd      = _prdRead;
        void *      pv       = prd->rgbBuf;
        UINT        cb       = prd->cbDat;
        CEnetHdr *  pEnetHdr = (CEnetHdr *)pv;
        UINT        uiFlags  = PKTF_TYPE_ENET;
        UINT        uiType   = pEnetHdr->_wType;

        PushPktRecvTags(pEnetHdr->_eaDst.IsBroadcast());

        if (NTOHS((WORD)uiType) <= ENET_DATA_MAXSIZE)
        {
            CIeeeHdr * pIeeeHdr = (CIeeeHdr *)pEnetHdr;
            BYTE abEnetHdr[sizeof(CEnetAddr) * 2];

            if (!pIeeeHdr->IsEnetFrame())
            {
                TraceSz(pktRecv, "[DISCARD] IEEE frame type not supported");
                goto nextframe;
            }

            // Convert the link header into a standard CEnetHdr

            uiType = pIeeeHdr->_wTypeIeee;
            pv     = (BYTE *)pv + (sizeof(CIeeeHdr) - sizeof(CEnetHdr));
            cb    -= (sizeof(CIeeeHdr) - sizeof(CEnetHdr));

            memcpy(abEnetHdr, pIeeeHdr, sizeof(abEnetHdr));
            memcpy(pv, abEnetHdr, sizeof(abEnetHdr));

            pEnetHdr = (CEnetHdr *)pv;
            pEnetHdr->_wType = (WORD)uiType;
        }

        pv  = (BYTE *)pv + sizeof(CEnetHdr);
        cb -= sizeof(CEnetHdr);

        TraceSz4(pktRecv, "[ENET %s %s %04X][%d]",
                 pEnetHdr->_eaDst.Str(), pEnetHdr->_eaSrc.Str(), NTOHS((WORD)uiType), cb);

        if (pEnetHdr->_eaDst.IsBroadcast())
        {
            uiFlags |= PKTF_RECV_BROADCAST;
        }
        else if (!pEnetHdr->_eaDst.IsEqual(_ea))
        {
            TraceSz(pktWarn, "[DISCARD] Frame should not have been accepted by Nic hardware");
            goto nextframe;
        }

#ifdef XNET_FEATURE_VMEM
        if (VMemIsEnabled())
        {
            void * pvNew = VMemAlloc(cb + sizeof(CEnetHdr));
            Assert(pvNew != NULL);
            memcpy(pvNew, (BYTE *)pv - sizeof(CEnetHdr), cb + sizeof(CEnetHdr));
            pv = (BYTE *)pvNew + sizeof(CEnetHdr);
        }
#endif

        pkt.Init(uiFlags, pv, cb, NULL);
        EnetRecv(&pkt, uiType);

#ifdef XNET_FEATURE_VMEM

        if (VMemIsEnabled())
        {
            VMemFree((BYTE *)pv - sizeof(CEnetHdr));
        }

#endif

    nextframe:
        
        _prdRead  = NextPrd(prd);
        _crdBusy -= 1;

        PopPktRecvTags();
    }
}

void CXnNic::DpcCallback(PRKDPC, void * pthis, void *, void *)
{
    ((CXnNic *)pthis)->RecvPush();
}

void CXnNic::SetInterrupts(BOOL fEnable)
{
    ICHECK(NIC, USER|UDPC|SDPC);

    RaiseToDpc();

    if (!!fEnable != !!_fIntr)
    {
        _fIntr = fEnable;

        if (fEnable)
        {   
            if (_crdBusy > 0)
            {
                KeInsertQueueDpc(&_dpcRecv, NULL, NULL);
            }
        }
        else
        {
            KeRemoveQueueDpc(&_dpcRecv);
        }
    }
}

CXnNic::RecvDesc * CXnNic::NextPrd(RecvDesc * prd)
{
    TCHECK(USER|UDPC|SDPC);
    return((prd == _prdLast) ? _prdFirst : prd + 1);
}

// ---------------------------------------------------------------------------------------
// VLanRecv
// ---------------------------------------------------------------------------------------

void WINAPI VLanRecv(BYTE * pb, UINT cb, void * pvArg)
{
    ((CXnNic *)pvArg)->NicRecvFrame(pb, cb);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\ipicmp.cpp ===
// ---------------------------------------------------------------------------------------
// ipicmp.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// CIcmpHdr
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ICMP

#include <pshpack1.h>

class CIcmpHdr
{

    // Definitions -----------------------------------------------------------------------

    #define ICMPTYPE_ECHO_REPLY                 0
    #define ICMPTYPE_DESTINATION_UNREACHABLE    3
    #define   ICMPCODE_NET_UNREACHABLE          0
    #define   ICMPCODE_HOST_UNREACHABLE         1
    #define   ICMPCODE_PROTOCOL_UNREACHABLE     2
    #define   ICMPCODE_PORT_UNREACHABLE         3
    #define   ICMPCODE_CANT_FRAGMENT_WITH_DF    4
    #define   ICMPCODE_SRCROUTE_FAILED          5
    #define   ICMPCODE_DEST_NET_UNKNOWN         6
    #define   ICMPCODE_DEST_HOST_UNKNOWN        7
    #define   ICMPCODE_SRC_HOST_ISOLATED        8
    #define   ICMPCODE_DEST_NET_PROHIBITED      9
    #define   ICMPCODE_DEST_HOST_PROHIBITED     10
    #define   ICMPCODE_NET_UNREACHABLE_TOS      11
    #define   ICMPCODE_HOST_UNREACHABLE_TOS     12
    #define ICMPTYPE_SOURCE_QUENCH              4
    #define ICMPTYPE_REDIRECT                   5
    #define   ICMPCODE_REDIRECT_NET             0
    #define   ICMPCODE_REDIRECT_HOST            1
    #define   ICMPCODE_REDIRECT_NET_TOS         2
    #define   ICMPCODE_REDIRECT_HOST_TOS        3
    #define ICMPTYPE_ECHO_REQUEST               8
    #define ICMPTYPE_ROUTER_ADVERTISEMENT       9
    #define ICMPTYPE_ROUTER_SOLICIATION         10
    #define ICMPTYPE_TIME_EXCEEDED              11
    #define   ICMPCODE_TTL_EXCEEDED             0
    #define   ICMPCODE_REASSEMBLY_TIMEOUT       1
    #define ICMPTYPE_PARAMETER_PROBLEM          12
    #define   ICMPCODE_PTR_INDICATES_ERROR      0
    #define   ICMPCODE_MISSING_REQD_OPTION      1
    #define ICMPTYPE_TIMESTAMP_REQUEST          13
    #define ICMPTYPE_TIMESTAMP_REPLY            14
    #define ICMPTYPE_INFORMATION_REQUEST        15
    #define ICMPTYPE_INFORMATION_REPLY          16
    #define ICMPTYPE_ADDRESSMASK_REQUEST        17
    #define ICMPTYPE_ADDRESSMASK_REPLY          18

    // Trace Support ---------------------------------------------------------------------

public:

    char * Str()
    {
        switch (_bType)
        {
            case ICMPTYPE_ECHO_REPLY:
                return("Echo Reply");
                break;
            case ICMPTYPE_DESTINATION_UNREACHABLE:
            {
                switch (_bCode)
                {
                    case ICMPCODE_NET_UNREACHABLE:
                        return("Net Unreachable");
                    case ICMPCODE_HOST_UNREACHABLE:
                        return("Host Unreachable");
                    case ICMPCODE_PROTOCOL_UNREACHABLE:
                        return("Protocol Unreachable");
                    case ICMPCODE_PORT_UNREACHABLE:
                        return("Port Unreachable");
                    case ICMPCODE_CANT_FRAGMENT_WITH_DF:
                        return("Can't Fragment With DF");
                    case ICMPCODE_SRCROUTE_FAILED:
                        return("Source Route Failed");
                    case ICMPCODE_DEST_NET_UNKNOWN:
                        return("Destination Net Unknown");
                    case ICMPCODE_DEST_HOST_UNKNOWN:
                        return("Destination Host Unknown");
                    case ICMPCODE_SRC_HOST_ISOLATED:
                        return("Source Host Isolated");
                    case ICMPCODE_DEST_NET_PROHIBITED:
                        return("Destination Net Prohibited");
                    case ICMPCODE_NET_UNREACHABLE_TOS:
                        return("Network Unreachable For Tos");
                    case ICMPCODE_HOST_UNREACHABLE_TOS:
                        return("Host Unreachable For Tos");
                    default:
                        return("Destination Unreachable");
                }
            }
            case ICMPTYPE_SOURCE_QUENCH:
                return("Source Quench");
                break;
            case ICMPTYPE_REDIRECT:
            {
                switch (_bCode)
                {
                    case ICMPCODE_REDIRECT_NET:
                        return("Redirect Datagrams For Net");
                    case ICMPCODE_REDIRECT_HOST:
                        return("Redirect Datagrams For Host");
                    case ICMPCODE_REDIRECT_NET_TOS:
                        return("Redirect Datagrams For Net And Tos");
                    case ICMPCODE_REDIRECT_HOST_TOS:
                        return("Redirect Datagrams For Host And Tos");
                    default:
                        return("Redirect");
                }
            }
            case ICMPTYPE_ECHO_REQUEST:
                return("Echo Request");
                break;
            case ICMPTYPE_ROUTER_ADVERTISEMENT:
                return("Router Advertisement");
                break;
            case ICMPTYPE_TIME_EXCEEDED:
            {
                switch (_bCode)
                {
                    case ICMPCODE_TTL_EXCEEDED:
                        return("Ttl Exceeded");
                    case ICMPCODE_REASSEMBLY_TIMEOUT:
                        return("Reassembly Timeout");
                    default:
                        return("Time Exceeded");
                }
            }
            case ICMPTYPE_PARAMETER_PROBLEM:
            {
                switch (_bCode)
                {
                    case ICMPCODE_MISSING_REQD_OPTION:
                        return("Missing Required Option");
                    default:
                        return("Parameter Problem");
                }
            }
            case ICMPTYPE_TIMESTAMP_REQUEST:
                return("Timestamp Request");
            case ICMPTYPE_TIMESTAMP_REPLY:
                return("Timestamp Reply");
            case ICMPTYPE_INFORMATION_REQUEST:
                return("Information Request");
            case ICMPTYPE_INFORMATION_REPLY:
                return("Information Reply");
            case ICMPTYPE_ADDRESSMASK_REQUEST:
                return("Address Mask Request");
            case ICMPTYPE_ADDRESSMASK_REPLY:
                return("Address Mask Reply");
            default:
                return("Unknown");
        }
    }

    // Data ------------------------------------------------------------------------------

public:

    BYTE            _bType;         // One of ICMPTYPE_* above
    BYTE            _bCode;         // One of ICMPCODE_* above
    WORD            _wChecksum;     // Checksum
    DWORD           _dwData;        // Data (depends on _bType)

};

#include <poppack.h>

// ---------------------------------------------------------------------------------------
// CXnIp::IcmpRecv
// ---------------------------------------------------------------------------------------

void CXnIp::IcmpRecv(CPacket* ppkt, CIpHdr * pIpHdr, void * pvData, UINT cbData)
{
    ICHECK(IP, UDPC|SDPC);

    if (cbData < sizeof(CIcmpHdr))
    {
        TraceSz1(pktWarn, "[DISCARD] ICMP header doesn't fit in the packet (%d bytes)", cbData);
        return;
    }

    if (tcpipxsum(0, pvData, cbData) != 0xFFFF)
    {
        TraceSz(pktWarn, "[DISCARD] ICMP header checksum failed");
        return;
    }

    CIcmpHdr * pIcmpHdr = (CIcmpHdr *)pvData;

    TraceSz4(pktRecv, "[ICMP <%d/%d> %s][cb=%d]",
             pIcmpHdr->_bType, pIcmpHdr->_bCode, pIcmpHdr->Str(),
             cbData - sizeof(CIcmpHdr));

    if (ppkt->TestFlags(PKTF_RECV_BROADCAST|PKTF_RECV_LOOPBACK))
    {
        TraceSz1(pktWarn, "[DISCARD] ICMP packet received via %s",
                 ppkt->TestFlags(PKTF_RECV_BROADCAST) ? "broadcast" : "loopback");
        return;
    }

#ifdef XNET_FEATURE_ROUTE

    if (    pIcmpHdr->_bType == ICMPTYPE_REDIRECT
        &&  (   pIcmpHdr->_bCode == ICMPCODE_REDIRECT_NET
             || pIcmpHdr->_bCode == ICMPCODE_REDIRECT_HOST
             || pIcmpHdr->_bCode == ICMPCODE_REDIRECT_NET_TOS
             || pIcmpHdr->_bCode == ICMPCODE_REDIRECT_HOST_TOS))
    {
        pvData  = (BYTE *)pvData + sizeof(CIcmpHdr);
        cbData -= sizeof(CIcmpHdr);

        if (cbData < sizeof(CIpHdr))
        {
            TraceSz(pktWarn, "[DISCARD] ICMP embedded IP header doesn't fit in the packet");
            return;
        }

        CIpHdr * pIpHdrIcmp = (CIpHdr *)pvData;
        UINT cbIpHdrIcmp = pIpHdrIcmp->VerifyHdrLen();

        if (cbIpHdrIcmp == 0)
        {
            TraceSz(pktWarn, "[DISCARD] ICMP embedded IP header version is incorrect");
            return;
        }

        if (cbData < (cbIpHdrIcmp + 8))
        {
            TraceSz(pktWarn, "[DISCARD] ICMP embedded IP header and 64-bits of data doesn't fit in the packet");
            return;
        }

        // The embedded IP header is supposed to have originated from this host, and
        // we would never have added IP options, so we can check that here.

        if (cbIpHdrIcmp != sizeof(CIpHdr))
        {
            TraceSz(pktWarn, "[DISCARD] ICMP embedded IP header has options");
            return;
        }

        TraceSz3(pktRecv, "[REDIRECT] Rerouting %s from gateway %s to gateway %s",
                 pIpHdrIcmp->_ipaDst.Str(), pIpHdr->_ipaSrc.Str(), CIpAddr(pIcmpHdr->_dwData).Str());

        RouteRedirect(pIpHdrIcmp->_ipaDst, pIpHdr->_ipaSrc, CIpAddr(pIcmpHdr->_dwData));
        return;
    }

#endif

    if (pIcmpHdr->_bType == ICMPTYPE_ECHO_REQUEST)
    {
        if (!pIpHdr->_ipaSrc.IsValidUnicast())
        {
            TraceSz1(pktWarn, "[DISCARD] ICMP echo from bad source address %s",
                     pIpHdr->_ipaSrc.Str());
            return;
        }

        if (pIpHdr->GetOptLen() > 0)
        {
            TraceSz(pktWarn, "[DISCARD] ICMP echo packet with IP header options");
            return;
        }

        // Don't allow Ping'er to make us consume gratuitous amounts of pool memory

        if (cbData > sizeof(CIcmpHdr) + 64)
        {
            TraceSz1(pktWarn, "[DISCARD] ICMP echo request with too much optional data (%d)",
                     cbData - sizeof(CIcmpHdr));
            return;
        }

        CPacket * ppktReply = PacketAlloc(PTAG_CIcmpEchoPacket,
                                          PKTF_TYPE_IP|PKTF_XMIT_INSECURE|PKTF_POOLALLOC,
                                          cbData);

        if (ppktReply == NULL)
        {
            TraceSz(pktWarn, "[DISCARD] Out of memory allocating ICMP echo reply packet");
            return;
        }

        CIpHdr * pIpHdrReply = ppktReply->GetIpHdr();

        memcpy(pIpHdrReply, pIpHdr, sizeof(CIpHdr) + cbData);

        CIcmpHdr * pIcmpHdrReply = (CIcmpHdr *)(pIpHdrReply + 1);

        pIcmpHdrReply->_bType     = ICMPTYPE_ECHO_REPLY;
        pIcmpHdrReply->_wChecksum = 0;
        pIcmpHdrReply->_wChecksum = (WORD)~tcpipxsum(0, pIcmpHdrReply, cbData);

        TraceSz(pktRecv, "[REPLY] Replying to ICMP echo request");

        IpFillAndXmit(ppktReply, pIpHdr->_ipaSrc, IPPROTOCOL_ICMP);
        return;
    }

    TraceSz3(pktWarn, "[DISCARD] No support ICMP <%d/%d> %s",
             pIcmpHdr->_bType, pIcmpHdr->_bCode, pIcmpHdr->Str());
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\ipdns.cpp ===
// ---------------------------------------------------------------------------------------
// ipdns.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(dns, 0);
DefineTag(dnsWarn, TAG_ENABLE);
DefineTag(dnsDump, 0);

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_DNS

struct CDnsName
{
    // Definitions -----------------------------------------------------------------------

    #define DNSMAXLABEL     63

    // External --------------------------------------------------------------------------

    INLINE          CDnsName() { _ab[0] = 0; }
    BOOL            InitFromString(const char * psz);
    BYTE *          InitFromLabels(BYTE * pbSrcBeg, BYTE * pbSrcEnd, BYTE * pbLabBeg);
    void            GenerateString(char * psz, UINT cb);
    BOOL            IsEqual(CDnsName * pdnsname);
    UINT            GetSize();

#if DBG
    char *          Str();
#endif

    // Data ------------------------------------------------------------------------------

    BYTE            _ab[255];           // Buffer of octet-prefixed labels
};

struct CDnsReg
{
    // Definitions -----------------------------------------------------------------------

    // External --------------------------------------------------------------------------

    INLINE CDnsReg() {}

    // Data ------------------------------------------------------------------------------

    CDnsReg *       _pdnsregNext;       // Next CDnsReg in linked list
    CTimer          _timer;             // Timer for scheduling timouts
    CDnsName *      _pdnsname;          // Parsed DNS name of host
    BYTE            _bRetry;            // Retry count
    BYTE            _fPending;          // TRUE while request in progress
    WORD            _wId;               // DNS message unique identifier
    PRKEVENT        _pEvent;            // Event reference (may be NULL)
    XNDNS           _xndns;             // XNDNS structure returned to client
};

struct CDnsHdr
{
    // Definitions -----------------------------------------------------------------------

    #define DNSF_RESPONSE       BIT(15) // 1 if response; 0 if query
    #define DNSF_QOP_MASK       0x7800  // 4 bits of query opcode
    #define DNSF_QOP_SQRY       0x0000  // Standard query opcode
    #define DNSF_QOP_IQRY       0x0800  // Inverse query opcode
    #define DNSF_QOP_STAT       0x1000  // Server status request
    #define DNSF_AA             BIT(10) // Authoritative answer
    #define DNSF_TC             BIT(9)  // Truncation
    #define DNSF_RD             BIT(8)  // Recursion desired
    #define DNSF_RA             BIT(7)  // Recursion available
    #define DNSF_ROP_MASK       0x000F  // 4 bits of response opcode
    #define DNSF_ROP_OK         0x0000  // No error response code
    #define DNSF_ROP_FMTERR     0x0001  // Format error response code
    #define DNSF_ROP_SRVFAIL    0x0002  // Server failure response code
    #define DNSF_ROP_NAMEERR    0x0003  // Name error response code
    #define DNSF_ROP_NOTIMPL    0x0004  // Not implemented response code
    #define DNSF_ROP_REFUSED    0x0005  // Refused response code

    #define DNSRT_A             1       // a host address
    #define DNSRT_NS            2       // an authoritative name server
    #define DNSRT_MD            3       // a mail destination (Obsolete - use MX)
    #define DNSRT_MF            4       // a mail forwarder (Obsolete - use MX)
    #define DNSRT_CNAME         5       // the canonical name for an alias
    #define DNSRT_SOA           6       // marks the start of a zone of authority
    #define DNSRT_MB            7       // a mailbox domain name (EXPERIMENTAL)
    #define DNSRT_MG            8       // a mail group member (EXPERIMENTAL)
    #define DNSRT_MR            9       // a mail rename domain name (EXPERIMENTAL)
    #define DNSRT_NULL          10      // a null RR (EXPERIMENTAL)
    #define DNSRT_WKS           11      // a well known service description
    #define DNSRT_PTR           12      // a domain name pointer
    #define DNSRT_HINFO         13      // host information
    #define DNSRT_MINFO         14      // mailbox or mail list information
    #define DNSRT_MX            15      // mail exchange
    #define DNSRT_TXT           16      // text strings

    #define DNSQT_AXFR          252     // a transfer of an entire zone
    #define DNSQT_MAILB         253     // mailbox-related records (MB, MG or MR)
    #define DNSQT_MAILA         254     // mail agent RRs (Obsolete - see MX)
    #define DNSQT_ALL           255     // all records

    #define DNSRC_IN            1       // the Internet
    #define DNSRC_CS            2       // the CSNET class (Obsolete)
    #define DNSRC_CH            3       // the CHAOS class
    #define DNSRC_HS            4       // the Hesiod class
    #define DNSRC_ANY           255     // any class

    // External --------------------------------------------------------------------------

    INLINE CDnsHdr() {}

    // Data ------------------------------------------------------------------------------

    WORD            _wId;               // DNS message unique identifier
    WORD            _wFlags;            // See DNSF_* above
    WORD            _cQd;               // Number of entries in questions section
    WORD            _cAn;               // Number of entries in answers section
    WORD            _cNs;               // Number of entries in authority section
    WORD            _cAr;               // Number of entries in additional section
    
};

// ---------------------------------------------------------------------------------------
// CDnsName
// ---------------------------------------------------------------------------------------

BOOL CDnsName::InitFromString(const char * psz)
{
    BYTE * pb = _ab;
    UINT cb = strlen(psz);

    if ((cb + 2) > sizeof(_ab))
    {
        TraceSz2(dnsWarn, "CDnsName::InitFromString - '%s': String is too %s",
                 psz, cb == 0 ? "small" : "big");
        goto err;
    }

    // Copy the entire string into the buffer offset by one byte.  Prepend a dot for
    // the first label, and copy the NULL string terminator into the buffer.

    _ab[0] = '.';
    memcpy(&_ab[1], psz, cb + 1);

    // Parse each label and prepend its size, overwriting each dot.

    while (*pb != 0)
    {
        // Find the next dot or end of string

        BYTE * pbDot = pb + 1;
        while (*pbDot != 0 && *pbDot != '.')
            ++pbDot;

        // The maximum size of a label is CB_DNSMAXLABEL

        UINT cbLabel = pbDot - (pb + 1);

        if (cbLabel > DNSMAXLABEL)
        {
            *pbDot = 0;
            TraceSz2(dnsWarn, "CDnsName::InitFromString - '%s': Label '%s' is too big",
                     psz, pb + 1);
            goto err;
        }

        if (cbLabel == 0 && *pbDot != 0)
        {
            TraceSz1(dnsWarn, "CDnsName::InitFromString - '%s': Empty label must be the last", psz);
            goto err;
        }

        // Prepend the length of the label and continue at the next dot

        *pb = (BYTE)cbLabel;
        pb  = pbDot;
    }

    // A valid name must contain at least one non-zero label

    if (_ab[0] == 0)
    {
        TraceSz1(dnsWarn, "CDnsName::InitFromString - '%s': Zero labels parsed", psz);
        goto err;
    }

    return(TRUE);

err:
    _ab[0] = 0;
    return(FALSE);
}

BYTE * CDnsName::InitFromLabels(BYTE * pbSrcBeg, BYTE * pbSrcEnd, BYTE * pbLabOrg)
{
    BYTE *  pbLabBeg    = pbLabOrg;
    BYTE *  pbDst       = _ab;
    BYTE *  pbDstEnd    = pbDst + sizeof(_ab);
    BYTE *  pbSrc;
    BYTE *  pbSrcHi     = NULL;
    BYTE    bLen;
    WORD    wLen;
    
chaselabel:

    if (pbLabBeg < pbSrcBeg || pbLabBeg >= pbSrcEnd)
    {
        TraceSz3(dnsWarn, "CDnsName::InitFromLabels - Label at %08lX is out of range [%08lX %08lX)",
                 pbLabBeg, pbSrcBeg, pbSrcEnd);
        goto err;
    }

    pbSrc = pbLabBeg;

nextlabel:

    bLen  = *pbSrc++;

    if ((bLen & 0xC0) == 0xC0)
    {
        // This is a pointer.  Compute the offset from pbSrcBeg and continue there.

        if (pbSrcEnd - pbSrc == 0)
        {
            TraceSz2(dnsWarn, "CDnsName::InitFromLabels - Label at %08lX has pointer spanning boundary (%08lX)",
                     pbLabBeg, pbSrcEnd);
            goto err;
        }

        wLen = ((bLen & 0x3F) << 8) | (*pbSrc++);

        // If this is the first pointer we've chased, then the result of this function
        // will be the current pbSrc pointer.

        if (pbSrcHi == NULL)
        {
            pbSrcHi = pbSrc;
        }

        // Compute the address of the chased label, and limit the pbSrcEnd so that the
        // range of acceptable addresses ends just before the current label.  Then jump
        // back to continue scanning.  Note that boundary conditions are checked later.

        pbSrcEnd = pbLabBeg;
        pbLabBeg = pbSrcBeg + wLen;

        goto chaselabel;
    }

    if ((bLen & 0xC0) != 0)
    {
        TraceSz3(dnsWarn, "CDnsName::InitFromLabels - Label at %08lX has bogus length byte (%02X) at %08lX",
                 pbLabBeg, bLen, pbSrc - 1);
        goto err;
    }

    if (pbDstEnd - pbDst <= bLen)
    {
        TraceSz1(dnsWarn, "CDnsName::InitFromLabels - Label at %08lX is too large", pbLabOrg);
        goto err;
    }

    *pbDst++ = bLen;

    if (bLen > 0)
    {
        memcpy(pbDst, pbSrc, bLen);
        pbDst += bLen;
        pbSrc += bLen;
        goto nextlabel;
    }

    // Finished copying the entire DNS name.  Return a pointer to just after the initial set of
    // bytes consumed.  This will be pbSrcHi if a pointer was chased, else it will be the current
    // pbSrc.

    return(pbSrcHi ? pbSrcHi : pbSrc);

err:
    _ab[0] = 0;
    return(NULL);
}

UINT CDnsName::GetSize()
{
    BYTE * pb = _ab;
    UINT   cb = 1;

    while (*pb != 0)
    {
        cb += *pb + 1;
        pb += *pb + 1;
    }

    return(cb);
}

BOOL CDnsName::IsEqual(CDnsName * pdnsname)
{
    BYTE * pb1 = _ab;
    BYTE * pb2 = pdnsname->_ab;

    while (*pb1 != 0 && *pb2 != 0)
    {
        if (*pb1 != *pb2)
        {
            return(FALSE);
        }

        if (_strnicmp((char *)(pb1 + 1), (char *)(pb2 + 1), *pb1) != 0)
        {
            return(FALSE);
        }

        pb1 += *pb1 + 1;
        pb2 += *pb2 + 1;
    }

    return(TRUE);
}

#if DBG

char * CDnsName::Str()
{
    #define DNSNAME_STR_BUFFS    4
    #define DNSNAME_BUF_SIZE     256
    static char g_chBufDnsName[DNSNAME_STR_BUFFS * DNSNAME_BUF_SIZE];
    static LONG g_lBufIndexDnsName = 0;
    char * pch = &g_chBufDnsName[(InterlockedIncrement(&g_lBufIndexDnsName) % DNSNAME_STR_BUFFS) * DNSNAME_BUF_SIZE];
    char * pchDst = pch;
    BYTE * pb = _ab;
    while (*pb != 0)
    {
        if (pch != pchDst)
        {
            *pchDst++ = '.';
        }

        memcpy(pchDst, pb + 1, *pb);
        pchDst += *pb;
        pb += *pb + 1;
    }
    *pchDst = 0;
    return(pch);
}

#endif

// ---------------------------------------------------------------------------------------
// CXnIp (DNS)
// ---------------------------------------------------------------------------------------

INT CXnIp::IpDnsLookup(const char * pszHost, WSAEVENT hEvent, XNDNS ** ppxndns)
{
    ICHECK(IP, USER);

    CDnsName dnsname;

    if (!dnsname.InitFromString(pszHost))
    {
        TraceSz1(dnsWarn, "%s is not a valid DNS domain name", pszHost);
        return(WSAEFAULT);
    }

    UINT        cbDnsName   = dnsname.GetSize();
    CDnsReg *   pdnsreg     = (CDnsReg *)PoolAllocZ(sizeof(CDnsReg) + cbDnsName, PTAG_CDnsReg);

    if (pdnsreg == NULL)
    {
        TraceSz(dnsWarn, "Out of memory allocating CDnsReg");
        return(WSAENOBUFS);
    }

    if (hEvent != NULL)
    {
        pdnsreg->_pEvent = EvtFromHandle(hEvent);

        if (pdnsreg->_pEvent == NULL)
        {
            TraceSz1(dnsWarn, "CXnIp::IpDnsLookup - Error referencing WSAEVENT %08lX", hEvent);
            PoolFree(pdnsreg);
            return(WSASYSCALLFAILURE);
        }
    }

    memcpy(pdnsreg + 1, dnsname._ab, cbDnsName);

    pdnsreg->_wId = HTONS(GetNextDgramId());
    pdnsreg->_pdnsname = (CDnsName *)(pdnsreg + 1);
    pdnsreg->_timer.Init((PFNTIMER)IpDnsTimer);
    pdnsreg->_fPending = TRUE;
    pdnsreg->_xndns.iStatus = WSAEINPROGRESS;

    *ppxndns = &pdnsreg->_xndns;

    RaiseToDpc();

    pdnsreg->_pdnsregNext = _pdnsreg;
    _pdnsreg = pdnsreg;

    IpXmitDns(pdnsreg);

    return(0);
}

INT CXnIp::IpDnsRelease(XNDNS * pxndns)
{
    ICHECK(IP, USER);

    RaiseToDpc();

    CDnsReg ** ppdnsreg = &_pdnsreg;
    CDnsReg *  pdnsreg;

    for (; (pdnsreg = *ppdnsreg) != NULL; ppdnsreg = &pdnsreg->_pdnsregNext)
        if (pxndns == &pdnsreg->_xndns)
            break;

    if (pdnsreg == NULL)
    {
        TraceSz1(Warning, "XNDNS %08lX is not valid", pxndns);
        return(WSAEINVAL);
    }

    TimerSet(&pdnsreg->_timer, TIMER_INFINITE);

    if (pdnsreg->_pEvent)
    {
        EvtDereference(pdnsreg->_pEvent);
    }

    *ppdnsreg = pdnsreg->_pdnsregNext;

    PoolFree(pdnsreg);

    return(0);
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpDnsTimer
// ---------------------------------------------------------------------------------------

void CXnIp::IpDnsTimer(CTimer * pt)
{
    ICHECK(IP, UDPC|SDPC);

    CDnsReg * pdnsreg = (CDnsReg *)((BYTE *)pt - offsetof(CDnsReg, _timer));

    pdnsreg->_bRetry += 1;

    if (pdnsreg->_bRetry >= cfgDnsRetries)
    {
        TraceSz3(dns, "IpDnsTimer %04X '%s': Maximum retries exceeded (%d)",
                 NTOHS(pdnsreg->_wId), pdnsreg->_pdnsname->Str(), cfgDnsRetries);
        IpDnsSignal(pdnsreg, WSAETIMEDOUT);
        return;
    }

    IpXmitDns(pdnsreg);
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpXmitDns
// ---------------------------------------------------------------------------------------

void CXnIp::IpXmitDns(CDnsReg * pdnsreg)
{
    ICHECK(IP, UDPC|SDPC);

    if (_options._dnsServerCount == 0)
    {
        TraceSz2(dnsWarn, "IpXmitDns %04X '%s': No DNS servers configured",
                 NTOHS(pdnsreg->_wId), pdnsreg->_pdnsname->Str());
        IpDnsSignal(pdnsreg, WSAHOST_NOT_FOUND);
        return;
    }

    CIpAddr ipaDst = _options._dnsServers[pdnsreg->_bRetry % _options._dnsServerCount];

    TraceSz4(dns, "IpXmitDns %04X '%s' to %s (try #%d)",
             NTOHS(pdnsreg->_wId), pdnsreg->_pdnsname->Str(), ipaDst.Str(), pdnsreg->_bRetry + 1);

    UINT cbDnsName = pdnsreg->_pdnsname->GetSize();
    UINT cbDnsMsg  = sizeof(CDnsHdr) + cbDnsName + 2 * sizeof(WORD);

    CPacket * ppkt = PacketAlloc(PTAG_CDnsPacket, PKTF_TYPE_UDP|PKTF_XMIT_INSECURE|PKTF_POOLALLOC, cbDnsMsg);

    if (ppkt == NULL)
    {
        TraceSz(dnsWarn, "Out of memory allocating DNS packet");
        return;
    }

    CUdpHdr *   pudphdr = ppkt->GetUdpHdr();
    CDnsHdr *   pdnshdr = (CDnsHdr *)(pudphdr + 1);
    BYTE *      pb      = (BYTE *)(pdnshdr + 1);

    pudphdr->_ipportSrc = DNS_CLIENT_PORT;
    pudphdr->_ipportDst = DNS_SERVER_PORT;
    pudphdr->_wLen      = HTONS(sizeof(CUdpHdr) + cbDnsMsg);

    memset(pdnshdr, 0, sizeof(CDnsHdr));
    pdnshdr->_wId       = pdnsreg->_wId;
    pdnshdr->_wFlags    = HTONS(DNSF_RD | DNSF_QOP_SQRY);
    pdnshdr->_cQd       = HTONS(1);

    memcpy(pb, pdnsreg->_pdnsname->_ab, cbDnsName);
    pb                 += cbDnsName;
    *(WORD *)pb         = HTONS(DNSRT_A);
    pb                 += sizeof(WORD);
    *(WORD *)pb         = HTONS(DNSRC_IN);

#ifdef XNET_FEATURE_TRACE
    if (Tag(dnsDump))
    {
        UINT dns = Tag(dns);
        Tag(dns) = Tag(dnsDump);
        IpDnsDump(pdnshdr, cbDnsMsg);
        Tag(dns) = dns;
    }
#endif

    TimerSetRelative(&pdnsreg->_timer, cfgDnsTimeoutInSeconds * TICKS_PER_SECOND);
    IpFillAndXmit(ppkt, ipaDst, IPPROTOCOL_UDP);
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpRecvDns
// ---------------------------------------------------------------------------------------

void CXnIp::IpRecvDns(CPacket * ppkt, CUdpHdr * pUdpHdr, UINT cbLen)
{
    ICHECK(IP, SDPC);

    if (ppkt->TestFlags(PKTF_RECV_BROADCAST) || ppkt->GetIpHdr()->_ipaDst.IsBroadcast())
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet received via broadcast");
        return;
    }

    CDnsHdr * pdnshdr = (CDnsHdr *)(pUdpHdr + 1);

    if (cbLen < sizeof(CDnsHdr))
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet is too small");
        return;
    }

    WORD wFlags = NTOHS(pdnshdr->_wFlags);

    if (    (wFlags & DNSF_RESPONSE) == 0
        ||  (wFlags & DNSF_QOP_MASK) != DNSF_QOP_SQRY
        ||  pdnshdr->_cQd != HTONS(1))
    {
        TraceSz3(pktWarn, "[DISCARD] DNS packet has invalid response (%d,%d,%d)",
                 (wFlags & DNSF_RESPONSE) == 0,
                 (wFlags & DNSF_QOP_MASK) != DNSF_QOP_SQRY,
                 pdnshdr->_cQd != HTONS(1));
        return;
    }

    CDnsReg * pdnsreg = _pdnsreg;

    for (; pdnsreg != NULL; pdnsreg = pdnsreg->_pdnsregNext)
        if (pdnsreg->_wId == pdnshdr->_wId)
            break;
    
    if (pdnsreg == NULL)
    {
        TraceSz1(pktWarn, "[DISCARD] Unrecognized DNS packet with ID %04X", NTOHS(pdnshdr->_wId));
        return;
    }

    if (!pdnsreg->_fPending)
    {
        TraceSz2(pktRecv, "[DISCARD] Ignoring duplicate DNS packet with ID %04X (iStatus=%d)",
                 NTOHS(pdnsreg->_wId), pdnsreg->_xndns.iStatus);
        return;
    }

#ifdef XNET_FEATURE_TRACE
    if (Tag(dnsDump))
    {
        UINT dns = Tag(dns);
        Tag(dns) = Tag(dnsDump);
        IpDnsDump(pdnshdr, cbLen);
        Tag(dns) = dns;
    }
#endif

    if ((wFlags & DNSF_ROP_MASK) == DNSF_ROP_NAMEERR)
    {
        IpDnsSignal(pdnsreg, WSAHOST_NOT_FOUND);
        return;
    }
    else if ((wFlags & DNSF_ROP_MASK) != DNSF_ROP_OK)
    {
        TraceSz1(pktWarn, "[DISCARD] DNS packet with RCODE %d", wFlags & DNSF_ROP_MASK);
        return;
    }

    // Scan the Answer section for DNSRT_A/DNSRC_IN records

    BYTE *      pbBeg = (BYTE *)pdnshdr;
    BYTE *      pbEnd = pbBeg + cbLen;
    BYTE *      pb    = (BYTE *)(pdnshdr + 1);
    CDnsName    dnsname;
    WORD        wType, wClass, wRdLen;
    DWORD       dwTtl;

    // But first, skip over the Question section and verify that the name is correct

    if (pb - pbEnd == 0)
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet has no Question section");
        return;
    }

    pb = dnsname.InitFromLabels(pbBeg, pbEnd, pb);

    if (pb == NULL)
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet has invalid Question name");
        return;
    }
        
    if (pbEnd - pb < sizeof(WORD) + sizeof(WORD))
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet has too small Question section");
        return;
    }

    wType  = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);
    wClass = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);

    if (!dnsname.IsEqual(pdnsreg->_pdnsname))
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet has wrong query name in Question section");
        return;
    }

    // Now pb points to the Answer section.  Parse all the answers to find DNSRT_A records.

    WORD cAn = NTOHS(pdnshdr->_cAn);
    UINT cina = 0;

    for (; cAn > 0; --cAn)
    {
        pb = dnsname.InitFromLabels(pbBeg, pbEnd, pb);

        if (pb == NULL)
        {
            TraceSz(pktWarn, "[DISCARD] DNS packet has invalid Answer name");
            return;
        }

        if (pbEnd - pb < sizeof(WORD) + sizeof(WORD) + sizeof(DWORD) + sizeof(WORD))
        {
            TraceSz(pktWarn, "[DISCARD] DNS packet ended prematurely while parsing Answer section (1)");
            return;
        }

        wType  = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);
        wClass = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);
        dwTtl  = NTOHL(*(DWORD *)pb);   pb += sizeof(DWORD);
        wRdLen = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);

        if (pbEnd - pb < wRdLen)
        {
            TraceSz(pktWarn, "[DISCARD] DNS packet ended prematurely while parsing Answer section (2)");
            return;
        }

        if (wType == DNSRT_A && wClass == DNSRC_IN && wRdLen == sizeof(CIpAddr))
        {
            pdnsreg->_xndns.aina[cina++] = *(IN_ADDR *)pb;

            if (cina == dimensionof(pdnsreg->_xndns.aina))
            {
                TraceSz(pktWarn, "DNS packet had more IN/A answers than XNDNS has room");
                break;
            }
        }

        pb += wRdLen;
    }

    if (cina == 0)
    {
        TraceSz(pktWarn, "[DISCARD] DNS packet had no A/IN answer records");
        return;
    }

    // Signal successful completion.

    pdnsreg->_xndns.cina = cina;
    IpDnsSignal(pdnsreg, 0);
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpDnsSignal
// ---------------------------------------------------------------------------------------

void CXnIp::IpDnsSignal(CDnsReg * pdnsreg, INT iStatus)
{
    ICHECK(IP, UDPC|SDPC);

    Assert(pdnsreg->_fPending);
    Assert(pdnsreg->_xndns.iStatus == WSAEINPROGRESS);
    Assert(iStatus != WSAEINPROGRESS);

    pdnsreg->_fPending = FALSE;
    pdnsreg->_xndns.iStatus = iStatus;
    TimerSet(&pdnsreg->_timer, TIMER_INFINITE);

    if (pdnsreg->_pEvent)
    {
        EvtSet(pdnsreg->_pEvent, EVENT_INCREMENT);
    }
}

// ---------------------------------------------------------------------------------------
// CXnIp::IpDnsDump
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_TRACE

void CXnIp::IpDnsDump(CDnsHdr * pdnshdr, UINT cbDnsMsg)
{
    ICHECK(IP, USER|UDPC|SDPC);

    Assert(cbDnsMsg >= sizeof(CDnsHdr));

    WORD wFlags = NTOHS(pdnshdr->_wFlags);

    TraceSz14(dns, "[DNS %s %d/%s %d/%s%s%s%s%s %04X %d/Qd %d/An %d/Ns %d/Ar]",
              (wFlags & DNSF_RESPONSE) ? "RESP" : "QUERY",
              (wFlags & DNSF_QOP_MASK),
              (wFlags & DNSF_QOP_MASK) == DNSF_QOP_SQRY ? "SQRY" :
              (wFlags & DNSF_QOP_MASK) == DNSF_QOP_IQRY ? "IQRY" :
              (wFlags & DNSF_QOP_MASK) == DNSF_QOP_STAT ? "STAT" : "????",
              (wFlags & DNSF_ROP_MASK),
              (wFlags & DNSF_ROP_MASK) == DNSF_ROP_OK ? "OK" :
              (wFlags & DNSF_ROP_MASK) == DNSF_ROP_FMTERR ? "FMTERR" :
              (wFlags & DNSF_ROP_MASK) == DNSF_ROP_SRVFAIL ? "SRVFAIL" :
              (wFlags & DNSF_ROP_MASK) == DNSF_ROP_NAMEERR ? "NAMEERR" :
              (wFlags & DNSF_ROP_MASK) == DNSF_ROP_NOTIMPL ? "NOTIMPL" :
              (wFlags & DNSF_ROP_MASK) == DNSF_ROP_REFUSED ? "REFUSED" : "????",
              (wFlags & DNSF_AA) ? " AA" : "",
              (wFlags & DNSF_TC) ? " TC" : "",
              (wFlags & DNSF_RD) ? " RD" : "",
              (wFlags & DNSF_RA) ? " RA" : "",
              NTOHS(pdnshdr->_wId),
              NTOHS(pdnshdr->_cQd),
              NTOHS(pdnshdr->_cAn),
              NTOHS(pdnshdr->_cNs),
              NTOHS(pdnshdr->_cAr));

    BYTE * pbBeg = (BYTE *)pdnshdr;
    BYTE * pbEnd = pbBeg + cbDnsMsg;
    BYTE * pbSec = (BYTE *)(pdnshdr + 1);

    if (NTOHS(pdnshdr->_cQd) != 0)
        pbSec = IpDnsDumpSection(pbBeg, pbEnd, pbSec, NTOHS(pdnshdr->_cQd), "Qd");
    if (pbSec && NTOHS(pdnshdr->_cAn) != 0)
        pbSec = IpDnsDumpSection(pbBeg, pbEnd, pbSec, NTOHS(pdnshdr->_cAn), "An");
    if (pbSec && NTOHS(pdnshdr->_cNs) != 0)
        pbSec = IpDnsDumpSection(pbBeg, pbEnd, pbSec, NTOHS(pdnshdr->_cNs), "Ns");
    if (pbSec && NTOHS(pdnshdr->_cAr) != 0)
        pbSec = IpDnsDumpSection(pbBeg, pbEnd, pbSec, NTOHS(pdnshdr->_cAr), "Ar");
}

char * DnsTypeToStr(WORD wType)
{
    switch (wType)
    {
        case DNSRT_A:       return("A");
        case DNSRT_NS:      return("NS");
        case DNSRT_MD:      return("MD");
        case DNSRT_MF:      return("MF");
        case DNSRT_CNAME:   return("CNAME");
        case DNSRT_SOA:     return("SOA");
        case DNSRT_MB:      return("MB");
        case DNSRT_MG:      return("MG");
        case DNSRT_MR:      return("MR");
        case DNSRT_NULL:    return("NULL");
        case DNSRT_WKS:     return("WKS");
        case DNSRT_PTR:     return("PTR");
        case DNSRT_HINFO:   return("HINFO");
        case DNSRT_MINFO:   return("MINFO");
        case DNSRT_MX:      return("MX");
        case DNSRT_TXT:     return("TXT");
        case DNSQT_AXFR:    return("AXFR");
        case DNSQT_MAILB:   return("MAILB");
        case DNSQT_MAILA:   return("MAILA");
        case DNSQT_ALL:     return("ALL");
        default:            return("?");
    }
}

char * DnsClassToStr(WORD wClass)
{
    switch (wClass)
    {
        case DNSRC_IN:      return("IN");
        case DNSRC_CS:      return("CS");
        case DNSRC_CH:      return("CH");
        case DNSRC_HS:      return("HS");
        case DNSRC_ANY:     return("ANY");
        default:            return("?");
    }
}

BYTE * CXnIp::IpDnsDumpSection(BYTE * pbBeg, BYTE * pbEnd, BYTE * pb, UINT cSec, char * pszSec)
{
    CDnsName    dnsname1, dnsname2;
    UINT        iSec;
    WORD        wType, wClass, wRdLen;
    DWORD       dwTtl;
    
    for (iSec = 0; iSec < cSec; ++iSec)
    {
        if (pb - pbEnd == 0)
            goto err;

        pb = dnsname1.InitFromLabels(pbBeg, pbEnd, pb);
        if (pb == NULL)
            goto err;

        if (strcmp(pszSec, "Qd") == 0)
        {
            if (pbEnd - pb < sizeof(WORD) + sizeof(WORD))
                goto err;

            wType  = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);
            wClass = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);

            TraceSz7(dns, "  %s.%d: %-32s %d/%s %d/%s",
                     pszSec, iSec, dnsname1.Str(), wType, DnsTypeToStr(wType),
                     wClass, DnsClassToStr(wClass));
        }
        else
        {
            if (pbEnd - pb < sizeof(WORD) + sizeof(WORD) + sizeof(DWORD) + sizeof(WORD))
                goto err;

            wType  = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);
            wClass = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);
            dwTtl  = NTOHL(*(DWORD *)pb);   pb += sizeof(DWORD);
            wRdLen = NTOHS(*(WORD *)pb);    pb += sizeof(WORD);

            if (pbEnd - pb < wRdLen)
                goto err;

            if (wType == DNSRT_A && wClass == DNSRC_IN && wRdLen == sizeof(CIpAddr))
            {
                TraceSz8(dns, "  %s.%d: %-32s %d/%s %d/%s %s",
                         pszSec, iSec, dnsname1.Str(), wType, DnsTypeToStr(wType),
                         wClass, DnsClassToStr(wClass), ((CIpAddr *)pb)->Str());
            }
            else if (   wRdLen > 0
                     && (   wType == DNSRT_NS
                         || wType == DNSRT_MD
                         || wType == DNSRT_MF
                         || wType == DNSRT_CNAME
                         || wType == DNSRT_MB
                         || wType == DNSRT_MG
                         || wType == DNSRT_MR
                         || wType == DNSRT_PTR)
                     && dnsname2.InitFromLabels(pbBeg, pb + wRdLen, pb) == pb + wRdLen)
            {
                TraceSz8(dns, "  %s.%d: %-32s %d/%s %d/%s %s",
                         pszSec, iSec, dnsname1.Str(), wType, DnsTypeToStr(wType),
                         wClass, DnsClassToStr(wClass), dnsname2.Str());
            }
            else
            {
                TraceSz8(dns, "  %s.%d: %-32s %d/%s %d/%s [+%d bytes]",
                         pszSec, iSec, dnsname1.Str(), wType, DnsTypeToStr(wType),
                         wClass, DnsClassToStr(wClass), wRdLen);
                IpDnsDumpHex(pb, wRdLen);
            }

            pb += wRdLen;
        }

    }
        
    return(pb);

err:
    TraceSz2(dns, "  %s.%d: <Error processing record>", pszSec, iSec);
    return(NULL);
}

void CXnIp::IpDnsDumpHex(BYTE * pb, UINT cb)
{
    char * pch;
    char ach[256];
    UINT ib, ibEnd;
    BYTE b;

    while (cb > 0)
    {
        pch = ach;

        ibEnd = 16;
        if (ibEnd > cb)
            ibEnd = cb;

        for (ib = 0; ib < ibEnd; ++ib, ++pb)
        {
            b = (*pb) >> 4;
            *pch++ = (b < 10) ? '0' + b : 'A' + b - 10;
            b = (*pb) & 0xF;
            *pch++ = (b < 10) ? '0' + b : 'A' + b - 10;
            *pch++ = (ib == 7) ? '-' : ' ';
        }

        pb -= ibEnd;

        if (ibEnd < 16)
        {
            memset(pch, ' ', 3 * (16 - ibEnd));
            pch += 3 * (16 - ibEnd);
        }

        *pch++ = ' ';
        *pch++ = ' ';

        for (ib = 0; ib < ibEnd; ++ib, ++pb)
        {
            b = *pb;
            if (b >= 32 && b < 127)
                *pch++ = b;
            else
                *pch++ = '.';
        }

        *pch = 0;

        TraceSz1(dns, "    %s", ach);

        cb -= ibEnd;
    }
}

#endif

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\nicx.h ===
// ---------------------------------------------------------------------------------------
// nicx.h
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef _NICX_H_
#define _NICX_H_

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

struct NICSTATS
{
    ULONG               isrCount;
    ULONG               dpcCount;
    ULONG               txGoodFrames;
    ULONG               rxGoodFrames;
    ULONG               txUnderflowErrors;
    ULONG               txLateCollisions;
    ULONG               txLostCarriers;
    ULONG               txDefers;
    ULONG               txExcessiveDefers;
    ULONG               txRetryErrors;
    ULONG               rxMinSizeErrors;
    ULONG               rxFramingErrors;
    ULONG               rxOverFlowErrors;
    ULONG               rxCrcErrors;
    ULONG               rxLengthErrors;
    ULONG               rxMaxFrameErrors;
    ULONG               rxLateCollisions;
    ULONG               rxRunts;
    ULONG               rxExtraByteErrors;
    ULONG               rxMissedFrames;
    ULONG               rxEndOfFrameErrors;

};

#define NIC_VENDORID    0x10DE      // nVidia Vendor ID
#define NIC_DEVICEID    0x01C3      // nVidia Device ID

#define RXDESC_OWN      BIT(31)     // 0 - host owns; 1 - controller owns
#define RXDESC_ERR      BIT(30)     // receive error
#define RXDESC_FRAM     BIT(29)     // framing error
#define RXDESC_OFOL     BIT(28)     // overflow error
#define RXDESC_CRC      BIT(27)     // CRC error
#define RXDESC_LFER     BIT(26)     // length field error
#define RXDESC_MAX      BIT(25)     // received frame larger than max size
#define RXDESC_LCOL     BIT(24)     // late collision
#define RXDESC_RUNT     BIT(23)     // runt packet received
#define RXDESC_PAM      BIT(22)     // physical address match
#define RXDESC_MAM      BIT(21)     // multicast address match
#define RXDESC_BAM      BIT(20)     // broadcast address match
#define RXDESC_EXTRA    BIT(18)     // received frame length has an extra byte
#define RXDESC_MISS     BIT(17)     // missed data reception
#define RXDESC_REND     BIT(16)     // end of receive frame

#define TXDESC_OWN      BIT(31)     // 0 - host owns; 1 - controller owns
#define TXDESC_ERR      BIT(30)     // transmit error
#define TXDESC_UFLO     BIT(29)     // underflow error
#define TXDESC_LCOL     BIT(28)     // late collision
#define TXDESC_LCAR     BIT(27)     // loss of carrier
#define TXDESC_DEF      BIT(26)     // deferred
#define TXDESC_EXDEF    BIT(25)     // excessive deferral
#define TXDESC_INTEN    BIT(24)     // interrupt override
#define TXDESC_RTRY     BIT(19)     // retry error (23-20: retry count)
#define TXDESC_TEND     BIT(16)     // end of transmit frame

struct XmitDesc
{
    DWORD       _dwPhyAddr;         // physical address of xmit buffer
    DWORD       _dwFlagsCount;      // HIWORD - control/status bits; LOWORD - byte count minus 1
};

struct RecvDesc
{
    DWORD       _dwPhyAddr;         // physical address of recv buffer
    DWORD       _dwFlagsCount;      // HIWORD - control/status bits; LOWORD - byte count
};

#define NIC_FRAME_SIZE      (PAGE_SIZE/2)
#define NIC_FRAME_ALIGNMENT 2

// ---------------------------------------------------------------------------------------
// CXnNic
// ---------------------------------------------------------------------------------------

class NOVTABLE CXnNic : public CXnBase
{
    // Definitions -----------------------------------------------------------------------

    struct XNADDRXBDM
    {
        BYTE        bSizeOfStruct;                  // sizeof(XNADDR)
        BYTE        bFlags;                         // XNET_XNADDR_* flags below
        BYTE        abEnet[6];                      // Ethernet MAC address
        IN_ADDR     ina;                            // IP address (zero if not static/DHCP)
        IN_ADDR     inaOnline;                      // Online IP address (zero if not online)
        WORD        wPortOnline;                    // Online port (zero if not online)
        BYTE        abIdOnline[20];                 // Online identifier (zero if not online)
    };

    // External --------------------------------------------------------------------------

public:

    HAL_DECLARE_NEW_DELETE(CXnNic)

    BOOL                NicXmitReady();
    void                NicXmit(CPacket * ppkt);
    VIRTUAL void        NicTimer();

#if defined(XNET_FEATURE_XBDM_CLIENT) || defined(XNET_FEATURE_XBDM_SERVER)
    DWORD               NicGetOtherXnAddr(XNADDR * pxna);
#endif

protected:

    NTSTATUS            NicInit(XNetInitParams * pxnip);
    INLINE INT          NicConfig(const XNetConfigParams * pxncp) { return(0); }
    void                NicStart();
    void                NicFlush();
    void                NicStop();
    void                NicTerm();

    VIRTUAL void        EnetRecv(CPacket * ppkt, UINT uiType) VPURE;
    VIRTUAL void        EnetPush() VPURE;

    // Internal --------------------------------------------------------------------------

private:

    INLINE XmitDesc *   PxdNext(XmitDesc * pxd) { return(pxd == _pxdLast ? _pxdFirst : (pxd + 1)); }
    INLINE RecvDesc *   PrdNext(RecvDesc * prd) { return(prd == _prdLast ? _prdFirst : (prd + 1)); }
    INLINE DWORD_PTR    PhyAddr(void * pv)      { return((DWORD_PTR)pv + _dwPhyOff); }
    INLINE void *       VirAddr(DWORD_PTR dw)   { return((void *)(dw - _dwPhyOff)); }

    void                NicStartXmitRecv();
    void                NicStopXmitRecv();
    static BOOLEAN      NicIsr(PKINTERRUPT, PVOID pvContext);
    BOOLEAN             NicProcessIsr();
    static void         NicDpc(PKDPC dpc, void * pvContext, void * pvArg1, void * pvArg2);
    void                NicProcessDpc();
    void                NicMiiInterrupt(DWORD dwMintr, BOOL fInit);
    void                NicRecvInterrupt();
    void                NicXmitInterrupt();

    static void         HalShutdownNotification(HAL_SHUTDOWN_REGISTRATION * pHalShutdownReg);

    class CXbdmClient
    {
    public:
        INLINE CXnNic *         GetXnNic();
        virtual void            XmitComplete(void * pvPkt);
        virtual void            EnetRecv(UINT uiFlags, void * pv, UINT cb, UINT uiType);
        virtual void            EnetPush();
        virtual DWORD           GetXnAddr(XNADDRXBDM * pxnaXbdm);
    };

    class CXbdmServer
    {
    public:
        // This magic cookie on the XBDM server CXnNic protects the client from connecting
        // to an incompatible version.  We only change it when this interface changes in
        // a non-backward compatible way.
        #define XBDM_SERVER_COOKIE 'XBD6'
        CXbdmServer() { _dwCookie = XBDM_SERVER_COOKIE; }
        BOOL                    IsValidServer() { return(_dwCookie == XBDM_SERVER_COOKIE); }
        INLINE CXnNic *         GetXnNic();
        virtual void            NicStop();
        virtual NTSTATUS        InitClient(UINT cfgRecvQ, UINT cfgXmitQ, CEnetAddr * pea, BOOL * pfLinkIsUp);
        virtual void            AttachClient(CXbdmClient * pXbdmClient);
        virtual void            DetachClient();
        virtual DWORD           GetXnAddr(XNADDRXBDM * pxnaXbdm);
        virtual void            Xmit(void * pvPkt, void * pv, UINT cb);
        virtual BOOL            XmitReady();
        DWORD                   _dwCookie;
    };

    class CXbdmPacket : public CPacket
    {

    public:

        void *          _pvPkt;                 // Client's packet pointer
    };

#ifdef XNET_FEATURE_STATS
    #define STATINC(n)          StatInc(offsetof(NICSTATS, n))
    #define STATINC_(x,n)       if (x) STATINC(n)
    void                        StatInit();
    void                        StatTerm();
    void                        StatInc(UINT iStat);
    void                        StatTimer(CTimer * pt);
#else
    #define STATINC(n)
    #define STATINC_(x,n)
    INLINE void                 StatInit() {};
    INLINE void                 StatTerm() {};
#endif

    // Data ------------------------------------------------------------------------------

public:

    CEnetAddr                   _ea;                // Ethernet address

private:

    KDPC                        _dpc;               // DPC object
    ULONG                       _ulIntrVector;      // interrupt vector
    KIRQL                       _irqlIntr;          // interrupt IRQ level
    DWORD                       _dwRxPollFreq;      // Rx polling frequency
    DWORD                       _dwLinkState;       // last known link state (from PhyGetLinkState)
    BOOL                        _fXmitFull;         // TRUE if _cxdBusy >= _cxdPool
    DWORD_PTR                   _dwPhyOff;          // virtual to physical offset
    LONG                        _cxdBusy;           // count of busy transmit descriptors
    LONG                        _cxdPool;           // number of transmit descriptors (minus 1)
    XmitDesc *                  _pxdFirst;          // first transmit descriptor
    XmitDesc *                  _pxdLast;           // last transmit descriptor
    XmitDesc *                  _pxdBusy;           // first busy transmit descriptor
    XmitDesc *                  _pxdFree;           // first free transmit descriptor
    CPacketQueue                _pqXmit;            // queue of packets being transmitted
    LONG                        _crdPool;           // number of receive descriptors available
    RecvDesc *                  _prdFirst;          // first receive descriptor
    RecvDesc *                  _prdLast;           // last receive descriptor
    RecvDesc *                  _prdPtr;            // current receive descriptor
    HAL_SHUTDOWN_REGISTRATION   _HalShutdownReg;    // registration for system shutdown

#ifdef XNET_FEATURE_XBDM_CLIENT
    CXbdmServer *               _pXbdmServer;       // Non-NULL when XBDM is running in this process
    CXbdmClient                 _XbdmClient;        // The object we give to the XBDM server
#endif

#ifdef XNET_FEATURE_XBDM_SERVER
    CXbdmClient *               _pXbdmClient;       // Non-NULL when the title stack is attached
    CXbdmServer                 _XbdmServer;        // The object we give to the XBDM client
    CEnetAddr                   _eaClient;          // Ethernet address of title stack
    CPacketQueue                _pqClient;          // Packet queue of client packets
    CXbdmPacket *               _ppktXbdm;          // Vector of CXbdmPacket structures
#endif

#ifdef XNET_FEATURE_STATS
    NICSTATS                    _NicStats;          // statistics
    NICSTATS                    _NicStatsLast;      // statistics at last report
    CTimer                      _timerStats;        // statistics timer
#endif

private:

    static KINTERRUPT           s_InterruptObject;

};

#endif  // _NICX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\ipqos.cpp ===
// ---------------------------------------------------------------------------------------
// ipqos.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

#ifdef XNET_FEATURE_QOS

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(qosInfo, 0);
DefineTag(qosWarn, TAG_ENABLE);

// ---------------------------------------------------------------------------------------
// CXnIp (IpQos)
// ---------------------------------------------------------------------------------------

INT CXnIp::IpQosListen(const XNKID * pxnkid, const BYTE * pb, UINT cb, DWORD dwBitsPerSec, DWORD dwFlags)
{
    ICHECK(IP, USER);

    RaiseToDpc();

#if 0
    CKeyReg * pKeyReg = KeyRegLookup(pxnkid);

    if (pKeyReg == NULL)
    {
        TraceSz1(qosWarn, "IpQosListen - XNKID %s is not registered",
                 HexStr(pxnkid->ab, sizeof(pxnkid->ab)));
        return(WSAEINVAL);
    }

    if (dwFlags & XNET_QOS_LISTEN_SET_DATA)
    {
        if (cb > (UINT)(cfgQosDataLimitDiv4 * 4))
        {
            TraceSz3(qosWarn, "IpQosListen - cb is %d bytes but cfgQosDataLimit is %d (%d bytes)",
                     cb, cfgQosDataLimitDiv4, cfgQosDataLimitDiv4 * 4);
            return(WSAEMSGSIZE);
        }

        BYTE * pbQos = NULL;

        if (cb > 0)
        {
            pbQos = (BYTE *)SysAlloc(cb, PTAG_QosData);

            if (pbQos == NULL)
            {
                TraceSz1(qosWarn, "IpSetListen - Out of memory allocating QosData (%d bytes)", cb);
                return(WSAENOBUFS);
            }

            memcpy(pbQos, pb, cb);
        }

        SysFree(pKeyReg->_pbQos);

        pKeyReg->_pbQos = pbQos;
        pKeyReg->_cbQos = cb;
    }

    if (dwFlags & XNET_QOS_LISTEN_SET_BITSPERSEC)
    {
        //@@@ Implement me
    }

    if (dwFlags & XNET_QOS_LISTEN_ENABLE)
    {
        //@@@ Implement me
    }

    if (dwFlags & XNET_QOS_LISTEN_DISABLE)
    {
        //@@@ Implement me
    }
#endif

    return(0);
}

INT CXnIp::IpQosXnAddr(UINT cxnqos, const XNADDR * apxna[], const XNKID * apxnkid[], const XNKEY * apxnkey[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos)
{
    ICHECK(IP, USER);

    if (cxnqos == 0)
    {
        TraceSz(qosWarn, "IpQosXnAddr - Must specify one or more addresses");
        return(WSAEFAULT);
    }

    //@@@ Implement me

    return(WSAEACCES);
}

#ifdef XNET_FEATURE_SG

INT CXnIp::IpQosServer(UINT cxnqos, const IN_ADDR aina[], const DWORD adwServiceId[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos)
{
    ICHECK(IP, USER);

    if (cxnqos == 0)
    {
        TraceSz(qosWarn, "IpQosServer - Must specify one or more addresses");
        return(WSAEFAULT);
    }

    //@@@ Implement me

    return(WSAEACCES);
}

#endif

INT CXnIp::IpQosRelease(XNQOS * pxnqos)
{
    ICHECK(IP, USER);

    //@@@ Implement me

    return(WSAEACCES);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\nicx.cpp ===
// ---------------------------------------------------------------------------------------
// nicx.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

#ifdef XNET_FEATURE_XBOX

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

KINTERRUPT CXnNic::s_InterruptObject;

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#define HWADDR0(_hwaddr) ((const DWORD *)((BYTE *)(_hwaddr)))[0]
#define HWADDR1(_hwaddr) ((const WORD *)((BYTE *)(_hwaddr)))[2]

DefineTag(nicStats,     TAG_ENABLE);        // Trace Nic stats
DefineTag(nicStatsAll,  0);                 // Trace all Nic stats

// ---------------------------------------------------------------------------------------
// Internal
// ---------------------------------------------------------------------------------------

void CXnNic::NicStartXmitRecv()
{
    ICHECK(NIC, USER|UDPC|SDPC);

    PNICCSR pCsr    = PNicCsr();
    pCsr->rx_poll   = RXPOLL_EN | _dwRxPollFreq;
    pCsr->tx_en     = TXEN_ENABLE;
    pCsr->rx_en     = RXEN_ENABLE;
    pCsr->mode      = MODE_TXDM|MODE_RXDM;
}

void CXnNic::NicStopXmitRecv()
{
    ICHECK(NIC, USER|UDPC|SDPC);

    PNICCSR pCsr = PNicCsr();
    int timeout;

    // Turn off the transmitter and receiver

    pCsr->rx_poll = 0;
    pCsr->rx_en = 0;
    pCsr->tx_en = 0;

    // Wait for a max of 5msec until both the transmitter and receiver are idle

    for (timeout=500; timeout--; )
    {
        if (    !(pCsr->rx_sta & RXSTA_BUSY)
            &&  !(pCsr->tx_sta & TXSTA_BUSY))
            break;

        KeStallExecutionProcessor(10);
    }

    // Ensure there is no active DMA transfer in progress

    pCsr->mode = MODE_DISABLE_DMA;

    for (timeout=500; timeout--; )
    {
        if (pCsr->mode & MODE_DMA_IDLE)
            break;

        KeStallExecutionProcessor(10);
    }

    pCsr->mode = 0;
}

BOOLEAN CXnNic::NicIsr(PKINTERRUPT, PVOID pvContext)
{
    return(((CXnNic *)pvContext)->NicProcessIsr());
}

BOOLEAN CXnNic::NicProcessIsr()
{
    Assert(!TestInitFlag(INITF_NIC_STOP));

    // Disable interrupts

    PNicCsr()->intr_mk = 0;

    // Queue the dpc to handle the interrupt

    KeInsertQueueDpc(&_dpc, NULL, NULL);

#ifdef XNET_FEATURE_STATS
    _NicStats.isrCount += 1;
#endif

    return(TRUE);
}

void CXnNic::NicDpc(PKDPC dpc, void * pvContext, void * pvArg1, void * pvArg2)
{
    ((CXnNic *)pvContext)->NicProcessDpc();
}

void CXnNic::NicProcessDpc()
{
    ICHECK(NIC, SDPC);

    PNICCSR pCsr = PNicCsr();

    STATINC(dpcCount);

    while (1)
    {
        DWORD dwMintr = pCsr->mintr;
        DWORD dwIntr  = pCsr->intr;

        if (dwIntr == 0)
            break;

        // Process the MII interrupt before acknowledging it to prevent the auto-poll
        // of the PHY interfering with reading of the current link state

        if (dwIntr & INTR_MINT)
        {
            NicMiiInterrupt(dwMintr, FALSE);
        }

        // Acknowledge interrupts (MII interrupts first)

        pCsr->mintr = dwMintr;
        pCsr->intr  = dwIntr;

        // We always call these two interrupt handlers no matter what the interrupt
        // bits say.  They will do nothing if there isn't anything to receive or transmit.

        NicRecvInterrupt();
        NicXmitInterrupt();

        // If a receive frame was missed, tell the Nic to restart RX polling

        if (dwIntr & INTR_MISS)
        {
            STATINC(rxMissedFrames);
            pCsr->mode = MODE_RXDM;
        }

    }

    // Re-enable interrupts

    pCsr->intr_mk = INTR_ALL;
}

void CXnNic::NicMiiInterrupt(DWORD dwMintr, BOOL fInit)
{
    ICHECK(NIC, USER|UDPC|SDPC);

    PNICCSR pCsr        = PNicCsr();
    DWORD   dwMiics     = pCsr->mii_cs;
    DWORD   dwLinkState = PhyGetLinkState(!fInit);

    if (fInit || (dwLinkState != _dwLinkState))
    {
        TraceSz3(Warning, "+Ethernet link status: %s %dMbps %s-duplex",
            (dwLinkState & XNET_ETHERNET_LINK_ACTIVE) ? "up" : "down",
            (dwLinkState & XNET_ETHERNET_LINK_100MBPS) ? 100 :
                (dwLinkState & XNET_ETHERNET_LINK_10MBPS) ? 10 : 0,
            (dwLinkState & XNET_ETHERNET_LINK_FULL_DUPLEX) ? "full" :
                (dwLinkState & XNET_ETHERNET_LINK_HALF_DUPLEX) ? "half" : "?");

        // NOTE: When the link was up before, we need to stop  both Tx and Rx and then set
        // Rx polling frequency and Tx duplex mode according to the link status.

        if (!fInit)
        {
            NicStopXmitRecv();
        }

        _dwRxPollFreq = (dwLinkState & XNET_ETHERNET_LINK_10MBPS) ? RXPOLL_FREQ_10MPS : RXPOLL_FREQ_100MPS;

        if (dwLinkState & XNET_ETHERNET_LINK_FULL_DUPLEX)
            pCsr->tx_cntl &= ~TXCNTL_HDEN;
        else
            pCsr->tx_cntl |=  TXCNTL_HDEN;

        if (!fInit)
        {
            NicStartXmitRecv();
        }

        if (fInit && (dwLinkState & XNET_ETHERNET_LINK_ACTIVE))
        {
            SetInitFlag(INITF_CONNECTED_BOOT);
        }

        _dwLinkState = dwLinkState;
    }
}

void CXnNic::NicRecvInterrupt()
{
    ICHECK(NIC, UDPC|SDPC);

    CPacket     pkt;
    void *      pv;
    UINT        cb;
    CEnetHdr *  pEnetHdr;
    UINT        uiFlags;
    UINT        uiType;
    RecvDesc *  prd;
    DWORD       dwFlagsCount;

    prd = _prdPtr;

    while (1)
    {
        dwFlagsCount = prd->_dwFlagsCount;

        if (dwFlagsCount & RXDESC_OWN)
            break;
        
        if ((dwFlagsCount & RXDESC_REND) == 0)
        {
            STATINC(rxEndOfFrameErrors);
            goto nextframe;
        }

        if (dwFlagsCount & RXDESC_ERR)
        {
            STATINC_(dwFlagsCount & RXDESC_OFOL,    rxOverFlowErrors);
            STATINC_(dwFlagsCount & RXDESC_CRC,     rxCrcErrors);
            STATINC_(dwFlagsCount & RXDESC_LFER,    rxLengthErrors);
            STATINC_(dwFlagsCount & RXDESC_MAX,     rxMaxFrameErrors);
            STATINC_(dwFlagsCount & RXDESC_LCOL,    rxLateCollisions);
            STATINC_(dwFlagsCount & RXDESC_RUNT,    rxRunts);
            STATINC_(dwFlagsCount & RXDESC_FRAM,    rxFramingErrors);

            // Accept an error frame if RXDESC_FRAM is the only error bit turned on.
            // For all other errors we discard the frame.

            if ((dwFlagsCount & (RXDESC_OFOL|RXDESC_CRC|RXDESC_LFER|RXDESC_MAX|RXDESC_LCOL|RXDESC_RUNT|RXDESC_FRAM)) != RXDESC_FRAM)
                goto nextframe;
        }

        // Until NicStart is called we drop all incoming frames because the upper
        // layers of the stack are still initializing.

        if (!TestInitFlag(INITF_NIC_2))
            goto nextframe;

        pv       = VirAddr(prd->_dwPhyAddr);
        cb       = (dwFlagsCount & 0xFFFF);
        pEnetHdr = (CEnetHdr *)pv;
        uiFlags  = PKTF_TYPE_ENET;
        uiType   = pEnetHdr->_wType;

        PushPktRecvTags(pEnetHdr->_eaDst.IsBroadcast());

        if ((dwFlagsCount & (RXDESC_ERR|RXDESC_FRAM|RXDESC_EXTRA)) == (RXDESC_ERR|RXDESC_FRAM|RXDESC_EXTRA))
        {
            STATINC(rxExtraByteErrors);

            if (cb > 0)
            {
                cb -= 1;
            }
        }

        if (cb < ENET_DATA_MINSIZE)
        {
            STATINC(rxMinSizeErrors);
            goto nextframepop;
        }

        STATINC(rxGoodFrames);

        if (NTOHS((WORD)uiType) <= ENET_DATA_MAXSIZE)
        {
            CIeeeHdr * pIeeeHdr = (CIeeeHdr *)pEnetHdr;
            BYTE abEnetHdr[sizeof(CEnetAddr) * 2];

            if (!pIeeeHdr->IsEnetFrame())
            {
                TraceSz(pktRecv, "[DISCARD] IEEE frame type not supported");
                goto nextframepop;
            }

            // Convert the link header into a standard CEnetHdr

            uiType = pIeeeHdr->_wTypeIeee;
            pv     = (BYTE *)pv + (sizeof(CIeeeHdr) - sizeof(CEnetHdr));
            cb    -= (sizeof(CIeeeHdr) - sizeof(CEnetHdr));

            memcpy(abEnetHdr, pIeeeHdr, sizeof(abEnetHdr));
            memcpy(pv, abEnetHdr, sizeof(abEnetHdr));

            pEnetHdr = (CEnetHdr *)pv;
            pEnetHdr->_wType = (WORD)uiType;
        }

        pv  = (BYTE *)pv + sizeof(CEnetHdr);
        cb -= sizeof(CEnetHdr);

        TraceSz4(pktRecv, "[ENET %s %s %04X][%d]",
                 pEnetHdr->_eaDst.Str(), pEnetHdr->_eaSrc.Str(), NTOHS((WORD)uiType), cb);

        if (pEnetHdr->_eaDst.IsBroadcast())
        {
            uiFlags |= PKTF_RECV_BROADCAST;
        }
        else if (!pEnetHdr->_eaDst.IsEqual(_ea))
        {
#ifdef XNET_FEATURE_XBDM_SERVER
            if (!pEnetHdr->_eaDst.IsEqual(_eaClient))
#endif
            {
                TraceSz(pktWarn, "[DISCARD] Frame should not have been accepted by Nic hardware");
                goto nextframepop;
            }
        }

#ifdef XNET_FEATURE_XBDM_SERVER
        if ((uiFlags & PKTF_RECV_BROADCAST) || (pEnetHdr->_eaDst.IsEqual(_eaClient)))
        {
            if (_pXbdmClient)
            {
                _pXbdmClient->EnetRecv(uiFlags, pv, cb, uiType);
            }
            else if ((uiFlags & PKTF_RECV_BROADCAST) == 0)
            {
                TraceSz(pktRecv, "[DISCARD] Title stack not attached");
            }

            if ((uiFlags & PKTF_RECV_BROADCAST) == 0)
                goto nextframepop;
        }
#endif

        pkt.Init(uiFlags, pv, cb, NULL);
        EnetRecv(&pkt, uiType);

    nextframepop:

        PopPktRecvTags();

    nextframe:

        prd->_dwFlagsCount = RXDESC_OWN | (NIC_FRAME_SIZE - NIC_FRAME_ALIGNMENT - 1);
        prd = PrdNext(prd);
    }

    _prdPtr = prd;
}

void CXnNic::NicXmitInterrupt()
{
    ICHECK(NIC, UDPC|SDPC);

    XmitDesc *  pxd;
    CPacket *   ppkt;
    DWORD       dwFlagsCount;
    
    while (1)
    {
        ppkt = _pqXmit.GetHead();

        if (ppkt == NULL)
            break;

        pxd = _pxdBusy;

        if (ppkt->TestFlags(PKTF_XMIT_DUALPAGE))
        {
            Assert((pxd->_dwFlagsCount & TXDESC_TEND) == 0);
            pxd = PxdNext(pxd);
        }

        dwFlagsCount = pxd->_dwFlagsCount;

        Assert(dwFlagsCount & TXDESC_TEND);

        if (dwFlagsCount & TXDESC_OWN)
            break;

        _pqXmit.RemoveHead();
        _pxdBusy  = PxdNext(pxd);
        _cxdBusy -= (1 + !!ppkt->TestFlags(PKTF_XMIT_DUALPAGE));
        MmLockUnlockBufferPages(ppkt->GetEnetHdr(), sizeof(CEnetHdr) + ppkt->GetCb(), TRUE);

        if (dwFlagsCount & TXDESC_ERR)
        {
            STATINC_(dwFlagsCount & TXDESC_UFLO,    txUnderflowErrors);
            STATINC_(dwFlagsCount & TXDESC_LCOL,    txLateCollisions);
            STATINC_(dwFlagsCount & TXDESC_LCAR,    txLostCarriers);
            STATINC_(dwFlagsCount & TXDESC_DEF,     txDefers);
            STATINC_(dwFlagsCount & TXDESC_EXDEF,   txExcessiveDefers);
            STATINC_(dwFlagsCount & TXDESC_RTRY,    txRetryErrors);
        }
        else
        {
            STATINC(txGoodFrames);
        }

#ifdef XNET_FEATURE_XBDM_SERVER
        if (ppkt->TestFlags(PKTF_XMIT_XBDMCLIENT))
        {
            CXbdmPacket * ppktXbdm = (CXbdmPacket *)ppkt;

            if (_pXbdmClient)
                _pXbdmClient->XmitComplete(ppktXbdm->_pvPkt);
            else
                TraceSz(Warning, "XBDM client detached with active packets in the Xmit queue");
                
            _pqClient.InsertTail(ppktXbdm);
            continue;
        }
#endif

        ppkt->ClearFlags(PKTF_XMIT_DUALPAGE);
        ppkt->Complete(this);
    }

    if (_fXmitFull && _cxdBusy < _cxdPool)
    {
        _fXmitFull = FALSE;

#ifdef XNET_FEATURE_XBDM_SERVER
        if (_pXbdmClient)
            _pXbdmClient->EnetPush();
#endif

        EnetPush();
    }
}

BOOL CXnNic::NicXmitReady()
{
    ICHECK(NIC, UDPC|SDPC);

#ifdef XNET_FEATURE_XBDM_CLIENT
    if (_pXbdmServer)
    {
        return(_pXbdmServer->XmitReady());
    }
#endif

    BOOL fReady = (_cxdBusy < _cxdPool);

    if (!fReady)
    {
        _fXmitFull = TRUE;
    }

    return(fReady);
}

void CXnNic::NicXmit(CPacket * ppkt)
{
    ICHECK(NIC, UDPC|SDPC);

#ifdef XNET_FEATURE_XBDM_CLIENT
    if (_pXbdmServer)
    {
        _pXbdmServer->Xmit(ppkt, ppkt->GetEnetHdr(), ppkt->GetCb() + sizeof(CEnetHdr));
    }
    else
#endif
    {
        Assert(_cxdBusy < _cxdPool);
        Assert(ppkt->GetCb() <= ENET_DATA_MAXSIZE);

        void *      pv      = ppkt->GetEnetHdr();
        UINT        cb      = ppkt->GetCb() + sizeof(CEnetHdr);
        XmitDesc *  pxd     = _pxdFree;
        XmitDesc *  pxd0;
        UINT        cb0;

        TraceSz4(pktXmit, "[ENET dst=%s src=%s %04X][%d]",
                 ((CEnetHdr *)pv)->_eaDst.Str(), ((CEnetHdr *)pv)->_eaSrc.Str(),
                 NTOHS(((CEnetHdr *)pv)->_wType), ppkt->GetCb());

        _pqXmit.InsertTail(ppkt);

        MmLockUnlockBufferPages(pv, cb, FALSE);

        pxd->_dwPhyAddr = MmGetPhysicalAddress(pv);
        cb0 = PAGE_SIZE - (pxd->_dwPhyAddr & (PAGE_SIZE - 1));

        if (cb <= cb0)
        {
            // Entire frame is in a single physical page.  Only need one transmit destriptor.
            // Notice that the length in the _dwFlagsCount is the actual length minus one.
            // That is an odd requirement of the nVidia hardware.

            ppkt->ClearFlags(PKTF_XMIT_DUALPAGE);

            pxd->_dwFlagsCount = TXDESC_OWN | TXDESC_TEND | (cb - 1);
        }
        else
        {
            // The frame straddles a page boundary.  Use two transmit descriptors.  We set
            // up the second descriptor before the first one to prevent the Nic from trying
            // to transmit the frame before we are done setting up the two descriptors.

            ppkt->SetFlags(PKTF_XMIT_DUALPAGE);

            pxd0 = pxd;
            pxd  = PxdNext(pxd0);
            _cxdBusy += 1;

            pxd->_dwPhyAddr     = MmGetPhysicalAddress((BYTE *)pv + cb0);
            pxd->_dwFlagsCount  = TXDESC_OWN | TXDESC_TEND | (cb - cb0 - 1);
            pxd0->_dwFlagsCount = TXDESC_OWN | (cb0 - 1);
        }

        _pxdFree = PxdNext(pxd);
        _cxdBusy += 1;

        if (!TestInitFlag(INITF_NIC_STOP))
        {
            // Tell the Nic to check the transmit ring
            PNICCSR pCsr = PNicCsr();
            pCsr->mode = MODE_TXDM;
        }
    }
}

void CXnNic::NicTimer()
{
    ICHECK(NIC, SDPC);

#ifdef XNET_FEATURE_XBDM_CLIENT
    if (_pXbdmServer)
        return;
#endif

    // This function gets called every 200ms from the main timer.  Occasionally, the
    // transmitter will stall with frames on the queue.  If there are any frames queued,
    // we set the MODE_TXDM bit on the Nic hardware to tell it to check the queue.

    if (_cxdBusy > 0)
    {
        PNICCSR pCsr = PNicCsr();
        pCsr->mode = MODE_TXDM;
    }

    // In case we miss a receive interrupt, process any received frames now

    if ((_prdPtr->_dwFlagsCount & RXDESC_OWN) == 0)
    {
        NicRecvInterrupt();
    }
}

NTSTATUS CXnNic::NicInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    NTSTATUS status = BaseInit(pxnip);
    if (!NT_SUCCESS(status))
        return(status);

#ifdef XNET_FEATURE_XBDM_CLIENT

    _pXbdmServer = (CXbdmServer *)KeGetCurrentPrcb()->DmEnetFunc;

    if (_pXbdmServer)
    {
        if (!_pXbdmServer->IsValidServer())
        {
            TraceSz(Warning, "XBDM.DLL is incompatible with this version of XNET.");
            return(NETERR_SYSCALL);
        }

        BOOL fLinkIsUp = FALSE;

        status = _pXbdmServer->InitClient(cfgEnetReceiveQueueLength, cfgEnetTransmitQueueLength,
                                          &_ea, &fLinkIsUp);

        if (!NT_SUCCESS(status))
            return(status);

        SetInitFlag(INITF_NIC);

        if (fLinkIsUp)
        {
            SetInitFlag(INITF_CONNECTED_BOOT);
        }

        return(NETERR_OK);
    }

#elif !defined(XNET_FEATURE_XBDM_SERVER)

    // For xnets.lib (secure library), we cannot have XBDM owning the network stack.
    // If we find that it is running, we tell it to release the NIC hardware now.
    // Note that this code will execute on the retail box, but will have no effect
    // because pXbdmServer will be NULL always.  This code sequence makes it possible
    // to run an XBE linked with xnets.lib on a devkit.

    CXbdmServer * pXbdmServer = (CXbdmServer *)KeGetCurrentPrcb()->DmEnetFunc;

    if (pXbdmServer && pXbdmServer->IsValidServer())
        pXbdmServer->NicStop();

#endif

    SetInitFlag(INITF_NIC);

    StatInit();

    PNICCSR pCsr = PNicCsr();

    _ulIntrVector = HalGetInterruptVector(XPCICFG_NIC_IRQ, &_irqlIntr);

    KeInitializeDpc(&_dpc, NicDpc, this);
    KeInitializeInterrupt(&s_InterruptObject, NicIsr, this, _ulIntrVector,
                          _irqlIntr, LevelSensitive, TRUE);

    NicStopXmitRecv();

    // Reset buffer management

    pCsr->mode = MODE_RESET_BUFFERS;
    KeStallExecutionProcessor(10);
    pCsr->mode = 0;
    KeStallExecutionProcessor(10);

    pCsr->mintr_mk  = 0;
    pCsr->intr_mk   = 0;
    pCsr->pm_cntl   = 0;
    pCsr->swtr_cntl = 0;
    pCsr->tx_poll   = 0;
    pCsr->rx_poll   = 0;
    pCsr->tx_sta    = pCsr->tx_sta;
    pCsr->rx_sta    = pCsr->rx_sta;
    pCsr->mintr     = pCsr->mintr;
    pCsr->intr      = pCsr->intr;

    _crdPool = cfgEnetReceiveQueueLength;

    if (_crdPool > (PAGE_SIZE/2)/sizeof(RecvDesc))
        _crdPool = (PAGE_SIZE/2)/sizeof(RecvDesc);

    _cxdPool = cfgEnetTransmitQueueLength + 1;

    if (_cxdPool > (PAGE_SIZE/2)/sizeof(XmitDesc))
        _cxdPool = (PAGE_SIZE/2)/sizeof(XmitDesc);

    XmitDesc * pxd = NULL;
    UINT cbDma = PAGE_SIZE + (_crdPool * NIC_FRAME_SIZE);

#ifdef XNET_FEATURE_XBDM_SERVER
    // Try allocating the DMA memory in the first 64K if possible under XBDM.
    pxd = (XmitDesc *)HalDmaAlloc(cbDma, 64 * 1024);
#endif

    if (pxd == NULL)
        pxd = (XmitDesc *)HalDmaAlloc(cbDma);

    if (pxd == NULL)
    {
        TraceSz(Warning, "Out of memory allocating DMA receive buffers");
        return(NETERR_MEMORY);
    }

    // Clear the entire first page where the transmit and receive descriptors go

    memset(pxd, 0, PAGE_SIZE);

    // Compute the offset between virtual and physical memory for these descriptors

    _dwPhyOff = MmGetPhysicalAddress(pxd) - (DWORD_PTR)pxd;

    // Fill in the transmit descriptor pointers

    _pxdFirst = pxd;
    _pxdBusy  = pxd;
    _pxdFree  = pxd;
    _pxdLast  = pxd + _cxdPool - 1;

    // Decrement _cxdPool so that we can assume that two transmit descriptors are
    // available whenever _cxdBusy < _cxdPool.  This makes for an easier check later.

    _cxdPool -= 1;

    RecvDesc * prd = (RecvDesc *)((BYTE *)pxd + (PAGE_SIZE/2));

    _prdFirst = prd;
    _prdPtr   = prd;
    _prdLast  = prd + _crdPool - 1;

    // Fill in the RecvDesc to point to the frame buffers.  Notice that we bias the
    // frame pointer by NIC_FRAME_ALIGNMENT (2 bytes).  This is because the CEnetHdr
    // is 14 bytes long, and we'd like the start of the IP packet to be on a four-byte
    // boundary.

    DWORD dwPhyAddr = (DWORD_PTR)pxd + _dwPhyOff + PAGE_SIZE + NIC_FRAME_ALIGNMENT;

    for (; prd <= _prdLast; ++prd, dwPhyAddr += NIC_FRAME_SIZE)
    {
        prd->_dwPhyAddr = dwPhyAddr;
        prd->_dwFlagsCount = RXDESC_OWN | (NIC_FRAME_SIZE - NIC_FRAME_ALIGNMENT - 1);
    }

#ifdef XNET_FEATURE_XBDM_SERVER

    // Allocate and enqueue enough CXbdmPacket structures to satisfy the worst case
    // where the client has completely filled the transmit queue.

    CXbdmPacket * ppktXbdm = (CXbdmPacket *)SysAllocZ((_cxdPool + 1) * sizeof(CXbdmPacket), PTAG_CXbdmPacket);

    if (ppktXbdm == NULL)
    {
        TraceSz(Warning, "Out of memory allocating CXbdmPacket");
        return(NETERR_MEMORY);
    }

    _ppktXbdm = ppktXbdm;

    for (int cPkt = _cxdPool + 1; cPkt > 0; --cPkt, ++ppktXbdm)
    {
        _pqClient.InsertTail(ppktXbdm);
    }

#endif

    ULONG ulType, ulSize;
    status = ExQueryNonVolatileSetting(XC_FACTORY_ETHERNET_ADDR, &ulType, (BYTE *)&_ea, sizeof(CEnetAddr), &ulSize);

    if (!NT_SUCCESS(status) || ulSize != sizeof(CEnetAddr))
    {
        // If we failed to read Ethernet address from non-volatile memory,
        // pick a random even address among the first 64 addresses of
        // the 00-50-f2 address block. This is so that we can at least boot
        // on the manufacturing line and start communicating with the test server.

        TraceSz(Warning, "**************************************************************************");
        TraceSz2(Warning, "Unable to read Ethernet address from EEPROM (status=%08X,ulSize=%d).", status, ulSize);
        TraceSz(Warning, "Run the recovery CD to repair.  Continuing with a random Ethernet address.");
        TraceSz(Warning, "**************************************************************************");

        BYTE bAddr;
        Rand(&bAddr, sizeof(bAddr));
        _ea._ab[1] = 0x50;
        _ea._ab[2] = 0xF2;
        _ea._ab[5] = (BYTE)(bAddr & 0x3E);
    }

    _dwRxPollFreq = RXPOLL_FREQ_100MPS;

#ifdef XNET_FEATURE_XBDM_SERVER

    if (_ea._ab[5] & 1)
    {
        TraceSz(Warning, "***************************************************************************");
        TraceSz1(Warning, "Ethernet address of this Development Kit is incorrect (%s).", _ea.Str());
        TraceSz(Warning, "The last bit of the address should not be set.  Clearing last bit and");
        TraceSz(Warning, "continuing.  There may be conflicts with other network devices as a result.");
        TraceSz(Warning, "***************************************************************************");
        
        _ea._ab[5] &= ~1;
    }

    _eaClient = _ea;    // Title always gets EEPROM address
    _ea._ab[5] |= 1;    // Debug always gets next address

    // Enable unicast reception for the Ethernet address of the title stack

    pCsr->uni0 = HWADDR0(_eaClient._ab);
    pCsr->uni1 = HWADDR1(_eaClient._ab);

    // Enable multicast reception for the Ethernet address of the debug stack

    pCsr->mult_mk0 = 0xFFFFFFFF;
    pCsr->mult_mk1 = 0xFFFF;
    pCsr->mult0    = HWADDR0(_ea._ab);
    pCsr->mult1    = HWADDR1(_ea._ab);

#else

    // Enable unicast reception for the Ethernet address of the title stack

    pCsr->uni0 = HWADDR0(_ea._ab);
    pCsr->uni1 = HWADDR1(_ea._ab);

    // Disable multicast reception

    pCsr->mult_mk0 = 0xFFFFFFFF;
    pCsr->mult_mk1 = 0xFFFF;
    pCsr->mult0    = 0xFFFFFFFF;
    pCsr->mult1    = 0xFFFF;

#endif

    // Setup transmitter and receiver
    // NOTE: nVidia NIC somehow expects the maximum
    // receive buffer size is 1518 instead of 1514.
    Assert(NIC_FRAME_SIZE - NIC_FRAME_ALIGNMENT > 1518);
    pCsr->rx_cntl_1 = 1518;
    pCsr->rx_cntl_0 = RXCNTL_DEFAULT;
    pCsr->tx_cntl = TXCNTL_DEFAULT;

    // Randomly generate a backoff control timeout (single byte), but don't let it
    // be zero because that means no seed (aggressive retry).
    BYTE bBackoff;
    Rand(&bBackoff, sizeof(bBackoff));
    bBackoff += (bBackoff == 0);
    pCsr->bkoff_cntl = (BKOFFCNTL_DEFAULT & 0xFFFFFF00) | bBackoff;

    pCsr->tx_def = TXDEF_DEFAULT;
    pCsr->rx_def = RXDEF_DEFAULT;

    pCsr->tx_dadr = PhyAddr(_pxdFirst);
    pCsr->rx_dadr = PhyAddr(_prdFirst);
    pCsr->dlen = ((_crdPool-1) << 16) | (_cxdPool); // _cxdPool already decremented earlier
    pCsr->rx_fifo_wm = RXFIFOWM_DEFAULT;
    pCsr->tx_fifo_wm = TXFIFOWM_DEFAULT;

    // Enable MII auto-polling interrupt (delay auto-poll enable until after PhyInitialize)
    pCsr->mii_cs = MIICS_DEFAULT & ~MIICS_APEN;
    pCsr->mii_tm = MIITM_DEFAULT;
    KeStallExecutionProcessor(50);

    // Initialize the PHY
    status = PhyInitialize(FALSE, NULL);
    if (!NT_SUCCESS(status))
        return(status);

    pCsr->mii_cs |= MIICS_APEN;
    KeStallExecutionProcessor(50);

    NicMiiInterrupt(0, TRUE);
    NicStartXmitRecv();

    pCsr->mintr = pCsr->mintr;
    pCsr->intr = pCsr->intr;
    pCsr->mintr_mk = MINTR_MAPI;
    pCsr->intr_mk = INTR_ALL;

    if (!KeConnectInterrupt(&s_InterruptObject))
    {
        TraceSz(Warning, "Failed to connect NIC interrupt");
        return(STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT);
    }

    _HalShutdownReg.NotificationRoutine = (PHAL_SHUTDOWN_NOTIFICATION)HalShutdownNotification;
    HalRegisterShutdownNotification(&_HalShutdownReg, TRUE);
    SetInitFlag(INITF_NIC_1);

#ifdef XNET_FEATURE_XBDM_SERVER
    
    KeGetCurrentPrcb()->DmEnetFunc = &_XbdmServer;

#endif

    return(NETERR_OK);
}

void CXnNic::NicStart()
{
    ICHECK(NIC, USER);

    BaseStart();

    Assert(!TestInitFlag(INITF_NIC_STOP));

#ifdef XNET_FEATURE_XBDM_CLIENT
    if (_pXbdmServer)
    {
        _pXbdmServer->AttachClient(&_XbdmClient);
        return;
    }
#endif

    SetInitFlag(INITF_NIC_2);
}

void CXnNic::NicFlush()
{
    TCHECK(UDPC|SDPC);

#ifdef XNET_FEATURE_XBDM_CLIENT
    if (_pXbdmServer)
        return;
#endif

    if (!TestInitFlag(INITF_NIC) || TestInitFlag(INITF_NIC_STOP))
        return;

    // Wait up to half a second for packets queued for transmit to go

    EnetPush();

    PNICCSR pCsr = PNicCsr();

    for (UINT cTimeout = 10000; cTimeout > 0; --cTimeout)
    {
        pCsr->mode = MODE_TXDM;
        NicXmitInterrupt();

        if (_pqXmit.IsEmpty())
            break;

        KeStallExecutionProcessor(50);
    }
}

void CXnNic::NicStop()
{
    TCHECK(UDPC|SDPC);

    if (TestInitFlag(INITF_NIC) && !TestInitFlag(INITF_NIC_STOP))
    {
        if (TestInitFlag(INITF_NIC_1))
        {
            HalRegisterShutdownNotification(&_HalShutdownReg, FALSE);
        }

#ifdef XNET_FEATURE_XBDM_CLIENT
        if (_pXbdmServer)
        {
            _pXbdmServer->DetachClient();
        }
        else
#endif
        {
            if (s_InterruptObject.Connected)
            {
                KeDisconnectInterrupt(&s_InterruptObject);
            }

            KeRemoveQueueDpc(&_dpc);
        }

        SetInitFlag(INITF_NIC_STOP);
    }

    BaseStop();
}

void CXnNic::NicTerm()
{
    TCHECK(UDPC);

    NicStop();

    SetInitFlag(INITF_NIC_TERM);

    if (TestInitFlag(INITF_NIC))
    {
        StatTerm();

        if (!_pqXmit.IsEmpty())
        {
            TraceSz1(Warning, "Nic shutdown with %d packet(s) queued for transmit", _pqXmit.Count());
        }

        while (!_pqXmit.IsEmpty())
        {
            CPacket * ppkt = _pqXmit.RemoveHead();
            MmLockUnlockBufferPages(ppkt->GetEnetHdr(), sizeof(CEnetHdr) + ppkt->GetCb(), TRUE);
            Assert(!ppkt->TestFlags(PKTF_XMIT_XBDMCLIENT));
            PacketFree(ppkt);
        }

        if (_pxdFirst)
        {
            HalDmaFree(_pxdFirst);
        }

#ifdef XNET_FEATURE_XBDM_SERVER
        if (_ppktXbdm)
        {
            SysFree(_ppktXbdm);
        }

        KeGetCurrentPrcb()->DmEnetFunc = NULL;
        Assert(_pXbdmClient == NULL);
#endif

        Assert(!s_InterruptObject.Connected);
    }

    BaseTerm();
}

void CXnNic::HalShutdownNotification(HAL_SHUTDOWN_REGISTRATION * pHalShutdownReg)
{
    KIRQL kirql = ::KeRaiseIrqlToDpcLevel();
    CXnNic * pXnNic = (CXnNic *)((BYTE *)pHalShutdownReg - offsetof(CXnNic, _HalShutdownReg));
    ((CXnIp *)pXnNic)->SecRegShutdown(FALSE);
    pXnNic->NicFlush();
    pXnNic->NicStop();
    ::KeLowerIrql(kirql);
}

// ---------------------------------------------------------------------------------------
// Nic Statistics
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_STATS

void CXnNic::StatInit()
{
    _timerStats.Init((PFNTIMER)StatTimer);
}

void CXnNic::StatTerm()
{
    TimerSet(&_timerStats, TIMER_INFINITE);
}

void CXnNic::StatInc(UINT iStat)
{
    ICHECK(NIC, UDPC|SDPC);

    ULONG * pul = (ULONG *)((BYTE *)&_NicStats + iStat);

    *pul += 1;

#ifdef XNET_FEATURE_TRACE

    if (    Tag(nicStats)
        &&  (   Tag(nicStatsAll)
             || (iStat > offsetof(NICSTATS, rxGoodFrames))))
    {
        if (!_timerStats.IsActive())
        {
            TimerSetRelative(&_timerStats, 5 * TICKS_PER_SECOND);
        }
    }

#endif
}

void CXnNic::StatTimer(CTimer * pt)
{
    ICHECK(NIC, UDPC|SDPC);

    #define DUMPSTAT(n) if (_NicStatsLast.n != _NicStats.n) { TraceSz3(nicStats, "%5d [%5d] %s", _NicStats.n - _NicStatsLast.n, _NicStats.n, #n); }

    TraceSz7(nicStats, "[tx %d] [txq %d/%d] [rx %d] [rxq %d] [isr %d] [dpc %d]",
             _NicStats.txGoodFrames, _cxdBusy, _cxdPool, _NicStats.rxGoodFrames, _crdPool,
             _NicStats.isrCount, _NicStats.dpcCount);

    DUMPSTAT(txUnderflowErrors);
    DUMPSTAT(txLateCollisions);
    DUMPSTAT(txLostCarriers);
    DUMPSTAT(txDefers);
    DUMPSTAT(txExcessiveDefers);
    DUMPSTAT(txRetryErrors);
    DUMPSTAT(rxMinSizeErrors);
    DUMPSTAT(rxFramingErrors);
    DUMPSTAT(rxOverFlowErrors);
    DUMPSTAT(rxCrcErrors);
    DUMPSTAT(rxLengthErrors);
    DUMPSTAT(rxMaxFrameErrors);
    DUMPSTAT(rxLateCollisions);
    DUMPSTAT(rxRunts);
    DUMPSTAT(rxExtraByteErrors);
    DUMPSTAT(rxMissedFrames);
    DUMPSTAT(rxEndOfFrameErrors);
    
    _NicStatsLast = _NicStats;
}

#endif

// ---------------------------------------------------------------------------------------
// CXbdmClient
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_XBDM_CLIENT

INLINE CXnNic * CXnNic::CXbdmClient::GetXnNic()
{
    return((CXnNic *)((BYTE *)this - offsetof(CXnNic, _XbdmClient)));
}

void CXnNic::CXbdmClient::XmitComplete(void * pvPkt)
{
    ((CPacket *)pvPkt)->Complete(GetXnNic());
}

void CXnNic::CXbdmClient::EnetRecv(UINT uiFlags, void * pv, UINT cb, UINT uiType)
{
    CPacket pkt;

    pkt.Init(uiFlags, pv, cb, NULL);

    GetXnNic()->PushPktRecvTags(pkt.GetEnetHdr()->_eaDst.IsBroadcast());
    GetXnNic()->EnetRecv(&pkt, uiType);
    GetXnNic()->PopPktRecvTags();
}

void CXnNic::CXbdmClient::EnetPush()
{
    GetXnNic()->EnetPush();
}

DWORD CXnNic::CXbdmClient::GetXnAddr(XNADDRXBDM * pxnaXbdm)
{
    XNADDR xnaddr;
    DWORD dwFlags = ((CXnIp *)GetXnNic())->IpGetXnAddr(&xnaddr);
    memcpy(pxnaXbdm->abEnet, xnaddr.abEnet, sizeof(pxnaXbdm->abEnet));
    pxnaXbdm->ina = xnaddr.ina;
    return(dwFlags);
}

DWORD CXnNic::NicGetOtherXnAddr(XNADDR * pxna)
{
    XNADDRXBDM xnaddrXbdm = { 0 };
    DWORD dwFlags = _pXbdmServer ? _pXbdmServer->GetXnAddr(&xnaddrXbdm) : XNET_GET_XNADDR_NONE;
    memset(pxna, 0, sizeof(*pxna));
    memcpy(pxna->abEnet, xnaddrXbdm.abEnet, sizeof(pxna->abEnet));
    pxna->ina = xnaddrXbdm.ina;
    return(dwFlags);
}

#endif

// ---------------------------------------------------------------------------------------
// CXbdmServer
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_XBDM_SERVER

INLINE CXnNic * CXnNic::CXbdmServer::GetXnNic()
{
    return((CXnNic *)((BYTE *)this - offsetof(CXnNic, _XbdmServer)));
}

void CXnNic::CXbdmServer::NicStop()
{
    Assert(GetXnNic()->_pXbdmClient == NULL);
    KIRQL irql = ::KeRaiseIrqlToDpcLevel();
    GetXnNic()->NicStop();
    KeGetCurrentPrcb()->DmEnetFunc = NULL;
    ::KeLowerIrql(irql);
}

NTSTATUS CXnNic::CXbdmServer::InitClient(UINT cfgRecvQ, UINT cfgXmitQ, CEnetAddr * pea, BOOL * pfLinkIsUp)
{
    Assert(GetXnNic()->_pXbdmClient == NULL);
    *pea = GetXnNic()->_eaClient;
    *pfLinkIsUp = GetXnNic()->TestInitFlag(INITF_CONNECTED_BOOT);
    return(NETERR_OK);
}

void CXnNic::CXbdmServer::AttachClient(CXbdmClient * pXbdmClient)
{
    Assert(GetXnNic()->_pXbdmClient == NULL);
    KIRQL irql = ::KeRaiseIrqlToDpcLevel();
    GetXnNic()->_pXbdmClient = pXbdmClient;
    ::KeLowerIrql(irql);
}

void CXnNic::CXbdmServer::DetachClient()
{
    Assert(KeGetCurrentIrql() == DISPATCH_LEVEL);

    CXnNic * pXnNic = GetXnNic();
    PNICCSR pCsr = PNicCsr();
    UINT cTimeout = 0;

    while (!pXnNic->_pqXmit.IsEmpty())
    {
        pCsr->mode = MODE_TXDM;
        pXnNic->NicXmitInterrupt();
        KeStallExecutionProcessor(50);
        cTimeout++;
        AssertSz(cTimeout != 20000, "Taking too long to flush transmit queue");
    }

    pXnNic->_pXbdmClient = NULL;
}

void CXnNic::CXbdmServer::Xmit(void * pvPkt, void * pv, UINT cb)
{
    CXnNic * pXnNic = GetXnNic();
    Assert(pXnNic->_pXbdmClient != NULL);
    Assert(!pXnNic->_pqClient.IsEmpty());
    CXbdmPacket * ppktXbdm = (CXbdmPacket *)pXnNic->_pqClient.RemoveHead();
    ppktXbdm->Init(PKTF_XMIT_XBDMCLIENT, (BYTE *)pv + sizeof(CEnetHdr), cb - sizeof(CEnetHdr), NULL);
    ppktXbdm->_pvPkt = pvPkt;
    pXnNic->NicXmit(ppktXbdm);
}

BOOL CXnNic::CXbdmServer::XmitReady()
{
    Assert(GetXnNic()->_pXbdmClient != NULL);
    BOOL fReady = GetXnNic()->NicXmitReady();
    return(fReady);
}

DWORD CXnNic::CXbdmServer::GetXnAddr(XNADDRXBDM * pxnaXbdm)
{
    XNADDR xnaddr;
    DWORD dwFlags = ((CXnIp *)GetXnNic())->IpGetXnAddr(&xnaddr);
    memcpy(pxnaXbdm->abEnet, xnaddr.abEnet, sizeof(pxnaXbdm->abEnet));
    pxnaXbdm->ina = xnaddr.ina;
    return(dwFlags);
}

DWORD CXnNic::NicGetOtherXnAddr(XNADDR * pxna)
{
    XNADDRXBDM xnaddrXbdm = { 0 };
    DWORD dwFlags = _pXbdmClient ? _pXbdmClient->GetXnAddr(&xnaddrXbdm) : XNET_GET_XNADDR_NONE;
    memset(pxna, 0, sizeof(*pxna));
    memcpy(pxna->abEnet, xnaddrXbdm.abEnet, sizeof(pxna->abEnet));
    pxna->ina = xnaddrXbdm.ina;
    return(dwFlags);
}

#endif

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\sources.inc ===
C_DEFINES=$(C_DEFINES) -DNT -DXNET_BUILD_LIB$(LIBTAG)

INCLUDES=\
    $(BASEDIR)\public\sdk\inc; \
    $(BASEDIR)\private\ntos\net; \
    $(BASEDIR)\private\ntos\inc; \
    $(BASEDIR)\private\inc\crypto; \

!if "$(LIBTAG)"=="XW" || "$(LIBTAG)"=="OW"
INCLUDES=$(BASEDIR)\public\wsdk\inc;$(INCLUDES)
UMTYPE=windows
!endif

TARGETPATH=obj
TARGETTYPE=LIBRARY

!if "$(LIBTAG)"=="M"
TARGETNAME=xnetm$(D)
!endif

!if "$(LIBTAG)"=="X"
TARGETNAME=xnet$(D)
TARGETPATH=$(BASEDIR)\public\sdk\lib
!endif

!if "$(LIBTAG)"=="XS"
TARGETNAME=xnets$(D)
TARGETPATH=$(BASEDIR)\public\sdk\lib
!endif

!if "$(LIBTAG)"=="XW"
TARGETNAME=xnetw$(D)
TARGETPATH=$(BASEDIR)\public\sdk\lib
!endif

!if "$(LIBTAG)"=="O"
TARGETNAME=xneto$(D)
!endif

!if "$(LIBTAG)"=="OS"
TARGETNAME=xnetos$(D)
!endif

!if "$(LIBTAG)"=="OW"
TARGETNAME=xnetow$(D)
!endif

MSC_WARNING_LEVEL=/W3 /WX /Ob1

!if defined(GENASM)
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /Fa
!endif

!if $(FREEBUILD) == 0
MSC_OPTIMIZATION=/Odi /Ob1
!endif

PRECOMPILED_INCLUDE=..\xnp.h
PRECOMPILED_PCH=xnp.pch
PRECOMPILED_OBJ=xnp.obj
PRECOMPILED_CXX=1

SOURCES=\
    tcpipxsum.asm \
    base.cpp \
    enet.cpp \
    halw.cpp \
    halx.cpp \
    ip.cpp \
    ipdhcp.cpp \
    ipdns.cpp \
    ipicmp.cpp \
    ipqos.cpp \
    nicw.cpp \
    nicx.cpp \
    sock.cpp \
    socktcp.cpp \
    sockudp.cpp \
    xnet.cpp \
    xnetp.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\sockudp.cpp ===
// ---------------------------------------------------------------------------------------
// sockudp.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(udpWarn, TAG_ENABLE);

// ---------------------------------------------------------------------------------------
// UdpShutdown
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::UdpShutdown(CSocket* pSocket, DWORD dwFlags)
{
    RaiseToDpc();

    if (dwFlags & SOCKF_NOMORE_RECV)
    {
        SockReqComplete(pSocket, pSocket->GetRecvReq(), NETERR(WSAESHUTDOWN));
        SockFlushRecvBuffers(pSocket);
    }

    if (dwFlags & SOCKF_NOMORE_XMIT)
    {
        SockReqComplete(pSocket, pSocket->GetSendReq(), NETERR(WSAESHUTDOWN));
    }

    pSocket->SetFlags(dwFlags);

    return(NETERR_OK);
}

NTSTATUS CXnSock::UdpConnect(CSocket* pSocket, CIpAddr dstaddr, CIpPort dstport)
{
    if (    dstaddr == 0 && dstport != 0
        ||  dstaddr != 0 && dstport == 0
        ||  dstaddr.IsMulticast()
        || (dstaddr.IsLoopback() && dstaddr != IPADDR_LOOPBACK))
    {
        return(NETERR(WSAEADDRNOTAVAIL));
    }

    // Destination hasn't changed, no need to do anything
    if (dstaddr == pSocket->_ipaDst && dstport == pSocket->_ipportDst)
    {
        return(NETERR_OK);
    }

    // Is this socket allowed to send broadcast
    // datagrams on this socket?
    if (dstaddr.IsBroadcast() && !pSocket->TestFlags(SOCKF_OPT_BROADCAST))
    {
        return(NETERR(WSAEACCES));
    }

    RaiseToDpc();

    // If the socket is currently connected,
    // we need to disconnect it first.
    if (pSocket->TestFlags(SOCKF_CONNECTED))
    {
        pSocket->_ipaDst = 0;
        pSocket->_ipportDst = 0;

        if (pSocket->_prte)
        {
            RouteRelease(pSocket->_prte);
            pSocket->_prte = NULL;
        }

        pSocket->ClearFlags(SOCKF_CONNECTED);
    }

    // Discard any received packets that have been
    // queued up but not yet processed
    SockFlushRecvBuffers(pSocket);

    if (dstaddr != 0)
    {
        // Bind to a local address if necessary
        if (!pSocket->TestFlags(SOCKF_BOUND))
        {
            NTSTATUS status = SockBind(pSocket, 0);
            if (!NT_SUCCESS(status))
                return(status);
        }

        pSocket->_ipaDst = dstaddr;
        pSocket->_ipportDst = dstport;
        pSocket->SetFlags(SOCKF_CONNECTED);
    }

    return(NETERR_OK);
}

// ---------------------------------------------------------------------------------------
// UdpRead
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::UdpRead(CSocket * pSocket, CRecvReq * pRecvReq)
{
    CUdpRecvBuf *   pUdpRecvBuf;
    UINT            cbCopy;
    NTSTATUS        status;

    {
        RaiseToDpc();

        if (pSocket->IsUdpRecvBufEmpty())
        {
            return(RecvReqEnqueue(pSocket, pRecvReq));
        }

        //
        // If there is unprocessed datagram,
        // we must not have any pending recv requests.
        // So we can satisfy the request immediately.
        //
        pUdpRecvBuf = (CUdpRecvBuf *)pSocket->DequeueRecvBuf();
        pSocket->SetCbRecvBuf(pSocket->GetCbRecvBuf() - pUdpRecvBuf->GetCbBuf());
    }

    pRecvReq->SetFromAddrPort(pUdpRecvBuf->fromaddr, pUdpRecvBuf->fromport);
    SecRegSetOwned(pUdpRecvBuf->fromaddr);

    if (pUdpRecvBuf->GetCbBuf() <= pRecvReq->buflen)
    {
        cbCopy = pUdpRecvBuf->GetCbBuf();
        pRecvReq->flags = 0;
        status = NETERR_OK;
    }
    else
    {
        cbCopy = pRecvReq->buflen;
        pRecvReq->flags = MSG_PARTIAL;
        status = NETERR_MSGSIZE;
    }

    *pRecvReq->bytesRecv = cbCopy;
    memcpy(pRecvReq->buf, pUdpRecvBuf+1, cbCopy);
    PoolFree(pUdpRecvBuf);

    return(status);
}

// ---------------------------------------------------------------------------------------
// UdpRecv
// ---------------------------------------------------------------------------------------

void CXnSock::UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbData)
{
    TCHECK(SDPC);

    CIpAddr     ipaDst      = pIpHdr->_ipaDst;
    CIpAddr     ipaSrc      = pIpHdr->_ipaSrc;
    CIpPort     ipportDst   = pUdpHdr->_ipportDst;
    CIpPort     ipportSrc   = pUdpHdr->_ipportSrc;
    BYTE *      pbData      = (BYTE *)pUdpHdr + sizeof(CUdpHdr);
    BOOL        fDelivered  = FALSE;
    CSocket *   pSocket;

    Assert(ipportDst != 0);
    Assert(ipportSrc != 0);

    if (ipaDst.IsBroadcast())
    {
        // Insecure broadcast UDP packets in the secure online stack are discarded. 

    #if defined(XNET_FEATURE_ONLINE) && !defined(XNET_FEATURE_INSECURE)
        if (ppkt->IsEsp())
    #endif
        {
            for (pSocket = GetFirstSocket(); pSocket; pSocket = GetNextSocket(pSocket))
            {
                if (    pSocket->GetFlags(SOCKF_TCP|SOCKF_BOUND|SOCKF_NOMORE_RECV) == SOCKF_BOUND
                    &&  (pSocket->_ipportSrc == ipportDst)
                    &&  (pSocket->_ipaDst == ipaSrc || !pSocket->_ipaDst)
                    &&  (pSocket->_ipportDst == ipportSrc || !pSocket->_ipportDst))
                {
                    TraceUdpHdr(pktRecv, pSocket, pUdpHdr, cbData);
                    UdpRecvData(pSocket, ipaSrc, ipportSrc, pbData, cbData);
                    fDelivered = TRUE;
                }
            }
        }
    }
    else
    {
        pSocket = SockFindMatch(ipportDst, ipaSrc, ipportSrc, SOCK_DGRAM);

        if (pSocket && pSocket->TestFlags(SOCKF_BOUND) && !pSocket->TestFlags(SOCKF_NOMORE_RECV))
        {
            // An insecure, non-loopback UDP packet will only be sent to a socket in the
            // secure online stack if the socket has explicitly allowed insecure packets.

        #if defined(XNET_FEATURE_ONLINE) && !defined(XNET_FEATURE_INSECURE)
            if (ppkt->IsEsp() || ppkt->TestFlags(PKTF_RECV_LOOPBACK) || pSocket->TestFlags(SOCKF_INSECURE))
        #endif
            {
                TraceUdpHdr(pktRecv, pSocket, pUdpHdr, cbData);
                UdpRecvData(pSocket, ipaSrc, ipportSrc, pbData, cbData);
                fDelivered = TRUE;
            }
        }
    }

#ifdef XNET_FEATURE_TRACE
    if (!fDelivered)
    {
        if (!ppkt->IsEsp() || ipaDst.IsBroadcast())
            TraceSz4(pktRecv, "[DISCARD] No UDP socket listening on port %d from %s:%d%s",
                     NTOHS(ipportDst), ipaSrc.Str(), NTOHS(ipportSrc),
                     ipaDst.IsBroadcast() ? " (via broadcast)" : "");
        else
            TraceSz3(pktWarn, "[DISCARD] No UDP socket listening on port %d from %s:%d",
                     NTOHS(ipportDst), ipaSrc.Str(), NTOHS(ipportSrc));
    }
#endif
}

void CXnSock::UdpRecvData(CSocket* pSocket, CIpAddr fromaddr, CIpPort fromport, BYTE * pbData, UINT cbData)
{
    if (pSocket->HasRecvReq())
    {
        CRecvReq *      pRecvReq;
        WSAOVERLAPPED * pWsaOverlapped;
        UINT            cbCopy;
        NTSTATUS        status;

        // If there is a pending receive request, then there must not be any receive buffers
        // enqueued on this socket (because they would have been consumed by the receive
        // request already).

        Assert(pSocket->IsUdpRecvBufEmpty());

        pRecvReq        = pSocket->GetRecvReq();
        pWsaOverlapped  = pRecvReq->_pWsaOverlapped;

        pRecvReq->SetFromAddrPort(fromaddr, fromport);
        SecRegSetOwned(fromaddr);

        cbCopy = min(cbData, pRecvReq->GetCbBuf());

        memcpy(pRecvReq->GetPbBuf(), pbData, cbCopy);

        pWsaOverlapped->_ioxfercnt = cbCopy;

        if (cbCopy < cbData)
        {
            pWsaOverlapped->_ioflags = MSG_PARTIAL;
            status = NETERR_MSGSIZE;
            TraceSz3(udpWarn, "[%X] Copied %ld bytes (%ld lost) into overlapped request",
                     pSocket, cbCopy, cbData - cbCopy);
        }
        else
        {
            pWsaOverlapped->_ioflags = 0;
            status = NETERR_OK;
            TraceSz2(pktRecv, "[%X] Copied %ld bytes directly into overlapped request",
                     pSocket, cbCopy);
        }

        SockReqComplete(pSocket, pRecvReq, status);
        return;
    }

    if (pSocket->IsRecvBufFull())
    {
        TraceSz3(udpWarn, "[%X] Receive buffer is full (%ld bytes).  UDP packet plus %ld data bytes lost.",
                 pSocket, pSocket->GetCbRecvBuf(), cbData);
        return;
    }

    // Copy the data into a receive buffer for later reading.
    
    CUdpRecvBuf * pUdpRecvBuf = (CUdpRecvBuf *)PoolAlloc(sizeof(CUdpRecvBuf) + cbData, PTAG_CUdpRecvBuf);

    if (pUdpRecvBuf == NULL)
    {
        TraceSz2(udpWarn, "[%X] Out of memory allocating receive buffer.  Packet and %ld data bytes lost.",
                 pSocket, cbData);
        return;
    }

    pUdpRecvBuf->Init(this);

    memcpy(pUdpRecvBuf + 1, pbData, cbData);
    pUdpRecvBuf->SetCbBuf(cbData);
    pUdpRecvBuf->fromaddr = fromaddr;
    pUdpRecvBuf->fromport = fromport;

    pSocket->SetCbRecvBuf(pSocket->GetCbRecvBuf() + cbData);
    pSocket->EnqueueRecvBuf(pUdpRecvBuf);
    pSocket->SignalEvent(SOCKF_EVENT_READ);

    TraceSz3(pktRecv, "[%X.u] Buffered %ld bytes (%ld available)",
             pSocket, cbData, pSocket->GetCbRecvBuf());
}

// ---------------------------------------------------------------------------------------
// UdpSend
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::UdpSend(CSocket* pSocket, CSendReq * pSendReq, UINT uiFlags)
{
    CSendBuf *      pSendBuf;
    CUdpHdr *       pUdpHdr;
    CIpAddr         ipaDst;
    CRouteEntry **  pprte;

    if (pSendReq->sendtotal > UDP_MAXIMUM_MSS)
    {
        TraceSz3(udpWarn, "[%X] Can't send %ld bytes.  Maximum is %ld bytes.",
                 pSocket, pSendReq->sendtotal, UDP_MAXIMUM_MSS);
        return(NETERR_MSGSIZE);
    }

    Assert((uiFlags & ~(PKTF_POOLALLOC)) == 0);

    uiFlags |= PKTF_TYPE_UDP;

    ipaDst = pSendReq->toaddr ? pSendReq->toaddr->sin_addr.s_addr : pSocket->_ipaDst;

    if (ipaDst.IsSecure())
    {
        uiFlags |= PKTF_TYPE_ESP|PKTF_CRYPT;
    }
    else if (ipaDst.IsBroadcast())
    {
        uiFlags |= PKTF_TYPE_ESP|PKTF_CRYPT;

    #ifdef XNET_FEATURE_INSECURE
        if (cfgFlags & XNET_STARTUP_BYPASS_SECURITY)
        {
            uiFlags &= ~(PKTF_TYPE_ESP|PKTF_CRYPT);
        }
    #endif
    }
    else
    {
    #ifdef XNET_FEATURE_ONLINE
        if (pSocket->TestFlags(SOCKF_INSECURE))
        {
            uiFlags |= PKTF_XMIT_INSECURE;
        }
    #endif
    }

    pSendBuf = (CSendBuf *)PacketAlloc(PTAG_CUdpPacket, uiFlags, pSendReq->sendtotal,
                                       sizeof(CSendBuf), (PFNPKTFREE)UdpPacketFree);

    if (pSendBuf == NULL)
    {
        TraceSz1(udpWarn, "[%X] Out of memory allocating UDP packet", pSocket);
        return(NETERR_MEMORY);
    }

    pSendBuf->Init(pSocket, pSendReq->sendtotal, 2);

    pUdpHdr = pSendBuf->GetUdpHdr();

    // Make a copy of the user data that's passed in

    if (pSendReq->bufcnt == 1)
    {
        memcpy(pUdpHdr + 1, pSendReq->bufs->buf, pSendReq->sendtotal);
    }
    else
    {
        BYTE *      p      = (BYTE *)(pUdpHdr + 1);
        WSABUF *    bufs   = pSendReq->bufs;
        UINT        bufcnt = pSendReq->bufcnt;

        while (bufcnt--)
        {
            memcpy(p, bufs->buf, bufs->len);
            p += bufs->len;
            bufs++;
        }
    }

    if (pSendReq->toaddr)
    {
        pUdpHdr->_ipportSrc = pSocket->_ipportSrc;
        pUdpHdr->_ipportDst = pSendReq->toaddr->sin_port;
        pprte               = NULL;
    }
    else
    {
        pUdpHdr->_ipportSrc = pSocket->_ipportSrc;
        pUdpHdr->_ipportDst = pSocket->_ipportDst;
        pprte               = &pSocket->_prte;
    }

    pUdpHdr->_wLen = HTONS(sizeof(CUdpHdr) + pSendReq->sendtotal);
    pUdpHdr->_wChecksum = 0;

    {
        RaiseToDpc();
        pSocket->IncCbSendBuf(pSendReq->sendtotal);
        pSocket->EnqueueSendBuf(pSendBuf);
        TraceUdpHdr(pktXmit, pSocket, pUdpHdr, pSendReq->sendtotal);
        IpFillAndXmit(pSendBuf, ipaDst, IPPROTOCOL_UDP, pprte);
    }

    return(NETERR_OK);
}

void CXnSock::UdpPacketFree(CPacket * ppkt)
{
    ICHECK(SOCK, UDPC|SDPC);

    CSendBuf * pSendBuf = (CSendBuf *)ppkt;

    if (pSendBuf->Release() > 0)
    {
        CSocket * pSocket = pSendBuf->GetSocket();
        pSocket->DequeueSendBuf(pSendBuf);
        pSocket->DecCbSendBuf(pSendBuf->GetCbBuf());

        if (!pSocket->IsSendBufFull())
        {
            if (pSocket->HasSendReq())
            {
                CSendReq * pSendReq = pSocket->GetSendReq();
                NTSTATUS status = UdpSend(pSocket, pSendReq, PKTF_POOLALLOC);
                pSendReq->_pWsaOverlapped->_ioxfercnt = pSendReq->sendtotal;
                SockReqComplete(pSocket, pSendReq, status);
            }
            else
            {
                pSocket->SignalEvent(SOCKF_EVENT_WRITE);
            }
        }
    }

    PacketFree(ppkt);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\xn.h ===
// ---------------------------------------------------------------------------------------
// xn.h
//
// Exported shared definitions for use by xnet.lib and xonline.lib
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef __XN_H__
#define __XN_H__

#ifndef __cplusplus
#error "xn.h must only be included by a C++ file"
#endif

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#define INLINE __forceinline

#if DBG
#define IFDBG(x)    x
#define IFNDBG(x)
#else
#define IFDBG(x)
#define IFNDBG(x)   x
#endif

// ---------------------------------------------------------------------------------------
// Asserts
// ---------------------------------------------------------------------------------------

INLINE void DbgBreak()
{
    _asm int 3;
}

#ifdef XNET_FEATURE_ASSERT
#ifdef _XBOX
#define DbgAssert(expr,file,line,msg) RtlAssert((PVOID)((msg)?(msg):(expr)),file,line,NULL)
#else
int DbgAssertPop(const char * pszExpr, const char * pszFile, int iLine, const char * pszMsg);
#define DbgAssert(expr,file,line,msg) do { if (DbgAssertPop(expr,file,line,msg)) { DbgBreak(); } } while (0)
#endif
char * __cdecl DbgAssertFmt(char const * pszFmt, ...);
#define ASSERT_BEG(x)   do { if (!(x)) { char * __pch__ = DbgAssertFmt(
#define ASSERT_END(x)   ); DbgAssert(#x,__FILE__,__LINE__,__pch__); } } while (0)
#define Assert(x) \
        do { if (!(x)) { DbgAssert(#x,__FILE__,__LINE__,NULL); } } while (0)
#define AssertSz(x,sz) \
        ASSERT_BEG(x) sz ASSERT_END(x)
#define AssertSz1(x,sz,a1) \
        ASSERT_BEG(x) sz,a1 ASSERT_END(x)
#define AssertSz2(x,sz,a1,a2) \
        ASSERT_BEG(x) sz,a1,a2 ASSERT_END(x)
#define AssertSz3(x,sz,a1,a2,a3) \
        ASSERT_BEG(x) sz,a1,a2,a3 ASSERT_END(x)
#define AssertSz4(x,sz,a1,a2,a3,a4) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4 ASSERT_END(x)
#define AssertSz5(x,sz,a1,a2,a3,a4,a5) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5 ASSERT_END(x)
#define AssertSz6(x,sz,a1,a2,a3,a4,a5,a6) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6 ASSERT_END(x)
#define AssertSz7(x,sz,a1,a2,a3,a4,a5,a6,a7) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7 ASSERT_END(x)
#define AssertSz8(x,sz,a1,a2,a3,a4,a5,a6,a7,a8) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7,a8 ASSERT_END(x)
#define AssertSz9(x,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
        ASSERT_BEG(x) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9 ASSERT_END(x)
#define AssertList(ple) \
        do { const char * __psz__ = DbgVerifyList(ple,NULL); \
        if (__psz__) { DbgAssert("AssertList("#ple")",__FILE__,__LINE__,__psz__); } } while (0)
#define AssertListEntry(ple,pleReq) \
        do { const char * __psz__ = DbgVerifyList(ple,pleReq); \
        if (__psz__) { DbgAssert("AssertListEntry("#ple","#pleReq")",__FILE__,__LINE__,__psz__); } } while (0)
#else
#define Assert(x)
#define AssertSz(x,sz)
#define AssertSz1(x,sz,a1)
#define AssertSz2(x,sz,a1,a2)
#define AssertSz3(x,sz,a1,a2,a3)
#define AssertSz4(x,sz,a1,a2,a3,a4)
#define AssertSz5(x,sz,a1,a2,a3,a4,a5)
#define AssertSz6(x,sz,a1,a2,a3,a4,a5,a6)
#define AssertSz7(x,sz,a1,a2,a3,a4,a5,a6,a7)
#define AssertSz8(x,sz,a1,a2,a3,a4,a5,a6,a7,a8)
#define AssertSz9(x,sz, a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define AssertList(ple)
#define AssertListEntry(ple,pleReq)
#endif

#undef  ASSERT
#define ASSERT(x)   Assert(x)

// ---------------------------------------------------------------------------------------
// Traces
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_TRACE
void __cdecl DbgTrace(const char * szTag, const char * szFmt, ...);
#ifdef XNET_FEATURE_XBDM_SERVER
#define Tag(t)  m_##t
#else
#define Tag(t)  t_##t
#endif
#if defined(_XBOX) || !defined(__cplusplus)
#define TAGINIT(t)
#else
class CTagInit { public: CTagInit(int * pi, const char * pszTag); int i; };
#define TAGINIT(t)          ; CTagInit __init__##t(&Tag(t),#t)
#endif
#define TAG_ENABLE      1
#define TAG_BREAK       2
#define DefineTag(t,i)      int Tag(t) = i TAGINIT(t)
#define ExternTag(t)        extern int Tag(t)
#define TRACE_BEG(t)        do { if (Tag(t) > 0) { DbgTrace(#t,
#define TRACE_END(t)        ); if (Tag(t) > 1) DbgBreak(); } } while (0)
#define TraceSz(t,sz) \
        TRACE_BEG(t) sz TRACE_END(t)
#define TraceSz1(t,sz,a1) \
        TRACE_BEG(t) sz,a1 TRACE_END(t)
#define TraceSz2(t,sz,a1,a2) \
        TRACE_BEG(t) sz,a1,a2 TRACE_END(t)
#define TraceSz3(t,sz,a1,a2,a3) \
        TRACE_BEG(t) sz,a1,a2,a3 TRACE_END(t)
#define TraceSz4(t,sz,a1,a2,a3,a4) \
        TRACE_BEG(t) sz,a1,a2,a3,a4 TRACE_END(t)
#define TraceSz5(t,sz,a1,a2,a3,a4,a5) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5 TRACE_END(t)
#define TraceSz6(t,sz,a1,a2,a3,a4,a5,a6) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6 TRACE_END(t)
#define TraceSz7(t,sz,a1,a2,a3,a4,a5,a6,a7) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7 TRACE_END(t)
#define TraceSz8(t,sz,a1,a2,a3,a4,a5,a6,a7,a8) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8 TRACE_END(t)
#define TraceSz9(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9 TRACE_END(t)
#define TraceSz10(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10 TRACE_END(t)
#define TraceSz11(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11 TRACE_END(t)
#define TraceSz12(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12 TRACE_END(t)
#define TraceSz13(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13 TRACE_END(t)
#define TraceSz14(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14 TRACE_END(t)
#define TraceSz15(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15 TRACE_END(t)
#define TraceSz16(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16) \
        TRACE_BEG(t) sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16 TRACE_END(t)
#else
#define DefineTag(t,i)
#define ExternTag(t)
#define TraceSz(t,sz)
#define TraceSz1(t,sz,a1)
#define TraceSz2(t,sz,a1,a2)
#define TraceSz3(t,sz,a1,a2,a3)
#define TraceSz4(t,sz,a1,a2,a3,a4)
#define TraceSz5(t,sz,a1,a2,a3,a4,a5)
#define TraceSz6(t,sz,a1,a2,a3,a4,a5,a6)
#define TraceSz7(t,sz,a1,a2,a3,a4,a5,a6,a7)
#define TraceSz8(t,sz,a1,a2,a3,a4,a5,a6,a7,a8)
#define TraceSz9(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define TraceSz10(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
#define TraceSz11(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)
#define TraceSz12(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12)
#define TraceSz13(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13)
#define TraceSz14(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14)
#define TraceSz15(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)
#define TraceSz16(t,sz,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16)
#endif

ExternTag(Warning);
ExternTag(Verbose);

// ---------------------------------------------------------------------------------------
// Rip
// ---------------------------------------------------------------------------------------

#ifdef _XBOX
#define Rip(sz) RIP(sz)
#elif defined(XNET_FEATURE_ASSERT)
#define Rip(sz) AssertSz1(0, "RIP: %s", sz)
#else
#define Rip(sz) { DbgPrint("%s", sz); DbgBreak(); }
#endif

// ---------------------------------------------------------------------------------------
// Leak Tracker
// ---------------------------------------------------------------------------------------

typedef const char * (*PFNLEAKTAG)(ULONG tag);

struct CLeakInfo
{
    PFNLEAKTAG      _pfnLeakTag;
    BOOL            _fLeakDisable;
    UINT            _cLeakAlloc;
    UINT            _cLeak;
    struct CLeak *  _pLeak;
};

// ---------------------------------------------------------------------------------------
// VMem (Windows)
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_VMEM

struct VMEMINFO
{
    size_t      cb;
    DWORD       dwFlags;
    size_t      cbFill1;
    size_t      cbFill2;
    void *      pv;
};

#define     VMEM_CHECKED            0x00000001
#define     VMEM_ENABLED            0x00000002
#define     VMEM_BACKSIDESTRICT     0x00000004
#define     VMEM_BACKSIDEALIGN8     0x00000008

BOOL        VMemIsEnabled();
void *      VMemAlloc(size_t cb);
void        VMemFree(void * pv);

#endif

// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

char * HexStr(const void * pv, size_t cb);

#define HTONL_(ul) \
    ((ULONG)((((ul) >> 24) & 0x000000FFL) | (((ul) >>  8) & 0x0000FF00L) | \
             (((ul) <<  8) & 0x00FF0000L) | (((ul) << 24))))

#define NTOHL_(ul) HTONL_(ul)

#define HTONS_(us) \
    ((USHORT)((((us) >> 8) & 0x00FF) | (((us) << 8) & 0xFF00)))

#define NTOHS_(us) HTONS_(us)

INLINE ULONG  HTONL(ULONG  ul) { return(HTONL_(ul)); }
INLINE ULONG  NTOHL(ULONG  ul) { return(NTOHL_(ul)); }
INLINE USHORT HTONS(USHORT us) { return(HTONS_(us)); }
INLINE USHORT NTOHS(USHORT us) { return(NTOHS_(us)); }

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

#define CBDHG1 96
extern "C" const BYTE g_abOakleyGroup1Mod[CBDHG1];
extern "C" const BYTE g_abOakleyGroup1Base[CBDHG1];

struct XOKERBINFO;

#define CBEVENTTIMER    (5 * sizeof(DWORD)) // sizeof(CEventTimer)

// ---------------------------------------------------------------------------------------
// Windows Support
// ---------------------------------------------------------------------------------------

#ifndef _XBOX
    typedef STRING OBJECT_STRING;
    #define RtlInitObjectString RtlInitAnsiString
    #define __OTEXT(quote) quote
    #define OTEXT(quote) __OTEXT(quote)
    #undef InitializeObjectAttributes
    #define InitializeObjectAttributes( p, n, a, r, s ) { (p)->RootDirectory = (r); (p)->Attributes = (a); (p)->ObjectName = (PUNICODE_STRING)(n); }
    #define XBOX_KEY_LENGTH 16
    #define XBOXAPI
    typedef struct _XINPUT_STATE * PXINPUT_STATE;
#endif

#include <xconfig.h>
#include <xonlinep.h>

// ---------------------------------------------------------------------------------------
// Online Support
// ---------------------------------------------------------------------------------------

#if defined(XNET_FEATURE_SG) || defined(XNET_FEATURE_ONLINE)

struct XOUSERINFO
{
    ULONGLONG       _qwUserId;              // User Id
    DWORD           _dwQFlags;              // Queue flags
    DWORD           _dwSeqQFlags;           // Sequence number of queue flags
    DWORD           _dwPState;              // Presence state
    XNKID           _xnkid;                 // Game session user is currently playing
    UINT            _cbData;                // Count of bytes of title data
    BYTE            _abData[MAX_TITLE_STATE_BYTES]; // Custom presence title data
};

#define XN_LOGON_STATE_IDLE         0x0000  // XnLogon not called yet
#define XN_LOGON_STATE_PENDING      0x0001  // XnLogon connection to SG is in progress
#define XN_LOGON_STATE_ONLINE       0x0002  // XnLogon connection to SG is successful
#define XN_LOGON_STATE_OFFLINE      0x0003  // XnLogon connection to SG has been lost

#endif

#ifdef XNET_FEATURE_ONLINE

struct XOKERBINFO
{
    BYTE            _abDhX[CBDHG1];         // Diffie-hellman X
    BYTE            _abDhGX[CBDHG1];        // Diffie-hellman g^X
    BYTE            _abKey[16];             // Session key from ticket
    DWORD           _dwTicketId;            // Ticket identifier
    UINT            _cbApReqMax;            // Maximum size of AP request
    DWORD           _dwUserPerm;            // User permutation and guest bits
};

class CXoBase : public CXNet
{

public:

    // Definitions -----------------------------------------------------------------------

    #define SO_INSECURE                 0x4001  // Special socket option to set socket insecure

    // XNet Support for XOnline ----------------------------------------------------------

    void            XnSetXoBase(CXoBase * pXoBase);
    INLINE void     XnSetInsecure(SOCKET s) { setsockopt(s, SOL_SOCKET, SO_INSECURE, (char *)this, sizeof(CXoBase *)); }
    void            XnLogon(IN_ADDR inaLogon, ULONGLONG * pqwUserId, WSAEVENT hEventLogon);
    DWORD           XnLogonGetStatus(SGADDR * psgaddr);
    BOOL            XnLogonGetQFlags(UINT iUserId, ULONGLONG * pqwUserId, DWORD * pdwQFlags, DWORD * pdwSeqQFlags);
    BOOL            XnLogonSetQFlags(UINT iUserId, DWORD dwQFlags, DWORD dwSeqQFlags);
    BOOL            XnLogonSetPState(UINT iUserId, DWORD dwPState, const XNKID * pxnkid, UINT cbData, BYTE * pbData);
    void            XnLogoff();

    void *          XnLeakAdd(CLeakInfo * pli, void * pv, UINT cb, ULONG tag);
    void *          XnLeakDel(CLeakInfo * pli, void * pv);
    void            XnLeakTerm(CLeakInfo * pli);

    void            XnSetEventTimer(BYTE * pbEventTimer, WSAEVENT hEvent, DWORD dwTimeout);
    void            XnRaiseToDpc(BOOL fRaise);

    // XOnline Support for XNet ----------------------------------------------------------

    BOOL            XoKerbBuildApReq(DWORD dwServiceId, LARGE_INTEGER * pliTime, BYTE * pbSha, UINT cbSha, BYTE * pbApReq, UINT * pcbApReq);
    BOOL            XoKerbCrackApRep(DWORD dwServiceId, LARGE_INTEGER * pliTime, BYTE * pbSha, UINT cbSha, BYTE * pbApRep, UINT cbApRep);
    void            XoKerbGetAuthData(XKERB_AD_XBOX * pAuthData);
    XOKERBINFO *    XoKerbGetInfo(DWORD dwServiceId);

};

#endif

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\sock.cpp ===
// ---------------------------------------------------------------------------------------
// sock.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

#pragma warning(disable:4102)

// ---------------------------------------------------------------------------------------
// Trace tags
// ---------------------------------------------------------------------------------------

DefineTag(sock,     0);
DefineTag(sockWarn, TAG_ENABLE);

// ---------------------------------------------------------------------------------------
// socket
// ---------------------------------------------------------------------------------------

SOCKET CXnSock::socket(IN int af, IN int type, IN int protocol)
{
    WinsockApiProlog_(socket, INVALID_SOCKET);

    ICHECK(SOCK, USER);

    CSocket * pSocket;

    if (af != 0 && af != AF_INET)
        err = WSAEAFNOSUPPORT;
    else if (type != 0 && type != SOCK_STREAM && type != SOCK_DGRAM)
        err = WSAESOCKTNOSUPPORT;
    else if (protocol != 0 && protocol != IPPROTO_TCP && protocol != IPPROTO_UDP)
        err = WSAEPROTONOSUPPORT;
    else
    {
        if (type == 0)
            type = (protocol == IPPROTO_UDP) ? SOCK_DGRAM : SOCK_STREAM;
        if (protocol == 0)
            protocol = (type == SOCK_DGRAM) ? IPPROTO_UDP : IPPROTO_TCP;
        if ((type == SOCK_STREAM) != (protocol == IPPROTO_TCP))
            err = WSAEPROTONOSUPPORT;
    }

    WinsockApiCheckError_(INVALID_SOCKET);

    pSocket = SockAlloc(type == SOCK_STREAM, FALSE);

    if (pSocket == NULL)
    {
        WinsockApiReturnError_(WSAENOBUFS, INVALID_SOCKET);
    }

    RaiseToDpc();
    pSocket->SetFlags(SOCKF_OWNED);
    pSocket->Enqueue(&_leSockets);

    return((SOCKET)pSocket);
}

CSocket * CXnSock::SockAlloc(BOOL fTcp, BOOL fPoolAlloc)
{
    ICHECK(SOCK, USER|UDPC|SDPC);

    CSocket *   pSocket;
    UINT        cb  = fTcp ? sizeof(CTcpSocket) : sizeof(CSocket);
    ULONG       tag = fTcp ? PTAG_CTcpSocket : PTAG_CSocket;

    if (_cSockets >= cfgSockMaxSockets)
    {
        TraceSz(Warning, "Too many sockets");
        return NULL;
    }

    if (fPoolAlloc)
        pSocket = (CSocket *)PoolAllocZ(cb, tag);
    else
        pSocket = (CSocket *)SysAllocZ(cb, tag);

    if (pSocket)
    {
        pSocket->Init(this, fTcp, fPoolAlloc);

        if (fTcp)
        {
            ((CTcpSocket *)pSocket)->TcpInit(this);
        }

        InterlockedIncrement((LONG *)&_cSockets);
    }

    return(pSocket);
}

// ---------------------------------------------------------------------------------------
// closesocket
// ---------------------------------------------------------------------------------------

int CXnSock::closesocket(IN SOCKET s)
{
    WinsockApiPrologSockLock_(closesocket, SOCKET_ERROR);

    RaiseToDpc();

    if (pSocket == NULL)
        err = NETERR_PARAM;
    else if (pSocket->TestFlags(SOCKF_CLOSED))
    {
        SockFree(pSocket);
        err = 0;
    }
    else
    {
        pSocket->ClearFlags(SOCKF_OWNED);
        err = SockClose(pSocket, FALSE);
    }

    MapNtStatusToWinsockError_(err);

    // Don't call SockUnlock here because the socket is most likely deallocated by now

    WinsockApiCheckError_(SOCKET_ERROR);
    return NO_ERROR;
}

NTSTATUS CXnSock::SockClose(CSocket * pSocket, BOOL fForce)
{
    RaiseToDpc();

    // If a TCP is being gracefully closed, then we'll
    // leave the the CSocket structure in the global list
    // until the connection is really gone.
    if (pSocket->IsTcp() && !TcpClose((CTcpSocket *)pSocket, fForce))
    {
        pSocket->SetFlags(SOCKF_NOMORE_XMIT|SOCKF_NOMORE_RECV|SOCKF_LINGERING);
        pSocket->SetClosed();
        return(NETERR_OK);
    }

    pSocket->Dequeue();

    // Clean up the information associated with the CSocket
    SockCleanup(pSocket);

    Assert(!pSocket->IsTcp() || !((CTcpSocket *)pSocket)->GetTimer()->IsActive());

    EvtTerm(pSocket->GetEvent());

    InterlockedDecrement((LONG *)&_cSockets);

    if (pSocket->TestFlags(SOCKF_OWNED))
        pSocket->SetFlags(SOCKF_CLOSED);
    else
        SockFree(pSocket);

    return(NETERR_OK);
}

void CXnSock::SockFree(CSocket * pSocket)
{
    // Mark socket as closed even though we are freeing the memory just in case the
    // user tries to access it anyways.

    pSocket->SetClosed();

    if (pSocket->TestFlags(SOCKF_POOLALLOC))
        PoolFree(pSocket);
    else
        SysFree(pSocket);
}

void CXnSock::SockCleanup(CSocket * pSocket)
{
    ICHECK(SOCK, UDPC|SDPC);

    NTSTATUS status;

    status = NT_SUCCESS(pSocket->GetStatus()) ? NETERR_CANCELLED : pSocket->GetStatus();

    SockReqComplete(pSocket, pSocket->GetRecvReq(), status);
    SockReqComplete(pSocket, pSocket->GetSendReq(), status);

    // Flush receive buffers

    SockFlushRecvBuffers(pSocket);

    // Flush send buffers

    while (pSocket->HasSendBuf())
    {
        CSendBuf * pSendBuf = pSocket->DequeueSendBuf();
        SockReleaseSendBuf(pSendBuf);
    }

    pSocket->SetCbSendBuf(0);

    if (pSocket->_prte)
    {
        RouteRelease(pSocket->_prte);
        pSocket->_prte = NULL;
    }
}

void CXnSock::SockReleaseSendBuf(CSendBuf * pSendBuf)
{
    if (pSendBuf->Release() == 0)
        PacketFree(pSendBuf);
    else
        pSendBuf->SetPfn((PFNPKTFREE)PacketFree);
}

//
// Flush a socket's receive buffers
//
void CXnSock::SockFlushRecvBuffers(CSocket * pSocket)
{
    while (pSocket->HasRecvBuf())
    {
        PoolFree(pSocket->DequeueRecvBuf());
    }

    pSocket->SetCbRecvBuf(0);
}

// ---------------------------------------------------------------------------------------
// shutdown
// ---------------------------------------------------------------------------------------

int CXnSock::shutdown(IN SOCKET s, IN int how)
{
    DWORD dwFlags;
    WinsockApiPrologSockLock_(shutdown, SOCKET_ERROR);

    WinsockApiParamCheck_(
        how == SD_SEND ||
        how == SD_RECEIVE ||
        how == SD_BOTH);

    switch (how) {
    case SD_SEND:
        dwFlags = SOCKF_NOMORE_XMIT;
        break;

    case SD_RECEIVE:
        dwFlags = SOCKF_NOMORE_RECV;
        break;

    default:
        dwFlags = SOCKF_NOMORE_XMIT|SOCKF_NOMORE_RECV;
        break;
    }

    if (pSocket->IsUdp())
    {
        err = UdpShutdown(pSocket, dwFlags);
    }
    else
    {
        if (!pSocket->TestFlags(SOCKF_CONNECTED))
        {
            WinsockApiGotoExit_(WSAENOTCONN);
        }
        err = TcpShutdown((CTcpSocket*) pSocket, dwFlags, TRUE);
    }

    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// ioctlsocket
// ---------------------------------------------------------------------------------------

int CXnSock::ioctlsocket(SOCKET s, long cmd, u_long* argp)
{
    KIRQL irql;
    UINT bytesReady;

    WinsockApiPrologSockLock_(ioctlsocket, SOCKET_ERROR);
    WinsockApiParamCheck_(argp != NULL);

    switch (cmd) {
    case FIONBIO:
        pSocket->SetFlags((*argp) ? SOCKF_OPT_NONBLOCKING : 0, SOCKF_OPT_NONBLOCKING);
        break;

    case FIONREAD:
    {
        RaiseToDpc();

        if (pSocket->IsUdp())
        {
            // For UDP sockets, return the size of the first buffered datagram
            // NOTE: For compatibility with win2k behavior, if the first datagram
            // is 0-sized, we'll return 1.
            if (pSocket->IsUdpRecvBufEmpty())
            {
                bytesReady = 0;
            }
            else
            {
                bytesReady = ((CUdpRecvBuf *)pSocket->GetRecvBufFirst())->GetCbBuf();
                if (bytesReady == 0)
                    bytesReady = 1;
            }
        }
        else
        {
            // For TCP sockets, return the total number of bytes
            // available for reading.
            bytesReady = pSocket->GetCbRecvBuf();
        }
        *argp = bytesReady;
        break;
    }
    
    // case SIOCATMARK:
    default:
        WinsockApiGotoExit_(WSAENOPROTOOPT);
        break;
    }

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// setsockopt
// ---------------------------------------------------------------------------------------

int CXnSock::setsockopt(SOCKET s, int level, int optname, const char* optval, int optlen)
{
    INT val;
    WinsockApiPrologSockLock_(setsockopt, SOCKET_ERROR);
    WinsockApiParamCheck_(optval != NULL && optlen > 0);

    if (optlen < (INT) sizeof(INT))
        val = (UCHAR) *optval;
    else
        val = *((INT*) optval);

    switch (level)
    {
        case SOL_SOCKET:
        {
            RaiseToDpc();

            // NOTE: Some options may not be applicable to datagram sockets,
            // while others may not be applicable to stream sockets. But
            // we'll let apps set those options here anyway (to avoid extra
            // checking code). Downstream code just won't use those 

            switch (optname)
            {
                case SO_BROADCAST:
                    if (pSocket->IsTcp()) goto noopt;
                    pSocket->SetFlags(val ? SOCKF_OPT_BROADCAST : 0, SOCKF_OPT_BROADCAST);
                    break;

                case SO_DONTLINGER:
                    if (pSocket->IsUdp()) goto noopt;
                    ((CTcpSocket *)pSocket)->SetLingerOnOff(!val);
                    break;

                case SO_LINGER:
                    if (pSocket->IsUdp()) goto noopt;
                    WinsockApiParamCheck_(optlen >= sizeof(LINGER));
                    ((CTcpSocket *)pSocket)->SetLinger((LINGER *)optval);
                    break;

                case SO_REUSEADDR:
                    if (pSocket->TestFlags(SOCKF_OPT_REUSEADDR) && val != 0) goto inval;
                    pSocket->SetFlags(val? SOCKF_OPT_REUSEADDR : 0, SOCKF_OPT_REUSEADDR);
                    break;

                case SO_EXCLUSIVEADDRUSE:
                    if (pSocket->TestFlags(SOCKF_OPT_EXCLUSIVEADDR) && val != 0) goto inval;
                    pSocket->SetFlags(val ? SOCKF_OPT_EXCLUSIVEADDR : 0, SOCKF_OPT_EXCLUSIVEADDR);
                    break;

                case SO_RCVTIMEO:
                    // Timeout value is in milliseconds
                    WinsockApiParamCheck_(optlen >= sizeof(INT));
                    pSocket->_uiRecvTimeout = val;
                    break;

                case SO_SNDTIMEO:
                    // Timeout value is in milliseconds
                    WinsockApiParamCheck_(optlen >= sizeof(INT));
                    pSocket->_uiSendTimeout = val;
                    break;

                case SO_RCVBUF:
                    WinsockApiParamCheck_(optlen >= sizeof(INT));
                    err = SockUpdateBufferSize(pSocket, pSocket->_cbMaxSendBuf, val);
                    if (!NT_SUCCESS(err)) goto inval;
                    break;

                case SO_SNDBUF:
                    WinsockApiParamCheck_(optlen >= sizeof(INT));
                    err = SockUpdateBufferSize(pSocket, val, pSocket->_cbMaxRecvBuf);
                    if (!NT_SUCCESS(err)) goto inval;
                    break;

#ifdef XNET_FEATURE_ONLINE

                case SO_INSECURE:
                    if (optlen == sizeof(CXoBase *) && optval == (char *)IpGetXoBase())
                        pSocket->SetFlags(SOCKF_INSECURE);
                    break;

#endif

                default:
                    goto noopt;
            }
            break;
        }

        case IPPROTO_TCP:
        {
            if (pSocket->IsUdp()) goto noopt;

            switch (optname) {
            case TCP_NODELAY:
                pSocket->SetFlags(val ? SOCKF_OPT_NONAGLE : 0, SOCKF_OPT_NONAGLE);
                break;

            default:
                goto noopt;
            }
            break;
        }

        default:
            goto inval;
    }

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);

inval:
    err = WSAEINVAL;
    goto exit;

noopt:
    err = WSAENOPROTOOPT;
    goto exit;
}

NTSTATUS CXnSock::SockUpdateBufferSize(CSocket* pSocket, INT sendBufsize, INT recvBufsize)

/*++

Routine Description:

    Update the send and receive buffer sizes

Arguments:

    pSocket - Points to the CSocket structure
    sendBufsize, recvBufsize - 
        Specifies the new send and receive buffer sizes

Return Value:

    Status code

--*/

{
    ICHECK(SOCK, UDPC);

    NTSTATUS status;

    if (sendBufsize > (INT) cfgSockMaxSendBufsizeInK * 1024)
        sendBufsize = (INT) cfgSockMaxSendBufsizeInK * 1024;
    else if (sendBufsize <= 0) {
        // NOTE: we never set actual send buffer size to 0
        // because we don't support the no-buffering option.
        sendBufsize = 1;
    }

    if (recvBufsize > (INT) cfgSockMaxRecvBufsizeInK * 1024)
        recvBufsize = (INT) cfgSockMaxRecvBufsizeInK * 1024;
    else if (recvBufsize <= 0)
        recvBufsize = 0;

    status = NETERR_OK;

    if (pSocket->IsUdp())
    {
        // For datagram sockets, we'll just update the send and
        // receive buffers sizes. If the current buffers are bigger
        // than the specified limits, we'll leave the current data alone.
        pSocket->_cbMaxSendBuf = sendBufsize;
        pSocket->_cbMaxRecvBuf = recvBufsize;
    }
    else
    {
        CTcpSocket* pTcpSocket = (CTcpSocket*) pSocket;

        // Set the send buffer size. If the current send buffer size
        // is larger than the specified limit, leave the current data untouched.
        pTcpSocket->_cbMaxSendBuf = sendBufsize;
        
        // If the TCP socket is already connected,
        // don't allow the app to reduce the receive buffer size.
        if (!pTcpSocket->IsIdleState() && recvBufsize < (INT) pTcpSocket->_cbMaxRecvBuf)
        {
            status = NETERR_PARAM;
        }
        else
        {
            // NOTE: we don't update receive window to the connection peer
            // right away. The new window information will be sent
            // in the next outgoing ACK segment.
            pTcpSocket->_cbMaxRecvBuf = recvBufsize;
        }
    }

    // NOTE: If the send buffer has just opened up,
    // we don't check to see if there is any pending
    // overlapped send request that can be started.
    // Rather the overlapped send request will be started
    // by the normal process.

    return(status);
}

// ---------------------------------------------------------------------------------------
// getsockopt
// ---------------------------------------------------------------------------------------

int CXnSock::getsockopt(SOCKET s, int level, int optname, char * optval, int * optlen)
{
    INT val;
    WinsockApiPrologSockLock_(getsockopt, SOCKET_ERROR);

    WinsockApiParamCheck_(
        optval != NULL &&
        optlen != NULL &&
        *optlen > 0);

    memset(optval, 0, *optlen);

    switch (level) {
    case SOL_SOCKET:

        switch (optname) {
        case SO_BROADCAST:
            if (pSocket->IsTcp()) goto noopt;
            val = pSocket->TestFlags(SOCKF_OPT_BROADCAST);
            break;

        case SO_DONTLINGER:
            if (pSocket->IsUdp()) goto noopt;
            val = !((CTcpSocket *)pSocket)->GetLingerOnOff();
            break;

        case SO_LINGER:
            if (pSocket->IsUdp()) goto noopt;
            WinsockApiParamCheck_(*optlen >= sizeof(LINGER));
            ((CTcpSocket *)pSocket)->GetLinger((LINGER *)optval);
            *optlen = sizeof(LINGER);
            goto exit;

        case SO_REUSEADDR:
            val = pSocket->TestFlags(SOCKF_OPT_REUSEADDR);
            break;

        case SO_EXCLUSIVEADDRUSE:
            val = pSocket->TestFlags(SOCKF_OPT_EXCLUSIVEADDR);
            break;

        case SO_RCVTIMEO:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pSocket->_uiRecvTimeout;
            break;

        case SO_SNDTIMEO:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pSocket->_uiSendTimeout;
            break;

        case SO_RCVBUF:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pSocket->_cbMaxRecvBuf;
            break;

        case SO_SNDBUF:
            WinsockApiParamCheck_(*optlen >= sizeof(INT));
            val = pSocket->_cbMaxSendBuf;
            break;

        case SO_TYPE:
            val = pSocket->IsUdp() ? SOCK_DGRAM : SOCK_STREAM;
            break;

        case SO_ACCEPTCONN:
            if (pSocket->IsUdp()) goto noopt;
            val = ((CTcpSocket *)pSocket)->IsListenState();
            break;

        default:
            goto noopt;
        }
        break;

    case IPPROTO_TCP:
        if (pSocket->IsUdp())
            goto noopt;

        switch (optname) {
        case TCP_NODELAY:
            val = pSocket->TestFlags(SOCKF_OPT_NONAGLE);
            break;

        default:
            goto noopt;
        }
        break;

    default:
        err = WSAEINVAL;
        goto exit;
    }

    if (*optlen < sizeof(INT)) {
        *optval = (CHAR) val;
        *optlen = 1;
    } else {
        *((INT*) optval) = val;
        *optlen = sizeof(INT);
    }

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);

noopt:
    err = WSAENOPROTOOPT;
    goto exit;
}

// ---------------------------------------------------------------------------------------
// getsockname
// ---------------------------------------------------------------------------------------

int CXnSock::getsockname(SOCKET s, struct sockaddr* name, int* namelen)
{
    struct sockaddr_in* sin;
    WinsockApiPrologSockLock_(getsockname, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen != NULL &&
        *namelen >= SOCKADDRLEN);

    if (!pSocket->TestFlags(SOCKF_BOUND))
    {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    sin = (struct sockaddr_in*) name;
    memset(sin, 0, SOCKADDRLEN);
    sin->sin_family = AF_INET;
    sin->sin_port = pSocket->_ipportSrc;
    sin->sin_addr.s_addr = 0;

    *namelen = SOCKADDRLEN;
    err = NO_ERROR;

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// getpeername
// ---------------------------------------------------------------------------------------

int CXnSock::getpeername(SOCKET s, struct sockaddr * name, int * namelen)
{
    struct sockaddr_in* sin;
    WinsockApiPrologSockLock_(getpeername, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen != NULL &&
        *namelen >= SOCKADDRLEN);

    if (!pSocket->TestFlags(SOCKF_CONNECTED)) {
        WinsockApiGotoExit_(WSAENOTCONN);
    }

    sin = (struct sockaddr_in*) name;
    sin->sin_family = AF_INET;
    sin->sin_port = pSocket->_ipportDst;
    sin->sin_addr.s_addr = pSocket->_ipaDst;
    memset(sin->sin_zero, 0, sizeof(sin->sin_zero));

    *namelen = SOCKADDRLEN;
    err = NO_ERROR;

    SecRegSetOwned(sin->sin_addr.s_addr);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// bind
// ---------------------------------------------------------------------------------------

int CXnSock::bind(SOCKET s, const struct sockaddr * name, int namelen)
{
    const struct sockaddr_in* sin = (const struct sockaddr_in*) name;
    WinsockApiPrologSockLock_(bind, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen >= SOCKADDRLEN &&
        sin->sin_family == AF_INET &&
        sin->sin_addr.s_addr == 0);

    if (pSocket->TestFlags(SOCKF_BOUND))
    {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    if (sin->sin_addr.s_addr != 0)
    {
        WinsockApiGotoExit_(WSAEADDRNOTAVAIL);
    }

    err = SockBind(pSocket, sin->sin_port);

    MapNtStatusToWinsockError_(err);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

NTSTATUS CXnSock::SockBind(CSocket * pSocket, CIpPort ipportBind)

/*++

Routine Description:

    Bind a socket to the specified local address

Arguments:

    pSocket - Points to the protocol control block
    srcaddr, srcport - Specifies the local socket address

Return Value:

    Status code

--*/

{
    int cRetry = ipportBind ? 0 : min(cfgSockMaxSockets, TEMP_PORT_COUNT);
    CSocket * pSocketCur;

    RaiseToDpc();

    Assert(!pSocket->TestFlags(SOCKF_BOUND));

    while (1)
    {
        if (cRetry-- > 0)
        {
            while (1)
            {
                _ipportTempNext += 1;

                if (_ipportTempNext > MAX_TEMP_PORT)
                    _ipportTempNext = MIN_TEMP_PORT;

                if (_ipportTempNext != NTOHS(ESPUDP_CLIENT_PORT))
                    break;
            }

            ipportBind = HTONS((WORD)_ipportTempNext);
        }

        for (pSocketCur = GetFirstSocket(); pSocketCur; pSocketCur = GetNextSocket(pSocketCur))
        {
            if (pSocketCur->TestFlags(SOCKF_BOUND))
            {
                Assert(pSocketCur != pSocket);

                if (    (pSocketCur->IsUdp() == pSocket->IsUdp())
                    &&  (pSocketCur->_ipportSrc == ipportBind)
                    &&  (   pSocketCur->TestFlags(SOCKF_OPT_EXCLUSIVEADDR)
                        ||  pSocket->TestFlags(SOCKF_OPT_EXCLUSIVEADDR)
                        || !pSocket->TestFlags(SOCKF_OPT_REUSEADDR)))
                {
                    break;
                }
            }
        }

        if (pSocketCur == NULL)
        {
            pSocket->_ipportSrc = ipportBind;
            pSocket->SetFlags(SOCKF_BOUND);
            return(NETERR_OK);
        }

        if (cRetry <= 0)
        {
            return(NETERR_ADDRINUSE);
        }
    }
}

// ---------------------------------------------------------------------------------------
// connect
// ---------------------------------------------------------------------------------------

int CXnSock::connect(SOCKET s, const struct sockaddr * name, int namelen)
{
    const struct sockaddr_in* sin = (const struct sockaddr_in*) name;
    CIpAddr dstaddr;
    CIpPort dstport;
    WinsockApiPrologSockLock_(connect, SOCKET_ERROR);

    WinsockApiParamCheck_(
        name != NULL &&
        namelen >= SOCKADDRLEN &&
        sin->sin_family == AF_INET);

    if (pSocket->TestFlags(SOCKF_CONNECTED) && pSocket->IsTcp()) {
        WinsockApiGotoExit_(WSAEISCONN);
    }

    dstaddr = sin->sin_addr.s_addr;
    dstport = sin->sin_port;
    if (pSocket->IsUdp())
    {
        err = UdpConnect(pSocket, dstaddr, dstport);
    }
    else if (pSocket->TestFlags(SOCKF_OPT_NONBLOCKING))
    {
        err = TcpConnect((CTcpSocket*) pSocket, dstaddr, dstport, FALSE);

        // For nonblocking socket, we'll return WSAEWOULDBLOCK
        // error code but the operation proceeds.
        if (NT_SUCCESS(err)) err = NETERR_WOULDBLOCK;
    }
    else
    {
        err = TcpConnect((CTcpSocket*) pSocket, dstaddr, dstport, FALSE);
        if (NT_SUCCESS(err))
        {
            // For blocking socket, we need to wait here for
            // the operation to complete.
            err = SockWaitForEvent(pSocket, SOCKF_EVENT_CONNECT, 0);
            pSocket->SetFlags(SOCKF_CONNECT_SELECTED);
        }
    }

    MapNtStatusToWinsockError_(err);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// listen
// ---------------------------------------------------------------------------------------

int CXnSock::listen(SOCKET s, int backlog)
{
    WinsockApiPrologSockLock_(listen, SOCKET_ERROR);

    WinsockApiParamCheck_(pSocket->IsTcp());

    if (pSocket->TestFlags(SOCKF_CONNECTED))
    {
        WinsockApiGotoExit_(WSAEISCONN);
    }

    if (!pSocket->TestFlags(SOCKF_BOUND))
    {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    err = TcpListen((CTcpSocket*) pSocket, backlog);
    MapNtStatusToWinsockError_(err);

    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// accept
// ---------------------------------------------------------------------------------------

SOCKET CXnSock::accept(SOCKET s, struct sockaddr * addr, int * addrlen)
{
    CTcpSocket * pTcpSocketChild = NULL;

    WinsockApiPrologSockLock_(accept, INVALID_SOCKET);

    WinsockApiParamCheck_(
        pSocket->IsTcp() &&
        (addr == NULL ||
         addrlen != NULL && *addrlen >= SOCKADDRLEN));

    CTcpSocket * pTcpSocket = (CTcpSocket *)pSocket;

    if (!pTcpSocket->IsTcp() || !pTcpSocket->IsListenState())
    {
        WinsockApiGotoExit_(WSAEINVAL);
    }

    while (1)
    {
        {
            RaiseToDpc();
            pTcpSocketChild = pTcpSocket->DequeueConnectedChild();
        }

        if (pTcpSocketChild)
            break;

        // For nonblocking socket, return an error code
        // if we don't have any pending connection requests.

        if (pTcpSocket->TestFlags(SOCKF_OPT_NONBLOCKING))
        {
            WinsockApiGotoExit_(WSAEWOULDBLOCK);
        }

        // For blocking sockets, wait until there
        // is a connection request.

        err = SockWaitForEvent(pSocket, SOCKF_EVENT_ACCEPT, 0);

        if (err != 0)
            break;
    }

    MapNtStatusToWinsockError_(err);

    if (pTcpSocketChild)
    {
        pTcpSocketChild->SetFlags(SOCKF_OWNED);

        if (addr && addrlen)
        {
            struct sockaddr_in* sin;

            sin = (struct sockaddr_in*) addr;
            sin->sin_family = AF_INET;
            sin->sin_port = pTcpSocketChild->_ipportDst;
            sin->sin_addr.s_addr = pTcpSocketChild->_ipaDst;
            memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
            *addrlen = SOCKADDRLEN;

            SecRegSetOwned(pTcpSocketChild->_ipaDst);
        }
    }

    WinsockApiExitSockUnlock_((SOCKET) pTcpSocketChild, INVALID_SOCKET);
}

// ---------------------------------------------------------------------------------------
// select
// ---------------------------------------------------------------------------------------

//
// Count the total number of socket handles
//
#define SOCKETS_IN_SET(_set) ((_set) ? ((_set)->fd_count & 0xffff) : 0)

//
// Select event masks
//
#define SELECT_READ_EVENTS (SOCKF_EVENT_READ|SOCKF_EVENT_ACCEPT|SOCKF_EVENT_CLOSE|SOCKF_EVENT_RESET)
#define SELECT_WRITE_EVENTS (SOCKF_EVENT_WRITE|SOCKF_EVENT_CONNECT)
#define SELECT_EXCEPT_EVENTS (SOCKF_EVENT_RESET)

//
// Number of KWAIT_BLOCKs allocated on the stack for select() calls.
//
#define SELECT_STACK_KWAIT_BLOCKS 3

int CXnSock::select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, const struct timeval* timeout)
{
    SELECTINFO tempinfo;
    PRKEVENT tempevent;
    SELECTINFO* selinfo;
    PRKEVENT* events;
    INT index, rdcnt, rwcnt, selcnt = 0;
    CSocket* pSocket;
    LARGE_INTEGER waittime;
    LARGE_INTEGER* pwait;
#ifdef XNET_FEATURE_XBOX
    KWAIT_BLOCK tempWaitBlocks[SELECT_STACK_KWAIT_BLOCKS];
    PKWAIT_BLOCK waitBlockArray = tempWaitBlocks;
#endif

    WinsockApiProlog_(select, SOCKET_ERROR);

    // Count the total number of sockets
    // (ignore the input nfds parameter)
    rdcnt = SOCKETS_IN_SET(readfds);
    rwcnt = rdcnt + SOCKETS_IN_SET(writefds);
    nfds = rwcnt + SOCKETS_IN_SET(exceptfds);

    if (nfds == 0) {
        WinsockApiReturnError_(WSAEINVAL, SOCKET_ERROR);
    }

    if (nfds == 1) {
        // Use temporary stack buffers for the special case
        // where there is only one socket. This saves us from
        // two extra memory allocations.
        events = &tempevent;
        selinfo = &tempinfo;
        memset(selinfo, 0, sizeof(SELECTINFO));
    } else {
        selinfo = (SELECTINFO*) SysAllocZ(nfds*sizeof(SELECTINFO), PTAG_select);
        events = (PRKEVENT*) SysAlloc(nfds*sizeof(PRKEVENT), PTAG_select);
        if (!selinfo || !events) {
            nfds = 0;
            WinsockApiGotoExit_(WSAENOBUFS);
        }
    }

    // Lock all the socket handles
    if ((err = SockLockSelectSockets(readfds, selinfo, 0, SELECT_READ_EVENTS)) != 0 ||
        (err = SockLockSelectSockets(writefds, selinfo, rdcnt, SELECT_WRITE_EVENTS)) != 0 ||
        (err = SockLockSelectSockets(exceptfds, selinfo, rwcnt, SELECT_EXCEPT_EVENTS)) != 0) {
        goto exit;
    }

    // Compute the wait time in 100ns unit
    if (timeout) {
        pwait = &waittime;
#ifdef XNET_FEATURE_XBOX
        waittime.QuadPart = Int32x32To64(timeout->tv_sec, -10000000) +
                            Int32x32To64(timeout->tv_usec, -10);
#else
        waittime.QuadPart = timeout->tv_sec * 1000 + timeout->tv_usec / 1000;
#endif
    } else {
        pwait = NULL;
    }

    // Check if we to wait:
    // if we do, set up the socket event flags
    if (!pwait || pwait->QuadPart) {
        INT waitCount = 0;
        for (index=0; index < nfds; index++) {
            pSocket = selinfo[index].pSocket;
            if (selinfo[index].pSocketMasks) {
                if (SockCheckSelectEvents(pSocket, selinfo[index].pSocketMasks, -1)) break;
                events[waitCount++] = pSocket->GetEvent();
            }
        }

        if (index == nfds) {

#ifdef XNET_FEATURE_XBOX
            if (waitCount > SELECT_STACK_KWAIT_BLOCKS) {
                waitBlockArray = (PKWAIT_BLOCK) SysAllocZ(waitCount * sizeof(KWAIT_BLOCK), PTAG_select);
                if (!waitBlockArray) {
                    WinsockApiGotoExit_(WSAENOBUFS);
                }
            }

#ifdef XNET_FEATURE_XBDM_SERVER

            do {
                err = KeWaitForMultipleObjects(
                            waitCount,
                            (void **)events,
                            WaitAny,
                            UserRequest,
                            KernelMode,
                            TRUE,
                            pwait,
                            waitBlockArray);
            } while(err == STATUS_KERNEL_APC);

            if(err == STATUS_ALERTED)
                err = STATUS_TIMEOUT; 

#else

            err = KeWaitForMultipleObjects(
                        waitCount,
                        (void **)events,
                        WaitAny,
                        UserRequest,
                        UserMode,
                        FALSE,
                        pwait,
                        waitBlockArray);

#endif // XBDM

            if ((err < 0 || err >= waitCount) && err != STATUS_TIMEOUT) {
                WinsockApiGotoExit_(WSAEFAULT);
            }
#else
            err = WaitForMultipleObjects(waitCount, (HANDLE *)events, FALSE, (DWORD)waittime.QuadPart);
            if (err == WAIT_FAILED)
                WinsockApiGotoExit_(WSAEFAULT);
#endif
        }
    }

    // Determine which socket events are ready
    // and return appropriate information

    if (readfds) { FD_ZERO(readfds); }
    if (writefds) { FD_ZERO(writefds); }
    if (exceptfds) { FD_ZERO(exceptfds); }

    for (index=selcnt=0; index < nfds; index++)
    {
        if (SockCheckSelectEvents(selinfo[index].pSocket, selinfo[index].eventMasks, 0))
        {
            FD_SET(selinfo[index].s, selinfo[index].fdset);
            selcnt++;
        }
    }

    err = NO_ERROR;

exit:

    for (index=0; index < nfds; index++)
    {
        pSocket = selinfo[index].pSocket;

        if (pSocket && selinfo[index].pSocketMasks)
        {
            pSocket->ClearFlags(SOCKF_EVENT_MASK);
            pSocket->Unlock();
        }
    }

#ifdef XNET_FEATURE_XBOX
    if (waitBlockArray != tempWaitBlocks) { SysFree(waitBlockArray); }
#endif
    if (selinfo != &tempinfo) { SysFree(selinfo); }
    if (events != &tempevent) { SysFree(events); }

    WinsockApiCheckError_(SOCKET_ERROR);
    return selcnt;
}

INT CXnSock::SockLockSelectSockets(fd_set* fdset, SELECTINFO* selinfo, INT offset, INT eventMasks)

/*++

Routine Description:

    Lock the socket handles that was passed to the select API

Arguments:

    fdset - Points to the socket set
    selinfo - Points to an array of SELECTINFO structures
        for storing the locked socket information
    eventMasks - Specifies the interested events

Return Value:

    Winsock error code

--*/

{
    INT i, count;

    // Nothing to do if the set is empty
    count = SOCKETS_IN_SET(fdset);

    for (i=0; i < count; i++) {
        SOCKET s = fdset->fd_array[i];
        INT j, k = offset + i;

        selinfo[k].s = s;
        selinfo[k].fdset = fdset;
        selinfo[k].eventMasks = eventMasks;

        // Check to see if the socket is already used
        // in the same select call
        for (j=0; j < k && selinfo[j].s != s; j++)
            ;

        if (j == k) {
            //
            // The socket isn't seen already
            //
            selinfo[k].pSocketMasks = eventMasks;
            selinfo[k].pSocket = CSocket::Lock(s);
            if (!selinfo[k].pSocket)
                return GetLastError();
        } else {
            //
            // The socket is already seen
            //
            selinfo[j].pSocketMasks |= eventMasks;
            selinfo[k].pSocketMasks = 0;
            selinfo[k].pSocket = selinfo[j].pSocket;
        }
    }

    return NO_ERROR;
}

INT CXnSock::SockCheckSelectEvents(CSocket * pSocket, INT eventMasks, INT setwait)

/*++

Routine Description:

    Check if the specified socket events are available
    and optionally set up the socket to wait for them

Arguments:

    pSocket - Points to the protocol control block
    eventMasks - Specifies the socket events the caller is interested in
    setwait - Whether to set up the sockets to wait if 
        none of the specified events are avaiable

Return Value:

    Set of event flags that are already available

--*/

{
    NTSTATUS status;
    INT readyMasks;

    RaiseToDpc();

    // Check to see if the specified event is already available
    // Since our checks are trivial, it's faster to check
    // everything instead of trying to check selectively
    // based on the flags specified by the caller.
    
    if (pSocket->IsTcp())
    {
        CTcpSocket * pTcpSocket = (CTcpSocket *)pSocket;

        // If the connection was reset, return reset status
        status = pSocket->GetStatus();

        if (!NT_SUCCESS(status))
        {
            // Note: If we already told the app that the socket was connected
            // and then the socket got resetted, we don't need to set the socket
            // in the exceptfds again to tell the app the connection has failed.

            if (eventMasks != SOCKF_EVENT_RESET || !pSocket->TestFlags(SOCKF_CONNECT_SELECTED))
            {
                return(SOCKF_EVENT_RESET);
            }
        }

        readyMasks = (pTcpSocket->IsTcpRecvBufEmpty() ? 0 : SOCKF_EVENT_READ) |
                     (pTcpSocket->HasConnectedChild() ? SOCKF_EVENT_ACCEPT : 0) |
                     (pTcpSocket->IsFinReceived() ? SOCKF_EVENT_READ|SOCKF_EVENT_CLOSE : 0);

        if (pSocket->TestFlags(SOCKF_CONNECTED))
        {
            if (!pSocket->IsSendBufFull())
            {
                readyMasks |= SOCKF_EVENT_WRITE;
            }

            // NOTE: we only signal the connect event exactly once
            if ((eventMasks & SOCKF_EVENT_CONNECT) && !pSocket->TestFlags(SOCKF_CONNECT_SELECTED))
            {
                readyMasks |= SOCKF_EVENT_CONNECT;
                if (setwait >= 0)
                {
                    pSocket->SetFlags(SOCKF_CONNECT_SELECTED);
                }
            }
        }
    } else {
        readyMasks = (pSocket->IsUdpRecvBufEmpty() ? 0 : SOCKF_EVENT_READ) |
                     (pSocket->IsSendBufFull() ? 0 : SOCKF_EVENT_WRITE);
    }

    if ((readyMasks &= eventMasks) == 0 && setwait)
    {
        // Indicate that we're interested in the specified event
        // and prepare to wait
        pSocket->SetFlags(eventMasks, SOCKF_EVENT_MASK);
        EvtClear(pSocket->GetEvent());
    }

    return(readyMasks);
}

// ---------------------------------------------------------------------------------------
// WSAGetOverlappedResult
// ---------------------------------------------------------------------------------------

BOOL CXnSock::WSAGetOverlappedResult(SOCKET s, LPWSAOVERLAPPED overlapped, LPDWORD byteCount, BOOL fWait, LPDWORD flags)
{
    WinsockApiPrologSockLock_(WSAGetOverlappedResult, FALSE);

    WinsockApiParamCheck_(
        overlapped != NULL &&
        overlapped->hEvent != NULL &&
        byteCount != NULL &&
        flags != NULL);

    //
    // Check if we need to wait for the I/O request to complete
    //
    if (overlapped->_iostatus == NETERR_PENDING && fWait)
    {
        WaitForSingleObject(overlapped->hEvent, INFINITE);

        RaiseToDpc();

        if (overlapped->_iostatus == NETERR_PENDING)
        {
            err = overlapped->_ioxfercnt ? NETERR_OK : NETERR_CANCELLED;
            SockReqComplete(pSocket, (CSockReq *)overlapped->_ioreq, err);
        }
    }

    //
    // If the I/O request was completed,
    // return the completion status information
    //
    if ((err = overlapped->_iostatus) != NETERR_PENDING && NT_SUCCESS(err))
    {
        *byteCount = overlapped->_ioxfercnt;
        *flags = overlapped->_ioflags;
    }

    if (err == NETERR_PENDING)
    {
        WinsockApiGotoExit_(WSA_IO_INCOMPLETE);
    }
    else
    {
        MapNtStatusToWinsockError_(err);
    }
    
    WinsockApiExitSockUnlock_(TRUE, FALSE);
}

// ---------------------------------------------------------------------------------------
// WSACancelOverlappedIO
// ---------------------------------------------------------------------------------------

INT CXnSock::WSACancelOverlappedIO(SOCKET s)
{
    WinsockApiPrologSockLock_(WSACancelOverlappedIO, SOCKET_ERROR);

    {
        RaiseToDpc();
        SockReqComplete(pSocket, pSocket->GetRecvReq(), NETERR_CANCELLED);
        SockReqComplete(pSocket, pSocket->GetSendReq(), NETERR_CANCELLED);
    }

    WinsockApiGotoExit_(NO_ERROR);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// recv
// ---------------------------------------------------------------------------------------

int CXnSock::recv(SOCKET s, char* buf, int len, int flags)
{
    CRecvReq pRecvReq;
    DWORD count;
    WinsockApiPrologSockLock_(recv, SOCKET_ERROR);

    WinsockApiParamCheck_(
        (len > 0 && buf != NULL || len == 0) &&
        flags == 0);

    pRecvReq.buf = (BYTE*) buf;
    pRecvReq.buflen = len;
    pRecvReq.flags = flags;
    pRecvReq.bytesRecv = &count;
    pRecvReq.fromaddr = NULL;
    pRecvReq._pWsaOverlapped = NULL;

    err = SockRead(pSocket, &pRecvReq);

    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(count, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// WSARecv
// ---------------------------------------------------------------------------------------

//
// Verify buffers passed to WSARecv API
// NOTE: we do not support more than 1 receive buffers.
//
INLINE
BOOL CheckRecvWsaBuf(WSABUF* bufs, UINT bufcnt)
{
    return (bufcnt == 1 && bufs != NULL && (bufs->len > 0 && bufs->buf != NULL || bufs->len == 0));
}

int CXnSock::WSARecv(SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesRecv, LPDWORD flags,
                     LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc)
{
    CRecvReq pRecvReq;
    WinsockApiPrologSockLock_(WSARecv, SOCKET_ERROR);

    WinsockApiParamCheck_(
        CheckRecvWsaBuf(bufs, bufcnt) &&
        bytesRecv != NULL &&
        flags != NULL && *flags == 0 &&
        completionproc == NULL);

    pRecvReq.buf = (BYTE*) bufs->buf;
    pRecvReq.buflen = bufs->len;
    pRecvReq.flags = *flags;
    pRecvReq.bytesRecv = bytesRecv;
    pRecvReq.fromaddr = NULL;
    pRecvReq._pWsaOverlapped = overlapped;

    err = SockRead(pSocket, &pRecvReq);

    *flags = pRecvReq.flags;

    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// recvfrom
// ---------------------------------------------------------------------------------------

int CXnSock::recvfrom(SOCKET s, char FAR * buf, int len, int flags, struct sockaddr * from, int * fromlen)
{
    DWORD count;
    INT err;
    WSABUF wsabuf;

    WinsockApiPrologLight_(recvfrom);
    WinsockApiParamCheck_(
        (len > 0 && buf != NULL || len == 0) &&
        (from == NULL ||
         fromlen != NULL && *fromlen >= SOCKADDRLEN));

    wsabuf.len = len;
    wsabuf.buf = buf;
    err = WSARecvFrom(s, &wsabuf, 1, &count, (DWORD*) &flags, from, fromlen, NULL, NULL);
    return (err == NO_ERROR) ? count : SOCKET_ERROR;
}

// ---------------------------------------------------------------------------------------
// WSARecvFrom
// ---------------------------------------------------------------------------------------

int CXnSock::WSARecvFrom(SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesRecv, LPDWORD flags,
                         struct sockaddr * fromaddr, LPINT fromlen, LPWSAOVERLAPPED overlapped,
                         LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc)
{
    CRecvReq pRecvReq;
    WinsockApiPrologSockLock_(WSARecvFrom, SOCKET_ERROR);

    WinsockApiParamCheck_(
        CheckRecvWsaBuf(bufs, bufcnt) &&
        bytesRecv != NULL &&
        (fromaddr == NULL ||
         fromlen != NULL && *fromlen >= SOCKADDRLEN) &&
        flags != NULL && *flags == 0 &&
        completionproc == NULL);

    // Winsock documentation on this call is extremely confusing
    // regarding the correct behavior for connection-oriented sockets
    // Here I've taken the liberty to treat WSARecvFrom the same way
    // as WSARecv for such cases.
    if (pSocket->IsTcp()) {
        TraceSz(Verbose, "WSARecvFrom called on stream socket!");
    }

    pRecvReq.buf = (BYTE*) bufs->buf;
    pRecvReq.buflen = bufs->len;
    pRecvReq.flags = *flags;
    pRecvReq.bytesRecv = bytesRecv;
    pRecvReq._pWsaOverlapped = overlapped;
    pRecvReq.fromaddr = (struct sockaddr_in*) fromaddr;

    if (fromaddr) 
    {
        memset(fromaddr, 0, SOCKADDRLEN);
        *fromlen = SOCKADDRLEN;
        pRecvReq.fromaddr->sin_family = AF_INET;
    }

    err = SockRead(pSocket, &pRecvReq);
    *flags = pRecvReq.flags;
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// SockRead
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::SockRead(CSocket * pSocket, CRecvReq * pRecvReq)
{
    WSAOVERLAPPED * pWsaOverlapped;
    WSAOVERLAPPED   WsaOverlappedTemp;
    NTSTATUS        status;

    if (pSocket->IsTcp())
    {
        if (!pSocket->TestFlags(SOCKF_CONNECTED))
        {
            return NETERR(WSAENOTCONN);
        }
    }
    else
    {
        if (!pSocket->TestFlags(SOCKF_BOUND))
        {
            return NETERR(WSAEINVAL);
        }
    }

    if (pSocket->TestFlags(SOCKF_NOMORE_RECV))
    {
        return(!NT_SUCCESS(pSocket->GetStatus()) ? pSocket->GetStatus() : NETERR(WSAESHUTDOWN));
    }

    // Since all our sockets are overlapped, we don't
    // enforce the Win32 behavior that the input socket
    // must be a non-overlapped socket.

    pWsaOverlapped = pRecvReq->_pWsaOverlapped;

    if (pWsaOverlapped != NULL)
    {
        pRecvReq->_pEvent = EvtFromHandle(pWsaOverlapped->hEvent);

        if (pRecvReq->_pEvent == NULL)
        {
            return(NETERR(WSASYSCALLFAILURE));
        }
    }
    else
    {
        pRecvReq->_pEvent = NULL;
    }

    // Check if we have any buffered data waiting to be read

    if (pSocket->IsRecvBufEmpty())
    {
        if (pWsaOverlapped)
        {
            // Overlapped call.  This used to clear the event here, but that breaks if the caller
            // is using the same event for multiple sockets and/or online tasks.  So now we
            // let the caller reset the event themselves before making the overlapped call.
            // Normally they would use an auto-reset event anyways, so there is nothing for them to do.
        }
        else if (pSocket->TestFlags(SOCKF_OPT_NONBLOCKING))
        {
            // Nonoverlapped call and socket is nonblocking:
            // just return WOULDBLOCK error code.
            //
            // Note: For TCP socket, if FIN has been received
            // we should return success with bytesRecv set to 0.
            if (pSocket->IsUdp() || !((CTcpSocket *)pSocket)->IsFinReceived())
            {
                return(NETERR(WSAEWOULDBLOCK));
            }
        }
        else
        {
            // Blocking call - prepare to wait
            pRecvReq->_pWsaOverlapped = &WsaOverlappedTemp;
            pRecvReq->_pEvent = pSocket->GetEvent();
            EvtClear(pRecvReq->_pEvent);
        }
    }

    status = pSocket->IsUdp() ?
                UdpRead(pSocket, pRecvReq) :
                TcpRead((CTcpSocket *) pSocket, pRecvReq);

    if (status == NETERR_PENDING)
    {
        if (pWsaOverlapped == NULL)
        {
            // A blocking call is still in progress
            EvtWait(pRecvReq->_pEvent, pSocket->_uiRecvTimeout);

            if (WsaOverlappedTemp._iostatus == NETERR_PENDING)
            {
                RaiseToDpc();

                if (WsaOverlappedTemp._iostatus == NETERR_PENDING)
                {
                    // We can use pRecvReq directly here because
                    // blocking recv call is treated as a special case
                    // in SockQueueOverlappedRecv 
                    SockReqComplete(pSocket, pRecvReq, NETERR_TIMEOUT);
                }
            }

            *pRecvReq->bytesRecv = WsaOverlappedTemp._ioxfercnt;
            pRecvReq->flags = WsaOverlappedTemp._ioflags;
            status = WsaOverlappedTemp._iostatus;
        }
    }
    else
    {
        if (pWsaOverlapped)
        {
            // An overlapped call was completed immediately
            pWsaOverlapped->_ioflags = pRecvReq->flags;
            pWsaOverlapped->_ioxfercnt = *pRecvReq->bytesRecv;
            pWsaOverlapped->_iostatus = status;

            // It would seem to be a waste to signal the event here.
            // But that's win2k behavior.
            EvtSet(pRecvReq->_pEvent, 0);
            EvtDereference(pRecvReq->_pEvent);
        }
    }

    return(status);
}

NTSTATUS CXnSock::RecvReqEnqueue(CSocket * pSocket, CRecvReq * pRecvReq)
{
    ICHECK(SOCK, UDPC|SDPC);

    CRecvReq * pRecvReqNew;

    if (pSocket->HasRecvReq())
    {
        TraceSz2(sockWarn, "[%08lX:%s] Can only have one overlapped read at a time",
                 pSocket, pSocket->TypeStr());
        return(NETERR_WOULDBLOCK);
    }
    else if (!pRecvReq->_pEvent)
    {
        TraceSz2(sockWarn, "[%08lX:%s] Overlapped read on nonblocking socket must supply an event",
                pSocket, pSocket->TypeStr());
        return(NETERR_WOULDBLOCK);
    }

    if (pRecvReq->_pEvent == pSocket->GetEvent())
    {
        // If the wait event is our internal per-CSocket event,
        // then this is a special case for implementing the
        // blocking recv call.
        //
        // In this case, we avoid an allocation by directly
        // queuing up the RECVREQ structure that was passed
        // in from the caller (winsock layer). This works because
        // the caller will wait for the recv to complete after
        // this function returns.

        pRecvReqNew = pRecvReq;
    }
    else
    {
        pRecvReqNew = (CRecvReq *)SysAlloc(sizeof(CRecvReq), PTAG_CRecvReq);

        if (pRecvReqNew == NULL)
        {
            TraceSz2(sockWarn, "[%08lX:%s] Out of memory allocating overlapped read control block",
                     pSocket, pSocket->TypeStr());
            return(NETERR_MEMORY);
        }

        *pRecvReqNew = *pRecvReq;
    }

    pSocket->SetRecvReq(pRecvReqNew);

    pRecvReqNew->_pWsaOverlapped->_ioxfercnt = 0;
    pRecvReqNew->_pWsaOverlapped->_ioflags = 0;
    pRecvReqNew->_pWsaOverlapped->_ioreq = (UINT_PTR)pRecvReqNew;
    pRecvReqNew->_pWsaOverlapped->_iostatus = (DWORD)NETERR_PENDING;

    TraceSz3(sock, "[%08lX:%s] Enqueued overlapped read of %ld bytes",
             pSocket, pSocket->TypeStr(), pRecvReq->GetCbBuf());

    return(NETERR_PENDING);
}

// ---------------------------------------------------------------------------------------
// Forward Declarations
// ---------------------------------------------------------------------------------------

UINT SockCountSendTotal(WSABUF * bufs, UINT bufcnt);
BOOL SockCheckSendWsaBuf(WSABUF * bufs, UINT bufcnt);

// ---------------------------------------------------------------------------------------
// send
// ---------------------------------------------------------------------------------------

int CXnSock::send(SOCKET s, const char* buf, int len, int flags)
{
    WSABUF wsabuf;
    CSendReq SendReq;
    WinsockApiPrologSockLock_(send, SOCKET_ERROR);

    WinsockApiParamCheck_(
        (len > 0 && buf != NULL || len == 0) &&
        (flags  == 0));

    wsabuf.len = len;
    wsabuf.buf = (char*) buf;
    SendReq._pWsaOverlapped = NULL;
    SendReq.bufs = &wsabuf;
    SendReq.bufcnt = 1;
    SendReq.sendtotal = len;
    SendReq.toaddr = NULL;

    err = SockSend(pSocket, &SendReq);
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(SendReq.sendtotal, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// WSASend
// ---------------------------------------------------------------------------------------

int CXnSock::WSASend(SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesSent, DWORD flags,
                     LPWSAOVERLAPPED overlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc)
{
    CSendReq SendReq;
    WinsockApiPrologSockLock_(WSASend, SOCKET_ERROR);

    WinsockApiParamCheck_(
        SockCheckSendWsaBuf(bufs, bufcnt) &&
        bytesSent != NULL &&
        flags == 0 &&
        completionproc == NULL);

    SendReq._pWsaOverlapped = overlapped;
    SendReq.bufs = bufs;
    SendReq.bufcnt = (WORD)bufcnt;
    SendReq.sendtotal = SockCountSendTotal(bufs, bufcnt);
    SendReq.toaddr = NULL;

    err = SockSend(pSocket, &SendReq);
    if (NT_SUCCESS(err)) *bytesSent = SendReq.sendtotal;
    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

BOOL SockCheckSendWsaBuf(WSABUF* bufs, UINT bufcnt)
{
    if (bufs == NULL || bufcnt == 0 || bufcnt > 0xFFFF)
        return FALSE;

    while (bufcnt--) {
        if (bufs->len && bufs->buf == NULL)
            return FALSE;
        bufs++;
    }
    return TRUE;
}

UINT SockCountSendTotal(WSABUF* bufs, UINT bufcnt)
{
    UINT total = 0;

    while (bufcnt--)
    {
        total += bufs->len;
        bufs++;
    }

    return(total);
}

// ---------------------------------------------------------------------------------------
// sendto
// ---------------------------------------------------------------------------------------

int CXnSock::sendto(SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen)
{
    DWORD count;
    INT err;
    WSABUF wsabuf;

    WinsockApiPrologLight_(sendto);
    WinsockApiParamCheck_(len > 0 && buf != NULL || len == 0);

    wsabuf.len = len;
    wsabuf.buf = (char*) buf;
    err = WSASendTo(s, &wsabuf, 1, &count, flags, to, tolen, NULL, NULL);
    return (err == NO_ERROR) ? count : SOCKET_ERROR;
}

// ---------------------------------------------------------------------------------------
// WSASendTo
// ---------------------------------------------------------------------------------------

int CXnSock::WSASendTo(SOCKET s, LPWSABUF bufs, DWORD bufcnt, LPDWORD bytesSent, DWORD flags,
                       const struct sockaddr* toaddr, int tolen, LPWSAOVERLAPPED overlapped,        
                       LPWSAOVERLAPPED_COMPLETION_ROUTINE completionproc)
{
    struct sockaddr_in* sin = (struct sockaddr_in*) toaddr;
    CSendReq SendReq;
    WinsockApiPrologSockLock_(WSASendTo, SOCKET_ERROR);

    WinsockApiParamCheck_(
        SockCheckSendWsaBuf(bufs, bufcnt) &&
        bytesSent != NULL &&
        flags == 0 &&
        (toaddr == NULL ||
         tolen >= SOCKADDRLEN && sin->sin_family == AF_INET) &&
        completionproc == NULL);

    SendReq._pWsaOverlapped = overlapped;
    SendReq.bufs = bufs;
    SendReq.bufcnt = (WORD)bufcnt;
    SendReq.sendtotal = SockCountSendTotal(bufs, bufcnt);

    if (pSocket->IsTcp() || toaddr == NULL)
    {
        // For TCP sockets, WSASendTo is equivalent to WSASend.
        // We simply ignore lpTo and iToLen parameters.
        //
        // Also, if toaddr parameter is NULL, we treat WSASendTo
        // the same way as WSASend.

        SendReq.toaddr = NULL;
    }
    else
    {
        CIpAddr ipaDst = sin->sin_addr.s_addr;

        // Must do this check because downstream code
        // doesn't expect the destination address to be 0.
        // Also, we consider sending to UDP port 0 an error.
        if (    ipaDst == 0
            ||  sin->sin_port == 0
            ||  ipaDst.IsMulticast()
            || (ipaDst.IsLoopback() && ipaDst != IPADDR_LOOPBACK))
        {
            WinsockApiGotoExit_(WSAEADDRNOTAVAIL);
        }

        // Is this socket allowed to send broadcast
        // datagrams on this socket?
        if (ipaDst.IsBroadcast() && !pSocket->TestFlags(SOCKF_OPT_BROADCAST))
        {
            WinsockApiGotoExit_(WSAEACCES);
        }

        // If the socket is not bound, bind it here
        if (!pSocket->TestFlags(SOCKF_BOUND))
        {
            err = SockBind(pSocket, 0);

            if (!NT_SUCCESS(err))
            {
                MapNtStatusToWinsockError_(err);
                goto exit;
            }
        }

        // Send to the new destination
        SendReq.toaddr = sin;
    }
        
    err = SockSend(pSocket, &SendReq);

    if (NT_SUCCESS(err))
    {
        *bytesSent = SendReq.sendtotal;
    }

    MapNtStatusToWinsockError_(err);
    WinsockApiExitSockUnlock_(NO_ERROR, SOCKET_ERROR);
}

// ---------------------------------------------------------------------------------------
// SockSend
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::SockSend(CSocket* pSocket, CSendReq* pSendReq)

/*++

Routine Description:

    Internal function for sending out data from a socket

Arguments:

    pSocket - Points to the protocol control block
    pSendReq - Points to send user request information

Return Value:

    Status code

--*/

{
    WSAOVERLAPPED * pWsaOverlapped;
    NTSTATUS        status;

    if (!pSocket->TestFlags(SOCKF_CONNECTED) && !pSendReq->toaddr)
        return NETERR(WSAENOTCONN);

    if (pSocket->TestFlags(SOCKF_NOMORE_XMIT))
    {
        return(!NT_SUCCESS(pSocket->GetStatus()) ? pSocket->GetStatus() : NETERR(WSAESHUTDOWN));
    }

    pWsaOverlapped = pSendReq->_pWsaOverlapped;

    if (pWsaOverlapped != NULL)
    {
        pSendReq->_pEvent = EvtFromHandle(pWsaOverlapped->hEvent);

        if (pSendReq->_pEvent == NULL)
        {
            return(NETERR(WSASYSCALLFAILURE));
        }
    }

    // Check if we have room in the send buffer

    if (pSocket->IsSendBufFull())
    {
        if (pWsaOverlapped)
        {
            // Overlapped call.  This used to clear the event here, but that breaks if the caller
            // is using the same event for multiple sockets and/or online tasks.  So now we
            // let the caller reset the event themselves before making the overlapped call.
            // Normally they would use an auto-reset event anyways, so there is nothing for them to do.

            status = SockQueueOverlappedSend(pSocket, pSendReq);

            // The overlapped request was successfully queued up
            if (status == NETERR_PENDING)
                return(status);

            // The overlapped send request wasn't queued
            // because of an error.
            if (!NT_SUCCESS(status))
                goto exit;

            // The send buffer has opened up and
            // the overlapped send request wasn't queued.
        }
        else if (pSocket->TestFlags(SOCKF_OPT_NONBLOCKING) || pSocket->HasSendReq())
        {
            return(NETERR_WOULDBLOCK);
        }
        else
        {
            status = SockWaitForEvent(pSocket, SOCKF_EVENT_WRITE, pSocket->_uiSendTimeout);

            if (!NT_SUCCESS(status))
                return(status);
        }
    }

    status = pSocket->IsUdp() ?
                UdpSend(pSocket, pSendReq, 0) :
                TcpSend((CTcpSocket *) pSocket, pSendReq, 0);

exit:

    if (pWsaOverlapped)
    {
        // An overlapped call was completed immediately
        pWsaOverlapped->_ioflags = 0;
        pWsaOverlapped->_ioxfercnt = pSendReq->sendtotal;
        pWsaOverlapped->_iostatus = status;

        // It would seem to be a waste to signal the event here.
        // But that's win2k behavior.

        EvtSet(pSendReq->_pEvent, 0);
        EvtDereference(pSendReq->_pEvent);
    }

    return(status);
}

NTSTATUS CXnSock::SockQueueOverlappedSend(CSocket * pSocket, CSendReq * pSendReq)

/*++

Routine Description:

    Queue up an overlapped send request

Arguments:

    pSocket - Points to the protocol control block
    pSendReq - Points to the overlapped send request

Return Value:

    Status code:
        NETERR_PENDING - the request was successfully queued up
        NETERR_OK - if the send buffer has opened up and
            there is no need to queue up the request
        otherwise - the request was not queued up due to an error

--*/

{
    NTSTATUS status;

    RaiseToDpc();

    if (pSocket->HasSendReq())
    {
        // We only support 1 outstanding overlapped send request.
        status = NETERR_WOULDBLOCK;
    }
    else if (!pSocket->IsSendBufFull())
    {
        // The send buffer opened up just as
        // we were raising to DPC level
        status = NETERR_OK;
    }
    else
    {
        CSendReq* newreq;
        UINT size = sizeof(CSendReq) +
                    (pSendReq->toaddr ? sizeof(*pSendReq->toaddr) : 0) +
                    sizeof(WSABUF) * pSendReq->bufcnt;

        newreq = (CSendReq*) SysAlloc(size, PTAG_CXmitReq);
        if (!newreq)
        {
            // Out of memory
            status = NETERR_MEMORY;
        }
        else
        {
            VOID* bufs;

            pSocket->SetSendReq(newreq);
            *newreq = *pSendReq;
            bufs = newreq+1;
            if (pSendReq->toaddr) {
                newreq->toaddr = (struct sockaddr_in*) bufs;
                *newreq->toaddr = *pSendReq->toaddr;
                bufs = newreq->toaddr + 1;
            }

            newreq->bufs = (WSABUF*) bufs;
            memcpy(bufs, pSendReq->bufs, sizeof(WSABUF) * pSendReq->bufcnt);

            newreq->_pWsaOverlapped->_ioxfercnt = 0;
            newreq->_pWsaOverlapped->_ioflags = 0;
            newreq->_pWsaOverlapped->_ioreq = (UINT_PTR) newreq;
            newreq->_pWsaOverlapped->_iostatus = status = NETERR_PENDING;
        }
    }

    return(status);
}

// ---------------------------------------------------------------------------------------
// inet_addr
// ---------------------------------------------------------------------------------------

ULONG _WSAAPI_ inet_addr(const char * pch)
{
    WinsockApiPrologTrivial_(inet_addr);
    WinsockApiParamCheck_(pch != NULL);

    // Convert the string representation of IP address to its binary form.
    // The following formats are recognized:
    //      a.b.c.d     8-8-8-8
    //      a.b.c       8-8-16
    //      a.b         8-24
    //      a           32
    // Each field can be in decimal, octal, or hex format.

    ULONG fields[4], addr;
    UINT fieldcnt = 0;
    const UCHAR* p = (const UCHAR *) pch;

    // NOTE: We don't handle overflow conditions.

    while (TRUE) {
        // skip leading spaces
        while (*p == ' ') p++;
        if (fieldcnt >= 4 || *p == 0) break;
    
        addr = 0;
        if (*p == '0' && (p[1] == 'x' || p[1] == 'X')) {
            // hex number
            const UCHAR* q = (p += 2);

            while (TRUE) {
                if (*p >= '0' && *p <= '9')
                    addr = (addr << 4) + (*p - '0');
                else if (*p >= 'a' && *p <= 'f')
                    addr = (addr << 4) + 10 + (*p - 'a');
                else if (*p >= 'A' && *p <= 'F')
                    addr = (addr << 4) + 10 + (*p - 'A');
                else
                    break;
                p++;
            }

            if (q == p)
            {
                return(INADDR_NONE);
            }

        } else if (*p == '0') {
            // octal number
            do {
                addr = (addr << 3) + (*p - '0');
                p++;
            } while (*p >= '0' && *p <= '7');
        } else if (*p >= '1' && *p <= '9') {
            // decimal number
            do {
                addr = addr*10 + (*p - '0');
                p++;
            } while (*p >= '0' && *p <= '9');
        } else {
            // invalid character
            break;
        }

        // skip trailing spaces and . separator
        while (*p == ' ') p++;
        if (*p == '.') p++;

        fields[fieldcnt++] = addr;
    }

    if (*p)
    {
        return(INADDR_NONE);
    }

    switch (fieldcnt) {
    case 1:
        addr = fields[0];
        break;
    case 2:
        addr = ((fields[0] & 0xff) << 24) |
               (fields[1] & 0xffffff);
        break;
    case 3:
        addr = ((fields[0] & 0xff) << 24) |
               ((fields[1] & 0xff) << 16) |
               (fields[2] & 0xffff);
        break;
    case 4:
        addr = ((fields[0] & 0xff) << 24) |
               ((fields[1] & 0xff) << 16) |
               ((fields[2] & 0xff) <<  8) |
               (fields[3] & 0xff);
        break;

    default:
        addr = 0;
        break;
    }

    return(HTONL(addr));
}

// ---------------------------------------------------------------------------------------
// Miscellanous
// ---------------------------------------------------------------------------------------

u_long      _WSAAPI_ htonl(IN u_long hostlong)            { return HTONL(hostlong); }
u_short     _WSAAPI_ htons(IN u_short hostshort)          { return HTONS(hostshort); }
u_long      _WSAAPI_ ntohl(IN u_long netlong)             { return NTOHL(netlong); }
u_short     _WSAAPI_ ntohs(IN u_short netshort)           { return NTOHS(netshort); }
int         _WSAAPI_ WSAGetLastError()                    { return(GetLastError()); }
void        _WSAAPI_ WSASetLastError(IN int error)        { SetLastError(error); }
WSAEVENT    _WSAAPI_ WSACreateEvent()                     { return(CreateEvent(NULL, TRUE, FALSE, NULL)); }
BOOL        _WSAAPI_ WSACloseEvent(IN WSAEVENT hEvent)    { return(CloseHandle(hEvent)); }
BOOL        _WSAAPI_ WSASetEvent(IN WSAEVENT hEvent)      { return(SetEvent(hEvent)); }
BOOL        _WSAAPI_ WSAResetEvent(IN WSAEVENT hEvent)    { return(ResetEvent(hEvent)); }

DWORD _WSAAPI_ WSAWaitForMultipleEvents(IN DWORD cEvents, IN const WSAEVENT* lphEvents,
                                        IN BOOL fWaitAll, IN DWORD dwTimeout, IN BOOL fAlertable)
{
    return(WaitForMultipleObjectsEx(cEvents, lphEvents, fWaitAll, dwTimeout, fAlertable));
}

int _WSAAPI_ __WSAFDIsSet(SOCKET fd, fd_set * set)
{
    int i = (set->fd_count & 0xffff);

    while (i--)
    {
        if (set->fd_array[i] == fd)
            return 1;
    }

    return 0;
}

// ---------------------------------------------------------------------------------------
// SockLock
// ---------------------------------------------------------------------------------------

CSocket * CSocket::Lock(SOCKET s)
{
    CSocket *   pSocket;
    LONG        lLock;
    int         err;

    // NOTE: We don't allow multiple threads to access the same
    // socket simultaneously. If the app tries to do that, the first
    // thread will succeed and other threads will get an error return.

    if (s == 0 || s == INVALID_SOCKET)
    {
        err = WSAENOTSOCK;
    }
    else
    {
        pSocket = (CSocket *)s;
        lLock   = InterlockedCompareExchange(&pSocket->_lLock, SOCK_LOCK_BUSY, SOCK_LOCK_ACTIVE);

        if (lLock == SOCK_LOCK_ACTIVE)
            return(pSocket);

        err = (lLock == SOCK_LOCK_BUSY) ? WSAEINPROGRESS : WSAENOTSOCK;
    }

#if defined(XNET_FEATURE_TRACE) && !defined(XNET_FEATURE_XBDM_SERVER)
    if (err == WSAEINPROGRESS)
    {
        TraceSz1(sockWarn, "[%X] Socket thread contention", s);
    }
#endif

    SetLastError(err);

    return(NULL);
}

// ---------------------------------------------------------------------------------------
// CXnSock::SockInit
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::SockInit(XNetInitParams * pxnip)
{
    TCHECK(USER);

    LARGE_INTEGER dueTime;
    UINT period;

    NTSTATUS status = IpInit(pxnip);
    if (!NT_SUCCESS(status))
        return(status);

    SetInitFlag(INITF_SOCK);

    InitializeListHead(&_leSockets);
    InitializeListHead(&_leDeadSockets);
    _ipportTempNext = MAX_TEMP_PORT;

    return(NETERR_OK);
}

void CXnSock::SockTerm()
{
    TCHECK(USER);

    RaiseToDpc();

    if (TestInitFlag(INITF_SOCK))
    {
        SockStop();
        SockShutdown();
    }

    SetInitFlag(INITF_SOCK_TERM);

    IpTerm();
}

void CXnSock::SockShutdown()
{
    if (TestInitFlag(INITF_SOCK))
    {
        RaiseToDpc();

        while (!IsListEmpty(&_leSockets))
        {
            CSocket * pSocket = (CSocket*)_leSockets.Flink;

            if (pSocket->TestFlags(SOCKF_OWNED))
            {
                TraceSz1(LeakWarn, "Socket %08lX not closed before WSACleanup", pSocket);
            }

            SockClose(pSocket, TRUE);
        }

        while (!IsListEmpty(&_leDeadSockets))
        {
            CSocket * pSocket = (CSocket*) _leDeadSockets.Flink;

            SockClose(pSocket, TRUE);
        }
    }
}

// ---------------------------------------------------------------------------------------
// SockWaitForEvent
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::SockWaitForEvent(CSocket* pSocket, INT eventMask, UINT timeout)

/*++

Routine Description:

    Block the current thread until the specified CSocket event is signalled

Arguments:

    pSocket - Points to the protocol control block
    eventMask - Flag bit to indicate which event to block on
    timeout - Specifies the wait timeout (in milliseconds, 0 means forever)

Return Value:

    Status code

--*/

{
    INT readyMask;
    NTSTATUS status = NETERR_OK;

    //
    // Check if the specified event is already available
    // or if the socket connection has been reset.
    //
    readyMask = SockCheckSelectEvents(pSocket, eventMask, 1);
    if (readyMask & SOCKF_EVENT_RESET) goto exit;
    if (readyMask != 0) return NETERR_OK;

    status = EvtWait(pSocket->GetEvent(), timeout) ? NETERR_OK : NETERR_TIMEOUT;

    pSocket->ClearFlags(SOCKF_EVENT_MASK);

exit:
    return NT_SUCCESS(status) ? pSocket->GetStatus() : status;
}


void CXnSock::SockReqComplete(CSocket * pSocket, CSockReq * pSockReq, NTSTATUS status)
{
    if (pSockReq)
    {
        if (pSocket->GetSendReq() == pSockReq)
            pSocket->SetSendReq(NULL);
        else if (pSocket->GetRecvReq() == pSockReq)
            pSocket->SetRecvReq(NULL);

        pSockReq->_pWsaOverlapped->_iostatus = status;

        EvtSet(pSockReq->_pEvent, EVENT_INCREMENT);

        if (pSockReq->_pEvent != pSocket->GetEvent())
        {
            EvtDereference(pSockReq->_pEvent);
            SysFree(pSockReq);
        }
    }
}


CSocket * CXnSock::SockFindMatch(CIpPort toport, CIpAddr fromaddr, CIpPort fromport, BYTE type)
{
    TCHECK(SDPC);

    CSocket *   pSocket;
    CSocket *   pSocketBest = NULL;
    BOOL        fIsUdp      = (type == SOCK_DGRAM);
    UINT        cWildMin    = 3;
    UINT        cWild;

    for (pSocket = GetFirstSocket(); pSocket; pSocket = GetNextSocket(pSocket))
    {
        if (!!pSocket->IsUdp() != fIsUdp)
            continue;

        if (pSocket->_ipportSrc != toport)
            continue;

        cWild = 0;

        if (pSocket->_ipaDst != fromaddr)
        {
            if (pSocket->_ipaDst)
                continue;

            cWild++;
        }

        if (pSocket->_ipportDst != fromport)
        {
            if (pSocket->_ipportDst)
                continue;

            cWild++;
        }

        if (cWild == 0)
        {
            pSocketBest = pSocket;
            break;
        }

        if (cWild < cWildMin)
        {
            pSocketBest = pSocket;
            cWildMin = cWild;
        }
    }

    return(pSocketBest);
}

void CSocket::SetFlagsAndOr(DWORD dwAnd, DWORD dwOr)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);

    DWORD dwFlagsOld, dwFlagsNew;

    while (1)
    {
        dwFlagsOld = _dwFlags;
        dwFlagsNew = (dwFlagsOld & dwAnd) | dwOr;

        if (InterlockedCompareExchange((LONG *)&_dwFlags, (LONG)dwFlagsNew, (LONG)dwFlagsOld) == (LONG)dwFlagsOld)
            break;

        TraceSz(Warning, "CSocket::SetFlagsAndOr: Thread/DPC contention detected.  Retrying.");
    }
}

// ---------------------------------------------------------------------------------------
// SockReset
// ---------------------------------------------------------------------------------------

void CXnSock::SockReset(CIpAddr ipa)
{
    TCHECK(UDPC|SDPC);

    if (ipa != 0 && TestInitFlag(INITF_SOCK) && !TestInitFlag(INITF_SOCK_TERM))
    {
        CSocket *       pSocket;
        CSocket *       pSocketNext;
        CTcpSocket *    pTcpSocket;

        for (pSocket = GetFirstSocket(); pSocket; pSocket = pSocketNext)
        {
            pSocketNext = GetNextSocket(pSocket);

            if (pSocket->IsTcp() && pSocket->_ipaDst == ipa)
            {
                pTcpSocket = (CTcpSocket *)pSocket;

                if (!pTcpSocket->IsIdleState())
                {
                    TcpReset(pTcpSocket, NETERR_CONNRESET);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\libx\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\xnet.cpp ===
// ---------------------------------------------------------------------------------------
// xnet.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(Verbose,      0);                 // Trace verbose messages
DefineTag(Warning,      TAG_ENABLE);        // Trace warnings
DefineTag(pktRecv,      0);                 // Trace packet receives
DefineTag(pktBroadcast, 0);                 // Trace broadcast packet receives
DefineTag(pktXmit,      0);                 // Trace packet transmits
DefineTag(pktWarn,      TAG_ENABLE);        // Trace packet Recv/Xmit uncommon events

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

LONG g_lXnLock = 0;

// ---------------------------------------------------------------------------------------
// XnInit
// ---------------------------------------------------------------------------------------

INT _WSAAPI_ XnInit(void ** ppXn, char * pszXbox, const XNetStartupParams * pxnsp, BOOL fWsa, WORD wVersionRequired, LPWSADATA lpWSAData)
{
    while (InterlockedCompareExchange(&g_lXnLock, 1, 0))
    {
        Sleep(0);
    }

    CXn *   pXn = (CXn *)(*ppXn);
    int     err = 0;

    if (pXn == NULL)
    {
        pXn = new CXn;

        if (pXn == NULL)
        {
            err = RtlNtStatusToDosError(NETERR_MEMORY);
            goto err;
        }

        *ppXn = pXn;

        // Set up XNetInitParams and XNetConfigParams

        XNetInitParams      xnip;
        XNetConfigParams    xncp;

        xnip.pxnp    = (XNetParams *)pxnsp;
        xnip.pszXbox = pszXbox;
        HalQueryTsc(&xnip.liTime);

        memset(&xncp, 0, sizeof(xncp));
        xncp.dwSigEnd = XNET_CONFIG_PARAMS_SIGEND;

        HANDLE hVolume = XNetOpenConfigVolume();

        if (hVolume != INVALID_HANDLE_VALUE)
        {
            if (XNetLoadConfigSector(hVolume, 0, (BYTE *)&xncp, sizeof(xncp)))
            {
                // Extract the rand seed from the config sector and move it into
                // the init params.  If we couldn't read the config sector, just
                // leave the seed with whatever is on the stack.

                Assert(sizeof(xnip.abSeed) == sizeof(xncp.abSeed));
                memcpy(xnip.abSeed, xncp.abSeed, sizeof(xnip.abSeed));
            }
        }

        if (xncp.dwSigEnd != XNET_CONFIG_PARAMS_SIGEND)
        {
            memset(&xncp, 0, sizeof(xncp));
            xncp.dwSigEnd = XNET_CONFIG_PARAMS_SIGEND;
        }

        NTSTATUS status = pXn->SockInit(&xnip);

        if (!NT_SUCCESS(status))
        {
            err = RtlNtStatusToDosError(status);
        }

        if (hVolume != INVALID_HANDLE_VALUE)
        {
            if (err == 0)
            {
                // Write the updated rand seed back to the config sector.

                Assert(sizeof(xnip.abSeed) == sizeof(xncp.abSeed));
                memcpy(xncp.abSeed, xnip.abSeed, sizeof(xncp.abSeed));

                XNetSaveConfigSector(hVolume, 0, (BYTE *)&xncp, sizeof(xncp));
            }

            XNetCloseConfigVolume(hVolume);
        }

        if (err == 0 && (pxnsp == NULL || (pxnsp->cfgFlags & XNET_STARTUP_MANUAL_CONFIG) == 0))
        {
        #if defined(XNET_FEATURE_XBDM_SERVER) && defined(DEVKIT)
            xncp.ina.s_addr = (ULONG)DmTell(DMTELL_GETDBGIP, NULL);
        #endif

            err = pXn->XNetConfig(&xncp, XNET_CONFIG_NORMAL);
        }

        if (err != 0)
        {
            pXn->SockTerm();
            pXn = NULL;
            *ppXn = NULL;
            goto err;
        }

        pXn->SockStart();
    }

    if (fWsa)
    {
        pXn->SockAddRef();

        lpWSAData->wVersion          = wVersionRequired;
        lpWSAData->wHighVersion      = 0x0202;
        lpWSAData->lpVendorInfo      = NULL;
        lpWSAData->iMaxSockets       = 0;
        lpWSAData->iMaxUdpDg         = 0;
        lpWSAData->szDescription[0]  = 0;
        lpWSAData->szSystemStatus[0] = 0;
    }
    else
    {
        pXn->XNetAddRef();
    }

err:

    g_lXnLock = 0;

    if (err != 0)
    {
        TraceSz2(Warning, "%s failed: %d", fWsa ? "WSAStartup" : "XNetStartup", err);

        if (fWsa)
        {
            SetLastError(err);
            err = SOCKET_ERROR;
        }
    }

    return(err);
}

// ---------------------------------------------------------------------------------------
// XnTerm
// ---------------------------------------------------------------------------------------

INT _WSAAPI_ XnTerm(void ** ppXn, BOOL fWsa)
{
    int err = 0;

    while (InterlockedCompareExchange(&g_lXnLock, 1, 0))
    {
        Sleep(0);
    }

    CXn * pXn = (CXn *)*ppXn;

    if (    pXn == NULL
        ||  ( fWsa && pXn->SockGetRefs() == 0)
        ||  (!fWsa && pXn->XNetGetRefs() == 0))
    {
        err = WSANOTINITIALISED;
    }
    else
    {
        if (fWsa)
        {
            if (pXn->SockRelease() == 0)
                pXn->SockShutdown();
        }
        else
        {
            pXn->XNetRelease();
        }

        if (pXn->XNetGetRefs() + pXn->SockGetRefs() == 0)
        {
            pXn->SockTerm();
            delete pXn;
            *ppXn = NULL;
        }
    }

    g_lXnLock = 0;

    if (err != 0)
    {
        TraceSz2(Warning, "%s failed: %d", fWsa ? "WSACleanup" : "XNetCleanup", err);

        if (fWsa)
        {
            SetLastError(err);
            err = SOCKET_ERROR;
        }
    }

    return(err);
}

// ---------------------------------------------------------------------------------------
// Key API's
// ---------------------------------------------------------------------------------------

INT CXn::XNetCreateKey(XNKID * pxnkid, XNKEY * pxnkey)
{
    XNetEnter(XNetCreateKey, pxnkid != NULL && pxnkey != NULL);
    INT err = IpCreateKey(pxnkid, pxnkey);
    XNetLeave(err);
    return(err);
}

INT CXn::XNetRegisterKey(const XNKID * pxnkid, const XNKEY * pxnkey)
{
    XNetEnter(XNetRegisterKey, pxnkid != NULL && pxnkey != NULL);
    INT err = IpRegisterKey(pxnkid, pxnkey);
    XNetLeave(err);
    return(err);
}

INT CXn::XNetUnregisterKey(const XNKID * pxnkid)
{
    XNetEnter(XNetUnregisterKey, pxnkid != NULL);
    INT err = IpUnregisterKey(pxnkid);
    XNetLeave(err);
    return(err);
}

INT CXn::XNetRandom(BYTE * pb, UINT cb)
{
    XNetEnter(XNetRandom, pb != NULL || cb == 0);
    Rand(pb, cb);
    XNetLeave(0);
    return(0);
}

// ---------------------------------------------------------------------------------------
// XnAddr API's
// ---------------------------------------------------------------------------------------

INT CXn::XNetXnAddrToInAddr(const XNADDR * pxna, const XNKID * pxnkid, IN_ADDR * pina)
{
    XNetEnter(XNetXnAddrToInAddr, pxna != NULL && pxnkid != NULL && pina != NULL);
    INT err = IpXnAddrToInAddr(pxna, pxnkid, (CIpAddr *)pina);
    XNetLeave(err);
    return(err);
}

INT CXn::XNetServerToInAddr(const IN_ADDR ina, DWORD dwServiceId, IN_ADDR * pina)
{
    XNetEnter(XNetServerToInAddr, ina.s_addr != 0 && pina != NULL);
#ifdef XNET_FEATURE_SG
    INT err = IpServerToInAddr(CIpAddr(ina.s_addr), dwServiceId, (CIpAddr *)pina);
#else
    INT err = WSAEACCES;
#endif
    XNetLeave(err);
    return(err);
}

INT CXn::XNetInAddrToXnAddr(const IN_ADDR ina, XNADDR * pxna, XNKID * pxnkid)
{
    XNetEnter(XNetInAddrToXnAddr, ina.s_addr != 0);
    INT err = IpInAddrToXnAddr(CIpAddr(ina.s_addr), pxna, pxnkid);
    XNetLeave(err);
    return(err);
}

INT CXn::XNetInAddrToString(const IN_ADDR ina, char * pchBuf, INT cchBuf)
{
    XNetParamCheck(XNetInAddrToString, pchBuf != NULL && cchBuf > 0, WSAEFAULT);
    XnInAddrToString(ina, pchBuf, cchBuf);
    return(0);
}

INT CXn::XNetUnregisterInAddr(const IN_ADDR ina)
{
    XNetEnter(XNetUnregisterInAddr, ina.s_addr != 0);
    INT err = IpUnregisterInAddr(CIpAddr(ina.s_addr));
    XNetLeave(err);
    return(err);
}

DWORD CXn::XNetGetTitleXnAddr(XNADDR * pxna)
{
    XNetInitCheck(XNetGetTitleXnAddr, XNET_GET_XNADDR_NONE);
    XNetParamCheck(XNetGetTitleXnAddr, pxna != NULL, XNET_GET_XNADDR_NONE);

#ifdef XNET_FEATURE_XBDM_SERVER
    return(NicGetOtherXnAddr(pxna));
#else
    return(IpGetXnAddr(pxna));
#endif
}

DWORD CXn::XNetGetDebugXnAddr(XNADDR * pxna)
{
    XNetInitCheck(XNetGetDebugXnAddr, XNET_GET_XNADDR_NONE);
    XNetParamCheck(XNetGetDebugXnAddr, pxna != NULL, XNET_GET_XNADDR_NONE);

#ifdef XNET_FEATURE_XBDM_CLIENT
    return(NicGetOtherXnAddr(pxna));
#elif defined(XNET_FEATURE_XBDM_SERVER)
    return(IpGetXnAddr(pxna));
#else
    return(XNET_GET_XNADDR_NONE);
#endif
}

// ---------------------------------------------------------------------------------------
// Domain Name Service APIs
// ---------------------------------------------------------------------------------------

INT CXn::XNetDnsLookup(const char * pszHost, WSAEVENT hEvent, XNDNS ** ppxndns)
{
    XNetEnter(XNetDnsLookup, pszHost != NULL && ppxndns != NULL);

    #ifdef XNET_FEATURE_DNS
    INT err = IpDnsLookup(pszHost, hEvent, ppxndns);
    #else
    INT err = WSAEACCES;
    #endif

    XNetLeave(err);
    return(err);
}

INT CXn::XNetDnsRelease(XNDNS * pxndns)
{
    XNetEnter(XNetDnsRelease, pxndns != NULL);

    #ifdef XNET_FEATURE_DNS
    INT err = IpDnsRelease(pxndns);
    #else
    INT err = WSAEACCES;
    #endif

    XNetLeave(err);
    return(err);
}

// ---------------------------------------------------------------------------------------
// Quality of Service APIs
// ---------------------------------------------------------------------------------------

INT CXn::XNetQosListen(const XNKID * pxnkid, const BYTE * pb, UINT cb, DWORD dwBitsPerSec, DWORD dwFlags)
{
    XNetEnter(XNetQosListen, pxnkid != NULL && (!!pb == !!cb) && (dwFlags & ~(XNET_QOS_LISTEN_ENABLE|XNET_QOS_LISTEN_DISABLE|XNET_QOS_LISTEN_SET_DATA|XNET_QOS_LISTEN_SET_BITSPERSEC)) == 0);

    #ifdef XNET_FEATURE_QOS
    INT err = IpQosListen(pxnkid, pb, cb, dwBitsPerSec, dwFlags);
    #else
    INT err = WSAEACCES;
    #endif

    XNetLeave(err);
    return(err);
}

INT CXn::XNetQosXnAddr(UINT cxnqos, const XNADDR * apxna[], const XNKID * apxnkid[], const XNKEY * apxnkey[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos)
{
    XNetEnter(XNetQosXnAddr, cxnqos > 0 && apxna != NULL && apxnkid != NULL && apxnkey != NULL && dwFlags == 0 && ppxnqos != NULL);

    #ifdef XNET_FEATURE_QOS
    INT err = IpQosXnAddr(cxnqos, apxna, apxnkid, apxnkey, dwFlags, hEvent, ppxnqos);
    #else
    INT err = WSAEACCES;
    #endif

    XNetLeave(err);
    return(err);
}

INT CXn::XNetQosServer(UINT cxnqos, const IN_ADDR aina[], const DWORD adwServiceId[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos)
{
    XNetEnter(XNetQosServer, cxnqos > 0 && aina != NULL && adwServiceId != NULL && dwFlags == 0 && ppxnqos != NULL);

    #if defined(XNET_FEATURE_QOS) && defined(XNET_FEATURE_SG)
    INT err = IpQosServer(cxnqos, aina, adwServiceId, dwFlags, hEvent, ppxnqos);
    #else
    INT err = WSAEACCES;
    #endif

    XNetLeave(err);
    return(err);
}

INT CXn::XNetQosRelease(XNQOS * pxnqos)
{
    XNetEnter(XNetQosRelease, pxnqos != NULL);

    #ifdef XNET_FEATURE_QOS
    INT err = IpQosRelease(pxnqos);
    #else
    INT err = WSAEACCES;
    #endif

    XNetLeave(err);
    return(err);
}

// ---------------------------------------------------------------------------------------
// Config
// ---------------------------------------------------------------------------------------

INT CXn::XNetConfig(const XNetConfigParams * pxncp, DWORD dwFlags)
{
    XNetEnter(XNetConfig, pxncp != NULL);
    INT err = IpConfig(pxncp, dwFlags);
    XNetLeave(err);
    return(err);
}

INT CXn::XNetGetConfigStatus(XNetConfigStatus * pxncs)
{
    XNetEnter(XNetGetConfigStatus, pxncs != NULL);
    INT err = IpGetConfigStatus(pxncs);
    XNetLeave(err);
    return(err);
}

// ---------------------------------------------------------------------------------------
// Main entrypoints for XNet/Winsock APIs
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_XBOX
CXn * g_pXn = NULL;
#endif

#undef  XNETAPI
#define XNETAPI(ret, fname, arglist, paramlist) ret _WSAAPI_ fname arglist { return(GetXn()->fname paramlist); }
#undef  XNETAPI_
#define XNETAPI_(ret, fname, arglist, paramlist)
#undef  XNETAPIV
#define XNETAPIV(ret, fname, arglist, paramlist)

XNETAPILIST()
SOCKAPILIST()

INT _WSAAPI_ XNetStartup(const XNetStartupParams * pxnsp)
{
    XNetParamCheck(XNetStartup, pxnsp == NULL || pxnsp->cfgSizeOfStruct == sizeof(XNetStartupParams), WSAEFAULT);
    return(XnInit((void **)GetXnRef(), GetAchXbox(), pxnsp, FALSE, 0, NULL));
}

int _WSAAPI_ WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData)
{
    WinsockApiPrologTrivial_(WSAStartup);
    WinsockApiParamCheck_(lpWSAData != NULL);
    return(XnInit((void **)GetXnRef(), GetAchXbox(), NULL, TRUE, wVersionRequired, lpWSAData));
}

INT _WSAAPI_ XNetCleanup()
{
    return(XnTerm((void **)GetXnRef(), FALSE));
}

int _WSAAPI_ WSACleanup()
{
    return(XnTerm((void **)GetXnRef(), TRUE));
}

// ---------------------------------------------------------------------------------------
// XNetGetEthernetLinkStatus
//
// This function is placed in the default .text code section so that is can be called
// before the XNET code section is loaded.
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_XBOX
#pragma code_seg(".text")
#endif

DWORD _WSAAPI_ XNetGetEthernetLinkStatus()
{
#ifdef XNET_FEATURE_XBOX
    while (InterlockedCompareExchange(&g_lXnLock, 1, 0))
    {
        Sleep(0);
    }
    
    if (g_pXn == NULL)
    {
        PhyInitialize(FALSE, NULL);
    }

    g_lXnLock = 0;

    return(PhyGetLinkState(FALSE));
#else
    return(XNET_ETHERNET_LINK_ACTIVE|XNET_ETHERNET_LINK_100MBPS|XNET_ETHERNET_LINK_FULL_DUPLEX);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\socktcp.cpp ===
// ---------------------------------------------------------------------------------------
// socktcp.cpp
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(tcpStat,  0);
DefineTag(tcpWarn,  TAG_ENABLE);

// ---------------------------------------------------------------------------------------
// TcpTimer
// ---------------------------------------------------------------------------------------

// TCP option length in our SYN segment
#define SYNTCPOPTLEN 4

void CXnSock::TcpTimer(CTimer * pt)
{
    CTcpSocket * pTcpSocket = CTcpSocket::TimerToSocket(pt);
    DWORD dwTickNow  = TimerTick();
    DWORD dwTickNext;

    if (pTcpSocket->delayedAcks)
    {
        TcpEmitACK(pTcpSocket);
    }

    if (pTcpSocket->dwTickSyn && dwTickNow >= pTcpSocket->dwTickSyn)
    {
        pTcpSocket->dwTickSyn = 0;
        if (TcpReset(pTcpSocket, NETERR_TIMEOUT) == NULL)
            return;
    }

    if (pTcpSocket->dwTickXmit && dwTickNow >= pTcpSocket->dwTickXmit)
    {
        pTcpSocket->dwTickXmit = 0;
        if (TcpXmitTimeout(pTcpSocket) == NULL)
            return;
    }

    if (pTcpSocket->dwTickWait && dwTickNow >= pTcpSocket->dwTickWait)
    {
        pTcpSocket->dwTickWait = 0;
        Assert(pTcpSocket->IsLingering());
        SockClose(pTcpSocket, TRUE);
        return;
    }

    dwTickNext = pTcpSocket->delayedAcks ? dwTickNow : TIMER_INFINITE;

    if (pTcpSocket->dwTickSyn > 0 && pTcpSocket->dwTickSyn < dwTickNext)
        dwTickNext = pTcpSocket->dwTickSyn;
    if (pTcpSocket->dwTickXmit > 0 && pTcpSocket->dwTickXmit < dwTickNext)
        dwTickNext = pTcpSocket->dwTickXmit;
    if (pTcpSocket->dwTickWait > 0 && pTcpSocket->dwTickWait < dwTickNext)
        dwTickNext = pTcpSocket->dwTickWait;

    TimerSet(pTcpSocket->GetTimer(), dwTickNext);
}

CTcpSocket * CXnSock::TcpXmitTimeout(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    This function is called when the TCP retransmission timer expires.

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    NULL if the specified CTcpSocket was deleted inside this call.
    Otherwise, just return the input pTcpSocket parameter.

--*/

{
    if (pTcpSocket->IsSendBufEmpty())
        return(pTcpSocket);

    CTcpSendBuf* pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();

    if (pTcpSendBuf->retries >= cfgSockRexmitRetries)
    {
        return(TcpReset(pTcpSocket, NETERR_TIMEOUT));
    }

    // Stop round-trip time measurement if there is retransmission
    pTcpSocket->rtt_tick = 0;

    // Retransmit the first segment
    if (pTcpSocket->TestFlags(SOCKF_PERSIST))
    {
        if (pTcpSendBuf->retries == 0)
        {
            // Send out the window probe segment for the first time.
            // BUGBUG: we always send out the whole segment instead
            // of just a single byte of data.

            Assert(pTcpSendBuf == pTcpSocket->GetSendBufPtr());
            TcpSendSegment(pTcpSocket, pTcpSendBuf, FALSE);
            pTcpSocket->snd_nxt = pTcpSendBuf->seqnext;
            pTcpSocket->SetSendBufPtr((CTcpSendBuf *)pTcpSocket->GetSendBufNext(pTcpSendBuf));
            return(pTcpSocket);
        }
    }
    else
    {
        TraceSz3(tcpStat, "[%X.t] Retransmission timeout seq %08lX (%d retries)",
                 pTcpSocket, pTcpSendBuf->seq, pTcpSendBuf->retries);
        Assert(pTcpSendBuf->retries != 0);
        // Congestion control:
        //  set the slow-start threshold to be half the flight size
        //  and set the congestion window to be 1 SMSS
        pTcpSocket->ResetSlowStartThresh();
        pTcpSocket->snd_cwnd = pTcpSocket->snd_mss;
        TcpStopFastRexmitMode(pTcpSocket);
    }

    TcpSendSegment(pTcpSocket, pTcpSendBuf, pTcpSendBuf->retries != 0);
    return(pTcpSocket);
}

CTcpSocket * CXnSock::TcpReset(CTcpSocket* pTcpSocket, NTSTATUS status)

/*++

Routine Description:

    Reset a TCP connection

Arguments:

    pTcpSocket - Points to the TCP control block
    status - Specifies the cause of the reset

Return Value:

    NULL if the specified CTcpSocket was deleted inside this call.
    Otherwise, just return the input pTcpSocket parameter.

--*/

{
    BOOL fRevivable;

    Assert(!pTcpSocket->IsIdleState());
    
    if (pTcpSocket->IsChild() || pTcpSocket->IsLingering())
    {
        SockClose(pTcpSocket, TRUE);
        return NULL;
    }

    // Remove the CTcpSocket from the active list
    // and move it to the zombie list.

    pTcpSocket->Dequeue();
    pTcpSocket->Enqueue(&_leDeadSockets);

    pTcpSocket->SetStatus((status != NETERR_CONNRESET || pTcpSocket->IsSyncState()) ? status : NETERR(WSAECONNREFUSED));

    fRevivable = !pTcpSocket->IsSyncState() && !pTcpSocket->TestFlags(SOCKF_NOMORE_XMIT|SOCKF_NOMORE_RECV);
    pTcpSocket->SetFlags(SOCKF_NOMORE_XMIT|SOCKF_NOMORE_RECV);
    TcpSetState(pTcpSocket, TCPST_CLOSED, "Reset");

    // Stop various timers
    // NOTE: This is a little hacky - we're clearing all the fields
    // from delayedAcks to rtt_tick in one shot. Be careful when you
    // add or remove fields from the CTcpSocket structure.

    memset(&pTcpSocket->delayedAcks, 0,
           offsetof(CTcpSocket, rtt_tick) + sizeof(pTcpSocket->rtt_tick) - offsetof(CTcpSocket, delayedAcks));

    TimerSet(pTcpSocket->GetTimer(), TIMER_INFINITE);
    pTcpSocket->TcpInit(this);
    pTcpSocket->ClearFlags(SOCKF_PERSIST|SOCKF_FAST_RETRANSMIT);
    pTcpSocket->SetDupAcks(0);
    pTcpSocket->SignalEvent(SOCKF_EVENT_MASK);

    SockCleanup(pTcpSocket);

    if (fRevivable)
    {
        pTcpSocket->SetFlags(SOCKF_REVIVABLE);
    }

    return(pTcpSocket);
}

CTcpSocket * CXnSock::TcpCloneChild(CTcpSocket * pTcpSocket)

/*++

Routine Description:

    Add a pending connection request to a listening socket

Arguments:

    pTcpSocket - Points to the listening socket

Return Value:

    Pointer to the child socket
    NULL if there is an error

--*/

{
    // Fail if the backlog is full
    Assert(pTcpSocket->IsListenState());

    if (pTcpSocket->GetBacklog() >= pTcpSocket->GetBacklogMax())
    {
        TraceSz2(Warning, "[%X.t] Reached backlog limit for listening socket (%d)",
                 pTcpSocket, pTcpSocket->GetBacklogMax());
        return(NULL);
    }
    
    // Allocate memory for the child socket
    CTcpSocket * pTcpSocketChild = (CTcpSocket *)SockAlloc(TRUE, TRUE);

    if (!pTcpSocketChild)
    {
        TraceSz1(Warning, "[%X.t] Out of memory allocating child of listening socket",
                 pTcpSocket);
        return(NULL);
    }

    pTcpSocket->EnqueueChild(pTcpSocketChild);

    return(pTcpSocketChild);
}
            
void CXnSock::TcpEmitRST(CTcpSocket * pTcpSocket, CIpAddr ipaDst, CIpPort ipportDst,
                         CIpPort ipportSrc, TCPSEQ seq, TCPSEQ ack, BYTE flags)
{
    CPacket * pkt = TcpPacketAlloc(pTcpSocket, ipaDst, PKTF_POOLALLOC);
    if (!pkt) return;

    CTcpHdr * pTcpHdr   = pkt->GetTcpHdr();
    pTcpHdr->SetHdrLen(sizeof(CTcpHdr));
    pTcpHdr->_ipportSrc = ipportSrc;
    pTcpHdr->_ipportDst = ipportDst;
    pTcpHdr->_dwSeqNum  = HTONL(seq);
    pTcpHdr->_dwAckNum  = HTONL(ack);
    pTcpHdr->_bFlags    = (BYTE)(TCP_RST | flags);
    pTcpHdr->_wWindow   = 0;
    pTcpHdr->_wUrgent   = 0;
    pTcpHdr->_wChecksum = 0;

    TraceTcpHdr(pktXmit, pTcpSocket, pTcpHdr, 0, 0);
    IpFillAndXmit(pkt, ipaDst, IPPROTOCOL_TCP);
}


// Return the effective snd_nxt value for a TCP connection
// NOTE: we cannot use CTcpSocket.snd_nxt field directly here
// because the way we're doing persisting causes snd_nxt
// to go past the send window.
TCPSEQ CXnSock::TcpSndNxt(CTcpSocket* pTcpSocket)
{
    TCPSEQ sndmax = pTcpSocket->snd_wl2 + pTcpSocket->snd_wnd;
    return (pTcpSocket->IsSyncState() && SEQ_GT(pTcpSocket->snd_nxt, sndmax)) ?
                sndmax :
                pTcpSocket->snd_nxt;
}

// Send a RST segment to the TCP connection peer
VOID CXnSock::TcpResetPeer(CTcpSocket* pTcpSocket)
{
    TcpEmitRST(pTcpSocket, pTcpSocket->_ipaDst, pTcpSocket->_ipportDst, pTcpSocket->_ipportSrc,
               TcpSndNxt(pTcpSocket), pTcpSocket->rcv_nxt, TCP_ACK);
}

NTSTATUS CXnSock::TcpEmitSYN(CTcpSocket* pTcpSocket, BOOL synAck)

/*++

Routine Description:

    Emit a TCP SYN segment

Arguments:

    pTcpSocket - Points to the TCP control block
    synAck - Whether to send ACK as well

Return Value:

    Status code

--*/

{
    CPacket* pkt;
    BYTE* opt;
    CTcpSendBuf* pTcpSendBuf;

    // Check if we're already trying to send out a SYN segment
    if (!pTcpSocket->IsSendBufEmpty())
    {
        pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->DequeueSendBuf();
        SockReleaseSendBuf(pTcpSendBuf);
        Assert(pTcpSocket->IsSendBufEmpty());
        Assert(pTcpSocket->GetSendBufPtr() == NULL);
    }

    pTcpSocket->snd_una = pTcpSocket->snd_nxt = pTcpSocket->snd_end = pTcpSocket->snd_isn;

    // Allocate a TCP send buffer for possible retransmission
    pkt = TcpPacketAlloc(pTcpSocket, pTcpSocket->_ipaDst, synAck ? PKTF_POOLALLOC : 0, SYNTCPOPTLEN,
                         sizeof(CTcpSendBuf), (PFNPKTFREE)TcpPacketFree);
    if (!pkt)
    {
        // This is very bad - we failed to allocate memory
        // for the SYN segment. We'll mark the CTcpSocket as dead
        // and return an error code.
        TcpReset(pTcpSocket, NETERR_MEMORY);
        return NETERR_MEMORY;
    }

    pTcpSocket->dwTickSyn = TimerSetRelative(pTcpSocket->GetTimer(), cfgSockConnectTimeoutInSeconds * TICKS_PER_SECOND);

    opt = (BYTE *)pkt->GetTcpHdr() + sizeof(CTcpHdr);
    opt[0] = TCPOPT_MAX_SEGSIZE;
    opt[1] = SYNTCPOPTLEN;
    opt[2] = (BYTE) (pTcpSocket->rcv_mss >> 8);
    opt[3] = (BYTE) pTcpSocket->rcv_mss;

    TcpQueueSegment(pTcpSocket, pkt, (BYTE) (synAck ? TCP_SYN|TCP_ACK : TCP_SYN), 0);
    return NETERR_OK;
}


void CXnSock::TcpEmitACK(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    Send out an ACK segment on a TCP connection

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    NONE

--*/

{
    CPacket * ppkt = TcpPacketAlloc(pTcpSocket, pTcpSocket->_ipaDst, PKTF_POOLALLOC);
    if (!ppkt)
        return;

    TCPSEQ seq = TcpSndNxt(pTcpSocket);
    pTcpSocket->delayedAcks = 0;

    CTcpHdr * pTcpHdr   = ppkt->GetTcpHdr();
    pTcpHdr->SetHdrLen(sizeof(CTcpHdr));
    pTcpHdr->_ipportSrc = pTcpSocket->_ipportSrc;
    pTcpHdr->_ipportDst = pTcpSocket->_ipportDst;
    pTcpHdr->_dwSeqNum  = HTONL(seq);
    pTcpHdr->_dwAckNum  = HTONL(pTcpSocket->rcv_nxt);
    pTcpHdr->_bFlags    = TCP_ACK;
    pTcpHdr->_wWindow   = HTONS((WORD)pTcpSocket->rcv_wnd);
    pTcpHdr->_wUrgent   = 0;
    pTcpHdr->_wChecksum = 0;

    TraceTcpHdr(pktXmit, pTcpSocket, pTcpHdr, 0, 0);
    IpFillAndXmit(ppkt, pTcpSocket->_ipaDst, IPPROTOCOL_TCP, &pTcpSocket->_prte);
}


NTSTATUS CXnSock::TcpEmitFIN(CTcpSocket * pTcpSocket)

/*++

Routine Description:

    Send out a FIN segment on a TCP connection

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    Status code

--*/

{
    ICHECK(SOCK, UDPC);
    CPacket * ppkt = TcpPacketAlloc(pTcpSocket, pTcpSocket->_ipaDst, 0, 0, sizeof(CTcpSendBuf), (PFNPKTFREE)TcpPacketFree);
    if (!ppkt) return NETERR_MEMORY;
    TcpQueueSegment(pTcpSocket, ppkt, TCP_ACK|TCP_FIN, 0);
    return(NETERR_OK);
}

//
// Update the receive window information after accepting
// the specified amount data from the connection peer.
//
void CXnSock::TcpSlideRecvWindow(CTcpSocket* pTcpSocket, UINT datalen)
{
    Assert(pTcpSocket->_cbMaxRecvBuf >= pTcpSocket->GetCbRecvBuf());

    UINT newwnd = pTcpSocket->_cbMaxRecvBuf - pTcpSocket->GetCbRecvBuf();

    // Here datalen must be <= rcv_wnd.
    Assert(datalen <= pTcpSocket->rcv_wnd);
    pTcpSocket->rcv_nxt += datalen;

    if ((datalen + newwnd) - pTcpSocket->rcv_wnd >= pTcpSocket->rcv_swsthresh) {
        // Enough space has freed up. Move the right edge of the receive window.
        pTcpSocket->rcv_wnd = newwnd;
    } else {
        // Implement receive side silly window avoidance:
        //  keep the right edge of the receive window unchanged.
        pTcpSocket->rcv_wnd -= datalen;
    }
}

void CXnSock::TcpUpdateRTO(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    Update the round-trip time measurements for a TCP connection

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    NONE

--*/

{
    INT nticks, delta;

    // The computation is based on the following formula:
    //  delta = nticks - srtt
    //  srtt = srtt + delta / 8
    //  rttvar = rttvar + (|delta| - rttvar) / 4
    //  RTO = srtt + 4 * rttvar

    nticks = TimerTick() - pTcpSocket->rtt_tick;
    pTcpSocket->rtt_tick = 0;

    if (pTcpSocket->srtt_8 != 0) {
        delta = nticks - (pTcpSocket->srtt_8 >> SRTT_SHIFT);
        if ((pTcpSocket->srtt_8 += delta) <= 0)
            pTcpSocket->srtt_8 = 1;

        if (delta < 0) delta = -delta;
        delta -= (pTcpSocket->rttvar_4 >> RTTVAR_SHIFT);
        if ((pTcpSocket->rttvar_4 += delta) <= 0)
            pTcpSocket->rttvar_4 = 1;
    } else {
        // The very first measurement - use the unsmoothed data
        if (nticks == 0) {
            pTcpSocket->srtt_8 = pTcpSocket->rttvar_4 = 1;
        } else {
            pTcpSocket->srtt_8 = nticks << SRTT_SHIFT;
            pTcpSocket->rttvar_4 = nticks << (RTTVAR_SHIFT-1);
        }
    }

    pTcpSocket->RTO = (pTcpSocket->srtt_8 >> SRTT_SHIFT) + pTcpSocket->rttvar_4;
    if (pTcpSocket->RTO < (UINT)cfgSockRexmitMinTimeoutInSeconds * TICKS_PER_SECOND)
        pTcpSocket->RTO = (UINT)cfgSockRexmitMinTimeoutInSeconds * TICKS_PER_SECOND;
}


BOOL CXnSock::TcpUpdatePersistFlag(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    This function is called after the send window information is updated.
    If we're currently sending out window probing segments, then
    we'll stop doing so if the send window has opened up.

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    FALSE if we got out of persist mode
    TRUE otherwise

--*/

{
    Assert(!pTcpSocket->IsSendBufEmpty());
    CTcpSendBuf* pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();

    if (pTcpSendBuf->GetCbBuf() <= pTcpSocket->snd_wnd)
    {
        pTcpSocket->ClearFlags(SOCKF_PERSIST);

        if (pTcpSendBuf->retries)
        {
            TraceSz1(tcpStat, "[%X.t] Retransmit persisting segment...", pTcpSocket);
            pTcpSendBuf->retries = 0;
            TcpSendSegment(pTcpSocket, pTcpSendBuf, TRUE);
        }
        else
        {
            pTcpSocket->dwTickXmit = 0;
        }

        return(FALSE);
    }

    return(TRUE);
}


void CXnSock::TcpUpdateSndUna(CTcpSocket* pTcpSocket, TCPSEQ ack)

/*++

Routine Description:

    Update the snd.una variable for a TCP connection

Arguments:

    pTcpSocket - Points to the TCP connection block
    ack - The acknowledged sequence number

Return Value:

    NONE

--*/

{
    CTcpSendBuf *   pTcpSendBuf;
    CTcpSendBuf *   pTcpSendBufNext;
    UINT            ackedSends = 0;

    if (SEQ_GT(ack, pTcpSocket->snd_una))
    {
        pTcpSocket->snd_una = ack;

        // Update round-trip time measurements
        if (pTcpSocket->rtt_tick && SEQ_GT(ack, pTcpSocket->rtt_seq))
        {
            TcpUpdateRTO(pTcpSocket);
        }

        // Complete fully acknowledged send user requests

        pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();

        while (pTcpSendBuf)
        {
            if (pTcpSendBuf->retries && SEQ_GE(ack, pTcpSendBuf->seqnext))
            {
                pTcpSendBufNext = (CTcpSendBuf *)pTcpSocket->GetSendBufNext(pTcpSendBuf);
                pTcpSocket->DequeueSendBuf();
                pTcpSocket->DecCbSendBuf(pTcpSendBuf->GetCbBuf());
                SockReleaseSendBuf(pTcpSendBuf);
                ackedSends++;
                pTcpSendBuf = pTcpSendBufNext;
            }
            else
            {
                break;
            }
        }
    }

    // Update congestion window
    if (pTcpSocket->TestFlags(SOCKF_FAST_RETRANSMIT))
    {
        if (ackedSends)
        {
            //
            // Getting out of fast retransmit / fast recovery mode:
            //  "deflate" the congestion window
            //
            pTcpSocket->snd_cwnd = pTcpSocket->snd_ssthresh;
        }
        else
        {
            //
            // In fast recovery mode:
            //  increment the congestion window by SMSS
            //  for every duplicate ACK received.
            //
            pTcpSocket->IncrementCongestionWindow(pTcpSocket->snd_mss);
        }
    }
    else
    {
        if (pTcpSocket->snd_cwnd < pTcpSocket->snd_ssthresh)
        {
            //
            // Slow-start mode:
            //  increment the congestion window by SMSS
            //
            pTcpSocket->IncrementCongestionWindow(pTcpSocket->snd_mss);
        }
        else
        {
            //
            // Congestion avoidance mode:
            //  increment the congestion window by ~SMSS per RTT
            //
            // NOTE: Overflow is not possible here because snd_mss
            // and snd_cwnd are 16-bit numbers. Also snd_cwnd is never 0.
            //
            UINT inc = pTcpSocket->snd_mss * pTcpSocket->snd_mss / pTcpSocket->snd_cwnd;
            pTcpSocket->IncrementCongestionWindow(max(1, inc));
        }
    }

    if (ackedSends)
    {
        pTcpSocket->ClearFlags(SOCKF_PERSIST);
        TcpStopFastRexmitMode(pTcpSocket);

        // Reset retransmission timer
        pTcpSocket->dwTickXmit = 0;

        if (pTcpSocket->snd_una != pTcpSocket->snd_nxt)
        {
            pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();

            if (pTcpSendBuf->firstSendTime + pTcpSocket->RTO <= TimerTick())
            {
                TcpXmitTimeout(pTcpSocket);
            }
            else
            {
                pTcpSocket->dwTickXmit = TimerSetRelative(pTcpSocket->GetTimer(), pTcpSendBuf->firstSendTime + pTcpSocket->RTO - TimerTick());
            }
        }

        if (!pTcpSocket->IsSendBufFull())
        {
            if (pTcpSocket->HasSendReq())
            {
                CSendReq * pSendReq = pTcpSocket->GetSendReq();
                NTSTATUS status = TcpSend(pTcpSocket, pSendReq, PKTF_POOLALLOC);
                pSendReq->_pWsaOverlapped->_ioxfercnt = pSendReq->sendtotal;
                SockReqComplete(pTcpSocket, pSendReq, status);
            }
            else
            {
                pTcpSocket->SignalEvent(SOCKF_EVENT_WRITE);
            }
        }
    }
    else if (pTcpSocket->TestFlags(SOCKF_PERSIST))
    {
        // If we're probing the send window and the ack was for
        // the probe segment, then make sure we continue to probe
        // without timing out.

        pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();

        if (SEQ_GE(ack, pTcpSendBuf->seq) &&
            pTcpSendBuf->retries >= cfgSockRexmitRetries-1)
        {
            pTcpSendBuf->retries--;
        }
    }
    else
    {
        if (pTcpSocket->snd_una != pTcpSocket->snd_nxt &&
            !pTcpSocket->TestFlags(SOCKF_FAST_RETRANSMIT) &&
            pTcpSocket->IncDupAcks() >= 4)
        {
            //
            // Too many duplicate ACK received:
            //  do fast retransmit / recovery
            //
            TcpDoFastRexmit(pTcpSocket);
        }
    }

    // If the send window has opened up and
    // we have pending data to send, try to do it now.
    if (!pTcpSocket->TestFlags(SOCKF_PERSIST) || !TcpUpdatePersistFlag(pTcpSocket))
    {
        while (pTcpSocket->GetSendBufPtr() && TcpStartOutput(pTcpSocket))
            NULL;
    }
}

void CXnSock::TcpDoFastRexmit(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    Initiate the TCP fast retransmit / recovery procedure

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    NONE

--*/

{
    CTcpSendBuf* pTcpSendBuf;

    TraceSz2(tcpStat, "[%X.t] Fast rexmit mode: %08lX", pTcpSocket, pTcpSocket->snd_una);

    // Reset the slow-start threshold
    // and set the congestion window to be that plus 3*SMSS
    pTcpSocket->ResetSlowStartThresh();
    pTcpSocket->snd_cwnd = pTcpSocket->snd_ssthresh + 3*pTcpSocket->snd_mss;
    pTcpSocket->SetFlags(SOCKF_FAST_RETRANSMIT);
    pTcpSocket->SetDupAcks(0);

    // Retransmit the "lost" segment immediately
    Assert(pTcpSocket->HasSendBuf());
    pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();
    Assert(pTcpSendBuf->retries);
    TcpSendSegment(pTcpSocket, pTcpSendBuf, TRUE);
}


// 
// Check if an acknowledged sequence number is valid for a TCP connection
//
#define IsValidACK(_pTcpSocket, _ack) \
        (SEQ_GT((_ack), (_pTcpSocket)->snd_una) && \
         SEQ_LE((_ack), (_pTcpSocket)->snd_nxt))

//
// Indicate whether we should send out an ACK immediately
// in response to an incoming segment.
//
//#define NeedSendACKNow(_pTcpSocket) ((_pTcpSocket)->delayedAcks += 0x20000)

void CXnSock::NeedSendACKNow(CTcpSocket * pTcpSocket)
{
    pTcpSocket->delayedAcks += 0x20000;
}

//
// Save the send window information from the connection peer
//
#define TcpUpdateSndWnd(_pTcpSocket, _wnd, _seq, _ack) { \
            (_pTcpSocket)->snd_wnd = (_wnd); \
            (_pTcpSocket)->snd_wl1 = (_seq); \
            (_pTcpSocket)->snd_wl2 = (_ack); \
        }


BOOL CXnSock::TcpValidateSeqs(CTcpSocket* pTcpSocket, TCPSEQ oldseq0, TCPSEQ oldseq1, TCPSEQ* newseq0, TCPSEQ* newseq1)

/*++

Routine Description:

    Check if the received sequence number is valid for a TCP connection

Arguments:

    pTcpSocket - Points to TCP control block
    oldseq0 - Starting sequence number from the received segment
    oldseq1 - Ending sequence number from the received segment (oldseq+seglen)
    newseq0 - Returns the effective starting sequence number inside the receive window
    newseq1 - Returns the effective ending sequence number

Return Value:

    FALSE if none of the received segment is inside the receive window,
    TRUE otherwise. In the latter case, seq0 and seq1 will return updated
    sequence numbers.

--*/

{
    TCPSEQ rcv_last;

    rcv_last = pTcpSocket->rcv_nxt + pTcpSocket->rcv_wnd;
    *newseq0 = SEQ_LT(oldseq0, pTcpSocket->rcv_nxt) ? pTcpSocket->rcv_nxt : oldseq0;
    *newseq1 = SEQ_GT(oldseq1, rcv_last) ? rcv_last : oldseq1;

    return SEQ_LT(*newseq0, *newseq1) ||
           (*newseq0 == *newseq1 && oldseq0 == oldseq1);
}


#if DBG

BOOL CXnSock::TcpVerifyRecvBuf(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    Verify the current receive buffers for a CTcpSocket is good

Arguments:

    pTcpSocket - Points to the TCP control block

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    if (!pTcpSocket->HasRecvBuf())
        return(TRUE);

    CTcpRecvBuf * pTcpRecvBuf0 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufFirst();
    CTcpRecvBuf * pTcpRecvBuf1;

    while (1)
    {
        pTcpRecvBuf1 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufNext(pTcpRecvBuf0);

        if (pTcpRecvBuf1 == NULL)
            return(TRUE);

        if (SEQ_GT(pTcpRecvBuf0->seqnext, pTcpRecvBuf1->seqnext - pTcpRecvBuf1->GetCbBuf()))
            return(FALSE);

        pTcpRecvBuf0 = pTcpRecvBuf1;
    }
}

#endif // DBG


UINT CXnSock::TcpCorrectMisorderedSegments(CTcpSocket* pTcpSocket, TCPSEQ seq, CTcpRecvBuf* recvbuf)

/*++

Routine Description:

    This function is called when we receive a segment
    whose starting sequence number matches rcv_nxt and
    there are buffered out-of-order segments after this one.

Arguments:

    pTcpSocket - Points to TCP control block
    seq - Specifies the starting sequence number for this segment
    recvbuf - Points to the received data buffer

Return Value:

    Number of continuous bytes that can be acknowledged

--*/

{
    CTcpRecvBuf* buf0 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufLast();
    CTcpRecvBuf* buf1;
    UINT count;

    do
    {
        buf0 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufPrev(buf0);
    }
    while (buf0 && buf0->seqnext != seq);

    buf1 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufNext(buf0);

    if (SEQ_GT(recvbuf->seqnext, buf1->seqnext - buf1->GetCbBuf())) {
        // Weird case: data in this segment overlapps with
        // data in the buffered out-of-order segments.
        // Chop off the overlapped data in the current receive buffer.
        TraceSz1(tcpStat, "[%X.t] TcpCorrectMisorderedSegments: overlapping segment", pTcpSocket);

        count = recvbuf->seqnext - (buf1->seqnext - buf1->GetCbBuf());
        Assert(count < recvbuf->GetCbBuf());

        recvbuf->DecCbBuf(count);
        recvbuf->seqnext -= count;
    }

    // Insert recvbuf after buf0 and before buf1
    pTcpSocket->InsertRecvBuf(recvbuf, buf0);

    count = recvbuf->GetCbBuf();
    buf0 = recvbuf;
    while (buf1 && buf0->seqnext == buf1->seqnext - buf1->GetCbBuf())
    {
        count += buf1->GetCbBuf();
        buf0 = buf1;
        buf1 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufNext(buf1);
    }

    // If we filled up a hole, emit an ACK immediately
    if (count > recvbuf->GetCbBuf())
    {
        NeedSendACKNow(pTcpSocket);
    }

    // Assert(TcpVerifyRecvBuf(pTcpSocket));
    return count;
}


void CXnSock::TcpBufferMisorderedSegment(CTcpSocket* pTcpSocket, UINT seq, CTcpRecvBuf* recvbuf)


/*++

Routine Description:

    This function is called when we receive an out-of-order segment.

Arguments:

    pTcpSocket - Points to TCP control block
    seq - Specifies the starting sequence number for this segment
    recvbuf - Points to the received data buffer

Return Value:

    NONE

--*/

{
    CTcpRecvBuf* buf0 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufLast();
    CTcpRecvBuf* buf1;
    UINT count;

    if (buf0 == NULL || SEQ_GE(seq, buf0->seqnext))
    {
        // The sequence number for this segment is larger
        // than everything in the receive buffer.
        pTcpSocket->EnqueueRecvBuf(recvbuf);
        return;
    }

    do
    {
        buf0 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufPrev(buf0);
    }
    while (buf0 != NULL && SEQ_LT(seq, buf0->seqnext));

    // recvbuf should go in between buf0 and buf1

    buf1 = (CTcpRecvBuf *)pTcpSocket->GetRecvBufNext(buf0);

    if (SEQ_GT(recvbuf->seqnext, buf1->seqnext - buf1->GetCbBuf()))
    {
        // Data in this segment overlapps with
        // data in the buffered out-of-order segments.
        TraceSz1(tcpStat, "[%X.t] TcpBufferMisorderedSegment: overlapping segment", pTcpSocket);
        
        count= recvbuf->seqnext - (buf1->seqnext - buf1->GetCbBuf());

        if (count >= recvbuf->GetCbBuf())
        {
            PoolFree(recvbuf);
            return;
        }

        recvbuf->DecCbBuf(count);
        recvbuf->seqnext -= count;
    }

    pTcpSocket->InsertRecvBuf(recvbuf, buf0);

    // Assert(TcpVerifyRecvBuf(pTcpSocket));
}


UINT CXnSock::TcpCompletePendingRecvReqFast(CTcpSocket* pTcpSocket, BYTE tcpflags, BYTE * pbData, UINT cbData)

/*++

Routine Description:

    This function is called when we received data from a TCP connection
    and there is a pending overlapped receive request
    and there is currently no data in the receive buffer.
    In this case we can satisfy the request right away without
    allocating memory to store data in the receive buffer.

Arguments:

    pTcpSocket - Points to the TCP control block
    tcpflags - TCP segment flags

Return Value:

    Number of bytes used up in this call

--*/

{
    UINT copycnt;
    CRecvReq* pRecvReq = pTcpSocket->GetRecvReq();

    copycnt = min(cbData, pRecvReq->buflen);
    memcpy(pRecvReq->buf, pbData, copycnt);
    pRecvReq->_pWsaOverlapped->_ioxfercnt += copycnt;
    pRecvReq->buf += copycnt;
    pRecvReq->buflen -= copycnt;

    if ((pRecvReq->buflen == 0) || (tcpflags & TCP_PSH|TCP_URG)) {
        SockReqComplete(pTcpSocket, pRecvReq, NETERR_OK);
    }

    TcpSlideRecvWindow(pTcpSocket, copycnt);
    return copycnt;
}


CTcpSocket * CXnSock::TcpRecvData(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr, BYTE * pbData, UINT cbData)

/*++

Routine Description:

    Process a received TCP data segment.
    And we assume the connection is in a synchronized state.

Arguments:

    pTcpSocket - Points to the TCP connection block
    tcphdr - Points to the TCP segment header information

Return Value:

    NULL if the CTcpSocket was deleted as a result of the incoming segment;
    Otherwise, just return the input pTcpSocket parameter

--*/

{
    TCPSEQ seq, ack, seq0, seq1;
    CTcpRecvBuf* recvbuf;
    DWORD dwTickWait;

    seq = SEG_SEQ(tcphdr);

    // Process ACK if it's present
    if (ISTCPSEG(tcphdr, ACK))
    {
        ack = SEG_ACK(tcphdr);
        if (SEQ_LT(ack, pTcpSocket->snd_una))
        {
            // ACK is an old duplicate, ignore it
        }
        else if (SEQ_GT(ack, pTcpSocket->snd_nxt))
        {
            // ACKing something that hasn't been sent.
            // Emit an ACK, drop the segment
            NeedSendACKNow(pTcpSocket);
            return pTcpSocket;
        }
        else
        {
            // update the send window information
            if (SEQ_LT(pTcpSocket->snd_wl1, seq) ||
                pTcpSocket->snd_wl1 == seq && SEQ_LE(pTcpSocket->snd_wl2, ack))
            {
                TcpUpdateSndWnd(pTcpSocket, SEG_WIN(tcphdr), seq, ack);
            }

            TcpUpdateSndUna(pTcpSocket, ack);

            // If we already sent FIN, check to see if FIN has been acknowledged
            if (pTcpSocket->IsFinSent() && pTcpSocket->IsSendBufEmpty())
            {
                switch (pTcpSocket->GetState())
                {
                case TCPST_FIN_WAIT_1:
                    TcpSetState(pTcpSocket, TCPST_FIN_WAIT_2, "FinAck");
                    break;

                case TCPST_CLOSING:
                    TcpSetState(pTcpSocket, TCPST_TIME_WAIT, "FinAck");

                    dwTickWait = TimerTick() + 2*cfgSockSegmentLifetimeInSeconds*TICKS_PER_SECOND;

                    if (pTcpSocket->dwTickWait == 0 || dwTickWait < pTcpSocket->dwTickWait)
                    {
                        pTcpSocket->dwTickWait = TimerSetRelative(pTcpSocket->GetTimer(), dwTickWait - TimerTick());
                    }
                    return NULL;

                case TCPST_LAST_ACK:
                    SockClose(pTcpSocket, TRUE);
                    return NULL;
                }
            }
        }
    }

    // If we already receive FIN from the peer,
    // we'll just ignore incoming data.
    if (pTcpSocket->IsFinReceived() || cbData == 0)
        return(pTcpSocket);

    pTcpSocket->delayedAcks += cbData;

    // Quick check to see if the data from incoming segment
    // fits entirely within the current receive window.
    if (seq != pTcpSocket->rcv_nxt || cbData > pTcpSocket->rcv_wnd)
    {
        // If the receive sequence number is outside of
        // the current receive window, send an ACK right away.
        if (!TcpValidateSeqs(pTcpSocket, seq, seq+cbData, &seq0, &seq1))
        {
            TraceSz4(tcpStat, "[%X.t] Sequence number out-of-range: %08lX %08lX %d",
                     pTcpSocket, seq, pTcpSocket->rcv_nxt, pTcpSocket->rcv_wnd);
            NeedSendACKNow(pTcpSocket);
            return pTcpSocket;
        }

        pbData += (seq0 - seq);
        cbData = (seq1 - seq0);
        Assert((INT)cbData > 0);
        seq = seq0;
    }

    if (pTcpSocket->TestFlags(SOCKF_NOMORE_RECV))
    {
        TcpResetPeer(pTcpSocket);
        TcpReset(pTcpSocket, NETERR_CONNRESET);
        return NULL;
    }

    // Special fast path: there is a pending overlapped receive request
    // and there is no data in the receive buffer.
    if (    pTcpSocket->HasRecvReq()
        &&  seq == pTcpSocket->rcv_nxt
        &&  !pTcpSocket->HasRecvBuf())
    {
        UINT copied = TcpCompletePendingRecvReqFast(pTcpSocket, tcphdr->_bFlags, pbData, cbData);
        if (copied == cbData) return pTcpSocket;

        pbData += copied;
        cbData -= copied;
        seq += copied;
    }

    // Make a copy of the incoming segment and buffer it up
    recvbuf = (CTcpRecvBuf*) PoolAlloc(sizeof(CTcpRecvBuf) + cbData, PTAG_CTcpRecvBuf);

    if (!recvbuf)
    {
        TraceSz2(tcpWarn, "[%X.t] Out of memory allocating receive buffer.  %ld bytes lost.",
                 pTcpSocket, cbData);
        return(pTcpSocket);
    }

    recvbuf->Init(this);

    recvbuf->seqnext = seq + cbData;
    recvbuf->dataoffset = sizeof(CTcpRecvBuf);
    recvbuf->tcpflags = tcphdr->_bFlags;
    recvbuf->SetCbBuf(cbData);
    memcpy(recvbuf+1, pbData, cbData);

    // Fast case: the receive segment is in sequence
    if (seq == pTcpSocket->rcv_nxt)
    {
        CTcpRecvBuf* lastbuf = (CTcpRecvBuf *)pTcpSocket->GetRecvBufLast();
        UINT datarun;

        if (lastbuf == NULL || lastbuf->seqnext == seq)
        {
            // We haven't buffered any out-of-order segments behind this one.
            datarun = cbData;
            pTcpSocket->EnqueueRecvBuf(recvbuf);
        }
        else
        {
            // Figure out if this segment fills out holes
            // in the receive buffer.
            Assert(SEQ_LT(seq, lastbuf->seqnext));
            datarun = TcpCorrectMisorderedSegments(pTcpSocket, seq, recvbuf);
        }

        pTcpSocket->SetCbRecvBuf(pTcpSocket->GetCbRecvBuf() + datarun);
        TcpSlideRecvWindow(pTcpSocket, datarun);

        if (pTcpSocket->HasRecvReq())
        {
            // If we have a pending overlapped receive request, satisfy it now
            CRecvReq* pRecvReq = pTcpSocket->GetRecvReq();
            pRecvReq->_pWsaOverlapped->_ioxfercnt += TcpCopyRecvData(pTcpSocket, pRecvReq);

            if (pRecvReq->buflen == 0)
            {
                SockReqComplete(pTcpSocket, pRecvReq, NETERR_OK);
            }

            TcpSlideRecvWindow(pTcpSocket, 0);
        }
        else
        {
            pTcpSocket->SignalEvent(SOCKF_EVENT_READ);
        }
    }
    else
    {
        // Slow case: a segment arrived out of order.
        // Buffer up this segment for later processing.
        TraceSz3(tcpStat, "[%X.t] Out-of-order segment: %08lX %08lX", pTcpSocket, SEG_SEQ(tcphdr), pTcpSocket->rcv_nxt);
        NeedSendACKNow(pTcpSocket);
        TcpBufferMisorderedSegment(pTcpSocket, seq, recvbuf);
    }

    return(pTcpSocket);
}


void CXnSock::TcpProcessFIN(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr, TCPSEQ seqfin)

/*++

Routine Description:

    Process an incoming TCP FIN segment

Arguments:

    pTcpSocket - Points to the TCP control block
    tcphdr - Points to the TCP segment header
    seqfin - Sequence number for the FIN

Return Value:

    NONE

--*/

{
    DWORD dwTickWait;

    if (seqfin != pTcpSocket->rcv_nxt)
        return;

    pTcpSocket->rcv_nxt = seqfin+1;
    NeedSendACKNow(pTcpSocket);
    pTcpSocket->SignalEvent(SOCKF_EVENT_CLOSE);

    switch (pTcpSocket->GetState()) {
    case TCPST_SYN_RECEIVED:
    case TCPST_ESTABLISHED:
        SockReqComplete(pTcpSocket, pTcpSocket->GetRecvReq(), NETERR_OK);
        pTcpSocket->SignalEvent(SOCKF_EVENT_READ);
        TcpSetState(pTcpSocket, TCPST_CLOSE_WAIT, "FinRecv");
        break;

    case TCPST_FIN_WAIT_1:
        if (pTcpSocket->IsSendBufEmpty()) {
            TcpSetState(pTcpSocket, TCPST_CLOSING, "FinRecv");
            break;
        }

        // If our FIN has been acknowledged,
        // fall through and change to TIME-WAIT state.

    case TCPST_FIN_WAIT_2:
        TcpSetState(pTcpSocket, TCPST_TIME_WAIT, "FinRecv");

        // Fall through

    case TCPST_TIME_WAIT:
        dwTickWait = TimerTick() + 2*cfgSockSegmentLifetimeInSeconds*TICKS_PER_SECOND;

        if (pTcpSocket->dwTickWait == 0  || dwTickWait < pTcpSocket->dwTickWait)
        {
            pTcpSocket->dwTickWait = TimerSetRelative(pTcpSocket->GetTimer(), dwTickWait - TimerTick());
        }
        break;
    }
}


//
// Structure for storing TCP option parameters
// from an incoming SYN segment
//
typedef struct _TcpOptions {
    UINT mss;
    // other TCP option parameters ...
} TcpOptions;

BOOL CXnSock::TcpParseOptions(CTcpSocket * pTcpSocket, CTcpHdr * tcphdr, struct _TcpOptions * opts)

/*++

Routine Description:

    Parse the option information in an incoming TCP SYN segment

Arguments:

    tcphdr - Points to the TCP segment header
    opts - Returns the parsed option information

Return Value:

    TRUE if successful, FALSE if the TCP options are not well-formed

--*/

{
    const BYTE* buf;
    UINT buflen;

    // We ignore any data that's sent in the initial SYN segment.
    // Not sure if this case actually happens in real-life.
    // In any case, the sender should retransmit the data.
#if 0
    if (ISTCPSEG(tcphdr, SYN) && cbData > 0) {
        TraceSz(Warning, "Ignoring data in SYN segment.");
    }
#endif

    // Use default values if no options are present
    opts->mss = TCP_DEFAULT_MSS;

    buflen = tcphdr->GetHdrLen() - sizeof(CTcpHdr);
    buf = (const BYTE*) (tcphdr+1);

    while (buflen) {
        BYTE opt, optlen;

        if ((opt = *buf) == TCPOPT_EOL) break;
        if (opt == TCPOPT_NOP) {
            buf++; buflen--; 
            continue;
        }

        // Verify option length field
        if (buflen < 2 || (optlen = buf[1]) < 2 || optlen > buflen)
            return FALSE;

        switch (opt) {
        case TCPOPT_MAX_SEGSIZE:
            if (optlen != 4) return FALSE;
            opts->mss = ((UINT) buf[2] << 8) | buf[3];
            if (opts->mss < TCP_MINIMUM_MSS)
                opts->mss = TCP_DEFAULT_MSS;
            break;

        default:
            TraceSz1(tcpStat, "TCP option ignored: %d", opt);
            break;
        }

        buf += optlen;
        buflen -= optlen;
    }
    return TRUE;
}


//
// Save the relevant information in an incoming connection request
//
#define TcpSaveConnReqParams(_pTcpSocket, _tcphdr, _opts) { \
            (_pTcpSocket)->rcv_isn = SEG_SEQ(_tcphdr); \
            (_pTcpSocket)->rcv_nxt = (_pTcpSocket)->rcv_isn+1; \
            (_pTcpSocket)->snd_mss = (_opts)->mss; \
        }

BOOL CXnSock::TcpAcceptConnReqPassive(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr, CIpAddr ipaSrc)

/*++

Routine Description:

    Process an incoming TCP connection request
    that was made to a listening (passively opened) socket

Arguments:

    pTcpSocket - TCP control block
    tcphdr - Points to the TCP segment header

Return Value:

    FALSE if the incoming connection request is bad and
    the caller should send out a RST in response; TRUE otherwise

--*/

{
    NTSTATUS status;
    CTcpSocket* pTcpSocketChild;
    TcpOptions opts;

    // Parse TCP options
    if (!TcpParseOptions(pTcpSocket, tcphdr, &opts)) return FALSE;

    pTcpSocketChild = TcpCloneChild(pTcpSocket);
    if (!pTcpSocketChild) return TRUE;

    TcpSetState(pTcpSocketChild, TCPST_SYN_RECEIVED, "Connection request");
    TcpSaveConnReqParams(pTcpSocketChild, tcphdr, &opts);

    status = TcpConnect(pTcpSocketChild, ipaSrc, tcphdr->_ipportSrc, TRUE);
    if (!NT_SUCCESS(status)) {
        SockClose(pTcpSocketChild, TRUE);
        return TRUE;
    }

    pTcpSocketChild->Enqueue(&_leSockets);

    return(TRUE);
}


void CXnSock::TcpConnectionEstablished(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr)

/*++

Routine Description:

    Change a TCP connection to established state

Arguments:

    pTcpSocket - Points to the TCP control block
    tcphdr - Points to the incoming SYN/ACK segment

Return Value:

    NONE

--*/

{
    TCPSEQ ack;
    CTcpSendBuf* pTcpSendBuf;

    TraceSz4(tcpStat, "[%X.t] Connection established on %d to %s:%d ", pTcpSocket,
             NTOHS(pTcpSocket->_ipportSrc), pTcpSocket->_ipaDst.Str(),
             NTOHS(pTcpSocket->_ipportDst));

    //
    // The incoming segment must acknowledge our SYN
    //
    pTcpSendBuf = (CTcpSendBuf *)pTcpSocket->GetSendBufFirst();
    ack = SEG_ACK(tcphdr);
    Assert(pTcpSendBuf->tcpflags & TCP_SYN);
    Assert(ISTCPSEG(tcphdr, ACK));
    Assert(ack == pTcpSocket->snd_nxt);

    pTcpSocket->snd_una = ack;
    TcpUpdateSndWnd(pTcpSocket, SEG_WIN(tcphdr), SEG_SEQ(tcphdr), ack);

    if (pTcpSocket->rtt_tick)
    {
        TcpUpdateRTO(pTcpSocket);
    }

    pTcpSocket->DequeueSendBuf(pTcpSendBuf);
    SockReleaseSendBuf(pTcpSendBuf);

    pTcpSocket->dwTickXmit = pTcpSocket->dwTickSyn = 0;

    // NOTE: Since we don't fragment outgoing IP datagrams, we need
    // to limit snd_mss to be less than the first-hop interface MTU
    // minus the TCP and IP headers.
    if (pTcpSocket->snd_mss > pTcpSocket->rcv_mss)
        pTcpSocket->snd_mss = pTcpSocket->rcv_mss;

    pTcpSocket->snd_cwnd = 2*pTcpSocket->snd_mss;
    pTcpSocket->snd_ssthresh = max(pTcpSocket->snd_wnd, pTcpSocket->snd_cwnd);
    pTcpSocket->rcv_swsthresh = min(pTcpSocket->_cbMaxSendBuf>>1, pTcpSocket->snd_mss);
    if (pTcpSocket->rcv_swsthresh < 1)
        pTcpSocket->rcv_swsthresh = 1;

    TcpSetState(pTcpSocket, TCPST_ESTABLISHED, "Connected");
    pTcpSocket->SetFlags(SOCKF_CONNECTED);
    pTcpSocket->SignalEvent(SOCKF_EVENT_CONNECT);

    if (pTcpSocket->IsChild())
    {
        // Signal the connection request is ready for acceptance
        pTcpSocket->GetParent()->SignalEvent(SOCKF_EVENT_ACCEPT);
    }
}


BOOL CXnSock::TcpAcceptConnReqActive(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr)

/*++

Routine Description:

    Process an incoming TCP connection request
    that was made to an actively opened socket

Arguments:

    pTcpSocket - TCP control block
    tcphdr - Points to the TCP segment header

Return Value:

    FALSE if the incoming connection request is bad and
    the caller should send out a RST in response; TRUE otherwise

--*/

{
    TcpOptions opts;
    NTSTATUS status;

    // Parse TCP options and save connection request information
    if (!TcpParseOptions(pTcpSocket, tcphdr, &opts)) return FALSE;
    TcpSaveConnReqParams(pTcpSocket, tcphdr, &opts);

    if (ISTCPSEG(tcphdr, ACK)) {
        TcpConnectionEstablished(pTcpSocket, tcphdr);
        NeedSendACKNow(pTcpSocket);
        status = NETERR_OK;
    } else {
        TcpSetState(pTcpSocket, TCPST_SYN_RECEIVED, "Simultaneous open");
        status = TcpEmitSYN(pTcpSocket, TRUE);
    }

    return NT_SUCCESS(status);
}


void CXnSock::TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbData)
{
    CTcpSocket *    pTcpSocket;
    BYTE *          pbData = (BYTE *)pTcpHdr + cbHdrLen;
    BOOL            isAck;
    TCPSEQ          ack;

    pTcpSocket = (CTcpSocket *)SockFindMatch(pTcpHdr->_ipportDst, pIpHdr->_ipaSrc,
                                             pTcpHdr->_ipportSrc, SOCK_STREAM);

#if defined(XNET_FEATURE_ONLINE) && !defined(XNET_FEATURE_INSECURE)
    if (!ppkt->IsEsp() && !ppkt->TestFlags(PKTF_RECV_LOOPBACK) && !pTcpSocket->TestFlags(SOCKF_INSECURE))
    {
        // An insecure, non-loopback TCP packet will only be sent to a socket in the
        // secure online stack if the socket has explicitly allowed insecure packets.

        pTcpSocket = NULL;
    }
#endif

    if (!pTcpSocket)
    {
#ifdef XNET_FEATURE_TRACE
        if (ppkt->IsEsp())
            TraceSz3(pktWarn, "[DISCARD] No TCP socket listening on port %d from %s:%d",
                     NTOHS(pTcpHdr->_ipportDst), pIpHdr->_ipaSrc.Str(), NTOHS(pTcpHdr->_ipportSrc));
        else
            TraceSz3(pktRecv, "[DISCARD] No TCP socket listening on port %d from %s:%d",
                     NTOHS(pTcpHdr->_ipportDst), pIpHdr->_ipaSrc.Str(), NTOHS(pTcpHdr->_ipportSrc));
#endif

#if defined(XNET_FEATURE_ONLINE) && !defined(XNET_FEATURE_INSECURE)
        if (!ppkt->IsEsp())
        {
            // An insecure TCP packet will not be sent a RST because we want to be "stealthy" and
            // not let a PC get any sort of response from us by sending random TCP packets.

            return;
        }
#endif

        goto sendrst;
    }

    TraceTcpHdr(pktRecv, pTcpSocket, pTcpHdr, cbHdrLen - sizeof(CTcpHdr), cbData);

    if (pTcpSocket->IsSyncState() && (pTcpHdr->_bFlags & TCP_CONTROLS) == 0)
    {
        // Common case of receiving data in a synchronized state

        pTcpSocket = TcpRecvData(pTcpSocket, pTcpHdr, pbData, cbData);

        goto rcvdone;
    }

    if (pTcpSocket->GetState() == TCPST_CLOSED)
    {
        TraceSz1(tcpWarn, "[%X.t] Received packet on closed socket.  Sending RST.", pTcpSocket);
        goto sendrst;
    }

    Assert(!pIpHdr->_ipaDst.IsBroadcast());
    Assert(!pIpHdr->_ipaSrc.IsBroadcast());

    isAck = ISTCPSEG(pTcpHdr, ACK);

    switch (pTcpSocket->GetState())
    {
        case TCPST_LISTEN:

            if (ISTCPSEG(pTcpHdr, RST))
            {
                TraceSz1(pktRecv, "[%X.t] Received RST while in LISTEN state.  Packet discarded.",
                         pTcpSocket);
                return;
            }

            if (isAck)
            {
                TraceSz1(tcpWarn, "[%X.t] Received ACK while in LISTEN state.  Sending RST.",
                         pTcpSocket);
                goto sendrst;
            }

            if (!ISTCPSEG(pTcpHdr, SYN))
            {
                TraceSz1(tcpWarn, "[%X.t] Received non-SYN while in LISTEN state.  Packet discarded.",
                         pTcpSocket);
                return;
            }

            // Process an incoming connection request on a listening socket
            if (!TcpAcceptConnReqPassive(pTcpSocket, pTcpHdr, pIpHdr->_ipaSrc))
            {
                TraceSz1(tcpWarn, "[%X.t] Failed to accept connection on listening socket", pTcpSocket);
                goto sendrst;
            }
            break;

        case TCPST_SYN_SENT:

            if (isAck)
            {
                ack = SEG_ACK(pTcpHdr);

                if (!IsValidACK(pTcpSocket, ack))
                {
                    TraceSz1(tcpWarn, "[%X.t] Received bad ACK seq while in SYN_SENT state.  Sending RST.",
                             pTcpSocket);
                    goto sendrst;
                }
            }

            if (ISTCPSEG(pTcpHdr, RST))
            {
                if (isAck)
                {
                    TraceSz1(tcpWarn, "[%X.t] Received RST while in SYN_SENT state.  Resetting connection.",
                             pTcpSocket);
                    TcpReset(pTcpSocket, NETERR_CONNRESET);
                }
                else
                {
                    TraceSz1(tcpWarn, "[%X.t] Ignoring RST without ACK in SYN_SENT state.",
                             pTcpSocket);
                }
                return;
            }

            if (!ISTCPSEG(pTcpHdr, SYN))
            {
                TraceSz1(tcpWarn, "[%X.t] Ignoring non-SYN while in SYN_SENT state.",
                         pTcpSocket);
                return;
            }

            // Simultaneous active open
            if (!TcpAcceptConnReqActive(pTcpSocket, pTcpHdr))
            {
                TraceSz1(tcpWarn, "[%X.t] Failed to accept simultaneous connection", pTcpSocket);
                goto sendrst;
            }
            break;

        default:
        {
            TCPSEQ oldseq0 = SEG_SEQ(pTcpHdr);
            TCPSEQ oldseq1 = oldseq0 + SEG_LEN(pTcpHdr, cbData);
            TCPSEQ seq0, seq1;

            // Make sure the sequence number is correct.
            // If not and the incoming segment is not RST, we'll emit an ACK.
            if (!TcpValidateSeqs(pTcpSocket, oldseq0, oldseq1, &seq0, &seq1))
            {
                if (!ISTCPSEG(pTcpHdr, RST))
                {
                    NeedSendACKNow(pTcpSocket);
                }
                break;
            }

            // If RST is on, then we'll reset the connection:
            //  - if the socket corresponds to a pending connection
            //    request, then we'll just close it and destroy the CTcpSocket.
            if (ISTCPSEG(pTcpHdr, RST))
            {
                TcpReset(pTcpSocket, NETERR_CONNRESET);
                goto discard;
            }

            // If SYN is set, there is an error.
            // We send out a RST as well as reset the connection.
            if (ISTCPSEG(pTcpHdr, SYN))
            {
                if (oldseq0 == seq0)
                {
                    TcpReset(pTcpSocket, NETERR_CONNRESET);
                    goto sendrst;
                }

                goto discard;
            }

            if (!ISTCPSEG(pTcpHdr, ACK))
            {
                goto discard;
            }

            if (pTcpSocket->GetState() == TCPST_SYN_RECEIVED)
            {
                ack = SEG_ACK(pTcpHdr);

                if (!IsValidACK(pTcpSocket, ack))
                {
                    // The acknowledgement number is bad, emit an RST
                    goto sendrst;
                }

                // NOTE: The ACK for our SYN will be processed
                // inside the TcpProcessDataAck call below.
                TcpConnectionEstablished(pTcpSocket, pTcpHdr);
            }

            // Process the data and acknowledgement information
            // and continue to process the FIN flag if necessary
            pTcpSocket = TcpRecvData(pTcpSocket, pTcpHdr, pbData, cbData);

            if (pTcpSocket && ISTCPSEG(pTcpHdr, FIN))
            {
                TcpProcessFIN(pTcpSocket, pTcpHdr, seq1-1);
            }
        }
        break;
    }

rcvdone:

    if (pTcpSocket && pTcpSocket->delayedAcks > 0)
    {
        // If we've delayed more than two maximum packets worth of data,
        // of if the receive window just closed, send an ACK now.

        if (    pTcpSocket->delayedAcks >= (pTcpSocket->rcv_mss << 1)
            ||  pTcpSocket->rcv_wnd == 0)
        {
            TcpEmitACK(pTcpSocket);
        }
        else
        {
            // If we aren't forced to send an ACK now, just queue up the timer and
            // wait for the very next tick.  This will come back anywhere from zero to
            // 200ms from now, depending on how far into a "tick" we happen to be.

            TimerSet(pTcpSocket->GetTimer(), TimerTick());
        }
    }
    return;

sendrst:

    // If the received segment is a RST, do nothing
    if ((pTcpHdr->_bFlags & TCP_RST) == 0) {
        TCPSEQ seq;
        BYTE flags;

        if (ISTCPSEG(pTcpHdr, ACK)) {
            ack = 0;
            seq = SEG_ACK(pTcpHdr);
            flags = 0;
        } else {
            ack = SEG_SEQ(pTcpHdr) + SEG_LEN(pTcpHdr, cbData);
            seq = 0;
            flags  = TCP_ACK;
        }

        TcpEmitRST(pTcpSocket, pIpHdr->_ipaSrc, pTcpHdr->_ipportSrc, pTcpHdr->_ipportDst,
                   seq, ack, flags);
        return;
    }

discard:
    return;
}

#ifdef XNET_FEATURE_TRACE

VOID CXnSock::TcpSetState(CTcpSocket* pTcpSocket, BYTE state, const CHAR* caller)
{
    static const CHAR* stateNames[] = {
        "CLOSED",
        "LISTEN",
        "SYN_SENT",
        "SYN_RECEIVED",
        "ESTABLISHED",
        "FIN_WAIT_1",
        "FIN_WAIT_2",
        "CLOSING",
        "TIME_WAIT",
        "CLOSE_WAIT",
        "LAST_ACK"
    };

    UINT oldstate = pTcpSocket->GetState();

    pTcpSocket->SetState(state);

    TraceSz7(tcpStat, "[%X.t] %s %d - %s:%d: %s => %s",
             pTcpSocket, caller, NTOHS(pTcpSocket->_ipportSrc),
             pTcpSocket->_ipaDst.Str(), NTOHS(pTcpSocket->_ipportDst),
             stateNames[oldstate], stateNames[state]);
}

#endif

BOOL CXnSock::TcpClose(CTcpSocket* pTcpSocket, BOOL forceful)

/*++

Routine Description:

    Close a TCP connection

Arguments:

    pTcpSocket - Points to the CTcpSocket structure
    forceful - Forceful close, always succeed and no wait

Return Value:

    TRUE if the CTcpSocket structure can be deleted immediately.
    FALSE if the connection is being gracefully closed
    and the CTcpSocket structure should be kept around until
    the connection is really closed.

--*/

{
    ICHECK(SOCK, UDPC|SDPC);

    //
    // Try to gracefully close the socket if requested by the caller
    //
    if (    !forceful
        &&  pTcpSocket->GetState() >= TCPST_SYN_RECEIVED
        &&  (!pTcpSocket->GetLingerOnOff() || pTcpSocket->GetLingerTimeout() > 0))
    {
        NTSTATUS status = TcpShutdown(pTcpSocket, SOCKF_NOMORE_XMIT|SOCKF_NOMORE_RECV, FALSE);

        if (NT_SUCCESS(status))
        {
            DWORD dwLingerSecs = pTcpSocket->GetLingerOnOff() ?
                                   pTcpSocket->GetLingerTimeout() :
                                   cfgSockLingerTimeoutInSeconds;

            // TIME-WAIT and linger timers are the same
            pTcpSocket->dwTickWait = TimerSetRelative(pTcpSocket->GetTimer(),
                dwLingerSecs * TICKS_PER_SECOND);

            return(FALSE);
        }
    }

    if (pTcpSocket->HasParent())
    {
        pTcpSocket->GetParent()->DequeueChild(pTcpSocket);
    }
    else
    {
        TcpTrimBacklog(pTcpSocket, 0);
    }

    TimerSet(pTcpSocket->GetTimer(), TIMER_INFINITE);

    return(TRUE);
}

VOID CXnSock::TcpTrimBacklog(CTcpSocket * pTcpSocket, UINT cBacklogMax)
{
    while (pTcpSocket->GetBacklog() > cBacklogMax)
    {
        CTcpSocket * pTcpSocketChild = pTcpSocket->GetLastChild();
        Assert(pTcpSocketChild != NULL);

        pTcpSocket->DequeueChild(pTcpSocketChild);
        SockClose(pTcpSocketChild, TRUE);
    }
}

NTSTATUS CXnSock::TcpShutdown(CTcpSocket* pTcpSocket, DWORD dwFlags, BOOL apicall)

/*++

Routine Description:

    Gracefully shutdown a TCP connection

Arguments:

    pTcpSocket - Points to the TCP control block
    flags - Shutdown flags: PCBFLAG_SEND_SHUTDOWN and/or PCBFLAG_RECV_SHUTDOWN
    apicall - Whether this is called by shutdown API

Return Value:

    Status code

--*/

{
    NTSTATUS status = NETERR_OK;

    RaiseToDpc();

    if ((dwFlags & SOCKF_NOMORE_RECV) && !pTcpSocket->TestFlags(SOCKF_NOMORE_RECV))
    {
        pTcpSocket->SetFlags(SOCKF_NOMORE_RECV);

        if (!pTcpSocket->IsTcpRecvBufEmpty())
        {
            //
            // If the receive buffer is not empty,
            // we'll send a RST to the connection peer
            // and reset the connection.
            //
            TcpResetPeer(pTcpSocket);
            status = apicall ? NETERR_OK : NETERR_CONNRESET;
            pTcpSocket = TcpReset(pTcpSocket, NETERR_CONNRESET);
            Assert(pTcpSocket != NULL);
        }
        else if (pTcpSocket->HasRecvReq())
        {
            // Cancel any pending overlapped receive requests
            TraceSz1(tcpStat, "[%X.t] TcpShutdown: Cancelling pending recv request", pTcpSocket);
            SockReqComplete(pTcpSocket, pTcpSocket->GetRecvReq(), NETERR(WSAESHUTDOWN));
        }
    }

    if ((dwFlags & SOCKF_NOMORE_XMIT) && !pTcpSocket->TestFlags(SOCKF_NOMORE_XMIT))
    {
        if (pTcpSocket->HasSendReq())
        {
            // Cancel any pending overlapped send requests
            TraceSz1(tcpStat, "[%X.t] TcpShutdown: Cancelling pending send request", pTcpSocket);
            SockReqComplete(pTcpSocket, pTcpSocket->GetSendReq(), NETERR(WSAESHUTDOWN));
        }

        switch (pTcpSocket->GetState()) {
        case TCPST_SYN_RECEIVED:
        case TCPST_ESTABLISHED:
            status = TcpEmitFIN(pTcpSocket);
            if (NT_SUCCESS(status)) {
                TcpSetState(pTcpSocket, TCPST_FIN_WAIT_1, "Shutdown");
                pTcpSocket->SetFlags(SOCKF_NOMORE_XMIT);
            }
            break;

        case TCPST_CLOSE_WAIT:
            status = TcpEmitFIN(pTcpSocket);
            if (NT_SUCCESS(status)) {
                TcpSetState(pTcpSocket, TCPST_LAST_ACK, "Shutdown");
                pTcpSocket->SetFlags(SOCKF_NOMORE_XMIT);
            }
            break;

        default:
            Assert(pTcpSocket->GetState() < TCPST_SYN_RECEIVED);
            status = NETERR(WSAENOTCONN);
            break;
        }
    }

    pTcpSocket->ClearFlags(SOCKF_REVIVABLE);

    return(status);
}

NTSTATUS CXnSock::TcpConnect(CTcpSocket* pTcpSocket, CIpAddr dstaddr, CIpPort dstport, BOOL synAck)

/*++

Routine Description:

    Make a TCP connection to the specified foreign address

Arguments:

    pTcpSocket - Points to the TCP control block
    dstaddr, dstport - Specifies the foreign address to connect to
    synAck - Whether we're acknowledging a received SYN request

Return Value:

    Status code

--*/

{
    NTSTATUS status;

    if (    dstport == 0
        ||  dstaddr == 0
        ||  dstaddr.IsBroadcast()
        ||  dstaddr.IsMulticast()
        || (dstaddr.IsLoopback() && dstaddr != IPADDR_LOOPBACK))
    {
        return(NETERR(WSAEADDRNOTAVAIL));
    }

    if (pTcpSocket->IsListenState())
        return NETERR_PARAM;

    // Bind to a local address if necessary
    if (!pTcpSocket->TestFlags(SOCKF_BOUND))
    {
        status = SockBind(pTcpSocket, 0);
        if (!NT_SUCCESS(status))
            return status;
    }

    RaiseToDpc();

    if (pTcpSocket->TestFlags(SOCKF_REVIVABLE))
    {
        // Revive a CTcpSocket that has been reset
        pTcpSocket->Dequeue();
        pTcpSocket->TcpInit(this);
        pTcpSocket->ClearFlags(SOCKF_CONNECT_SELECTED|SOCKF_REVIVABLE|SOCKF_NOMORE_RECV|SOCKF_NOMORE_XMIT|SOCKF_EVENT_MASK);
        EvtClear(pTcpSocket->GetEvent());
        pTcpSocket->SetStatus(NETERR_OK);
        pTcpSocket->Enqueue(&_leSockets);
    }
    else
    {
        status = pTcpSocket->GetStatus();
        if (!NT_SUCCESS(status))
            return(status);
    }

    if (!pTcpSocket->IsIdleState() && !synAck)
    {
        return(NETERR(WSAEALREADY));
    }

    // If this is an active open, go to SYN-SENT state.
    // Otherwise, we should already be in SYN-RECEIVED state.
    if (!synAck)
    {
        TcpSetState(pTcpSocket, TCPST_SYN_SENT, "Connect");
    }

    // Set up MSS to make sure we don't have to
    // fragment on the first hop. We assume the first hop
    // interface won't change during the life of the connection.
    pTcpSocket->rcv_mss = TCP_MAXIMUM_MSS;
    pTcpSocket->_cbMaxRecvBuf = 
        ((pTcpSocket->_cbMaxRecvBuf + pTcpSocket->rcv_mss - 1) / pTcpSocket->rcv_mss) * pTcpSocket->rcv_mss;
    if (pTcpSocket->_cbMaxRecvBuf > (UINT)(cfgSockMaxRecvBufsizeInK * 1024))
        pTcpSocket->_cbMaxRecvBuf = (UINT)(cfgSockMaxRecvBufsizeInK * 1024);

    pTcpSocket->_ipaDst = dstaddr;
    pTcpSocket->_ipportDst = dstport;

    // Get the initial sequence number for a new TCP connection.

    LARGE_INTEGER time;
    HalQueryTsc(&time);
    pTcpSocket->snd_isn = (TCPSEQ)time.QuadPart;

    pTcpSocket->rcv_wnd = pTcpSocket->_cbMaxRecvBuf;
    Assert(pTcpSocket->IsTcpRecvBufEmpty());

    // send out a SYN or SYN/ACK segment
    return(TcpEmitSYN(pTcpSocket, synAck));
}

NTSTATUS CXnSock::TcpListen(CTcpSocket* pTcpSocket, INT cBacklog)

/*++

Routine Description:

    Switch a TCP socket into listening state

Arguments:

    pTcpSocket - Points to the TCP control block
    backlog - Maximum number of pending connections

Return Value:

    Status code

--*/

{
    if (!pTcpSocket->IsIdleState())
    {
        return(NETERR(WSAEISCONN));
    }
    
    RaiseToDpc();

    NTSTATUS status = pTcpSocket->GetStatus();
    if (!NT_SUCCESS(status))
        return(status);

    TcpSetState(pTcpSocket, TCPST_LISTEN, "Listen");

    if (cBacklog < 1)
        cBacklog = 1;
    else if (cBacklog > cfgSockMaxListenBacklog)
        cBacklog = cfgSockMaxListenBacklog;

    pTcpSocket->SetBacklogMax(cBacklog);

    TcpTrimBacklog(pTcpSocket, cBacklog);

    return(NETERR_OK);
}

// ---------------------------------------------------------------------------------------
// TcpRead
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::TcpRead(CTcpSocket* pTcpSocket, CRecvReq* pRecvReq)

/*++

Routine Description:

    Handle a user request to receive data from a TCP socket

Arguments:

    pTcpSocket - Points to the TCP control block
    pRecvReq - Points to the receive request information

Return Value:

    Status code

--*/

{
    NTSTATUS status;
    UINT oldrcvwnd;

    RaiseToDpc();

    // Only segments from the connection peer are accepted
    pRecvReq->SetFromAddrPort(pTcpSocket->_ipaDst, pTcpSocket->_ipportDst);
    SecRegSetOwned(pTcpSocket->_ipaDst);
    *pRecvReq->bytesRecv = 0;

    if (!pTcpSocket->IsTcpRecvBufEmpty()) {

        // If the receive buffer is not empty, return as much data
        // as possible from the receive buffer.

        (*pRecvReq->bytesRecv) += TcpCopyRecvData(pTcpSocket, pRecvReq);
        status = NETERR_OK;

        // If the receive window was closed and there is
        // now enough free spce in the receive buffer,
        // then we'll send out a gratuitous ACK here.

        oldrcvwnd = pTcpSocket->rcv_wnd;
        TcpSlideRecvWindow(pTcpSocket, 0);
        if (oldrcvwnd < pTcpSocket->rcv_swsthresh &&
            pTcpSocket->rcv_wnd >= pTcpSocket->rcv_swsthresh) {
            TcpEmitACK(pTcpSocket);
        }
    } else if (pTcpSocket->IsFinReceived()) {
        // The connection has been gracefully closed
        status = NETERR_OK;
    } else {
        status = pTcpSocket->GetStatus();
        if (NT_SUCCESS(status)) {
            status = RecvReqEnqueue(pTcpSocket, pRecvReq);
        }
    }

    return(status);
}

//
// Copy data from the CTcpSocket receive buffer to the user's receive buffer
//
UINT CXnSock::TcpCopyRecvData(CTcpSocket* pTcpSocket, CRecvReq* pRecvReq)
{
    CTcpRecvBuf* recvbuf;
    UINT copycnt, total = 0;
    BYTE tcpflags = 0;

    do {
        recvbuf = (CTcpRecvBuf *) pTcpSocket->GetRecvBufFirst();
        Assert(SEQ_LE(recvbuf->seqnext, pTcpSocket->rcv_nxt));

        copycnt = min(recvbuf->GetCbBuf(), pRecvReq->buflen);
        memcpy(pRecvReq->buf, (BYTE*) recvbuf + recvbuf->dataoffset, copycnt);
        total += copycnt;
        pTcpSocket->SetCbRecvBuf(pTcpSocket->GetCbRecvBuf() - copycnt);
        pRecvReq->buf += copycnt;
        pRecvReq->buflen -= copycnt;

        tcpflags |= recvbuf->tcpflags;
        if (copycnt == recvbuf->GetCbBuf())
        {
            pTcpSocket->DequeueRecvBuf(recvbuf);
            PoolFree(recvbuf);
        }
        else
        {
            recvbuf->dataoffset = (WORD) (recvbuf->dataoffset + copycnt);
            recvbuf->DecCbBuf(copycnt);
        }
    } while (pRecvReq->buflen && !pTcpSocket->IsTcpRecvBufEmpty());

    if (tcpflags & (TCP_PSH|TCP_URG))
        pRecvReq->buflen = 0;

    return total;
}

// ---------------------------------------------------------------------------------------
// TcpSend
// ---------------------------------------------------------------------------------------

NTSTATUS CXnSock::TcpSend(CTcpSocket* pTcpSocket, CSendReq * pSendReq, UINT uiFlags)

/*++

Routine Description:

    Handle a user request to send data from a TCP socket

Arguments:

    pTcpSocket - Points to the TCP control block
    pSendReq - Points to the send request information

Return Value:

    Status code

Note:

    This function always return immediately. For blocking operation,
    we assume the caller has taken care of any necessary wait.

--*/

{
    NTSTATUS status = NETERR_OK;
    CPacket* pkt = NULL;
    WSABUF* bufs = pSendReq->bufs;
    UINT bytesToSend = pSendReq->sendtotal;
    UINT mss = pTcpSocket->snd_mss;
    UINT n, datalen;
    BYTE* data;

    // Make sure we don't overflow the send buffer too much.
    // In the following case:
    //  old pTcpSendBuf size + the datagram size > max pTcpSendBuf size
    // we'll temporarily exceed the send buffer size limit a little bit.
    Assert(!pTcpSocket->IsSendBufFull());
    Assert(pTcpSocket->_cbMaxSendBuf >= pTcpSocket->GetCbSendBuf());
    n = pTcpSocket->_cbMaxSendBuf - pTcpSocket->GetCbSendBuf();
    if (bytesToSend > max(n, mss))
        pSendReq->sendtotal = bytesToSend = mss;

    data = (BYTE *)bufs->buf;
    datalen = bufs->len;

    while (bytesToSend > 0)
    {
        UINT segsize = min(mss, bytesToSend);
        BYTE* p;

        pkt = TcpPacketAlloc(pTcpSocket, pTcpSocket->_ipaDst, uiFlags, segsize, sizeof(CTcpSendBuf), (PFNPKTFREE)TcpPacketFree);

        if (!pkt)
        {
            if ((pSendReq->sendtotal -= bytesToSend) == 0)
            {
                // If we've already send out some data,
                // then return success with partial byte count.
                // Otherwise, return error code.
                status = NETERR_MEMORY;
            }
            break;
        }

        bytesToSend -= segsize;
        p = (BYTE *)pkt->GetTcpHdr() + sizeof(CTcpHdr);
        if (segsize <= datalen)
        {
            // Fast case: all the data for this segment
            // comes from the same user buffer.
            memcpy(p, data, segsize);
            data += segsize;
            datalen -= segsize;
        }
        else
        {
            // Slow case: need to gather data for this segment
            // from multiple user buffers.
            
            UINT segremain = segsize;

            while (segremain)
            {
                while (datalen == 0)
                {
                    bufs++;
                    data = (BYTE *)bufs->buf;
                    datalen = bufs->len;
                }
                n = min(segremain, datalen);
                memcpy(p, data, n);
                p += n;
                data += n;
                datalen -= n;
                segremain -= n;
            }
        }

        {
            RaiseToDpc();

            status = pTcpSocket->GetStatus();

            if (NT_SUCCESS(status))
            {
                TcpQueueSegment(pTcpSocket, pkt, (BYTE)(bytesToSend ? TCP_ACK : (TCP_ACK|TCP_PSH)),
                                segsize);
            }
            else
            {
                PacketFree(pkt);
                break;
            }
        }
    }

    // If the app calls connect() on a non-blocking socket, and then calls send()
    // without calling select(), then we need to reset the connectSelected flag
    // so future select() calls will ignore SOCKF_EVENT_CONNECT.

    pTcpSocket->SetFlags(SOCKF_CONNECT_SELECTED);

    return(status);
}

CPacket * CXnSock::TcpPacketAlloc(CTcpSocket * pTcpSocket, CIpAddr ipaDst, UINT uiFlags, UINT cbDat, UINT cbPkt, PFNPKTFREE pfn)
{
    Assert((uiFlags & ~PKTF_POOLALLOC) == 0);

    uiFlags |= PKTF_TYPE_TCP;

    if (ipaDst.IsSecure())
    {
        uiFlags |= PKTF_TYPE_ESP|PKTF_CRYPT;
    }
    else
    {
    #ifdef XNET_FEATURE_ONLINE
        if (pTcpSocket && pTcpSocket->TestFlags(SOCKF_INSECURE))
        {
            uiFlags |= PKTF_XMIT_INSECURE;
        }
    #endif
    }

    return(PacketAlloc(PTAG_CTcpPacket, uiFlags, cbDat, cbPkt, pfn));
}

void CXnSock::TcpPacketFree(CPacket * ppkt)
{
    ICHECK(SOCK, UDPC|SDPC);

    if (((CTcpSendBuf *)ppkt)->Release() == 0)
    {
        PacketFree(ppkt);
    }
}

void CXnSock::TcpQueueSegment(CTcpSocket* pTcpSocket, CPacket* pkt, BYTE tcpflags, UINT datalen)

/*++

Routine Description:

    Initialize the header information for an outgoing TCP packet

Arguments:

    pTcpSocket - Points to the TCP control block
    pkt - Points to the outgoing TCP packet
    tcpflags - Specifies the TCP segment flags

Return Value:

    NONE

--*/

{
    TCHECK(UDPC|SDPC);

    CTcpSendBuf* pTcpSendBuf = (CTcpSendBuf *)pkt;
    pTcpSendBuf->Init(pTcpSocket, 0, 1);
    pTcpSendBuf->retries = 0;
    pTcpSendBuf->tcpflags = tcpflags;
    pTcpSendBuf->tcphdrlen = (BYTE) ((tcpflags & TCP_SYN) ?
                                    sizeof(CTcpHdr)+SYNTCPOPTLEN :
                                    sizeof(CTcpHdr));
    pTcpSendBuf->seq = pTcpSocket->snd_end;

    if (tcpflags & (TCP_SYN|TCP_FIN))
    {
        Assert(datalen == 0);
        pTcpSendBuf->seqnext = pTcpSendBuf->seq + 1;
    }
    else
    {
        pTcpSendBuf->SetCbBuf(datalen);
        pTcpSendBuf->seqnext = pTcpSendBuf->seq + datalen;
    }

    pTcpSocket->snd_end = pTcpSendBuf->seqnext;

    pTcpSocket->IncCbSendBuf(pTcpSendBuf->GetCbBuf());
    pTcpSocket->EnqueueSendBuf(pTcpSendBuf);

    if (pTcpSocket->GetSendBufPtr() == NULL)
    {
        pTcpSocket->SetSendBufPtr(pTcpSendBuf);
        TcpStartOutput(pTcpSocket);
    }
}

BOOL CXnSock::TcpStartOutput(CTcpSocket* pTcpSocket)

/*++

Routine Description:

    Called when we have buffered data to send on a TCP socket. 

Arguments:

    pTcpSocket - Points to the TCP control block
    pTcpSendBuf - Specifies the segment to be sent

Return Value:

    TRUE if a segment was sent; FALSE otherwise.

--*/

{
    TCHECK(UDPC|SDPC);

    INT sndwndAvail;
    CTcpSendBuf* pTcpSendBuf;
    TCPSEQ cwndmax, swndmax;

    pTcpSendBuf = pTcpSocket->GetSendBufPtr();
    Assert(pTcpSocket->snd_nxt == pTcpSendBuf->seq);
    Assert(pTcpSendBuf->retries == 0);

    // We always send SYN or FIN segments without delay
    if (pTcpSendBuf->GetCbBuf() == 0)
        goto sendnow;

    // NOTE: We're using signed integer here in case
    // the send window was shrunk by the receiver.
    swndmax = pTcpSocket->snd_wl2 + pTcpSocket->snd_wnd;
    cwndmax = pTcpSocket->snd_una + pTcpSocket->snd_cwnd;
    sndwndAvail = (SEQ_LE(swndmax, cwndmax) ? swndmax : cwndmax) - pTcpSocket->snd_nxt;

    if ((INT) pTcpSendBuf->GetCbBuf() <= sndwndAvail) {
        // Send window is large enough. Perform send-side
        // SWS avoidance. Note that if the PSH flag is not set,
        // then we must be sending a full-sized data segment.
        // Check the logic in TcpSend().

        // BUGBUG: Since we don't yet combine data from
        // multiple send calls into a single segment, it's
        // meaningless to delay the send.
        goto sendnow;
    }

    // Cannot send due to window constraints
    //  set up persist timers
    if (pTcpSocket->snd_nxt == pTcpSocket->snd_una)
    {
        TraceSz1(tcpStat, "[%X.t] Setting persist timer...", pTcpSocket);
        pTcpSocket->SetFlags(SOCKF_PERSIST);
        pTcpSocket->dwTickXmit = TimerSetRelative(pTcpSocket->GetTimer(), max(pTcpSocket->RTO, (UINT)(cfgSockPersistTimeoutInSeconds * TICKS_PER_SECOND)));
    }
    return FALSE;

sendnow:

    // Use this segment to measure round-trip time if possible
    pTcpSocket->ClearFlags(SOCKF_PERSIST);
    if (pTcpSocket->rtt_tick == 0) {
        pTcpSocket->rtt_tick = TimerTick();
        pTcpSocket->rtt_seq = pTcpSendBuf->seq;
    }
    
    pTcpSendBuf->firstSendTime = TimerTick();
    TcpSendSegment(pTcpSocket, pTcpSendBuf, pTcpSendBuf->retries != 0);
    pTcpSocket->snd_nxt = pTcpSendBuf->seqnext;
    pTcpSocket->SetSendBufPtr((CTcpSendBuf *)pTcpSocket->GetSendBufNext(pTcpSendBuf));
    return(TRUE);
}

void CXnSock::TcpSendSegment(CTcpSocket* pTcpSocket, CTcpSendBuf* pTcpSendBuf, BOOL fRetransmit)
{
    if (!pTcpSendBuf->IsActive())
    {
        CPacket * ppkt = pTcpSendBuf;

        pTcpSocket->delayedAcks = 0;

        Assert(     (pTcpSendBuf->tcpflags & TCP_FIN)
               ||   pTcpSocket->TestFlags(SOCKF_PERSIST)
               ||   SEQ_LE(pTcpSendBuf->seq, TcpSndNxt(pTcpSocket)));

        // If this packet is encrypted, we need to make sure it decrypts properly before
        // attempting to retransmit.  If it fails for any reason, just continue without
        // retransmitting and allow the timeouts to reset the socket.

        if (    !fRetransmit
            ||  !ppkt->IsEsp()
            ||  !ppkt->IsCrypt()
            ||  IpDecrypt(ppkt, pTcpSocket->_ipaDst))
        {
            CTcpHdr * pTcphdr   = ppkt->GetTcpHdr();
            pTcphdr->SetHdrLen(pTcpSendBuf->tcphdrlen);
            pTcphdr->_ipportSrc = pTcpSocket->_ipportSrc;
            pTcphdr->_ipportDst = pTcpSocket->_ipportDst;
            pTcphdr->_dwSeqNum  = HTONL(pTcpSendBuf->seq),
            pTcphdr->_dwAckNum  = HTONL(pTcpSocket->rcv_nxt);
            pTcphdr->_bFlags    = (BYTE)pTcpSendBuf->tcpflags;
            pTcphdr->_wWindow   = HTONS((WORD)pTcpSocket->rcv_wnd);
            pTcphdr->_wUrgent   = 0;
            pTcphdr->_wChecksum = 0;

            pTcpSendBuf->AddRef();

            TraceTcpHdr(pktXmit, pTcpSocket, pTcphdr, pTcpSendBuf->tcphdrlen - sizeof(CTcpHdr), pTcpSendBuf->GetCbBuf());
            IpFillAndXmit(ppkt, pTcpSocket->_ipaDst, IPPROTOCOL_TCP, &pTcpSocket->_prte);
        }
    }

    if (pTcpSendBuf == pTcpSocket->GetSendBufFirst())
    {
        // Set up the retransmisssion or persist timer

        UINT minTimeout = pTcpSocket->TestFlags(SOCKF_PERSIST) ?
                            cfgSockPersistTimeoutInSeconds :
                            cfgSockRexmitMinTimeoutInSeconds;

        minTimeout *= TICKS_PER_SECOND;

        pTcpSocket->dwTickXmit = (pTcpSocket->RTO << pTcpSendBuf->retries);
        if (pTcpSocket->dwTickXmit < minTimeout)
            pTcpSocket->dwTickXmit = minTimeout;
        if (pTcpSocket->dwTickXmit > (UINT)cfgSockRexmitMaxTimeoutInSeconds * TICKS_PER_SECOND)
            pTcpSocket->dwTickXmit = (UINT)cfgSockRexmitMaxTimeoutInSeconds * TICKS_PER_SECOND;

        pTcpSocket->dwTickXmit = TimerSetRelative(pTcpSocket->GetTimer(), pTcpSocket->dwTickXmit);
    }

    pTcpSendBuf->retries++;
}

// ---------------------------------------------------------------------------------------
// CTcpSocket
// ---------------------------------------------------------------------------------------

void CTcpSocket::EnqueueChild(CTcpSocket * pTcpSocketChild)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(_pTcpSocketParent == NULL);
    Assert(pTcpSocketChild->_pTcpSocketParent == NULL);

    _bBacklog += 1;
    pTcpSocketChild->_pTcpSocketParent = this;

    AssertList(&_le);
    InsertTailList(&_le, &pTcpSocketChild->_le);

    // Copy the local address bindings
    pTcpSocketChild->SetFlags(GetFlags() | SOCKF_BOUND, SOCKF_OPT_MASK | SOCKF_BOUND);
    pTcpSocketChild->_ipportSrc      = _ipportSrc;
    pTcpSocketChild->_uiSendTimeout  = _uiSendTimeout;
    pTcpSocketChild->_uiRecvTimeout  = _uiRecvTimeout;
    pTcpSocketChild->_cbMaxSendBuf   = _cbMaxSendBuf;
    pTcpSocketChild->_cbMaxRecvBuf   = _cbMaxRecvBuf;
    pTcpSocketChild->_Linger         = _Linger;
}

void CTcpSocket::DequeueChild(CTcpSocket * pTcpSocketChild)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);

    Assert(_pTcpSocketParent == NULL);
    Assert(pTcpSocketChild->_pTcpSocketParent == this);

    AssertListEntry(&_le, &pTcpSocketChild->_le);
    RemoveEntryList(&pTcpSocketChild->_le);
    InitializeListHead(&pTcpSocketChild->_le);
    pTcpSocketChild->_pTcpSocketParent = NULL;

    Assert(_bBacklog > 0);
    _bBacklog -= 1;
}

CTcpSocket * CTcpSocket::GetConnectedChild()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    
    Assert(_pTcpSocketParent == NULL);

    CTcpSocket * pTcpSocketChild = GetFirstChild();
    while (pTcpSocketChild && !pTcpSocketChild->TestFlags(SOCKF_CONNECTED))
        pTcpSocketChild = GetNextChild(pTcpSocketChild);

    return(pTcpSocketChild);
}

CTcpSocket * CTcpSocket::DequeueConnectedChild()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);

    CTcpSocket * pTcpSocketChild = GetConnectedChild();

    if (pTcpSocketChild)
    {
        DequeueChild(pTcpSocketChild);
    }

    return(pTcpSocketChild);
}

void CSocket::InsertRecvBuf(CRecvBuf * pRecvBuf, CRecvBuf * pRecvBufPrev)
{
    ICHECK_(GetXnBase(), SOCK, SDPC);
    Assert(offsetof(CRecvBuf, _le) == 0);
    Assert(pRecvBuf != NULL);

    AssertList(&_leRecvBufs);

    if (pRecvBufPrev == NULL)
    {
        InsertHeadList(&_leRecvBufs, &pRecvBuf->_le);
    }
    else
    {
        pRecvBuf->_le.Flink = pRecvBufPrev->_le.Flink;
        pRecvBuf->_le.Blink = &pRecvBufPrev->_le;
        pRecvBufPrev->_le.Flink->Blink = &pRecvBuf->_le;
        pRecvBufPrev->_le.Flink = &pRecvBuf->_le;
        AssertList(&_leRecvBufs);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\libxs\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\xnetp.cpp ===
// ---------------------------------------------------------------------------------------
// xnetp.cpp
//
// Implementation of private XNet API's
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"
#include "xnver.h"

// ---------------------------------------------------------------------------------------
// Trace Tags
// ---------------------------------------------------------------------------------------

DefineTag(NatPort, 0);
DefineTag(NatFlow, 0);

// ---------------------------------------------------------------------------------------
// Reading and Writing Configuration Sectors
// ---------------------------------------------------------------------------------------

HANDLE _WSAAPI_ XNetOpenConfigVolume()
{
    HANDLE              hVolume;
    OBJECT_ATTRIBUTES   oa;
    OBJECT_STRING       os;
    IO_STATUS_BLOCK     statusBlock;
    NTSTATUS            status;

    RtlInitObjectString(&os, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &os, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&hVolume, SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE, &oa, &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_ALERT);

    if (!NT_SUCCESS(status))
    {
        TraceSz1(Warning, "XNetOpenConfigVolume: NtOpenFile returned %08lX", status);
        hVolume = INVALID_HANDLE_VALUE;
    }

    return(hVolume);
}

BOOL _WSAAPI_ XNetLoadConfigSector(HANDLE hVolume, UINT iSector, BYTE * pbData, UINT cbData)
{
    BYTE                abSector[XBOX_HD_SECTOR_SIZE];
    PXBOX_CONFIG_SECTOR pxbcs = (PXBOX_CONFIG_SECTOR)abSector;
    LARGE_INTEGER       liOffset;
    IO_STATUS_BLOCK     statusBlock;
    NTSTATUS            status;

    Assert(hVolume != INVALID_HANDLE_VALUE);
    Assert(cbData == sizeof(pxbcs->Data));

    if (iSector >= XBOX_NUM_CONFIG_SECTORS)
    {
        TraceSz2(Warning, "XNetSaveConfigSector (%d): iSector must be between 0 and %d",
                 iSector, XBOX_NUM_CONFIG_SECTORS);
        return(FALSE);
    }

    liOffset.QuadPart = (XBOX_CONFIG_SECTOR_INDEX + iSector) * XBOX_HD_SECTOR_SIZE;

    status = NtReadFile(hVolume, 0, NULL, NULL, &statusBlock, abSector, sizeof(abSector), &liOffset);

    if (!NT_SUCCESS(status))
    {
        TraceSz2(Warning, "XNetLoadConfigSector (%d): NtReadFile returned %08lX", iSector, status);
        return(FALSE);
    }

    if (    pxbcs->SectorBeginSignature != XBOX_CONFIG_SECTOR_BEGIN_SIGNATURE
        ||  pxbcs->SectorEndSignature != XBOX_CONFIG_SECTOR_END_SIGNATURE
        ||  pxbcs->Version < XBOX_CONFIG_VERSION
        ||  pxbcs->SectorCount < XBOX_CONFIG_SECTOR_COUNT)
    {
        return(FALSE);
    }

    memcpy(pbData, pxbcs->Data, sizeof(pxbcs->Data));
    return(TRUE);
}

BOOL _WSAAPI_ XNetSaveConfigSector(HANDLE hVolume, UINT iSector, const BYTE * pbData, UINT cbData)
{
    BYTE                abSector[XBOX_HD_SECTOR_SIZE];
    PXBOX_CONFIG_SECTOR pxbcs = (PXBOX_CONFIG_SECTOR)abSector;
    LARGE_INTEGER       liOffset;
    IO_STATUS_BLOCK     statusBlock;
    NTSTATUS            status;

    Assert(hVolume != INVALID_HANDLE_VALUE);
    Assert(cbData == sizeof(pxbcs->Data));

    if (iSector >= XBOX_NUM_CONFIG_SECTORS)
    {
        TraceSz2(Warning, "XNetSaveConfigSector (%d): iSector must be between 0 and %d",
                 iSector, XBOX_NUM_CONFIG_SECTORS);
        return(FALSE);
    }

    liOffset.QuadPart = (XBOX_CONFIG_SECTOR_INDEX + iSector) * XBOX_HD_SECTOR_SIZE;

    pxbcs->SectorBeginSignature = XBOX_CONFIG_SECTOR_BEGIN_SIGNATURE;
    pxbcs->SectorEndSignature = XBOX_CONFIG_SECTOR_END_SIGNATURE;
    pxbcs->Version = XBOX_CONFIG_VERSION;
    pxbcs->SectorCount = XBOX_CONFIG_SECTOR_COUNT;

    memcpy(pxbcs->Data, pbData, sizeof(pxbcs->Data));
    
    // Recompute the checksum of the configuration sector

    pxbcs->Checksum = 0;
    pxbcs->Checksum = ~XConfigChecksum(pxbcs, sizeof(*pxbcs));

    // Write the config sector back to the disk

    status = NtWriteFile(hVolume, 0, NULL, NULL, &statusBlock, abSector, sizeof(abSector), &liOffset);

    if (!NT_SUCCESS(status))
    {
        TraceSz2(Warning, "XNetSaveConfigSector (%d): NtWriteFile returned %08lX", iSector, status);
        return(FALSE);
    }

    return(TRUE);
}

BOOL _WSAAPI_ XNetCloseConfigVolume(HANDLE hVolume)
{
    if (hVolume != INVALID_HANDLE_VALUE)
    {
        NtClose(hVolume);
    }

    return(TRUE);
}

BOOL _WSAAPI_ XNetLoadConfigParams(XNetConfigParams * pxncp)
{
    HANDLE hVolume = XNetOpenConfigVolume();

    if (hVolume != INVALID_HANDLE_VALUE)
    {
        pxncp->dwSigEnd = 0;

        XNetLoadConfigSector(hVolume, 0, (BYTE *)pxncp, sizeof(XNetConfigParams));

        if (pxncp->dwSigEnd != XNET_CONFIG_PARAMS_SIGEND)
        {
            memset(pxncp, 0, sizeof(pxncp));
            pxncp->dwSigEnd = XNET_CONFIG_PARAMS_SIGEND;
        }

        XNetCloseConfigVolume(hVolume);
    }

    return(TRUE);
}

BOOL _WSAAPI_ XNetSaveConfigParams(const XNetConfigParams * pxncp)
{
    BOOL   fResult = FALSE;
    HANDLE hVolume = XNetOpenConfigVolume();

    if (hVolume != INVALID_HANDLE_VALUE)
    {
        Assert(pxncp->dwSigEnd == XNET_CONFIG_PARAMS_SIGEND);

        fResult = XNetSaveConfigSector(hVolume, 0, (BYTE *)pxncp, sizeof(XNetConfigParams));

        XNetCloseConfigVolume(hVolume);
    }

    return(fResult);
}

// ---------------------------------------------------------------------------------------
// XoBase Support
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_ONLINE

void CXoBase::XnSetXoBase(CXoBase * pXoBase)
{
    GetXn()->IpSetXoBase(pXoBase);
}

void CXoBase::XnLogon(IN_ADDR inaLogon, ULONGLONG * pqwUserId, WSAEVENT hEventLogon)
{
    GetXn()->IpLogon(CIpAddr(inaLogon.s_addr), pqwUserId, hEventLogon);
}

DWORD CXoBase::XnLogonGetStatus(SGADDR * psgaddr)
{
    return(GetXn()->IpLogonGetStatus(psgaddr));
}

BOOL CXoBase::XnLogonGetQFlags(UINT iUserId, ULONGLONG * pqwUserId, DWORD * pdwQFlags, DWORD * pdwSeqQFlags)
{
    return(GetXn()->IpLogonGetQFlags(iUserId, pqwUserId, pdwQFlags, pdwSeqQFlags));
}

BOOL CXoBase::XnLogonSetQFlags(UINT iUserId, DWORD dwQFlagsSet, DWORD dwQFlagsClr)
{
    return(GetXn()->IpLogonSetQFlags(iUserId, dwQFlagsSet, dwQFlagsClr));
}

BOOL CXoBase::XnLogonSetPState(UINT iUserId, DWORD dwPState, const XNKID * pxnkid, UINT cbData, BYTE * pbData)
{
    return(GetXn()->IpLogonSetPState(iUserId, dwPState, pxnkid, cbData, pbData));
}

void CXoBase::XnLogoff()
{
    GetXn()->IpLogoff();
}

void CXoBase::XnSetEventTimer(BYTE * pbEventTimer, WSAEVENT hEvent, DWORD dwTimeout)
{
    GetXn()->IpSetEventTimer((CEventTimer *)pbEventTimer, hEvent, dwTimeout);
}

void CXoBase::XnRaiseToDpc(BOOL fRaise)
{
    GetXn()->IpRaiseToDpc(fRaise);
}

#ifdef XNET_FEATURE_ASSERT

void * CXoBase::XnLeakAdd(CLeakInfo * pli, void * pv, UINT cb, ULONG tag)
{
    return(GetXn()->LeakAdd(pli, pv, cb, tag));
}

void * CXoBase::XnLeakDel(CLeakInfo * pli, void * pv)
{
    return(GetXn()->LeakDel(pli, pv));
}

void CXoBase::XnLeakTerm(CLeakInfo * pli)
{
    GetXn()->LeakTerm(pli);
}

#endif

#endif

// ---------------------------------------------------------------------------------------
// Simulated Network Address Translator
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_WINDOWS

#include <pshpack1.h>

struct CDhcpHdr
{
    // Definitions -----------------------------------------------------------------------

    #define DHCP_OP_BOOTREQUEST         1
    #define DHCP_OP_BOOTREPLY           2

    #define DHCP_HWTYPE_ETHERNET        1
    #define DHCP_FLAGS_BROADCAST        0x0008
    #define DHCP_MAGIC_COOKIE           0x63538263

    #define DHCP_TYPE_DISCOVER          1
    #define DHCP_TYPE_OFFER             2
    #define DHCP_TYPE_REQUEST           3
    #define DHCP_TYPE_DECLINE           4
    #define DHCP_TYPE_ACK               5
    #define DHCP_TYPE_NAK               6
    #define DHCP_TYPE_RELEASE           7
    #define DHCP_TYPE_INFORM            8

    #define DHCP_OPT_PAD                0
    #define DHCP_OPT_SUBNET_MASK        1
    #define DHCP_OPT_ROUTERS            3
    #define DHCP_OPT_DNS_SERVERS        6
    #define DHCP_OPT_DOMAIN_NAME        15
    #define DHCP_OPT_REQUESTED_IPADDR   50
    #define DHCP_OPT_IPADDR_LEASE_TIME  51
    #define DHCP_OPT_FIELD_OVERLOAD     52
    #define DHCP_OPT_MESSAGE_TYPE       53
    #define DHCP_OPT_SERVERID           54
    #define DHCP_OPT_PARAM_REQUEST_LIST 55
    #define DHCP_OPT_T1_INTERVAL        58
    #define DHCP_OPT_T2_INTERVAL        59
    #define DHCP_OPT_CLIENTID           61
    #define DHCP_OPT_END                255

    #define DHCP_OVERLOAD_FILE          1
    #define DHCP_OVERLOAD_SERVER        2

    // Functions -------------------------------------------------------------------------

    BOOL        GetOpt(UINT cbLen, BYTE bOpt, UINT cbOpt, BOOL fVariable, BYTE ** ppbOpt, UINT * pcbOpt);
    static BOOL GetOpt(BYTE * pb, UINT cb, BYTE bOpt, UINT cbOpt, BOOL fVar, BYTE ** ppbOpt, UINT * pcbOpt, BYTE * pbOver);

    // Data ------------------------------------------------------------------------------

    BYTE        _bOp;               // DHCP_OP_*
    BYTE        _bHwType;           // DHCP_HWTYPE_*
    BYTE        _bHwLen;            // hardware address length
    BYTE        _bHops;             // relay hops
    DWORD       _dwXid;             // random transaction identifier
    WORD        _wSecs;             // seconds since address acquisition process began
    WORD        _wFlags;            // DHCP_FLAGS_*
    CIpAddr     _ipaC;              // IP address requested by client
    CIpAddr     _ipaY;              // IP address assigned to client
    CIpAddr     _ipaS;              // IP address of DHCP server
    CIpAddr     _ipaG;              // IP address of gateway in trans-router booting
    CEnetAddr   _ea;                // Ethernet Address of client
    BYTE        _abHwPad[10];       // Pad hardware address to full 16 bytes
    char        _achServer[64];     // Null-terminated server hostname
    char        _achFile[128];      // Null-terminated name of bootfile
    DWORD       _dwMagicCookie;     // DHCP_MAGIC_COOKIE

};

#include <poppack.h>

BOOL CDhcpHdr::GetOpt(UINT cbLen, BYTE bOpt, UINT cbOpt, BOOL fVar, BYTE ** ppbOpt, UINT * pcbOpt)
{
    BYTE bOver = 0;

    if (GetOpt((BYTE *)(this + 1), cbLen - sizeof(CDhcpHdr), bOpt, cbOpt, fVar, ppbOpt, pcbOpt, &bOver))
    {
        return(TRUE);
    }

    if (bOver & DHCP_OVERLOAD_FILE)
    {
        if (GetOpt((BYTE *)_achFile, sizeof(_achFile), bOpt, cbOpt, fVar, ppbOpt, pcbOpt, NULL))
        {
            return(TRUE);
        }
    }

    if (bOver & DHCP_OVERLOAD_SERVER)
    {
        if (GetOpt((BYTE *)_achServer, sizeof(_achServer), bOpt, cbOpt, fVar, ppbOpt, pcbOpt, NULL))
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

BOOL CDhcpHdr::GetOpt(BYTE * pb, UINT cb, BYTE bOpt, UINT cbOpt, BOOL fVar, BYTE ** ppbOpt, UINT * pcbOpt, BYTE * pbOver)
{
    BYTE b1, b2;

    while (cb > 0)
    {
        b1  = *pb++;
        cb -= 1;

        if (b1 == DHCP_OPT_END)
            break;

        if (b1 == DHCP_OPT_PAD)
            continue;

        if (cb == 0)
        {
            TraceSz1(Warning, "CDhcpHdr::GetOpt(%d) - Premature end of option list", bOpt);
            break;
        }

        b2  = *pb++;
        cb -= 1;

        if (b2 == 0 || b2 > cb)
        {
            TraceSz3(Warning, "CDhcpHdr::GetOpt(%d) - Option length (%d) is invalid (cb %d)", bOpt, b2, cb);
            break;
        }

        if (b1 == DHCP_OPT_FIELD_OVERLOAD && pbOver && *pbOver == 0 && b2 == 1)
        {
            *pbOver = *pb;
        }

        if (b1 == bOpt)
        {
            if (    (!fVar && b2 != cbOpt)
                ||  ( fVar && (b2 < cbOpt || (b2 % cbOpt) != 0)))
            {
                TraceSz4(Warning, "CDhcpHdr::GetOpt(%d) - Option length (%d) is invalid (%d%s)",
                         bOpt, b2, cbOpt, fVar ? " variable" : "");
                break;
            }

            *ppbOpt = pb;

            if (pcbOpt)
            {
                *pcbOpt = b2;
            }

            return(TRUE);
        }

        pb += b2;
        cb -= b2;
    }

    return(FALSE);
}

class CXnNat
{
    // Definitions -----------------------------------------------------------------------

    struct CDhcpLease
    {
        CEnetAddr       _ea;                // Ethernet address of client
        CIpAddr         _ipa;               // IP address assigned to client
        FILETIME        _ftExpire;          // Expiration time of the lease
    };

    struct CNatFilt
    {
        CIpAddr         _ipaOuter;          // IP address of server on outer lan
        CIpPort         _ipportOuter;       // IP port of server on outer lan
        DWORD           _dwTick;            // Tick of last packet activity through this filter
    };

    struct CNatPort
    {
        LIST_ENTRY      _leHash;            // Link into hash table bucket
        LIST_ENTRY      _leLru;             // Link into LRU list
        CIpAddr         _ipaInner;          // IP address of client on inner lan
        CIpPort         _ipportInner;       // IP port of client on inner lan
        CIpPort         _ipportNat;         // IP port assigned by NAT
        CIpAddr         _ipaOuter;          // IP address of server on outer lan (aggressive) 
        CIpPort         _ipportOuter;       // IP port of server on outer lan (aggressive)
        CNatFilt *      _pNatFilt;          // Vector of sorted CNatFilt structures
        UINT            _cNatFilt;          // Count of CNatFilt structures in _pNatFilt in use
        UINT            _cNatFiltAlloc;     // Count of CNatFilt structures in _pNatFilt
        DWORD           _dwTick;            // Tick of last packet activity through this mapping
    };

    class CXnIpNat : public CXnIp
    {

    public:

        HAL_DECLARE_NEW_DELETE(CXnIpNat)

        BOOL    Init(CXnNat * pXnNat, XNetStartupParams * pxnsp, XNetConfigParams * pxncp, char * pszXbox);
        void    Stop();
        void    Term();
        void    UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
        void    TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen);
        void    SockReset(CIpAddr ipa) {}
        BOOL    IsGateway(CIpPort ipport);
        void    IpXmitIp(CPacket * ppkt) { CXnIp::IpXmitIp(ppkt); }

        CIpAddr GetIpa()                { return(_ipa); }
        CIpAddr GetIpaMask()            { return(_ipaMask); }
        CIpAddr GetIpaDns(UINT iDns)    { return(iDns < _options._dnsServerCount ? _options._dnsServers[iDns] : 0); }

    private:

        CXnNat *    _pXnNat;

    };

public:

    HAL_DECLARE_NEW_DELETE(CXnNat)

    BOOL        Init(NATCREATE * pNatCreate);
    void        Term();
    void        Recv(CXnIpNat * pXnIpNat, CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    void        RecvDhcp(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    void        RecvInner(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    void        RecvOuter(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    BOOL        IsGateway(CIpPort ipport, CXnIpNat * pXnIpNat);
    CNatPort *  NatPortLookup(CIpAddr ipaInner, CIpPort ipportInner, CIpAddr ipaOuter, CIpPort ipportOuter);
    CNatPort *  NatPortLookup(CIpPort ipportNat);
    BOOL        NatPortExpire(CNatPort * pNatPort);
    void        NatPortFree(CNatPort * pNatPort);
    CNatFilt *  NatFiltLookup(CNatPort * pNatPort, CIpAddr ipaOuter, CIpPort ipportOuter, BOOL fAlloc);

private:

    CXnIpNat *      _pXnIpNatInner;         // Inner network stack
    CXnIpNat *      _pXnIpNatOuter;         // Outer network stack
    DWORD           _dwIpaBase;             // Base IP address (host order) of DHCP server
    DWORD           _dwIpaLast;             // Last IP address (host order) of DHCP server
    DWORD           _dwIpaNext;             // Next IP address (host order) of DHCP server
    DWORD           _dwLeaseTime;           // Lease time in seconds for DHCP server
    CDhcpLease *    _pDhcpLease;            // Vector of CDhcpLease structures
    UINT            _cDhcpLease;            // Count of CDhcpLease structures in use
    UINT            _cDhcpLeaseAlloc;       // Count of CDhcpLease structures allocated
    UINT            _iAssign;               // See NAT_ASSIGN_*
    UINT            _iFilter;               // See NAT_FILTER_*
    UINT            _iTimeout;              // NAT timeout interval in ticks
    LIST_ENTRY *    _pleHash;               // Vector of hash buckets of CNatPort structures
    UINT            _cBucket;               // Number of buckets in the hash table
    LIST_ENTRY      _leLru;                 // CNatPort structures in LRU order
    CNatPort **     _ppNatPort;             // Mapping from ipportNat to CNatPort
    UINT            _iNatPortBase;          // Base ipportNat to assign
    UINT            _iNatPortLast;          // Last ipportNat to assign
    UINT            _iNatPortNext;          // Next ipportNat to assign
    UINT            _cNatPortFree;          // Count of free ipportNat
    BOOL            _fInitialized;          // TRUE when CXnNat::Init has completed

};

BOOL CXnNat::CXnIpNat::Init(CXnNat * pXnNat, XNetStartupParams * pxnsp, XNetConfigParams * pxncp, char * pszXbox)
{
    _pXnNat = pXnNat;

    XNetInitParams xnip;
    xnip.pxnp = (XNetParams *)pxnsp;
    xnip.pszXbox = pszXbox;
    HalQueryTsc(&xnip.liTime);

    NTSTATUS status = IpInit(&xnip);

    if (!NT_SUCCESS(status))
    {
        TraceSz1(Warning, "CXnNat::CXnIpNat::Init - IpInit failed (%08lX)", status);
        return(FALSE);
    }

    cfgFlags |= XNET_STARTUP_BYPASS_SECURITY;

    INT err = IpConfig(pxncp, XNET_CONFIG_NORMAL);

    if (err != 0)
    {
        TraceSz1(Warning, "CXnNat::CXnIpNat::Init - IpConfig failed (%08lX)", err);
        return(FALSE);
    }

    IpStart();

    return(TRUE);    
}

void CXnNat::CXnIpNat::Stop()
{
    if (TestInitFlag(INITF_HAL))
    {
        RaiseToDpc();
        IpStop();
    }
}

void CXnNat::CXnIpNat::Term()
{
    if (TestInitFlag(INITF_HAL))
    {
        RaiseToDpc();
        IpTerm();
    }

    _pXnNat = NULL;
}

void CXnNat::CXnIpNat::UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    _pXnNat->Recv(this, ppkt, pIpHdr, pUdpHdr, cbLen);
}

void CXnNat::CXnIpNat::TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen)
{
    _pXnNat->Recv(this, ppkt, pIpHdr, (CUdpHdr *)pTcpHdr, cbLen);
}

BOOL CXnNat::CXnIpNat::IsGateway(CIpPort ipport)
{
    return(_pXnNat->IsGateway(ipport, this));
}

BOOL CXnNat::Init(NATCREATE * pNatCreate)
{
    _dwIpaBase     = NTOHL(pNatCreate->_inaBase.s_addr);
    _dwIpaLast     = NTOHL(pNatCreate->_inaLast.s_addr);
    _dwIpaNext     = _dwIpaBase;
    _dwLeaseTime   = pNatCreate->_dwLeaseTime;
    _iAssign       = pNatCreate->_iAssign;
    _iFilter       = pNatCreate->_iFilter;
    _iTimeout      = (pNatCreate->_iTimeout ? pNatCreate->_iTimeout : 60) * TICKS_PER_SECOND;
    _iNatPortBase  = pNatCreate->_iNatPortBase ? pNatCreate->_iNatPortBase : 1000;
    _iNatPortLast  = _iNatPortBase + (pNatCreate->_cNatPort ? pNatCreate->_cNatPort : 1000) - 1;
    _iNatPortNext  = _iNatPortBase;

    if (_iAssign < NAT_ASSIGN_MINIMAL && _iAssign > NAT_ASSIGN_AGGRESSIVE)
        _iAssign = NAT_ASSIGN_MINIMAL;
    if (_iFilter < NAT_FILTER_NONE || _iFilter > NAT_FILTER_ADDRESS_PORT)
        _iFilter = NAT_FILTER_NONE;

    if (_iNatPortLast > 0xFFFF)
        _iNatPortLast = 0xFFFF;

    _cNatPortFree  = _iNatPortLast - _iNatPortBase + 1;
    _cBucket       = _cNatPortFree * 160 / 100;

    static DWORD s_adwPrimes[] = { 37,59,89,139,227,359,577,929,1499,2423,3919,6337,10253,16573,
        26821,43391,70207,113591,183797,297377,481171,778541,1259701,2038217,3297913,5336129,
        8633983,13970093,22604069,36574151,59178199,95752333,154930511,250682837,405613333,
        656296153,1061909479,1718205583,2780115059,0xFFFFFFFF};

    DWORD * pdwPrime = s_adwPrimes;
    for (; _cBucket < *pdwPrime; pdwPrime++) ;
    _cBucket = *pdwPrime;

    _pleHash       = (LIST_ENTRY *)HalAllocZ(_cBucket * sizeof(LIST_ENTRY), PTAG_CNatPort);
    _ppNatPort     = (CNatPort **)HalAllocZ(_cNatPortFree * sizeof(CNatPort *), PTAG_CNatPort);
    _pXnIpNatInner = new CXnIpNat;
    _pXnIpNatOuter = new CXnIpNat;

    if (_pleHash == NULL || _ppNatPort == NULL || _pXnIpNatInner == NULL || _pXnIpNatOuter == NULL)
    {
        TraceSz(Warning, "CXnNat::Init - Out of memory");
        return(FALSE);
    }

    InitializeListHead(&_leLru);

    LIST_ENTRY *    ple     = _pleHash;
    UINT            cBucket = _cBucket;

    for (; cBucket > 0; --cBucket, ++ple)
    {
        InitializeListHead(ple);
    }

    if (!_pXnIpNatInner->Init(this, pNatCreate->_pxnsp, &pNatCreate->_xncpInner, pNatCreate->_achXboxInner))
    {
        return(FALSE);
    }

    if (!_pXnIpNatOuter->Init(this, pNatCreate->_pxnsp, &pNatCreate->_xncpOuter, pNatCreate->_achXboxOuter))
    {
        return(FALSE);
    }

    _fInitialized = TRUE;

    return(TRUE);
}

void CXnNat::Term()
{
    if (_pXnIpNatInner)
    {
        _pXnIpNatInner->Stop();
    }

    if (_pXnIpNatOuter)
    {
        _pXnIpNatOuter->Stop();
    }

    if (_pXnIpNatInner)
    {
        _pXnIpNatInner->Term();
        delete _pXnIpNatInner;
        _pXnIpNatInner = NULL;
    }

    if (_pXnIpNatOuter)
    {
        _pXnIpNatOuter->Term();
        delete _pXnIpNatOuter;
        _pXnIpNatOuter = NULL;
    }

    if (!IsListNull(&_leLru))
    {
        while (!IsListEmpty(&_leLru))
        {
            CNatPort * pNatPort = (CNatPort *)((BYTE *)_leLru.Flink - offsetof(CNatPort, _leLru));
            NatPortFree(pNatPort);
        }
    }

    if (_ppNatPort)
    {
        HalFree(_ppNatPort);
    }

    if (_pDhcpLease)
    {
        HalFree(_pDhcpLease);
    }
}

void CXnNat::Recv(CXnIpNat * pXnIpNat, CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    if (!_fInitialized)
        return;

    if (pXnIpNat == _pXnIpNatOuter)
        RecvOuter(ppkt, pIpHdr, pUdpHdr, cbLen);
    else if (pIpHdr->_bProtocol == IPPROTOCOL_UDP && pUdpHdr->_ipportDst == DHCP_SERVER_PORT)
        RecvDhcp(ppkt, pIpHdr, pUdpHdr, cbLen);
    else
        RecvInner(ppkt, pIpHdr, pUdpHdr, cbLen);
}

void CXnNat::RecvDhcp(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    if (cbLen < sizeof(CDhcpHdr))
    {
        TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - DHCP payload is too small");
        return;
    }

    CDhcpHdr * pDhcpHdr = (CDhcpHdr *)(pUdpHdr + 1);

    if (    pDhcpHdr->_bOp != DHCP_OP_BOOTREQUEST
        ||  pDhcpHdr->_bHwType != DHCP_HWTYPE_ETHERNET
        ||  pDhcpHdr->_bHwLen != sizeof(CEnetAddr)
        ||  pDhcpHdr->_dwMagicCookie != DHCP_MAGIC_COOKIE)
    {
        TraceSz4(pktWarn, "[DISCARD] CXnNat::RecvDhcp - DHCP request is invalid (%d,%d,%d,%d)",
                 (pDhcpHdr->_bOp != DHCP_OP_BOOTREQUEST),
                 (pDhcpHdr->_bHwType != DHCP_HWTYPE_ETHERNET),
                 (pDhcpHdr->_bHwLen != sizeof(CEnetAddr)),
                 (pDhcpHdr->_dwMagicCookie != DHCP_MAGIC_COOKIE));
        return;
    }

    BYTE * pbOpt;
    UINT   cbOpt;
    BYTE   bType;

    if (!pDhcpHdr->GetOpt(cbLen, DHCP_OPT_MESSAGE_TYPE, 1, FALSE, &pbOpt, NULL))
    {
        TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - DHCP_OPT_MESSAGE_TYPE not found");
        return;
    }

    bType = *pbOpt;

    if (bType != DHCP_TYPE_DISCOVER && bType != DHCP_TYPE_REQUEST)
    {
        TraceSz1(pktWarn, "[DISCARD] CXnNat::RecvDhcp - DHCP_OPT_MESSAGE_TYPE (%d) not supported", bType);
        return;
    }

    if (_pXnIpNatOuter->GetIpa() == 0)
    {
        TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - NAT hasn't acquired outer IP address yet");
        return;
    }

    CDhcpLease * pDhcpLease = _pDhcpLease;
    UINT         cDhcpLease = _cDhcpLease;

    for (; cDhcpLease > 0; ++pDhcpLease, --cDhcpLease)
    {
        if (pDhcpLease->_ea.IsEqual(pDhcpHdr->_ea))
            break;
    }

    if (cDhcpLease == 0)
    {
        if (bType != DHCP_TYPE_DISCOVER)
        {
            TraceSz1(pktWarn, "[DISCARD] CXnNat::RecvDhcp - No lease found for %s", pDhcpHdr->_ea.Str());
            return;
        }

        for (; _dwIpaNext <= _dwIpaLast; ++_dwIpaNext)
        {
            if (CIpAddr(HTONL(_dwIpaNext)).IsValidAddr())
                break;
        }

        if (_dwIpaNext > _dwIpaLast)
        {
            TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - Out of IP addresses");
            return;
        }

        if (_cDhcpLease == _cDhcpLeaseAlloc)
        {
            UINT         cDhcpLeaseAlloc = _cDhcpLeaseAlloc + 64;
            CDhcpLease * pDhcpLease      = (CDhcpLease *)HalAllocZ(cDhcpLeaseAlloc * sizeof(CDhcpLease), PTAG_CDhcpLease);

            if (pDhcpLease == NULL)
            {
                TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - Out of memory allocating CDhcpLease vector");
                return;
            }

            if (_cDhcpLease > 0)
            {
                memcpy(pDhcpLease, _pDhcpLease, _cDhcpLease * sizeof(CDhcpLease));
                HalFree(_pDhcpLease);
            }

            _pDhcpLease      = pDhcpLease;
            _cDhcpLeaseAlloc = cDhcpLeaseAlloc;
        }

        pDhcpLease       = &_pDhcpLease[_cDhcpLease];
        pDhcpLease->_ea  = pDhcpHdr->_ea;
        pDhcpLease->_ipa = HTONL(_dwIpaNext);
        _dwIpaNext      += 1;
        _cDhcpLease     += 1;
    }

    if (bType == DHCP_TYPE_REQUEST)
    {
        if (!pDhcpHdr->GetOpt(cbLen, DHCP_OPT_REQUESTED_IPADDR, sizeof(CIpAddr), FALSE, &pbOpt, NULL))
        {
            TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - REQUESTED_IPADDR not supplied");
            return;
        }

        if (*(CIpAddr *)pbOpt != pDhcpLease->_ipa)
        {
            TraceSz2(pktWarn, "[DISCARD] CXnNat::RecvDhcp - REQUESTED_IPADDR is %s, expecting %s",
                     *(CIpAddr *)pbOpt, pDhcpLease->_ipa);
            return;
        }
    }

    CPacket * ppktReply = _pXnIpNatInner->PacketAlloc(PTAG_CDhcpPacket,
        PKTF_TYPE_UDP|PKTF_XMIT_INSECURE|PKTF_POOLALLOC, sizeof(CDhcpHdr) + 128);

    if (ppktReply == NULL)
    {
        TraceSz(pktWarn, "[DISCARD] CXnNat::RecvDhcp - Out of memory allocating CDhcpPacket");
        return;
    }

    CIpHdr *    pIpHdrReply     = ppktReply->GetIpHdr();
    CUdpHdr *   pUdpHdrReply    = (CUdpHdr *)(pIpHdrReply + 1);
    CDhcpHdr *  pDhcpHdrReply   = (CDhcpHdr *)(pUdpHdrReply + 1);
    BYTE *      pbOptReply      = (BYTE *)(pDhcpHdrReply + 1);

    pUdpHdrReply->_ipportSrc = DHCP_SERVER_PORT;
    pUdpHdrReply->_ipportDst = DHCP_CLIENT_PORT;
    
    memset(pDhcpHdrReply, 0, sizeof(CDhcpHdr));
    pDhcpHdrReply->_bOp = DHCP_OP_BOOTREPLY;
    pDhcpHdrReply->_bHwType = DHCP_HWTYPE_ETHERNET;
    pDhcpHdrReply->_bHwLen = sizeof(CEnetAddr);
    pDhcpHdrReply->_dwXid = pDhcpHdr->_dwXid;
    pDhcpHdrReply->_wFlags = pDhcpHdr->_wFlags;
    pDhcpHdrReply->_ipaY = pDhcpLease->_ipa;
    pDhcpHdrReply->_ea = pDhcpLease->_ea;
    pDhcpHdrReply->_dwMagicCookie = DHCP_MAGIC_COOKIE;

    *pbOptReply++ = DHCP_OPT_MESSAGE_TYPE;
    *pbOptReply++ = 1;
    *pbOptReply++ = bType == DHCP_TYPE_DISCOVER ? DHCP_TYPE_OFFER : DHCP_TYPE_ACK;

    *pbOptReply++ = DHCP_OPT_IPADDR_LEASE_TIME;
    *pbOptReply++ = sizeof(DWORD);
    *(DWORD *)pbOptReply = HTONL(_dwLeaseTime);
    pbOptReply += sizeof(DWORD);

    *pbOptReply++ = DHCP_OPT_SERVERID;
    *pbOptReply++ = sizeof(CIpAddr);
    *(CIpAddr *)pbOptReply = _pXnIpNatInner->GetIpa();
    pbOptReply += sizeof(CIpAddr);

    if (pDhcpHdr->GetOpt(cbLen, DHCP_OPT_PARAM_REQUEST_LIST, 1, TRUE, &pbOpt, &cbOpt))
    {
        for (; cbOpt > 0; ++pbOpt, --cbOpt)
        {
            switch (*pbOpt)
            {
                case DHCP_OPT_SUBNET_MASK:
                    *pbOptReply++ = DHCP_OPT_SUBNET_MASK;
                    *pbOptReply++ = sizeof(CIpAddr);
                    *(CIpAddr *)pbOptReply = _pXnIpNatInner->GetIpaMask();
                    pbOptReply += sizeof(CIpAddr);
                    break;

                case DHCP_OPT_ROUTERS:
                    *pbOptReply++ = DHCP_OPT_ROUTERS;
                    *pbOptReply++ = sizeof(CIpAddr);
                    *(CIpAddr *)pbOptReply = _pXnIpNatInner->GetIpa();
                    pbOptReply += sizeof(CIpAddr);
                    break;

                case DHCP_OPT_DNS_SERVERS:
                {
                    CIpAddr *   pipa = (CIpAddr *)(pbOptReply + 2);
                    UINT        iDns;

                    for (iDns = 0; iDns < MAX_DEFAULT_DNSSERVERS; ++iDns)
                    {
                        CIpAddr ipaDns = _pXnIpNatOuter->GetIpaDns(iDns);

                        if (ipaDns == 0)
                            break;

                        *pipa++ = ipaDns;
                    }

                    if (iDns > 0)
                    {
                        *pbOptReply++ = DHCP_OPT_DNS_SERVERS;
                        *pbOptReply++ = iDns * sizeof(CIpAddr);
                        pbOptReply += iDns * sizeof(CIpAddr);
                    }
                    break;
                }
            }
        }
    }

    *pbOptReply++ = DHCP_OPT_END;

    ppktReply->SetCb(pbOptReply - (BYTE *)pIpHdrReply);
    pUdpHdrReply->_wLen = NTOHS(pbOptReply - (BYTE *)pUdpHdrReply);

    _pXnIpNatInner->IpFillAndXmit(ppktReply, pIpHdr->_ipaSrc ? pIpHdr->_ipaSrc : IPADDR_BROADCAST, IPPROTOCOL_UDP);
}

void CXnNat::RecvInner(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    if (    ppkt->TestFlags(PKTF_RECV_BROADCAST|PKTF_RECV_LOOPBACK)
        ||  ppkt->GetHdrOptLen() > 0
        ||  pIpHdr->_ipaDst == _pXnIpNatInner->GetIpa())
        return;

    CIpAddr     ipaInner    = pIpHdr->_ipaSrc;
    CIpPort     ipportInner = pUdpHdr->_ipportSrc;
    CIpAddr     ipaOuter    = pIpHdr->_ipaDst;
    CIpPort     ipportOuter = pUdpHdr->_ipportDst;
    DWORD       dwTick      = _pXnIpNatInner->TimerTick();

    CNatPort * pNatPort = NatPortLookup(ipaInner, ipportInner, ipaOuter, ipportOuter);

    if (pNatPort == NULL)
    {
        TraceSz5(Warning, "[DISCARD] Cannot allocate CNatPort for outbound %s [%s:%d %s:%d]",
                 pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
                 ipaInner.Str(), NTOHS(ipportInner), ipaOuter.Str(), NTOHS(ipportOuter));
        return;
    }

    pNatPort->_dwTick = dwTick;

    if (_iFilter)
    {
        CNatFilt * pNatFilt = NatFiltLookup(pNatPort, ipaOuter, ipportOuter, TRUE);

        if (pNatFilt == NULL)
        {
            TraceSz5(Warning, "[DISCARD] Out of memory allocating CNatFilt for outbound %s [%s:%d %s:%d]",
                     pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
                     ipaInner.Str(), NTOHS(ipportInner), ipaOuter.Str(), NTOHS(ipportOuter));
            return;
        }

        pNatFilt->_dwTick = dwTick;
    }

    // Copy the packet, change source address and port, and forward to _pXnIpNatOuter

    CPacket * ppktNat = _pXnIpNatOuter->PacketAlloc(PTAG_CNatPacket,
        PKTF_TYPE_IP|PKTF_POOLALLOC|PKTF_XMIT_INSECURE, ppkt->GetCb() - sizeof(CIpHdr));

    if (ppktNat == NULL)
    {
        TraceSz5(pktWarn, "[DISCARD] Out of memory allocating CNatPacket for outbound %s [%s:%d %s:%d]",
                 pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
                 ipaInner.Str(), NTOHS(ipportInner), ipaOuter.Str(), NTOHS(ipportOuter));
        return;
    }

    ppktNat->SetType((WORD)(pIpHdr->_bProtocol == IPPROTOCOL_UDP ? PKTF_TYPE_UDP : PKTF_TYPE_TCP));

    CIpHdr *  pIpHdrNat  = ppktNat->GetIpHdr();
    CUdpHdr * pUdpHdrNat = (CUdpHdr *)(pIpHdrNat + 1);

    Assert(ppkt->GetCb() == ppktNat->GetCb());
    memcpy(pIpHdrNat, pIpHdr, ppkt->GetCb());

    pIpHdrNat->_ipaSrc = _pXnIpNatOuter->GetIpa();
    pUdpHdrNat->_ipportSrc = pNatPort->_ipportNat;

    TraceSz10(NatFlow, ">> %s [%s:%d %s:%d] -> [%s:%d %s:%d] (+%d)",
              pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
              pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc),
              pIpHdr->_ipaDst.Str(), NTOHS(pUdpHdr->_ipportDst),
              pIpHdrNat->_ipaSrc.Str(), NTOHS(pUdpHdrNat->_ipportSrc),
              pIpHdrNat->_ipaDst.Str(), NTOHS(pUdpHdrNat->_ipportDst),
              cbLen);

    _pXnIpNatOuter->IpXmit(ppktNat);
}

void CXnNat::RecvOuter(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    if (ppkt->TestFlags(PKTF_RECV_BROADCAST|PKTF_RECV_LOOPBACK) || ppkt->GetHdrOptLen() > 0)
        return;

    CIpAddr     ipaOuter    = pIpHdr->_ipaSrc;
    CIpPort     ipportOuter = pUdpHdr->_ipportSrc;
    CIpAddr     ipaNat      = pIpHdr->_ipaDst;
    CIpPort     ipportNat   = pUdpHdr->_ipportDst;
    DWORD       dwTick      = _pXnIpNatInner->TimerTick();

    CNatPort * pNatPort = NatPortLookup(ipportNat);

    if (pNatPort == NULL)
    {
        TraceSz5(NatPort, "!! No port mapping found for inbound %s [%s:%d %s:%d]",
                 pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
                 ipaOuter.Str(), NTOHS(ipportOuter), ipaNat.Str(), NTOHS(ipportNat));
        return;
    }

    pNatPort->_dwTick = dwTick;
    RemoveEntryList(&pNatPort->_leLru);
    InsertTailList(&_leLru, &pNatPort->_leLru);

    if (_iFilter)
    {
        CNatFilt * pNatFilt = NatFiltLookup(pNatPort, ipaOuter, ipportOuter, FALSE);

        if (pNatFilt == NULL)
        {
            TraceSz10(NatPort, "!! %s filter discarding inbound %s [%s:%d %s:%d] -> [%s:%d %s:%d]",
                      _iFilter == NAT_FILTER_ADDRESS ? "Addr" : _iFilter == NAT_FILTER_PORT ? "Port" : "AddrPort",
                      pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
                      ipaOuter.Str(), NTOHS(ipportOuter),
                      ipaNat.Str(), NTOHS(ipportNat),
                      ipaOuter.Str(), NTOHS(ipportOuter),
                      pNatPort->_ipaInner.Str(), NTOHS(pNatPort->_ipportInner));
            return;
        }

        pNatFilt->_dwTick = dwTick;
    }

    // Copy the packet, change source address and port, and forward to _pXnIpNatOuter

    CPacket * ppktNat = _pXnIpNatInner->PacketAlloc(PTAG_CNatPacket,
        PKTF_TYPE_IP|PKTF_POOLALLOC|PKTF_XMIT_INSECURE, ppkt->GetCb() - sizeof(CIpHdr));

    if (ppktNat == NULL)
    {
        TraceSz5(pktWarn, "[DISCARD] Out of memory allocating CNatPacket for inbound %s [%s:%d %s:%d]",
                 pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
                 ipaOuter.Str(), NTOHS(ipportOuter), ipaNat.Str(), NTOHS(ipportNat));
        return;
    }

    ppktNat->SetType((WORD)(pIpHdr->_bProtocol == IPPROTOCOL_UDP ? PKTF_TYPE_UDP : PKTF_TYPE_TCP));

    CIpHdr *  pIpHdrNat  = ppktNat->GetIpHdr();
    CUdpHdr * pUdpHdrNat = (CUdpHdr *)(pIpHdrNat + 1);

    Assert(ppkt->GetCb() == ppktNat->GetCb());
    memcpy(pIpHdrNat, pIpHdr, ppkt->GetCb());

    pIpHdrNat->_ipaDst = pNatPort->_ipaInner;
    pUdpHdrNat->_ipportDst = pNatPort->_ipportInner;

    TraceSz10(NatFlow, "<< %s [%s:%d %s:%d] -> [%s:%d %s:%d] (+%d)",
              pIpHdr->_bProtocol == IPPROTOCOL_UDP ? "UDP" : "TCP",
              pIpHdr->_ipaSrc.Str(), NTOHS(pUdpHdr->_ipportSrc),
              pIpHdr->_ipaDst.Str(), NTOHS(pUdpHdr->_ipportDst),
              pIpHdrNat->_ipaSrc.Str(), NTOHS(pUdpHdrNat->_ipportSrc),
              pIpHdrNat->_ipaDst.Str(), NTOHS(pUdpHdrNat->_ipportDst),
              cbLen);

    _pXnIpNatInner->IpXmitIp(ppktNat);
}

CXnNat::CNatPort * CXnNat::NatPortLookup(CIpAddr ipaInner, CIpPort ipportInner, CIpAddr ipaOuter, CIpPort ipportOuter)
{
    CNatPort * pNatPort;
    
    while (!IsListEmpty(&_leLru))
    {
        pNatPort = (CNatPort *)((BYTE *)_leLru.Flink - offsetof(CNatPort, _leLru));

        if (!NatPortExpire(pNatPort))
            break;
    }

    DWORD dwHash = ipaInner ^ (ipportInner << 3);

    if (_iAssign == NAT_ASSIGN_AGGRESSIVE)
    {
        dwHash ^= (ipaOuter << 13);
        dwHash ^= (ipaOuter >> 19);
        dwHash ^= (ipportOuter << 7);
    }
    else
    {
        ipaOuter = 0;
        ipportOuter = 0;
    }

    LIST_ENTRY * pleHead = &_pleHash[dwHash % _cBucket];

    for (LIST_ENTRY * ple = pleHead->Flink; ple != pleHead; ple = ple->Flink)
    {
        pNatPort = (CNatPort *)ple;

        if (    pNatPort->_ipaInner == ipaInner
            &&  pNatPort->_ipportInner == ipportInner
            &&  pNatPort->_ipaOuter == ipaOuter
            &&  pNatPort->_ipportOuter == ipportOuter)
        {
            return(pNatPort);
        }
    }

    if (_cNatPortFree == 0)
    {
        return(NULL);
    }

    pNatPort = (CNatPort *)HalAllocZ(sizeof(CNatPort), PTAG_CNatPort);

    if (pNatPort != NULL)
    {
        while (1)
        {
            if (_iNatPortNext > _iNatPortLast)
                _iNatPortNext = _iNatPortBase;

            if (_ppNatPort[_iNatPortNext - _iNatPortBase] == NULL)
                break;

            _iNatPortNext += 1;
        }

        pNatPort->_ipaInner     = ipaInner;
        pNatPort->_ipportInner  = ipportInner;
        pNatPort->_ipportNat    = HTONS((WORD)_iNatPortNext);
        pNatPort->_ipaOuter     = ipaOuter;
        pNatPort->_ipportOuter  = ipportOuter;
        pNatPort->_dwTick       = _pXnIpNatInner->TimerTick();

        InsertTailList(pleHead, &pNatPort->_leHash);
        InsertTailList(&_leLru, &pNatPort->_leLru);

        _ppNatPort[_iNatPortNext - _iNatPortBase] = pNatPort;

        _cNatPortFree -= 1;

        TraceSz5(NatPort, "** Port mapping %d [%s:%d %s:%d] allocated",
                 NTOHS(pNatPort->_ipportNat), pNatPort->_ipaInner.Str(), NTOHS(pNatPort->_ipportInner),
                 pNatPort->_ipaOuter.Str(), NTOHS(pNatPort->_ipportOuter));
    }

    return(pNatPort);
}

CXnNat::CNatPort * CXnNat::NatPortLookup(CIpPort ipportNat)
{
    UINT iNatPort = NTOHS(ipportNat);

    if (iNatPort < _iNatPortBase || iNatPort > _iNatPortLast)
        return(NULL);
    else
        return(_ppNatPort[iNatPort - _iNatPortBase]);
}

BOOL CXnNat::NatPortExpire(CNatPort * pNatPort)
{
    if (pNatPort->_dwTick + _iTimeout > _pXnIpNatInner->TimerTick())
    {
        return(FALSE);
    }
    
    TraceSz5(NatPort, "** Port mapping %d [%s:%d %s:%d] has timed out",
             NTOHS(pNatPort->_ipportNat), pNatPort->_ipaInner.Str(), NTOHS(pNatPort->_ipportInner),
             pNatPort->_ipaOuter.Str(), NTOHS(pNatPort->_ipportOuter));

    NatPortFree(pNatPort);
    return(TRUE);
}

void CXnNat::NatPortFree(CNatPort * pNatPort)
{
    UINT iNatPort = NTOHS(pNatPort->_ipportNat);

    TraceSz5(NatPort, "** Port mapping %d [%s:%d %s:%d] freed",
             iNatPort, pNatPort->_ipaInner.Str(), NTOHS(pNatPort->_ipportInner),
             pNatPort->_ipaOuter.Str(), NTOHS(pNatPort->_ipportOuter));

    Assert(iNatPort >= _iNatPortBase && iNatPort <= _iNatPortLast);
    Assert(_ppNatPort[iNatPort - _iNatPortBase] == pNatPort);
    _ppNatPort[iNatPort - _iNatPortBase] = NULL;

    RemoveEntryList(&pNatPort->_leHash);
    RemoveEntryList(&pNatPort->_leLru);

    if (pNatPort->_pNatFilt)
    {
        HalFree(pNatPort->_pNatFilt);
    }

    HalFree(pNatPort);

    _cNatPortFree += 1;
}

CXnNat::CNatFilt * CXnNat::NatFiltLookup(CNatPort * pNatPort, CIpAddr ipaOuter, CIpPort ipportOuter, BOOL fAlloc)
{
    CNatFilt *  pNatFilt;
    UINT        idx, idxIns;
    DWORD       dwTimeout = _pXnIpNatInner->TimerTick() - _iTimeout;

    if ((_iFilter & NAT_FILTER_ADDRESS) == 0)
    {
        ipaOuter = 0;
    }

    if ((_iFilter & NAT_FILTER_PORT) == 0)
    {
        ipportOuter = 0;
    }

    for (int iLo = 0, iHi = (int)pNatPort->_cNatFilt, iMid; iLo < iHi; )
    {
        iMid     = (iLo + iHi) >> 1;
        pNatFilt = &pNatPort->_pNatFilt[iMid];

        if (pNatFilt->_ipaOuter == ipaOuter && pNatFilt->_ipportOuter == ipportOuter)
        {
            if (!fAlloc && pNatFilt->_dwTick <= dwTimeout)
            {
                return(NULL);
            }

            return(pNatFilt);
        }

        if (pNatFilt->_ipaOuter < ipaOuter || (pNatFilt->_ipaOuter == ipaOuter && pNatFilt->_ipportOuter < ipportOuter))
            iLo = iMid + 1;
        else
            iHi = iMid;
    }

    idxIns = iLo;

    if (!fAlloc)
    {
        return(NULL);
    }

    if (pNatPort->_cNatFilt > 0 && pNatPort->_cNatFilt == pNatPort->_cNatFiltAlloc)
    {
        CNatFilt * pNatFiltDst = pNatPort->_pNatFilt;
        CNatFilt * pNatFiltEnd = pNatFiltDst + pNatPort->_cNatFilt;

        pNatFilt = pNatFiltDst;

        for (idx = 0; pNatFilt < pNatFiltEnd; ++pNatFilt)
        {
            if (pNatFilt->_dwTick > dwTimeout)
            {
                if (pNatFiltDst < pNatFilt)
                {
                    memcpy(pNatFiltDst, pNatFilt, sizeof(CNatFilt));

                    TraceSz7(NatPort, "** Port filter  %d [%s:%d %s:%d] <--> [%s:%d] has timed out",
                             NTOHS(pNatPort->_ipportNat), pNatPort->_ipaInner.Str(), NTOHS(pNatPort->_ipportInner),
                             pNatPort->_ipaOuter.Str(), NTOHS(pNatPort->_ipportOuter),
                             pNatFilt->_ipaOuter.Str(), NTOHS(pNatFilt->_ipportOuter));
                }

                pNatFiltDst += 1;
                idx += 1;
            }
            else
            {
                pNatPort->_cNatFilt -= 1;
                if (idxIns > idx)
                    idxIns -= 1;
            }
        }
    }

    if (pNatPort->_cNatFilt == pNatPort->_cNatFiltAlloc)
    {
        UINT cNatFiltAlloc = pNatPort->_cNatFiltAlloc + 8;

        pNatFilt = (CNatFilt *)HalAlloc(cNatFiltAlloc * sizeof(CNatFilt), PTAG_CNatFilt);

        if (pNatFilt == NULL)
        {
            return(NULL);
        }

        if (pNatPort->_cNatFilt > 0)
        {
            memcpy(pNatFilt, pNatPort->_pNatFilt, pNatPort->_cNatFilt * sizeof(CNatFilt));
            HalFree(pNatPort->_pNatFilt);
        }

        pNatPort->_pNatFilt = pNatFilt;
        pNatPort->_cNatFiltAlloc = cNatFiltAlloc;
    }

    Assert(idxIns <= pNatPort->_cNatFilt);
    Assert(idxIns <  pNatPort->_cNatFiltAlloc);

    pNatFilt = &pNatPort->_pNatFilt[idxIns];

    if (idxIns < pNatPort->_cNatFilt)
    {
        memmove(pNatFilt + 1, pNatFilt, (pNatPort->_cNatFilt - idxIns) * sizeof(CNatFilt));
    }

    pNatFilt->_ipaOuter     = ipaOuter;
    pNatFilt->_ipportOuter  = ipportOuter;
    pNatFilt->_dwTick       = _pXnIpNatInner->TimerTick();

    pNatPort->_cNatFilt    += 1;

    TraceSz7(NatPort, "** Port filter  %d [%s:%d %s:%d] <--> [%s:%d] allocated",
             NTOHS(pNatPort->_ipportNat), pNatPort->_ipaInner.Str(), NTOHS(pNatPort->_ipportInner),
             pNatPort->_ipaOuter.Str(), NTOHS(pNatPort->_ipportOuter),
             pNatFilt->_ipaOuter.Str(), NTOHS(pNatFilt->_ipportOuter));

    return(pNatFilt);
}

BOOL CXnNat::IsGateway(CIpPort ipport, CXnIpNat * pXnIpNat)
{
    return(pXnIpNat == _pXnIpNatInner || ipport == DNS_CLIENT_PORT);
}

// ---------------------------------------------------------------------------------------
// XNetNatCreate / XNetNatDelete
// ---------------------------------------------------------------------------------------

void * WSAAPI XNetNatCreate(NATCREATE * pNatCreate)
{
    CXnNat * pXnNat = new CXnNat;

    if (pXnNat == NULL)
    {
        TraceSz(Warning, "XNetNatCreate - Out of memory allocating CXnNat");
    }
    else if (!pXnNat->Init(pNatCreate))
    {
        XNetNatDelete(pXnNat);
        pXnNat = NULL;
    }

    return(pXnNat);
}

void WSAAPI XNetNatDelete(void * pvNat)
{
    CXnNat * pXnNat = (CXnNat *)pvNat;
    pXnNat->Term();
    delete pXnNat;
}

void WSAAPI XNetNatXmit(void * pvNat, void * pvPkt, BOOL fDiscard)
{
//@@@    ((CXnNat *)pvNat)->NatXmit(pvPkt, fDiscard);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\xnp.h ===
// ---------------------------------------------------------------------------------------
// xnp.h
//
// Private header file for the XNet Secure Networking Library
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#ifndef _XNP_H
#define _XNP_H

// ---------------------------------------------------------------------------------------
// To Do List
//
// @@@ Probing support
// @@@ DHCP rewrite (sync with XP client, gratuitous ARP, host name support, yank auto-ip)
// @@@ PPPoE support
// @@@ Network troubleshooter support
// ---------------------------------------------------------------------------------------

#pragma code_seg("XNET")
#pragma const_seg("XNET_RD")

// ---------------------------------------------------------------------------------------
// System Includes
// ---------------------------------------------------------------------------------------

#ifndef DBG
#define DBG 0
#endif

#ifdef _XBOX
    extern "C" {
        #include <ntos.h>
        #include <init.h>
        #include <hal.h>
        #include <nturtl.h>
        #include <xtl.h>
        #include <xboxp.h>
        #include <xdbg.h>
        #include <phy.h>
        #include <xbeimage.h>
        #include <ldr.h>
    };
#else
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <windows.h>
    #include <winsockx.h>
    #include <xboxp.h>
#endif

#include <winsockp.h>

// ---------------------------------------------------------------------------------------
// Configuration
// ---------------------------------------------------------------------------------------

#if DBG
    #define XNET_FEATURE_ASSERT
    #define XNET_FEATURE_TRACE
    #define XNET_FEATURE_STATS
#endif

#if defined(XNET_BUILD_LIBXS)
    #define XNET_FEATURE_XBOX
    #if DBG
        #pragma message("Building xnetsd.lib")
        #define XNET_FEATURE_XBDM_CLIENT
    #else
        #pragma message("Building xnets.lib")
    #endif
#elif defined(XNET_BUILD_LIBX)
    #define XNET_FEATURE_ARP
    #define XNET_FEATURE_DHCP
    #define XNET_FEATURE_DNS
    #define XNET_FEATURE_FRAG
    #define XNET_FEATURE_ICMP
    #define XNET_FEATURE_INSECURE
    #define XNET_FEATURE_ROUTE
    #define XNET_FEATURE_XBDM_CLIENT
    #define XNET_FEATURE_XBOX
    #if DBG
        #pragma message("Building xnetd.lib")
    #else
        #pragma message("Building xnet.lib")
    #endif
#elif defined(XNET_BUILD_LIBOS)
    #define XNET_FEATURE_ARP
    #define XNET_FEATURE_DHCP
    #define XNET_FEATURE_DNS
    #define XNET_FEATURE_FRAG
    #define XNET_FEATURE_ICMP
    #define XNET_FEATURE_ONLINE
    #define XNET_FEATURE_QOS
    #define XNET_FEATURE_ROUTE
    #define XNET_FEATURE_SG
    #define XNET_FEATURE_XBOX
    #if DBG
        #pragma message("Building xnetosd.lib")
        #define XNET_FEATURE_XBDM_CLIENT
    #else
        #pragma message("Building xnetos.lib")
    #endif
#elif defined(XNET_BUILD_LIBO)
    #define XNET_FEATURE_ARP
    #define XNET_FEATURE_DHCP
    #define XNET_FEATURE_DNS
    #define XNET_FEATURE_ICMP
    #define XNET_FEATURE_FRAG
    #define XNET_FEATURE_INSECURE
    #define XNET_FEATURE_ONLINE
    #define XNET_FEATURE_QOS
    #define XNET_FEATURE_ROUTE
    #define XNET_FEATURE_SG
    #define XNET_FEATURE_XBDM_CLIENT
    #define XNET_FEATURE_XBOX
    #if DBG
        #pragma message("Building xnetod.lib")
    #else
        #pragma message("Building xneto.lib")
    #endif
#elif defined(XNET_BUILD_LIBM)
    #define XNET_FEATURE_ARP
    #define XNET_FEATURE_DHCP
    #define XNET_FEATURE_ICMP
    #define XNET_FEATURE_FRAG
    #define XNET_FEATURE_INSECURE
    #define XNET_FEATURE_ROUTE
    #define XNET_FEATURE_XBDM_SERVER
    #define XNET_FEATURE_XBOX
    #if DBG
        #pragma message("Building xnetmd.lib")
    #else
        #pragma message("Building xnetm.lib")
    #endif
#elif defined(XNET_BUILD_LIBXW)
    #define XNET_FEATURE_ARP
    #define XNET_FEATURE_DHCP
    #define XNET_FEATURE_DNS
    #define XNET_FEATURE_FRAG
    #define XNET_FEATURE_FRAG_LOOPBACK
    #define XNET_FEATURE_ICMP
    #define XNET_FEATURE_INSECURE
    #define XNET_FEATURE_QOS
    #define XNET_FEATURE_ROUTE
    #define XNET_FEATURE_SG
    #define XNET_FEATURE_WINDOWS
    #define XNET_FEATURE_VIRTUAL
    #if DBG
        #pragma message("Building xnetwd.lib")
        #define XNET_FEATURE_VMEM
    #else
        #pragma message("Building xnetw.lib")
    #endif
#elif defined(XNET_BUILD_LIBOW)
    #define XNET_FEATURE_ARP
    #define XNET_FEATURE_DHCP
    #define XNET_FEATURE_DNS
    #define XNET_FEATURE_FRAG
    #define XNET_FEATURE_FRAG_LOOPBACK
    #define XNET_FEATURE_ICMP
    #define XNET_FEATURE_INSECURE
    #define XNET_FEATURE_ONLINE
    #define XNET_FEATURE_QOS
    #define XNET_FEATURE_ROUTE
    #define XNET_FEATURE_SG
    #define XNET_FEATURE_WINDOWS
    #define XNET_FEATURE_VIRTUAL
    #if DBG
        #pragma message("Building xnetwd.lib")
        #define XNET_FEATURE_VMEM
    #else
        #pragma message("Building xnetw.lib")
    #endif
#else
    #error "Don't know which xnet library to build"
#endif

#ifdef XNET_FEATURE_ARP
#pragma message("  XNET_FEATURE_ARP")
#endif

#ifdef XNET_FEATURE_ASSERT
#pragma message("  XNET_FEATURE_ASSERT")
#endif

#ifdef XNET_FEATURE_DHCP
#pragma message("  XNET_FEATURE_DHCP")
#endif

#ifdef XNET_FEATURE_DNS
#pragma message("  XNET_FEATURE_DNS")
#endif

#ifdef XNET_FEATURE_FRAG
#pragma message("  XNET_FEATURE_FRAG")
#endif

#ifdef XNET_FEATURE_FRAG_LOOPBACK
#pragma message("  XNET_FEATURE_FRAG_LOOPBACK")
#endif

#ifdef XNET_FEATURE_ICMP
#pragma message("  XNET_FEATURE_ICMP")
#endif

#ifdef XNET_FEATURE_INSECURE
#pragma message("  XNET_FEATURE_INSECURE")
#endif

#ifdef XNET_FEATURE_ONLINE
#pragma message("  XNET_FEATURE_ONLINE")
#endif

#ifdef XNET_FEATURE_QOS
#pragma message("  XNET_FEATURE_QOS")
#endif

#ifdef XNET_FEATURE_ROUTE
#pragma message("  XNET_FEATURE_ROUTE")
#endif

#ifdef XNET_FEATURE_SG
#pragma message("  XNET_FEATURE_SG")
#endif

#ifdef XNET_FEATURE_TRACE
#pragma message("  XNET_FEATURE_TRACE")
#endif

#ifdef XNET_FEATURE_VIRTUAL
#pragma message("  XNET_FEATURE_VIRTUAL")
#endif

#ifdef XNET_FEATURE_VMEM
#pragma message("  XNET_FEATURE_VMEM")
#endif

#ifdef XNET_FEATURE_WINDOWS
#pragma message("  XNET_FEATURE_WINDOWS")
#endif

#ifdef XNET_FEATURE_XBDM_CLIENT
#pragma message("  XNET_FEATURE_XBDM_CLIENT")
#endif

#ifdef XNET_FEATURE_XBDM_SERVER
#pragma message("  XNET_FEATURE_XBDM_SERVER")
#endif

#ifdef XNET_FEATURE_XBOX
#pragma message("  XNET_FEATURE_XBOX")
#endif

// ---------------------------------------------------------------------------------------
// Debugging
// ---------------------------------------------------------------------------------------

#include <xn.h>

ExternTag(LeakWarn);
ExternTag(pktXmit);
ExternTag(pktRecv);
ExternTag(pktBroadcast);
ExternTag(pktWarn);
ExternTag(secStat);
ExternTag(sock);
ExternTag(sockWarn);

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_VIRTUAL
#define VIRTUAL                 virtual
#define NOVTABLE
#define VPURE                   = 0
#else
#define NOVTABLE                __declspec(novtable)
#define VIRTUAL
#define VPURE
#endif

#define XNETPTAGLIST() \
    XNETPTAG(CXnHal,            'NET0') \
    XNETPTAG(CXnBase,           'NET1') \
    XNETPTAG(CXnNic,            'NET2') \
    XNETPTAG(CXnEnet,           'NET3') \
    XNETPTAG(CXnIp,             'NET4') \
    XNETPTAG(CXnSock,           'NET5') \
    XNETPTAG(CDhcpOptions,      'NET6') \
    XNETPTAG(CRouteEntry,       'NET7') \
    XNETPTAG(CSocket,           'NET8') \
    XNETPTAG(CUdpRecvBuf,       'NET9') \
    XNETPTAG(CTcpSocket,        'NETa') \
    XNETPTAG(CTcpRecvBuf,       'NETb') \
    XNETPTAG(CRecvReq,          'NETc') \
    XNETPTAG(CXmitReq,          'NETd') \
    XNETPTAG(Pool,              'NETe') \
    XNETPTAG(PoolStart,         'NETf') \
    XNETPTAG(PoolEnd,           'NETg') \
    XNETPTAG(select,            'NETh') \
    XNETPTAG(CArpPacket,        'NETi') \
    XNETPTAG(CDhcpPacket,       'NETj') \
    XNETPTAG(CIcmpEchoPacket,   'NETk') \
    XNETPTAG(CFragPacket,       'NETl') \
    XNETPTAG(CTcpPacket,        'NETm') \
    XNETPTAG(CUdpPacket,        'NETn') \
    XNETPTAG(CKeyReg,           'NETo') \
    XNETPTAG(CSecReg,           'NETp') \
    XNETPTAG(CKeyExPacket,      'NETq') \
    XNETPTAG(CPacket,           'NETr') \
    XNETPTAG(CXbdmPacket,       'NETs') \
    XNETPTAG(CDnsReg,           'NETt') \
    XNETPTAG(CDnsPacket,        'NETu') \
    XNETPTAG(CSecMsgPacket,     'NETv') \
    XNETPTAG(CXnNat,            'NETw') \
    XNETPTAG(CXnIpNat,          'NETx') \
    XNETPTAG(CDhcpLease,        'NETy') \
    XNETPTAG(CNatPacket,        'NETz') \
    XNETPTAG(CNatPort,          'NETA') \
    XNETPTAG(CNatFilt,          'NETB') \
    XNETPTAG(QosData,           'NETC') \

#undef  XNETPTAG
#define XNETPTAG(_name, _tag) PTAG_##_name = NTOHL_(_tag),

enum { XNETPTAGLIST() };

#define INITF_HAL               0x00000001
#define INITF_HAL_1             0x00000002
#define INITF_HAL_2             0x00000004
#define INITF_HAL_STOP          0x00000008
#define INITF_HAL_TERM          0x00000010
#define INITF_BASE              0x00000020
#define INITF_BASE_1            0x00000040
#define INITF_BASE_2            0x00000080
#define INITF_BASE_STOP         0x00000100
#define INITF_BASE_TERM         0x00000200
#define INITF_NIC               0x00000400
#define INITF_NIC_1             0x00000800
#define INITF_NIC_2             0x00001000
#define INITF_NIC_STOP          0x00002000
#define INITF_NIC_TERM          0x00004000
#define INITF_ENET              0x00008000
#define INITF_ENET_1            0x00010000
#define INITF_ENET_2            0x00020000
#define INITF_ENET_STOP         0x00040000
#define INITF_ENET_TERM         0x00080000
#define INITF_IP                0x00100000
#define INITF_IP_1              0x00200000
#define INITF_IP_2              0x00400000
#define INITF_IP_STOP           0x00800000
#define INITF_IP_TERM           0x01000000
#define INITF_SOCK              0x02000000
#define INITF_SOCK_1            0x04000000
#define INITF_SOCK_2            0x08000000
#define INITF_SOCK_STOP         0x10000000
#define INITF_SOCK_TERM         0x20000000
#define INITF_CONNECTED_BOOT    0x80000000

#define NETERR(_err)            HRESULT_FROM_WIN32(_err)
#define NETERR_OK               STATUS_SUCCESS
#define NETERR_PARAM            NETERR(WSAEINVAL)
#define NETERR_MEMORY           NETERR(WSAENOBUFS)
#define NETERR_SYSCALL          NETERR(WSASYSCALLFAILURE)
#define NETERR_FAULT            NETERR(WSAEFAULT)
#define NETERR_CANCELLED        NETERR(WSAECANCELLED)
#define NETERR_PENDING          NETERR(WSA_IO_PENDING)
#define NETERR_WOULDBLOCK       NETERR(WSAEWOULDBLOCK)
#define NETERR_MSGSIZE          NETERR(WSAEMSGSIZE)
#define NETERR_TIMEOUT          NETERR(WSAETIMEDOUT)
#define NETERR_NOTIMPL          NETERR(ERROR_CALL_NOT_IMPLEMENTED)
#define NETERR_UNREACHABLE      NETERR(WSAEHOSTUNREACH)
#define NETERR_NETDOWN          NETERR(WSAENETDOWN)
#define NETERR_ADDRINUSE        NETERR(WSAEADDRINUSE)
#define NETERR_ADDRCONFLICT     NETERR(ERROR_DHCP_ADDRESS_CONFLICT)
#define NETERR_CONNRESET        NETERR(WSAECONNRESET)

#define IPPROTOCOL_SECMSG       0
#define IPPROTOCOL_ICMP         1
#define IPPROTOCOL_TCP          6
#define IPPROTOCOL_UDP          17

#define DNS_SERVER_PORT         HTONS_(53)
#define DNS_CLIENT_PORT         HTONS_(53)
#define DHCP_CLIENT_PORT        HTONS_(68)
#define DHCP_SERVER_PORT        HTONS_(67)
#define ESPUDP_CLIENT_PORT      HTONS_(3074)

#define dimensionof(x)          (sizeof((x))/sizeof(*(x)))
#define BIT(n)                  (1u << (n))
#define ROUNDUP4(count)         (((count) + 3) & ~3)
#define ROUNDUP8(count)         (((count) + 7) & ~7)
#define IsListNull(_ple)        ((_ple)->Flink == NULL)

// ---------------------------------------------------------------------------------------
// XNetParams
// ---------------------------------------------------------------------------------------

#define XNETPARAMDEFS() \
    DEFINE_PARAM_( 0, cfgSizeOfStruct,                         0, 0,   0) \
    DEFINE_PARAM_( 1, cfgFlags,                                0, 0, 255) \
    DEFINE_PARAM_( 2, cfgPrivatePoolSizeInPages,              12, 4, 255) \
    DEFINE_PARAM_( 3, cfgEnetReceiveQueueLength,               8, 4, 255) \
    DEFINE_PARAM_( 4, cfgIpFragMaxSimultaneous,                4, 1, 255) \
    DEFINE_PARAM_( 5, cfgIpFragMaxPacketDiv256,                8, 4, 255) \
    DEFINE_PARAM_( 6, cfgSockMaxSockets,                      64, 1, 255) \
    DEFINE_PARAM_( 7, cfgSockDefaultRecvBufsizeInK,           16, 1,  63) \
    DEFINE_PARAM_( 8, cfgSockDefaultSendBufsizeInK,           16, 1,  63) \
    DEFINE_PARAM_( 9, cfgKeyRegMax,                            4, 1, 255) \
    DEFINE_PARAM_(10, cfgSecRegMax,                           32, 1, 255) \
    DEFINE_PARAM_(11, cfgQosDataLimitDiv4,                   128, 0, 255) \
    DEFINE_PARAM (    cfgEnetTransmitQueueLength,             10, 4, 255) \
    DEFINE_PARAM (    cfgEnetArpReqRetries,                    2, 1, 255) \
    DEFINE_PARAM (    cfgEnetArpRexmitTimeoutInSeconds,        1, 1, 255) \
    DEFINE_PARAM (    cfgEnetArpPosCacheTimeoutInMinutes,     10, 1, 255) \
    DEFINE_PARAM (    cfgEnetArpNegCacheTimeoutInMinutes,      1, 1, 255) \
    DEFINE_PARAM (    cfgIpFragTimeoutInSeconds,              60, 1, 255) \
    DEFINE_PARAM (    cfgIpDefaultTos,                         0, 0, 255) \
    DEFINE_PARAM (    cfgIpDefaultTtl,                        64, 1, 255) \
    DEFINE_PARAM (    cfgAutoIpMaxAttempts,                   10, 1, 255) \
    DEFINE_PARAM (    cfgAutoIpRexmitTimeoutInSeconds,         2, 1, 255) \
    DEFINE_PARAM (    cfgAutoIpRetriesPerAttempt,              2, 1, 255) \
    DEFINE_PARAM (    cfgDhcpRetryCount,                       3, 1, 255) \
    DEFINE_PARAM (    cfgDhcpRetryMaxTimeoutInSeconds,        10, 1, 255) \
    DEFINE_PARAM (    cfgDhcpDefaultLeaseTimeInDays,           0, 0, 255) \
    DEFINE_PARAM (    cfgDhcpRenewMinTimeoutInSeconds,        60, 1, 255) \
    DEFINE_PARAM (    cfgDhcpDeclineWaitInSeconds,            10, 1, 255) \
    DEFINE_PARAM (    cfgSockMaxListenBacklog,                 5, 1, 255) \
    DEFINE_PARAM (    cfgSockMaxSendBufsizeInK,               63, 1,  63) \
    DEFINE_PARAM (    cfgSockMaxRecvBufsizeInK,               63, 1,  63) \
    DEFINE_PARAM (    cfgSockSegmentLifetimeInSeconds,        30, 1, 255) \
    DEFINE_PARAM (    cfgSockConnectTimeoutInSeconds,         20, 1, 255) \
    DEFINE_PARAM (    cfgSockLingerTimeoutInSeconds,         120, 1, 255) \
    DEFINE_PARAM (    cfgSockRexmitRetries,                    5, 1, 255) \
    DEFINE_PARAM (    cfgSockRexmitTimeoutInSeconds,           3, 1, 255) \
    DEFINE_PARAM (    cfgSockRexmitMinTimeoutInSeconds,        1, 1, 255) \
    DEFINE_PARAM (    cfgSockRexmitMaxTimeoutInSeconds,        8, 1, 255) \
    DEFINE_PARAM (    cfgSockPersistTimeoutInSeconds,          5, 1, 255) \
    DEFINE_PARAM (    cfgKeyExXbToXbRexmitRetries,             9, 1, 255) \
    DEFINE_PARAM (    cfgKeyExXbToXbRexmitTimeoutInSeconds,    1, 1, 255) \
    DEFINE_PARAM (    cfgKeyExXbToSgRexmitRetries,             4, 1, 255) \
    DEFINE_PARAM (    cfgKeyExXbToSgRexmitTimeoutInSeconds,    2, 1, 255) \
    DEFINE_PARAM (    cfgDnsRetries,                           4, 1, 255) \
    DEFINE_PARAM (    cfgDnsTimeoutInSeconds,                  2, 1, 255) \
    DEFINE_PARAM (    cfgSecRegVisitInSeconds,                 5, 1, 255) \
    DEFINE_PARAM (    cfgSecRegPulseTimeoutInSeconds,         20, 1, 255) \
    DEFINE_PARAM (    cfgSecRegTimeoutInSecondsDiv10,         13, 1, 255) \

#define DEFINE_PARAM_(idx, name, def, min, max) BYTE name;
#define DEFINE_PARAM(name, def, min, max) BYTE name;

#include <pshpack1.h>
struct XNetParams { XNETPARAMDEFS() };
#include <poppack.h>

struct XNetInitParams
{
    XNetParams *    pxnp;
    char *          pszXbox;
    LARGE_INTEGER   liTime;
    BYTE            abSeed[20];
};

// ---------------------------------------------------------------------------------------
// CXnVoid
// ---------------------------------------------------------------------------------------

class NOVTABLE CXnVoid
{
    VIRTUAL void VoidInit() {};
};

// ---------------------------------------------------------------------------------------
// CXnHal
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_WINDOWS
#include "halw.h"
#endif

#ifdef XNET_FEATURE_XBOX
#include "halx.h"
#endif

#include <stdio.h>
#include <stddef.h>
#include <stdarg.h>

// ---------------------------------------------------------------------------------------
// Crypto
// ---------------------------------------------------------------------------------------

#include <xcrypt.h>

#ifdef XNET_FEATURE_ASSERT
#define XCRYPT_VERIFY(x)    do { BOOL __fOK__ = (x); if (!__fOK__) AssertSz(FALSE, "XCRYPT_SERVICE failed"); } while (0)
#else
#define XCRYPT_VERIFY(x)    x
#endif

// ---------------------------------------------------------------------------------------
// CTimer
// ---------------------------------------------------------------------------------------

typedef void (CXnVoid::*PFNPKTFREE)(class CPacket * ppkt);
typedef void (CXnVoid::*PFNTIMER)(class CTimer * pt);

class CTimer
{
    friend class CXnBase;

    // Definitions -------------------------------------------------------------------

    #define TICKS_PER_SECOND    5       // 200 ms per tick (25 years before DWORD wraps)
    #define MSEC_PER_TICK       (1000 / TICKS_PER_SECOND)
    #define TIMER_INFINITE      0xFFFFFFFF

    // External ----------------------------------------------------------------------

public:

    INLINE void Init(PFNTIMER pfn)  { _le.Flink = NULL; _pfn = pfn; _dwTick = TIMER_INFINITE; }
    INLINE BOOL IsActive()          { return(_le.Flink != NULL); }
    INLINE BOOL IsNull()            { return(_pfn == NULL); }

    // Data --------------------------------------------------------------------------

private:

    LIST_ENTRY  _le;
    DWORD       _dwTick;
    PFNTIMER    _pfn;

};

struct CEventTimer : public CTimer
{
    PRKEVENT    _pEvent;
};

C_ASSERT(sizeof(CEventTimer) == CBEVENTTIMER);

// ---------------------------------------------------------------------------------------
// CXnBase
// ---------------------------------------------------------------------------------------

struct CLeak
{
    void *  _pv;
    UINT    _cb;
    ULONG   _tag;
};

class NOVTABLE CXnBase : public CXnHal
{
    // Definitions -----------------------------------------------------------------------

public:

    #define MAX_SMALL_BLOCKS 5

private:

    // External --------------------------------------------------------------------------

public:

    HAL_DECLARE_NEW_DELETE(CXnBase)

    NTSTATUS        BaseInit(XNetInitParams * pxnip);
    void            BaseStart();
    void            BaseStop();
    void            BaseTerm();

    void *          LeakAdd(CLeakInfo * pli, void * pv, UINT cb, ULONG tag);
    void *          LeakDel(CLeakInfo * pli, void * pv);
    BOOL            LeakFind(CLeakInfo * pli, void * pv, CLeak ** ppLeak);
    void            LeakTerm(CLeakInfo * pli);

    void *          SysAlloc(size_t size, ULONG tag);
    void *          SysAllocZ(size_t size, ULONG tag);
    void            SysFree(void * pv);

    void *          PoolAlloc(size_t size, ULONG tag);
    void *          PoolAllocZ(size_t size, ULONG tag);
    void            PoolFree(void * pv);

    CPacket *       PacketAlloc(ULONG tag, UINT uiFlags, UINT cbPayload = 0, UINT cbPkt = 0, PFNPKTFREE pfn = NULL);
    void            PacketFree(CPacket * ppkt);

    void            Rand(BYTE * pb, UINT cb);
    ULONG           RandLong();
    INLINE ULONG    RandScaled(ULONG ulMax);

    void            TimerSet(CTimer * pt, DWORD dwTick);
    DWORD           TimerSetRelative(CTimer * pt, DWORD dwTicksFromNow);
    INLINE DWORD    TimerTick()         { TCHECK(UDPC|SDPC); return(_dwTick); }

    void            PushPktRecvTags(BOOL fBroadcast);
    void            PopPktRecvTags();

    VIRTUAL void    SecRegProbe() VPURE;
    VIRTUAL void    NicTimer() VPURE;

    // Internal --------------------------------------------------------------------------

private:

    void            RandInit(XNetInitParams * pxnip);

    void            PoolDump();

    static void     TimerDpc(PKDPC pkdpc, void * pvContext, void * pvParam1, void * pvParam2);
    void            TimerPush();

    // Data ------------------------------------------------------------------------------

public:

    XNETPARAMDEFS()

    void *          _pvPoolStart;
    void *          _pvPoolEnd;
    LIST_ENTRY      _aleFree[MAX_SMALL_BLOCKS + 1];
    BYTE            _abRandRc4Struct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
    KDPC            _dpcTimer;
    KTIMER          _timerTimer;
    LIST_ENTRY      _leTimers;
    DWORD           _dwTickKe;
    DWORD           _dwTick;

#ifdef XNET_FEATURE_ASSERT
    CLeakInfo       _leakinfo;
#endif

#ifdef XNET_FEATURE_TRACE
    BYTE            _abPushPop[32];
    UINT            _cbPushPop;
    UINT            _cPushPopBroadcast;
    UINT            _pktRecvPushPop;
    UINT            _pktWarnPushPop;
#endif

private:

    static const XNetParams s_XNetParamsDef;
    static const XNetParams s_XNetParamsMin;
    static const XNetParams s_XNetParamsMax;

};

INLINE void * CXnBase::SysAlloc(size_t size, ULONG tag)
{
    ICHECK(BASE, USER|UDPC);
    void * pv = HalAlloc(size, tag);
#ifdef XNET_FEATURE_ASSERT
    LeakAdd(&_leakinfo, pv, size, tag);
#endif
    return(pv);
}

INLINE void * CXnBase::SysAllocZ(size_t size, ULONG tag)
{
    ICHECK(BASE, USER|UDPC);
    void * pv = HalAllocZ(size, tag);
#ifdef XNET_FEATURE_ASSERT
    LeakAdd(&_leakinfo, pv, size, tag);
#endif
    return(pv);
}

INLINE void CXnBase::SysFree(void * pv)
{
    ICHECK(BASE, USER|UDPC|SDPC);
#ifdef XNET_FEATURE_ASSERT
    LeakDel(&_leakinfo, pv);
#endif
    HalFree(pv);
}

INLINE ULONG CXnBase::RandScaled(ULONG ulMax)
{
    ICHECK(BASE, USER|UDPC|SDPC);
    return(RandLong() % (ulMax + 1));
}

#ifndef XNET_FEATURE_TRACE

INLINE void CXnBase::PushPktRecvTags(BOOL fBroadcast) {}
INLINE void CXnBase::PopPktRecvTags() {}

#endif

// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

extern "C" UINT tcpipxsum(UINT xsum, const void * buf, UINT buflen);
const char * DbgVerifyList(LIST_ENTRY * ple, LIST_ENTRY * pleRequire);
char * XnAddrStr(const XNADDR * pxnaddr);
void XnInAddrToString(const IN_ADDR ina, char * pchBuf, INT cchBuf);

// Ethernet Address ----------------------------------------------------------------------

#include <pshpack1.h>

struct CEnetAddr
{
    BYTE _ab[6];

    INLINE BOOL IsEqual(const CEnetAddr & ea) const { return(memcmp(_ab, ea._ab, sizeof(_ab)) == 0); }
    INLINE BOOL IsEqual(const BYTE * pb) const { return(memcmp(_ab, pb, sizeof(_ab)) == 0); }
    INLINE void SetBroadcast()                { *(DWORD *)&_ab[0] = 0xFFFFFFFF; *(WORD *)&_ab[4] = 0xFFFF; }
    INLINE void SetZero()                     { *(DWORD *)&_ab[0] = 0x00000000; *(WORD *)&_ab[4] = 0x0000; }
    INLINE BOOL IsBroadcast() const           { return(*(DWORD *)&_ab[0] == 0xFFFFFFFF && *(WORD *)&_ab[4] == 0xFFFF); }
    INLINE BOOL IsMulticast() const           { return((_ab[0] & 1) != 0); }
    INLINE BOOL IsZero() const                { return(*(DWORD *)&_ab[0] == 0 && *(WORD *)&_ab[4] == 0); }
    char * Str() const;
};

#include <poppack.h>

// Ethernet Link Headers -----------------------------------------------------------------

#define ENET_LINK_MAXSIZE   ROUNDUP4(sizeof(CIeeeHdr))
#define ENET_DATA_MAXSIZE   1500
#define ENET_DATA_MINSIZE   42
#define ENET_TYPE_IP        HTONS_(0x0800)
#define ENET_TYPE_ARP       HTONS_(0x0806)

#include <pshpack1.h>

struct CEnetHdr
{
    CEnetAddr       _eaDst;
    CEnetAddr       _eaSrc;
    WORD            _wType;
};

struct CIeeeHdr : public CEnetHdr
{
    BYTE            _bDsap;         // 0xAA
    BYTE            _bSsap;         // 0xAA
    BYTE            _bControl;      // 0x03
    BYTE            _bOrgCode[3];   // 0x00 0x00 0x00
    WORD            _wTypeIeee;

    INLINE BOOL IsEnetFrame()   { return(*(DWORD *)&_bDsap == 0x0003AAAA && *(WORD *)&_bOrgCode[1] == 0); }
    INLINE BOOL IsValid()       { return(NTOHS(_wType) > ENET_DATA_MAXSIZE || IsEnetFrame()); }
};

#include <poppack.h>

// IP Address in Network Byte Order ------------------------------------------------------

struct CIpAddr                      // IP Address in Network Byte Order
{
    union
    {
        BYTE        _ab[4];
        DWORD       _dw;
    };

    #define IPADDR_BROADCAST            CIpAddr(HTONL_(0xFFFFFFFF))
    #define IPADDR_LOOPBACK             CIpAddr(HTONL_(0x7F000001))
    #define IPADDR_ALLHOSTS             CIpAddr(HTONL_(0xE0000001))
    #define IPADDR_ALLROUTERS           CIpAddr(HTONL_(0xE0000002))
    #define IPADDR_CLASSA_NETMASK       CIpAddr(HTONL_(0xFF000000))
    #define IPADDR_CLASSB_NETMASK       CIpAddr(HTONL_(0xFFFF0000))
    #define IPADDR_CLASSC_NETMASK       CIpAddr(HTONL_(0xFFFFFF00))
    #define IPADDR_CLASSD_NETMASK       CIpAddr(HTONL_(0xF0000000))
    #define IPADDR_CLASSD_NETID         CIpAddr(HTONL_(0xE0000000))
    #define IPADDR_LOOPBACK_NETID       CIpAddr(HTONL_(0x7F000000))
    #define IPADDR_SECURE_NETID         CIpAddr(HTONL_(0x00000000))
    #define IPADDR_SECURE_NETMASK       CIpAddr(HTONL_(0xFF000000))
    #define IPADDR_SECURE_DEFAULT       CIpAddr(HTONL_(0x00000001))

    INLINE operator DWORD () const { return(_dw); }
    INLINE DWORD operator = (DWORD & dw) { return(_dw = dw); }
    INLINE CIpAddr(DWORD dw) { _dw = dw; }
    INLINE CIpAddr(WORD wUniq, BYTE bSlot) { Assert(wUniq > 0); _dw = HTONL((wUniq << 8) | bSlot); Assert(IsSecure()); }
    INLINE CIpAddr() {}

    INLINE BOOL IsBroadcast() const { return(_dw == IPADDR_BROADCAST); }
    INLINE BOOL IsMulticast() const { return(IsClassD() && !IsBroadcast()); }
    INLINE BOOL IsLoopback() const { return((_dw & IPADDR_CLASSA_NETMASK) == IPADDR_LOOPBACK_NETID); }
    INLINE BOOL IsSecure() const { return(_dw && (_dw & IPADDR_SECURE_NETMASK) == IPADDR_SECURE_NETID); }
    INLINE UINT SecureSlot() const { Assert(IsSecure()); return(_dw >> 24); }
    INLINE BOOL IsClassA() const { return((_dw & HTONL_(0x80000000)) == HTONL_(0x00000000)); }
    INLINE BOOL IsClassB() const { return((_dw & HTONL_(0xC0000000)) == HTONL_(0x80000000)); }
    INLINE BOOL IsClassC() const { return((_dw & HTONL_(0xE0000000)) == HTONL_(0xC0000000)); }
    INLINE BOOL IsClassD() const { return((_dw & HTONL_(0xF0000000)) == HTONL_(0xE0000000)); }
    INLINE BOOL IsValidMask() const { DWORD dw = ~NTOHL(_dw); return((dw & (dw + 1)) == 0); }
    BOOL IsValidUnicast() const;
    BOOL IsValidAddr() const;
    CIpAddr DefaultMask() const;
    char * Str() const;
};

// IP Port in Network Byte Order ---------------------------------------------------------

struct CIpPort
{
    WORD            _w;

    INLINE operator WORD () { return (_w); }
    INLINE WORD operator = (WORD & w) { return(_w = w); }
    INLINE CIpPort(WORD w) { _w = w; }
    INLINE CIpPort() {}
};

// IP Header in Network Byte Order -------------------------------------------------------

#include <pshpack1.h>

struct CIpHdr
{
    BYTE            _bVerHdr;       // Version & header length
    BYTE            _bTos;          // Type of service
    WORD            _wLen;          // Total length including IP header
    WORD            _wId;           // Identification
    WORD            _wFragOff;      // Flags and fragment offset
    BYTE            _bTtl;          // Time to live
    BYTE            _bProtocol;     // Protocol
    WORD            _wChecksum;     // Header checksum
    CIpAddr         _ipaSrc;        // Source address
    CIpAddr         _ipaDst;        // Destination address

    INLINE UINT     GetHdrLen()         { return((_bVerHdr & 0xF) << 2); }
    INLINE void     SetHdrLen(UINT cb)  { _bVerHdr = (BYTE)(0x40 | (cb >> 2)); } 
    INLINE UINT     GetOptLen()         { return(GetHdrLen() - sizeof(CIpHdr)); }
    INLINE UINT     GetLen()            { return(NTOHS(_wLen)); }
    INLINE UINT     VerifyHdrLen()      { return((_bVerHdr & 0xF0) == 0x40 ? GetHdrLen() : 0); }

};

#include <poppack.h>

#define MAXIPHDRLEN         (15*4)
#define DONT_FRAGMENT       BIT(14)
#define MORE_FRAGMENTS      BIT(13)
#define FRAGOFFSET_MASK     0x1FFF

#define TraceIpHdr(tag, pIpHdr, cbDat) \
    TraceSz9(tag, "[IP %s %s (%d %d %04X %04X) %d]{%d}[%d]", \
             (pIpHdr)->_ipaDst.Str(), (pIpHdr)->_ipaSrc.Str(), (pIpHdr)->_bTos, (pIpHdr)->_bTtl, \
             NTOHS((pIpHdr)->_wId), NTOHS((pIpHdr)->_wFragOff), (pIpHdr)->_bProtocol, \
             (pIpHdr)->GetOptLen(), (cbDat))

// UDP/TCP Pseudo Header in Network Byte Order -------------------------------------------

#include <pshpack1.h>

struct CPseudoHeader
{
    CIpAddr         _ipaSrc;
    CIpAddr         _ipaDst;
    BYTE            _bZero;
    BYTE            _bProtocol;
    WORD            _wLen;
};

#include <poppack.h>

// UDP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

struct CUdpHdr
{
    CIpPort         _ipportSrc;     // Source port
    CIpPort         _ipportDst;     // Destination port
    WORD            _wLen;          // Datagram length including UDP header
    WORD            _wChecksum;     // Datagram checksum

    INLINE UINT GetLen()            { return(NTOHS(_wLen)); }
};

#include <poppack.h>

#define TraceUdpHdr(tag, pSocket, pUdpHdr, cbDat) \
        TraceSz5(tag, "[%X.u] [UDP %d %d][%d] %s", (pSocket), \
                  NTOHS((pUdpHdr)->_ipportDst), NTOHS((pUdpHdr)->_ipportSrc), \
                  (cbDat), DataToString((BYTE *)(pUdpHdr) + sizeof(CUdpHdr), cbDat)) \

// TCP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

struct CTcpHdr
{
    // Definitions -----------------------------------------------------------------------

    #define TCPSEQ  DWORD

    // External --------------------------------------------------------------------------

    INLINE void SetHdrLen(UINT cb)  { _bHdrLen = (BYTE)(ROUNDUP4(cb) << 2); }
    INLINE UINT GetHdrLen()         { return((_bHdrLen & 0xF0) >> 2); }

    // Data ------------------------------------------------------------------------------

    CIpPort         _ipportSrc;     // Source port
    CIpPort         _ipportDst;     // Destination port
    TCPSEQ          _dwSeqNum;      // Sequence number
    TCPSEQ          _dwAckNum;      // Ack number
    BYTE            _bHdrLen;       // Header length (number of DWORDs)
    BYTE            _bFlags;        // Flags
    WORD            _wWindow;       // Window
    WORD            _wChecksum;     // Checksum
    WORD            _wUrgent;       // Urgent pointer

};

#include <poppack.h>

// Return the sequence numbers in a TCP segment (in host byte order)
#define SEG_SEQ(_tcphdr) NTOHL((_tcphdr)->_dwSeqNum)
#define SEG_ACK(_tcphdr) NTOHL((_tcphdr)->_dwAckNum)
#define SEG_WIN(_tcphdr) NTOHS((_tcphdr)->_wWindow)
#define SEG_URG(_tcphdr) NTOHS((_tcphdr)->_wUrgent)

// Return the length of a TCP segment (counting SYN and FIN)
#define SEG_LEN(_tcphdr, _datalen) \
        ((_datalen) + \
         (((_tcphdr)->_bFlags & TCP_SYN) ? 1 : 0) + \
         (((_tcphdr)->_bFlags & TCP_FIN) ? 1 : 0))

// convenience macro for checking segment flags
#define ISTCPSEG(_tcphdr, _flag) ((_tcphdr)->_bFlags & TCP_##_flag)

#define MAXTCPHDRLEN (4*15)
// TCP segment flag bits
#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20

// Control flags
#define TCP_CONTROLS (TCP_SYN|TCP_FIN|TCP_RST) 

//
// TCP option tags
//
#define TCPOPT_EOL              0x00
#define TCPOPT_NOP              0x01
#define TCPOPT_MAX_SEGSIZE      0x02
#define TCPOPT_WINDOW_SCALE     0x03
#define TCPOPT_SACK_PERMITTED   0x04
#define TCPOPT_SACK             0x05
#define TCPOPT_TIMESTAMP        0x08

char * DataToString(BYTE * pb, UINT cb);

#define TraceTcpHdr(tag, pTcpSocket, pTcpHdr, cbOpt, cbDat) \
        TraceSz16(tag, "[%X.t] [TCP %d %d %08lX %08lX %d %d%s%s%s%s%s%s]{%d}[%d] %s", (pTcpSocket), \
                  NTOHS((pTcpHdr)->_ipportDst), NTOHS((pTcpHdr)->_ipportSrc), \
                  NTOHL((pTcpHdr)->_dwSeqNum), NTOHL((pTcpHdr)->_dwAckNum), \
                  NTOHS((pTcpHdr)->_wWindow), NTOHS((pTcpHdr)->_wUrgent), \
                  ((pTcpHdr)->_bFlags & TCP_FIN) ? " FIN" : "", \
                  ((pTcpHdr)->_bFlags & TCP_SYN) ? " SYN" : "", \
                  ((pTcpHdr)->_bFlags & TCP_RST) ? " RST" : "", \
                  ((pTcpHdr)->_bFlags & TCP_PSH) ? " PSH" : "", \
                  ((pTcpHdr)->_bFlags & TCP_ACK) ? " ACK" : "", \
                  ((pTcpHdr)->_bFlags & TCP_URG) ? " URG" : "", \
                  (cbOpt), (cbDat), DataToString((BYTE *)(pTcpHdr) + sizeof(CTcpHdr) + (cbOpt), cbDat)) \

// ESP Header in Network Byte Order ------------------------------------------------------

#include <pshpack1.h>

struct CEspHdr : public CUdpHdr
{
    DWORD           _dwSpi;         // Security parameters index
    DWORD           _dwSeq;         // Sequence number
};

struct CEspTail
{
    BYTE            _bPadLen;       // Length of padding
    BYTE            _bNextHeader;   // Protocol
    BYTE            _abHash[12];    // HMAC-SHA-1-96 digest
};

#include <poppack.h>

#define ESP_OVERHEAD_1      (sizeof(CIpHdr) + sizeof(CEspHdr) + (sizeof(CEspTail) - offsetof(CEspTail, _abHash)))
#define ESP_OVERHEAD_8      (offsetof(CEspTail, _abHash))
#define ESP_MSS(n,p)        (((((n) - ESP_OVERHEAD_1) / 8) * 8) - XC_SERVICE_DES_BLOCKLEN - (p) - ESP_OVERHEAD_8)

// ---------------------------------------------------------------------------------------
// CPacket
// ---------------------------------------------------------------------------------------

class CPacket
{
    friend class CPacketQueue;

    // Definitions -----------------------------------------------------------------------

public:

    #define PKTF_RECV_BROADCAST     0x0001      // Packet was received via link-level broadcast
    #define PKTF_RECV_LOOPBACK      0x0002      // Packet was received via local loopback
    #define PKTF_IHL_MASK           0x003C      // Number of DWORD's of IP header options
    #define PKTF_POOLALLOC          0x0040      // Packet was allocated with pool allocator
    #define PKTF_CRYPT              0x0080      // Packet is encrypted on the wire
    #define PKTF_TYPE_MASK          0x0700      // PKTF_TYPE_* mask
    #define PKTF_XMIT_FRAME         0x0800      // Tells ENET layer to send packet without ARP
    #define PKTF_XMIT_PRIORITY      0x1000      // Tells ENET layer to queue packet before others
    #define PKTF_XMIT_DUALPAGE      0x2000      // Used by NIC layer during transmit
    #define PKTF_XMIT_XBDMCLIENT    0x4000      // Used by NIC layer during transmit
    #define PKTF_XMIT_INSECURE      0x8000      // Tells IP layer to bypass security

    #define PKTF_IHL_SHIFT          2
    #define PKTF_TYPE_SHIFT         8

    #define PKTFT(i)                ((i) << PKTF_TYPE_SHIFT)

    #define PKTF_TYPE_IP            PKTFT(0)    // [ENET]^[IP][Payload]
    #define PKTF_TYPE_IP_ESP        PKTFT(1)    // [ENET]^[IP][ESP][Payload][ESPT]
    #define PKTF_TYPE_UDP           PKTFT(2)    // [ENET]^[IP][UDP][Payload]
    #define PKTF_TYPE_UDP_ESP       PKTFT(3)    // [ENET]^[IP][ESP][UDP][Payload][ESPT]
    #define PKTF_TYPE_TCP           PKTFT(4)    // [ENET]^[IP][TCP][Payload]
    #define PKTF_TYPE_TCP_ESP       PKTFT(5)    // [ENET]^[IP][ESP][TCP][Payload][ESPT]
    #define PKTF_TYPE_ENET          PKTFT(6)    // [ENET]^[Payload]
    #define PKTF_TYPE_ESP           PKTFT(1)    // Bit common to all [ESP] types

    #define PKTI_ESP                0           // [ESP]
    #define PKTI_UDP_TCP            1           // [UDP]/[TCP]
    #define PKTI_SIZE               2           // Size of frame excluding [ENET] and [Payload]
    #define PKTI_MAX                3           // Number of PKTI_* defined

    // Allocate / Deallocate -------------------------------------------------------------

public:

    INLINE void Init(UINT uiFlags, void * pv, UINT cb, PFNPKTFREE pfn)
    {
        _pv         = pv;
        _cb         = (WORD)cb;
        _wFlags     = (WORD)uiFlags;
        _ppktNext   = NULL;
        _pfn        = pfn;
#if DBG
        _fAllocated = FALSE;
        DbgSetSpy();
#endif
    }

    INLINE void Complete(CXnVoid * pXnVoid)
    {
        (pXnVoid->*_pfn)(this);
    }

    // Member Functions ------------------------------------------------------------------

public:

    INLINE WORD        GetFlags()              { return(_wFlags); }
    INLINE void        SetFlags(WORD wFlags)   { _wFlags |= wFlags; IFDBG(DbgSetSpy();) }
    INLINE void        ClearFlags(WORD wFlags) { _wFlags &= ~wFlags; IFDBG(DbgSetSpy();) }
    INLINE BOOL        TestFlags(WORD wFlags)  { return(!!(_wFlags & wFlags)); }
    INLINE WORD        GetType()               { return(_wFlags & PKTF_TYPE_MASK); }
    INLINE void        SetType(WORD wFlags)    { _wFlags = (_wFlags & ~PKTF_TYPE_MASK) | (wFlags & PKTF_TYPE_MASK); IFDBG(DbgSetSpy();) }

    INLINE void *      GetPv()                 { return(_pv); }
    INLINE void        SetPv(void * pv)        { _pv = pv; }
    INLINE UINT        GetCb()                 { return(_cb); }
    INLINE void        SetCb(UINT cb)          { _cb = (WORD)cb; }
    INLINE void        SetPfn(PFNPKTFREE pfn)  { _pfn = pfn; }
    INLINE UINT        GetHdrOptLen()          { Assert(PKTF_IHL_SHIFT == 2); return(_wFlags & PKTF_IHL_MASK); }
    INLINE void        SetHdrOptLen(UINT cb)   { Assert(PKTF_IHL_SHIFT == 2); Assert(ROUNDUP4(cb) == cb); _wFlags = (_wFlags & ~PKTF_IHL_MASK) | cb; }

    INLINE BOOL        IsEnet()                { return(GetType() == PKTF_TYPE_ENET); }
    INLINE BOOL        IsIp()                  { return(GetType() <  PKTF_TYPE_ENET); }
    INLINE BOOL        IsEsp()                 { return(TestFlags(PKTF_TYPE_ESP)); }
    INLINE BOOL        IsCrypt()               { Assert(IsEsp()); return(TestFlags(PKTF_CRYPT)); }
    INLINE BOOL        IsUdp()                 { return(TestFlags(PKTF_TYPE_UDP)); }
    INLINE BOOL        IsTcp()                 { return(TestFlags(PKTF_TYPE_TCP)); }

           void *      GetHdr(int iHdr);
    INLINE CEnetHdr *  GetEnetHdr()            { return((CEnetHdr *)((BYTE *)_pv - sizeof(CEnetHdr))); }
    INLINE CIpHdr *    GetIpHdr()              { Assert(IsIp()); return((CIpHdr *)_pv); }
    INLINE CEspHdr *   GetEspHdr()             { Assert(IsEsp()); return((CEspHdr *)GetHdr(PKTI_ESP)); }
    INLINE CUdpHdr *   GetUdpHdr()             { Assert(IsUdp()); return((CUdpHdr *)GetHdr(PKTI_UDP_TCP)); }
    INLINE CTcpHdr *   GetTcpHdr()             { Assert(IsTcp()); return((CTcpHdr *)GetHdr(PKTI_UDP_TCP)); }
    INLINE CEspTail *  GetEspTail()            { Assert(IsEsp()); return((CEspTail *)((BYTE *)_pv + _cb - sizeof(CEspTail))); }
    
    INLINE CPacket *   GetNextPkt()            { return(_ppktNext); }

    // Data ------------------------------------------------------------------------------

private:

    void *              _pv;                // [LINK]^[Payload]
    WORD                _cb;                // Size of [Payload]
    WORD                _wFlags;            // See PKTF_* above
    CPacket *           _ppktNext;          // Next packet in packet queue
    PFNPKTFREE          _pfn;               // Function which frees the packet

#if DBG

    struct CSpy
    {
        CEnetHdr *      _pEnetHdr;          // Pointer to CEnetHdr (if any)
        CIpHdr *        _pIpHdr;            // Pointer to CIpHdr (if any)
        CEspHdr *       _pEspHdr;           // Pointer to CEspHdr (if any)
        CUdpHdr *       _pUdpHdr;           // Pointer to CUdpHdr (if any)
        CTcpHdr *       _pTcpHdr;           // Pointer to CTcpHdr (if any)
        CEspTail *      _pEspTail;          // Pointer to CEspTail (if any)
    };

private:

    const char *        _pchSpy;            // String describing packet format
    CSpy                _spy;               // Spy structure
    BOOL                _fAllocated;        // Packet was allocated via PacketAlloc

public:

    void                DbgSetSpy();
    void                SetAllocated()      { _fAllocated = TRUE; }
    BOOL                IsAllocated()       { return(_fAllocated); }
    void                Validate();

#else

public:

    INLINE void         Validate()          {}

#endif

public:

    static const BYTE         _abPktTypeInfo[];
    static const char * const _aszPktTypeName[];

};

// ---------------------------------------------------------------------------------------
// CPacketQueue
// ---------------------------------------------------------------------------------------

class CPacketQueue
{

public:

    void                InsertHead(CPacket * ppkt);
    void                InsertTail(CPacket * ppkt);
    void                InsertHead(CPacketQueue * ppq);
    CPacket *           RemoveHead();
    void                Dequeue(CPacket * ppktDequeue);
    void                Complete(CXnBase * pXnBase);
    void                Discard(CXnBase * pXnBase);
    UINT                Count();

    INLINE void         Init()      { _ppktHead = NULL; _ppktTail = NULL; }
    INLINE BOOL         IsEmpty()   { return(_ppktHead == NULL); }
    INLINE CPacket *    GetHead()   { return(_ppktHead); }

private:

    CPacket *           _ppktHead;
    CPacket *           _ppktTail;

};

// ---------------------------------------------------------------------------------------
// CXnNic
// ---------------------------------------------------------------------------------------

#ifdef XNET_FEATURE_WINDOWS
#include "nicw.h"
#endif

#ifdef XNET_FEATURE_XBOX
#include "nicx.h"
#endif

// ---------------------------------------------------------------------------------------
// CXnEnet
// ---------------------------------------------------------------------------------------

class NOVTABLE CXnEnet : public CXnNic
{
    friend void CXnNic::EnetRecv(CPacket * ppkt, UINT uiType);
    friend void CXnNic::EnetPush();

    // Definitions -----------------------------------------------------------------------

#ifdef XNET_FEATURE_ARP

    #define ARP_STATE_FREE      0           // entry is free
    #define ARP_STATE_IDLE      1           // entry is good
    #define ARP_STATE_BAD       2           // target is unreachable
    #define ARP_STATE_BUSY      3           // entry is being resolved

    #define ARP_OP_REQUEST      HTONS_(1)   // opcodes
    #define ARP_OP_REPLY        HTONS_(2)

    #define ARP_HWTYPE_ENET     HTONS_(1)   // hardware address spaces
    #define ARP_HWTYPE_802      HTONS_(6)

    enum ArpResolve
    {
        eNone,
        eCreateEntry,
        eSendRequest
    };

    #define ARP_CACHE_SIZE      64          // cache parametes (modulo should be prime)
    #define ARP_HASH_RETRY      5
    #define ARP_HASH_MODULO     (ARP_CACHE_SIZE-ARP_HASH_RETRY)
    #define ARP_HASH(_addr)     ((_addr) % ARP_HASH_MODULO)

    struct CArpEntry
    {
        CIpAddr         _ipa;
        DWORD           _dwTick;
        CPacketQueue    _pqWait;
        CEnetAddr       _eaNext;
        WORD            _wState;

        INLINE CArpEntry() {}
        INLINE BOOL IsFree()   { return(_wState == ARP_STATE_FREE); }
        INLINE BOOL IsIdle()   { return(_wState == ARP_STATE_IDLE); }
        INLINE BOOL IsBad()    { return(_wState == ARP_STATE_BAD); }
        INLINE BOOL IsBusy()   { return(_wState >= ARP_STATE_BUSY); }
    };

    #include <pshpack1.h>

    struct CArpMsg
    {
        WORD            _wHrd;      // hardware address space
        WORD            _wPro;      // protocol address space (ENET_TYPE_IP)
        BYTE            _bHln;      // hardware address length (6)
        BYTE            _bPln;      // protocol address length (4)
        WORD            _wOp;       // opcode
        CEnetAddr       _eaSender;  // sender's hardware address
        CIpAddr         _ipaSender; // sender's protocol address
        CEnetAddr       _eaTarget;  // target's hardware address
        CIpAddr         _ipaTarget; // target's protocol address
    };

    #include <poppack.h>

#endif

    // External --------------------------------------------------------------------------

public:

    HAL_DECLARE_NEW_DELETE(CXnEnet)

    void            EnetXmit(CPacket * ppkt, CIpAddr ipaNext = 0);
    void            EnetXmitArp(CIpAddr ipa);
    void            EnetPush();

protected:

    NTSTATUS        EnetInit(XNetInitParams * pxnip);
    INLINE void     EnetStart()     { NicStart(); }
    void            EnetStop();
    void            EnetTerm();

    VIRTUAL void    IpRecv(CPacket * ppkt) VPURE;
    VIRTUAL void    IpRecvArp(CEnetAddr * pea) VPURE;

    VIRTUAL void    EnetRecv(CPacket * ppkt, UINT uiType);
    VIRTUAL void    EnetQueuePush();

    // Internal --------------------------------------------------------------------------

private:

#ifdef XNET_FEATURE_ARP

    void            ArpXmit(WORD wOp, CIpAddr ipaTarget, CIpAddr ipaSender, CEnetAddr * peaTarget);
    CArpEntry *     ArpLookup(CIpAddr ipa, ArpResolve eResolve);
    void            ArpTimer(CTimer * pt);
    void            ArpRecv(CPacket * ppkt);

#endif

    void            EnetFillAndXmit(CPacket * ppkt, CEnetAddr * peaNext);

    static void     EnetDpc(PKDPC, void *, void *, void *);
    void            EnetProcessDpc();

    // Data ------------------------------------------------------------------------------
    
public:

    CIpAddr         _ipa;                   // IP address of this interface
    CIpAddr         _ipaMask;               // IP address mask
    CIpAddr         _ipaSubnet;             // IP subnet address

private:

    CPacketQueue    _pqXmit;                // Transmit packet queue
    KDPC            _dpcEnet;               // DPC

#ifdef XNET_FEATURE_ARP

    CIpAddr         _ipaCheck;              // IP address we are checking for uniqueness
    CArpEntry *     _paeLast;               // Last entry fetched
    CArpEntry       _aae[ARP_CACHE_SIZE];   // Arp cache
    CTimer          _timerArp;              // Arp timer

#endif

};    

// ---------------------------------------------------------------------------------------
// CRouteEntry
// ---------------------------------------------------------------------------------------

class CRouteEntry
{
    friend class CXnIp;

    // Definitions -----------------------------------------------------------------------

    #define RTEF_ORPHAN         0x0001             // the route entry is orphaned
    #define RTEF_HOST           0x0002             // host route
    #define RTEF_DEFAULT        0x0004             // default gateway route
    #define RTEF_LOCAL          0x0008             // local route

    #define RTE_DEFAULT_METRIC  1

    // External --------------------------------------------------------------------------

private:

    HAL_DECLARE_NEW_DELETE(CRouteEntry)

    void            AddRef()                    { InterlockedIncrement(&_cRefs); }

    // Internal --------------------------------------------------------------------------

    INLINE void     SetFlags(WORD wFlags)       { _wFlags |= wFlags; }
    INLINE void     ClearFlags(WORD wFlags)     { _wFlags &= ~wFlags; }
    INLINE BOOL     TestFlags(WORD wFlags)      { return(!!(_wFlags & wFlags)); }

    INLINE BOOL     IsOrphan()                  { return(TestFlags(RTEF_ORPHAN)); }
    INLINE BOOL     IsLocal()                   { return(TestFlags(RTEF_LOCAL)); }
    INLINE BOOL     IsHost()                    { return(TestFlags(RTEF_HOST)); }

    // Data ------------------------------------------------------------------------------

    LIST_ENTRY      _le;                        // Doubly linked list entry
    LONG            _cRefs;                     // Reference count
    WORD            _wFlags;                    // See RTEF_*
    WORD            _wMetric;                   // Route metrics (smaller is higher priority)
    CIpAddr         _ipaDst;                    // Destination IP address
    CIpAddr         _ipaMask;                   // Destination IP address mask
    CIpAddr         _ipaNext;                   // Next hop IP address

};

// ---------------------------------------------------------------------------------------
// CXnIp
// ---------------------------------------------------------------------------------------

struct CDnsReg;
struct CDnsHdr;

class NOVTABLE CXnIp : public CXnEnet
{
    friend void CXnBase::SecRegProbe();
    friend void CXnEnet::IpRecv(CPacket * ppkt);
    friend void CXnEnet::IpRecvArp(CEnetAddr * pea);

    #define MAX_DEFAULT_GATEWAYS 4
    #define MAX_DEFAULT_DNSSERVERS 4

    typedef DWORD DHCPTIME;

    struct CSecReg;

    struct CDhcpOptions
    {
        INLINE CDhcpOptions() {}
        INT         _recvMsgType;           // type message received
        CIpAddr     _dhcpmask;              // subnet mask
        CIpAddr     _dhcpServer;            // dhcp server address
        DHCPTIME    _t1time;                // when to enter renewing state
        DHCPTIME    _t2time;                // when to enter rebinding state
        DHCPTIME    _exptime;               // lease expiration time
        UINT        _gatewayCount;          // number of gateways
        CIpAddr     _gateways[MAX_DEFAULT_GATEWAYS];
        UINT        _dnsServerCount;
        CIpAddr     _dnsServers[MAX_DEFAULT_DNSSERVERS];
    };

    struct CQosPkt : public CPacket
    {
        void *          _pvQos;             // Pointer to CQosReq or CQosListen owning this packet
        BOOL            _fQosReq;           // TRUE if packet belongs to CQosReq; FALSE for CQosListen
        BOOL            _fInXmit;           // TRUE if packet is being transmitted
    };

    struct CQosInfo
    {
        LIST_ENTRY      _le;                // Link into _leXmit{Wait} or _leOpen{Wait}
        XNADDR          _xnaddr;            // XNet Address (XbToXb)
        XNKID           _xnkid;             // Key identifier (XbToXb)
        XNKEY           _xnkey;             // Key exchange key (XbToXb)
        CSecReg *       _pSecReg;           // Pointer to CSecReg (XbToSg)
        BYTE            _bState;            // Current state of this Qos item
        BYTE            _bRetry;            // Retries remaining at current state
        CIpPort         _ipportDst;         // Destination port
        CIpAddr         _ipaDst;            // Destination IP address
        UINT            _cbQos;             // Size of Qos data
        BYTE *          _pbQos;             // Qos data buffer
    };

    struct CQosReq
    {
        CQosReq *       _pQosReqNext;       // Next CQosReq item in the list
        BOOL            _fXbToSg;           // TRUE if XB to SG; FALSE if XB to XB
        PRKEVENT        _pEvent;            // Event to signal whenever progress is made
        DWORD           _dwFlags;           // XNET_QOS_* flags from request
        BYTE            _abNonce[8];        // Nonce for this request
        LIST_ENTRY      _leXmit;            // Queue of CQosInfo ready to xmit
        LIST_ENTRY      _leWait;            // Queue of CQosInfo waiting for response
        UINT            _iQosInfo;          // Index of CQosInfo to process next
        UINT            _cQosInfo;          // Count of CQosInfo items
        CQosInfo *      _pQosInfo;          // Array of CQosInfo items
        CQosPkt *       _pQosPkt1;          // Pointer to first Qos packet in packet pair
        CQosPkt *       _pQosPkt2;          // Pointer to second Qos packet in packet pair
        BYTE *          _pbQosData;         // Pointer to Qos data buffer for all CQosInfo
        XNQOS           _xnqos;             // User-visible XNQOS structure
    };

    struct CQosReg
    {
        DWORD           _dwBitsPerSec;      // Bandwidth limit for responses
        CQosPkt *       _pQosPkt1;          // Pointer to first Qos packet in packet pair
        CQosPkt *       _pQosPkt2;          // Pointer to second Qos packet in packet pair
        UINT            _cbQos;             // Size of Qos data
        BYTE            _abQos[1];          // Qos data buffer
    };

    struct CKeyReg
    {
        // External ----------------------------------------------------------------------

        INLINE CKeyReg() {}

        // Data --------------------------------------------------------------------------

        XNKID           _xnkid;             // key identifier
        BYTE            _abKeySha[16];      // key exchange SHA auth key
        BYTE            _abKeyDes[8];       // key exchange DES key
        BYTE            _abDhX[CBDHG1];     // diffie-hellman X value
        BYTE            _abDhGX[CBDHG1];    // diffie-hellman g^X value
        CQosReg *       _pQosReg;           // Pointer to CQosReg if listening
    };

    #include <pshpack1.h>

    struct CKeyExXbToXb : public CKeyExHdr
    {
        XNKID           _xnkid;             // key identifier of key-exchange-key
        DWORD           _dwSpiInit;         // SPI of the initiator
        DWORD           _dwSpiResp;         // SPI of the responder
        BYTE            _abNonceInit[8];    // Nonce of the initiator
        BYTE            _abNonceResp[8];    // Nonce of the responder
        LARGE_INTEGER   _liTime;            // Increasing time-value of the sender
        BYTE            _abIv[8];           // Initialization vector for DES encryption
        XNADDR          _xnaddrInit;        // XNADDR of the initiator (encrypted)
        XNADDR          _xnaddrResp;        // XNADDR of the responder (encrypted)
    };

    struct CKeyExNatOpen : public CKeyExHdr
    {
        // Definitions -------------------------------------------------------------------
        
        #define KNOF_XBTOXB_KEYEX   0x0001  // Request occuring for key exchange
        #define KNOF_XBTOXB_PROBE   0x0002  // Request occuring for probing

        // Data --------------------------------------------------------------------------

        XNKID           _xnkid;             // key identifier of key-exhcange-key
        DWORD           _dwCtx;             // Context identifier from the sender
        BYTE            _abNonce[8];        // Nonce from the sender
        CIpAddr         _ipaDst;            // IP address of the sender
        CIpPort         _ipportDst;         // IP port of the sender
        WORD            _wFlags;            // See KNOF_* above
        BYTE            _abHash[20];        // SHA hash of this message (including header)
    };

    struct CKeyExQos : public CKeyExHdr
    {
        DWORD           _dwReserved;        // Placeholder
    };

    #include <poppack.h>

    struct CSecReg
    {
        // Definitions -------------------------------------------------------------------

        #define SR_STATE_IDLE       0       // key exchange not started by either side
        #define SR_STATE_INITSENT   1       // initiator packet has been sent
        #define SR_STATE_RESPSENT   2       // response packet has been sent
        #define SR_STATE_INITWAIT   3       // initiator waiting for responder to synchronize
        #define SR_STATE_READY      4       // key exchange is complete

        #define SRF_SYSTEMLINK      0x0001  // Other side is an XB via system link
        #define SRF_ONLINEPEER      0x0002  // Other side is an XB that is online
        #define SRF_ONLINESERVER    0x0004  // Other side is an SG
        #define SRF_SECMSG_DELETE   0x0008  // SECMSG_TYPE_DELETE has been sent
        #define SRF_OWNED           0x0010  // This side owns this CSecReg

        // External ----------------------------------------------------------------------

        INLINE      CSecReg() {}
        INLINE      IsXmitReady() { return(_bState >= SR_STATE_INITWAIT); }
        INLINE      IsRecvReady() { return(_bState >= SR_STATE_RESPSENT); }
        char *      CSecReg::Str();

        INLINE BOOL TestFlags(WORD wFlags)  { return(!!(_wFlags & wFlags)); }
        INLINE void SetFlags(WORD wFlags)   { _wFlags |= wFlags; }
        INLINE void ClearFlags(WORD wFlags) { _wFlags &= ~wFlags; }

        // Data --------------------------------------------------------------------------

        BYTE            _wFlags;                // See SRF_* above
        BYTE            _bState;                // See SR_STATE_* above
        BYTE            _bRetry;                // Number of retries remaining
        DWORD           _dwSpiRecv;             // SPI assigned by this side
        DWORD           _dwSpiXmit;             // SPI assigned by other side
        DWORD           _dwSeqRecv;             // Base sequence of receive window
        DWORD           _dwSeqMask;             // Bit mask of sequence numbers received
        DWORD           _dwSeqXmit;             // Highest sequence number transmitted
        DWORD           _dwTickRecv;            // TimerTick when last packet recv
        DWORD           _dwTickXmit;            // TimerTick when last packet xmit
        DWORD           _dwTickPulse;           // TimerTick when last pulse xmit
        DWORD           _dwTickPulseTimeout;    // Outbound inactivity before sending pulse
        DWORD           _dwTickTimeout;         // Inbound inactivity before timing out connection
        CPacketQueue    _pqWait;                // Queue of packets waiting
        CTimer          _timer;                 // Timer for scheduling timeouts
        BYTE            _abIv[8];               // Next IV to use for encrypted packets
        BYTE            _abNonceInit[8];        // Nonce generated by the initiator
        BYTE            _abNonceResp[8];        // Nonce generated by the responder
        BYTE            _abKeyShaRecv[16];      // Negotiated incoming SHA auth key
        BYTE            _abKeyDesRecv[24];      // Negotiated incoming DES crypt key
        WORD            _cbKeyDesRecv;          // Size of incoming DES crypt key
        BYTE            _abKeyShaXmit[16];      // Negotiated outgoing SHA auth key
        BYTE            _abKeyDesXmit[24];      // Negotiated outgoing DES crypt key
        WORD            _cbKeyDesXmit;          // Size of outgoing DES crypt key
        CIpAddr         _ipaDst;                // Destination IP address for ONLINEPEER or ONLINESERVER
        CIpPort         _ipportDst;             // Destination port for ONLINEPEER or ONLINESERVER
        LARGE_INTEGER   _liTime;                // [XB] Highest time value, [SG] Kerberos time
        union {
            struct {
                CKeyReg *       _pKeyReg;       // [XB] Pointer to corresponding CKeyReg
                XNADDR          _xnaddr;        // [XB] XNADDR of the destination
            };
            struct {
                DWORD           _dwServiceId;   // [SG] Service Identifier
                SGADDR          _sgaddr;        // [SG] SGADDR assigned by SG
                CIpAddr         _ipaNat;        // [SG] NAT'd source IP address as seen by SG
                CIpPort         _ipportNat;     // [SG] NAT'd source port as seen by SG
            };
        };
    };

    // External --------------------------------------------------------------------------

public:

    INLINE          CXnIp() {};

    void            IpXmit(CPacket * ppkt, CRouteEntry ** pprte = NULL);
    void            IpFillAndXmit(CPacket * ppkt, CIpAddr ipaDst, BYTE bProtocol, CRouteEntry ** pprte = NULL);
    void            IpFillHdr(CPacket * ppkt, CIpAddr ipaDst, BYTE bProtocol);
    void            IpSetAddress(CIpAddr ipa, CIpAddr ipaMask);

    BOOL            IpDecrypt(CPacket * ppkt, CIpAddr ipaDst);

    INT             IpCreateKey(XNKID * pxnkid, XNKEY * pxnkey);
    INT             IpRegisterKey(const XNKID * pxnkid, const XNKEY * pxnkey);
    INT             IpUnregisterKey(const XNKID * pxnkid);
    INT             IpXnAddrToInAddr(const XNADDR * pxna, const XNKID * pxnkid, CIpAddr * pipa);
    INT             IpServerToInAddr(const CIpAddr ipa, DWORD dwServiceId, CIpAddr * pipa);
    INT             IpInAddrToXnAddr(const CIpAddr ipa, XNADDR * pxna, XNKID * pxnkid);
    INT             IpUnregisterInAddr(const CIpAddr ipa);
    DWORD           IpGetXnAddr(XNADDR * pxna);

    void            RouteRelease(CRouteEntry * prte);
    INLINE WORD     GetNextDgramId()    { return((WORD)InterlockedIncrement(&_lNextDgramId)); }

#ifdef XNET_FEATURE_DNS
    INT             IpDnsLookup(const char * pszHost, WSAEVENT hEvent, XNDNS ** ppxndns);
    INT             IpDnsRelease(XNDNS * pxndns);
#endif

#ifndef XNET_FEAUTRE_QOS
    INT             IpQosListen(const XNKID * pxnkid, const BYTE * pb, UINT cb, DWORD dwBitsPerSec, DWORD dwFlags);
    INT             IpQosXnAddr(UINT cxnqos, const XNADDR * apxna[], const XNKID * apxnkid[], const XNKEY * apxnkey[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos);
    INT             IpQosServer(UINT cxnqos, const IN_ADDR aina[], const DWORD adwServiceId[], DWORD dwFlags, WSAEVENT hEvent, XNQOS ** ppxnqos);
    INT             IpQosRelease(XNQOS * pxnqos);
#endif

    void            SecRegSetOwned(CIpAddr ipa);
    void            SecRegShutdown(BOOL fOnlineOnly);
    INLINE BYTE     SecRegRexmitRetries(CSecReg * pSecReg);
    INLINE BYTE     SecRegRexmitTimeoutInSeconds(CSecReg * pSecReg);

#ifdef XNET_FEATURE_ONLINE
    INLINE CXoBase *IpGetXoBase() { return(_pXoBase); }
    void            IpSetXoBase(CXoBase * pXoBase);
    void            IpRaiseToDpc(BOOL fRaise);
#endif

#ifdef XNET_FEATURE_SG
    void            IpLogon(CIpAddr ipaLogon, ULONGLONG * pqwUserId, WSAEVENT hEventLogon);
    DWORD           IpLogonGetStatus(SGADDR * psgaddr);
    BOOL            IpLogonGetQFlags(UINT iUserId, ULONGLONG * pqwUserId, DWORD * pdwQFlags, DWORD * pdwSeqQFlags);
    BOOL            IpLogonSetQFlags(UINT iUserId, DWORD dwQFlags, DWORD dwSeqQFlags);
    BOOL            IpLogonSetPState(UINT iUserId, DWORD dwPState, const XNKID * pxnkid, UINT cbData, BYTE * pbData);
    void            IpLogoff();
#endif

    void            IpSetEventTimer(CEventTimer * pEventTimer, WSAEVENT hEvent, DWORD dwTimeout);
    void            EventTimer(CTimer * pt);

protected:

    NTSTATUS        IpInit(XNetInitParams * pxnip);
    INT             IpConfig(const XNetConfigParams * pxncp, DWORD dwFlags);
    INT             IpGetConfigStatus(XNetConfigStatus * pxncs);
    INLINE void     IpStart()       { EnetStart(); }
    void            IpStop();
    void            IpTerm();

    VIRTUAL void    IpRecv(CPacket * ppkt);
    VIRTUAL void    IpRecvArp(CEnetAddr * pea);

    VIRTUAL void    UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen) VPURE;
    VIRTUAL void    TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen) VPURE;
    VIRTUAL void    SockReset(CIpAddr ipa) VPURE;

#ifdef XNET_FEATURE_WINDOWS
    VIRTUAL void    EnetXmit(CPacket * ppkt, CIpAddr ipaNext = 0) { CXnEnet::EnetXmit(ppkt, ipaNext); }
    INLINE  void    IpXmitIp(CPacket * ppkt) { IpXmitIp(ppkt, NULL); }
    VIRTUAL BOOL    IsGateway(CIpPort ipport) { return(FALSE); }
#else
    INLINE  BOOL    IsGateway(CIpPort ipport) { return(FALSE); }
#endif

    // Internal --------------------------------------------------------------------------

private:
    
    void            IpXmitEsp(CPacket * ppkt, CSecReg * pSecReg, CRouteEntry ** pprte);
    void            IpXmitIp(CPacket * ppkt, CRouteEntry ** pprte);

    NTSTATUS        RouteInit();
    void            RouteTerm();
    CRouteEntry *   RouteLookup(CIpAddr ipaDst);
    void            RouteAdd(CIpAddr ipaDst, CIpAddr ipaMask, CIpAddr ipaNext, WORD wFlags, WORD wMetric);
    void            RouteRedirect(CIpAddr ipaDst, CIpAddr ipaOldGateway, CIpAddr ipNewGateway);
    void            RouteDelete(CIpAddr ipaDst, CIpAddr ipaMask, CIpAddr ipaNext);
    void            RouteListOrphan();
    void            RouteInvalidateCache();
    void            RouteEntryOrphan(CRouteEntry * prte);
    void            RouteListDump();

    void            FragTerm();
    void            FragRecv(CPacket * ppkt, CIpHdr * pIpHdr, UINT cbHdrLen, UINT cbLen);
    void            FragTimer(CTimer * pt);
    void            FragFree(CPacket * ppkt);

    void            IcmpRecv(CPacket* ppkt, CIpHdr * pIpHdr, void * pvData, UINT cbData);

    NTSTATUS        DhcpInit();
    INT             DhcpConfig(const XNetConfigParams * pxncp);
    void            DhcpTerm();
    void            DhcpTimer(CTimer * pt);
    void            DhcpRecv(CPacket * ppkt, CUdpHdr * pUdpHdr, UINT cbLen);
    void            DhcpNotifyAddressConflict();
    BOOL            DhcpForceAutonet(CIpAddr addr, CIpAddr mask);
    void            DhcpTimerSetRelative(UINT minWait, UINT maxWait);
    void            DhcpTimerSetAbsolute(DHCPTIME dhcptime);
    void            DhcpComputeTimeout();
    void            DhcpChangeState(INT state);
    void            DhcpResetInterface();
    NTSTATUS        DhcpSendMessage(CPacket * ppkt, UINT msglen, BOOL broadcast);
    BYTE *          DhcpFillMessageHeader(BYTE * buf, INT msgtype);
    void            DhcpComputeSecsSinceStart();
    NTSTATUS        DhcpSendDiscover();
    NTSTATUS        DhcpSendRequest();
    NTSTATUS        DhcpSendInform();
    NTSTATUS        DhcpSendRelease();
    NTSTATUS        DhcpProcessOffer(CIpAddr yiaddr, CDhcpOptions * param);
    void            DhcpAddOrRemoveGateways(BOOL doDelete);
    void            DhcpSetDefaultGateways();
    void            DhcpUseOptionParams(CDhcpOptions * param);
    NTSTATUS        DhcpProcessAck(CIpAddr yiaddr, CDhcpOptions * param);
    NTSTATUS        DhcpProcessNak(CIpAddr dhcpServer);
    void            DhcpSelectAutonetAddr();
    BYTE *          DhcpAppendLeaseTimeOption(BYTE * option);
    BOOL            DhcpValidateOffer(CIpAddr yiaddr, CDhcpOptions * param);
    BOOL            ActiveDhcpAddr();
    BOOL            ActiveAutonetAddr();
    BOOL            ActiveStaticAddr();
    BOOL            ActiveNoAddr();
    NTSTATUS        DhcpParseOptionParams(CDhcpOptions * param, const BYTE* buf, UINT buflen, BYTE* overload);
    DHCPTIME        DhcpTime();

    void            IpXmitDns(CDnsReg * pdnsreg);
    void            IpRecvDns(CPacket * ppkt, CUdpHdr * pUdpHdr, UINT cbLen);
    void            IpDnsTimer(CTimer * pt);
    void            IpDnsSignal(CDnsReg * pdnsreg, INT iStatus);
    void            IpDnsDump(CDnsHdr * pdnshdr, UINT cbDnsMsg);
    BYTE *          IpDnsDumpSection(BYTE * pbBeg, BYTE * pbEnd, BYTE * pb, UINT cSec, char * pszSec);
    void            IpDnsDumpHex(BYTE * pb, UINT cb);

    void            IpRecvUdp(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    void            IpRecvTcp(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbLen);
    void            IpRecvEsp(CPacket * ppkt, CIpHdr * pIpHdr, CEspHdr * pEspHdr, UINT cbLen);
    void            IpRecvKeyEx(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExHdr * pKeyExHdr, UINT cbKeyEx);
    void            IpRecvKeyExXbToXb(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExXbToXb * pKeyExXbToXb, UINT cbKeyEx);
    void            IpRecvKeyExSgToXb(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExSgToXbResp * pKeyExSgToXbResp, UINT cbKeyEx);
    void            IpRecvKeyExNatOpen(CPacket * ppkt, CIpAddr ipaSrc, CIpPort ipportSrc, CKeyExNatOpen * pKeyExNatOpen, UINT cbKeyEx);
    void            IpRecvSecMsg(CPacket * ppkt, CSecReg * pSecReg, DWORD dwSeq, CSecMsgHdr * pSecMsgHdr, UINT cb);

    void            IpXmitKeyEx(CSecReg * pSecReg);
    void            IpXmitKeyExXbToXb(CSecReg * pSecReg, BOOL fInhibitNatOpen = FALSE);
    void            IpFillKeyExXbToXb(CSecReg * pSecReg, CKeyExXbToXb * pKeyExXbToXb);
    void            IpXmitKeyExXbToSg(CSecReg * pSecReg);
    void            IpXmitSecMsg(CSecReg * pSecReg, WORD wType, void * pv1 = NULL, UINT cb1 = 0, void * pv2 = 0, UINT cb2 = 0);
    void            IpXmitSecMsgDelete(CSecReg * pSecReg, DWORD dwReason);
    void            IpXmitSecMsgXbToSgPulse(CSecReg * pSecReg);

    CKeyReg *       KeyRegLookup(const XNKID * pxnkid);

    void            CryptDes(DWORD dwOp, BYTE * pbKey, UINT cbKey, BYTE * pbIv, BYTE * pb, UINT cb);

    CSecReg *       SecRegLookup(const XNADDR * pxna, const XNKID * pxnkid);
    CSecReg *       SecRegLookup(const CIpAddr ipa, DWORD dwServiceId, const XOKERBINFO * pxokerbinfo);
    CSecReg *       SecRegLookup(DWORD dwSpiRecv);
    CSecReg *       SecRegAlloc();
    CSecReg *       SecRegAlloc(const XNADDR * pxna, CKeyReg * pKeyReg);
    CSecReg *       SecRegAlloc(const CIpAddr ipa, DWORD dwServiceId);
    void            SecRegFree(CSecReg * ppSecReg);

    void            SecRegEnqueue(CSecReg * pSecReg, CPacket * ppkt);
    void            SecRegXmitQueue(CSecReg * pSecReg);
    void            SecRegSetIdle(CSecReg * pSecReg);
    void            SecRegSetTicks(CSecReg * pSecReg);
    void            SecRegSetKey(CSecReg * pSecReg, BYTE * pbKeyHmac, UINT cbKeyHmac, BYTE * pbDhX, UINT cbDhX, BYTE * pbDhGY, UINT cbDhGY, BOOL fInitiator);
    void            SecRegTimer(CTimer * pt);
    void            SecRegProbe();

    // Data ------------------------------------------------------------------------------

protected:

#ifdef XNET_FEATURE_DHCP
    CDhcpOptions    _options;
#endif

private:

    LONG            _lNextDgramId;

#ifdef XNET_FEATURE_ROUTE
    LIST_ENTRY      _leRouteList;
    CIpAddr         _ipaDstLast;
    CRouteEntry *   _prteLast;
#endif

#ifdef XNET_FEATURE_FRAG
    CPacketQueue    _pqFrag;
    UINT            _cFrag;
#endif

#ifdef XNET_FEATURE_DHCP
    INT             _state;             // current state of the interface
    INT             _flags;             // misc. flags (see constants below)
    CIpAddr         _activeaddr;        // active IP address
    CIpAddr         _activemask;        // active IP mask
    CIpAddr         _dhcpaddr;          // last DHCP address
    CIpAddr         _autonetaddr;       // last autonet address
    DHCPTIME        _acqtime;           // when lease acquisition started
    DWORD           _xid;               // XID for the next outgoing message
    UINT            _retries;           // number of retries for the current message
    UINT            _initRetryCount;    // how many retries into INIT state
    UINT            _secsSinceStart;    // secs since the address-req process started
    CTimer          _timerDhcp;
    DWORD           _dwXidNext;
#endif

#ifdef XNET_FEATURE_DNS
    CDnsReg *       _pdnsreg;           // Active DNS lookups
#endif

#if defined(XNET_FEATURE_SG) && defined(XNET_FEATURE_INSECURE)
    BYTE            _abDhXNull[CBDHG1]; // Diffie-hellman X for insecure XbToSg
    BYTE            _abDhGXNull[CBDHG1];// Diffie-hellman g^X for insecure XbToSg
    BYTE            _abKeyNull[16];     // Session key for insecure XbToSg
#endif

    BYTE            _abKeyShaLan[16];   // LAN broadcast SHA auth key
    BYTE            _abKeyDesLan[24];   // LAN broadcast DES crypt key (3des)
    CKeyReg *       _pKeyReg;           // Vector of CKeyReg structures
    CSecReg *       _pSecReg;           // Vector of CSecReg structures
    CSecReg *       _pSecRegProbe;      // Next CSecReg to process in SecRegProbeTimer
    WORD            _cKeyReg;           // Number of registered key slots in use
    WORD            _wSecRegUniq;       // Number cycled to generate next secure IP address
    UINT            _cSecRegProbeNumer; // Probe timer numer (cfgSecRegMax per tick)
    UINT            _cSecRegProbeDenom; // Probe timer denom (ticks per CSecReg visit)
    LARGE_INTEGER   _liTime;            // Highest system time sent during key exchange

#ifdef XNET_FEATURE_ONLINE
    CXoBase *       _pXoBase;           // Pointer to CXoBase implemented by the Online code
#endif

#ifdef XNET_FEATURE_SG
    UINT            _uiLogonState;      // One of the XN_LOGON_* states
    CSecReg *       _pSecRegLogon;      // Pointer to CSecReg from IpLogon
    PRKEVENT        _pEventLogon;       // Pointer to cracked WSAEVENT from IpLogon
    XOUSERINFO      _axouserinfo[4];    // Vector of XOUSERINFO
    BYTE            _abXbToSgPulse[4];  // Changes to transmit on next XbToSg pulse
    DWORD           _dwSeqXbToSg;       // Sequence number of latest XbToSg pulse with changes
    DWORD           _dwSeqSgToXb;       // Sequence number to acknowledge in next XbToSg pulse
#endif

};

INLINE BYTE CXnIp::SecRegRexmitRetries(CSecReg * pSecReg)
{
#ifdef XNET_FEATURE_SG
    if (pSecReg->TestFlags(SRF_ONLINESERVER))
    {
        return(cfgKeyExXbToSgRexmitRetries);
    }
#endif

    return(cfgKeyExXbToXbRexmitRetries);
}

INLINE BYTE CXnIp::SecRegRexmitTimeoutInSeconds(CSecReg * pSecReg)
{
#ifdef XNET_FEATURE_SG
    if (pSecReg->TestFlags(SRF_ONLINESERVER))
    {
        return(cfgKeyExXbToSgRexmitTimeoutInSeconds);
    }
#endif

    return(cfgKeyExXbToXbRexmitTimeoutInSeconds);
}

// ---------------------------------------------------------------------------------------
// CSocket
// ---------------------------------------------------------------------------------------

class CRecvReq;
class CRecvBuf;
class CSendReq;
class CSendBuf;

class CSocket
{
    // Definitions -----------------------------------------------------------------------

    #define SOCKF_POOLALLOC             0x00000001      // [ANY] Socket allocated with pool allocator
    #define SOCKF_TCP                   0x00000002      // [ANY] Socket is CTcpSocket
    #define SOCKF_NOMORE_XMIT           0x00000004      // [ANY] No more transmission of data allowed
    #define SOCKF_NOMORE_RECV           0x00000008      // [ANY] No more receiving of data allowed
    #define SOCKF_BOUND                 0x00000010      // [ANY] Socket is bound to a local address
    #define SOCKF_CONNECTED             0x00000020      // [ANY] Socket is connected
    #define SOCKF_REVIVABLE             0x00000040      // [TCP] Socket is revivable
    #define SOCKF_CONNECT_SELECTED      0x00000080      // [TCP] Select has been called for connect event
    #define SOCKF_PERSIST               0x00000100      // [TCP] Socket is persisting
    #define SOCKF_FAST_RETRANSMIT       0x00000200      // [TCP] Socket is in fast retransmit mode
    #define SOCKF_EVENT_READ            0x00000400      // [ANY] FD_READ event
    #define SOCKF_EVENT_WRITE           0x00000800      // [ANY] FD_WRITE event
    #define SOCKF_EVENT_ACCEPT          0x00001000      // [ANY] FD_ACCEPT event
    #define SOCKF_EVENT_CONNECT         0x00002000      // [ANY] FD_CONNECT event
    #define SOCKF_EVENT_CLOSE           0x00004000      // [ANY] FD_CLOSE event
    #define SOCKF_EVENT_RESET           0x00008000      // [ANY] Socket has been reset
    #define SOCKF_OPT_BROADCAST         0x00010000      // [UDP] Broadcast is allowed
    #define SOCKF_OPT_NONBLOCKING       0x00020000      // [ANY] Nonblocking socket
    #define SOCKF_OPT_REUSEADDR         0x00040000      // [ANY] Address reuse is allowed
    #define SOCKF_OPT_EXCLUSIVEADDR     0x00080000      // [ANY] Address reuse prohibited
    #define SOCKF_OPT_NONAGLE           0x00100000      // [TCP] Don't buffer data
    #define SOCKF_OWNED                 0x00200000      // [ANY] Socket belongs to user (socket() & accept())
    #define SOCKF_CLOSED                0x00400000      // [ANY] Socket is closed but not freed yet
    #define SOCKF_LINGERING             0x00800000      // [ANY] Socket is lingering
    #define SOCKF_INSECURE              0x01000000      // [ANY] Socket is insecure

    #define SOCKF_EVENT_MASK            (SOCKF_EVENT_READ|SOCKF_EVENT_WRITE|SOCKF_EVENT_ACCEPT|SOCKF_EVENT_CONNECT|SOCKF_EVENT_CLOSE|SOCKF_EVENT_RESET)
    #define SOCKF_OPT_MASK              (SOCKF_OPT_NONBLOCKING|SOCKF_OPT_BROADCAST|SOCKF_OPT_REUSEADDR|SOCKF_OPT_EXCLUSIVEADDR|SOCKF_OPT_NONAGLE)

    #define SOCK_LOCK_ACTIVE            '+COS'
    #define SOCK_LOCK_BUSY              '*COS'
    #define SOCK_LOCK_CLOSED            '-cos'

    // External --------------------------------------------------------------------------

public:

    INLINE void         Init(CXnBase * pXnBase, BOOL fTcp, BOOL fPoolAlloc);
    INLINE void         Enqueue(LIST_ENTRY * pleHead);
    INLINE void         Dequeue();
    INLINE LIST_ENTRY * GetFlink();
    static CSocket *    Lock(SOCKET s);
    INLINE void         Unlock();
    INLINE void         SetClosed();
    INLINE BOOL         IsLingering();
    INLINE PRKEVENT     GetEvent();
    INLINE void         SignalEvent(DWORD dwFlags);
    INLINE BOOL         TestFlags(DWORD dwFlags);
    INLINE DWORD        GetFlags(DWORD dwMask = 0xFFFFFFFF);
    INLINE void         SetFlags(DWORD dwFlags);
    INLINE void         SetFlags(DWORD dwFlags, DWORD dwMask);
           void         SetFlagsAndOr(DWORD dwAnd, DWORD dwOr);
    INLINE void         ClearFlags(DWORD dwFlags);
    INLINE BOOL         IsTcp();
    INLINE BOOL         IsUdp();
    INLINE const char * TypeStr();
    INLINE BOOL         HasRecvReq();
    INLINE CRecvReq *   GetRecvReq();
    INLINE void         SetRecvReq(CRecvReq * pRecvReq);
    INLINE BOOL         HasRecvBuf();
    INLINE CRecvBuf *   GetRecvBufFirst();
    INLINE CRecvBuf *   GetRecvBufNext(CRecvBuf * pRecvBuf);
    INLINE CRecvBuf *   GetRecvBufLast();
    INLINE CRecvBuf *   GetRecvBufPrev(CRecvBuf * pRecvBuf);
    INLINE CRecvBuf *   DequeueRecvBuf();
    INLINE void         DequeueRecvBuf(CRecvBuf * pRecvBuf);
    INLINE void         EnqueueRecvBuf(CRecvBuf * pRecvBuf);
           void         InsertRecvBuf(CRecvBuf * pRecvBuf, CRecvBuf * pRecvBufPrev);
    INLINE BOOL         IsRecvBufFull();
    INLINE BOOL         IsRecvBufEmpty();
    INLINE BOOL         IsUdpRecvBufEmpty();
    INLINE BOOL         IsTcpRecvBufEmpty();
    INLINE UINT         GetCbRecvBuf();
    INLINE void         SetCbRecvBuf(UINT cb);
    INLINE BOOL         HasSendReq();
    INLINE CSendReq *   GetSendReq();
    INLINE void         SetSendReq(CSendReq * pSendReq);
    INLINE BOOL         HasSendBuf();
    INLINE CSendBuf *   GetSendBufFirst();
    INLINE CSendBuf *   GetSendBufNext(CSendBuf * pSendBuf);
    INLINE CSendBuf *   DequeueSendBuf();
    INLINE void         DequeueSendBuf(CSendBuf * pSendBuf);
    INLINE void         EnqueueSendBuf(CSendBuf * pSendBuf);
    INLINE BOOL         IsSendBufFull();
    INLINE BOOL         IsSendBufEmpty();
    INLINE UINT         GetCbSendBuf();
    INLINE void         SetCbSendBuf(UINT cb);
    INLINE UINT         IncCbSendBuf(UINT cb);
    INLINE UINT         DecCbSendBuf(UINT cb);
    INLINE NTSTATUS     GetStatus();
    INLINE void         SetStatus(NTSTATUS status);

    // Data ------------------------------------------------------------------------------

private:

    LIST_ENTRY          _le;
    LONG                _lLock;
    DWORD               _dwFlags;
    KEVENT              _Event;
    CRecvReq *          _pRecvReq;
    LIST_ENTRY          _leRecvBufs;
    UINT                _cbRecvBuf;
    CSendReq *          _pSendReq;
    LIST_ENTRY          _leSendBufs;
    UINT                _cbSendBuf;
    NTSTATUS            _status;

public:

    CIpAddr             _ipaDst;
    CIpPort             _ipportDst;
    CIpPort             _ipportSrc;
    CRouteEntry *       _prte;
    UINT                _uiSendTimeout;
    UINT                _uiRecvTimeout;
    UINT                _cbMaxSendBuf;
    UINT                _cbMaxRecvBuf;

#ifdef XNET_FEATURE_ASSERT
private:
    CXnBase *           _pXnBase;
public:
    INLINE CXnBase *    GetXnBase() { return(_pXnBase); }
#endif

};

// ---------------------------------------------------------------------------------------
// CSockReq
// ---------------------------------------------------------------------------------------

class CSockReq
{
    // Definitions -----------------------------------------------------------------------

    // We use the WSAOVERLAPPED structure to keep track of the status of an overlapped I/O
    // request. When the request is pending, the fields are interpreted as follows:
    //      Internal     - pointer to the I/O request structure
    //      InternalHigh - unused
    //      Offset       - unused
    //      OffsetHigh   - status code = NETERR_PENDING
    // After a request is completed, the fields are interpreted differently:
    //      Internal     - unused
    //      InternalHigh - I/O request completion flags
    //      Offset       - number of bytes actually transferred
    //      OffsetHigh   - status code != NETERR_PENDING

    #define _ioreq      Internal
    #define _ioflags    InternalHigh
    #define _ioxfercnt  Offset
    #define _iostatus   OffsetHigh

    // Data ------------------------------------------------------------------------------

public:

    PRKEVENT            _pEvent;
    WSAOVERLAPPED *     _pWsaOverlapped;

};

// ---------------------------------------------------------------------------------------
// CRecvReq
// ---------------------------------------------------------------------------------------

class CRecvReq : public CSockReq
{

    // External --------------------------------------------------------------------------

public:

    INLINE void SetFromAddrPort(CIpAddr ipa, CIpPort ipport)
    {
        if (fromaddr)
        {
            fromaddr->sin_addr.s_addr = ipa;
            fromaddr->sin_port = ipport;
        }
    }

    INLINE UINT GetCbBuf()
    {
        return(buflen);
    }

    INLINE BYTE * GetPbBuf()
    {
        return(buf);
    }

    // Data ------------------------------------------------------------------------------

public:

    DWORD               flags;
    DWORD *             bytesRecv;
    BYTE *              buf;
    UINT                buflen;
    struct sockaddr_in* fromaddr;

};

// ---------------------------------------------------------------------------------------
// CRecvBuf
// ---------------------------------------------------------------------------------------

class CRecvBuf
{
    friend class CSocket;

    // External --------------------------------------------------------------------------

public:

    INLINE void         Init(CXnBase * pXnBase);
    INLINE UINT         GetCbBuf();
    INLINE void         SetCbBuf(UINT cb);
    INLINE UINT         IncCbBuf(UINT cb);
    INLINE UINT         DecCbBuf(UINT cb);

    // Data ------------------------------------------------------------------------------

private:

    LIST_ENTRY          _le;
    UINT                _cbBuf;

#ifdef XNET_FEATURE_ASSERT
    CXnBase *           _pXnBase;
public:
    INLINE CXnBase *    GetXnBase() { return(_pXnBase); }
#endif

};

INLINE void CRecvBuf::Init(CXnBase * pXnBase)
{
    ICHECK_(pXnBase, SOCK, USER|UDPC|SDPC);
#ifdef XNET_FEATURE_ASSERT
    _pXnBase = pXnBase;
#endif
}

INLINE UINT CRecvBuf::GetCbBuf()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_cbBuf);
}

INLINE void CRecvBuf::SetCbBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _cbBuf = cb;
}

INLINE UINT CRecvBuf::IncCbBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbBuf += cb);
}

INLINE UINT CRecvBuf::DecCbBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbBuf -= cb);
}

// ---------------------------------------------------------------------------------------
// CUdpRecvBuf
// ---------------------------------------------------------------------------------------

class CUdpRecvBuf : public CRecvBuf
{

    // Data ------------------------------------------------------------------------------

public:

    CIpAddr             fromaddr;
    CIpPort             fromport;
};

// ---------------------------------------------------------------------------------------
// CTcpRecvBuf
// ---------------------------------------------------------------------------------------

class CTcpRecvBuf : public CRecvBuf
{

    // Data ------------------------------------------------------------------------------

public:

    TCPSEQ              seqnext;
    WORD                dataoffset;
    BYTE                tcpflags;

};

// ---------------------------------------------------------------------------------------
// CSendReq
// ---------------------------------------------------------------------------------------

class CSendReq : public CSockReq
{

    // Data ------------------------------------------------------------------------------

public:

    WSABUF *            bufs;
    UINT                bufcnt;
    UINT                sendtotal;
    struct sockaddr_in* toaddr;

};

// ---------------------------------------------------------------------------------------
// CSendBuf
// ---------------------------------------------------------------------------------------

class CSendBuf : public CPacket
{
    friend class CSocket;

    // External --------------------------------------------------------------------------

public:

    INLINE void         Init(CSocket * pSocket, UINT cbData, UINT cRefs);
    INLINE void         AddRef();
    INLINE LONG         Release();
    INLINE BOOL         IsActive();
    INLINE UINT         GetCbBuf();
    INLINE void         SetCbBuf(UINT cb);
    INLINE UINT         DecCbBuf(UINT cb);
    INLINE CSocket *    GetSocket();

#ifdef XNET_FEATURE_ASSERT
    INLINE CXnBase *    GetXnBase()     { return(_pSocket->GetXnBase()); }
#endif

    // Data ------------------------------------------------------------------------------

private:

    LIST_ENTRY          _le;
    CSocket *           _pSocket;
    UINT                _cbBuf;
    LONG                _cRefs;

};

INLINE void CSendBuf::Init(CSocket * pSocket, UINT cbBuf, UINT cRefs)
{
    ICHECK_(pSocket->GetXnBase(), SOCK, USER|UDPC|SDPC);
    _pSocket    = pSocket;
    _cbBuf      = cbBuf;
    _cRefs      = cRefs;
}

INLINE void CSendBuf::AddRef()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _cRefs += 1;
}

INLINE LONG CSendBuf::Release()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(--_cRefs);
}

INLINE BOOL CSendBuf::IsActive()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cRefs > 1);
}

INLINE UINT CSendBuf::GetCbBuf()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbBuf);
}

INLINE void CSendBuf::SetCbBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _cbBuf = cb;
}

INLINE UINT CSendBuf::DecCbBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _cbBuf -= cb;
}

INLINE CSocket * CSendBuf::GetSocket()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pSocket);
}

// ---------------------------------------------------------------------------------------
// CTcpSendBuf
// ---------------------------------------------------------------------------------------

class CTcpSendBuf : public CSendBuf
{

    // Data ------------------------------------------------------------------------------

public:

    TCPSEQ              seq;            // starting sequence number for this TCP segment
    TCPSEQ              seqnext;        // the first seqno after this segment
    WORD                retries;        // number of times this segment has been rexmitted
    BYTE                tcpflags;       // TCP segment flags
    BYTE                tcphdrlen;      // TCP segment header length
    UINT                firstSendTime;  // the time this segment was first sent

};

// ---------------------------------------------------------------------------------------
// CSocket Inlines
// ---------------------------------------------------------------------------------------

INLINE void CSocket::Init(CXnBase * pXnBase, BOOL fTcp, BOOL fPoolAlloc)
{
    ICHECK_(pXnBase, SOCK, USER|UDPC|SDPC);

#ifdef XNET_FEATURE_ASSERT
    _pXnBase        = pXnBase;
#endif

    _lLock          = SOCK_LOCK_ACTIVE;
    _dwFlags        = (fPoolAlloc ? SOCKF_POOLALLOC : 0) | (fTcp ? SOCKF_TCP : 0);
    _cbMaxSendBuf   = pXnBase->cfgSockDefaultSendBufsizeInK * 1024;
    _cbMaxRecvBuf   = pXnBase->cfgSockDefaultRecvBufsizeInK * 1024;

    InitializeListHead(&_le);
    InitializeListHead(&_leRecvBufs);
    InitializeListHead(&_leSendBufs);
    EvtInit(EvtRef(_Event));
}

INLINE void CSocket::Enqueue(LIST_ENTRY * pleHead)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(!IsListNull(&_le));
    AssertList(pleHead);
    InsertTailList(pleHead, &_le);
}

INLINE void CSocket::Dequeue()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(!IsListNull(&_le));
    RemoveEntryList(&_le);
}

INLINE void CSocket::Unlock()
{
    ICHECK_(GetXnBase(), SOCK, USER);
    Assert(_lLock == SOCK_LOCK_BUSY);
    _lLock = SOCK_LOCK_ACTIVE;
}

INLINE void CSocket::SetClosed()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _lLock = SOCK_LOCK_CLOSED;
}

INLINE BOOL CSocket::IsLingering()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(TestFlags(SOCKF_LINGERING));
}

INLINE PRKEVENT CSocket::GetEvent()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(EvtRef(_Event));
}

INLINE void CSocket::SignalEvent(DWORD dwFlags)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);

    if (TestFlags(dwFlags))
    {
        EvtSet(EvtRef(_Event), EVENT_INCREMENT);
    }
}

INLINE DWORD CSocket::GetFlags(DWORD dwMask)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_dwFlags & dwMask);
}

INLINE void CSocket::SetFlags(DWORD dwFlags)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    SetFlagsAndOr(0xFFFFFFFF, dwFlags);
}

INLINE void CSocket::SetFlags(DWORD dwFlags, DWORD dwMask)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    SetFlagsAndOr(~dwMask, dwFlags & dwMask);
}

INLINE void CSocket::ClearFlags(DWORD dwFlags)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    SetFlagsAndOr(~dwFlags, 0);
}

INLINE BOOL CSocket::TestFlags(DWORD dwFlags)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(!!(_dwFlags & dwFlags));
}

INLINE BOOL CSocket::IsTcp()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(TestFlags(SOCKF_TCP));
}

INLINE BOOL CSocket::IsUdp()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(!IsTcp());
}

INLINE const char * CSocket::TypeStr()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(IsUdp() ? "UDP" : "TCP");
}

INLINE BOOL CSocket::HasRecvReq()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pRecvReq != NULL);
}

INLINE CRecvReq * CSocket::GetRecvReq()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pRecvReq);
}

INLINE void CSocket::SetRecvReq(CRecvReq * pRecvReq)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _pRecvReq = pRecvReq;
}

INLINE BOOL CSocket::HasRecvBuf()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(!IsListEmpty(&_leRecvBufs));
}

INLINE CRecvBuf * CSocket::GetRecvBufNext(CRecvBuf * pRecvBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);

    if (pRecvBuf == NULL)
        pRecvBuf = (CRecvBuf *)_leRecvBufs.Flink;
    else
        pRecvBuf = (CRecvBuf *)pRecvBuf->_le.Flink;

    return(pRecvBuf == (CRecvBuf *)&_leRecvBufs ? NULL : pRecvBuf);
}

INLINE CRecvBuf * CSocket::GetRecvBufFirst()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(GetRecvBufNext(NULL));
}

INLINE CRecvBuf * CSocket::GetRecvBufPrev(CRecvBuf * pRecvBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(offsetof(CRecvBuf, _le) == 0);

    if (pRecvBuf == NULL)
        pRecvBuf = (CRecvBuf *)_leRecvBufs.Blink;
    else
        pRecvBuf = (CRecvBuf *)pRecvBuf->_le.Blink;

    return(pRecvBuf == (CRecvBuf *)&_leRecvBufs ? NULL : pRecvBuf);
}

INLINE CRecvBuf * CSocket::GetRecvBufLast()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(GetRecvBufPrev(NULL));
}

INLINE CRecvBuf * CSocket::DequeueRecvBuf()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(!IsListEmpty(&_leRecvBufs));
    Assert(offsetof(CRecvBuf, _le) == 0);
    CRecvBuf * pRecvBuf = (CRecvBuf *)RemoveHeadList(&_leRecvBufs);
    return(pRecvBuf);
}

INLINE void CSocket::DequeueRecvBuf(CRecvBuf * pRecvBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(!IsListEmpty(&_leRecvBufs));
    AssertListEntry(&_leRecvBufs, &pRecvBuf->_le);
    RemoveEntryList(&pRecvBuf->_le);
}

INLINE void CSocket::EnqueueRecvBuf(CRecvBuf * pRecvBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(pRecvBuf != NULL);
    AssertList(&_leRecvBufs);
    InsertTailList(&_leRecvBufs, &pRecvBuf->_le);
}

INLINE BOOL CSocket::IsRecvBufFull()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbRecvBuf >= _cbMaxRecvBuf);
}

INLINE BOOL CSocket::IsUdpRecvBufEmpty()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    Assert(IsUdp());
    return(IsListEmpty(&_leRecvBufs));
}

INLINE BOOL CSocket::IsTcpRecvBufEmpty()
{ 
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    Assert(IsTcp());
    return(_cbRecvBuf == 0);
}

INLINE BOOL CSocket::IsRecvBufEmpty()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(IsUdp() ? IsUdpRecvBufEmpty() : IsTcpRecvBufEmpty());
}

INLINE UINT CSocket::GetCbRecvBuf()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbRecvBuf);
}

INLINE void CSocket::SetCbRecvBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _cbRecvBuf = cb;
}

INLINE BOOL CSocket::HasSendReq()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_pSendReq != NULL);
}

INLINE CSendReq * CSocket::GetSendReq()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pSendReq);
}

INLINE void CSocket::SetSendReq(CSendReq * pSendReq)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _pSendReq = pSendReq;
}

INLINE BOOL CSocket::HasSendBuf()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(!IsListEmpty(&_leSendBufs));
}

INLINE CSendBuf * CSocket::GetSendBufNext(CSendBuf * pSendBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    LIST_ENTRY * ple = (pSendBuf == NULL) ? _leSendBufs.Flink : pSendBuf->_le.Flink;
    return(ple == &_leSendBufs ? NULL : (CSendBuf *)((BYTE *)ple - offsetof(CSendBuf, _le)));
}

INLINE CSendBuf * CSocket::GetSendBufFirst()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(GetSendBufNext(NULL));
}

INLINE CSendBuf * CSocket::DequeueSendBuf()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(!IsListEmpty(&_leSendBufs));
    AssertList(&_leSendBufs);
    LIST_ENTRY * ple = RemoveHeadList(&_leSendBufs);
    return((CSendBuf *)((BYTE *)ple - offsetof(CSendBuf, _le)));
}

INLINE void CSocket::DequeueSendBuf(CSendBuf * pSendBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(!IsListEmpty(&_leSendBufs));
    AssertListEntry(&_leSendBufs, &pSendBuf->_le);
    RemoveEntryList(&pSendBuf->_le);
}

INLINE void CSocket::EnqueueSendBuf(CSendBuf * pSendBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(pSendBuf != NULL);
    AssertList(&_leSendBufs);
    InsertTailList(&_leSendBufs, &pSendBuf->_le);
}

INLINE BOOL CSocket::IsSendBufFull()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_cbSendBuf >= _cbMaxSendBuf);
}

INLINE BOOL CSocket::IsSendBufEmpty()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(IsListEmpty(&_leSendBufs));
}

INLINE UINT CSocket::GetCbSendBuf()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_cbSendBuf);
}

INLINE void CSocket::SetCbSendBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _cbSendBuf = cb;
}

INLINE UINT CSocket::IncCbSendBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbSendBuf += cb);
}

INLINE UINT CSocket::DecCbSendBuf(UINT cb)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_cbSendBuf -= cb);
}

INLINE NTSTATUS CSocket::GetStatus()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_status);
}

INLINE void CSocket::SetStatus(NTSTATUS status)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _status = status;
}

INLINE LIST_ENTRY * CSocket::GetFlink()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_le.Flink);
}

// ---------------------------------------------------------------------------------------
// CTcpSocket
// ---------------------------------------------------------------------------------------

class CTcpSocket : public CSocket
{
    // Definitions -----------------------------------------------------------------------

    #define TCPST_CLOSED            0
    #define TCPST_LISTEN            1
    #define TCPST_SYN_SENT          2
    #define TCPST_SYN_RECEIVED      3
    #define TCPST_ESTABLISHED       4
    #define TCPST_FIN_WAIT_1        5
    #define TCPST_FIN_WAIT_2        6
    #define TCPST_CLOSING           7
    #define TCPST_TIME_WAIT         8
    #define TCPST_CLOSE_WAIT        9
    #define TCPST_LAST_ACK          10
    #define TCPST_MAX               TCPST_LAST_ACK

    #define UDP_DEFAULT_MSS         ESP_MSS(576, sizeof(CUdpHdr))
    #define UDP_MAXIMUM_MSS         ESP_MSS(ENET_DATA_MAXSIZE, sizeof(CUdpHdr))

    #define TCP_MINIMUM_MSS         (MAXIPHDRLEN+MAXTCPHDRLEN+8-sizeof(CIpHdr)-sizeof(CTcpHdr))
    #define TCP_DEFAULT_MSS         ESP_MSS(576, sizeof(CTcpHdr))
    #define TCP_MAXIMUM_MSS         ESP_MSS(ENET_DATA_MAXSIZE, sizeof(CTcpHdr))
    #define MAX_TCP_WNDSIZE         0xFFFF

    #define MIN_TEMP_PORT           1024
    #define MAX_TEMP_PORT           4998
    #define TEMP_PORT_COUNT         (MAX_TEMP_PORT-MIN_TEMP_PORT+1)

    #define SEQ_LT(a, b)            ((INT) ((a) - (b)) < 0)
    #define SEQ_LE(a, b)            ((INT) ((a) - (b)) <= 0)
    #define SEQ_GT(a, b)            ((INT) ((a) - (b)) > 0)
    #define SEQ_GE(a, b)            ((INT) ((a) - (b)) >= 0)

    #define SRTT_SHIFT              3
    #define SRTT_SCALE              (1 << SRTT_SHIFT)
    #define RTTVAR_SHIFT            2
    #define RTTVAR_SCALE            (1 << RTTVAR_SHIFT)

    // External --------------------------------------------------------------------------

public:

    INLINE void                 TcpInit(CXnBase * pXnBase);
    INLINE static CTcpSocket *  TimerToSocket(CTimer * pt);
    INLINE BOOL                 HasParent();
    INLINE CTcpSocket *         GetParent();
    INLINE BOOL                 IsChild();
           void                 EnqueueChild(CTcpSocket * pTcpSocketChild);
           void                 DequeueChild(CTcpSocket * pTcpSocketChild);
    INLINE CTcpSocket *         GetNextChild(CTcpSocket * pTcpSocketPrev);
    INLINE CTcpSocket *         GetFirstChild();
    INLINE CTcpSocket *         GetPrevChild(CTcpSocket * pTcpSocketNext);
    INLINE CTcpSocket *         GetLastChild();
    INLINE BOOL                 HasConnectedChild();
           CTcpSocket *         GetConnectedChild();
           CTcpSocket *         DequeueConnectedChild();
    INLINE UINT                 GetBacklog();
    INLINE UINT                 GetBacklogMax();
    INLINE void                 SetBacklogMax(UINT cBacklogMax);
    INLINE UINT                 IncDupAcks();
    INLINE void                 SetDupAcks(UINT cDupAcks);
    INLINE UINT                 GetState();
    INLINE void                 SetState(UINT uiState);
    INLINE BOOL                 IsIdleState();
    INLINE BOOL                 IsListenState();
    INLINE BOOL                 IsSyncState();
    INLINE BOOL                 IsFinReceived();
    INLINE BOOL                 IsFinSent();
    INLINE void                 IncrementCongestionWindow(UINT uiIncr);
    INLINE void                 ResetSlowStartThresh();
    INLINE void                 GetLinger(LINGER * pLinger);
    INLINE void                 SetLinger(LINGER * pLinger);
    INLINE BOOL                 GetLingerOnOff();
    INLINE void                 SetLingerOnOff(BOOL fOn);
    INLINE UINT                 GetLingerTimeout();
    INLINE CTimer *             GetTimer();
    INLINE CTcpSendBuf *        GetSendBufPtr();
    INLINE void                 SetSendBufPtr(CTcpSendBuf * pTcpSendBuf);

    // Data ------------------------------------------------------------------------------

private:

    CTcpSocket *            _pTcpSocketParent;
    LIST_ENTRY              _le;
    CTimer                  _timer;
    BYTE                    _bState;
    BYTE                    _bBacklog;
    BYTE                    _bBacklogMax;
    BYTE                    _bDupAcks;
    LINGER                  _Linger;
    CTcpSendBuf *           _pTcpSendBufPtr;

public:

    //
    // TCP timers
    //  delayedAcks is the number of delay-acked segments;
    //
    // NOTE: Be careful when you add or remove fields between
    // delayedAcks and rtt_tick (inclusive). See comments in
    // function TcpReset().
    //
    UINT delayedAcks;
    UINT dwTickSyn;        // connection establishment timer
    UINT dwTickXmit;       // retransmission & persist timer
    UINT dwTickWait;       // TIME-WAIT & linger timer

    //
    // Send/receive state information
    //
    TCPSEQ snd_isn;         // initial send sequence number
    TCPSEQ snd_una;         // sent but not yet acknowledged
    TCPSEQ snd_nxt;         // buffered but not yet sent
    TCPSEQ snd_end;         // not yet buffered
    TCPSEQ snd_wl1;         // seq and ack numbers of the last ACK 
    TCPSEQ snd_wl2;         // that was used to update snd_wnd
    UINT snd_wnd;           // send window
    UINT snd_cwnd;          // congestion window
    UINT snd_ssthresh;      // slow-start threshold
    UINT snd_mss;           // send MSS
    TCPSEQ rcv_isn;         // initial receive sequence number
    TCPSEQ rcv_nxt;         // next expected receive sequence number
    UINT rcv_wnd;           // receive window
    UINT rcv_mss;           // receive MSS
    UINT rcv_swsthresh;     // receive SWS avoidance threshold

    //
    // Round-trip time measurements
    //
    INT srtt_8;             // smoothed round-trip time, in 1/8 ticks
    INT rttvar_4;           // round-trip time variance, in 1/4 ticks
    UINT RTO;               // retransmission timeout, in ticks
    TCPSEQ rtt_seq;         // the seqno of the segment being timed
    UINT rtt_tick;          // when the timed segment was sent

};

INLINE CTcpSocket * CTcpSocket::TimerToSocket(CTimer * pt)
{
    return((CTcpSocket *)((BYTE *)pt - offsetof(CTcpSocket, _timer)));
}

INLINE BOOL CTcpSocket::HasParent()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pTcpSocketParent != NULL);
}

INLINE CTcpSocket * CTcpSocket::GetParent()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(_pTcpSocketParent != NULL);
    return(_pTcpSocketParent);
}

INLINE BOOL CTcpSocket::IsChild()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pTcpSocketParent != NULL);
}

INLINE CTcpSocket * CTcpSocket::GetNextChild(CTcpSocket * pTcpSocketPrev)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    LIST_ENTRY * ple = pTcpSocketPrev ? pTcpSocketPrev->_le.Flink : _le.Flink;
    return(ple == &_le ? NULL : (CTcpSocket *)((BYTE *)ple - offsetof(CTcpSocket, _le)));
}

INLINE CTcpSocket * CTcpSocket::GetFirstChild()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(GetNextChild(NULL));
}
    
INLINE CTcpSocket * CTcpSocket::GetPrevChild(CTcpSocket * pTcpSocketNext)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    LIST_ENTRY * ple = pTcpSocketNext ? pTcpSocketNext->_le.Blink : _le.Blink;
    return(ple == &_le ? NULL : (CTcpSocket *)((BYTE *)ple - offsetof(CTcpSocket, _le)));
}

INLINE CTcpSocket * CTcpSocket::GetLastChild()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(GetPrevChild(NULL));
}

INLINE BOOL CTcpSocket::HasConnectedChild()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(GetConnectedChild() != NULL);
}

INLINE UINT CTcpSocket::GetBacklog()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_bBacklog);
}

INLINE UINT CTcpSocket::GetBacklogMax()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_bBacklogMax);
}

INLINE void CTcpSocket::SetBacklogMax(UINT cBacklogMax)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _bBacklogMax = (BYTE)cBacklogMax;
}

INLINE UINT CTcpSocket::IncDupAcks()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(++_bDupAcks);
}

INLINE void CTcpSocket::SetDupAcks(UINT cDupAcks)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(cDupAcks <= 255);
    _bDupAcks = (BYTE)cDupAcks;
}

INLINE UINT CTcpSocket::GetState()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_bState);
}

INLINE void CTcpSocket::SetState(UINT uiState)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    Assert(uiState <= TCPST_MAX);
    _bState = (BYTE)uiState;
}

INLINE BOOL CTcpSocket::IsIdleState()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    // CLOSED or LISTEN
    return(_bState <= TCPST_LISTEN);
}

INLINE BOOL CTcpSocket::IsListenState()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(_bState == TCPST_LISTEN);
}

INLINE BOOL CTcpSocket::IsSyncState()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    // ESTABLISHED, FIN_WAIT_1, FIN_WAIT_2, CLOSING, TIME_WAIT, CLOSE_WAIT, LAST_ACK
    return(_bState >= TCPST_ESTABLISHED);
}

INLINE BOOL CTcpSocket::IsFinReceived()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    // CLOSING, TIME_WAIT, CLOSE_WAIT, LAST_ACK
    return(_bState >= TCPST_CLOSING);
}

INLINE BOOL CTcpSocket::IsFinSent()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    // FIN_WAIT_1, FIND_WAIT_2, CLOSING, TIME_WAIT, LAST_ACK
    return(_bState >= TCPST_FIN_WAIT_1 && _bState != TCPST_CLOSE_WAIT);
}

INLINE void CTcpSocket::IncrementCongestionWindow(UINT uiIncr)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    snd_cwnd += uiIncr;
    if (snd_cwnd > MAX_TCP_WNDSIZE)
        snd_cwnd = MAX_TCP_WNDSIZE;
}

INLINE void CTcpSocket::ResetSlowStartThresh()
{
    snd_ssthresh = (snd_nxt - snd_una) >> 1;
    if (snd_ssthresh < 2*snd_mss)
        snd_ssthresh = 2*snd_mss;
}

INLINE void CTcpSocket::GetLinger(LINGER * pLinger)
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    *pLinger = _Linger;
}

INLINE void CTcpSocket::SetLinger(LINGER * pLinger)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _Linger = *pLinger;
}

INLINE BOOL CTcpSocket::GetLingerOnOff()
{
    ICHECK_(GetXnBase(), SOCK, USER|UDPC|SDPC);
    return(!!_Linger.l_onoff);
}

INLINE void CTcpSocket::SetLingerOnOff(BOOL fOn)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _Linger.l_onoff = !!fOn;
}

INLINE UINT CTcpSocket::GetLingerTimeout()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_Linger.l_linger);
}

INLINE CTimer * CTcpSocket::GetTimer()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(&_timer);
}

INLINE CTcpSendBuf * CTcpSocket::GetSendBufPtr()
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    return(_pTcpSendBufPtr);
}

INLINE void CTcpSocket::SetSendBufPtr(CTcpSendBuf * pTcpSendBuf)
{
    ICHECK_(GetXnBase(), SOCK, UDPC|SDPC);
    _pTcpSendBufPtr = pTcpSendBuf;
}

//
// Socket address length
//
#define SOCKADDRLEN ((INT) sizeof(SOCKADDR_IN))

//------------------------------------------------------------------------
// Prolog and epilog code for Winsock API functions
//------------------------------------------------------------------------

#if DBG

ExternTag(sock);

#define WinsockApiProlog_(_apiname, _result) \
        static const CHAR* fname_ = #_apiname; \
        INT err = (!this || SockGetRefs() <= 0) ? WSANOTINITIALISED : NO_ERROR; \
        WinsockApiCheckError_(_result) \
        TCHECK(USER); \

#define WinsockApiPrologLight_(_apiname) \
        static const CHAR* fname_ = #_apiname; \
        TCHECK(USER); \

#define WinsockApiPrologTrivial_(_apiname) \
        static const CHAR* fname_ = #_apiname; \

#define WinsockApiWarnError_(_err) { \
            if ((_err) != WSA_IO_PENDING && \
                (_err) != WSA_IO_INCOMPLETE && \
                (_err) != WSAETIMEDOUT && \
                (_err) != WSAEWOULDBLOCK) { \
                TraceSz2(Warning, "%s failed: %d", fname_, _err); \
            } \
        }

#define WinsockApiParamCheck_(_exp) { \
            if (!(_exp)) { \
                TraceSz2(Warning, "%s: %s", fname_, #_exp); \
                Rip("bad winsock parameters\n"); \
            } \
        }

#else // !DBG

#define WinsockApiProlog_(_apiname, _result) \
        INT err = (!this || SockGetRefs() <= 0) ? WSANOTINITIALISED : NO_ERROR; \
        WinsockApiCheckError_(_result) \
        TCHECK(USER); \

#define WinsockApiPrologLight_(_apiname)
#define WinsockApiPrologTrivial_(_apiname)
#define WinsockApiWarnError_(_err)
#define WinsockApiParamCheck_(_exp)

#endif // !DBG

#define WinsockApiReturnError_(_err, _result) { \
            WinsockApiWarnError_(_err); \
            SetLastError(_err); \
            return (_result); \
        }

#define WinsockApiCheckError_(_result) { \
            if (err != NO_ERROR) { \
                WinsockApiReturnError_(err, _result); \
            } \
        }

#define WinsockApiPrologSockLock_(_apiname, _result) \
        WinsockApiProlog_(_apiname, _result); \
        CSocket * pSocket = CSocket::Lock(s); \
        if (!pSocket) return (_result)

#define WinsockApiExitSockUnlock_(_resultOk, _resultErr) \
        exit: pSocket->Unlock(); \
        WinsockApiCheckError_(_resultErr); \
        return (_resultOk)

#define WinsockApiGotoExit_(_err) \
        { err = (_err); goto exit; }

#define MapNtStatusToWinsockError_(_err) \
        ((_err) = NT_SUCCESS(_err) ? NO_ERROR : RtlNtStatusToDosError(_err))

#define XNetInitCheck(_fname, _err) \
    if (this == NULL) \
    { \
        TraceSz1(Warning, "%s: You must call XNetStartup or WSAStartup before calling this function.", #_fname); \
        return(_err); \
    } \

#ifdef XNET_FEATURE_ASSERT
    #define XNetParamCheck(_fname, _pcheck, _err) \
        if (!(_pcheck)) \
        { \
            TraceSz2(Warning, "%s: %s", #_fname, #_pcheck); \
            Rip("bad XNet parameters\n"); \
            return(_err); \
        }
    #define XNetEnter(_fname, _pcheck) \
        const char * __pszFName__ = #_fname; \
        XNetInitCheck(_fname, WSANOTINITIALISED); \
        XNetParamCheck(_fname, _pcheck, WSAEFAULT)
    #define XNetLeave(_err) \
        if ((_err) != 0) { TraceSz2(Warning, "%s failed: %d", __pszFName__, (_err)); }
#else
    #define XNetParamCheck(_fname, _pcheck, _err)
    #define XNetEnter(fname, pcheck) XNetInitCheck(fname, WSANOTINITIALISED) 
    #define XNetLeave(_err)
#endif

//
// Stop TCP fast retransmit/recovery mode
//
INLINE VOID TcpStopFastRexmitMode(CTcpSocket* pTcpSocket) {
    pTcpSocket->ClearFlags(SOCKF_FAST_RETRANSMIT);
    pTcpSocket->SetDupAcks(0);
}

// ---------------------------------------------------------------------------------------
// CXnSock
// ---------------------------------------------------------------------------------------

class NOVTABLE CXnSock : public CXnIp
{
    friend void CTcpSocket::TcpInit(CXnBase * pXnBase);
    friend void CXnIp::UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    friend void CXnIp::TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen);
    friend void CXnIp::SockReset(CIpAddr ipa);

    // Definitions -----------------------------------------------------------------------

    //
    // Information about sockets that was passed to the select calls
    //
    typedef struct _SELECTINFO {
        SOCKET s;
        fd_set* fdset;
        INT eventMasks;
        CSocket* pSocket;
        INT pSocketMasks;
    } SELECTINFO;

    // External --------------------------------------------------------------------------

public:

    HAL_DECLARE_NEW_DELETE(CXnSock)

    NTSTATUS            SockInit(XNetInitParams * pxnip);
    void                SockStart()     { IpStart(); }
    void                SockStop()      { IpStop(); }
    void                SockTerm();

    LONG                XNetGetRefs()   { return(_cRefs); }
    LONG                XNetAddRef()    { return(++_cRefs); }
    LONG                XNetRelease()   { return(--_cRefs); }

    LONG                SockGetRefs()   { return(_cRefsSock); }
    LONG                SockAddRef()    { return(++_cRefsSock); }
    LONG                SockRelease()   { return(--_cRefsSock); }
    void                SockShutdown();

    #undef  XNETAPI
    #define XNETAPI(ret, fname, arglist, paramlist) ret fname arglist;
    #undef  XNETAPI_
    #define XNETAPI_(ret, fname, arglist, paramlist)
    #undef  XNETAPIV
    #define XNETAPIV(ret, fname, arglist, paramlist)

    SOCKAPILIST()

    // Internal --------------------------------------------------------------------------

private:

    VIRTUAL void        UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen);
    VIRTUAL void        TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen);
    VIRTUAL void        SockReset(CIpAddr ipa);

    INLINE CSocket *    GetFirstSocket();
    INLINE CSocket *    GetNextSocket(CSocket * pSocketPrev);
    CSocket *           SockAlloc(BOOL fTcp, BOOL fPoolAlloc);
    NTSTATUS            SockClose(CSocket * pSocket, BOOL fForce);
    void                SockCleanup(CSocket * pSocket);
    void                SockFree(CSocket * pSocket);
    CSocket *           SockFindMatch(CIpPort toport, CIpAddr fromaddr, CIpPort fromport, BYTE type);
    NTSTATUS            SockUpdateBufferSize(CSocket* pSocket, INT sendBufsize, INT recvBufsize);
    NTSTATUS            SockBind(CSocket* pSocket, CIpPort ipportBind);
    NTSTATUS            SockWaitForEvent(CSocket* pSocket, INT eventMask, UINT timeout);
    INT                 SockCheckSelectEvents(CSocket * pSocket, INT eventMasks, INT setwait);
    void                SockReqComplete(CSocket * pSocket, CSockReq * pSockReq, NTSTATUS status);
    NTSTATUS            RecvReqEnqueue(CSocket * pSocket, CRecvReq * pRecvReq);
    NTSTATUS            SockQueueOverlappedSend(CSocket * pSocket, CSendReq * sendreq);
    NTSTATUS            SockRead(CSocket * pSocket, CRecvReq * recvreq);
    INT                 SockLockSelectSockets(fd_set* fdset, SELECTINFO* selinfo, INT offset, INT eventMasks);
    NTSTATUS            SockSend(CSocket* pSocket, CSendReq* sendreq);
    void                SockInsertToList(CSocket * pSocket);
    void                SockReleaseSendBuf(CSendBuf * pSendBuf);
    void                SockFlushRecvBuffers(CSocket* pSocket);
    VOID                TcpDisassociateChild(CTcpSocket * childTcp);
    VOID                TcpTrimBacklog(CTcpSocket* pTcpSocket, UINT cBacklogMax);
    BOOL                TcpClose(CTcpSocket* pTcpSocket, BOOL forceful);
    NTSTATUS            TcpShutdown(CTcpSocket* pTcpSocket, DWORD dwFlags, BOOL apicall);
    CTcpSocket *        TcpReset(CTcpSocket* pTcpSocket, NTSTATUS status);
    CTcpSocket *        TcpCloneChild(CTcpSocket * pTcpSocket);
    NTSTATUS            TcpListen(CTcpSocket* pTcpSocket, INT backlog);
    NTSTATUS            TcpConnect(CTcpSocket* pTcpSocket, CIpAddr dstaddr, CIpPort dstport, BOOL synAck);
    void                TcpSetState(CTcpSocket* pTcpSocket, BYTE state, const CHAR* caller);
    void                TcpSlideRecvWindow(CTcpSocket* pTcpSocket, UINT datalen);
    UINT                TcpCopyRecvData(CTcpSocket* pTcpSocket, CRecvReq* recvreq);
    NTSTATUS            TcpRead(CTcpSocket* pTcpSocket, CRecvReq* recvreq);
    void                TcpUpdateRTO(CTcpSocket* pTcpSocket);
    BOOL                TcpUpdatePersistFlag(CTcpSocket* pTcpSocket);
    void                TcpUpdateSndUna(CTcpSocket* pTcpSocket, TCPSEQ ack);
    BOOL                TcpValidateSeqs(CTcpSocket* pTcpSocket, TCPSEQ oldseq0, TCPSEQ oldseq1, TCPSEQ* newseq0, TCPSEQ* newseq1);
    BOOL                TcpVerifyRecvBuf(CTcpSocket* pTcpSocket);
    UINT                TcpCorrectMisorderedSegments(CTcpSocket* pTcpSocket, TCPSEQ seq, CTcpRecvBuf * recvbuf);
    void                TcpBufferMisorderedSegment(CTcpSocket* pTcpSocket, UINT seq, CTcpRecvBuf * recvbuf);
    UINT                TcpCompletePendingRecvReqFast(CTcpSocket* pTcpSocket, BYTE tcpflags, BYTE * pbData, UINT cbData);
    CTcpSocket *        TcpRecvData(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr, BYTE * pbData, UINT cbData);
    void                TcpProcessFIN(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr, TCPSEQ seqfin);
    BOOL                TcpParseOptions(CTcpSocket * pTcpSocket, CTcpHdr * tcphdr, struct _TcpOptions * opts);
    BOOL                TcpAcceptConnReqPassive(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr, CIpAddr ipaSrc);
    void                TcpConnectionEstablished(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr);
    BOOL                TcpAcceptConnReqActive(CTcpSocket* pTcpSocket, CTcpHdr* tcphdr);
    void                TcpSendSegment(CTcpSocket* pTcpSocket, CTcpSendBuf* sendbuf, BOOL fRetransmit);
    BOOL                TcpStartOutput(CTcpSocket* pTcpSocket);
    CTcpSocket *        TcpXmitTimeout(CTcpSocket* pTcpSocket);
    void                TcpDoFastRexmit(CTcpSocket* pTcpSocket);
    void                TcpQueueSegment(CTcpSocket* pTcpSocket, CPacket* pkt, BYTE tcpflags, UINT datalen);
    NTSTATUS            TcpSend(CTcpSocket* pTcpSocket, CSendReq * sendreq, UINT uiFlags);
    TCPSEQ              TcpSndNxt(CTcpSocket* pTcpSocket);
    VOID                TcpResetPeer(CTcpSocket* pTcpSocket);
    void                TcpEmitRST(CTcpSocket * pTcpSocket, CIpAddr ipaDst, CIpPort ipportDst, CIpPort ipportSrc, TCPSEQ seq, TCPSEQ ack, BYTE flags);
    NTSTATUS            TcpEmitSYN(CTcpSocket* pTcpSocket, BOOL synAck);
    void                TcpEmitACK(CTcpSocket* pTcpSocket);
    NTSTATUS            TcpEmitFIN(CTcpSocket * pTcpSocket);
    void                NeedSendACKNow(CTcpSocket * pTcpSocket);
    void                TcpTimer(CTimer * pt);
    CPacket *           TcpPacketAlloc(CTcpSocket * pTcpSocket, CIpAddr ipaDst, UINT uiFlags, UINT cbDat = 0, UINT cbPkt = 0, PFNPKTFREE pfn = NULL);
    void                TcpPacketFree(CPacket * ppkt);
    NTSTATUS            UdpConnect(CSocket* pSocket, CIpAddr dstaddr, CIpPort dstport);
    void                UdpRecvData(CSocket* pSocket, CIpAddr fromaddr, CIpPort fromport, BYTE * pbData, UINT cbData);
    NTSTATUS            UdpRead(CSocket* pSocket, CRecvReq* recvreq);
    NTSTATUS            UdpSend(CSocket* pSocket, CSendReq* sendreq, UINT uiFlags);
    void                UdpPacketFree(CPacket * ppkt);
    NTSTATUS            UdpShutdown(CSocket* pSocket, DWORD dwFlags);

    // Data ------------------------------------------------------------------------------

private:

    LONG                _cRefs;
    LONG                _cRefsSock;
    ULONG               _cSockets;
    LIST_ENTRY          _leSockets;
    LIST_ENTRY          _leDeadSockets;
    UINT                _ipportTempNext;

};

INLINE CSocket * CXnSock::GetNextSocket(CSocket * pSocketPrev)
{
    ICHECK(SOCK, UDPC|SDPC);
    LIST_ENTRY * ple = pSocketPrev ? pSocketPrev->GetFlink() : _leSockets.Flink;
    return(ple == &_leSockets ? NULL : (CSocket *)ple);
}

INLINE CSocket * CXnSock::GetFirstSocket()
{
    ICHECK(SOCK, UDPC|SDPC);
    return(GetNextSocket(NULL));
}

// ---------------------------------------------------------------------------------------
// CTcpSocket Inlines (Requires CSocket Declared)
// ---------------------------------------------------------------------------------------

INLINE void CTcpSocket::TcpInit(CXnBase * pXnBase)
{
    ICHECK_(pXnBase, SOCK, USER|UDPC|SDPC);

    _Linger.l_linger = pXnBase->cfgSockLingerTimeoutInSeconds;
    _Linger.l_onoff  = FALSE;
    _pTcpSendBufPtr  = NULL;
    snd_mss          = TCP_DEFAULT_MSS;
    rcv_mss          = TCP_DEFAULT_MSS;
    snd_cwnd         = MAX_TCP_WNDSIZE;
    snd_ssthresh     = MAX_TCP_WNDSIZE;
    srtt_8           = 0;
    rttvar_4         = (UINT)(pXnBase->cfgSockRexmitTimeoutInSeconds * TICKS_PER_SECOND);
    RTO              = rttvar_4;

    Assert(IsListNull(&_le) || IsListEmpty(&_le));
    InitializeListHead(&_le);

    Assert(!_timer.IsActive());
    _timer.Init((PFNTIMER)CXnSock::TcpTimer);
}

// ---------------------------------------------------------------------------------------
// CXn
// ---------------------------------------------------------------------------------------

class NOVTABLE CXn : public CXnSock
{

public:

    // External --------------------------------------------------------------------------

    #undef  XNETAPI
    #define XNETAPI(ret, fname, arglist, paramlist) ret fname arglist;
    #undef  XNETAPI_
    #define XNETAPI_(ret, fname, arglist, paramlist)
    #undef  XNETAPIV
    #define XNETAPIV(ret, fname, arglist, paramlist)

    XNETAPILIST()

};

#ifdef XNET_FEATURE_XBOX
extern CXn * g_pXn;
#define GetXn()      g_pXn
#define GetXnRef()  &g_pXn
#endif

// ---------------------------------------------------------------------------------------
// XNET_FEATURE_VIRTUAL
// ---------------------------------------------------------------------------------------

#ifndef XNET_FEATURE_VIRTUAL

INLINE void CXnBase::SecRegProbe() { ((CXnIp *)this)->SecRegProbe(); }
INLINE void CXnBase::NicTimer() { ((CXnNic *)this)->NicTimer(); }
INLINE void CXnNic::EnetRecv(CPacket * ppkt, UINT uiType) { ((CXnEnet *)this)->EnetRecv(ppkt, uiType); }
INLINE void CXnNic::EnetPush() { ((CXnEnet *)this)->EnetPush(); }
INLINE void CXnEnet::IpRecv(CPacket * ppkt) { ((CXnIp *)this)->IpRecv(ppkt); }
INLINE void CXnEnet::IpRecvArp(CEnetAddr * pea) { ((CXnIp *)this)->IpRecvArp(pea); }
INLINE void CXnIp::UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen) { ((CXnSock *)this)->UdpRecv(ppkt, pIpHdr, pUdpHdr, cbLen); }
INLINE void CXnIp::TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen) { ((CXnSock *)this)->TcpRecv(ppkt, pIpHdr, pTcpHdr, cbHdrLen, cbLen); }
INLINE void CXnIp::SockReset(CIpAddr ipa) { ((CXnSock *)this)->SockReset(ipa); }

#endif

// ---------------------------------------------------------------------------------------
// XNET_FEATURE_FRAG
// ---------------------------------------------------------------------------------------

#ifndef XNET_FEATURE_FRAG

INLINE void CXnIp::FragTerm() {}

#endif

// ---------------------------------------------------------------------------------------
// XNET_FEATURE_ROUTE
// ---------------------------------------------------------------------------------------

#ifndef XNET_FEATURE_ROUTE

INLINE NTSTATUS CXnIp::RouteInit() { return(NETERR_OK); }
INLINE void     CXnIp::RouteTerm() {}
INLINE void     CXnIp::RouteAdd(CIpAddr ipaDst, CIpAddr ipaMask, CIpAddr ipaNext, WORD wFlags, WORD wMetric) {}
INLINE void     CXnIp::RouteDelete(CIpAddr ipaDst, CIpAddr ipaMask, CIpAddr ipaNext) {}
INLINE void     CXnIp::RouteRedirect(CIpAddr ipaDst, CIpAddr ipaOldGateway, CIpAddr ipNewGateway) {}
INLINE void     CXnIp::RouteRelease(CRouteEntry * prte) {}
INLINE void     CXnIp::RouteListOrphan() {}

#endif

// ---------------------------------------------------------------------------------------
// XNET_FEATURE_DHCP
// ---------------------------------------------------------------------------------------

#ifndef XNET_FEATURE_DHCP

INLINE NTSTATUS CXnIp::DhcpInit() { return(NETERR_OK); }
INLINE void     CXnIp::DhcpTerm() {}
INLINE void     CXnIp::DhcpTimer(CTimer * pt) {}
INLINE void     CXnIp::IpRecvArp(CEnetAddr *) {}

#endif

// ---------------------------------------------------------------------------------------
// XNET_FEATURE_TRACE
// ---------------------------------------------------------------------------------------

#ifndef XNET_FEATURE_TRACE

INLINE void CXnSock::TcpSetState(CTcpSocket* pTcpSocket, BYTE state, const CHAR* caller)
{
    pTcpSocket->SetState(state);
}

#endif

// ---------------------------------------------------------------------------------------
// XNET_FEATURE_ASSERT
// ---------------------------------------------------------------------------------------

#ifndef XNET_FEATURE_ASSERT

INLINE void *   CXnBase::LeakAdd(CLeakInfo * pli, void * pv, UINT cb, ULONG tag) { return(pv); }
INLINE void *   CXnBase::LeakDel(CLeakInfo * pli, void * pv) { return(pv); }

#endif

// ---------------------------------------------------------------------------------------

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\test\codesize\sources.inc ===
TARGETPATH=obj
TARGETTYPE=PROGRAM
TARGETNAME=codesize
NO_BINPLACE=1
NTPREFIX=1
INCLUDES=$(INCLUDE);$(SDK_INC_PATH);..\..\..
LINKER_FLAGS=$(LINKER_FLAGS) /map
SOURCES=\
    codesize.c\
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\i386\tcpipxsum.asm ===
title  "Compute TCP/IP Checksum"

;/*++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    tcpipxsum.asm
;
; Abstract:
;
;    This module implements a function to compute the checksum of a buffer.
;
; Author:
;
;    David N. Cutler (davec) 27-Jan-1992
;
; Revision History:
;
;     Who         When        What
;     --------    --------    ----------------------------------------------
;     mikeab      01-22-94    Pentium optimization
;
;--*/



LOOP_UNROLLING_BITS equ     4
LOOP_UNROLLING      equ     (1 SHL LOOP_UNROLLING_BITS)

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        .list

XNET    SEGMENT DWORD PUBLIC 'CODE'

;++
;
; ULONG
; tcpipxsum(
;   IN ULONG xsum,
;   IN const VOID* buf,
;   IN UINT len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;    It uses Processor's prefetch instruction.
;
; Arguments:
;
;    xsum - Suppiles the initial checksum value, in 16-bit form,
;           with the high word set to 0.
;
;    buf - Supplies a pointer to the buffer to the checksum buffer.
;
;    len - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum in 32-bit two-partial-accumulators form, added to
;    the initial checksum, is returned as the function value.
;
;--

xsum    equ     12                      ; stack offset to initial checksum
buf     equ     16                      ; stack offset to source address
len     equ     20                      ; stack offset to length in words

to_checksum_last_word:
        jmp     checksum_last_word

to_checksum_done:
        jmp     checksum_done

to_checksum_dword_loop_done:
        jmp     checksum_dword_loop_done

cPublicProc tcpipxsum,3

        push    ebx                     ; save nonvolatile register
        push    esi                     ; save nonvolatile register

        mov     ecx,[esp + len]         ; get length in bytes
        sub     eax,eax                 ; clear computed checksum
        test    ecx,ecx                 ; any bytes to checksum at all?
        jz      short to_checksum_done  ; no bytes to checksum

;
; if the checksum buffer is not word aligned, then add the first byte of
; the buffer to the input checksum.
;

        mov     esi,[esp + buf]         ; get source address
        sub     edx,edx                 ; set up to load word into EDX below
        test    esi,1                   ; check if buffer word aligned
        jz      short checksum_word_aligned ; if zf, buffer word aligned
        mov     ah,[esi]                ; get first byte (we know we'll have
                                        ;  to swap at the end)
        inc     esi                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; If the buffer is not an even number of of bytes, then initialize
; the computed checksum with the last byte of the buffer.
;

checksum_word_aligned:                  ;
        shr     ecx,1                   ; convert to word count
        jnc     short checksum_start    ; if nc, even number of bytes
        mov     al,[esi+ecx*2]          ; initialize the computed checksum
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; Compute checksum in large blocks of dwords, with one partial word up front if
; necessary to get dword alignment, and another partial word at the end if
; needed.
;

;
; Compute checksum on the leading word, if that's necessary to get dword
; alignment.
;

checksum_start:                         ;
        test    esi,02h                 ; check if source dword aligned
        jz      short checksum_dword_aligned ; source is already dword aligned
        mov     dx,[esi]                ; get first word to checksum
        add     esi,2                   ; update source address
        add     eax,edx                 ; update partial checksum
                                        ;  (no carry is possible, because EAX
                                        ;  and EDX are both 16-bit values)
        dec     ecx                     ; count off this word (zero case gets
                                        ;  picked up below)

;
; Checksum as many words as possible by processing a dword at a time.
;

checksum_dword_aligned:
        push    ecx                     ; so we can tell if there's a trailing
                                        ;  word later
        shr     ecx,1                   ; # of dwords to checksum
        jz      short to_checksum_last_word ; no dwords to checksum

        mov     edx,[esi]               ; preload the first dword
        add     esi,4                   ; point to the next dword
        dec     ecx                     ; count off the dword we just loaded
        jz      short to_checksum_dword_loop_done
                                        ; skip the loop if that was the only dword
        mov     ebx,ecx                 ; EBX = # of dwords left to checksum
        add     ecx,LOOP_UNROLLING-1    ; round up loop count
        shr     ecx,LOOP_UNROLLING_BITS ; convert from word count to unrolled loop count
        and     ebx,LOOP_UNROLLING-1    ; # of partial dwords to do in first loop
        jz      short checksum_dword_loop ; special-case when no partial loop,
                                          ;  because fixup below doesn't work
                                          ;  in that case (carry flag is
                                          ;  cleared at this point, as required
                                          ;  at loop entry)
        lea     esi,[esi+ebx*4-(LOOP_UNROLLING*4)]
                                        ; adjust buffer pointer back to
                                        ;  compensate for hardwired displacement
                                        ;  at loop entry point
                                        ; ***doesn't change carry flag***
        jmp     loop_entry[ebx*4]       ; enter the loop to do the first,
                                        ; partial iteration, after which we can
                                        ; just do 32-word blocks
                                        ; ***doesn't change carry flag***

checksum_dword_loop:
        ; prefetch the 32-byte cache line from [esi+0]
        db 0fH
        db 18H
        db 46H
        db 00H

        ; prefetch the 32-byte cache line from [esi+20h]
        db 0fH
        db 18H
        db 46H
        db 20H

DEFLAB  macro   pre,suf
pre&suf:
        endm

TEMP=0
        REPT    LOOP_UNROLLING
        deflab  loop_entry_,%TEMP
        adc     eax,edx
        mov     edx,[esi + TEMP]
TEMP=TEMP+4
        ENDM

checksum_dword_loop_end:

        lea     esi,[esi + LOOP_UNROLLING * 4]  ; update source address
                                        ; ***doesn't change carry flag***
        dec     ecx                     ; count off unrolled loop iteration
                                        ; ***doesn't change carry flag***
        jnz     checksum_dword_loop     ; do more blocks

checksum_dword_loop_done label proc
        adc     eax,edx                 ; finish dword checksum
        mov     edx,0                   ; prepare to load trailing word
        adc     eax,edx

;
; Compute checksum on the trailing word, if there is one.
; High word of EDX = 0 at this point
; Carry flag set iff there's a trailing word to do at this point
;

checksum_last_word label proc           ; "proc" so not scoped to function
        pop     ecx                     ; get back word count
        test    ecx,1                   ; is there a trailing word?
        jz      short checksum_done     ; no trailing word
        add     ax,[esi]                ; add in the trailing word
        adc     eax,0                   ;

checksum_done label proc                ; "proc" so not scoped to function
        mov     ecx,eax                 ; fold the checksum to 16 bits
        ror     ecx,16
        add     eax,ecx
        mov     ebx,[esp + buf]
        shr     eax,16
        test    ebx,1                   ; check if buffer word aligned
        jz      short checksum_combine  ; if zf set, buffer word aligned
        ror     ax,8                    ; byte aligned--swap bytes back
checksum_combine label proc             ; "proc" so not scoped to function
        add     ax, word ptr [esp + xsum] ; combine checksums
        pop     esi                     ; restore nonvolatile register
        adc     eax,0                   ;
        pop     ebx                     ; restore nonvolatile register
        stdRET  tcpipxsum


REFLAB  macro   pre,suf
        dd      pre&suf
        endm

        align   4
loop_entry      label   dword
        dd      0
TEMP=LOOP_UNROLLING*4
        REPT    LOOP_UNROLLING-1
TEMP=TEMP-4
        reflab  loop_entry_,%TEMP
        ENDM

stdENDP tcpipxsum

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\xnver.h ===
// ---------------------------------------------------------------------------------------
// xnver.h
//
// Include file for stamping source files with the appropriate version structure
// ---------------------------------------------------------------------------------------

#ifdef  __XNVER_H__
#error "xnver.h should not be included more than once"
#endif
#define __XNVER_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <xboxverp.h>

#ifdef XNET_FEATURE_XBOX
#pragma data_seg(push)
#pragma data_seg(".XBLD$V")
#endif

#if defined(XNET_BUILD_LIBX) && DBG==0
    #define VERXNET()   VERGEN(XNetBuildNumber,     'X','N','E','T',0,0,0,0)
#elif defined(XNET_BUILD_LIBX) 
    #define VERXNET()   VERGEN(XNetBuildNumberD,    'X','N','E','T','D',0,0,0)
#elif defined(XNET_BUILD_LIBXS) && DBG==0
    #define VERXNET()   VERGEN(XNetBuildNumberS,    'X','N','E','T','S',0,0,0)
#elif defined(XNET_BUILD_LIBXS)
    #define VERXNET()   VERGEN(XNetBuildNumberSD,   'X','N','E','T','S','D',0,0)
#elif defined(XNET_BUILD_LIBXW) && DBG==0
    #define VERXNET()   VERGEN(XNetBuildNumberW,    'X','N','E','T','S',0,0,0)
#elif defined(XNET_BUILD_LIBXW)
    #define VERXNET()   VERGEN(XNetBuildNumberWD,   'X','N','E','T','S','D',0,0)
#elif defined(XNET_BUILD_LIBM) && DBG==0
    #define VERXNET()   VERGEN(XNetBuildNumberM,    'X','N','E','T','M',0,0,0)
#elif defined(XNET_BUILD_LIBM)
    #define VERXNET()   VERGEN(XNetBuildNumberMD,   'X','N','E','T','M','D',0,0)
#elif defined(XNET_BUILD_LIBO) && DBG==0
    #define VERXNET()   VERGEN(XOnlineBuildNumber,  'X','O','N','L','I','N','E',0)
#elif defined(XNET_BUILD_LIBO)
    #define VERXNET()   VERGEN(XOnlineBuildNumberD, 'X','O','N','L','I','N','E','D')
#elif defined(XNET_BUILD_LIBOS) && DBG==0
    #define VERXNET()   VERGEN(XOnlineBuildNumberS, 'X','O','N','L','I','N','E','S')
#elif defined(XNET_BUILD_LIBOS)
    #define VERXNET()   VERGEN(XOnlineBuildNumberSD,'X','O','N','L','I','N','S','D')
#elif defined(XNET_BUILD_LIBOW) && DBG==0
    #define VERXNET()   VERGEN(XOnlineBuildNumberW, 'X','O','N','L','I','N','E','W')
#elif defined(XNET_BUILD_LIBOW)
    #define VERXNET()   VERGEN(XOnlineBuildNumberWD,'X','O','N','L','I','N','W','D')
#else
    #error "Don't know how to make VERXNET"
#endif

#if DBG
#define VERDBG  0x8000
#else
#define VERDBG  0x0000
#endif

//
// XNET_BUILD_LIBOS is not conditionally approved yet - when it is, uncomment the
// line below
//

// #if DBG==0 && (defined(XNET_BUILD_LIBXS) || defined(XNET_BUILD_LIBOS))
#if DBG==0 && (defined(XNET_BUILD_LIBXS))
#define VERSEC  0x2000
#else
#define VERSEC  0x0000
#endif

#define VERGEN(var,a1,a2,a3,a4,a5,a6,a7,a8) comment(linker, "/include:_" # var)
#pragma VERXNET()
#undef  VERGEN
#define VERGEN(var,a1,a2,a3,a4,a5,a6,a7,a8) var[8] = { (a1) | ((a2) << 8), (a3) | ((a4) << 8), (a5) | ((a6) << 8), (a7) | ((a8) << 8), VER_PRODUCTVERSION | VERDBG | VERSEC }
__declspec(selectany) unsigned short VERXNET();
#undef  VERGEN
#undef  VERDBG
#undef  VERSEC
#undef  VERXNET

#ifdef XNET_FEATURE_XBOX
#pragma data_seg(pop)
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\test\codesize\codesize.cpp ===
// ---------------------------------------------------------------------------------------
// codesize.cpp
//
// Test program which links with all of the external entry points of
// the XNet library.  Used to track the size of the XNet code.
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "xnp.h"

#ifdef XNET_FEATURE_XBOX
#define CODESIZEINHERIT
#else
#define CODESIZEINHERIT     : public CXNet
#endif

void __cdecl Ref(DWORD dw, ...)
{
    static DWORD s_dwCount;
    s_dwCount += dw;
}

class CCodeSize CODESIZEINHERIT
{
public:
    void DoRef();
};

void CCodeSize::DoRef()
{
#ifndef XNETBASELINE
    #undef  XNETAPI
    #define XNETAPI(ret, fname, arglist, paramlist) Ref(0, fname);
    #undef  XNETAPI_
    #define XNETAPI_(ret, fname, arglist, paramlist) Ref(0, fname);
    #undef  XNETAPIV
    #define XNETAPIV(ret, fname, arglist, paramlist) Ref(0, fname);
    XNETAPILIST()
    SOCKAPILIST()
#endif
}

void __cdecl main(int argc, char * argv[])
{
    CCodeSize CodeSize;
    CodeSize.DoRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\test\xnet\testxnet.cpp ===
// ----------------------------------------------------------------------------
// testxnet.cpp
//
// Copyright (C) Microsoft Corporation
// ----------------------------------------------------------------------------

#include "xnp.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <vlan.h>

// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

#define Verify(x)       do { if (!(x)) DbgBreak(); } while (0)

struct CDiscReq
{
    BYTE    abNonce[8];         // Nonce of the requester
};

struct CDiscRsp : public CDiscReq
{
    XNKID   xnkid;              // The host's key identifier
    XNKEY   xnkey;              // The host's key
    XNADDR  xnaddr;             // The host's address
};

ULONG WSAAPI inet_addr(const char * pch)
{
    return(((CXNet *)0)->inet_addr(pch));
}

// ---------------------------------------------------------------------------------------
// CTestXnIp
// ---------------------------------------------------------------------------------------

class CTestXnIp : public CXnIp
{

public:
    
    virtual void Startup(char * pszXbox, char * pszIp, char * pszMask, char * pszGateway, DWORD dwFlags)
    {
        XNetParams xnp = { sizeof(XNetStartupParams) };
        xnp.cfgFlags = (BYTE)(XNET_STARTUP_MANUAL_CONFIG|dwFlags);
        XNetInitParams xnip = { &xnp, pszXbox };
        Verify(IpInit(&xnip) == 0);

        XNetConfigParams xncp = { 0 };
        xncp.ina.s_addr = pszIp ? inet_addr(pszIp) : 0;
        xncp.inaMask.s_addr = pszMask ? inet_addr(pszMask) : 0;
        xncp.inaGateway.s_addr = pszGateway ? inet_addr(pszGateway) : 0;
        Verify(IpConfig(&xncp, XNET_CONFIG_NORMAL) == 0);

        IpStart();
    }

    virtual void Init()
    {
        Startup(NULL, NULL, NULL, NULL, 0);
    }

    virtual void Term()
    {
        RaiseToDpc();
        IpTerm();
    }

    void Go(HANDLE hEvent1, HANDLE hEvent2)
    {
        Init();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) Verify(WaitForSingleObject(hEvent2, INFINITE) == WAIT_OBJECT_0);
        Test();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) Verify(WaitForSingleObject(hEvent2, INFINITE) == WAIT_OBJECT_0);
        Term();
    }

    void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen) {};
    void TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen) {};
    void SockReset(CIpAddr ipa) {};

    virtual void Test() = 0;
};

#define IPTEST_BEG(_name, pszXbox, pszIp, pszMask, pszGateway, dwFlags) \
    class CTest##_name : public CTestXnIp { \
    virtual void Init() { Startup(pszXbox, pszIp, pszMask, pszGateway, dwFlags); } \
    virtual void Test()
#define IPTEST_END(_name) \
    }; void Test_##_name(HANDLE hEvent1 = 0, HANDLE hEvent2 = 0) \
    { CTest##_name * p = new CTest##_name; p->Go(hEvent1, hEvent2); delete p; }

// ---------------------------------------------------------------------------------------
// CTestXNet
// ---------------------------------------------------------------------------------------

HANDLE  g_hEventXb1ToXb2;
HANDLE  g_hEventXb2ToXb1;
XNADDR  g_xnaddrXb1;
XNADDR  g_xnaddrXb2;
XNKID   g_xnkidXb1ToXb2;
XNKEY   g_xnkeyXb1ToXb2;
BOOL    g_fXb1ToXb2Timeout;
UINT    g_cSecsXb1ToXb2Connect;

class CTestXNet : public CXNet
{
public:
    
    CTestXNet(char * pszXbox = NULL) : CXNet(pszXbox) {}

    virtual void Startup(char * pszIp, char * pszMask, char * pszGateway, DWORD dwFlags)
    {
        XNetStartupParams xnp = { sizeof(XNetStartupParams) };
        xnp.cfgFlags = (BYTE)(XNET_STARTUP_MANUAL_CONFIG|dwFlags);
        Verify(XNetStartup(&xnp) == 0);

        XNetConfigParams xncp = { 0 };
        xncp.ina.s_addr = pszIp ? inet_addr(pszIp) : 0;
        xncp.inaMask.s_addr = pszMask ? inet_addr(pszMask) : 0;
        xncp.inaGateway.s_addr = pszGateway ? inet_addr(pszGateway) : 0;
        Verify(XNetConfig(&xncp, XNET_CONFIG_NORMAL) == 0);

        WSADATA WSAData;
        Verify(WSAStartup(0x0200, &WSAData) == 0);
    }

    virtual void Init()
    {
        Startup(NULL, NULL, NULL, 0);
    }

    virtual void Term()
    {
        WSACleanup();
        XNetCleanup();
    }

    void Go(HANDLE hEvent1, HANDLE hEvent2)
    {
        Init();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) Verify(WaitForSingleObject(hEvent2, INFINITE) == WAIT_OBJECT_0);
        Test();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) Verify(WaitForSingleObject(hEvent2, INFINITE) == WAIT_OBJECT_0);
        Term();
    }

    virtual void Test() = 0;

    SOCKET  SockUdpCreate(CIpPort ipport = 0, BOOL fBroadcast = FALSE);
    void    SockUdpTransmit(SOCKET s, CIpAddr ipaDst, CIpPort ipport, UINT cbMax = UDP_MAXIMUM_MSS);
    void    SockUdpReflect(SOCKET s);
    SOCKET  SockTcpCreate(CIpPort ipport = 0);
    void    SockTcpTransmit(SOCKET s, UINT cbMax = TCP_MAXIMUM_MSS);
    void    SockTcpReflect(SOCKET s);
    void    DiscoveryHost(UINT cClient, XNKID * pxnkid);
    void    DiscoveryClient(XNKID * pxnkid, CIpAddr * pipa);
    void    SgTcpXbToXbClient();
    void    SgTcpXbToXbServer();

};

SOCKET CTestXNet::SockUdpCreate(CIpPort ipport, BOOL fBroadcast)
{
    SOCKET s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    Verify(s != SOCKET_ERROR);

    if (ipport)
    {
        sockaddr_in sin;
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = 0;
        sin.sin_port = ipport;
        Verify(bind(s, (struct sockaddr *)&sin, sizeof(sin)) == 0);
    }

    if (fBroadcast)
    {
        char cBroadcast = 1;
        Verify(setsockopt(s, SOL_SOCKET, SO_BROADCAST, &cBroadcast, 1) == 0);
    }

    return(s);
}

void CTestXNet::SockUdpTransmit(SOCKET s, CIpAddr ipaDst, CIpPort ipport, UINT cbMax)
{
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = ipaDst;
    sin.sin_port = ipport;
    
    BYTE abXmit[1500], abRecv[1500];

    if (cbMax > sizeof(abXmit))
        cbMax = sizeof(abXmit);

    int cb;

    for (cb = 1; cb < (int)cbMax; ++cb)
    {
        XNetRandom(abXmit, cb);
        Verify(sendto(s, (char *)abXmit, cb, 0, (struct sockaddr *)&sin, sizeof(sin)) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    for (; cb > 0; --cb)
    {
        XNetRandom(abXmit, cb);
        Verify(sendto(s, (char *)abXmit, cb, 0, (struct sockaddr *)&sin, sizeof(sin)) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    Verify(sendto(s, (char *)abXmit, 0, 0, (struct sockaddr *)&sin, sizeof(sin)) == 0);
    Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == 0);
}

void CTestXNet::SockUdpReflect(SOCKET s)
{
    BYTE abRecv[1500];

    sockaddr_in sin;
    int cb;

    while (1)
    {
        int slen = sizeof(sin);
        cb = recvfrom(s, (char *)abRecv, sizeof(abRecv), 0, (struct sockaddr *)&sin, &slen);
        Verify(cb != SOCKET_ERROR);
        Verify(sendto(s, (char *)abRecv, cb, 0, (struct sockaddr *)&sin, sizeof(sin)) == cb);
        if (cb == 0)
            break;
    }
}

SOCKET CTestXNet::SockTcpCreate(CIpPort ipport)
{
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);

    if (ipport)
    {
        sockaddr_in sin;
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = 0;
        sin.sin_port = ipport;
        Verify(bind(s, (struct sockaddr *)&sin, sizeof(sin)) == 0);
    }

    return(s);
}

void CTestXNet::SockTcpTransmit(SOCKET s, UINT cbMax)
{
    BYTE abXmit[1500], abRecv[1500];

    if (cbMax > sizeof(abXmit))
        cbMax = sizeof(abXmit);

    int cb;

    for (cb = 1; cb < (int)cbMax; ++cb)
    {
        XNetRandom(abXmit, cb);
        Verify(send(s, (char *)abXmit, cb, 0) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    for (; cb > 0; --cb)
    {
        XNetRandom(abXmit, cb);
        Verify(send(s, (char *)abXmit, cb, 0) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    Verify(shutdown(s, SD_SEND) != SOCKET_ERROR);
}

void CTestXNet::SockTcpReflect(SOCKET s)
{
    BYTE abRecv[1500];
    int cb;

    while (1)
    {
        cb = recv(s, (char *)abRecv, sizeof(abRecv), 0);
        Verify(cb != SOCKET_ERROR);

        if (cb == 0)
        {
            Verify(shutdown(s, SD_SEND) != SOCKET_ERROR);
            break;
        }

        Verify(send(s, (char *)abRecv, cb, 0) == cb);
    }
}

void CTestXNet::DiscoveryHost(UINT cClient, XNKID * pxnkid)
{
    SOCKET s = SockUdpCreate(NTOHS(1234), TRUE);

    CDiscReq dreq;
    CDiscRsp drsp;
    UINT iClient = 0;
    sockaddr_in sin;
    BYTE * pbNonce = (BYTE *)LocalAlloc(LPTR, sizeof(dreq.abNonce) * cClient);
    Verify(pbNonce != NULL);
    XNADDR xnaddr;
    XNKID xnkid;
    XNKEY xnkey;

    Verify(XNetCreateKey(&drsp.xnkid, &drsp.xnkey) == 0);
    Verify(XNetRegisterKey(&drsp.xnkid, &drsp.xnkey) == 0);
    Verify(XNetGetTitleXnAddr(&drsp.xnaddr) != 0);

    XNetRandom(drsp.abNonce, sizeof(drsp.abNonce));

    while (iClient < cClient)
    {
        Verify(recv(s, (char *)&dreq, sizeof(dreq), 0) == sizeof(dreq));

        for (UINT i = 0; i < iClient; ++i)
        {
            if (memcmp(&pbNonce[i * sizeof(dreq.abNonce)], dreq.abNonce, sizeof(dreq.abNonce)) == 0)
                break;
        }

        if (i == iClient)
        {
            memcpy(&pbNonce[i * sizeof(dreq.abNonce)], dreq.abNonce, sizeof(dreq.abNonce));
            iClient += 1;
        }

        memcpy(drsp.abNonce, dreq.abNonce, sizeof(dreq.abNonce));
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = INADDR_BROADCAST;
        sin.sin_port = NTOHS(1234);
        Verify(sendto(s, (char *)&drsp, sizeof(drsp), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(drsp));
    }

    Verify(closesocket(s) == 0);
    LocalFree(pbNonce);
    *pxnkid = drsp.xnkid;
}

void CTestXNet::DiscoveryClient(XNKID * pxnkid, CIpAddr * pipa)
{
    SOCKET s = SockUdpCreate(NTOHS(1234));

    char cBroadcast = 1;
    sockaddr_in sin;
    CDiscReq dreq;
    CDiscRsp drsp;

    XNetRandom(dreq.abNonce, sizeof(dreq.abNonce));

    Verify(setsockopt(s, SOL_SOCKET, SO_BROADCAST, &cBroadcast, 1) == 0);

    while (1)
    {
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = INADDR_BROADCAST;
        sin.sin_port = NTOHS(1234);
        Verify(sendto(s, (char *)&dreq, sizeof(dreq), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(dreq));

        fd_set  fds;
        TIMEVAL tv;
        FD_ZERO(&fds);
        FD_SET(s, &fds);
        tv.tv_sec  = 0;
        tv.tv_usec = 200000;

        INT iResult = select(0, &fds, NULL, NULL, &tv);
        Verify(iResult != SOCKET_ERROR);

        while (1)
        {
            ULONG ul = 0;
            iResult = ioctlsocket(s, FIONREAD, &ul);
            Verify(iResult != SOCKET_ERROR);

            if (ul == 0)
                break;

            Verify(recv(s, (char *)&drsp, sizeof(drsp), 0) == sizeof(drsp));
            if (memcmp(drsp.abNonce, dreq.abNonce, sizeof(drsp.abNonce)) == 0)
                goto done;
        }
    }

done:

    Verify(XNetRegisterKey(&drsp.xnkid, &drsp.xnkey) == 0);
    Verify(XNetXnAddrToInAddr(&drsp.xnaddr, &drsp.xnkid, (IN_ADDR *)pipa) == 0);
    Verify(closesocket(s) == 0);
    *pxnkid = drsp.xnkid;
}

void CTestXNet::SgTcpXbToXbClient()
{
    while (XNetGetTitleXnAddr(&g_xnaddrXb1) == XNET_GET_XNADDR_PENDING)
        Sleep(100);

    IN_ADDR inaVip, inaSg, inaXb2;
    HANDLE hEventLogon;

    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSg) == 0);
    Verify((hEventLogon = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    GetXn()->IpLogon(inaSg.s_addr, NULL, hEventLogon);
    Verify(WaitForSingleObject(hEventLogon, INFINITE) == WAIT_OBJECT_0);
    Verify(GetXn()->IpLogonGetStatus(NULL) == XN_LOGON_STATE_ONLINE);

    Verify(WaitForSingleObject(g_hEventXb1ToXb2, INFINITE) == WAIT_OBJECT_0);

    Verify(XNetRegisterKey(&g_xnkidXb1ToXb2, &g_xnkeyXb1ToXb2) == 0);
    Verify(XNetXnAddrToInAddr(&g_xnaddrXb2, &g_xnkidXb1ToXb2, &inaXb2) == 0);

    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = inaXb2.s_addr;
    sin.sin_port = HTONS(80);
    DWORD dwTick = GetTickCount();
    INT err = connect(s, (struct sockaddr *)&sin, sizeof(sin));
    dwTick = GetTickCount() - dwTick;
    g_cSecsXb1ToXb2Connect = (dwTick + 500) / 1000;

    if (err == SOCKET_ERROR)
    {
        g_fXb1ToXb2Timeout = TRUE;
    }

    SetEvent(g_hEventXb2ToXb1);

    if (!g_fXb1ToXb2Timeout)
    {
        SockTcpTransmit(s, 10);
    }

    Verify(closesocket(s) == 0);

    // don't blow away the SA before the TCP connection has a chance to close gracefully
    Sleep(100);
    
    Verify(XNetUnregisterKey(&g_xnkidXb1ToXb2) == 0);

    GetXn()->IpLogoff();
    Verify(CloseHandle(hEventLogon));
}

void CTestXNet::SgTcpXbToXbServer()
{
    while (XNetGetTitleXnAddr(&g_xnaddrXb2) == XNET_GET_XNADDR_PENDING)
        Sleep(100);

    IN_ADDR inaVip, inaSg, inaXb2;
    HANDLE hEventLogon;

    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSg) == 0);
    Verify((hEventLogon = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    GetXn()->IpLogon(inaSg.s_addr, NULL, hEventLogon);
    Verify(WaitForSingleObject(hEventLogon, INFINITE) == WAIT_OBJECT_0);
    Verify(GetXn()->IpLogonGetStatus(NULL) == XN_LOGON_STATE_ONLINE);

    Verify(XNetCreateKey(&g_xnkidXb1ToXb2, &g_xnkeyXb1ToXb2) == 0);
    g_xnkidXb1ToXb2.ab[0] &= ~XNET_XNKID_MASK;
    g_xnkidXb1ToXb2.ab[0] |=  XNET_XNKID_ONLINE_PEER;
    Verify(XNetRegisterKey(&g_xnkidXb1ToXb2, &g_xnkeyXb1ToXb2) == 0);
    DWORD dw = XNetGetTitleXnAddr(&g_xnaddrXb2);
    Verify(dw != XNET_GET_XNADDR_PENDING);
    Verify(dw & XNET_GET_XNADDR_ONLINE);

    SOCKET s1 = SockTcpCreate(HTONS(80));
    Verify(listen(s1, 1) == 0);

    SetEvent(g_hEventXb1ToXb2);
    Verify(WaitForSingleObject(g_hEventXb2ToXb1, INFINITE) == WAIT_OBJECT_0);

    if (!g_fXb1ToXb2Timeout)
    {
        sockaddr_in sin;
        int slen = sizeof(sin);
        SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
        Verify(s2 != SOCKET_ERROR);
        Verify(slen == sizeof(sin));
        SockTcpReflect(s2);
        Verify(closesocket(s2) == 0);
    }

    Verify(closesocket(s1) == 0);
    Verify(XNetUnregisterKey(&g_xnkidXb1ToXb2) == 0);

    GetXn()->IpLogoff();
    Verify(CloseHandle(hEventLogon));
}

#define XNETTEST_BEG(_name, pszXbox, pszIp, pszMask, pszGateway, dwFlags) \
    class CTest##_name : public CTestXNet { public: \
    CTest##_name() : CTestXNet(pszXbox) {}; \
    virtual void Init() { Startup(pszIp, pszMask, pszGateway, dwFlags); } \
    virtual void Test()
#define XNETTEST_END(_name) \
    }; void Test_##_name(HANDLE hEvent1 = 0, HANDLE hEvent2 = 0) { CTest##_name * p = new CTest##_name; p->Go(hEvent1, hEvent2); delete p; }

// ---------------------------------------------------------------------------------------
// TWOTHREADTEST
// ---------------------------------------------------------------------------------------

typedef void (*PFNTEST)(HANDLE hEvent1, HANDLE hEvent2);

typedef struct {
    HANDLE      hThread;
    HANDLE      hEvent1;
    HANDLE      hEvent2;
    PFNTEST     pfn;
} TWOTHREADPARAM;

DWORD WINAPI TwoThreadProc(void * pv)
{
    TWOTHREADPARAM * p = (TWOTHREADPARAM *)pv;
    p->pfn(p->hEvent1, p->hEvent2);
    return(0);
}

#define TWOTHREADTEST(_name) \
    void Test_##_name##_run() \
    { \
        g_fXb1ToXb2Timeout = FALSE; \
        Verify((g_hEventXb1ToXb2 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); \
        Verify((g_hEventXb2ToXb1 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); \
        HANDLE  hThread1 = NULL, hEvent1 = NULL, hThread2 = NULL, hEvent2 = NULL; \
        TWOTHREADPARAM p1, p2; \
        Verify((p1.hEvent1 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); \
        Verify((p1.hEvent2 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); \
        p1.pfn = &Test_##_name##_1; \
        p2.hEvent1 = p1.hEvent2; \
        p2.hEvent2 = p1.hEvent1; \
        p2.pfn = &Test_##_name##_2; \
        Verify((p1.hThread = CreateThread(NULL, 0, TwoThreadProc, &p1, 0, NULL)) != NULL); \
        Verify((p2.hThread = CreateThread(NULL, 0, TwoThreadProc, &p2, 0, NULL)) != NULL); \
        Verify(WaitForSingleObject(p1.hThread, INFINITE) == WAIT_OBJECT_0); \
        Verify(WaitForSingleObject(p2.hThread, INFINITE) == WAIT_OBJECT_0); \
        CloseHandle(p1.hEvent1); CloseHandle(p2.hEvent1); \
        CloseHandle(p1.hThread); CloseHandle(p2.hThread); \
        CloseHandle(g_hEventXb1ToXb2); g_hEventXb1ToXb2 = NULL; \
        CloseHandle(g_hEventXb2ToXb1); g_hEventXb2ToXb1 = NULL; \
    } \
    void Test_##_name() \

#define TWOTHREADRUN(_name) Test_##_name##_run()

// Test_inet_addr ------------------------------------------------------------------------

XNETTEST_BEG(inet_addr, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    printf("Testing inet_addr ");
    Verify(inet_addr("004.003.002.020") == 0x10020304);
    Verify(inet_addr("0377.0377.0377.0377") == 0xffffffff);
    Verify(inet_addr("004.003.002.0400") == 0x00020304);
    Verify(inet_addr("004.003.0400.020") == 0x10000304);
    Verify(inet_addr("004.0400.002.020") == 0x10020004);
    Verify(inet_addr("0400.003.002.020") == 0x10020300);
    Verify(inet_addr("0x4.0x3.0x2.0x10") == 0x10020304);
    Verify(inet_addr("0xFF.0xFF.0xFF.0xFF") == 0xffffffff);
    Verify(inet_addr("0x4.0x3.0x2.0x100") == 0x00020304);
    Verify(inet_addr("0x4.0x3.0x100.0x10") == 0x10000304);
    Verify(inet_addr("0x4.0x100.0x2.0x10") == 0x10020004);
    Verify(inet_addr("0x100.0x3.0x2.0x10") == 0x10020300);
    Verify(inet_addr("4.003.2.0x10") == 0x10020304);
    Verify(inet_addr("004.3.0x2.16") == 0x10020304);
    Verify(inet_addr("4.0x3.2.020") == 0x10020304);
    Verify(inet_addr("0x4.3.002.16") == 0x10020304);
    Verify(inet_addr("255.0377.255.0xFF") == 0xffffffff);
    Verify(inet_addr("0377.255.0xFF.255") == 0xffffffff);
    Verify(inet_addr("255.0xFF.255.0377") == 0xffffffff);
    Verify(inet_addr("0xFF.255.0377.255") == 0xffffffff);
    Verify(inet_addr("4.0400.2.0x10") == 0x10020004);
    Verify(inet_addr("004.3.0x100.16") == 0x10000304);
    Verify(inet_addr("256.0x3.2.020") == 0x10020300);
    Verify(inet_addr("0x4.3.002.256") == 0x00020304);
    Verify(inet_addr("4.3.2") == 0x02000304);
    Verify(inet_addr("255.255.255") == 0xff00ffff);
    Verify(inet_addr("4.3.256") == 0x00010304);
    Verify(inet_addr("4.3.65536") == 0x00000304);
    Verify(inet_addr("4.3") == 0x03000004);
    Verify(inet_addr("255.255") == 0xff0000ff);
    Verify(inet_addr("4.256") == 0x00010004);
    Verify(inet_addr("4.16777216") == 0x00000004);
    Verify(inet_addr("4") == 0x04000000);
    Verify(inet_addr("255") == 0xff000000);
    Verify(inet_addr("4294967296") == 0x00000000);
    Verify(inet_addr("4.3.2.16abcdef") == 0xffffffff);
    Verify(inet_addr("4.3.2abcdef.16") == 0xffffffff);
    Verify(inet_addr("4.3abcdef.2.16") == 0xffffffff);
    Verify(inet_addr("4abcdef.3.2.16") == 0xffffffff);
    Verify(inet_addr("4.3.2.abcdef16") == 0xffffffff);
    Verify(inet_addr("4.3.abcdef2.16") == 0xffffffff);
    Verify(inet_addr("4.abcdef3.2.16") == 0xffffffff);
    Verify(inet_addr("abcdef4.3.2.16") == 0xffffffff);
    Verify(inet_addr("4.3.2 .16") == 0x10020304);
    Verify(inet_addr("4.3 .2.16") == 0x10020304);
    Verify(inet_addr("4 .3.2.16") == 0x10020304);
    Verify(inet_addr("4.3.2. 16") == 0x10020304);
    Verify(inet_addr("4.3. 2.16") == 0x10020304);
    Verify(inet_addr("4. 3.2.16") == 0x10020304);
    Verify(inet_addr(" 4.3.2.16") == 0x10020304);
    printf(" [OK]\n");
}
XNETTEST_END(inet_addr);

// Test_XNetRandom -----------------------------------------------------------------------

XNETTEST_BEG(XNetRandom, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    printf("Testing XNetRandom ");

    DWORD dw1, dw2;
    Verify(XNetRandom((BYTE *)&dw1, sizeof(dw1)) == 0);
    Verify(XNetRandom((BYTE *)&dw2, sizeof(dw2)) == 0);
    Verify(dw1 != dw2);

    BYTE ab[13];
    UINT c = 200;
    for (; c > 0; --c)
    {
        Verify(XNetRandom(ab, sizeof(ab)) == 0);
    }

    printf("[OK]\n");
}
XNETTEST_END(XNetRandom);

// Test_XNetRegisterKey ------------------------------------------------------------------

XNETTEST_BEG(XNetRegisterKey, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    printf("Testing XNetRegisterKey ");

    XNKID xnkid1, xnkid2, xnkid3, xnkid4, xnkid5;
    XNKEY xnkey1, xnkey2, xnkey3, xnkey4, xnkey5;

    Verify(XNetCreateKey(&xnkid1, &xnkey1) == 0);
    Verify(XNetCreateKey(&xnkid2, &xnkey2) == 0);
    Verify(XNetCreateKey(&xnkid3, &xnkey3) == 0);
    Verify(XNetCreateKey(&xnkid4, &xnkey4) == 0);
    Verify(XNetCreateKey(&xnkid5, &xnkey5) == 0);

    Verify(XNetRegisterKey(&xnkid1, &xnkey1) == 0);
    Verify(XNetRegisterKey(&xnkid1, &xnkey1) == WSAEALREADY);
    Verify(XNetRegisterKey(&xnkid1, &xnkey2) == WSAEALREADY);
    Verify(XNetRegisterKey(&xnkid2, &xnkey2) == 0);
    Verify(XNetRegisterKey(&xnkid2, &xnkey1) == WSAEALREADY);
    Verify(XNetRegisterKey(&xnkid2, &xnkey2) == WSAEALREADY);
    Verify(XNetUnregisterKey(&xnkid1) == 0);
    Verify(XNetUnregisterKey(&xnkid1) == WSAEINVAL);
    Verify(XNetRegisterKey(&xnkid1, &xnkey1) == 0);
    Verify(XNetRegisterKey(&xnkid1, &xnkey1) == WSAEALREADY);
    Verify(XNetUnregisterKey(&xnkid2) == 0);
    Verify(XNetUnregisterKey(&xnkid2) == WSAEINVAL);
    Verify(XNetUnregisterKey(&xnkid1) == 0);
    Verify(XNetUnregisterKey(&xnkid1) == WSAEINVAL);
    Verify(XNetRegisterKey(&xnkid1, &xnkey1) == 0);
    Verify(XNetRegisterKey(&xnkid2, &xnkey2) == 0);
    Verify(XNetRegisterKey(&xnkid3, &xnkey3) == 0);
    Verify(XNetRegisterKey(&xnkid4, &xnkey4) == 0);
    Verify(XNetRegisterKey(&xnkid5, &xnkey5) == WSAENOMORE);
    Verify(XNetUnregisterKey(&xnkid3) == 0);
    Verify(XNetRegisterKey(&xnkid5, &xnkey5) == 0);
    Verify(XNetUnregisterKey(&xnkid3) == WSAEINVAL);
    Verify(XNetUnregisterKey(&xnkid2) == 0);
    Verify(XNetUnregisterKey(&xnkid4) == 0);
    Verify(XNetUnregisterKey(&xnkid1) == 0);
    Verify(XNetUnregisterKey(&xnkid5) == 0);

    printf("[OK]\n");
}
XNETTEST_END(XNetRegisterKey);

// Test_XNetXnAddrToInAddr ---------------------------------------------------------------

XNETTEST_BEG(XNetXnAddrToInAddr, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    printf("Testing XNetXnAddrToInAddr ");

    XNKID   xnkid1,     xnkid2,     xnkid3,     xnkidT,     xnkidZ;
    XNKEY   xnkey1,     xnkey2,     xnkey3,     xnkeyT;
    XNADDR  xnaddr1,    xnaddr2,    xnaddr3,    xnaddrT,    xnaddrZ;
    CIpAddr ipa1,       ipa2,       ipa3,       ipaT;

    Verify(XNetCreateKey(&xnkid1, &xnkey1) == 0);
    Verify(XNetCreateKey(&xnkid2, &xnkey2) == 0);
    Verify(XNetCreateKey(&xnkid3, &xnkey3) == 0);

    Verify(XNetRegisterKey(&xnkid1, &xnkey1) == 0);
    Verify(XNetRegisterKey(&xnkid2, &xnkey2) == 0);
    Verify(XNetRegisterKey(&xnkid3, &xnkey3) == 0);
    
    Verify(XNetGetTitleXnAddr(&xnaddr1) != 0);
    Verify(XNetXnAddrToInAddr(&xnaddr1, &xnkid1, (IN_ADDR *)&ipa1) == 0);
    Verify(ipa1 == IPADDR_LOOPBACK);

    memset(&xnkidZ, 0, sizeof(xnkidZ));
    Verify(XNetInAddrToXnAddr(*(IN_ADDR *)&ipa1, &xnaddrT, &xnkidT) == 0);
    Verify(memcmp(&xnaddr1, &xnaddrT, sizeof(XNADDR)) == 0);
    Verify(memcmp(&xnkidT, &xnkidZ, sizeof(xnkidZ)) == 0);

    XNADDR  rgxna[32];
    CIpAddr rgipa[32];
    int     i;

    for (i = 0; i < dimensionof(rgxna); ++i)
    {
        XNADDR * pxnaddr = &rgxna[i];
        memset(pxnaddr, 0, sizeof(XNADDR));
        Verify(XNetRandom(pxnaddr->abEnet, sizeof(pxnaddr->abEnet)) == 0);
        pxnaddr->ina.s_addr = 0;
        XNKID * pxnkid = ((i % 3) == 0 ? &xnkid1 : ((i % 3) == 1) ? &xnkid2 : &xnkid3);
        Verify(XNetXnAddrToInAddr(pxnaddr, pxnkid, (IN_ADDR *)&rgipa[i]) == 0);
    }

    memset(&xnaddrT, 0, sizeof(xnaddrT));
    Verify(XNetRandom(xnaddrT.abEnet, sizeof(xnaddrT.abEnet)) == 0);
    Verify(XNetXnAddrToInAddr(&xnaddrT, &xnkid1, (IN_ADDR *)&ipaT) == WSAENOMORE);

    for (i = 0; i < dimensionof(rgxna); ++i)
    {
        XNADDR * pxnaddr = &rgxna[i];
        XNKID * pxnkid = ((i % 3) == 0 ? &xnkid1 : ((i % 3) == 1) ? &xnkid2 : &xnkid3);
        Verify(XNetInAddrToXnAddr(*(IN_ADDR *)&rgipa[i], &xnaddrT, &xnkidT) == 0);
        Verify(memcmp(&xnaddrT, &rgxna[i], sizeof(XNADDR)) == 0);
        Verify(memcmp(&xnkidT, pxnkid, sizeof(XNKID)) == 0);
    }

    Verify(XNetUnregisterKey(&xnkid2) == 0);

    for (i = 0; i < dimensionof(rgxna); ++i)
    {
        XNKID * pxnkid = ((i % 3) == 0 ? &xnkid1 : ((i % 3) == 1) ? &xnkid2 : &xnkid3);
        if ((i % 3) == 1)
        {
            memset(&xnaddrZ, 0, sizeof(XNADDR));
            memcpy(&xnaddrT, &rgxna[i], sizeof(XNADDR));
            memset(&xnkidZ, 0, sizeof(XNKID));
            memcpy(&xnkidT, pxnkid, sizeof(XNKID));
            Verify(XNetInAddrToXnAddr(*(IN_ADDR *)&rgipa[i], &xnaddrT, &xnkidT) == WSAEINVAL);
            Verify(memcmp(&xnaddrT, &xnaddrZ, sizeof(XNADDR)) == 0);
            Verify(memcmp(&xnkidT, &xnkidZ, sizeof(XNKID)) == 0);
        }
        else
        {
            Verify(XNetInAddrToXnAddr(*(IN_ADDR *)&rgipa[i], &xnaddrT, &xnkidT) == 0);
            Verify(memcmp(&xnaddrT, &rgxna[i], sizeof(XNADDR)) == 0);
            Verify(memcmp(&xnkidT, pxnkid, sizeof(XNKID)) == 0);
        }
    }

    Verify(XNetUnregisterKey(&xnkid1) == 0);
    Verify(XNetUnregisterKey(&xnkid3) == 0);

    printf("[OK]\n");
}
XNETTEST_END(XNetXnAddrToInAddr)

// Test_Broadcast ------------------------------------------------------------------------

IPTEST_BEG(Broadcast_1, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, XNET_STARTUP_BYPASS_SECURITY)
{
    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);

    _uiFlags = PKTF_TYPE_UDP_ESP|PKTF_CRYPT;

    for (int i = 0; i < 2; ++i)
    {
        Rand(_ab, sizeof(_ab));

        CPacket *   ppkt    = PacketAlloc(0, _uiFlags, sizeof(_ab));
        CUdpHdr *   pUdpHdr = ppkt->GetUdpHdr();
        memcpy(pUdpHdr + 1, _ab, sizeof(_ab));
        pUdpHdr->_ipportDst = HTONS(666);
        pUdpHdr->_ipportSrc = HTONS(666);
        pUdpHdr->_wLen      = HTONS(sizeof(CUdpHdr) + sizeof(_ab));
        IpFillAndXmit(ppkt, IPADDR_BROADCAST, IPPROTOCOL_UDP, NULL);
        Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
        _uiFlags = PKTF_TYPE_UDP;
    }
}

virtual void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    Verify(ppkt->IsUdp());
    Verify(pIpHdr->_ipaDst.IsBroadcast());
    Verify(!!ppkt->TestFlags(PKTF_TYPE_ESP) == !!(_uiFlags & PKTF_TYPE_ESP));
    Verify(!!ppkt->TestFlags(PKTF_CRYPT) == !!(_uiFlags & PKTF_CRYPT));
    Verify(pUdpHdr->_ipportDst == HTONS(666));
    Verify(pUdpHdr->_ipportSrc == HTONS(666));
    Verify(NTOHS(pUdpHdr->_wLen) == sizeof(CUdpHdr) + sizeof(_ab));
    Verify(memcmp(pUdpHdr + 1, _ab, sizeof(_ab)) == 0);
    SetEvent(_hEvent);
}

UINT _uiFlags;
HANDLE _hEvent;
BYTE _ab[211];

IPTEST_END(Broadcast_1);

IPTEST_BEG(Broadcast_2, "xb2@Lan", "10.0.0.2", "255.0.0.0", NULL, XNET_STARTUP_BYPASS_SECURITY)
{
    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);

    for (int i = 0; i < 2; ++i)
    {
        Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    }
}

virtual void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    Verify(pIpHdr->_ipaDst.IsBroadcast());
    UINT uiFlags = (ppkt->GetFlags() & (PKTF_TYPE_UDP|PKTF_TYPE_ESP|PKTF_CRYPT));
    CPacket * ppktNew = PacketAlloc(PTAG_CPacket, PKTF_POOLALLOC|uiFlags, cbLen);
    memcpy(ppktNew->GetUdpHdr(), pUdpHdr, sizeof(CUdpHdr) + cbLen);
    IpFillAndXmit(ppktNew, IPADDR_BROADCAST, IPPROTOCOL_UDP, NULL);
    SetEvent(_hEvent);
}

HANDLE _hEvent;

IPTEST_END(Broadcast_2);

TWOTHREADTEST(Broadcast)
{
    printf("Testing Broadcast ");
    TWOTHREADRUN(Broadcast);
    printf("[OK]\n");
}

// Test_Discovery ------------------------------------------------------------------------

#define DISCOVERY_UNICAST       200

IPTEST_BEG(Discovery_1, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    // This is the host of the "game session".  We create a key and register it.

    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    Verify(IpCreateKey(&_xnkid, &_xnkey) == 0);
    IpGetXnAddr(&_xnaddr);
    Verify(IpRegisterKey(&_xnkid, &_xnkey) == 0);
    _fListening = TRUE;

    // Now we wait for discovery requests and respond with a discovery response.
    // This event will be signalled as soon as we've responded.

    Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    Verify(_cBroadcast > 0);

    // Now we wait for a stream of unicast UDP packets from the client

    while (_cUnicast < DISCOVERY_UNICAST)
    {
        Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    }

    Verify(IpUnregisterKey(&_xnkid) == 0);
}

virtual void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    if (pIpHdr->_ipaDst.IsBroadcast())
    {
        if (!_fListening)
        {
            TraceSz(Warning, "Dropping discovery request that arrived too early");
            return;
        }

        Verify(cbLen == sizeof(CDiscReq));
        Verify(pUdpHdr->_ipportDst == HTONS(666));
        Verify(pUdpHdr->_ipportSrc == HTONS(666));
        CDiscReq *  pDiscReq    = (CDiscReq *)(pUdpHdr + 1);
        CPacket *   ppktNew     = PacketAlloc(PTAG_CPacket, PKTF_POOLALLOC|PKTF_TYPE_UDP_ESP|PKTF_CRYPT, sizeof(CDiscRsp));
        CUdpHdr *   pUdpHdrNew  = ppktNew->GetUdpHdr();
        pUdpHdrNew->_ipportDst  = HTONS(666);
        pUdpHdrNew->_ipportSrc  = HTONS(666);
        pUdpHdrNew->_wLen       = HTONS(sizeof(CUdpHdr) + sizeof(CDiscRsp));
        CDiscRsp *  pDiscRsp    = (CDiscRsp *)(pUdpHdrNew + 1);
        memcpy(pDiscRsp->abNonce, pDiscReq->abNonce, sizeof(pDiscReq->abNonce));
        pDiscRsp->xnkid         = _xnkid;
        pDiscRsp->xnkey         = _xnkey;
        pDiscRsp->xnaddr        = _xnaddr;
        IpFillAndXmit(ppktNew, IPADDR_BROADCAST, IPPROTOCOL_UDP, NULL);
        _cBroadcast += 1;
        SetEvent(_hEvent);
        return;
    }

    CIpAddr ipaSrc = pIpHdr->_ipaSrc;
    XNKID   xnkid;
    XNADDR  xnaddr;
    Verify(IpInAddrToXnAddr(ipaSrc, &xnaddr, &xnkid) == 0);
    Verify(memcmp(&xnkid, &_xnkid, sizeof(XNKID)) == 0);
    Verify(ppkt->GetEnetHdr()->_eaSrc.IsEqual(xnaddr.abEnet));
    UINT uiFlags = ppkt->GetFlags() & (PKTF_TYPE_UDP|PKTF_TYPE_ESP|PKTF_CRYPT);
    CPacket * ppktNew = PacketAlloc(PTAG_CPacket, PKTF_POOLALLOC|uiFlags, cbLen);
    memcpy(ppktNew->GetUdpHdr(), pUdpHdr, sizeof(CUdpHdr) + cbLen);
    IpFillAndXmit(ppktNew, ipaSrc, IPPROTOCOL_UDP, NULL);
    _cUnicast += 1;
    SetEvent(_hEvent);
}

HANDLE _hEvent;
XNKID _xnkid;
XNKEY _xnkey;
XNADDR _xnaddr;
BOOL _fListening;
UINT _cBroadcast;
UINT _cUnicast;

IPTEST_END(Discovery_1);

IPTEST_BEG(Discovery_2, "xb2@Lan", "10.0.0.2", "255.0.0.0", NULL, 0)
{
    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);

    // Until we get a response, keep broadcasting a CDiscReq packet

    Rand(_abNonce, sizeof(_abNonce));

    while (_cBroadcast == 0)
    {
        CPacket * ppkt = PacketAlloc(0, PKTF_TYPE_UDP_ESP|PKTF_CRYPT, sizeof(CDiscReq));
        CUdpHdr * pUdpHdr = ppkt->GetUdpHdr();
        CDiscReq * pDiscReq = (CDiscReq *)(pUdpHdr + 1);
        pUdpHdr->_ipportDst  = HTONS(666);
        pUdpHdr->_ipportSrc  = HTONS(666);
        pUdpHdr->_wLen       = HTONS(sizeof(CUdpHdr) + sizeof(CDiscReq));
        memcpy(pDiscReq->abNonce, _abNonce, sizeof(_abNonce));
        IpFillAndXmit(ppkt, IPADDR_BROADCAST, IPPROTOCOL_UDP, NULL);
        WaitForSingleObject(_hEvent, 200);
    }

    // Register the host's key

    Verify(IpRegisterKey(&_xnkid, &_xnkey) == 0);

    // Get a secure IP address for the host

    CIpAddr ipaHost;

    Verify(IpXnAddrToInAddr(&_xnaddr, &_xnkid, &ipaHost) == 0);

    // Send Unicast UDP packets

    Rand(_ab, sizeof(_ab));

    UINT i;

    for (i = 0; i < DISCOVERY_UNICAST; ++i)
    {
        UINT uiFlags = PKTF_TYPE_UDP_ESP|PKTF_CRYPT;
        CPacket * ppkt = PacketAlloc(0, uiFlags, sizeof(_ab));
        CUdpHdr * pUdpHdr = ppkt->GetUdpHdr();
        pUdpHdr->_ipportDst  = HTONS(666);
        pUdpHdr->_ipportSrc  = HTONS(666);
        pUdpHdr->_wLen       = HTONS(sizeof(CUdpHdr) + sizeof(_ab));
        memcpy(pUdpHdr + 1, _ab, sizeof(_ab));
        IpFillAndXmit(ppkt, ipaHost, IPPROTOCOL_UDP, NULL);

        // Don't get too far ahead of the other side

        while (_cUnicast + 6 < i)
        {
            Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
        }
    }

    // Wait for the remaining packets to be reflected

    while (_cUnicast < i)
    {
        Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    }

    Verify(IpUnregisterKey(&_xnkid) == 0);
}

virtual void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    if (pIpHdr->_ipaDst.IsBroadcast())
    {
        Verify(cbLen == sizeof(CDiscRsp));
        Verify(pUdpHdr->_ipportDst == HTONS(666));
        Verify(pUdpHdr->_ipportSrc == HTONS(666));
        CDiscRsp * pDiscRsp = (CDiscRsp *)(pUdpHdr + 1);
        Verify(memcmp(pDiscRsp->abNonce, _abNonce, sizeof(_abNonce)) == 0);
        _xnkid = pDiscRsp->xnkid;
        _xnkey = pDiscRsp->xnkey;
        _xnaddr = pDiscRsp->xnaddr;
        _cBroadcast += 1;
        SetEvent(_hEvent);
        return;
    }

    Verify(pUdpHdr->_ipportDst == HTONS(666));
    Verify(pUdpHdr->_ipportSrc == HTONS(666));
    Verify(cbLen == sizeof(_ab));
    Verify(memcmp(pUdpHdr + 1, _ab, sizeof(_ab)) == 0);
    _cUnicast += 1;
    SetEvent(_hEvent);
}

HANDLE _hEvent;
XNKID _xnkid;
XNKEY _xnkey;
XNADDR _xnaddr;
BYTE _abNonce[8];
BYTE _ab[592];
UINT _cBroadcast;
UINT _cUnicast;

IPTEST_END(Discovery_2);

TWOTHREADTEST(Discovery)
{
    printf("Testing Discovery ");
    TWOTHREADRUN(Discovery);
    printf("[OK]\n");
}

// Test_Frag -----------------------------------------------------------------------------

#define FRAGALG_FORWARD     0
#define FRAGALG_REVERSE     1
#define FRAGALG_RANDOM      2
#define FRAGALG_OVERLAP     3
#define FRAGALG_COUNT       4

DefineTag(fragTest, 0);

IPTEST_BEG(Frag, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);

    for (int iAlg = 0; iAlg < FRAGALG_COUNT; ++iAlg)
    {
        printf("Testing Fragment Reassembler (%s) ",
               iAlg == FRAGALG_FORWARD ? "forward" :
               iAlg == FRAGALG_REVERSE ? "reverse" :
               iAlg == FRAGALG_RANDOM ? "random" : "overlap");

        if (iAlg == FRAGALG_RANDOM)
        {
            printf(" ");
        }

        for (int cbHdrOpt = 0; cbHdrOpt <= (MAXIPHDRLEN-sizeof(CIpHdr)); cbHdrOpt += 4)
        {
            printf(".");

            for (int cbData = 1; cbData < (int)(ENET_DATA_MAXSIZE - sizeof(CIpHdr) - cbHdrOpt - sizeof(CUdpHdr)); )
            {
                int cbChunk = 8;

                while (1)
                {
                    TestFrag(cbHdrOpt, cbData, iAlg, cbChunk);

                    if (cbChunk < 64)
                        cbChunk += 8;
                    else
                        cbChunk += 32;

                    if (cbChunk > (int)((cbData + sizeof(CUdpHdr)) / 2))
                        break;
                }

                if (cbData < 63)
                    cbData += 1;
                else if (cbData < 253)
                    cbData += 51;
                else
                    cbData += 127;
            }
        }

        printf(" [OK]\n");
    }

    CloseHandle(_hEvent);
}

void TestFrag(int cbHdrOpt, int cbData, int iAlg, int cbChunk)
{
    CIpHdr *        pIpHdr;
    CUdpHdr *       pUdpHdr;
    CPseudoHeader   ph;
    UINT            uiChecksum;
    int             iChunk;
    int             cChunk;

    TraceSz4(fragTest, "cbHdrOpt=%d,cbData=%d,iAlg=%d,cbChunk=%d", cbHdrOpt, cbData, iAlg, cbChunk);

    ResetEvent(_hEvent);

    // Create the original packet

    _ppktOrig = PacketAlloc(0, PKTF_TYPE_UDP, cbHdrOpt + cbData);
    Verify(_ppktOrig != NULL);

    pIpHdr              = _ppktOrig->GetIpHdr();
    pIpHdr->SetHdrLen(sizeof(CIpHdr) + cbHdrOpt);
    pIpHdr->_bTos       = 0;
    pIpHdr->_wLen       = HTONS(sizeof(CIpHdr) + cbHdrOpt + sizeof(CUdpHdr) + cbData);
    pIpHdr->_wId        = HTONS(GetNextDgramId());
    pIpHdr->_wFragOff   = 0;
    pIpHdr->_bTtl       = 64;
    pIpHdr->_bProtocol  = IPPROTOCOL_UDP;
    pIpHdr->_ipaSrc     = IPADDR_LOOPBACK;
    pIpHdr->_ipaDst     = IPADDR_LOOPBACK;
    Rand((BYTE *)(pIpHdr + 1), cbHdrOpt);
    pIpHdr->_wChecksum  = 0;
    pIpHdr->_wChecksum  = ~tcpipxsum(0, pIpHdr, sizeof(CIpHdr) + cbHdrOpt);

    _ppktOrig->SetHdrOptLen(cbHdrOpt);

    pUdpHdr             = _ppktOrig->GetUdpHdr();
    pUdpHdr->_ipportSrc = HTONS(666);
    pUdpHdr->_ipportDst = HTONS(666);
    pUdpHdr->_wLen      = HTONS(sizeof(CUdpHdr) + cbData);
    pUdpHdr->_wChecksum = 0;
    Rand((BYTE *)(pUdpHdr + 1), cbData);
    ph._ipaSrc          = pIpHdr->_ipaSrc;
    ph._ipaDst          = pIpHdr->_ipaDst;
    ph._bZero           = 0;
    ph._bProtocol       = IPPROTOCOL_UDP;
    ph._wLen            = HTONS(sizeof(CUdpHdr) + cbData);
    pUdpHdr->_wChecksum = 0;
    uiChecksum          = ~tcpipxsum(tcpipxsum(0, &ph, sizeof(ph)), pUdpHdr, sizeof(CUdpHdr) + cbData);
    pUdpHdr->_wChecksum = uiChecksum - (uiChecksum == 0);

    TraceUdpHdr(fragTest, 0, pUdpHdr, pUdpHdr->GetLen() - sizeof(CUdpHdr));
    TraceSz9(fragTest, "[IP %s %s (%d %d %04X %04X) %d]{%d}[%d]",
             pIpHdr->_ipaDst.Str(), pIpHdr->_ipaSrc.Str(), pIpHdr->_bTos, pIpHdr->_bTtl,
             NTOHS(pIpHdr->_wId), NTOHS(pIpHdr->_wFragOff), pIpHdr->_bProtocol,
             pIpHdr->GetOptLen(), _ppktOrig->GetCb() - pIpHdr->GetHdrLen());

    // Create and send packet fragments

    cbData += sizeof(CUdpHdr);
    cChunk  = (cbData + cbChunk - 1) / cbChunk;

    if (iAlg == FRAGALG_FORWARD)
    {
        for (iChunk = 0; iChunk < cChunk; ++iChunk)
        {
            SendChunk(iChunk, 1, cbChunk, iChunk == (cChunk - 1));
        }
    }
    else if (iAlg == FRAGALG_REVERSE)
    {
        for (iChunk = cChunk - 1; iChunk >= 0; --iChunk)
        {
            SendChunk(iChunk, 1, cbChunk, iChunk == (cChunk - 1));
        }
    }
    else if (iAlg == FRAGALG_RANDOM || iAlg == FRAGALG_OVERLAP)
    {
        BYTE abMap[ENET_DATA_MAXSIZE / 8];
        int cChunkSent = 0;

        memset(abMap, 0, sizeof(abMap));

        while (cChunkSent < cChunk)
        {
            // Randomly select a chunk to send.  If that chunk is already sent,
            // look for the next one that isn't sent yet.

            int iChunkRand = rand() % cChunk;

            while (abMap[iChunkRand])
            {
                iChunkRand += 1;
                if (iChunkRand == cChunk)
                    iChunkRand = 0;
            }

            if (iAlg == FRAGALG_OVERLAP)
            {
                int iChunkBeg = iChunkRand;
                int iChunkEnd = iChunkRand;

                if (iChunkBeg > 0)
                {
                    // Back up a random number of chunks (no more than 4)

                    iChunkBeg -= rand() % (min(4, iChunkBeg));
                    Verify(iChunkBeg >= 0);
                }

                if (iChunkEnd < (cChunk - 1))
                {
                    // Extend the range a random number of chunks (no more than 4)

                    iChunkEnd += rand() % (cChunk - iChunkEnd);
                    Verify(iChunkEnd < cChunk);
                }

                if (iChunkBeg == 0 && iChunkEnd == (cChunk - 1))
                {
                    // Whoops.  Can't send the whole thing in one chunk.

                    if (iChunkBeg != iChunkRand)
                        iChunkBeg += 1;
                    else
                    {
                        Verify(iChunkEnd != iChunkRand);
                        iChunkEnd -= 1;
                    }
                }

                Verify(iChunkBeg >= 0);
                Verify(iChunkEnd < cChunk);

                for (iChunkRand = iChunkBeg; iChunkRand <= iChunkEnd; ++iChunkRand)
                {
                    if (abMap[iChunkRand] == 0)
                    {
                        abMap[iChunkRand] = 1;
                        cChunkSent += 1;
                        Verify(cChunkSent <= cChunk);
                    }
                }

                SendChunk(iChunkBeg, iChunkEnd - iChunkBeg + 1, cbChunk, iChunkEnd == (cChunk - 1));
            }
            else
            {
                abMap[iChunkRand] = 1;
                cChunkSent += 1;
                Verify(cChunkSent <= cChunk);
                SendChunk(iChunkRand, 1, cbChunk, iChunkRand == (cChunk - 1));
            }
        }
    }

    // Wait for the packet to arrive

    Verify(WaitForSingleObject(_hEvent, 1000) == WAIT_OBJECT_0);

    PacketFree(_ppktOrig);
    _ppktOrig = NULL;
}

void SendChunk(int iChunk, int cChunk, int cbChunk, BOOL fLastChunk)
{
    CIpHdr *    pIpHdrOrig   = _ppktOrig->GetIpHdr();
    int         cbHdrOptOrig = pIpHdrOrig->GetOptLen();
    int         cbDataOrig   = _ppktOrig->GetCb() - sizeof(CIpHdr) - cbHdrOptOrig;
    int         cbHdrOpt     = iChunk == 0 ? cbHdrOptOrig : 0;
    int         ibData       = iChunk * cbChunk;
    int         cbData       = cChunk * cbChunk;

    Verify(ibData < cbDataOrig);

    if (ibData + cbData >= cbDataOrig)
    {
        cbData = cbDataOrig - ibData;
        Verify(fLastChunk);
    }

    Verify(cbData > 0);
    Verify(!fLastChunk || iChunk > 0);

    CPacket *   ppkt    = PacketAlloc(0, PKTF_TYPE_IP, cbHdrOpt + cbData);
    Verify(ppkt != NULL);

    CIpHdr *    pIpHdr  = ppkt->GetIpHdr();
    memcpy(pIpHdr, pIpHdrOrig, sizeof(CIpHdr) + cbHdrOpt);
    pIpHdr->SetHdrLen(sizeof(CIpHdr) + cbHdrOpt);
    pIpHdr->_wLen       = NTOHS((WORD)(sizeof(CIpHdr) + cbHdrOpt + cbData));
    pIpHdr->_wFragOff   = NTOHS((WORD)((iChunk * (cbChunk / 8)) | (fLastChunk ? 0 : MORE_FRAGMENTS)));
    pIpHdr->_wChecksum  = 0;
    pIpHdr->_wChecksum  = ~tcpipxsum(0, pIpHdr, pIpHdr->GetHdrLen());
    memcpy((BYTE *)(pIpHdr + 1) + cbHdrOpt, (BYTE *)(pIpHdrOrig + 1) + cbHdrOptOrig + ibData, cbData);

    RaiseToDpc();
    IpXmit(ppkt);
}

void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen)
{
    Verify(ppkt->GetCb() == _ppktOrig->GetCb());
    Verify(memcmp(ppkt->GetPv(), _ppktOrig->GetPv(), ppkt->GetCb()) == 0);
    SetEvent(_hEvent);
}

CPacket *   _ppktOrig;
HANDLE      _hEvent;

IPTEST_END(Frag);

// Test_SockUdp --------------------------------------------------------------------------

XNETTEST_BEG(SockUdp_1, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    SOCKET s = SockUdpCreate(NTOHS(1567));
    XNKID xnkid;
    DiscoveryHost(1, &xnkid);
    SockUdpReflect(s);
    Verify(closesocket(s) == 0);
    Verify(XNetUnregisterKey(&xnkid) == 0);
}
XNETTEST_END(SockUdp_1);

XNETTEST_BEG(SockUdp_2, "xb2@Lan", "10.0.0.2", "255.0.0.0", NULL, 0)
{
    SOCKET s = SockUdpCreate(CIpPort(NTOHS(6543)));
    XNKID xnkid;
    CIpAddr ipa;
    DiscoveryClient(&xnkid, &ipa);
    SockUdpTransmit(s, ipa, CIpPort(NTOHS(1567)));
    Verify(closesocket(s) == 0);
    Verify(XNetUnregisterKey(&xnkid) == 0);
}
XNETTEST_END(SockUdp_2);

TWOTHREADTEST(SockUdp)
{
    printf("Testing SockUdp ");
    TWOTHREADRUN(SockUdp);
    printf(" [OK]\n");
}

// Test_SockTcp --------------------------------------------------------------------------

XNETTEST_BEG(SockTcp_1, "xb1@Lan", "10.0.0.1", "255.0.0.0", NULL, 0)
{
    SOCKET s1 = SockTcpCreate(NTOHS(1567));
    Verify(listen(s1, 1) == 0);
    XNKID xnkid;
    DiscoveryHost(1, &_xnkid);
    sockaddr_in sin;
    int slen = sizeof(sin);
    SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
    Verify(s2 != SOCKET_ERROR);
    Verify(slen == sizeof(sin));
    SockTcpReflect(s2);
    Verify(closesocket(s2) == 0);
    Verify(closesocket(s1) == 0);
}

virtual void Term()
{
    Verify(XNetUnregisterKey(&_xnkid) == 0);
    CTestXNet::Term();
}

XNKID _xnkid;

XNETTEST_END(SockTcp_1);

XNETTEST_BEG(SockTcp_2, "xb2@Lan", "10.0.0.2", "255.0.0.0", NULL, 0)
{
    SOCKET s = SockTcpCreate();
    XNKID xnkid;
    CIpAddr ipa;
    DiscoveryClient(&_xnkid, &ipa);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = ipa;
    sin.sin_port = NTOHS(1567);
    Verify(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != SOCKET_ERROR);
    SockTcpTransmit(s);
    Verify(closesocket(s) == 0);
}

virtual void Term()
{
    Verify(XNetUnregisterKey(&_xnkid) == 0);
    CTestXNet::Term();
}

XNKID _xnkid;

XNETTEST_END(SockTcp_2);

TWOTHREADTEST(SockTcp)
{
    printf("Testing SockTcp ");
    TWOTHREADRUN(SockTcp);
    printf(" [OK]\n");
}

// Test_Dhcp -----------------------------------------------------------------------------

#include <pshpack1.h>

struct DhcpMessage
{
    CEnetHdr        _enethdr;           // [ENET]
    CIpHdr          _iphdr;             // [IP]
    CUdpHdr         _udphdr;            // [UDP]
    BYTE            _op;                // message type
    BYTE            _htype;             // hareware address type
    BYTE            _hlen;              // hardware address length
    BYTE            _hops;              // relay hops
    DWORD           _xid;               // transaction ID
    WORD            _secs;              // seconds since address acquisition process began
    WORD            _flags;             // flags
    CIpAddr         _ciaddr;            // client IP address
    CIpAddr         _yiaddr;            // "your" (client) IP address
    CIpAddr         _siaddr;            // server IP address
    CIpAddr         _giaddr;            // relay agent IP address
    BYTE            _chaddr[16];        // client hardware address
    BYTE            _sname[64];         // optional server hostname
    BYTE            _file[128];         // boot filename
    BYTE            _options[256];      // optional parameters (variable length)
};

#include <poppack.h>

BYTE abDhcpResp[] =
{
    0x00,0x50,0xF2,0x00,0x17,0xFC,0x00,0x90,0x27,0xCC,0x74,0x7C,0x08,0x00,0x45,0x10,
    0x01,0x4E,0x00,0x00,0x00,0x00,0x10,0x11,0x9F,0x47,0x0A,0x47,0x00,0x02,0xFF,0xFF,
    0xFF,0xFF,0x00,0x43,0x00,0x44,0x01,0x3A,0xB4,0xF7,0x02,0x01,0x06,0x00,0x39,0x73,
    0xDD,0x20,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x0A,0x47,0xFE,0x63,0x0A,0x47,
    0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x50,0xF2,0x00,0x17,0xFC,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x82,0x53,0x63,0x35,0x01,0x02,0x36,0x04,0x0A,
    0x47,0x00,0x02,0x33,0x04,0x00,0x00,0x46,0x50,0x01,0x04,0xFF,0xFF,0x00,0x00,0x03,
    0x04,0x0A,0x47,0x00,0x01,0x06,0x0C,0x0A,0x47,0x00,0x02,0x0A,0x49,0x00,0x02,0xD1,
    0xF9,0xE0,0x82,0x0F,0x16,0x73,0x61,0x6E,0x6A,0x6F,0x73,0x65,0x2E,0x69,0x6E,0x66,
    0x6F,0x67,0x72,0x61,0x6D,0x65,0x73,0x2E,0x6C,0x6F,0x63,0xFF
};

BYTE abDhcpAck[] =
{
    0x00,0x50,0xF2,0x00,0x17,0xFC,0x00,0x90,0x27,0xCC,0x74,0x7C,0x08,0x00,0x45,0x10,
    0x01,0x4E,0x00,0x00,0x00,0x00,0x10,0x11,0x9F,0x47,0x0A,0x47,0x00,0x02,0xFF,0xFF,
    0xFF,0xFF,0x00,0x43,0x00,0x44,0x01,0x3A,0xB1,0xF6,0x02,0x01,0x06,0x00,0x39,0x73,
    0xDD,0x21,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x0A,0x47,0xFE,0x63,0x0A,0x47,
    0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x50,0xF2,0x00,0x17,0xFC,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x82,0x53,0x63,0x35,0x01,0x05,0x36,0x04,0x0A,
    0x47,0x00,0x02,0x33,0x04,0x00,0x00,0x46,0x50,0x01,0x04,0xFF,0xFF,0x00,0x00,0x03,
    0x04,0x0A,0x47,0x00,0x01,0x06,0x0C,0x0A,0x47,0x00,0x02,0x0A,0x49,0x00,0x02,0xD1,
    0xF9,0xE0,0x82,0x0F,0x16,0x73,0x61,0x6E,0x6A,0x6F,0x73,0x65,0x2E,0x69,0x6E,0x66,
    0x6F,0x67,0x72,0x61,0x6D,0x65,0x73,0x2E,0x6C,0x6F,0x63,0xFF
};

IPTEST_BEG(Dhcp, "xb1@Lan", NULL, NULL, NULL, 0)
{
    printf("Testing Dhcp ");
    XNADDR xnaddr;
    while (IpGetXnAddr(&xnaddr) == XNET_GET_XNADDR_PENDING)
        Sleep(100);
	Verify(xnaddr.ina.s_addr == inet_addr("10.71.254.99"));
    printf("[OK]\n");
}

virtual void EnetXmit(CPacket * ppkt, CIpAddr ipaNext)
{
    DhcpMessage * pdhcpMsg = (DhcpMessage *)ppkt->GetEnetHdr();
    DhcpMessage   dhcpMsg;

    BYTE * pb = abDhcpResp;
    UINT   cb = sizeof(abDhcpResp);

    if (_fGotDiscover)
    {
        pb = abDhcpAck;
        cb = sizeof(abDhcpAck);
    }

    Assert(sizeof(dhcpMsg) >= cb);
    memcpy(&dhcpMsg, pb, cb);

    memcpy(dhcpMsg._chaddr, _ea._ab, sizeof(_ea._ab));
    dhcpMsg._xid = pdhcpMsg->_xid;
    dhcpMsg._enethdr._eaDst = _ea;

    CPseudoHeader ph;
    ph._ipaSrc      = dhcpMsg._iphdr._ipaSrc;
    ph._ipaDst      = dhcpMsg._iphdr._ipaDst;
    ph._bZero       = 0;
    ph._bProtocol   = IPPROTOCOL_UDP;
    ph._wLen        = dhcpMsg._udphdr._wLen;
    dhcpMsg._udphdr._wChecksum = 0;
    UINT uiChecksum = ~tcpipxsum(tcpipxsum(0, &ph, sizeof(ph)), &dhcpMsg._udphdr, NTOHS(ph._wLen));
    dhcpMsg._udphdr._wChecksum = uiChecksum - (uiChecksum == 0);

    NicRecvFrame(&dhcpMsg, cb);

    CXnEnet::EnetXmit(ppkt, 0);

    _fGotDiscover = TRUE;
}

BOOL _fGotDiscover;

IPTEST_END(Dhcp)

// Test_Dns ------------------------------------------------------------------------------

XNETTEST_BEG(Dns, "xb1@Nic/0:FEFFDEADF00D", NULL, NULL, NULL, 0)
{
    printf("Testing Dns ");

    if (!VLanDriver())
    {
        printf("[No VLan]\n");
        return;
    }

    XNADDR xnaddr;
    while (XNetGetTitleXnAddr(&xnaddr) == XNET_GET_XNADDR_PENDING)
        Sleep(100);
    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    
    XNDNS * pxndns = NULL;

    Verify(XNetDnsLookup("nosuchhost.foo.bar.com", _hEvent, &pxndns) == 0);
    Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    Verify(pxndns->iStatus == WSAHOST_NOT_FOUND);
    Verify(pxndns->cina == 0);
    Verify(XNetDnsRelease(pxndns) == 0);

    Verify(XNetDnsLookup("products.redmond.corp.microsoft.com", _hEvent, &pxndns) == 0);
    Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    Verify(pxndns->iStatus == 0);
    Verify(pxndns->cina > 0);
    Verify(XNetDnsRelease(pxndns) == 0);

    Verify(XNetDnsLookup("products.redmond.corp.microsoft.com", NULL, &pxndns) == 0);
    while (pxndns->iStatus == WSAEINPROGRESS)
        Sleep(100);
    Verify(pxndns->iStatus == 0);
    Verify(pxndns->cina > 0);
    Verify(XNetDnsRelease(pxndns) == 0);

    CloseHandle(_hEvent);
    printf("[OK]\n");
}

HANDLE _hEvent;

XNETTEST_END(Dns)

// Test_SgUdp ----------------------------------------------------------------------------

XNETTEST_BEG(SgUdp_1, "xb1@Internet", "10.0.0.10", "255.0.0.0", "10.0.0.1", 0)
{
    GetXn()->IpLogon(0, NULL, NULL);
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    SockUdpTransmit(s, inaSec.s_addr, CIpPort(NTOHS(1)));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgUdp_1)

XNETTEST_BEG(SgUdp_2, "xb2@Datacenter", "10.0.0.4", "255.0.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(127));
    SockUdpReflect(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgUdp_2)

TWOTHREADTEST(SgUdp)
{
    printf("Testing SgUdp ");
    TWOTHREADRUN(SgUdp);
    printf(" [OK]\n");
}

// Test_SgTcp ----------------------------------------------------------------------------

XNETTEST_BEG(SgTcp_1, "xb1@Internet", "10.0.0.11", "255.0.0.0", "10.0.0.1", 0)
{
    GetXn()->IpLogon(0, NULL, NULL);
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = HTONS(2);
    Verify(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != SOCKET_ERROR);
    SockTcpTransmit(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgTcp_1)

XNETTEST_BEG(SgTcp_2, "xb2@Datacenter", "10.0.0.5", "255.0.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s1 = SockTcpCreate(HTONS(80));
    Verify(listen(s1, 1) == 0);
    sockaddr_in sin;
    int slen = sizeof(sin);
    SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
    Verify(s2 != SOCKET_ERROR);
    Verify(slen == sizeof(sin));
    SockTcpReflect(s2);
    Verify(closesocket(s2) == 0);
    Verify(closesocket(s1) == 0);
}
XNETTEST_END(SgTcp_2)

TWOTHREADTEST(SgTcp)
{
    printf("Testing SgTcp ");
    TWOTHREADRUN(SgTcp);
    printf(" [OK]\n");
}

// Test_SgRst ----------------------------------------------------------------------------

XNETTEST_BEG(SgRst_1, "xb1@Internet", "10.0.0.11", "255.0.0.0", "10.0.0.1", 0)
{
    GetXn()->IpLogon(0, NULL, NULL);
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = HTONS(2);
    Verify(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != SOCKET_ERROR);
    Verify(recv(s, (char *)&s, 1, 0) == 1);
    Verify(XNetUnregisterInAddr(inaSec) == 0);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgRst_1)

XNETTEST_BEG(SgRst_2, "xb2@Datacenter", "10.0.0.5", "255.0.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s1 = SockTcpCreate(HTONS(80));
    Verify(listen(s1, 1) == 0);
    sockaddr_in sin;
    int slen = sizeof(sin);
    SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
    Verify(s2 != SOCKET_ERROR);
    Verify(slen == sizeof(sin));

    while (1)
    {
        INT err = send(s2, (char *)&s2, 1, 0);

        if (err == SOCKET_ERROR)
        {
            Verify(WSAGetLastError() == WSAECONNRESET);
            break;
        }

        Sleep(100);
    }

    Verify(closesocket(s2) == 0);
    Verify(closesocket(s1) == 0);
}
XNETTEST_END(SgRst_2)

TWOTHREADTEST(SgRst)
{
    printf("Testing SgRst ");
    TWOTHREADRUN(SgRst);
    printf("[OK]\n");
}

// Test_SgAlive --------------------------------------------------------------------------

XNETTEST_BEG(SgAlive_1, "xb1@Internet", "10.0.0.10", "255.0.0.0", "10.0.0.1", 0)
{
    GetXn()->IpLogon(0, NULL, NULL);
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = NTOHS(3);
    Verify(sendto(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(inaVip));

    // Sleep for a while to allow keepalives to flow
    Sleep(60 * 1000);

    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = NTOHS(3);
    Verify(sendto(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(inaVip));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgAlive_1)

XNETTEST_BEG(SgAlive_2, "xb2@Datacenter", "10.0.0.6", "255.0.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(123));

    IN_ADDR inaVip;
    sockaddr_in sin;
    int slen = sizeof(sin);
    
    Verify(recvfrom(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, &slen) == sizeof(inaVip));
    Verify(inaVip.s_addr == inet_addr("10.0.0.2"));

    CSgMsgAuthReq   sgar;

    sgar._wType   = SGMSG_TYPE_AUTHDATA_REQ;
    sgar._cbEnt   = sizeof(CSgMsgAuthReq);
    XNetRandom((BYTE *)&sgar._dwReqNum, sizeof(sgar._dwReqNum));
    sgar._ipaZ    = sin.sin_addr;
    sgar._ipportZ = sin.sin_port;
    
    sin.sin_port = NTOHS(0xFFFF);
    Verify(sendto(s, (char *)&sgar, sizeof(sgar), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(sgar));

    BYTE            ab[CBSGAUTHREPMSG];
    CSgMsgAuthRep * psgap     = (CSgMsgAuthRep *)ab;
    CSgMsgHdr *     psgmh     = (CSgMsgHdr *)(psgap + 1);
    CAuthData *     pAuthData = (CAuthData *)(psgmh + 1);

    slen = sizeof(sin);
    Verify(recvfrom(s, (char *)ab, sizeof(ab), 0, (struct sockaddr *)&sin, &slen) == sizeof(ab));
    Verify(psgap->_wType == SGMSG_TYPE_AUTHDATA_REP);
    Verify(psgap->_cbEnt == sizeof(CSgMsgAuthRep));
    Verify(psgap->_dwReqNum == sgar._dwReqNum);
    Verify(psgap->_ipaZ.s_addr == sgar._ipaZ.s_addr);
    Verify(psgap->_ipaI.s_addr == inet_addr("10.0.0.10"));
    Verify(psgap->_ipportZ == sgar._ipportZ);
    Verify(psgap->_fNotFound == FALSE);
    Verify(psgmh->_wType == SGMSG_TYPE_AUTHDATA);
    Verify(psgmh->_cbEnt == sizeof(CSgMsgHdr) + sizeof(CAuthData));
    Verify(pAuthData->GetCb() == sizeof(CAuthData));

    slen = sizeof(sin);
    Verify(recvfrom(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, &slen) == sizeof(inaVip));
    Verify(inaVip.s_addr == inet_addr("10.0.0.2"));

    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgAlive_2)

TWOTHREADTEST(SgAlive)
{
    printf("Testing SgAlive ");
    TWOTHREADRUN(SgAlive);
    printf("[OK]\n");
}

// Test_SgMsg ----------------------------------------------------------------------------

XNETTEST_BEG(SgMsg_1, "xb1@Internet", "10.0.0.10", "255.0.0.0", "10.0.0.1", 0)
{
    GetXn()->IpLogon(0, NULL, NULL);
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = NTOHS(3);
    Verify(sendto(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(inaVip));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgMsg_1)

XNETTEST_BEG(SgMsg_2, "xb2@Datacenter", "10.0.0.6", "255.0.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(123));

    IN_ADDR inaVip;
    sockaddr_in sin;
    int slen = sizeof(sin);
    
    Verify(recvfrom(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, &slen) == sizeof(inaVip));
    Verify(inaVip.s_addr == inet_addr("10.0.0.2"));

    CSgMsgAuthReq   sgar;

    sgar._wType   = SGMSG_TYPE_AUTHDATA_REQ;
    sgar._cbEnt   = sizeof(CSgMsgAuthReq);
    XNetRandom((BYTE *)&sgar._dwReqNum, sizeof(sgar._dwReqNum));
    sgar._ipaZ    = sin.sin_addr;
    sgar._ipportZ = sin.sin_port;
    
    sin.sin_port = NTOHS(0xFFFF);
    Verify(sendto(s, (char *)&sgar, sizeof(sgar), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(sgar));

    BYTE            ab[CBSGAUTHREPMSG];
    CSgMsgAuthRep * psgap     = (CSgMsgAuthRep *)ab;
    CSgMsgHdr *     psgmh     = (CSgMsgHdr *)(psgap + 1);
    CAuthData *     pAuthData = (CAuthData *)(psgmh + 1);

    slen = sizeof(sin);
    Verify(recvfrom(s, (char *)ab, sizeof(ab), 0, (struct sockaddr *)&sin, &slen) == sizeof(ab));
    Verify(psgap->_wType == SGMSG_TYPE_AUTHDATA_REP);
    Verify(psgap->_cbEnt == sizeof(CSgMsgAuthRep));
    Verify(psgap->_dwReqNum == sgar._dwReqNum);
    Verify(psgap->_ipaZ.s_addr == sgar._ipaZ.s_addr);
    Verify(psgap->_ipaI.s_addr == inet_addr("10.0.0.10"));
    Verify(psgap->_ipportZ == sgar._ipportZ);
    Verify(psgap->_fNotFound == FALSE);
    Verify(psgmh->_wType == SGMSG_TYPE_AUTHDATA);
    Verify(psgmh->_cbEnt == sizeof(CSgMsgHdr) + sizeof(CAuthData));
    Verify(pAuthData->GetCb() == sizeof(CAuthData));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgMsg_2)

TWOTHREADTEST(SgMsg)
{
    printf("Testing SgMsg ");
    TWOTHREADRUN(SgMsg);
    printf("[OK]\n");
}

// Test_SgLogon --------------------------------------------------------------------------

XNETTEST_BEG(SgLogon_1, "xb1@Internet", "10.0.0.10", "255.0.0.0", "10.0.0.1", 0)
{
    IN_ADDR inaVip, inaSec;
    HANDLE hEventLogon = NULL;
    ULONGLONG aqwUserId[4];
    XNKID axnkid[4];
    BYTE abData[32];
    UINT iUser;

    // Let the other thread start up so it doesn't miss our first UDP packet
    Sleep(500);

    XNetRandom((BYTE *)aqwUserId, sizeof(aqwUserId));
    XNetRandom((BYTE *)axnkid, sizeof(axnkid));
    XNetRandom(abData, sizeof(abData));

    inaVip.s_addr = inet_addr("10.0.0.2");
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    Verify((hEventLogon = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    GetXn()->IpLogon(inaSec.s_addr, aqwUserId, hEventLogon);
    Verify(WaitForSingleObject(hEventLogon, INFINITE) == WAIT_OBJECT_0);
    Verify(GetXn()->IpLogonGetStatus(NULL) == XN_LOGON_STATE_ONLINE);

    XNADDR xnaddr;
    Verify(XNetGetTitleXnAddr(&xnaddr) != XNET_GET_XNADDR_PENDING);

    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = NTOHS(3);
    Verify(sendto(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(inaVip));

    printf(".");

    for (iUser = 0; iUser < 4; ++iUser)
    {
        Verify(GetXn()->IpLogonSetPState(0, ~iUser, &axnkid[0], iUser ? (iUser + 1) * 2 : 0, &abData[iUser * 8]));
        printf(".");
    }

    // Sleep for a while to allow keepalives to flow
    for (int i = 0; i < 5; i++)
    {
        Sleep(4 * 1000);
        printf(".");
    }

    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = NTOHS(3);
    Verify(sendto(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(inaVip));
    Verify(closesocket(s) == 0);
    printf(".");

    GetXn()->IpLogoff();
    printf(".");

    CloseHandle(hEventLogon);
}
XNETTEST_END(SgLogon_1)

XNETTEST_BEG(SgLogon_2, "xb2@Datacenter", "10.0.0.6", "255.0.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(123));

    IN_ADDR inaVip;
    sockaddr_in sin;
    int slen = sizeof(sin);
    
    Verify(recvfrom(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, &slen) == sizeof(inaVip));
    Verify(inaVip.s_addr == inet_addr("10.0.0.2"));
    printf(".");

    CSgMsgAuthReq   sgar;

    sgar._wType   = SGMSG_TYPE_AUTHDATA_REQ;
    sgar._cbEnt   = sizeof(CSgMsgAuthReq);
    XNetRandom((BYTE *)&sgar._dwReqNum, sizeof(sgar._dwReqNum));
    sgar._ipaZ    = sin.sin_addr;
    sgar._ipportZ = sin.sin_port;
    
    sin.sin_port = NTOHS(0xFFFF);
    Verify(sendto(s, (char *)&sgar, sizeof(sgar), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(sgar));

    BYTE            ab[CBSGAUTHREPMSG];
    CSgMsgAuthRep * psgap     = (CSgMsgAuthRep *)ab;
    CSgMsgHdr *     psgmh     = (CSgMsgHdr *)(psgap + 1);
    CAuthData *     pAuthData = (CAuthData *)(psgmh + 1);

    slen = sizeof(sin);
    Verify(recvfrom(s, (char *)ab, sizeof(ab), 0, (struct sockaddr *)&sin, &slen) == sizeof(ab));
    Verify(psgap->_wType == SGMSG_TYPE_AUTHDATA_REP);
    Verify(psgap->_cbEnt == sizeof(CSgMsgAuthRep));
    Verify(psgap->_dwReqNum == sgar._dwReqNum);
    Verify(psgap->_ipaZ.s_addr == sgar._ipaZ.s_addr);
    Verify(psgap->_ipaI.s_addr == inet_addr("10.0.0.10"));
    Verify(psgap->_ipportZ == sgar._ipportZ);
    Verify(psgap->_fNotFound == FALSE);
    Verify(psgmh->_wType == SGMSG_TYPE_AUTHDATA);
    Verify(psgmh->_cbEnt == sizeof(CSgMsgHdr) + sizeof(CAuthData));
    Verify(pAuthData->GetCb() == sizeof(CAuthData));

    slen = sizeof(sin);
    Verify(recvfrom(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, &slen) == sizeof(inaVip));
    Verify(inaVip.s_addr == inet_addr("10.0.0.2"));

    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgLogon_2)

TWOTHREADTEST(SgLogon)
{
    printf("Testing SgLogon ");
    TWOTHREADRUN(SgLogon);
    printf(" [OK]\n");
}

// Test_XnSetEventTimer ------------------------------------------------------------------

IPTEST_BEG(XnSetEventTimer, "xb1@Internet", "10.0.0.1", "255.255.0.0", NULL, 0)
{
    printf("Testing XnSetEventTimer ");
    
    CEventTimer et;
    HANDLE hEvent;

    memset(&et, 0, sizeof(et));
    Verify((hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    DWORD dwTickBeg = GetTickCount();
    IpSetEventTimer(&et, hEvent, 1000);
    IpSetEventTimer(&et, hEvent, 0xFFFFFFFF);
    CloseHandle(hEvent);
    hEvent = NULL;

    for (DWORD dwTimeout = 50; dwTimeout < 1000; dwTimeout += 160)
    {
        for (int i = 0; i < 5; ++i)
        {
            memset(&et, 0, sizeof(et));
            Verify((hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
            DWORD dwTickBeg = GetTickCount();
            IpSetEventTimer(&et, hEvent, dwTimeout);
            Verify(WaitForSingleObject(hEvent, INFINITE) == WAIT_OBJECT_0);
            CloseHandle(hEvent);
            hEvent = NULL;
            DWORD dwTickEnd = GetTickCount();
            Verify(dwTickEnd - dwTickBeg > dwTimeout);
            printf(".");
            Sleep(17 * i);
        }
    }

    printf(" [OK]\n");
}
IPTEST_END(XnSetEventTimer);

// Test_NatDhcp --------------------------------------------------------------------------

XNETTEST_BEG(NatDhcp_1, "xb1@Nat1Inner", NULL, NULL, NULL, 0)
{
    XNADDR xnaddr;
    DWORD dw;

    while (1)
    {
        dw = XNetGetTitleXnAddr(&xnaddr);
        if (dw != XNET_GET_XNADDR_PENDING)
            break;
        Sleep(100);
    }

    Verify(dw & XNET_GET_XNADDR_DHCP);
}
XNETTEST_END(NatDhcp_1)

void Test_NatDhcp()
{
    for (UINT iAssign = NAT_ASSIGN_MINIMAL; iAssign <= NAT_ASSIGN_AGGRESSIVE; ++iAssign)
    {
        for (UINT iFilter = NAT_FILTER_NONE; iFilter <= NAT_FILTER_ADDRESS_PORT; ++iFilter)
        {
            printf("Testing NatDhcp %s/%s ", iAssign == NAT_ASSIGN_MINIMAL ? "min" : "agr",
                   iFilter == NAT_FILTER_NONE ? "none" : iFilter == NAT_FILTER_ADDRESS ? "addr" :
                   iFilter == NAT_FILTER_PORT ? "port" : "both");

            NATCREATE natcreate = { 0 };

            strcpy(natcreate._achXboxInner, "Nat@Nat1Inner");
            strcpy(natcreate._achXboxOuter, "Nat@Nat1Outer");

            natcreate._xncpInner.ina.s_addr         = inet_addr("10.0.0.1");
            natcreate._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._xncpOuter.ina.s_addr         = inet_addr("10.0.0.1");
            natcreate._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._inaBase.s_addr               = inet_addr("10.0.1.0");
            natcreate._inaLast.s_addr               = inet_addr("10.0.254.254");
            natcreate._dwLeaseTime                  = 60 * 60 * 24;
            natcreate._iAssign                      = iAssign;
            natcreate._iFilter                      = iFilter;

            void * pvNat = XNetNatCreate(&natcreate);
            Verify(pvNat != NULL);

            Test_NatDhcp_1();

            XNetNatDelete(pvNat);

            printf("[OK]\n");
        }
    }
}

// Test_NatDns ---------------------------------------------------------------------------

XNETTEST_BEG(NatDns_1, "xb1@Nat1Inner", NULL, NULL, NULL, 0)
{
    XNADDR xnaddr;
    while (XNetGetTitleXnAddr(&xnaddr) == XNET_GET_XNADDR_PENDING)
        Sleep(100);
    Verify((_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    
    XNDNS * pxndns = NULL;

    Verify(XNetDnsLookup("nosuchhost.foo.bar.com", _hEvent, &pxndns) == 0);
    Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    Verify(pxndns->iStatus == WSAHOST_NOT_FOUND);
    Verify(pxndns->cina == 0);
    Verify(XNetDnsRelease(pxndns) == 0);

    Verify(XNetDnsLookup("products.redmond.corp.microsoft.com", _hEvent, &pxndns) == 0);
    Verify(WaitForSingleObject(_hEvent, INFINITE) == WAIT_OBJECT_0);
    Verify(pxndns->iStatus == 0);
    Verify(pxndns->cina > 0);
    Verify(XNetDnsRelease(pxndns) == 0);

    Verify(XNetDnsLookup("products.redmond.corp.microsoft.com", NULL, &pxndns) == 0);
    while (pxndns->iStatus == WSAEINPROGRESS)
        Sleep(100);
    Verify(pxndns->iStatus == 0);
    Verify(pxndns->cina > 0);
    Verify(XNetDnsRelease(pxndns) == 0);

    CloseHandle(_hEvent);
}

HANDLE _hEvent;

XNETTEST_END(NatDns_1)

void Test_NatDns()
{
    for (UINT iAssign = NAT_ASSIGN_MINIMAL; iAssign <= NAT_ASSIGN_AGGRESSIVE; ++iAssign)
    {
        for (UINT iFilter = NAT_FILTER_NONE; iFilter <= NAT_FILTER_ADDRESS_PORT; ++iFilter)
        {
            printf("Testing NatDns %s/%s ", iAssign == NAT_ASSIGN_MINIMAL ? "min" : "agr",
                   iFilter == NAT_FILTER_NONE ? "none" : iFilter == NAT_FILTER_ADDRESS ? "addr" :
                   iFilter == NAT_FILTER_PORT ? "port" : "both");

            if (!VLanDriver())
            {
                printf("[No VLan]\n");
                return;
            }

            NATCREATE natcreate = { 0 };

            strcpy(natcreate._achXboxInner, "Nat1@Nat1Inner");
            strcpy(natcreate._achXboxOuter, "Nat1@Nic/0");

            natcreate._xncpInner.ina.s_addr         = inet_addr("10.0.0.1");
            natcreate._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._inaBase.s_addr               = inet_addr("10.0.1.0");
            natcreate._inaLast.s_addr               = inet_addr("10.0.254.254");
            natcreate._dwLeaseTime                  = 60 * 60 * 24;
            natcreate._iAssign                      = iAssign;
            natcreate._iFilter                      = iFilter;

            void * pvNat = XNetNatCreate(&natcreate);
            Verify(pvNat != NULL);

            Test_NatDns_1();

            XNetNatDelete(pvNat);

            printf("[OK]\n");
        }
    }
}

// Test_NatUdp ---------------------------------------------------------------------------

XNETTEST_BEG(NatUdp_1, "xb1@Nat1Inner", NULL, NULL, NULL, XNET_STARTUP_BYPASS_SECURITY)
{
    XNADDR xnaddr;
    while (XNetGetTitleXnAddr(&xnaddr) == XNET_GET_XNADDR_PENDING)
        Sleep(100);

    SOCKET s = SockUdpCreate(CIpPort(NTOHS(6543)));
    SockUdpTransmit(s, inet_addr("192.168.0.2"), CIpPort(NTOHS(1567)));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(NatUdp_1);

XNETTEST_BEG(NatUdp_2, "xb2@Nat1Outer", "192.168.0.2", "255.255.0.0", NULL, XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(NTOHS(1567));
    SockUdpReflect(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(NatUdp_2);

TWOTHREADTEST(NatUdp)
{
    for (UINT iAssign = NAT_ASSIGN_MINIMAL; iAssign <= NAT_ASSIGN_AGGRESSIVE; ++iAssign)
    {
        for (UINT iFilter = NAT_FILTER_NONE; iFilter <= NAT_FILTER_ADDRESS_PORT; ++iFilter)
        {
            printf("Testing NatUdp %s/%s ", iAssign == NAT_ASSIGN_MINIMAL ? "min" : "agr",
                   iFilter == NAT_FILTER_NONE ? "none" : iFilter == NAT_FILTER_ADDRESS ? "addr" :
                   iFilter == NAT_FILTER_PORT ? "port" : "both");

            NATCREATE natcreate = { 0 };

            strcpy(natcreate._achXboxInner, "Nat1@Nat1Inner");
            strcpy(natcreate._achXboxOuter, "Nat1@Nat1Outer");

            natcreate._xncpInner.ina.s_addr         = inet_addr("10.0.0.1");
            natcreate._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._xncpOuter.ina.s_addr         = inet_addr("192.168.0.1");
            natcreate._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._inaBase.s_addr               = inet_addr("10.0.1.0");
            natcreate._inaLast.s_addr               = inet_addr("10.0.254.254");
            natcreate._dwLeaseTime                  = 60 * 60 * 24;
            natcreate._iAssign                      = iAssign;
            natcreate._iFilter                      = iFilter;

            void * pvNat = XNetNatCreate(&natcreate);
            Verify(pvNat != NULL);

            TWOTHREADRUN(NatUdp);

            XNetNatDelete(pvNat);

            printf(" [OK]\n");
        }
    }
}

// Test_NatTcp ---------------------------------------------------------------------------

XNETTEST_BEG(NatTcp_1, "xb1@Nat1Inner", NULL, NULL, NULL, XNET_STARTUP_BYPASS_SECURITY)
{
    XNADDR xnaddr;
    while (XNetGetTitleXnAddr(&xnaddr) == XNET_GET_XNADDR_PENDING)
        Sleep(100);

    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = inet_addr("192.168.0.2");
    sin.sin_port = HTONS(80);
    Verify(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != SOCKET_ERROR);
    SockTcpTransmit(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(NatTcp_1)

XNETTEST_BEG(NatTcp_2, "xb2@Nat1Outer", "192.168.0.2", "255.255.0.0", NULL, XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s1 = SockTcpCreate(HTONS(80));
    Verify(listen(s1, 1) == 0);
    sockaddr_in sin;
    int slen = sizeof(sin);
    SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
    Verify(s2 != SOCKET_ERROR);
    Verify(slen == sizeof(sin));
    SockTcpReflect(s2);
    Verify(closesocket(s2) == 0);
    Verify(closesocket(s1) == 0);
}
XNETTEST_END(NatTcp_2)

TWOTHREADTEST(NatTcp)
{
    for (UINT iAssign = NAT_ASSIGN_MINIMAL; iAssign <= NAT_ASSIGN_AGGRESSIVE; ++iAssign)
    {
        for (UINT iFilter = NAT_FILTER_NONE; iFilter <= NAT_FILTER_ADDRESS_PORT; ++iFilter)
        {
            printf("Testing NatTcp %s/%s ", iAssign == NAT_ASSIGN_MINIMAL ? "min" : "agr",
                   iFilter == NAT_FILTER_NONE ? "none" : iFilter == NAT_FILTER_ADDRESS ? "addr" :
                   iFilter == NAT_FILTER_PORT ? "port" : "both");

            NATCREATE natcreate = { 0 };

            strcpy(natcreate._achXboxInner, "Nat1@Nat1Inner");
            strcpy(natcreate._achXboxOuter, "Nat1@Nat1Outer");

            natcreate._xncpInner.ina.s_addr         = inet_addr("10.0.0.1");
            natcreate._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._xncpOuter.ina.s_addr         = inet_addr("192.168.0.1");
            natcreate._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate._inaBase.s_addr               = inet_addr("10.0.1.0");
            natcreate._inaLast.s_addr               = inet_addr("10.0.254.254");
            natcreate._dwLeaseTime                  = 60 * 60 * 24;
            natcreate._iAssign                      = iAssign;
            natcreate._iFilter                      = iFilter;

            void * pvNat = XNetNatCreate(&natcreate);
            Verify(pvNat != NULL);

            TWOTHREADRUN(NatTcp);

            XNetNatDelete(pvNat);

            printf(" [OK]\n");
        }
    }
}

// Test_SgNat1Xb1ToNat2Xb2 ---------------------------------------------------------------

XNETTEST_BEG(SgXb1ToXb2_1, "xb1@Internet", "10.0.0.10", "255.0.0.0", "10.0.0.1", 0)
{
    SgTcpXbToXbClient();
}
XNETTEST_END(SgXb1ToXb2_1)

XNETTEST_BEG(SgXb1ToXb2_2, "xb2@Internet", "10.0.0.11", "255.0.0.0", "10.0.0.1", 0)
{
    SgTcpXbToXbServer();
}
XNETTEST_END(SgXb1ToXb2_2)

TWOTHREADTEST(SgXb1ToXb2)
{
    TWOTHREADRUN(SgXb1ToXb2);
}

XNETTEST_BEG(SgXb1ToNat2Xb2_1, "xb1@Internet", "10.0.0.10", "255.0.0.0", "10.0.0.1", 0)
{
    SgTcpXbToXbClient();
}
XNETTEST_END(SgXb1ToNat2Xb2_1)

XNETTEST_BEG(SgXb1ToNat2Xb2_2, "xb2@Nat2Inner", NULL, NULL, NULL, 0)
{
    SgTcpXbToXbServer();
}
XNETTEST_END(SgXb1ToNat2Xb2_2)

TWOTHREADTEST(SgXb1ToNat2Xb2)
{
    TWOTHREADRUN(SgXb1ToNat2Xb2);
}

XNETTEST_BEG(SgNat1Xb1ToXb2_1, "xb1@Nat1Inner", NULL, NULL, NULL, 0)
{
    SgTcpXbToXbClient();
}
XNETTEST_END(SgNat1Xb1ToXb2_1)

XNETTEST_BEG(SgNat1Xb1ToXb2_2, "xb2@Internet", "10.0.0.10", "255.0.0.0", NULL, 0)
{
    SgTcpXbToXbServer();
}
XNETTEST_END(SgNat1Xb1ToXb2_2)

TWOTHREADTEST(SgNat1Xb1ToXb2)
{
    TWOTHREADRUN(SgNat1Xb1ToXb2);
}

XNETTEST_BEG(SgNat1Xb1ToNat2Xb2_1, "xb1@Nat1Inner", NULL, NULL, NULL, 0)
{
    SgTcpXbToXbClient();
}
XNETTEST_END(SgNat1Xb1ToNat2Xb2_1)

XNETTEST_BEG(SgNat1Xb1ToNat2Xb2_2, "xb2@Nat2Inner", NULL, NULL, NULL, 0)
{
    SgTcpXbToXbServer();
}
XNETTEST_END(SgNat1Xb1ToNat2Xb2_2)

TWOTHREADTEST(SgNat1Xb1ToNat2Xb2)
{
    TWOTHREADRUN(SgNat1Xb1ToNat2Xb2);
}

XNETTEST_BEG(SgNat1Xb1ToNat1Xb2_1, "xb1@Nat1Inner", NULL, NULL, NULL, 0)
{
    SgTcpXbToXbClient();
}
XNETTEST_END(SgNat1Xb1ToNat1Xb2_1)

XNETTEST_BEG(SgNat1Xb1ToNat1Xb2_2, "xb2@Nat1Inner", NULL, NULL, NULL, 0)
{
    SgTcpXbToXbServer();
}
XNETTEST_END(SgNat1Xb1ToNat1Xb2_2)

TWOTHREADTEST(SgNat1Xb1ToNat1Xb2)
{
    TWOTHREADRUN(SgNat1Xb1ToNat1Xb2);
}

void Test_SgNat()
{
    printf("Testing SgNat\n\n");
    printf("         Direct Min/-- Min/A- Min/-P Min/AP Agr/-- Agr/A- Agr/-P Agr/AP\n");

    UINT    aiAssign[] = { NAT_ASSIGN_MINIMAL, NAT_ASSIGN_MINIMAL, NAT_ASSIGN_MINIMAL, NAT_ASSIGN_MINIMAL, NAT_ASSIGN_AGGRESSIVE, NAT_ASSIGN_AGGRESSIVE, NAT_ASSIGN_AGGRESSIVE, NAT_ASSIGN_AGGRESSIVE };
    UINT    aiFilter[] = { NAT_FILTER_NONE, NAT_FILTER_ADDRESS, NAT_FILTER_PORT, NAT_FILTER_ADDRESS_PORT, NAT_FILTER_NONE, NAT_FILTER_ADDRESS, NAT_FILTER_PORT, NAT_FILTER_ADDRESS_PORT };
    UINT    iAssign1, iAssign2, iFilter1, iFilter2;
    void *  pvNat1, * pvNat2;
    UINT    i, j;

    printf("  OneNat ");
    TWOTHREADRUN(SgXb1ToXb2);
    printf(g_fXb1ToXb2Timeout ? "[F:%2d] " : "%6d ", g_cSecsXb1ToXb2Connect);

    for (i = 0; i < dimensionof(aiAssign); ++i)
    {
        iAssign1 = aiAssign[i];
        iFilter1 = aiFilter[i];

        NATCREATE natcreate1 = { 0 };

        strcpy(natcreate1._achXboxOuter, "Nat1@Internet");
        natcreate1._xncpOuter.ina.s_addr         = inet_addr("10.0.0.253");
        natcreate1._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");

        strcpy(natcreate1._achXboxInner, "Nat1@Nat1Inner");
        natcreate1._xncpInner.ina.s_addr         = inet_addr("192.168.0.1");
        natcreate1._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
        natcreate1._inaBase.s_addr               = inet_addr("192.168.0.2");
        natcreate1._inaLast.s_addr               = inet_addr("192.168.254.254");

        natcreate1._dwLeaseTime                  = 60 * 60 * 24;
        natcreate1._iAssign                      = iAssign1;
        natcreate1._iFilter                      = iFilter1;

        pvNat1 = XNetNatCreate(&natcreate1);
        Verify(pvNat1 != NULL);
        TWOTHREADRUN(SgNat1Xb1ToNat1Xb2);
        XNetNatDelete(pvNat1);
        printf(g_fXb1ToXb2Timeout ? "[F:%2d] " : "%6d ", g_cSecsXb1ToXb2Connect);
    }

    printf("\n");
    printf("  Direct ");

    TWOTHREADRUN(SgXb1ToXb2);
    printf(g_fXb1ToXb2Timeout ? "[F:%2d] " : "%6d ", g_cSecsXb1ToXb2Connect);

    for (i = 0; i < dimensionof(aiAssign); ++i)
    {
        iAssign2 = aiAssign[i];
        iFilter2 = aiFilter[i];

        NATCREATE natcreate2 = { 0 };

        strcpy(natcreate2._achXboxOuter, "Nat2@Internet");
        natcreate2._xncpOuter.ina.s_addr         = inet_addr("10.0.0.254");
        natcreate2._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");

        strcpy(natcreate2._achXboxInner, "Nat2@Nat2Inner");
        natcreate2._xncpInner.ina.s_addr         = inet_addr("192.168.0.1");
        natcreate2._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
        natcreate2._inaBase.s_addr               = inet_addr("192.168.0.2");
        natcreate2._inaLast.s_addr               = inet_addr("192.168.254.254");

        natcreate2._dwLeaseTime                  = 60 * 60 * 24;
        natcreate2._iAssign                      = iAssign2;
        natcreate2._iFilter                      = iFilter2;
        natcreate2._iNatPortBase                 = 2000;

        pvNat2 = XNetNatCreate(&natcreate2);
        Verify(pvNat2 != NULL);
        TWOTHREADRUN(SgXb1ToNat2Xb2);
        XNetNatDelete(pvNat2);
        printf(g_fXb1ToXb2Timeout ? "[F:%2d] " : "%6d ", g_cSecsXb1ToXb2Connect);
    }

    printf("\n");

    for (i = 0; i < dimensionof(aiAssign); ++i)
    {
        iAssign1 = aiAssign[i];
        iFilter1 = aiFilter[i];

        printf("  %s/%c%c ", iAssign1 == NAT_ASSIGN_MINIMAL ? "Min" : "Agr",
               (iFilter1 & NAT_FILTER_ADDRESS) ? 'A' : '-', (iFilter1 & NAT_FILTER_PORT) ? 'P' : '-');

        NATCREATE natcreate1 = { 0 };

        strcpy(natcreate1._achXboxOuter, "Nat1@Internet");
        natcreate1._xncpOuter.ina.s_addr         = inet_addr("10.0.0.253");
        natcreate1._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");

        strcpy(natcreate1._achXboxInner, "Nat1@Nat1Inner");
        natcreate1._xncpInner.ina.s_addr         = inet_addr("192.168.0.1");
        natcreate1._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
        natcreate1._inaBase.s_addr               = inet_addr("192.168.0.2");
        natcreate1._inaLast.s_addr               = inet_addr("192.168.254.254");

        natcreate1._dwLeaseTime                  = 60 * 60 * 24;
        natcreate1._iAssign                      = iAssign1;
        natcreate1._iFilter                      = iFilter1;

        pvNat1 = XNetNatCreate(&natcreate1);
        Verify(pvNat1 != NULL);
        TWOTHREADRUN(SgNat1Xb1ToXb2);
        XNetNatDelete(pvNat1);
        printf(g_fXb1ToXb2Timeout ? "[F:%2d] " : "%6d ", g_cSecsXb1ToXb2Connect);

        for (j = 0; j < dimensionof(aiAssign); ++j)
        {
            iAssign2 = aiAssign[j];
            iFilter2 = aiFilter[j];

            NATCREATE natcreate1 = { 0 };

            strcpy(natcreate1._achXboxOuter, "Nat1@Internet");
            natcreate1._xncpOuter.ina.s_addr         = inet_addr("10.0.0.253");
            natcreate1._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");

            strcpy(natcreate1._achXboxInner, "Nat1@Nat1Inner");
            natcreate1._xncpInner.ina.s_addr         = inet_addr("192.168.0.1");
            natcreate1._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate1._inaBase.s_addr               = inet_addr("192.168.0.2");
            natcreate1._inaLast.s_addr               = inet_addr("192.168.254.254");

            natcreate1._dwLeaseTime                  = 60 * 60 * 24;
            natcreate1._iAssign                      = iAssign1;
            natcreate1._iFilter                      = iFilter1;

            pvNat1 = XNetNatCreate(&natcreate1);
            Verify(pvNat1 != NULL);

            NATCREATE natcreate2 = { 0 };

            strcpy(natcreate2._achXboxOuter, "Nat2@Internet");
            natcreate2._xncpOuter.ina.s_addr         = inet_addr("10.0.0.254");
            natcreate2._xncpOuter.inaMask.s_addr     = inet_addr("255.255.0.0");

            strcpy(natcreate2._achXboxInner, "Nat2@Nat2Inner");
            natcreate2._xncpInner.ina.s_addr         = inet_addr("192.168.0.1");
            natcreate2._xncpInner.inaMask.s_addr     = inet_addr("255.255.0.0");
            natcreate2._inaBase.s_addr               = inet_addr("192.168.0.2");
            natcreate2._inaLast.s_addr               = inet_addr("192.168.254.254");

            natcreate2._dwLeaseTime                  = 60 * 60 * 24;
            natcreate2._iAssign                      = iAssign2;
            natcreate2._iFilter                      = iFilter2;
            natcreate2._iNatPortBase                 = 2000;

            pvNat2 = XNetNatCreate(&natcreate2);
            Verify(pvNat2 != NULL);
            TWOTHREADRUN(SgNat1Xb1ToNat2Xb2);
            XNetNatDelete(pvNat2);
            XNetNatDelete(pvNat1);

            printf(g_fXb1ToXb2Timeout ? "[F:%2d] " : "%6d ", g_cSecsXb1ToXb2Connect);
        }
            
        printf("\n");
    }

    printf("\n");
}

// ---------------------------------------------------------------------------------------
// main
// ---------------------------------------------------------------------------------------

int     g_argc;
char ** g_argv;

BOOL RunTest(char * pszName, ...)
{
    BOOL fByNameOnly = FALSE;

    va_list va;

    va_start(va, pszName);

    while (pszName)
    {
        if (*pszName == '*')
        {
            fByNameOnly = TRUE;
            pszName += 1;
        }
        else
        {
            fByNameOnly = FALSE;
        }

        if (!fByNameOnly && g_argc == 1)
        {
            return(TRUE);
        }

        for (int i = 1; i < g_argc; ++i)
        {
            if (g_argv[i] && lstrcmpiA(g_argv[i], pszName) == 0)
                return(TRUE);
        }

        pszName = va_arg(va, char *);
    }

    return(FALSE);
}

int __cdecl main(int argc, char * argv[])
{
    g_argc = argc;
    g_argv = argv;

    Verify(VLanInit());

    if (RunTest("inet_addr", NULL))                     Test_inet_addr();
    if (RunTest("XNetRandom", NULL))                    Test_XNetRandom();
    if (RunTest("XNetRegisterKey", NULL))               Test_XNetRegisterKey();
    if (RunTest("XNetXnAddrToInAddr", NULL))            Test_XNetXnAddrToInAddr();
    if (RunTest("Broadcast", NULL))                     Test_Broadcast();
    if (RunTest("Discovery", NULL))                     Test_Discovery();
    if (RunTest("Frag", NULL))                          Test_Frag();
    if (RunTest("XnSetEventTimer", NULL))               Test_XnSetEventTimer();
    if (RunTest("SockUdp", NULL))                       Test_SockUdp();
    if (RunTest("SockTcp", NULL))                       Test_SockTcp();
    if (RunTest("Dhcp", NULL))                          Test_Dhcp();
    if (RunTest("Dns", NULL))                           Test_Dns();
    if (RunTest("NatDhcp", "Nat", NULL))                Test_NatDhcp();
    if (RunTest("NatDns", "Nat", NULL))                 Test_NatDns();
    if (RunTest("NatUdp", "Nat", NULL))                 Test_NatUdp();
    if (RunTest("NatTcp", "Nat", NULL))                 Test_NatTcp();
    if (RunTest("*SgAlive", NULL))                      Test_SgAlive();
    if (RunTest("*SgMsg", "*Sg", NULL))                 Test_SgMsg();
    if (RunTest("*SgUdp", "*Sg", NULL))                 Test_SgUdp();
    if (RunTest("*SgTcp", "*Sg", NULL))                 Test_SgTcp();
    if (RunTest("*SgRst", "*Sg", NULL))                 Test_SgRst();
    if (RunTest("*SgNat", "*Sg", NULL))                 Test_SgNat();
    if (RunTest("*SgLogon", "*Sg", NULL))               Test_SgLogon();

    VLanTerm();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\net\test\sg\testsg.cpp ===
// ----------------------------------------------------------------------------
// test.cpp
//
// Copyright (C) Microsoft Corporation
// ----------------------------------------------------------------------------

#include "xnp.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <vlan.h>
#include <sgadmin.h>

// ---------------------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------------------

#define TESTSG_START_EVENT_NAME     "$TESTSG$1$EVENT$START$"
#define TESTSG_TERM_EVENT_NAME      "$TESTSG$1$EVENT$TERM$"

// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

ULONG   g_ipInet = inet_addr("10.0.0.2");

char    g_szServerConfiguration[] =
"Service    { Id 0 Name TestSg }\n"
"Server     { Id 1 Ip 10.0.0.4 Port 127 Service TestSg }\n"
"Server     { Id 2 Ip 10.0.0.5 Port  80 Service TestSg }\n"
"Server     { Id 3 Ip 10.0.0.6 Port 123 Service TestSg }\n";

char    g_szVirtualNicConfiguration[] =
"NetworkInterface {\n"
"    Type                Internet        ; Interface is connected to the Internet\n"
"    Ip                  10.0.0.2        ; Static IP address of this interface\n"
"    IpMask              255.255.0.0     ; Subnet mask of this interface\n"
"    IpGateway           10.0.0.1        ; Gateway of this interface\n"
"    VLan                sg1@Nic/0       ; VLan this interface is connected to }\n"
"NetworkInterface { \n"
"    Type                Datacenter      ; Interface is connected to the Internet\n"
"    Ip                  10.0.0.3        ; Static IP address of this interface\n"
"    IpMask              255.255.0.0     ; Subnet mask of this interface\n"
"    IpGateway           10.0.0.1        ; Gateway of this interface\n"
"    IpAdmin             10.0.0.100      ; Admin IP address of this interface\n"
"    VLan                sg2@Nic/1       ; VLan this interface is connected to }\n";

char    g_szVirtualOtherConfiguration[] =
"ClientLimit                     64      ; Maximum simultanous clients\n"
"ClientScanFrequencyInSeconds    5       ; How often each client is checked for inactivity\n"
"ClientProbeFrequencyInSeconds   5       ; Inactivity time before probe is sent to client\n"
"ClientKeyExTimeoutInSeconds     10      ; KeyEx inactivity before client presumed dead\n"
"ClientActivityTimeoutInSeconds  20      ; Normal inactivity before client presumed dead\n"
"IpHdrTos                        0       ; IP header type-of-service\n"
"IpHdrTtl                        64      ; IP header time-to-live\n"
"EspReplayWindow                 1024    ; Number of packets sender can get ahead of receiver\n"
"KerberosApReqDeltaInMinutes     5       ; Allowable time-skew for AP request\n"
"HashTableOverheadInPercent      60      ; Hash table bucket overhead above expected maximum\n"
"ArpRequestRetries               4       ; Number of times to retry ARP request\n"
"ArpRexmitTimeoutInSeconds       2       ; Timeout for ARP request\n"
"ArpPositiveTimeoutInSeconds     10      ; Timeout before good ARP request is verified\n"
"ArpNegativeTimeoutInSeconds     10      ; Timeout before bad ARP request is retried\n"
"PacketPool                      64      ; Initial packet pool size (will grow if needed)\n";


char    g_szVirtualSgFormat[] = "sgvlan.exe -s \"%s %s %s\" -e " TESTSG_START_EVENT_NAME " " TESTSG_TERM_EVENT_NAME;

HANDLE  g_hTermVirtualSg;

// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

#define Verify(x)       do { if (!(x)) DbgBreak(); } while (0)

struct CDiscReq
{
    BYTE    abNonce[8];         // Nonce of the requester
};

struct CDiscRsp : public CDiscReq
{
    XNKID   xnkid;              // The host's key identifier
    XNKEY   xnkey;              // The host's key
    XNADDR  xnaddr;             // The host's address
};

// ---------------------------------------------------------------------------------------
// CTestXnIp
// ---------------------------------------------------------------------------------------

class CTestXnIp : public CXnIp
{

public:
    
    virtual void Startup(char * pszXbox, char * pszIp, char * pszMask, char * pszGateway, DWORD dwFlags)
    {
        XNetParams xnp = { sizeof(XNetStartupParams) };
        xnp.cfgFlags = (BYTE)(XNET_STARTUP_MANUAL_CONFIG|dwFlags);
        XNetInitParams xnip = { &xnp, pszXbox };
        Verify(IpInit(&xnip) == 0);

        XNetConfigParams xncp = { 0 };
        xncp.ina.s_addr = pszIp ? inet_addr(pszIp) : 0;
        xncp.inaMask.s_addr = pszMask ? inet_addr(pszMask) : 0;
        xncp.inaGateway.s_addr = pszGateway ? inet_addr(pszGateway) : 0;
        Verify(IpConfig(&xncp, XNET_CONFIG_NORMAL) == 0);

        IpStart();
    }

    virtual void Init()
    {
        Startup(NULL, NULL, NULL, NULL, 0);
    }

    virtual void Term()
    {
        RaiseToDpc();
        IpTerm();
    }

    void Go(HANDLE hEvent1, HANDLE hEvent2)
    {
        Init();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) WaitForSingleObject(hEvent2, INFINITE);
        Test();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) WaitForSingleObject(hEvent2, INFINITE);
        Term();
    }

    void UdpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CUdpHdr * pUdpHdr, UINT cbLen) {};
    void TcpRecv(CPacket * ppkt, CIpHdr * pIpHdr, CTcpHdr * pTcpHdr, UINT cbHdrLen, UINT cbLen) {};

    virtual void Test() = 0;
};


// ---------------------------------------------------------------------------------------
// CTestXNet
// ---------------------------------------------------------------------------------------

class CTestXNet : public CXNet
{
public:

    CTestXNet(char * pszXbox = NULL) : CXNet(pszXbox) {}
    
    virtual void Startup(char * pszIp, char * pszMask, char * pszGateway, DWORD dwFlags)
    {
        XNetStartupParams xnp = { sizeof(XNetStartupParams) };
        xnp.cfgFlags = (BYTE)(XNET_STARTUP_MANUAL_CONFIG|dwFlags);
        Verify(XNetStartup(&xnp) == 0);

        XNetConfigParams xncp = { 0 };
        xncp.ina.s_addr = pszIp ? inet_addr(pszIp) : 0;
        xncp.inaMask.s_addr = pszMask ? inet_addr(pszMask) : 0;
        xncp.inaGateway.s_addr = pszGateway ? inet_addr(pszGateway) : 0;
        Verify(XNetConfig(&xncp, XNET_CONFIG_NORMAL) == 0);

        WSADATA WSAData;
        Verify(WSAStartup(0x0200, &WSAData) == 0);
    }

    virtual void Init()
    {
        Startup(NULL, NULL, NULL, 0);
    }

    virtual void Term()
    {
        WSACleanup();
        XNetCleanup();
    }

    void Go(HANDLE hEvent1, HANDLE hEvent2)
    {
        Init();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) WaitForSingleObject(hEvent2, INFINITE);
        Test();
        if (hEvent1) SetEvent(hEvent1);
        if (hEvent2) WaitForSingleObject(hEvent2, INFINITE);
        Term();
    }

    virtual void Test() = 0;

    SOCKET  SockUdpCreate(CIpPort ipport = 0, BOOL fBroadcast = FALSE);
    void    SockUdpTransmit(SOCKET s, CIpAddr ipaDst, CIpPort ipport);
    void    SockUdpReflect(SOCKET s);
    SOCKET  SockTcpCreate(CIpPort ipport = 0);
    void    SockTcpTransmit(SOCKET s);
    void    SockTcpReflect(SOCKET s);
    void    DiscoveryHost(UINT cClient, XNKID * pxnkid);
    void    DiscoveryClient(XNKID * pxnkid, CIpAddr * pipa);

};

SOCKET CTestXNet::SockUdpCreate(CIpPort ipport, BOOL fBroadcast)
{
    SOCKET s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    Verify(s != SOCKET_ERROR);

    if (ipport)
    {
        sockaddr_in sin;
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = 0;
        sin.sin_port = ipport;
        Verify(bind(s, (struct sockaddr *)&sin, sizeof(sin)) == 0);
    }

    if (fBroadcast)
    {
        char cBroadcast = 1;
        Verify(setsockopt(s, SOL_SOCKET, SO_BROADCAST, &cBroadcast, 1) == 0);
    }

    return(s);
}

void CTestXNet::SockUdpTransmit(SOCKET s, CIpAddr ipaDst, CIpPort ipport)
{
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = ipaDst;
    sin.sin_port = ipport;
    
    BYTE abXmit[1500], abRecv[1500];

    int cb;

    for (cb = 1; cb < UDP_MAXIMUM_MSS; ++cb)
    {
        XNetRandom(abXmit, cb);
        Verify(sendto(s, (char *)abXmit, cb, 0, (struct sockaddr *)&sin, sizeof(sin)) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    for (; cb > 0; --cb)
    {
        XNetRandom(abXmit, cb);
        Verify(sendto(s, (char *)abXmit, cb, 0, (struct sockaddr *)&sin, sizeof(sin)) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    Verify(sendto(s, (char *)abXmit, 0, 0, (struct sockaddr *)&sin, sizeof(sin)) == 0);
    Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == 0);
}

void CTestXNet::SockUdpReflect(SOCKET s)
{
    BYTE abRecv[1500];

    sockaddr_in sin;
    int cb;

    while (1)
    {
        int slen = sizeof(sin);
        cb = recvfrom(s, (char *)abRecv, sizeof(abRecv), 0, (struct sockaddr *)&sin, &slen);
        Verify(cb != SOCKET_ERROR);
        Verify(sendto(s, (char *)abRecv, cb, 0, (struct sockaddr *)&sin, sizeof(sin)) == cb);
        if (cb == 0)
            break;
    }
}

SOCKET CTestXNet::SockTcpCreate(CIpPort ipport)
{
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);

    if (ipport)
    {
        sockaddr_in sin;
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = 0;
        sin.sin_port = ipport;
        Verify(bind(s, (struct sockaddr *)&sin, sizeof(sin)) == 0);
    }

    return(s);
}

void CTestXNet::SockTcpTransmit(SOCKET s)
{
    BYTE abXmit[1500], abRecv[1500];

    int cb;

    for (cb = 1; cb < TCP_MAXIMUM_MSS; ++cb)
    {
        XNetRandom(abXmit, cb);
        Verify(send(s, (char *)abXmit, cb, 0) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    for (; cb > 0; --cb)
    {
        XNetRandom(abXmit, cb);
        Verify(send(s, (char *)abXmit, cb, 0) == cb);
        Verify(recv(s, (char *)abRecv, sizeof(abRecv), 0) == cb);
        Verify(memcmp(abXmit, abRecv, cb) == 0);
        if ((cb % 200) == 0) printf(".");
    }

    Verify(shutdown(s, SD_SEND) != SOCKET_ERROR);
}

void CTestXNet::SockTcpReflect(SOCKET s)
{
    BYTE abRecv[1500];
    int cb;

    while (1)
    {
        cb = recv(s, (char *)abRecv, sizeof(abRecv), 0);
        Verify(cb != SOCKET_ERROR);

        if (cb == 0)
        {
            Verify(shutdown(s, SD_SEND) != SOCKET_ERROR);
            break;
        }

        Verify(send(s, (char *)abRecv, cb, 0) == cb);
    }
}

void CTestXNet::DiscoveryHost(UINT cClient, XNKID * pxnkid)
{
    SOCKET s = SockUdpCreate(NTOHS(1234), TRUE);

    CDiscReq dreq;
    CDiscRsp drsp;
    UINT iClient = 0;
    sockaddr_in sin;
    BYTE * pbNonce = (BYTE *)LocalAlloc(LPTR, sizeof(dreq.abNonce) * cClient);
    Verify(pbNonce != NULL);
    XNADDR xnaddr;
    XNKID xnkid;
    XNKEY xnkey;

    Verify(XNetCreateKey(&drsp.xnkid, &drsp.xnkey) == 0);
    Verify(XNetRegisterKey(&drsp.xnkid, &drsp.xnkey) == 0);
    Verify(XNetGetTitleXnAddr(&drsp.xnaddr) != 0);

    XNetRandom(drsp.abNonce, sizeof(drsp.abNonce));

    while (iClient < cClient)
    {
        Verify(recv(s, (char *)&dreq, sizeof(dreq), 0) == sizeof(dreq));

        for (UINT i = 0; i < iClient; ++i)
        {
            if (memcmp(&pbNonce[i * sizeof(dreq.abNonce)], dreq.abNonce, sizeof(dreq.abNonce)) == 0)
                break;
        }

        if (i == iClient)
        {
            memcpy(&pbNonce[i * sizeof(dreq.abNonce)], dreq.abNonce, sizeof(dreq.abNonce));
            iClient += 1;
        }

        memcpy(drsp.abNonce, dreq.abNonce, sizeof(dreq.abNonce));
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = INADDR_BROADCAST;
        sin.sin_port = NTOHS(1234);
        Verify(sendto(s, (char *)&drsp, sizeof(drsp), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(drsp));
    }

    Verify(closesocket(s) == 0);
    LocalFree(pbNonce);
    *pxnkid = drsp.xnkid;
}

void CTestXNet::DiscoveryClient(XNKID * pxnkid, CIpAddr * pipa)
{
    SOCKET s = SockUdpCreate(NTOHS(1234));

    char cBroadcast = 1;
    sockaddr_in sin;
    CDiscReq dreq;
    CDiscRsp drsp;

    XNetRandom(dreq.abNonce, sizeof(dreq.abNonce));

    Verify(setsockopt(s, SOL_SOCKET, SO_BROADCAST, &cBroadcast, 1) == 0);

    while (1)
    {
        sin.sin_family = AF_INET;
        sin.sin_addr.s_addr = INADDR_BROADCAST;
        sin.sin_port = NTOHS(1234);
        Verify(sendto(s, (char *)&dreq, sizeof(dreq), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(dreq));

        fd_set  fds;
        TIMEVAL tv;
        FD_ZERO(&fds);
        FD_SET(s, &fds);
        tv.tv_sec  = 0;
        tv.tv_usec = 200000;

        INT iResult = select(0, &fds, NULL, NULL, &tv);
        Verify(iResult != SOCKET_ERROR);

        while (1)
        {
            ULONG ul = 0;
            iResult = ioctlsocket(s, FIONREAD, &ul);
            Verify(iResult != SOCKET_ERROR);

            if (ul == 0)
                break;

            Verify(recv(s, (char *)&drsp, sizeof(drsp), 0) == sizeof(drsp));
            if (memcmp(drsp.abNonce, dreq.abNonce, sizeof(drsp.abNonce)) == 0)
                goto done;
        }
    }

done:

    Verify(XNetRegisterKey(&drsp.xnkid, &drsp.xnkey) == 0);
    Verify(XNetXnAddrToInAddr(&drsp.xnaddr, &drsp.xnkid, (IN_ADDR *)pipa) == 0);
    Verify(closesocket(s) == 0);
    *pxnkid = drsp.xnkid;
}

#define XNETTEST_BEG(_name, pszXbox, pszIp, pszMask, pszGateway, dwFlags) \
    class CTest##_name : public CTestXNet { public: \
    CTest##_name() : CTestXNet(pszXbox) {}; \
    virtual void Init() { Startup(pszIp, pszMask, pszGateway, dwFlags); } \
    virtual void Test()
#define XNETTEST_END(_name) \
    }; void Test_##_name(HANDLE hEvent1 = 0, HANDLE hEvent2 = 0) { CTest##_name * p = new CTest##_name; p->Go(hEvent1, hEvent2); delete p; }

// ---------------------------------------------------------------------------------------
// TWOTHREADTEST
// ---------------------------------------------------------------------------------------

typedef void (*PFNTEST)(HANDLE hEvent1, HANDLE hEvent2);

typedef struct {
    HANDLE      hThread;
    HANDLE      hEvent1;
    HANDLE      hEvent2;
    PFNTEST     pfn;
} TWOTHREADPARAM;

DWORD WINAPI TwoThreadProc(void * pv)
{
    TWOTHREADPARAM * p = (TWOTHREADPARAM *)pv;
    p->pfn(p->hEvent1, p->hEvent2);
    return(0);
}

#define TWOTHREADTEST(_name) \
    void Test_##_name##_run() \
    { \
        HANDLE  hThread1 = NULL, hEvent1 = NULL, hThread2 = NULL, hEvent2 = NULL; \
        TWOTHREADPARAM p1, p2; \
        Verify((p1.hEvent1 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); \
        Verify((p1.hEvent2 = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL); \
        p1.pfn = &Test_##_name##_1; \
        p2.hEvent1 = p1.hEvent2; \
        p2.hEvent2 = p1.hEvent1; \
        p2.pfn = &Test_##_name##_2; \
        Verify((p1.hThread = CreateThread(NULL, 0, TwoThreadProc, &p1, 0, NULL)) != NULL); \
        Verify((p2.hThread = CreateThread(NULL, 0, TwoThreadProc, &p2, 0, NULL)) != NULL); \
        WaitForSingleObject(p1.hThread, INFINITE); \
        WaitForSingleObject(p2.hThread, INFINITE); \
        CloseHandle(p1.hEvent1); CloseHandle(p2.hEvent1); \
        CloseHandle(p1.hThread); CloseHandle(p2.hThread); \
    } \
    void Test_##_name() \

#define TWOTHREADRUN(_name) Test_##_name##_run()


// Test_SgUdpCrypt -----------------------------------------------------------------------

//XNETTEST_BEG(SgUdpCrypt_1, NULL, NULL, NULL, "Nic/0:FEFFDEADF00D", 0)
XNETTEST_BEG(SgUdpCrypt_1, "xbsg10@Nic/0", "10.0.0.10", "255.255.0.0", "10.0.0.1", 0)
{
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = g_ipInet;
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    SockUdpTransmit(s, inaSec.s_addr, CIpPort(NTOHS(1)));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgUdpCrypt_1)

XNETTEST_BEG(SgUdpCrypt_2, "xbsg4@Nic/1", "10.0.0.4", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(127));
    SockUdpReflect(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgUdpCrypt_2)

TWOTHREADTEST(SgUdpCrypt)
{
    printf("Testing SgUdpCrypt ");
    TWOTHREADRUN(SgUdpCrypt);
    printf(" [OK]\n");
}

// Test_SgUdpAuth -----------------------------------------------------------------------

//XNETTEST_BEG(SgUdpAuth_1, NULL, NULL, NULL, "Nic/0:FEFFDEADF00D", XNET_STARTUP_BYPASS_ENCRYPTION)
XNETTEST_BEG(SgUdpAuth_1, "xbsg10@Nic/0", "10.0.0.10", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_ENCRYPTION)
{
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = g_ipInet;
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    SockUdpTransmit(s, inaSec.s_addr, CIpPort(NTOHS(1)));
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgUdpAuth_1)

XNETTEST_BEG(SgUdpAuth_2, "xbsg4@Nic/1", "10.0.0.4", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(127));
    SockUdpReflect(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgUdpAuth_2)

TWOTHREADTEST(SgUdpAuth)
{
    printf("Testing SgUdpAuth  ");
    TWOTHREADRUN(SgUdpAuth);
    printf(" [OK]\n");
}

// Test_SgTcpCrypt -----------------------------------------------------------------------

//XNETTEST_BEG(SgTcpCrypt_1, NULL, NULL, NULL, "Nic/0:FEFFDEADF00D", 0)
XNETTEST_BEG(SgTcpCrypt_1, "xbsg11@Nic/0", "10.0.0.11", "255.255.0.0", "10.0.0.1", 0)
{
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = g_ipInet;
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = HTONS(2);
    Verify(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != SOCKET_ERROR);
    SockTcpTransmit(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgTcpCrypt_1)

XNETTEST_BEG(SgTcpCrypt_2, "xbsg5@Nic/1", "10.0.0.5", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s1 = SockTcpCreate(HTONS(80));
    Verify(listen(s1, 1) == 0);
    sockaddr_in sin;
    int slen = sizeof(sin);
    SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
    Verify(s2 != SOCKET_ERROR);
    Verify(slen == sizeof(sin));
    SockTcpReflect(s2);
    Verify(closesocket(s2) == 0);
    Verify(closesocket(s1) == 0);
}
XNETTEST_END(SgTcpCrypt_2)

TWOTHREADTEST(SgTcpCrypt)
{
    printf("Testing SgTcpCrypt ");
    TWOTHREADRUN(SgTcpCrypt);
    printf(" [OK]\n");
}

// Test_SgTcpAuth -----------------------------------------------------------------------

//XNETTEST_BEG(SgTcpAuth_1, NULL, NULL, NULL, "Nic/0:FEFFDEADF00D", XNET_STARTUP_BYPASS_ENCRYPTION)
XNETTEST_BEG(SgTcpAuth_1, "xbsg11@Nic/0", "10.0.0.11", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_ENCRYPTION)
{
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = g_ipInet;
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    SOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    Verify(s != SOCKET_ERROR);
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = HTONS(2);
    Verify(connect(s, (struct sockaddr *)&sin, sizeof(sin)) != SOCKET_ERROR);
    SockTcpTransmit(s);
    Verify(closesocket(s) == 0);
}
XNETTEST_END(SgTcpAuth_1)

XNETTEST_BEG(SgTcpAuth_2, "xbsg5@Nic/1", "10.0.0.5", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s1 = SockTcpCreate(HTONS(80));
    Verify(listen(s1, 1) == 0);
    sockaddr_in sin;
    int slen = sizeof(sin);
    SOCKET s2 = accept(s1, (struct sockaddr *)&sin, &slen);
    Verify(s2 != SOCKET_ERROR);
    Verify(slen == sizeof(sin));
    SockTcpReflect(s2);
    Verify(closesocket(s2) == 0);
    Verify(closesocket(s1) == 0);
}
XNETTEST_END(SgTcpAuth_2)

TWOTHREADTEST(SgTcpAuth)
{
    printf("Testing SgTcpAuth  ");
    TWOTHREADRUN(SgTcpAuth);
    printf(" [OK]\n");
}

// Test_SgMsg ----------------------------------------------------------------------------

//XNETTEST_BEG(SgMsg_1, NULL, NULL, NULL, "Nic/0:FEFFDEADF00D", 0)
XNETTEST_BEG(SgMsg_1, "xbsg10@Nic/0", "10.0.0.10", "255.255.0.0", "10.0.0.1", 0)
{
    Sleep(200);
    IN_ADDR inaVip, inaSec;
    inaVip.s_addr = g_ipInet;
    Verify(XNetServerToInAddr(inaVip, 0, &inaSec) == 0);
    printf("1");
    SOCKET s = SockUdpCreate(0, FALSE);
    Verify(s != SOCKET_ERROR);
    printf("1");
    sockaddr_in sin;
    sin.sin_family = AF_INET;
    sin.sin_addr = inaSec;
    sin.sin_port = NTOHS(3);
    Verify(sendto(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(inaVip));
    printf("1");
    Verify(closesocket(s) == 0);
    printf("1");
}
XNETTEST_END(SgMsg_1)

XNETTEST_BEG(SgMsg_2, "xbsg6@Nic/1", "10.0.0.6", "255.255.0.0", "10.0.0.1", XNET_STARTUP_BYPASS_SECURITY)
{
    SOCKET s = SockUdpCreate(HTONS(123));

    IN_ADDR inaVip;
    sockaddr_in sin;
    int slen = sizeof(sin);
    
    Verify(recvfrom(s, (char *)&inaVip, sizeof(inaVip), 0, (struct sockaddr *)&sin, &slen) == sizeof(inaVip));
    printf("2");
    inaVip.s_addr = g_ipInet;

    CSgMsgAuthReq   sgar;

    sgar._wType   = SGMSG_TYPE_AUTHDATA_REQ;
    sgar._cbEnt   = sizeof(CSgMsgAuthReq);
    XNetRandom((BYTE *)&sgar._dwReqNum, sizeof(sgar._dwReqNum));
    sgar._ipaZ    = sin.sin_addr;
    sgar._ipportZ = sin.sin_port;
    
    sin.sin_port = NTOHS(0xFFFF);
    Verify(sendto(s, (char *)&sgar, sizeof(sgar), 0, (struct sockaddr *)&sin, sizeof(sin)) == sizeof(sgar));
    printf("2");

    BYTE            ab[CBSGAUTHREPMSG];
    CSgMsgAuthRep * psgap     = (CSgMsgAuthRep *)ab;
    CSgMsgHdr *     psgmh     = (CSgMsgHdr *)(psgap + 1);
    CAuthData *     pAuthData = (CAuthData *)(psgmh + 1);

    slen = sizeof(sin);
    Verify(recvfrom(s, (char *)ab, sizeof(ab), 0, (struct sockaddr *)&sin, &slen) == sizeof(ab));
    printf("2");
    Verify(psgap->_wType == SGMSG_TYPE_AUTHDATA_REP);
    Verify(psgap->_cbEnt == sizeof(CSgMsgAuthRep));
    Verify(psgap->_dwReqNum == sgar._dwReqNum);
    Verify(psgap->_ipaZ.s_addr == sgar._ipaZ.s_addr);
    Verify(psgap->_ipportZ == sgar._ipportZ);
    Verify(psgap->_fNotFound == FALSE);
    Verify(psgap->_bReserved == 0);
//    Verify(psgap->_ipaI.s_addr == inet_addr("10.0.0.10"));
    Verify(psgmh->_wType == SGMSG_TYPE_AUTHDATA);
    Verify(psgmh->_cbEnt == sizeof(CSgMsgHdr) + sizeof(CAuthData));
    Verify(pAuthData->GetCb() == sizeof(CAuthData));

    Verify(closesocket(s) == 0);
    printf("2");
}
XNETTEST_END(SgMsg_2)

TWOTHREADTEST(SgMsg)
{
    printf("Testing SgMsg ");
    TWOTHREADRUN(SgMsg);
    printf("[OK]\n");
}


// ---------------------------------------------------------------------------------------
// main
// ---------------------------------------------------------------------------------------

int     g_argc;
char ** g_argv;

BOOL RunTest(char * pszName, ...)
{
    BOOL fByNameOnly = FALSE;

    va_list va;

    va_start(va, pszName);

    while (pszName)
    {
        if (*pszName == '*')
        {
            fByNameOnly = TRUE;
            pszName += 1;
        }
        else
        {
            fByNameOnly = FALSE;
        }

        if (!fByNameOnly && g_argc == 0)
        {
            return(TRUE);
        }

        for (int i = 0; i < g_argc; ++i)
        {
            if (g_argv[i] && lstrcmpiA(g_argv[i], pszName) == 0)
                return(TRUE);
        }

        pszName = va_arg(va, char *);
    }

    return(FALSE);
}

BOOL RunVirtualSg()
{
    BOOL fReturn;
    STARTUPINFOA StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    char szCmdLine[sizeof(g_szVirtualSgFormat)
                   + sizeof(g_szVirtualNicConfiguration) 
                   + sizeof(g_szServerConfiguration) 
                   + sizeof(g_szVirtualOtherConfiguration)];

    HANDLE hStart       = CreateEventA(NULL, FALSE, FALSE, TESTSG_START_EVENT_NAME);
    g_hTermVirtualSg    = CreateEventA(NULL, FALSE, FALSE, TESTSG_TERM_EVENT_NAME);

    memset(&StartupInfo, 0, sizeof(StartupInfo));
    sprintf(szCmdLine, g_szVirtualSgFormat, g_szVirtualNicConfiguration, g_szServerConfiguration, g_szVirtualOtherConfiguration);

    fReturn = CreateProcessA(NULL,
                             szCmdLine,
                             NULL,                  // lpProcessAttributes
                             NULL,                  // lpThreadAttributes
                             FALSE,                 // bInheritHandles
                             CREATE_NEW_CONSOLE,    // dwCreationFlags
                             NULL,                  // lpEnvironment
                             NULL,                  // lpCurrentDirectory
                             &StartupInfo,
                             &ProcessInfo);
                             

    if (!fReturn)
    {
        printf("Error %d executing sgvlan.exe\n", GetLastError());
    }
    else
    {
        printf("Waiting for sgvlan to start... ");

        HANDLE ah[2];
        DWORD i;

        ah[0] = hStart;
        ah[1] = ProcessInfo.hProcess;

        i = WaitForMultipleObjects(2, ah, FALSE, INFINITE);

        if (i == WAIT_OBJECT_0)
        {
            printf("[OK]\n");
        }
        else
        {
            printf("[FAIL]\n");
        }

        CloseHandle(hStart);
        CloseHandle(ProcessInfo.hProcess);
        CloseHandle(ProcessInfo.hThread);
    }

    return fReturn;                             
}

void Usage()
{
    printf("Usage:\n"
           "    testsg client <sg-ip-inet> [testlist]\n"
           "    testsg server\n"
           "    testsg virtual\n"
           "\n");
}

void Run()
{
    Verify(VLanInit());

    if (RunTest("SgMsg", "Sg", NULL))                   Test_SgMsg();
    if (RunTest("SgUdpCrypt", "SgUdp", "Sg", NULL))     Test_SgUdpCrypt();
    if (RunTest("SgUdpAuth", "SgUdp", "Sg", NULL))      Test_SgUdpAuth();
    if (RunTest("SgTcpCrypt", "SgTcp", "Sg", NULL))     Test_SgTcpCrypt();
    if (RunTest("SgTcpAuth", "SgTcp", "Sg", NULL))      Test_SgTcpAuth();
    
    VLanTerm();
}

int __cdecl main(int argc, char * argv[])
{
    if (argc < 2)
    {
        Usage();
        return(0);
    }

    g_argc = argc - 2;
    g_argv = argv + 2;

    if (lstrcmpiA(argv[1], "client") == 0)
    {
        if (argc < 3 || inet_addr(argv[2]) == INADDR_NONE)
        {
            printf("Error, testsg client requires an IP address\n\n");
            Usage();
            return(0);
        }

        g_argc--;
        g_argv++;

        g_ipInet = inet_addr(argv[2]);
        Run();
    }
    else if (lstrcmpiA(argv[1], "server") == 0)
    {
        Verify(NT_SUCCESS(SgConfigure(g_szServerConfiguration)));
    }
    else if (lstrcmpiA(argv[1], "virtual") == 0)
    {
        if (!RunVirtualSg())
        {
            return(0);
        }

        Run();

        SetEvent(g_hTermVirtualSg);
        CloseHandle(g_hTermVirtualSg);
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\obx\oblink.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    oblink.c

Abstract:

    This module implements routines to manage symbolic link objects.

--*/

#include "obp.h"

//
// Local support.
//

VOID
ObpDeleteSymbolicLink(
    PVOID Object
    );

//
// Object type information for symbolic links.
//
DECLSPEC_RDATA OBJECT_TYPE ObSymbolicLinkObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    ObpDeleteSymbolicLink,
    NULL,
    &ObpDefaultObject,
    'bmyS'
};

NTSTATUS
ObpResolveLinkTarget(
    IN POBJECT_STRING LinkTarget,
    OUT PVOID *ReturnedLinkTargetObject
    )
/*++

Routine Description:

    This routine resolves the object specified by the supplied target name.

Arguments:

    LinkTarget - Supplies the name of the link target.

    ReturnedLinkTargetObject - Supplies the location to receive the object
        reference.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;
    POBJECT_DIRECTORY Directory;
    OBJECT_STRING RemainingName;
    OBJECT_STRING ElementName;
    PVOID FoundObject;
    POBJECT_HEADER ObjectHeader;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE FileHandle;
    IO_STATUS_BLOCK IoStatusBlock;

    RemainingName = *LinkTarget;

    //
    // Verify that this is an absolute path.
    //

    if ((RemainingName.Length == 0) ||
        (RemainingName.Buffer[0] != OBJ_NAME_PATH_SEPARATOR)) {
        return STATUS_INVALID_PARAMETER;
    }

    ObpAcquireObjectManagerLock(&OldIrql);

    Directory = ObpRootDirectoryObject;

    for (;;) {

        ObDissectName(RemainingName, &ElementName, &RemainingName);

        //
        // Verify that there aren't multiple backslashes in the name.
        //

        if ((RemainingName.Length != 0) &&
            (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR)) {
            break;
        }

        //
        // Search for the object in the directory and return an error if it
        // doesn't already exist.
        //

        if (!ObpLookupElementNameInDirectory(Directory, &ElementName, TRUE,
            &FoundObject)) {
            break;
        }

        ObjectHeader = OBJECT_TO_OBJECT_HEADER(FoundObject);

        //
        // If we've consumed the entire path, then we found the object, so
        // return success.
        //

        if (RemainingName.Length == 0) {

            ObjectHeader->PointerCount++;

            *ReturnedLinkTargetObject = FoundObject;

            ObpReleaseObjectManagerLock(OldIrql);

            return STATUS_SUCCESS;
        }

        //
        // Only continue parsing in this loop if we found a directory object.
        //

        if (ObjectHeader->Type != &ObDirectoryObjectType) {

            //
            // Check if the object has a parse procedure.  If not, we don't know
            // how to continue resolving the link.
            //

            if (ObjectHeader->Type->ParseProcedure == NULL) {
                break;
            }

            //
            // Make sure the object stays alive after we drop the object manager
            // lock.
            //

            ObjectHeader->PointerCount++;

            ObpReleaseObjectManagerLock(OldIrql);

            //
            // Invoke the object's parse procedure.
            //

            status = ObjectHeader->Type->ParseProcedure(FoundObject, NULL,
                OBJ_CASE_INSENSITIVE, LinkTarget, &RemainingName, NULL,
                ReturnedLinkTargetObject);

            if (status == STATUS_OBJECT_TYPE_MISMATCH) {

                //
                // The parse procedure failed due to an object type mismatch.
                // We didn't specify a desired object type, so the most likely
                // reason for the failure is that we needed the I/O manager to
                // build a parse context object in order to resolve a file
                // object.  Attempt to resolve the link using NtOpenFile.
                //

                InitializeObjectAttributes(&ObjectAttributes, LinkTarget,
                    OBJ_CASE_INSENSITIVE, NULL, NULL);

                status = NtOpenFile(&FileHandle, 0, &ObjectAttributes,
                    &IoStatusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE |
                    FILE_SHARE_DELETE, FILE_DIRECTORY_FILE);

                if (NT_SUCCESS(status)) {
                    status = ObReferenceObjectByHandle(FileHandle,
                        &IoFileObjectType, ReturnedLinkTargetObject);
                    NtClose(FileHandle);
                }
            }

            ObDereferenceObject(FoundObject);

            return status;
        }

        Directory = (POBJECT_DIRECTORY)FoundObject;
    }

    ObpReleaseObjectManagerLock(OldIrql);

    return STATUS_INVALID_PARAMETER;
}

NTSTATUS
NtCreateSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN POBJECT_STRING LinkTarget
    )
/*++

Routine Description:

    This routine creates a symbolic link object with the supplied attributes.

Arguments:

    LinkHandle - Supplies the location to receive the created handle.

    ObjectAttributes - Supplies the name and parent directory of the new object.

    LinkTarget - Supplies the name of the link target.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID LinkTargetObject;
    ULONG LinkTargetLength;
    POBJECT_SYMBOLIC_LINK SymbolicLink;
    POSTR LinkTargetBuffer;

    //
    // Resolve the link target.  Unlike the NT implementation, we require the
    // target object to exist.
    //

    status = ObpResolveLinkTarget(LinkTarget, &LinkTargetObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Create the symbolic link object.
    //

    LinkTargetLength = LinkTarget->Length;

    status = ObCreateObject(&ObSymbolicLinkObjectType, ObjectAttributes,
        sizeof(OBJECT_SYMBOLIC_LINK) + LinkTargetLength, (PVOID*)&SymbolicLink);

    if (NT_SUCCESS(status)) {

        //
        // Copy the link target name to the symbolic link object.
        //

        LinkTargetBuffer = (POSTR)(SymbolicLink + 1);
        RtlCopyMemory(LinkTargetBuffer, LinkTarget->Buffer, LinkTargetLength);

        SymbolicLink->LinkTargetObject = LinkTargetObject;
        SymbolicLink->LinkTarget.Buffer = LinkTargetBuffer;
        SymbolicLink->LinkTarget.Length = (USHORT)LinkTargetLength;
        SymbolicLink->LinkTarget.MaximumLength = (USHORT)LinkTargetLength;

        status = ObInsertObject(SymbolicLink, ObjectAttributes, 0, LinkHandle);

    } else {
        ObDereferenceObject(LinkTargetObject);
    }

    return status;
}

NTSTATUS
NtOpenSymbolicLinkObject(
    OUT PHANDLE LinkHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
/*++

Routine Description:

    This routine opens an existing symbolic link object with the supplied
    attributes.

Arguments:

    LinkHandle - Supplies the location to receive the opened handle.

    ObjectAttributes - Supplies the name and parent directory of the desired
        object.

Return Value:

    Status of operation.

--*/
{
    return ObOpenObjectByName(ObjectAttributes, &ObSymbolicLinkObjectType, NULL,
        LinkHandle);
}

NTSTATUS
NtQuerySymbolicLinkObject(
    IN HANDLE LinkHandle,
    IN OUT POBJECT_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    )
/*++

Routine Description:

    This routine returns the link target string from the supplied symbolic link.

Arguments:

    LinkHandle - Supplies the handle of the symbolic link.

    LinkTarget - Supplies the buffer to receive the link target string.

    ReturnedLength - Supplies the location to receive the number of bytes
        required to hold the link target string.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    POBJECT_SYMBOLIC_LINK SymbolicLink;
    ULONG BytesRequired;
    ULONG NameBytesToCopy;

    //
    // Reference the symbolic link object.
    //

    status = ObReferenceObjectByHandle(LinkHandle, &ObSymbolicLinkObjectType,
        (PVOID*)&SymbolicLink);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Compute the number of bytes required to copy the string and the number of
    // bytes that we can actually copy.
    //

    BytesRequired = SymbolicLink->LinkTarget.Length;

    if (BytesRequired <= LinkTarget->MaximumLength) {
        NameBytesToCopy = BytesRequired;
        status = STATUS_SUCCESS;
    } else {
        NameBytesToCopy = LinkTarget->MaximumLength;
        status = STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory(LinkTarget->Buffer, SymbolicLink->LinkTarget.Buffer,
        NameBytesToCopy);

    LinkTarget->Length = (USHORT)NameBytesToCopy;

    //
    // Dereference the object and return the number of bytes that we copied or
    // that are required.
    //

    ObDereferenceObject(SymbolicLink);

    if (ReturnedLength != NULL) {
        *ReturnedLength = BytesRequired;
    }

    return status;
}

VOID
ObpDeleteSymbolicLink(
    PVOID Object
    )
/*++

Routine Description:

    This routine is called when the last reference to a symbolic link object is
    released.  The link target object is released.

Arguments:

    Object - Supplies the symbolic link to delete.

Return Value:

    None.

--*/
{
    ObDereferenceObject(((POBJECT_SYMBOLIC_LINK)Object)->LinkTargetObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\obx\obmanage.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    obmanage.c

Abstract:

    This module implements general routines related to the object manager.

--*/

#include "obp.h"

//
// Pointer to the directory object for the root of the object space.
//
POBJECT_DIRECTORY ObpRootDirectoryObject;

//
// Pointer to the directory object for the DOS devices space.
//
POBJECT_DIRECTORY ObpDosDevicesDirectoryObject;

//
// Pointer to the directory object for the devices space.
//
POBJECT_DIRECTORY ObpIoDevicesDirectoryObject;

//
// Pointer to the directory object for the Win32 named objects space.
//
POBJECT_DIRECTORY ObpWin32NamedObjectsDirectoryObject;

//
// Event used by object types that cannot be signaled.
//
INITIALIZED_KEVENT(ObpDefaultObject, SynchronizationEvent, TRUE);

//
// Name of the DOS devices directory object.
//
INITIALIZED_OBJECT_STRING_RDATA(ObpDosDevicesString, "\\??");
INITIALIZED_OBJECT_STRING_RDATA(ObpIoDevicesString, "\\Device");
INITIALIZED_OBJECT_STRING_RDATA(ObpWin32NamedObjectsString, "\\Win32NamedObjects");

//
// Local support.
//

BOOLEAN                      
ObpCreatePermanentDirectoryObject(
    IN POBJECT_STRING DirectoryName OPTIONAL,
    OUT POBJECT_DIRECTORY *DirectoryObject
    )
/*++

Routine Description:

    This routine creates a permament directory object with the supplied name.

Arguments:

    DirectoryName - Supplies the name of the directory object.

    DirectoryObject - Supplies the buffer to receive the pointer to the
        directory object.

Return Value:

    Returns TRUE if the directory object was created, else FALSE.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;

    InitializeObjectAttributes(&ObjectAttributes, DirectoryName, OBJ_PERMANENT,
        NULL, NULL);

    status = NtCreateDirectoryObject(&Handle, &ObjectAttributes);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    status = ObReferenceObjectByHandle(Handle, &ObDirectoryObjectType,
        (PVOID *)DirectoryObject);

    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    NtClose(Handle);

    return TRUE;
}

BOOLEAN
ObInitSystem(
    VOID
    )
/*++

Routine Description:

    This routine initializes the object manager.

Arguments:

    None.

Return Value:

    Returns TRUE if the object manager was successfully initialized, else FALSE.

--*/
{
    //
    // Initialize the object handle table.
    //

    ObpObjectHandleTable.HandleCount = 0;
    ObpObjectHandleTable.FirstFreeTableEntry = -1;
    ObpObjectHandleTable.NextHandleNeedingPool = 0;
    ObpObjectHandleTable.RootTable = NULL;

    //
    // Null out the DOS drive letters array.
    //

    RtlZeroMemory(ObpDosDevicesDriveLetterMap, sizeof(ObpDosDevicesDriveLetterMap));

    //
    // Create the root directory object.
    //

    if (!ObpCreatePermanentDirectoryObject(NULL, &ObpRootDirectoryObject)) {
        return FALSE;
    }

    //
    // Create the DOS devices directory object.
    //

    if (!ObpCreatePermanentDirectoryObject(&ObpDosDevicesString,
        &ObpDosDevicesDirectoryObject)) {
        return FALSE;
    }

    //
    // Create the I/O devices directory object.
    //

    if (!ObpCreatePermanentDirectoryObject(&ObpIoDevicesString,
        &ObpIoDevicesDirectoryObject)) {
        return FALSE;
    }

    //
    // Create the Win32 named objects directory object.
    //

    if (!ObpCreatePermanentDirectoryObject(&ObpWin32NamedObjectsString,
        &ObpWin32NamedObjectsDirectoryObject)) {
        return FALSE;
    }

    return TRUE;
}

VOID
ObDissectName(
    IN OBJECT_STRING Path,
    OUT POBJECT_STRING FirstName,
    OUT POBJECT_STRING RemainingName
    )

/*++

Routine Description:

    This routine cracks a path.  It picks off the first element in the
    given path name and provides both it and the remaining part.  A path
    is a set of file names separated by backslashes.  If a name begins
    with a backslash, the FirstName is the string immediately following
    the backslash.  Here are some examples:

        Path           FirstName    RemainingName
        ----           ---------    -------------
        empty          empty        empty

        \              empty        empty

        A              A            empty

        \A             A            empty

        A\B\C\D\E      A            B\C\D\E

        *A?            *A?          empty


    Note that both output strings use the same string buffer memory of the
    input string, and are not necessarily null terminated.

    Also, this routine makes no judgement as to the legality of each
    file name componant.  This must be done separatly when each file name
    is extracted.

Arguments:

    Path - The full path name to crack.

    FirstName - The first name in the path.  Don't allocate a buffer for
        this string.

    RemainingName - The rest of the path.  Don't allocate a buffer for this
        string.

Return Value:

    None.

--*/

{
    ULONG i = 0;
    ULONG PathLength;
    ULONG FirstNameStart;

    //
    //  Make both output strings empty for now
    //

    FirstName->Length = 0;
    FirstName->MaximumLength = 0;
    FirstName->Buffer = NULL;

    RemainingName->Length = 0;
    RemainingName->MaximumLength = 0;
    RemainingName->Buffer = NULL;

    PathLength = Path.Length / sizeof(OCHAR);

    //
    //  Check for an empty input string
    //

    if (PathLength == 0) {

        return;
    }

    //
    //  Skip over a starting backslash, and make sure there is more.
    //

    if ( Path.Buffer[0] == OTEXT('\\') ) {

        i = 1;
    }

    //
    //  Now run down the input string until we hit a backslash or the end
    //  of the string, remembering where we started;
    //

    for ( FirstNameStart = i;
          (i < PathLength) && (Path.Buffer[i] != OTEXT('\\'));
          i += 1 ) {

        NOTHING;
    }

    //
    //  At this point all characters up to (but not including) i are
    //  in the first part.   So setup the first name
    //

    FirstName->Length = (USHORT)((i - FirstNameStart) * sizeof(OCHAR));
    FirstName->MaximumLength = FirstName->Length;
    FirstName->Buffer = &Path.Buffer[FirstNameStart];

    //
    //  Now the remaining part needs a string only if the first part didn't
    //  exhaust the entire input string.  We know that if anything is left
    //  that is must start with a backslash.  Note that if there is only
    //  a trailing backslash, the length will get correctly set to zero.
    //

    if (i < PathLength) {

        RemainingName->Length = (USHORT)((PathLength - (i + 1)) * sizeof(OCHAR));
        RemainingName->MaximumLength = RemainingName->Length;
        RemainingName->Buffer = &Path.Buffer[i + 1];
    }

    //
    //  And return to our caller
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\obx\obcreate.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    obcreate.c

Abstract:

    This module implements routines to create and insert objects into the global
    handle table.

--*/

#include "obp.h"

NTSTATUS
ObCreateObject(
    IN POBJECT_TYPE ObjectType,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG ObjectBodySize,
    OUT PVOID *Object
    )
/*++

Routine Description:

    This routine creates an object with the supplied size and attributes.

Arguments:

    ObjectType - Supplies the type for the object.

    ObjectAttributes - Supplies the attributes for the object.

    ObjectBodySize - Supplies the number of bytes to allocate for the object's
        body.

    Object - Supplies the location to receive the created object.

Return Value:

    Status of operation.

--*/
{
    POBJECT_HEADER ObjectHeader;
    OBJECT_STRING RemainingName;
    OBJECT_STRING ElementName;
    POBJECT_HEADER_NAME_INFO ObjectNameInfo;

    *Object = NULL;

    //
    // Handle the trivial case of creating an unnamed object.
    //

    if (ObjectAttributes == NULL || ObjectAttributes->ObjectName == NULL) {

        ObjectHeader = (POBJECT_HEADER)ObjectType->AllocateProcedure(
            FIELD_OFFSET(OBJECT_HEADER, Body) + ObjectBodySize,
            ObjectType->PoolTag);

        if (ObjectHeader == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        ObjectHeader->PointerCount = 1;
        ObjectHeader->HandleCount = 0;
        ObjectHeader->Type = ObjectType;
        ObjectHeader->Flags = 0;

        *Object = &ObjectHeader->Body;

        return STATUS_SUCCESS;
    }

    //
    // The object is named.  Dissect the path to obtain the last element which
    // is the object's name.
    //

    RemainingName = *ObjectAttributes->ObjectName;
    ElementName.Buffer = NULL;
    ElementName.Length = 0;

    while (RemainingName.Length != 0) {

        ObDissectName(RemainingName, &ElementName, &RemainingName);

        //
        // Verify that there aren't multiple backslashes in the name.
        //

        if ((RemainingName.Length != 0) && (RemainingName.Buffer[0] ==
            OBJ_NAME_PATH_SEPARATOR)) {
            return STATUS_OBJECT_NAME_INVALID;
        }
    }

    //
    // There should be at least one character in the element name.
    //

    if (ElementName.Length == 0) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    //
    // Allocate the object header, body, and name in one chunk.
    //

    ObjectBodySize = ALIGN_UP(ObjectBodySize, ULONG);

    ObjectNameInfo = (POBJECT_HEADER_NAME_INFO)ObjectType->AllocateProcedure(
        sizeof(OBJECT_HEADER_NAME_INFO) + FIELD_OFFSET(OBJECT_HEADER, Body) +
        ObjectBodySize + ElementName.Length, ObjectType->PoolTag);

    if (ObjectNameInfo == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize the object.
    //

    ObjectHeader = (POBJECT_HEADER)(ObjectNameInfo + 1);

    ObjectNameInfo->ChainLink = NULL;
    ObjectNameInfo->Directory = NULL;
    ObjectNameInfo->Name.Buffer = (POSTR)((PUCHAR)&ObjectHeader->Body +
        ObjectBodySize);
    ObjectNameInfo->Name.Length = ElementName.Length;
    ObjectNameInfo->Name.MaximumLength = ElementName.Length;

    RtlCopyMemory(ObjectNameInfo->Name.Buffer, ElementName.Buffer,
        ElementName.Length);

    ObjectHeader->PointerCount = 1;
    ObjectHeader->HandleCount = 0;
    ObjectHeader->Type = ObjectType;
    ObjectHeader->Flags = OB_FLAG_NAMED_OBJECT;

    *Object = &ObjectHeader->Body;

    return STATUS_SUCCESS;
}

NTSTATUS
ObInsertObject(
    IN PVOID Object,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG ObjectPointerBias,
    OUT PHANDLE ReturnedHandle
    )
/*++

Routine Description:

    This routine inserts the supplied object into the handle table and
    optionally into an object directory.

Arguments:

    Object - Supplies the object to insert into the handle table.

    ObjectAttributes - Supplies the attributes for the object.

    ObjectPointerBias - Supplies the number of additional pointer references
        that should be applied to the object.

    ReturnedHandle - Supplies the location to receive the object's handle.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    HANDLE Handle;
    PVOID InsertObject;
    HANDLE RootDirectoryHandle;
    POBJECT_HEADER ObjectHeader;
    POBJECT_DIRECTORY Directory;
    KIRQL OldIrql;
    OBJECT_STRING RemainingName;
    OBJECT_STRING ElementName;
    PVOID FoundObject;
    POBJECT_HEADER_NAME_INFO ObjectHeaderNameInfo;
    ULONG HashIndex;
    PVOID DosDevicesObject;
    OCHAR DriveLetter;

    ObpAcquireObjectManagerLock(&OldIrql);

    Handle = NULL;
    InsertObject = Object;

    //
    // Check if the object is named.  If so, then we need to go find the
    // directory to attach the object to.
    //

    if (ObjectAttributes != NULL && ObjectAttributes->ObjectName != NULL) {

        RemainingName = *ObjectAttributes->ObjectName;

        //
        // ObCreateObject has already checked that the name has at least one
        // character in it and that there aren't multiple backslashes in the
        // name.
        //

        ASSERT(RemainingName.Length != 0);

        //
        // Determine whether we parse the object name from an absolute or
        // relative root directory.
        //

        RootDirectoryHandle = ObjectAttributes->RootDirectory;

        if (RootDirectoryHandle != NULL) {

            //
            // Verify that this is not an absolute path.
            //

            if (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) {
                status = STATUS_OBJECT_NAME_INVALID;
                goto CleanupAndExit;
            }

            if (RootDirectoryHandle == ObDosDevicesDirectory()) {

                //
                // Reference the root of the DOS devices space.
                //

                Directory = ObpDosDevicesDirectoryObject;

            } else if (RootDirectoryHandle == ObWin32NamedObjectsDirectory()) {

                //
                // Reference the root of the Win32 named objects space.
                //

                Directory = ObpWin32NamedObjectsDirectoryObject;

            } else {

                //
                // Reference the root directory handle.
                //

                Directory = (POBJECT_DIRECTORY)
                    ObpGetObjectHandleContents(RootDirectoryHandle);

                if (Directory == NULL) {
                    status = STATUS_INVALID_HANDLE;
                    goto CleanupAndExit;
                }

                if (OBJECT_TO_OBJECT_HEADER(Directory)->Type != &ObDirectoryObjectType) {
                    status = STATUS_OBJECT_TYPE_MISMATCH;
                    goto CleanupAndExit;
                }
            }

        } else {

            //
            // Verify that this is an absolute path.
            //

            if (RemainingName.Buffer[0] != OBJ_NAME_PATH_SEPARATOR) {
                status = STATUS_OBJECT_NAME_INVALID;
                goto CleanupAndExit;
            }

            //
            // Reference the global root directory handle.
            //

            Directory = ObpRootDirectoryObject;
        }

        for (;;) {

            ObDissectName(RemainingName, &ElementName, &RemainingName);

            if (ObpLookupElementNameInDirectory(Directory, &ElementName, TRUE,
                &FoundObject)) {

                //
                // If we found the element and there's no more of a path to
                // process, then we can't create the object due to a name
                // collision.
                //

                if (RemainingName.Length == 0) {

                    if (ObpIsFlagSet(ObjectAttributes->Attributes, OBJ_OPENIF)) {

                        if (OBJECT_TO_OBJECT_HEADER(FoundObject)->Type ==
                            OBJECT_TO_OBJECT_HEADER(Object)->Type) {

                            //
                            // We found an object with the same name and type.
                            // The caller wants us to open that object instead
                            // of the one we were given, so change the insertion
                            // object.
                            //
                            // Null out the directory pointer so that we don't
                            // attempt to reinsert this object into the
                            // directory.
                            //

                            InsertObject = FoundObject;
                            Directory = NULL;
                            break;

                        } else {
                            status = STATUS_OBJECT_TYPE_MISMATCH;
                            goto CleanupAndExit;
                        }

                    } else {
                        status = STATUS_OBJECT_NAME_COLLISION;
                        goto CleanupAndExit;
                    }
                }

                //
                // We found the element and there's more of a path to process.
                // The object we found had better be a directory.
                //

                if (OBJECT_TO_OBJECT_HEADER(FoundObject)->Type !=
                    &ObDirectoryObjectType) {
                    status = STATUS_OBJECT_PATH_NOT_FOUND;
                    goto CleanupAndExit;
                }

                Directory = (POBJECT_DIRECTORY)FoundObject;

            } else {

                //
                // If we failed to find the element and there's more of a path
                // name to process, then return path not found.
                //

                if (RemainingName.Length != 0) {
                    status = STATUS_OBJECT_PATH_NOT_FOUND;
                    goto CleanupAndExit;
                }

                //
                // Break out of the loop since we've consumed the entire path
                // and we didn't collide with an existing object's name.
                //

                break;
            }
        }

    } else {
        Directory = NULL;
    }

    //
    // Create the handle for the object.
    //

    Handle = ObpCreateObjectHandle(InsertObject);

    if (Handle == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto CleanupAndExit;
    }

    //
    // Apply the reference bias to the object, including one for the handle
    // itself.
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(InsertObject);
    ObjectHeader->PointerCount += ObjectPointerBias + 1;

    //
    // If the object is to be attached to an object directory, then do it now.
    //

    if (Directory != NULL) {

        ObjectHeaderNameInfo = OBJECT_TO_OBJECT_HEADER_NAME_INFO(Object);

        HashIndex = ObpComputeHashIndex(&ObjectHeaderNameInfo->Name);

        ObjectHeader->Flags |= OB_FLAG_ATTACHED_OBJECT;

        ObjectHeaderNameInfo->Directory = Directory;
        ObjectHeaderNameInfo->ChainLink = Directory->HashBuckets[HashIndex];
        Directory->HashBuckets[HashIndex] = ObjectHeaderNameInfo;

        //
        // If we're attaching a drive letter relative to the DOS devices
        // directory, then also add the object to the quick array lookup.  If
        // the object that we're attaching is a symbolic link object, then put
        // the resolved link target in the quick array-- the common case is to
        // lookup fully resolve paths.
        //

        if ((Directory == ObpDosDevicesDirectoryObject) &&
            (ObjectHeaderNameInfo->Name.Length == sizeof(OCHAR) * 2) &&
            (ObjectHeaderNameInfo->Name.Buffer[1] == (OCHAR)':')) {

            DosDevicesObject = Object;

            if (OBJECT_TO_OBJECT_HEADER(DosDevicesObject)->Type ==
                &ObSymbolicLinkObjectType) {
                DosDevicesObject =
                    ((POBJECT_SYMBOLIC_LINK)DosDevicesObject)->LinkTargetObject;
            }

            DriveLetter = ObjectHeaderNameInfo->Name.Buffer[0];

            if (DriveLetter >= 'a' && DriveLetter <= 'z') {
                ASSERT(ObpDosDevicesDriveLetterMap[DriveLetter - 'a'] == NULL);
                ObpDosDevicesDriveLetterMap[DriveLetter - 'a'] = DosDevicesObject;
            } else if (DriveLetter >= 'A' && DriveLetter <= 'Z') {
                ASSERT(ObpDosDevicesDriveLetterMap[DriveLetter - 'A'] == NULL);
                ObpDosDevicesDriveLetterMap[DriveLetter - 'A'] = DosDevicesObject;
            }
        }

        //
        // Increment the number of references to the object and the directory.
        // These references are undone in ObpDetachNamedObject.
        //

        OBJECT_TO_OBJECT_HEADER(Directory)->PointerCount++;
        ObjectHeader->PointerCount++;
    }

    //
    // Mark the object as permanent if requested.
    //

    if ((ObjectAttributes != NULL) &&
        ObpIsFlagSet(ObjectAttributes->Attributes, OBJ_PERMANENT)) {
        ObjectHeader->Flags |= OB_FLAG_PERMANENT_OBJECT;
    }

    status = (Object == InsertObject) ? STATUS_SUCCESS : STATUS_OBJECT_NAME_EXISTS;

CleanupAndExit:
    ObpReleaseObjectManagerLock(OldIrql);

    ObDereferenceObject(Object);

    *ReturnedHandle = Handle;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\obx\obp.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    obp.h

Abstract:

    This module contains the private data structures and procedure
    prototypes for the object management system.

--*/

#ifndef _OBP_
#define _OBP_

#include <ntos.h>

//
// Bit flag macros.
//

#define ObpIsFlagSet(flagset, flag)             (((flagset) & (flag)) != 0)
#define ObpIsFlagClear(flagset, flag)           (((flagset) & (flag)) == 0)

//
// Define macros to lock and unlock the object manager.
//

#define ObpAcquireObjectManagerLock(OldIrql) \
    *(OldIrql) = KeRaiseIrqlToDpcLevel()

#define ObpReleaseObjectManagerLock(OldIrql) \
    KeLowerIrql(OldIrql)

#define ObpAssertObjectManagerLock() \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

//
// Routines which operate on directory objects.
//

ULONG
FASTCALL
ObpComputeHashIndex(
    IN POBJECT_STRING ElementName
    );

BOOLEAN
ObpLookupElementNameInDirectory(
    IN POBJECT_DIRECTORY Directory,
    IN POBJECT_STRING ElementName,
    IN BOOLEAN ResolveSymbolicLink,
    OUT PVOID *ReturnedObject
    );

NTSTATUS
ObpReferenceObjectByName(
    IN HANDLE RootDirectoryHandle,
    IN POBJECT_STRING ObjectName,
    IN ULONG Attributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PVOID *ReturnedObject
    );

//
// Routines which operate on the handle table.
//

VOID
ObpInitializeObjectHandleTable(
    VOID
    );

HANDLE
ObpCreateObjectHandle(
    PVOID Object
    );

PVOID
ObpGetObjectHandleReference(
    HANDLE Handle
    );

PVOID
ObpGetObjectHandleContents(
    HANDLE Handle
    );

PVOID
ObpDestroyObjectHandle(
    HANDLE Handle
    );

//
// External symbols.
//

extern POBJECT_DIRECTORY ObpRootDirectoryObject;
extern POBJECT_DIRECTORY ObpDosDevicesDirectoryObject;
extern POBJECT_DIRECTORY ObpIoDevicesDirectoryObject;
extern POBJECT_DIRECTORY ObpWin32NamedObjectsDirectoryObject;
extern PVOID ObpDosDevicesDriveLetterMap['Z' - 'A' + 1];
extern OBJECT_HANDLE_TABLE ObpObjectHandleTable;

#endif  // OBP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\obx\obhandle.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    obhandle.c

Abstract:

    This module implements routines to manage object handles.

--*/

#include "obp.h"

VOID
ObpDetachNamedObject(
    IN PVOID Object,
    IN KIRQL OldIrql
    )
/*++

Routine Description:

    This routine detaches a named object from its parent directory.

Arguments:

    Object - Supplies the named object to remove.

Return Value:

    None.

--*/
{
    POBJECT_HEADER_NAME_INFO ObjectHeaderNameInfo;
    POBJECT_DIRECTORY Directory;
    OCHAR DriveLetter;
    ULONG HashIndex;
    POBJECT_HEADER_NAME_INFO LastObjectHeaderNameInfo;
    POBJECT_HEADER_NAME_INFO CurrentObjectHeaderNameInfo;

    ObpAssertObjectManagerLock();

    ASSERT(ObpIsFlagSet(OBJECT_TO_OBJECT_HEADER(Object)->Flags, OB_FLAG_NAMED_OBJECT));
    ASSERT(ObpIsFlagSet(OBJECT_TO_OBJECT_HEADER(Object)->Flags, OB_FLAG_ATTACHED_OBJECT));

    ObjectHeaderNameInfo = OBJECT_TO_OBJECT_HEADER_NAME_INFO(Object);

    Directory = ObjectHeaderNameInfo->Directory;

    //
    // If we're removing a drive letter relative to the DOS devices directory,
    // then also remove the object from the quick array lookup.
    //

    if ((Directory == ObpDosDevicesDirectoryObject) &&
        (ObjectHeaderNameInfo->Name.Length == sizeof(OCHAR) * 2) &&
        (ObjectHeaderNameInfo->Name.Buffer[1] == (OCHAR)':')) {

        DriveLetter = ObjectHeaderNameInfo->Name.Buffer[0];

        if (DriveLetter >= 'a' && DriveLetter <= 'z') {
            ASSERT(ObpDosDevicesDriveLetterMap[DriveLetter - 'a'] != NULL);
            ObpDosDevicesDriveLetterMap[DriveLetter - 'a'] = NULL;
        } else if (DriveLetter >= 'A' && DriveLetter <= 'Z') {
            ASSERT(ObpDosDevicesDriveLetterMap[DriveLetter - 'A'] != NULL);
            ObpDosDevicesDriveLetterMap[DriveLetter - 'A'] = NULL;
        }
    }

    //
    // Compute the hash index for the object's name.
    //

    HashIndex = ObpComputeHashIndex(&ObjectHeaderNameInfo->Name);

    //
    // Walk through the directory's hash table to find the object so that we
    // can detach it.
    //

    LastObjectHeaderNameInfo = NULL;
    CurrentObjectHeaderNameInfo = Directory->HashBuckets[HashIndex];

    while (CurrentObjectHeaderNameInfo != ObjectHeaderNameInfo) {

        LastObjectHeaderNameInfo = CurrentObjectHeaderNameInfo;
        CurrentObjectHeaderNameInfo = CurrentObjectHeaderNameInfo->ChainLink;

        ASSERT(CurrentObjectHeaderNameInfo != NULL);
    }

    //
    // Remove the entry.
    //

    if (LastObjectHeaderNameInfo == NULL) {
        Directory->HashBuckets[HashIndex] = CurrentObjectHeaderNameInfo->ChainLink;
    } else {
        LastObjectHeaderNameInfo->ChainLink = CurrentObjectHeaderNameInfo->ChainLink;
    }

    //
    // Null out the link and directory fields so that we don't attempt to do
    // this again.
    //

    ObjectHeaderNameInfo->ChainLink = NULL;
    ObjectHeaderNameInfo->Directory = NULL;

    //
    // Release the reference to the directory and the object which applied in
    // ObInsertObject.
    //

    ObpReleaseObjectManagerLock(OldIrql);

    ObDereferenceObject(Directory);
    ObDereferenceObject(Object);
}

NTSTATUS
NtClose(
    IN HANDLE Handle
    )
/*++

Routine Description:

    This routine closes the supplied handle.

Arguments:

    Handle - Supplies the handle to close.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;
    PVOID Object;
    POBJECT_HEADER ObjectHeader;
    ULONG HandleCount;

    ObpAcquireObjectManagerLock(&OldIrql);

    //
    // Attempt to destroy the handle and obtain the object that was stored
    // in the handle.
    //

    Object = ObpDestroyObjectHandle(Handle);

    if (Object != NULL) {

        ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

        //
        // Grab the current handle count for the object.
        //

        HandleCount = ObjectHeader->HandleCount;
        ASSERT(HandleCount > 0);

        //
        // Decrement the number of handles for this object.
        //

        ObjectHeader->HandleCount--;

        //
        // If the object type has a close procedure, invoke it with the old
        // handle count.
        //

        if (ObjectHeader->Type->CloseProcedure != NULL) {

            ObpReleaseObjectManagerLock(OldIrql);

            ObjectHeader->Type->CloseProcedure(Object, HandleCount);

            ObpAcquireObjectManagerLock(&OldIrql);
        }

        //
        // Check if the object should be removed from its parent directory.
        //

        if ((ObjectHeader->HandleCount == 0) &&
            ObpIsFlagSet(ObjectHeader->Flags, OB_FLAG_ATTACHED_OBJECT) &&
            ObpIsFlagClear(ObjectHeader->Flags, OB_FLAG_PERMANENT_OBJECT)) {
            ObpDetachNamedObject(Object, OldIrql);
        } else {
            ObpReleaseObjectManagerLock(OldIrql);
        }

        //
        // Release the reference that the handle held on the object.
        //

        ObDereferenceObject(Object);

        status = STATUS_SUCCESS;

    } else {

        ObpReleaseObjectManagerLock(OldIrql);

        status = STATUS_INVALID_HANDLE;
    }

    return status;
}

NTSTATUS
NtDuplicateObject(
    IN HANDLE SourceHandle,
    OUT PHANDLE TargetHandle,
    IN ULONG Options
    )
/*++

Routine Description:

    This routine duplicates the supplied handle.

Arguments:

    SourceHandle - Supplies the handle to duplicate.

    TargetHandle - Supplies the location to receive the duplicated handle.

    Options - Supplies options that control the duplication process.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID Object;

    //
    // Obtain the object referenced by the handle.
    //

    status = ObReferenceObjectByHandle(SourceHandle, NULL, &Object);

    if (!NT_SUCCESS(status)) {
        *TargetHandle = NULL;
        return status;
    }

    //
    // Close the source handle if requested to.
    //

    if (ObpIsFlagSet(Options, DUPLICATE_CLOSE_SOURCE)) {
        NtClose(SourceHandle);
    }

    //
    // Create a handle for the object and release the reference we acquired
    // above.
    //

    status = ObOpenObjectByPointer(Object, OBJECT_TO_OBJECT_HEADER(Object)->Type,
        TargetHandle);

    ObDereferenceObject(Object);

    return status;
}

NTSTATUS
NtMakeTemporaryObject(
    IN HANDLE Handle
    )
/*++

Routine Description:

    This routine converts a permanent object to a non permanent object.  Non
    permanent objects are removed from the object directory when the last
    handle is closed.

Arguments:

    Handle - Supplies the handle to make temporary.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID Object;

    status = ObReferenceObjectByHandle(Handle, NULL, &Object);

    if (NT_SUCCESS(status)) {
        ObMakeTemporaryObject(Object);
        ObDereferenceObject(Object);
    }

    return status;
}

VOID
ObMakeTemporaryObject (
    IN PVOID Object
    )
/*++

Routine Description:

    This routine converts a permanent object to a non permanent object.  Non
    permanent objects are removed from the object directory when the last
    handle is closed.

Arguments:

    Object - Supplies the object to make temporary.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    POBJECT_HEADER ObjectHeader;

    ObpAcquireObjectManagerLock(&OldIrql);

    //
    // Clear the permanent flag.
    //

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);
    ObjectHeader->Flags &= ~OB_FLAG_PERMANENT_OBJECT;

    //
    // Check if the object should be removed from its parent directory.
    //

    if ((ObjectHeader->HandleCount == 0) &&
        ObpIsFlagSet(ObjectHeader->Flags, OB_FLAG_ATTACHED_OBJECT)) {
        ObpDetachNamedObject(Object, OldIrql);
    } else {
        ObpReleaseObjectManagerLock(OldIrql);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\obx\obdir.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    obdir.c

Abstract:

    This module implements routines to manage directory objects.

--*/

#include "obp.h"

//
// Object type information for directories.
//
DECLSPEC_RDATA OBJECT_TYPE ObDirectoryObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    NULL,
    NULL,
    &ObpDefaultObject,
    'eriD'
};

//
// Array lookup of the DOS drive letters for the DOS devices directory object.
//
PVOID ObpDosDevicesDriveLetterMap['Z' - 'A' + 1];

NTSTATUS
NtCreateDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
/*++

Routine Description:

    This routine creates a directory object with the supplied attributes.

Arguments:

    DirectoryHandle - Supplies the location to receive the created handle.

    ObjectAttributes - Supplies the name and parent directory of the new object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    POBJECT_DIRECTORY Directory;

    //
    // Create the directory object.
    //

    status = ObCreateObject(&ObDirectoryObjectType, ObjectAttributes,
        sizeof(OBJECT_DIRECTORY), (PVOID*)&Directory);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(Directory, sizeof(OBJECT_DIRECTORY));

        status = ObInsertObject(Directory, ObjectAttributes, 0, DirectoryHandle);
    }

    return status;
}

NTSTATUS
NtOpenDirectoryObject(
    OUT PHANDLE DirectoryHandle,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
/*++

Routine Description:

    This routine opens an existing directory object with the supplied
    attributes.

Arguments:

    DirectoryHandle - Supplies the location to receive the opened handle.

    ObjectAttributes - Supplies the name and parent directory of the desired
        object.

Return Value:

    Status of operation.

--*/
{
    return ObOpenObjectByName(ObjectAttributes, &ObDirectoryObjectType, NULL,
        DirectoryHandle);
}

NTSTATUS
NtQueryDirectoryObject(
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnedLength OPTIONAL
    )
/*++

Routine Description:

    This routine returns the next directory entry from the supplied object
    directory.

Arguments:

    DirectoryHandle - Supplies the handle of the object directory.

    Buffer - Supplies the buffer to receive the information.

    Length - Supplies the length of the above buffer.

    RestartScan - Supplies whether or not the scan should restart.

    Context - Supplies data that controls the current position of the
        enumeration.

    ReturnedLength - Supplies the location to receive the number of bytes copied
        to the buffer or the number of bytes required if the buffer is too
        small.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    POBJECT_DIRECTORY_INFORMATION DirectoryInformation;
    POBJECT_DIRECTORY Directory;
    ULONG BytesRequired;
    ULONG DesiredIndex;
    ULONG CurrentIndex;
    KIRQL OldIrql;
    ULONG HashBucket;
    POBJECT_HEADER_NAME_INFO ObjectHeaderNameInfo;
    ULONG NameBytesToCopy;
    POSTR ReturnedObjectName;

    //
    // Verify that we have enough space to write out at least the header.
    //

    DirectoryInformation = (POBJECT_DIRECTORY_INFORMATION)Buffer;

    if (Length < sizeof(OBJECT_DIRECTORY_INFORMATION)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Reference the directory object.
    //

    status = ObReferenceObjectByHandle(DirectoryHandle, &ObDirectoryObjectType,
        (PVOID*)&Directory);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Assume that we won't find any more entries.
    //

    status = STATUS_NO_MORE_ENTRIES;
    BytesRequired = 0;

    //
    // Figure out which entry we want to find.
    //

    DesiredIndex = RestartScan ? 0 : *Context;
    CurrentIndex = 0;

    //
    // Loop over all of the hash buckets until we find our desired index.
    //

    ObpAcquireObjectManagerLock(&OldIrql);

    for (HashBucket = 0; HashBucket < OB_NUMBER_HASH_BUCKETS; HashBucket++) {

        ObjectHeaderNameInfo = Directory->HashBuckets[HashBucket];

        while (ObjectHeaderNameInfo != NULL) {

            if (CurrentIndex == DesiredIndex) {

                //
                // Compute the number of bytes required to copy the string and
                // the number of bytes that we can actually copy.
                //

                NameBytesToCopy = ObjectHeaderNameInfo->Name.Length;
                BytesRequired = sizeof(OBJECT_DIRECTORY_INFORMATION) +
                    NameBytesToCopy;

                if (BytesRequired <= Length) {
                    status = STATUS_SUCCESS;
                } else {
                    NameBytesToCopy = Length - sizeof(OBJECT_DIRECTORY_INFORMATION);
                    status = STATUS_BUFFER_TOO_SMALL;
                }

                ReturnedObjectName = (POCHAR)(DirectoryInformation + 1);

                DirectoryInformation->Type =
                    OBJECT_HEADER_NAME_INFO_TO_OBJECT_HEADER(ObjectHeaderNameInfo)->Type->PoolTag;
                DirectoryInformation->Name.Buffer = ReturnedObjectName;
                DirectoryInformation->Name.Length =
                    ObjectHeaderNameInfo->Name.Length;
                DirectoryInformation->Name.MaximumLength =
                    ObjectHeaderNameInfo->Name.Length;

                RtlCopyMemory(ReturnedObjectName,
                    ObjectHeaderNameInfo->Name.Buffer, NameBytesToCopy);

                //
                // Bump up the index number for the next iteration.
                //

                *Context = DesiredIndex + 1;

                goto FoundDesiredIndex;
            }

            ObjectHeaderNameInfo = ObjectHeaderNameInfo->ChainLink;
            CurrentIndex++;
        }
    }

FoundDesiredIndex:
    ObpReleaseObjectManagerLock(OldIrql);

    //
    // Dereference the object and return the number of bytes that we copied or
    // that are required.
    //

    ObDereferenceObject(Directory);

    if (ReturnedLength != NULL) {
        *ReturnedLength = BytesRequired;
    }

    return status;
}

ULONG
FASTCALL
ObpComputeHashIndex(
    IN POBJECT_STRING ElementName
    )
/*++

Routine Description:

    This routine computes the hash index for the supplied name.

Arguments:

    ElementName - Supplies the name to compute the hash value for.

Return Value:

    The hash index.

--*/
{
    ULONG HashIndex;
    PUCHAR Buffer;
    PUCHAR BufferEnd;
    UCHAR Char;

    HashIndex = 0;
    Buffer = (PUCHAR)ElementName->Buffer;
    BufferEnd = Buffer + ElementName->Length;

    while (Buffer < BufferEnd) {

        Char = *Buffer++;

        //
        // Don't allow extended characters to change the hash value since we're
        // going to be doing case insensitive comparisions.
        //

        if (Char >= 0x80) {
            continue;
        }

        //
        // Force any upper case characters to be lower case.
        //

        Char |= 0x20;

        HashIndex += (HashIndex << 1) + (HashIndex >> 1) + Char;
    }

    return HashIndex % OB_NUMBER_HASH_BUCKETS;
}

BOOLEAN
ObpLookupElementNameInDirectory(
    IN POBJECT_DIRECTORY Directory,
    IN POBJECT_STRING ElementName,
    IN BOOLEAN ResolveSymbolicLink,
    OUT PVOID *ReturnedObject
    )
/*++

Routine Description:

    This routine searches the object directory for the supplied object name.

Arguments:

    Directory - Supplies the object directory to search.

    ElementName - Supplies the name of the object to find.

    ResolveSymbolicLink - Supplies TRUE if the returned object should be the
        target of a symbolic link

    ReturnedObject - Supplies the location to receive the object if found.

Return Value:

    Returns TRUE if the element name was found, else FALSE.

--*/
{
    OCHAR DriveLetter;
    PVOID Object;
    ULONG HashIndex;
    POBJECT_HEADER_NAME_INFO ObjectHeaderNameInfo;

    ObpAssertObjectManagerLock();

    //
    // If we're looking up a drive letter relative to the DOS devices directory
    // and we're allowed to resolve symbolic links, then do a quick array lookup
    // instead of walking the hash table.
    //

    if ((Directory == ObpDosDevicesDirectoryObject) &&
        ResolveSymbolicLink &&
        (ElementName->Length == sizeof(OCHAR) * 2) &&
        (ElementName->Buffer[1] == (OCHAR)':')) {

        DriveLetter = ElementName->Buffer[0];

        if (DriveLetter >= 'a' && DriveLetter <= 'z') {
            Object = ObpDosDevicesDriveLetterMap[DriveLetter - 'a'];
        } else if (DriveLetter >= 'A' && DriveLetter <= 'Z') {
            Object = ObpDosDevicesDriveLetterMap[DriveLetter - 'A'];
        } else {
            Object = NULL;
        }

        if (Object != NULL) {
            *ReturnedObject = Object;
            return TRUE;
        }
    }

    //
    // Compute the hash index for the element name.
    //

    HashIndex = ObpComputeHashIndex(ElementName);

    //
    // Walk through the object's on this hash chain.
    //

    ObjectHeaderNameInfo = Directory->HashBuckets[HashIndex];

    while (ObjectHeaderNameInfo != NULL) {

        if (RtlEqualObjectString(&ObjectHeaderNameInfo->Name, ElementName, TRUE)) {

            Object = OBJECT_HEADER_NAME_INFO_TO_OBJECT(ObjectHeaderNameInfo);

            //
            // Resolve the symbolic link if requested to.
            //

            if (ResolveSymbolicLink &&
                (OBJECT_TO_OBJECT_HEADER(Object)->Type == &ObSymbolicLinkObjectType)) {
                Object = ((POBJECT_SYMBOLIC_LINK)Object)->LinkTargetObject;
            }

            *ReturnedObject = Object;
            return TRUE;
        }

        ObjectHeaderNameInfo = ObjectHeaderNameInfo->ChainLink;
    }

    *ReturnedObject = NULL;
    return FALSE;
}

NTSTATUS
ObpReferenceObjectByName(
    IN HANDLE RootDirectoryHandle,
    IN POBJECT_STRING ObjectName,
    IN ULONG Attributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PVOID *ReturnedObject
    )
/*++

Routine Description:

    This routine references the object with the supplied name and attributes.

Arguments:

    RootDirectoryHandle - Supplies the handle to the root directory to begin
        searching from.

    ObjectName - Supplies the name of the object to reference.

    Attributes - Supplies the attributes of the desired object.

    ObjectType - Optionally supplies the desired type for the returned object.

    ParseContext - Supplies state used while parsing the object's attributes.

    ReturnedObject - Supplies the location to receive the object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;
    OBJECT_STRING RemainingName;
    OBJECT_STRING ElementName;
    BOOLEAN ResolveSymbolicLink;
    PVOID FoundObject;
    POBJECT_HEADER ObjectHeader;
    POBJECT_DIRECTORY Directory;
    PVOID ParsedObject;

    *ReturnedObject = NULL;

    ObpAcquireObjectManagerLock(&OldIrql);

    if (ObjectName != NULL) {
        RemainingName = *ObjectName;
    } else {
        RtlZeroMemory(&RemainingName, sizeof(OBJECT_STRING));
    }

    ResolveSymbolicLink = TRUE;

    //
    // Determine whether we parse the object name from an absolute or
    // relative root directory.
    //

    if (RootDirectoryHandle != NULL) {

        if (RootDirectoryHandle == ObDosDevicesDirectory()) {

            //
            // Reference the root of the DOS devices space.
            //

            FoundObject = ObpDosDevicesDirectoryObject;

        } else if (RootDirectoryHandle == ObWin32NamedObjectsDirectory()) {

            //
            // Reference the root of the Win32 named objects space.
            //

            FoundObject = ObpWin32NamedObjectsDirectoryObject;

        } else {

            //
            // Reference the root directory handle.
            //

            FoundObject = (POBJECT_DIRECTORY)ObpGetObjectHandleContents(RootDirectoryHandle);

            if (FoundObject == NULL) {
                status = STATUS_INVALID_HANDLE;
                goto CleanupAndExit;
            }
        }

        //
        // Verify that this is not an absolute path.
        //

        if ((RemainingName.Length != 0) &&
            (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR)) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto CleanupAndExit;
        }

        goto OpenRootDirectory;
    }

    //
    // Verify that this is an absolute path.
    //

    if ((RemainingName.Length == 0) ||
        (RemainingName.Buffer[0] != OBJ_NAME_PATH_SEPARATOR)) {
        status = STATUS_OBJECT_NAME_INVALID;
        goto CleanupAndExit;
    }

    //
    // Reference the global root directory handle.
    //

    FoundObject = ObpRootDirectoryObject;

    //
    // Check if we're supposed to open the root directory.
    //

    if (RemainingName.Length == sizeof(OCHAR)) {

        //
        // Advance past the backslash.
        //

        RemainingName.Buffer++;
        RemainingName.Length = 0;
        RemainingName.MaximumLength = 0;

        goto OpenRootDirectory;
    }

    //
    // Process the object name.
    //

    for (;;) {

        Directory = (POBJECT_DIRECTORY)FoundObject;

        ASSERT(OBJECT_TO_OBJECT_HEADER(Directory)->Type == &ObDirectoryObjectType);

        ObDissectName(RemainingName, &ElementName, &RemainingName);

        if (RemainingName.Length != 0) {

            //
            // Verify that there aren't multiple backslashes in the name.
            //

            if (RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) {
                status = STATUS_OBJECT_NAME_INVALID;
                goto CleanupAndExit;
            }

        } else {

            //
            // If the caller is trying to access a symbolic link object, then
            // don't resolve symbolic links for the last element.
            //

            if (ObjectType == &ObSymbolicLinkObjectType) {
                ResolveSymbolicLink = FALSE;
            }
        }

        //
        // Search for the object in the directory and return an error if it
        // doesn't already exist.
        //

        if (!ObpLookupElementNameInDirectory(Directory, &ElementName,
            ResolveSymbolicLink, &FoundObject)) {
            status = (RemainingName.Length != 0) ?
                STATUS_OBJECT_PATH_NOT_FOUND : STATUS_OBJECT_NAME_NOT_FOUND;
            goto CleanupAndExit;
        }

OpenRootDirectory:
        ObjectHeader = OBJECT_TO_OBJECT_HEADER(FoundObject);

        //
        // If we've consumed the entire path, then we found the object, so
        // return success.
        //

        if (RemainingName.Length == 0) {

            //
            // If the object has a parse procedure, then we need to invoke it
            // since it may want to return a different object (such as when we
            // open a device object, we really want to return a file object).
            //

            if (ObjectHeader->Type->ParseProcedure != NULL) {
                goto InvokeParseProcedure;
            }

            //
            // Verify that the found object matches the requested object type.
            //

            if ((ObjectType != NULL) && (ObjectType != ObjectHeader->Type)) {
                status = STATUS_OBJECT_TYPE_MISMATCH;
                goto CleanupAndExit;
            }

            ObjectHeader->PointerCount++;

            *ReturnedObject = FoundObject;

            status = STATUS_SUCCESS;
            goto CleanupAndExit;
        }

        //
        // Only continue parsing in this loop if we found a directory object.
        //

        if (ObjectHeader->Type != &ObDirectoryObjectType) {

            //
            // If the object has a parse procedure, use it to evaluate the
            // remainder of the string.  If not, then we can't go any further.
            //

            if (ObjectHeader->Type->ParseProcedure == NULL) {
                status = STATUS_OBJECT_PATH_NOT_FOUND;
                goto CleanupAndExit;
            }

            //
            // Make sure the object stays alive after we drop the object manager
            // lock.
            //

InvokeParseProcedure:
            ObjectHeader->PointerCount++;

            ObpReleaseObjectManagerLock(OldIrql);

            //
            // If this isn't a file object that we're parsing, then back the
            // remaining name up to the path separator.  If we do have a file
            // object, then it must be from a symbolic link to a directory.  For
            // a directory, we want it to appear that we're doing a relative
            // lookup, so we don't want the leading backslash.
            //

            if (ObjectHeader->Type != &IoFileObjectType &&
                (RemainingName.Buffer > ObjectName->Buffer)) {

                RemainingName.Buffer--;
                RemainingName.Length += sizeof(OCHAR);
                RemainingName.MaximumLength = RemainingName.Length;

                ASSERT(RemainingName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR);
            }

            //
            // Invoke the object's parse procedure.
            //

            ParsedObject = NULL;

            status = ObjectHeader->Type->ParseProcedure(FoundObject, ObjectType,
                Attributes, ObjectName, &RemainingName, ParseContext,
                &ParsedObject);

            ObDereferenceObject(FoundObject);

            //
            // Verify that the parsed object matches the requested object type.
            //

            if (NT_SUCCESS(status)) {

                ASSERT(ParsedObject != NULL);

                if ((ObjectType == NULL) ||
                    (ObjectType == OBJECT_TO_OBJECT_HEADER(ParsedObject)->Type)) {

                    *ReturnedObject = ParsedObject;
                    status = STATUS_SUCCESS;

                } else {

                    ObDereferenceObject(ParsedObject);
                    status = STATUS_OBJECT_TYPE_MISMATCH;
                }
            }

            return status;
        }
    }

CleanupAndExit:
    ObpReleaseObjectManagerLock(OldIrql);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\obx\obref.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    obref.c

Abstract:

    This module implements routines to reference and dereference objects.

--*/

#include "obp.h"

VOID
FASTCALL
ObfReferenceObject(
    IN PVOID Object
    )
/*++

Routine Description:

    This routine increments the reference count for the supplied object.

Arguments:

    Object - Supplies the object to reference.

Return Value:

    None.

--*/
{
    InterlockedIncrement(&OBJECT_TO_OBJECT_HEADER(Object)->PointerCount);
}

NTSTATUS
ObReferenceObjectByPointer(
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType
    )
/*++

Routine Description:

    This routine increments the reference count for the supplied object after
    validating the object type.

Arguments:

    Object - Supplies the object to reference.

    ObjectType - Optionally supplies the desired type for the returned object.

Return Value:

    Status of operation.

--*/
{
    POBJECT_HEADER ObjectHeader;

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

    if (ObjectType == ObjectHeader->Type) {

        InterlockedIncrement(&ObjectHeader->PointerCount);

        return STATUS_SUCCESS;

    } else {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }
}

NTSTATUS
ObOpenObjectByPointer(
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType,
    OUT PHANDLE ReturnedHandle
    )
/*++

Routine Description:

    This routine creates a new handle for the supplied object after validating
    the object type.

Arguments:

    Object - Supplies the object to reference.

    ObjectType - Optionally supplies the desired type for the returned object.

    ReturnedHandle - Supplies the location to receive the object's handle.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    HANDLE Handle;
    KIRQL OldIrql;

    status = ObReferenceObjectByPointer(Object, ObjectType);

    if (NT_SUCCESS(status)) {

        ObpAcquireObjectManagerLock(&OldIrql);

        Handle = ObpCreateObjectHandle(Object);

        ObpReleaseObjectManagerLock(OldIrql);

        if (Handle != NULL) {
            status = STATUS_SUCCESS;
        } else {
            ObDereferenceObject(Object);
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {
        Handle = NULL;
    }

    *ReturnedHandle = Handle;

    return status;
}

NTSTATUS
ObReferenceObjectByHandle(
    IN HANDLE Handle,
    IN POBJECT_TYPE ObjectType OPTIONAL,
    OUT PVOID *ReturnedObject
    )
/*++

Routine Description:

    This routine returns the object referenced by the supplied handle and
    optionally validates the object type.

Arguments:

    Handle - Supplies the handle to reference.

    ObjectType - Optionally supplies the desired type for the returned object.

    ReturnedObject - Supplies the pointer to receive the returned object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID Object;
    POBJECT_HEADER ObjectHeader;

    //
    // Check for the static current process or thread handles.
    //

    if (Handle == NtCurrentThread()) {

        if ((ObjectType == &PsThreadObjectType) || (ObjectType == NULL)) {

            Object = PsGetCurrentThread();
            ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);
            InterlockedIncrement(&ObjectHeader->PointerCount);

            *ReturnedObject = Object;

            return STATUS_SUCCESS;

        } else {
            status = STATUS_OBJECT_TYPE_MISMATCH;
        }

    } else {

        //
        // The handle is not one of the static handles, so reference the object
        // from the handle and validate the type.
        //

        Object = ObpGetObjectHandleReference(Handle);

        if (Object != NULL) {

            ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

            if ((ObjectType == ObjectHeader->Type) || (ObjectType == NULL)) {

                *ReturnedObject = Object;

                return STATUS_SUCCESS;

            } else {
                ObDereferenceObject(Object);
                status = STATUS_OBJECT_TYPE_MISMATCH;
            }

        } else {
            status = STATUS_INVALID_HANDLE;
        }
    }

    *ReturnedObject = NULL;

    return status;
}

NTSTATUS
ObReferenceObjectByName(
    IN POBJECT_STRING ObjectName,
    IN ULONG Attributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PVOID *ReturnedObject
    )
/*++

Routine Description:

    This routine references the object with the supplied name and attributes.

Arguments:

    ObjectName - Supplies the name of the object to reference.

    Attributes - Supplies the attributes of the desired object.

    ObjectType - Optionally supplies the desired type for the returned object.

    ParseContext - Supplies state used while parsing the object's attributes.

    ReturnedObject - Supplies the location to receive the object.

Return Value:

    Status of operation.

--*/
{
    return ObpReferenceObjectByName(NULL, ObjectName, Attributes, ObjectType,
        ParseContext, ReturnedObject);
}

NTSTATUS
ObOpenObjectByName(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PHANDLE ReturnedHandle
    )
/*++

Routine Description:

    This routine creates a new handle for the object with the supplied
    attributes after validating the object type.

Arguments:

    ObjectAttributes - Supplies the attributes of the desired object.

    ObjectType - Optionally supplies the desired type for the returned object.

    ParseContext - Supplies state used while parsing the object's attributes.

    ReturnedHandle - Supplies the location to receive the object's handle.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PVOID Object;
    HANDLE Handle;
    KIRQL OldIrql;

    status = ObpReferenceObjectByName(ObjectAttributes->RootDirectory,
        ObjectAttributes->ObjectName, ObjectAttributes->Attributes, ObjectType,
        ParseContext, &Object);

    if (NT_SUCCESS(status)) {

        ObpAcquireObjectManagerLock(&OldIrql);

        Handle = ObpCreateObjectHandle(Object);

        ObpReleaseObjectManagerLock(OldIrql);

        if (Handle == NULL) {
            ObDereferenceObject(Object);
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {
        Handle = NULL;
    }

    *ReturnedHandle = Handle;

    return status;
}

VOID
FASTCALL
ObfDereferenceObject(
    IN PVOID Object
    )
/*++

Routine Description:

    This routine decrements the reference count for the supplied object and
    destroys the object when the reference count reaches zero.

Arguments:

    Object - Supplies the object to reference.

Return Value:

    None.

--*/
{
    POBJECT_HEADER ObjectHeader;
    PVOID ObjectBase;

    ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

    if (InterlockedDecrement(&ObjectHeader->PointerCount) == 0) {

        ASSERT(ObjectHeader->HandleCount == 0);

        //
        // If the object has a delete procedure, then invoke it.
        //

        if (ObjectHeader->Type->DeleteProcedure != NULL) {
            ObjectHeader->Type->DeleteProcedure(Object);
        }

        //
        // Determine the allocation base for the object and free the memory.
        //

        if (ObpIsFlagSet(ObjectHeader->Flags, OB_FLAG_NAMED_OBJECT)) {
            ObjectBase = OBJECT_HEADER_TO_OBJECT_HEADER_NAME_INFO(ObjectHeader);
            ASSERT(((POBJECT_HEADER_NAME_INFO)ObjectBase)->Directory == NULL);
        } else {
            ObjectBase = ObjectHeader;
        }

        ObjectHeader->Type->FreeProcedure(ObjectBase);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\obx\obwait.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    obwait.c

Abstract:

    This module implements the generic wait system services.

--*/

#include "obp.h"

NTSTATUS
NtSignalAndWaitForSingleObjectEx (
    IN HANDLE SignalHandle,
    IN HANDLE WaitHandle,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function atomically signals the specified signal object and then
    waits until the specified wait object attains a state of Signaled.  An
    optional timeout can also be specified.  If a timeout is not specified,
    then the wait will not be satisfied until the wait object attains a
    state of Signaled.  If a timeout is specified, and the wait object has
    not attained a state of Signaled when the timeout expires, then the
    wait is automatically satisfied.  If an explicit timeout value of zero
    is specified, then no wait will occur if the wait cannot be satisfied
    immediately.  The wait can also be specified as alertable.

Arguments:

    SignalHandle - Supplies the handle of the signal object.

    WaitHandle  - Supplies the handle for the wait object.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait
        is alertable.

    Timeout - Supplies an pointer to an absolute or relative time over
        which the wait is to occur.

Return Value:

    The wait completion status.  A value of STATUS_TIMEOUT is returned if a
    timeout occurred.  A value of STATUS_SUCCESS is returned if the specified
    object satisfied the wait.  A value of STATUS_ALERTED is returned if the
    wait was aborted to deliver an alert to the current thread.  A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{
    PVOID RealObject;
    PVOID SignalObject;
    POBJECT_HEADER SignalObjectHeader;
    NTSTATUS Status;
    PVOID WaitObject;
    POBJECT_HEADER WaitObjectHeader;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    //  Reference the signal object by handle.
    //

    Status = ObReferenceObjectByHandle( SignalHandle,
                                        NULL,
                                        &SignalObject );

    //
    //  If the reference was successful, then reference the wait object by
    //  handle.
    //

    if (NT_SUCCESS(Status)) {

        Status = ObReferenceObjectByHandle( WaitHandle,
                                            NULL,
                                            &WaitObject );

        //
        //  If the reference was successful, then determine the real wait
        //  object, check the signal object access, signal the signal object,
        //  and wait for the real wait object.
        //

        if (NT_SUCCESS(Status)) {

            WaitObjectHeader = OBJECT_TO_OBJECT_HEADER(WaitObject);
            RealObject = WaitObjectHeader->Type->DefaultObject;

            if ((LONG_PTR)RealObject >= 0) {

                RealObject = (PVOID)((PCHAR)WaitObject + (ULONG_PTR)RealObject);
            }

            //
            //  If the signal object is an event, then check for modify access
            //  and set the event.  Otherwise, if the signal object is a
            //  mutant, then attempt to release ownership of the mutant.
            //  Otherwise, if the object is a semaphore, then check for modify
            //  access and release the semaphore.  Otherwise, the signal objet
            //  is invalid.
            //

            SignalObjectHeader = OBJECT_TO_OBJECT_HEADER(SignalObject);
            Status = STATUS_ACCESS_DENIED;

            if (SignalObjectHeader->Type == &ExEventObjectType) {

                //
                //  Set the specified event and wait atomically.
                //

                KeSetEvent((PKEVENT)SignalObject, EVENT_INCREMENT, TRUE);

            } else if (SignalObjectHeader->Type == &ExMutantObjectType) {

                //
                //  Release the specified mutant and wait atomically.
                //
                //  N.B. The release will only be successful if the current
                //       thread is the owner of the mutant.
                //

                try {

                    KeReleaseMutant( (PKMUTANT)SignalObject,
                                     MUTANT_INCREMENT,
                                     FALSE,
                                     TRUE );

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    Status = GetExceptionCode();

                    goto WaitExit;
                }

            } else if (SignalObjectHeader->Type == &ExSemaphoreObjectType) {

                //
                //  Release the specified semaphore and wait atomically.
                //

                try {

                    //
                    //  Release the specified semaphore and wait atomically.
                    //

                    KeReleaseSemaphore( (PKSEMAPHORE)SignalObject,
                                        SEMAPHORE_INCREMENT,
                                        1,
                                        TRUE );

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    Status = GetExceptionCode();

                    goto WaitExit;
                }

            } else {

                Status = STATUS_OBJECT_TYPE_MISMATCH;

                goto WaitExit;
            }

            //
            //  Protect the wait call just in case KeWait decides to raise
            //  For example, a mutant level is exceeded
            //

            try {

                Status = KeWaitForSingleObject( RealObject,
                                                UserRequest,
                                                WaitMode,
                                                Alertable,
                                                Timeout );

            } except(EXCEPTION_EXECUTE_HANDLER) {

                Status = GetExceptionCode();
            }

WaitExit:

            ObDereferenceObject(WaitObject);
        }

        ObDereferenceObject(SignalObject);
    }

    return Status;
}

NTSTATUS
NtWaitForSingleObject (
    IN HANDLE Handle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )
{
    return NtWaitForSingleObjectEx (Handle, KernelMode, Alertable, Timeout);
}

NTSTATUS
NtWaitForSingleObjectEx (
    IN HANDLE Handle,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function waits until the specified object attains a state of
    Signaled.  An optional timeout can also be specified.  If a timeout
    is not specified, then the wait will not be satisfied until the
    object attains a state of Signaled.  If a timeout is specified, and
    the object has not attained a state of Signaled when the timeout
    expires, then the wait is automatically satisfied.  If an explicit
    timeout value of zero is specified, then no wait will occur if the
    wait cannot be satisfied immediately.  The wait can also be specified
    as alertable.

Arguments:

    Handle  - Supplies the handle for the wait object.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait
        is alertable.

    Timeout - Supplies an pointer to an absolute or relative time over
        which the wait is to occur.

Return Value:

    The wait completion status. A value of STATUS_TIMEOUT is returned if a
    timeout occurred.  A value of STATUS_SUCCESS is returned if the specified
    object satisfied the wait.  A value of STATUS_ALERTED is returned if the
    wait was aborted to deliver an alert to the current thread. A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{
    PVOID Object;
    POBJECT_HEADER ObjectHeader;
    NTSTATUS Status;
    PVOID WaitObject;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    //  Get a referenced pointer to the specified object with synchronize
    //  access.
    //

    Status = ObReferenceObjectByHandle( Handle, NULL, &Object );

    //
    //  If access is granted, then check to determine if the specified object
    //  can be waited on.
    //

    if (NT_SUCCESS(Status)) {

        ObjectHeader = OBJECT_TO_OBJECT_HEADER( Object );
        WaitObject = ObjectHeader->Type->DefaultObject;

        if ((LONG_PTR)WaitObject >= 0) {

            WaitObject = (PVOID)((PCHAR)Object + (ULONG_PTR)WaitObject);
        }

        //
        //  Protect the wait call just in case KeWait decides to raise
        //  For example, a mutant level is exceeded
        //

        try {

            Status = KeWaitForSingleObject( WaitObject,
                                            UserRequest,
                                            WaitMode,
                                            Alertable,
                                            Timeout );

        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();
        }

        ObDereferenceObject(Object);
    }

    return Status;
}

NTSTATUS
NtWaitForMultipleObjectsEx (
    IN ULONG Count,
    IN HANDLE Handles[],
    IN WAIT_TYPE WaitType,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function waits until the specified objects attain a state of
    Signaled.  The wait can be specified to wait until all of the objects
    attain a state of Signaled or until one of the objects attains a state
    of Signaled.  An optional timeout can also be specified.  If a timeout
    is not specified, then the wait will not be satisfied until the objects
    attain a state of Signaled.  If a timeout is specified, and the objects
    have not attained a state of Signaled when the timeout expires, then
    the wait is automatically satisfied.  If an explicit timeout value of
    zero is specified, then no wait will occur if the wait cannot be satisfied
    immediately.  The wait can also be specified as alertable.

Arguments:

    Count - Supplies a count of the number of objects that are to be waited
        on.

    Handles[] - Supplies an array of handles to wait objects.

    WaitType - Supplies the type of wait to perform (WaitAll, WaitAny).

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait is
        alertable.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

Return Value:

    The wait completion status.  A value of STATUS_TIMEOUT is returned if a
    timeout occurred.  The index of the object (zero based) in the object
    pointer array is returned if an object satisfied the wait.  A value of
    STATUS_ALERTED is returned if the wait was aborted to deliver an alert
    to the current thread.  A value of STATUS_USER_APC is returned if the
    wait was aborted to deliver a user APC to the current thread.

--*/

{
    ULONG i;
    ULONG j;
    PVOID Object;
    POBJECT_HEADER ObjectHeader;
    PVOID Objects[MAXIMUM_WAIT_OBJECTS];
    ULONG RefCount;
    ULONG Size;
    NTSTATUS Status;
    PKWAIT_BLOCK WaitBlockArray;
    union {
        PVOID WaitObjects[MAXIMUM_WAIT_OBJECTS];
        struct {
            PVOID WaitObjectsSmall[OB_MAXIMUM_STACK_WAIT_BLOCKS];
            KWAIT_BLOCK WaitBlocks[OB_MAXIMUM_STACK_WAIT_BLOCKS];
        };
    } WaitState;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    //  If the number of objects is zero or greater than the largest number
    //  that can be waited on, then return and invalid parameter status.
    //

    if ((Count == 0) || (Count > MAXIMUM_WAIT_OBJECTS)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  If the wait type is not wait any or wait all, then return an invalid
    //  parameter status.
    //

    if ((WaitType != WaitAny) && (WaitType != WaitAll)) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  If the number of objects to be waited on is greater than the number
    //  of stack wait blocks, then allocate an array of wait blocks from
    //  nonpaged pool. If the wait block array cannot be allocated, then
    //  return insufficient resources.
    //

    if (Count > OB_MAXIMUM_STACK_WAIT_BLOCKS) {

        Size = Count * sizeof( KWAIT_BLOCK );
        WaitBlockArray = ExAllocatePoolWithTag(Size, 'tiaW');

        if (WaitBlockArray == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

    } else {

        WaitBlockArray = WaitState.WaitBlocks;
    }

    //
    //  Loop through the array of handles and get a referenced pointer to
    //  each object.
    //

    i = 0;
    RefCount = 0;

    Status = STATUS_SUCCESS;

    do {

        //
        //  Get the handle table entry
        //

        Object = ObpGetObjectHandleReference( Handles[i] );

        //
        //  Make sure the handle really did translate to a valid
        //  entry
        //

        if (Object != NULL) {

            RefCount += 1;
            Objects[i] = Object;

            //
            //  We have a object with proper access so get the header
            //  and if the default objects points to a real object
            //  then that is the one we're going to wait on.
            //  Otherwise we'll find the kernel wait object at an
            //  offset into the object body
            //

            ObjectHeader = OBJECT_TO_OBJECT_HEADER(Object);

            if ((LONG_PTR)ObjectHeader->Type->DefaultObject < 0) {

                WaitState.WaitObjects[i] = ObjectHeader->Type->DefaultObject;

            } else {

                //
                //  Compute the address of the kernel wait object.
                //

                WaitState.WaitObjects[i] = (PVOID)((PCHAR)&ObjectHeader->Body +
                    (ULONG_PTR)ObjectHeader->Type->DefaultObject);
            }

        } else {

            //
            //  The entry in the handle table isn't in use
            //

            Status = STATUS_INVALID_HANDLE;

            goto ServiceFailed;
        }

        i += 1;

    } while (i < Count);

    //
    //  At this point the WaitObjects[] is set to the kernel wait objects
    //
    //  Now Check to determine if any of the objects are specified more than
    //  once, but we only need to check this for wait all, with a wait any
    //  the user can specify the same object multiple times.
    //

    if (WaitType == WaitAll) {

        i = 0;

        do {

            for (j = i + 1; j < Count; j += 1) {

                if (WaitState.WaitObjects[i] == WaitState.WaitObjects[j]) {

                    Status = STATUS_INVALID_PARAMETER_MIX;

                    goto ServiceFailed;
                }
            }

            i += 1;

        } while (i < Count);
    }

    //
    //  Wait for the specified objects to attain a state of Signaled or a
    //  time out to occur.  Protect the wait call just in case KeWait decides
    //  to raise For example, a mutant level is exceeded
    //

    try {

        Status = KeWaitForMultipleObjects( Count,
                                           WaitState.WaitObjects,
                                           WaitType,
                                           UserRequest,
                                           WaitMode,
                                           Alertable,
                                           Timeout,
                                           WaitBlockArray );

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Status = GetExceptionCode();
    }

    //
    //  If any objects were referenced, then deference them.
    //

ServiceFailed:

    while (RefCount > 0) {

        RefCount -= 1;
        ObDereferenceObject(Objects[RefCount]);
    }

    //
    //  If a wait block array was allocated, then deallocate it.
    //

    if (WaitBlockArray != WaitState.WaitBlocks) {

        ExFreePool(WaitBlockArray);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\phy\phy.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    phy.c

Abstract:

    Ethernet transceiver code inside the ROM

Revision History:

    04/5/2001 davidx
        Created it.
    06/5/2001 dinartem
        Moved to ntos\phy and made it independent of the xnet codebase

--*/

#include <stddef.h>
#include <ntos.h>
#include <nturtl.h>
#include <xtl.h>
#include "phy.h"

//
// Global variables
//  NOTE: The init count persists across quick reboots.
//
DECLSPEC_STICKY DWORD PhyInitFlag;
DWORD PhyLinkState;
LONG PhyLockFlag;

#define PhyLock() InterlockedCompareExchange(&PhyLockFlag, 1, 0)
#define PhyUnlock() (PhyLockFlag = 0)

//
// Macro for spewing debug message
//
#if DBG
BOOL PhyVerboseMode = TRUE;
#define WARNING_ DbgPrint
#define VERBOSE_ !PhyVerboseMode ? (void)0 : (void)DbgPrint
#else !DBG
#define WARNING_ 1 ? (void)0 : (void)
#define VERBOSE_ 1 ? (void)0 : (void)
#endif

#define NETERR(_err)        HRESULT_FROM_WIN32(_err)
#define NETERR_OK           STATUS_SUCCESS
#define NETERR_HARDWARE     0x801f0001  // hardware not responding

BOOL PhyWriteReg(PNICCSR csr, DWORD phyreg, DWORD val);
BOOL PhyReadReg(PNICCSR csr, DWORD phyreg, DWORD* val);

BOOL
PhyUpdateLinkState(
    PNICCSR csr
    )

/*++

Routine Description:

    Update PHY link state information
    (read the information from the PHY registers)

Arguments:

    csr - Points to the NIC registers

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD anar, lpanar, miiStatus, state = 0;

    if (!PhyReadReg(csr, MIIREG_ANAR, &anar) ||
        !PhyReadReg(csr, MIIREG_LPANAR, &lpanar) ||
        !PhyReadReg(csr, MIIREG_STATUS, &miiStatus))
        return FALSE;

    anar &= lpanar;
    if (anar & (MII4_100BASE_T_FULL_DUPLEX | MII4_100BASE_T_HALF_DUPLEX))
        state |= XNET_ETHERNET_LINK_100MBPS;
    else if (anar & (MII4_10BASE_T_FULL_DUPLEX | MII4_10BASE_T_HALF_DUPLEX))
        state |= XNET_ETHERNET_LINK_10MBPS;

    if (anar & (MII4_10BASE_T_FULL_DUPLEX | MII4_100BASE_T_FULL_DUPLEX))
        state |= XNET_ETHERNET_LINK_FULL_DUPLEX;
    else if (anar & (MII4_10BASE_T_HALF_DUPLEX | MII4_100BASE_T_HALF_DUPLEX))
        state |= XNET_ETHERNET_LINK_HALF_DUPLEX;

    if (miiStatus & MIISTATUS_LINK_IS_UP)
        state |= XNET_ETHERNET_LINK_ACTIVE;

    PhyLinkState = state;
    return TRUE;
}


//
// Wait for up to 500ms until the link to be up.
//
DWORD PhyWaitForLinkUp(PNICCSR csr)
{
    DWORD miiStatus = 0;
    INT timeout = 1000;
    while (timeout-- && !(miiStatus & MIISTATUS_LINK_IS_UP)) {
        KeStallExecutionProcessor(500);
        if (!PhyReadReg(csr, MIIREG_STATUS, &miiStatus)) break;
    }
    return miiStatus;
}


// Clear MDIOADR_LOCK bit
VOID PhyClearMDIOLOCK(PNICCSR csr)
{
    INT timeout;

    csr->mdio_adr = MDIOADR_LOCK;
    WARNING_("PHY: MDIOADR_LOCK is set\n");

    timeout = PHYRW_TIMEOUT;
    do {
        KeStallExecutionProcessor(50);
        timeout -= 50;
    } while (timeout > 0 && (csr->mdio_adr & MDIOADR_LOCK));
}


BOOL
PhyReadReg(
    PNICCSR csr,
    DWORD phyreg,
    DWORD* val
    )

/*++

Routine Description:

    Read the value of a PHY register

Arguments:

    csr - Points to the NIC registers
    phyreg - Specifies the PHY register to be read
    val - Return the PHY register value

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD mdioadr;
    INT timeout;

    // The lock bit shouldn't be set.
    // Clear it just in case it's stuck.

    if (csr->mdio_adr & MDIOADR_LOCK) {
        PhyClearMDIOLOCK(csr);
    }

    // Write the PHY register address

    mdioadr = (PHY_ADDR << MDIOADR_PHYSHIFT) | (phyreg << MDIOADR_REGSHIFT);
    csr->mdio_adr = mdioadr;

    mdioadr |= MDIOADR_LOCK;
    for (timeout=PHYRW_TIMEOUT; timeout > 0 && (mdioadr & MDIOADR_LOCK); timeout -= 50) {
        KeStallExecutionProcessor(50);
        mdioadr = csr->mdio_adr;
    }

    // Read the PHY register value
    *val = csr->mdio_data;

    if (mdioadr & MDIOADR_LOCK) {
        WARNING_("PHY read failed: reg %d.\n", phyreg);
        ASSERT(FALSE);
        return FALSE;
    }

    return TRUE;
}


BOOL
PhyWriteReg(
    PNICCSR csr,
    DWORD phyreg,
    DWORD val
    )

/*++

Routine Description:

    Write the specified value to a PHY register

Arguments:

    csr - Points to the NIC registers
    phyreg - Specifies the PHY register to be written
    val - Specifies the value for the PHY register

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD mdioadr;
    INT timeout;

    // The lock bit shouldn't be set.
    // Clear it just in case it's stuck.

    if (csr->mdio_adr & MDIOADR_LOCK) {
        PhyClearMDIOLOCK(csr);
    }

    // Write the data first

    csr->mdio_data = val;

    // Write the PHY register address

    mdioadr = (PHY_ADDR << MDIOADR_PHYSHIFT) | (phyreg << MDIOADR_REGSHIFT) | MDIOADR_WRITE;
    csr->mdio_adr = mdioadr;

    mdioadr |= MDIOADR_LOCK;
    for (timeout=PHYRW_TIMEOUT; timeout > 0 && (mdioadr & MDIOADR_LOCK); timeout -= 50) {
        KeStallExecutionProcessor(50);
        mdioadr = csr->mdio_adr;
    }

    if (mdioadr & MDIOADR_LOCK) {
        WARNING_("PHY write failed: reg %d.\n", phyreg);
        ASSERT(FALSE);
        return FALSE;
    }

    return TRUE;
}


NTSTATUS
PhyInitialize(
    BOOL forceReset,
    VOID* param OPTIONAL
    )

/*++

Routine Description:

    Initialize the Ethernet PHY interface

Arguments:

    forceReset - Whether to force a PHY reset
    param -optional parameters

Return Value:

    Status code

--*/

{
    PNICCSR csr = PNicCsr();
    DWORD miiControl, miiStatus;
    INT timeout;
    NTSTATUS status = NETERR_HARDWARE;

    if (PhyLock() != 0)
        return NETERR(ERROR_BUSY);
    
    if (forceReset) {
        PhyInitFlag = 0;
        PhyLinkState = 0;

        //
        // Force the PHY to reset
        //
        miiControl = MIICONTROL_RESET;
        if (!PhyWriteReg(csr, MIIREG_CONTROL, miiControl)) goto err;

        // Wait for up to 500ms
        timeout = 1000;
        while (timeout-- && (miiControl & MIICONTROL_RESET)) {
            KeStallExecutionProcessor(500);
            if (!PhyReadReg(csr, MIIREG_CONTROL, &miiControl)) goto err;
        }

        // If the reset is still asserted, return error
        if (miiControl & MIICONTROL_RESET) goto err;
    } else if (PhyInitFlag) {
        //
        // If PHY is already initialized, just update the link state
        //
        PhyUpdateLinkState(csr);
        status = NETERR_OK;
        goto exit;
    }

    // The auto-negotiation should be started by now.
    // Wait for a max of 3 seconds for it to complete.
    timeout = 6000;
    miiStatus = 0;
    while (timeout-- && !(miiStatus & MIISTATUS_AUTO_NEGOTIATION_COMPLETE)) {
        KeStallExecutionProcessor(500);
        if (!PhyReadReg(csr, MIIREG_STATUS, &miiStatus)) goto err;
    }

    // NOTE: Workaround for ICS PHY problems with some 10base-t hubs
    //  e.g. Garret Communications Magnum Personal Hub H50
    if (XboxHardwareInfo.McpRevision != 0xa1) {
        DWORD icshack;
        // clear bit 8 of undocumented register 0x18
        if (PhyReadReg(csr, 0x18, &icshack)) {
            icshack &= ~0x0100;
            PhyWriteReg(csr, 0x18, icshack);
        }
    }

    //
    // Use auto-negotiation
    //
    if (!PhyReadReg(csr, MIIREG_CONTROL, &miiControl)) goto err;

    if (miiControl & MIICONTROL_RESTART_AUTO_NEGOTIATION) {
        // If the restart-auto-negotiation bit is set,
        // default to the highest available speed in half-duplex mode.
        WARNING_("Auto-negotiation didn't succeed.\n");

        if (miiStatus & (MIISTATUS_100MBS_T4_CAPABLE |
                         MIISTATUS_100MBS_X_HALF_DUPLEX_CAPABLE |
                         MIISTATUS_100MBS_T2_HALF_DUPLEX_CAPABLE)) {
            // We can do 100Mbps
            miiControl |=  MIICONTROL_SPEED_SELECTION_BIT1;
            miiControl &= ~MIICONTROL_SPEED_SELECTION_BIT0;
            PhyLinkState |= XNET_ETHERNET_LINK_100MBPS;
        } else if (miiStatus & MIISTATUS_10MBS_HALF_DUPLEX_CAPABLE) {
            // We can do 10Mbps
            miiControl &= ~MIICONTROL_SPEED_SELECTION_BIT1;
            miiControl |=  MIICONTROL_SPEED_SELECTION_BIT0;
            PhyLinkState |= XNET_ETHERNET_LINK_10MBPS;
        } else
            goto err;

        PhyLinkState |= XNET_ETHERNET_LINK_HALF_DUPLEX;

        // Set the desired speed if the auto-negotiation never completed
        PhyWriteReg(csr, MIIREG_CONTROL, miiControl);

        miiStatus = PhyWaitForLinkUp(csr);
        if (miiStatus & MIISTATUS_LINK_IS_UP)
            PhyLinkState |= XNET_ETHERNET_LINK_ACTIVE;
    } else {
        // Auto-negotiation worked.
        PhyWaitForLinkUp(csr);
        if (!PhyUpdateLinkState(csr)) goto err;
    }

    PhyInitFlag = 1;
    status = NETERR_OK;

exit:
    PhyUnlock();
    return status;

err:
    WARNING_("Ethernet PHY initialization failed.\n");
    goto exit;
}


//
// Public function for retrieving link state information
//
DWORD PhyGetLinkState(BOOL update)
{
    if ((!PhyLinkState || update) && PhyLock() == 0) {
        PhyUpdateLinkState(PNicCsr());
        PhyUnlock();
    }
    return PhyLinkState;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ps\psctx.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psctx.c

Abstract:

    This procedure implements Get/Set Context Thread

Author:

    Mark Lucovsky (markl) 25-May-1989

Revision History:

--*/

#include "psp.h"

VOID
PspQueueApcSpecialApc(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )
{
    PAGED_CODE();

    ExFreePool(Apc);
}

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThread(
    IN HANDLE ThreadHandle,
    IN PPS_APC_ROUTINE ApcRoutine,
    IN PVOID ApcArgument1,
    IN PVOID ApcArgument2,
    IN PVOID ApcArgument3
    )

/*++

Routine Description:

    This function is used to queue a user-mode APC to the specified thread. The APC
    will fire when the specified thread does an alertable wait

Arguments:

    ThreadHandle - Supplies a handle to a thread object.  The caller
        must have THREAD_SET_CONTEXT access to the thread.

    ApcRoutine - Supplies the address of the APC routine to execute when the
        APC fires.

    ApcArgument1 - Supplies the first PVOID passed to the APC

    ApcArgument2 - Supplies the second PVOID passed to the APC

    ApcArgument3 - Supplies the third PVOID passed to the APC

Return Value:

    Returns an NT Status code indicating success or failure of the API

--*/

{
    PETHREAD Thread;
    NTSTATUS Status;
    PKAPC Apc;

    PAGED_CODE();

    Status = ObReferenceObjectByHandle(ThreadHandle,
                                       &PsThreadObjectType,
                                       (PVOID *)&Thread);

    if (NT_SUCCESS(Status)) {

        Apc = ExAllocatePoolWithTag(sizeof(*Apc), 'pasP');

        if (Apc != NULL) {

            KeInitializeApc(Apc,
                            &Thread->Tcb,
                            PspQueueApcSpecialApc,
                            NULL,
                            (PKNORMAL_ROUTINE)ApcRoutine,
                            UserMode,
                            ApcArgument1);

            if (!KeInsertQueueApc(Apc, ApcArgument2, ApcArgument3, 0)) {
                ExFreePool(Apc);
                Status = STATUS_UNSUCCESSFUL;
            }

        } else {
            Status = STATUS_NO_MEMORY;
        }

        ObDereferenceObject(Thread);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ps\psdelete.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    psdelete.c

Abstract:

    This module implements process and thread object termination and
    deletion.

--*/

#include "psp.h"

VOID
PspReaper(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine implements the thread reaper. The reaper is responsible
    for processing terminated threads. This includes:

        - deallocating their kernel stacks

        - releasing their process' CreateDelete lock

        - dereferencing their process

        - dereferencing themselves

Arguments:

    Dpc - Supplies a pointer to the DPC that has fired.

    Context - Unused.

    SystemArgument1 - Supplies a pointer to the thread object to reap.

    SystemArgument2 - Unused.

Return Value:

    None.

--*/

{

    PLIST_ENTRY NextEntry;
    PETHREAD Thread;

    //
    // Lock the dispatcher data and continually remove entries from the
    // reaper list until no more entries exist.
    //
    // N.B. The dispatcher database lock is used to synchronize access to
    //      the reaper list. This is done to avoid a race condition with
    //      the thread termination code.
    //

    KiLockDispatcherDatabaseAtDpcLevel();
    NextEntry = PsReaperListHead.Flink;
    while (NextEntry != &PsReaperListHead) {

        //
        // Remove the next thread from the reaper list, get the address of
        // the executive thread object, and then release the dispatcher
        // database lock.
        //

        RemoveEntryList(NextEntry);
        Thread = CONTAINING_RECORD(NextEntry, ETHREAD, ReaperListEntry);

        KiUnlockDispatcherDatabaseFromDpcLevel();

        //
        // Delete the kernel stack and dereference the thread.
        //

        MmDeleteKernelStack(Thread->Tcb.StackBase, Thread->Tcb.StackLimit);
        Thread->Tcb.StackBase = NULL;
        ObDereferenceObject(Thread);

        //
        // Lock the dispatcher database and get the address of the next
        // entry in the list.
        //

        KiLockDispatcherDatabaseAtDpcLevel();
        NextEntry = PsReaperListHead.Flink;
    }

    //
    // Unlock the dispatcher database.
    //

    KiUnlockDispatcherDatabaseFromDpcLevel();
    return;
}

VOID
PsTerminateSystemThread(
    IN NTSTATUS ExitStatus
    )

/*++

Routine Description:

    This function causes the current thread, which must be a system
    thread, to terminate.

Arguments:

    ExitStatus - Supplies the exit status associated with the thread.

Return Value:

    None.

--*/

{
    PETHREAD Thread;
    PKAPC Apc;
    PLIST_ENTRY FirstEntry;
    PLIST_ENTRY NextEntry;

    PAGED_CODE();

    Thread = PsGetCurrentThread();
    Thread->Tcb.HasTerminated = TRUE;

    KeLowerIrql(PASSIVE_LEVEL);

    //
    // Notify registered callout routines of thread deletion.
    //

    if (Thread->UniqueThread != NULL) {

        if (PspCreateThreadNotifyRoutineCount != 0) {
            ULONG i;

            for (i=0; i<PSP_MAX_CREATE_THREAD_NOTIFY; i++) {
                if (PspCreateThreadNotifyRoutine[i] != NULL) {
                    (*PspCreateThreadNotifyRoutine[i])(Thread,
                                                       Thread->UniqueThread,
                                                       FALSE);
                }
            }
        }
    }

    //
    // Finish terminating the thread at a realtime priority.
    //

    if (Thread->Tcb.Priority < LOW_REALTIME_PRIORITY) {
        KeSetPriorityThread (&Thread->Tcb, LOW_REALTIME_PRIORITY);
    }

    //
    // Rundown The Lists:
    //
    //      - Cancel Io By Thread
    //      - Cancel Timers
    //      - Cancel Registry Notify Requests pending against this thread
    //      - Perform kernel thread rundown
    //

    IoCancelThreadIo(Thread);
    ExTimerRundown();
    KeRundownThread();

    //
    // Set the exit status and exit time for the thread.
    //

    Thread->ExitStatus = ExitStatus;
    KeQuerySystemTime(&Thread->ExitTime);

    //
    // Delete the thread id handle.
    //

    if (Thread->UniqueThread != NULL) {
        NtClose(Thread->UniqueThread);
        Thread->UniqueThread = NULL;
    }

    //
    // Prevent additional APCs from being queued to this thread.
    //

    KeEnterCriticalRegion();
    KeDisableApcQueuingThread(&Thread->Tcb);

    //
    // Guard against another thread suspending us while we were in the process
    // of disabling APCs.
    //

    KeForceResumeThread (&Thread->Tcb);
    KeLeaveCriticalRegion();

    //
    // Flush user-mode APC queue.
    //

    FirstEntry = KeFlushQueueApc(&Thread->Tcb,UserMode);

    if ( FirstEntry ) {

        NextEntry = FirstEntry;
        do {
            Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
            NextEntry = NextEntry->Flink;

            //
            // If the APC has a rundown routine then call it. Otherwise
            // deallocate the APC
            //

            if ( Apc->RundownRoutine ) {
                (Apc->RundownRoutine)(Apc);
            } else {
                ExFreePool(Apc);
            }

        } while (NextEntry != FirstEntry);
    }

    //
    // At this point, we shouldn't have kernel APCs disabled at all.  If kernel
    // APCs are disabled, then some component forgot to exit a critical region.
    //

    ASSERT(Thread->Tcb.KernelApcDisable == 0);

    //
    // Flush kernel-mode APC queue.
    //
    // There should never be any kernel mode APCs found this far
    // into thread termination. Since we go to PASSIVE_LEVEL upon
    // entering exit.
    //

    FirstEntry = KeFlushQueueApc(&Thread->Tcb,KernelMode);

    if ( FirstEntry ) {
        KeBugCheckEx(
            KERNEL_APC_PENDING_DURING_EXIT,
            (ULONG_PTR)FirstEntry,
            (ULONG_PTR)Thread->Tcb.KernelApcDisable,
            (ULONG_PTR)KeGetCurrentIrql(),
            0
            );
    }

    //
    // Terminate the thread.
    //
    // N.B. There is no return from this call.
    //
    // N.B. The kernel inserts the current thread in the reaper list.
    //

    KeTerminateThread();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ps\psinit.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    psinit.c

Abstract:

    Process Structure Initialization.

--*/

#include "psp.h"

//
// Process Structure Global Data
//

DECLSPEC_RDATA OBJECT_TYPE PsThreadObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    NULL,
    NULL,
    (PVOID)FIELD_OFFSET(KTHREAD, Header),
    'erhT'
};

INITIALIZED_LIST_ENTRY(PsReaperListHead);
KDPC PsReaperDpc;

//
// List head and mutex that links all processes that have been initialized
//

BOOLEAN
PsInitSystem (
    VOID
    )
/*++

Routine Description:

    This function fermorms process structure initialization.
    It is called during phase 0 and phase 1 initialization. Its
    function is to dispatch to the appropriate phase initialization
    routine.

Arguments:

    None.

Return Value:

    TRUE - Initialization succeeded.

    FALSE - Initialization failed.

--*/
{
    HANDLE ThreadHandle;

    //
    // Initialize Reaper Data Structures
    //

    KeInitializeDpc(&PsReaperDpc, PspReaper, NULL);

    //
    // Phase 1 System initialization
    //

    if ( !NT_SUCCESS(PsCreateSystemThread(
                    &ThreadHandle,
                    NULL,
                    Phase1Initialization,
                    NULL,
                    FALSE
                    )) ) {
        return FALSE;
    }

    NtClose( ThreadHandle );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\obx\obtable.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    obtable.c

Abstract:

    This module implements routines to maintain a handle table.

--*/

#include "obp.h"

//
// Global object handle table.
//
OBJECT_HANDLE_TABLE ObpObjectHandleTable;

//
// Define macros to encode and decode the linked list of free handle in the
// object handle table.
//

#define ObpEncodeFreeHandleLink(Link) \
    (((ULONG_PTR)(Link)) | 1)

#define ObpDecodeFreeHandleLink(Link) \
    (((ULONG_PTR)(Link)) & (~1))

#define ObpIsFreeHandleLink(Link) \
    ((LOGICAL)(((ULONG_PTR)(Link)) & 1))

//
// Define a macro to mask off the reserved application bits from a handle.
//

#define ObpMaskOffApplicationBits(Handle) \
    ((HANDLE)(((ULONG_PTR)(Handle)) & ~(sizeof(ULONG) - 1)))

//
// Define macros to index the object handle table.
//

#define ObpGetTableByteOffsetFromHandle(Handle) \
    (HandleToUlong(Handle) & (OB_HANDLES_PER_TABLE * sizeof(PVOID) - 1))

#define ObpGetTableFromHandle(Handle) \
    ObpObjectHandleTable.RootTable[HandleToUlong(Handle) >> (OB_HANDLES_PER_TABLE_SHIFT + 2)]

#define ObpGetHandleContentsPointer(Handle) \
    ((PVOID*)((PUCHAR)ObpGetTableFromHandle(Handle) + ObpGetTableByteOffsetFromHandle(Handle)))

BOOLEAN
ObpExtendObjectHandleTable(
    VOID
    )
/*++

Routine Description:

    This routine extends the tables in the object handle table in order to hold
    more handles.

Arguments:

    None.

Return Value:

    Returns TRUE if the tables were successfully extended, else FALSE.

--*/
{
    PVOID *NewTable;
    SIZE_T OldRootTableSize;
    SIZE_T NewRootTableSize;
    PVOID **NewRootTable;
    HANDLE Handle;
    LONG_PTR FreeHandleLink;
    PVOID *HandleContents;
    ULONG Index;

    ObpAssertObjectManagerLock();

    //
    // Allocate a new table.
    //

    NewTable = (PVOID*)ExAllocatePoolWithTag(sizeof(PVOID) * OB_HANDLES_PER_TABLE,
        'tHbO');

    if (NewTable == NULL) {
        return FALSE;
    }

    //
    // Check if the root table needs to be extended.
    //

    if ((HandleToUlong(ObpObjectHandleTable.NextHandleNeedingPool) &
        (sizeof(PVOID) * OB_HANDLES_PER_SEGMENT - 1)) == 0) {

        if (ObpObjectHandleTable.NextHandleNeedingPool == NULL) {

            //
            // Simple case.  Use the builtin root table.
            //

            NewRootTable = ObpObjectHandleTable.BuiltinRootTable;

        } else {

            OldRootTableSize = HandleToUlong(ObpObjectHandleTable.NextHandleNeedingPool) /
                (sizeof(PVOID*) * OB_HANDLES_PER_TABLE);
            NewRootTableSize = OldRootTableSize + OB_TABLES_PER_SEGMENT;

            //
            // Allocate a new root table.
            //

            NewRootTable = (PVOID**)ExAllocatePoolWithTag(sizeof(PVOID*) *
                NewRootTableSize, 'rHbO');

            if (NewRootTable == NULL) {
                ExFreePool(NewTable);
                return FALSE;
            }

            //
            // Copy the old table to the new table.
            //

            RtlCopyMemory(NewRootTable, ObpObjectHandleTable.RootTable,
                sizeof(PVOID*) * OldRootTableSize);

            //
            // Free the old root table if necessary and switch to the new
            // root table.
            //

            if (ObpObjectHandleTable.RootTable !=
                ObpObjectHandleTable.BuiltinRootTable) {
                ExFreePool(ObpObjectHandleTable.RootTable);
            }
        }

        ObpObjectHandleTable.RootTable = NewRootTable;
    }

    //
    // Attach the new table to the root table.
    //

    ObpGetTableFromHandle(ObpObjectHandleTable.NextHandleNeedingPool) = NewTable;

    //
    // Compute the first handle that will be placed on the free list and it's
    // table position.
    //

    Handle = ObpObjectHandleTable.NextHandleNeedingPool;
    HandleContents = NewTable;
    ASSERT(HandleContents == ObpGetHandleContentsPointer(Handle));

    //
    // Chain the handles from the new table into a free list.
    //

    FreeHandleLink = ObpEncodeFreeHandleLink(Handle);
    ObpObjectHandleTable.FirstFreeTableEntry = FreeHandleLink;

    for (Index = 0; Index < OB_HANDLES_PER_TABLE - 1; Index++) {
        FreeHandleLink += sizeof(PVOID);
        *HandleContents++ = (PVOID)FreeHandleLink;
    }

    //
    // Terminate the free handle list with a negative one.
    //

    *HandleContents = (PVOID)-1;

    //
    // Special case the NULL handle by removing it from the list and setting
    // it's value to NULL.
    //

    if (Handle == NULL) {

        HandleContents = NewTable;
        ASSERT(HandleContents == ObpGetHandleContentsPointer(Handle));

        ObpObjectHandleTable.FirstFreeTableEntry = (LONG_PTR)*HandleContents;
        *HandleContents = NULL;
    }

    ASSERT(ObpIsFreeHandleLink(ObpObjectHandleTable.FirstFreeTableEntry));

    ObpObjectHandleTable.NextHandleNeedingPool = (HANDLE)(HandleToLong(Handle) +
        (sizeof(PVOID) * OB_HANDLES_PER_TABLE));

    return TRUE;
}

HANDLE
ObpCreateObjectHandle(
    PVOID Object
    )
/*++

Routine Description:

    This routine creates an object handle for the supplied object pointer.

Arguments:

    Object - Supplies the object pointer to insert into the handle table.

Return Value:

    Returns the allocated handle or NULL if no resources are available.

--*/
{
    HANDLE Handle;
    PVOID *HandleContents;

    ASSERT((Object != NULL) && !ObpIsFreeHandleLink(Object));

    ObpAssertObjectManagerLock();

    //
    // Check if the object handle table needs to be extended.
    //

    if (ObpObjectHandleTable.FirstFreeTableEntry == -1) {
        if (!ObpExtendObjectHandleTable()) {
            return NULL;
        }
    }

    //
    // Pop the first free handle from the list and initialize the handle to
    // contain the supplied object pointer.
    //

    ASSERT(ObpIsFreeHandleLink(ObpObjectHandleTable.FirstFreeTableEntry));

    Handle = (HANDLE)ObpDecodeFreeHandleLink(ObpObjectHandleTable.FirstFreeTableEntry);
    HandleContents = ObpGetHandleContentsPointer(Handle);

    ObpObjectHandleTable.FirstFreeTableEntry = (LONG_PTR)*HandleContents;

    ASSERT(ObpIsFreeHandleLink(ObpObjectHandleTable.FirstFreeTableEntry));

    ObpObjectHandleTable.HandleCount++;

    OBJECT_TO_OBJECT_HEADER(Object)->HandleCount++;

    *HandleContents = Object;

    return Handle;
}

PVOID
ObpGetObjectHandleReference(
    HANDLE Handle
    )
/*++

Routine Description:

    This routine returns a reference to the supplied handle's contents.

Arguments:

    Handle - Supplies the object handle to reference.

Return Value:

    Returns a referenced object pointer.  ObDereferenceObject should be used to
    release the reference.  Returns NULL if the supplied object handle is
    invalid.

--*/
{
    KIRQL OldIrql;
    PVOID *HandleContents;
    PVOID Object;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    Handle = ObpMaskOffApplicationBits(Handle);

    ObpAcquireObjectManagerLock(&OldIrql);

    //
    // Verify that the handle is not past the end of the allocate handle range.
    //

    if (HandleToUlong(Handle) < HandleToUlong(ObpObjectHandleTable.NextHandleNeedingPool)) {

        HandleContents = ObpGetHandleContentsPointer(Handle);
        Object = *HandleContents;

        //
        // Verify that the handle isn't a free handle link.
        //

        if (Object != NULL && !ObpIsFreeHandleLink(Object)) {

            OBJECT_TO_OBJECT_HEADER(Object)->PointerCount++;

            ObpReleaseObjectManagerLock(OldIrql);

            return Object;
        }
    }

    ObpReleaseObjectManagerLock(OldIrql);

    return NULL;
}

PVOID
ObpGetObjectHandleContents(
    HANDLE Handle
    )
/*++

Routine Description:

    This routine returns the supplied handle's contents.

Arguments:

    Handle - Supplies the object handle to reference.

Return Value:

    Returns a unreferenced object pointer.

--*/
{
    PVOID *HandleContents;
    PVOID Object;

    Handle = ObpMaskOffApplicationBits(Handle);

    ObpAssertObjectManagerLock();

    //
    // Verify that the handle is not past the end of the allocate handle range.
    //

    if (HandleToUlong(Handle) < HandleToUlong(ObpObjectHandleTable.NextHandleNeedingPool)) {

        HandleContents = ObpGetHandleContentsPointer(Handle);
        Object = *HandleContents;

        //
        // Verify that the handle isn't a free handle link.
        //

        if (Object != NULL && !ObpIsFreeHandleLink(Object)) {
            return Object;
        }
    }

    return NULL;
}

PVOID
ObpDestroyObjectHandle(
    HANDLE Handle
    )
/*++

Routine Description:

    This routine destroys an object handle allocated by ObCreateObjectHandle.

Arguments:

    Handle - Supplies the object handle to remove from the handle table.

Return Value:

    Returns the object pointer if the handle is valid, else NULL.

--*/
{
    PVOID *HandleContents;
    PVOID Object;

    Handle = ObpMaskOffApplicationBits(Handle);

    ObpAssertObjectManagerLock();

    //
    // Verify that the handle is not past the end of the allocate handle range.
    //

    if (HandleToUlong(Handle) < HandleToUlong(ObpObjectHandleTable.NextHandleNeedingPool)) {

        HandleContents = ObpGetHandleContentsPointer(Handle);
        Object = *HandleContents;

        //
        // Verify that the handle isn't a free handle link.
        //

        if (Object != NULL && !ObpIsFreeHandleLink(Object)) {

            //
            // Push this handle on the free list.
            //

            *HandleContents = (PVOID)ObpObjectHandleTable.FirstFreeTableEntry;

            ObpObjectHandleTable.FirstFreeTableEntry =
                ObpEncodeFreeHandleLink(Handle);

            ObpObjectHandleTable.HandleCount--;

            return Object;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ps\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    create.c

Abstract:

    Process and Thread Creation.

Author:

    Mark Lucovsky (markl) 20-Apr-1989

Revision History:

--*/

#include "psp.h"

ULONG
PspUnhandledExceptionInSystemThread(
    IN PEXCEPTION_POINTERS ExceptionPointers
    )
{
    KdPrint(("PS: Unhandled Kernel Mode Exception Pointers = 0x%p\n", ExceptionPointers));
    KdPrint(("Code %x Addr %p\nInfo0 %p Info1 %p Info2 %p Info3 %p\n",
        ExceptionPointers->ExceptionRecord->ExceptionCode,
        (ULONG_PTR)ExceptionPointers->ExceptionRecord->ExceptionAddress,
        ExceptionPointers->ExceptionRecord->ExceptionInformation[0],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[1],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[2],
        ExceptionPointers->ExceptionRecord->ExceptionInformation[3]
        ));

    //
    // Return EXCEPTION_CONTINUE_SEARCH and let the exception dispatcher notify
    // the debugger of the second chance exception or bugcheck the system.
    //

    return EXCEPTION_CONTINUE_SEARCH;
}

VOID
PspSystemThreadStartup(
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext
    )

/*++

Routine Description:

    This function is called by the kernel to start a system thread.

Arguments:

    StartRoutine - Supplies the address of the system threads entry point.

    StartContext - Supplies a context value for the system thread.

Return Value:

    None.

--*/

{
    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    try {
        (StartRoutine)(StartContext);
    } except (PspUnhandledExceptionInSystemThread(GetExceptionInformation())) {
    }

    PsTerminateSystemThread(STATUS_SUCCESS);
}

NTSTATUS
PsCreateSystemThread(
    OUT PHANDLE ThreadHandle,
    OUT PHANDLE ThreadId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext,
    IN BOOLEAN DebuggerThread
    )

/*++

Routine Description:

    This routine creates and starts a system thread.

Arguments:

    ThreadHandle - Returns the handle for the new thread.

    ThreadId - Returns the thread ID of for the new thread.

    StartRoutine - Supplies the address of the system thread start routine.

    StartContext - Supplies context for a system thread start routine.

    DebuggerThread - Supplies a value that controls whether or not this is a
        thread owned by the debugger.

Return Value:

    Status of operation.

--*/

{
    return PsCreateSystemThreadEx(ThreadHandle,
                                  0,
                                  KERNEL_STACK_SIZE,
                                  0,
                                  ThreadId,
                                  StartRoutine,
                                  StartContext,
                                  FALSE,
                                  DebuggerThread,
                                  PspSystemThreadStartup);
}

NTSTATUS
PsCreateSystemThreadEx(
    OUT PHANDLE ThreadHandle,
    IN SIZE_T ThreadExtensionSize,
    IN SIZE_T KernelStackSize,
    IN SIZE_T TlsDataSize,
    OUT PHANDLE ThreadId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext,
    IN BOOLEAN CreateSuspended,
    IN BOOLEAN DebuggerThread,
    IN PKSYSTEM_ROUTINE SystemRoutine OPTIONAL
    )

/*++

Routine Description:

    This routine creates and initializes a thread object. It implements the
    foundation for NtCreateThread and for PsCreateSystemThread.

Arguments:

    ThreadHandle - Returns the handle for the new thread.

    XapiThreadSize - Supplies the size of the XAPITHREAD to allocate as part of
        the thread's object body.

    ThreadExtensionSize - Supplies the number of bytes to allocate as part of
        the thread's object body.

    KernelStackSize - Supplies the size of the stack for the new thread.

    TlsDataSize - Supplies the number of bytes to reserve from the kernel stack
        for thread local storage.

    ThreadId - Returns the thread ID of for the new thread.

    StartRoutine - Supplies the address of the system thread start routine.

    StartContext - Supplies context for a system thread start routine.

    CreateSuspended - Supplies a value that controls whether or not a thread is
        created in a suspended state.

    DebuggerThread - Supplies a value that controls whether or not this is a
        thread owned by the debugger.

    SystemRoutine - Supplies the address of the routine that wraps the
        StartRoutine.

Return Value:

    Status of operation.

--*/

{
    NTSTATUS st;
    PETHREAD Thread;
    PVOID KernelStack;

    PAGED_CODE();

    Thread = NULL;

    //
    // Allocate thread object.
    //

    st = ObCreateObject(&PsThreadObjectType,
                        NULL,
                        sizeof(ETHREAD) + ThreadExtensionSize,
                        (PVOID *)&Thread);

    if (!NT_SUCCESS(st)) {
        return st;
    }

    //
    // Zero out the thread object.
    //

    RtlZeroMemory(Thread, sizeof(ETHREAD) + ThreadExtensionSize);

    //
    // Initialize Io.
    //

    InitializeListHead(&Thread->IrpList);

    //
    // Initialize Ex.
    //

    InitializeListHead(&Thread->ActiveTimerListHead);

    //
    // Allocate the stack.
    //

    KernelStackSize = ROUND_TO_PAGES(KernelStackSize);
    if (KernelStackSize < KERNEL_STACK_SIZE) {
        KernelStackSize = KERNEL_STACK_SIZE;
    }

    ASSERT(KernelStackSize > TlsDataSize);
    ASSERT((KernelStackSize - TlsDataSize) > KERNEL_USABLE_STACK_SIZE);

    KernelStack = MmCreateKernelStack(KernelStackSize, DebuggerThread);
    if (KernelStack == NULL) {
        ObDereferenceObject(Thread);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize kernel thread object for kernel mode thread.
    //

    Thread->StartAddress = (PVOID)(ULONG_PTR)StartRoutine;

    KeInitializeThread(&Thread->Tcb,
                       KernelStack,
                       KernelStackSize,
                       TlsDataSize,
                       SystemRoutine,
                       StartRoutine,
                       StartContext,
                       &KiSystemProcess);

    KeEnableApcQueuingThread(&Thread->Tcb);

    if (CreateSuspended) {
        KeSuspendThread(&Thread->Tcb);
    }

    //
    // Failures that occur after this point cause the thread to go through
    // PsTerminateSystemThread.
    //

    //
    // Increment the reference count on the thread so that we can safely use the
    // object until the end of this routine.  The thread that we start could
    // terminate before we end up returning to our caller.
    //

    ObReferenceObject(Thread);

    //
    // Increment the reference count on the thread on behalf of the running
    // thread.  The thread reaper will release this reference.
    //

    ObReferenceObject(Thread);

    //
    // Insert the thread object into the handle table and use that handle as the
    // thread identifier.
    //

    st = ObInsertObject(Thread, NULL, 0, &Thread->UniqueThread);

    if (NT_SUCCESS(st)) {

        //
        // Notify registered callout routines of thread creation.
        //

        if (PspCreateThreadNotifyRoutineCount != 0) {
            ULONG i;

            for (i=0; i<PSP_MAX_CREATE_THREAD_NOTIFY; i++) {
                if (PspCreateThreadNotifyRoutine[i] != NULL) {
                    (*PspCreateThreadNotifyRoutine[i])(Thread,
                                                       Thread->UniqueThread,
                                                       TRUE);
                }
            }
        }

        //
        // Create another handle to pass back to the client.
        //

        st = ObOpenObjectByPointer(Thread, &PsThreadObjectType, ThreadHandle);
    }

    if (!NT_SUCCESS(st)) {

        //
        // The insert failed or the handle creation failed.  Terminate the
        // thread.
        //

        Thread->Tcb.HasTerminated = TRUE;

        if (CreateSuspended) {
            KeResumeThread(&Thread->Tcb);
        }

    } else {

        //
        // Return the thread id to the client if requested.
        //

        if (ARGUMENT_PRESENT(ThreadId)) {
            *ThreadId = Thread->UniqueThread;
        }
    }

    //
    // Set the create time for the thread and insert the thread into the ready
    // queue.
    //

    KeQuerySystemTime(&Thread->CreateTime);
    KeReadyThread(&Thread->Tcb);

    //
    // Release the reference to the thread that we made above.
    //

    ObDereferenceObject(Thread);

    return st;
}

NTSTATUS
PsSetCreateThreadNotifyRoutine(
    IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    )

/*++

Routine Description:

    This function allows an installable file system to hook into thread
    creation and deletion to track those events against their own internal
    data structures.

Arguments:

    NotifyRoutine - Supplies the address of the routine which is called at
        thread creation and deletion. The routine is passed the unique Id
        of the created or deleted thread and the unique Id of the containing
        process. The third parameter passed to the notify routine is TRUE if
        the thread is being created and FALSE if it is being deleted.

Return Value:

    STATUS_SUCCESS if successful, and STATUS_INSUFFICIENT_RESOURCES if not.

--*/

{

    ULONG i;
    NTSTATUS Status;

    Status = STATUS_INSUFFICIENT_RESOURCES;
    for (i = 0; i < PSP_MAX_CREATE_THREAD_NOTIFY; i += 1) {
        if (PspCreateThreadNotifyRoutine[i] == NULL) {
            PspCreateThreadNotifyRoutine[i] = NotifyRoutine;
            PspCreateThreadNotifyRoutineCount += 1;
            Status = STATUS_SUCCESS;
            break;
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ps\psquery.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psquery.c

Abstract:

    This module implements the set and query functions for
    process and thread objects.

--*/

#include "psp.h"

extern OBJECT_HANDLE_TABLE ObpObjectHandleTable;

NTSTATUS
PsQueryStatistics(
    IN OUT PPS_STATISTICS ProcessStatistics
    )
/*++

Routine Description:

    This routine returns various statistics about the state of the process
    subsystem.

Arguments:

    ProcessStatistics - Supplies the buffer to fill with the process manager's
        statistics.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PKPROCESS Process;

    if (ProcessStatistics->Length == sizeof(PS_STATISTICS)) {

        Process = PsGetCurrentProcess();

        ProcessStatistics->ThreadCount = Process->StackCount;
        ProcessStatistics->HandleCount = ObpObjectHandleTable.HandleCount;

        status = STATUS_SUCCESS;

    } else {
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ps\psspnd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    psspnd.c

Abstract:

    This module implements NtSuspendThread and NtResumeThread

Author:

    Mark Lucovsky (markl) 25-May-1989

Revision History:

--*/

#include "psp.h"

NTSTATUS
NtSuspendThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    )

/*++

Routine Description:

    This function suspends the target thread, and optionally
    returns the previous suspend count.

Arguments:

    ThreadHandle - Supplies a handle to the thread object to suspend.

    PreviousSuspendCount - An optional parameter, that if specified
        points to a variable that receives the thread's previous suspend
        count.

Return Value:

    Status of operation.

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    ULONG LocalPreviousSuspendCount;

    PAGED_CODE();

    st = ObReferenceObjectByHandle(
            ThreadHandle,
            &PsThreadObjectType,
            (PVOID *)&Thread
            );

    if ( !NT_SUCCESS(st) ) {
        return st;
    }

    try {

        if ( Thread != PsGetCurrentThread() ) {
            if ( Thread->Tcb.HasTerminated ) {
                ObDereferenceObject(Thread);
                return STATUS_THREAD_IS_TERMINATING;
            }

            LocalPreviousSuspendCount = (ULONG) KeSuspendThread(&Thread->Tcb);

        } else {
            LocalPreviousSuspendCount = (ULONG) KeSuspendThread(&Thread->Tcb);
        }

        ObDereferenceObject(Thread);

        if (ARGUMENT_PRESENT(PreviousSuspendCount))
            *PreviousSuspendCount = LocalPreviousSuspendCount;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        st = GetExceptionCode();

        //
        // Either the suspend, or the store could cause an
        // exception. The store is a partial success, while the
        // suspend exception is an error
        //

        if ( st == STATUS_SUSPEND_COUNT_EXCEEDED ) {
            ObDereferenceObject(Thread);
        } else {
            st = STATUS_SUCCESS;
        }

        return st;
    }

    return STATUS_SUCCESS;

}

NTSTATUS
NtResumeThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    )

/*++

Routine Description:

    This function resumes the target thread, and optionally
    returns the previous suspend count.

Arguments:

    ThreadHandle - Supplies a handle to the thread object to resume.

    PreviousSuspendCount - An optional parameter, that if specified
        points to a variable that receives the thread's previous suspend
        count.

Return Value:

    Status of operation.

--*/

{
    PETHREAD Thread;
    NTSTATUS st;
    ULONG LocalPreviousSuspendCount;

    PAGED_CODE();

    st = ObReferenceObjectByHandle(
            ThreadHandle,
            &PsThreadObjectType,
            (PVOID *)&Thread
            );

    if ( !NT_SUCCESS(st) ) {
        return st;
    }

    LocalPreviousSuspendCount = (ULONG) KeResumeThread(&Thread->Tcb);

    ObDereferenceObject(Thread);

    if (ARGUMENT_PRESENT(PreviousSuspendCount)) {
        *PreviousSuspendCount = LocalPreviousSuspendCount;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rawx\cleanup.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    cleanup.c

Abstract:

    This module implements routines related to handling IRP_MJ_CLEANUP.

--*/

#include "rawx.h"

NTSTATUS
RawxFsdCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLEANUP requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PRAW_VOLUME_EXTENSION VolumeExtension;
    PFILE_OBJECT FileObject;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    RawxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Cleanup the sharing mode associated with the file object.
    //

    FileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;
    IoRemoveShareAccess(FileObject, &VolumeExtension->ShareAccess);

    RawxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\ps\psp.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    psp.h

Abstract:

    Private Interfaces for process structure.

--*/

#ifndef _PSP_
#define _PSP_

#include <ntos.h>
#include <ki.h>

#define PSP_MAX_CREATE_THREAD_NOTIFY 8

ULONG PspCreateThreadNotifyRoutineCount;
PCREATE_THREAD_NOTIFY_ROUTINE PspCreateThreadNotifyRoutine[ PSP_MAX_CREATE_THREAD_NOTIFY ];

VOID
PspReaper(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#endif // _PSP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rawx\create.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    create.c

Abstract:

    This module implements routines related to handling IRP_MJ_CREATE.

--*/

#include "rawx.h"

NTSTATUS
RawxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CREATE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PRAW_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ACCESS_MASK DesiredAccess;
    USHORT ShareAccess;
    ULONG CreateOptions;
    PFILE_OBJECT FileObject;
    ULONG CreateDisposition;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    DesiredAccess = IrpSp->Parameters.Create.DesiredAccess;
    ShareAccess = IrpSp->Parameters.Create.ShareAccess;
    CreateOptions = IrpSp->Parameters.Create.Options;
    FileObject = IrpSp->FileObject;

    RawxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Don't allow a relative path to be opened.
    //

    if (IrpSp->FileObject->RelatedFileObject != NULL) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    } else if (IrpSp->Parameters.Create.RemainingName->Length != 0) {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
        goto CleanupAndExit;
    }

    //
    // Verify that the create disposition is for open access only.
    //

    CreateDisposition = (CreateOptions >> 24) & 0xFF;

    if ((CreateDisposition != FILE_OPEN) && (CreateDisposition != FILE_OPEN_IF)) {
        status = STATUS_ACCESS_DENIED;
        goto CleanupAndExit;
    }

    //
    // The caller shouldn't be expecting to see a directory file.
    //

    if (RawxIsFlagSet(CreateOptions, FILE_DIRECTORY_FILE)) {
        status = STATUS_NOT_A_DIRECTORY;
        goto CleanupAndExit;
    }

    //
    // If this is the first open handle to the file, then initialize the sharing
    // mode.  Otherwise, verify that the requested sharing mode is compatible
    // with the current sharing mode.
    //

    if (VolumeExtension->ShareAccess.OpenCount == 0) {
        IoSetShareAccess(DesiredAccess, ShareAccess, FileObject,
            &VolumeExtension->ShareAccess);
        status = STATUS_SUCCESS;
    } else {
        status = IoCheckShareAccess(DesiredAccess, ShareAccess, FileObject,
            &VolumeExtension->ShareAccess, TRUE);
    }

    if (NT_SUCCESS(status)) {

        //
        // Physical volume access is always non-cached.  Mark the file object as
        // non-cached so that the I/O manager enforces alignment requirements.
        //

        FileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;

        //
        // Indicate to the caller that we opened the file as opposed to creating
        // or overwriting the file.
        //

        Irp->IoStatus.Information = FILE_OPENED;

        status = STATUS_SUCCESS;
    }

CleanupAndExit:
    RawxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rawx\driver.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module implements routines that apply to the driver object including
    initialization and IRP dispatch routines.

--*/

#include "rawx.h"

//
// Driver object for the RAW file system.
//
DECLSPEC_RDATA DRIVER_OBJECT RawxDriverObject = {
    NULL,                               // DriverStartIo
    NULL,                               // DriverDeleteDevice
    RawxDismountVolume,                 // DriverDismountVolume
    {
        RawxFsdCreate,                  // IRP_MJ_CREATE
        RawxFsdClose,                   // IRP_MJ_CLOSE
        RawxPassIrpDownToTargetDevice,  // IRP_MJ_READ
        RawxPassIrpDownToTargetDevice,  // IRP_MJ_WRITE
        RawxFsdQueryInformation,        // IRP_MJ_QUERY_INFORMATION
        RawxFsdSetInformation,          // IRP_MJ_SET_INFORMATION
        RawxPassIrpDownToTargetDevice,  // IRP_MJ_FLUSH_BUFFERS
        RawxFsdQueryVolumeInformation,  // IRP_MJ_QUERY_VOLUME_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_DIRECTORY_CONTROL
        RawxFsdFileSystemControl,       // IRP_MJ_FILE_SYSTEM_CONTROL
        RawxPassIrpDownToTargetDevice,  // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        RawxFsdCleanup,                 // IRP_MJ_CLEANUP
    }
};

NTSTATUS
RawxVolumeIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called to process the completion of a volume I/O transfer.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

    Context - Specifies the context that was supplied to IoSetCompletionRoutine.

Return Value:

    Status of operation.

--*/
{
    PRAW_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Propagate the pending flag up the IRP stack.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // Check if this is a read or write completion.  This completion routine is
    // shared by other IRP dispatch routines.
    //

    if ((IrpSp->MajorFunction == IRP_MJ_READ) ||
        (IrpSp->MajorFunction == IRP_MJ_WRITE)) {

        if (NT_SUCCESS(Irp->IoStatus.Status)) {

            //
            // If the file is open for synchronous I/O, then we need to update
            // the current file position.
            //

            FileObject = IrpSp->FileObject;

            if (RawxIsFlagSet(FileObject->Flags, FO_SYNCHRONOUS_IO)) {
                FileObject->CurrentByteOffset.QuadPart =
                    IrpSp->Parameters.Read.ByteOffset.QuadPart +
                    Irp->IoStatus.Information;
            }
        }
    }

    RawxDpcReleaseVolumeMutex(VolumeExtension);

    return STATUS_SUCCESS;
}

NTSTATUS
RawxPassIrpDownToTargetDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine passes the current request down to the target device.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PRAW_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    RawxAcquireVolumeMutexShared(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {

        RawxReleaseVolumeMutex(VolumeExtension);

        Irp->IoStatus.Status = STATUS_VOLUME_DISMOUNTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    // Initialize the next IRP stack location.
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // Set a completion routine to unlock the volume mutex and update any state
    // in the file control block.
    //

    IoSetCompletionRoutine(Irp, RawxVolumeIoCompletion, NULL, TRUE, TRUE, TRUE);

    //
    // Call down to the target device.
    //

    status = IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

    //
    // Leave the critical region that we acquired when we took the volume mutex.
    //

    KeLeaveCriticalRegion();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rawx\close.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module implements routines related to handling IRP_MJ_CLOSE.

--*/

#include "rawx.h"

NTSTATUS
RawxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLOSE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PRAW_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    RawxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if we're ready to delete this device object.
    //

    if ((VolumeExtension->ShareAccess.OpenCount == 0) &&
        VolumeExtension->Dismounted) {
        RawxReleaseVolumeMutex(VolumeExtension);
        RawxDeleteVolumeDevice(DeviceObject);
    } else {
        RawxReleaseVolumeMutex(VolumeExtension);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\recovery\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rawx\fileinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fileinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_INFORMATION and IRP_MJ_SET_INFORMATION.

--*/

#include "rawx.h"

NTSTATUS
RawxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_QUERY_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_POSITION_INFORMATION PositionInformation;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // The only thing that can be queried is the current file position.
    //

    if (IrpSp->Parameters.QueryFile.FileInformationClass != FilePositionInformation) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;

    //
    // Return the current file position in the user's buffer.
    //

    PositionInformation->CurrentByteOffset = IrpSp->FileObject->CurrentByteOffset;

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = sizeof(FILE_POSITION_INFORMATION);
    status = STATUS_SUCCESS;

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
RawxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_SET_INFORMATION
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PFILE_POSITION_INFORMATION PositionInformation;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // The only thing that can be set is the current file position.
    //

    if (IrpSp->Parameters.SetFile.FileInformationClass != FilePositionInformation) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    PositionInformation = (PFILE_POSITION_INFORMATION)Irp->UserBuffer;

    //
    // If the file was opened without intermediate buffering, then the byte
    // offset must be sector aligned.
    //
    // Note that we still do the check for FO_NO_INTERMEDIATE_BUFFERING even
    // though this is always set for RAWX file objects; this keeps the code
    // identical to GdfxFsdSetInformation and allows the functions to be
    // collpased by the linker.
    //

    if (RawxIsFlagSet(FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING) &&
        (PositionInformation->CurrentByteOffset.LowPart &
        (DeviceObject->SectorSize - 1)) != 0) {
        status = STATUS_INVALID_PARAMETER;
        goto CleanupAndExit;
    }

    //
    // Update the current file position.
    //

    FileObject->CurrentByteOffset = PositionInformation->CurrentByteOffset;
    status = STATUS_SUCCESS;

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rawx\mountvol.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    mountvol.c

Abstract:

    This module implements routines related to the mounting of a RAW volume.

--*/

#include "rawx.h"

VOID
RawxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    )
/*++

Routine Description:

    This routine deletes an instance of a volume device object.

Arguments:

    VolumeDeviceObject - Specifies the volume device object to delete.

Return Value:

    Status of operation.

--*/
{
    PRAW_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    //
    // There shouldn't be any open files for this volume.
    //

    ASSERT(VolumeExtension->ShareAccess.OpenCount == 0);

    //
    // Release the reference on the target device object.
    //

    if (VolumeExtension->TargetDeviceObject != NULL) {
        ObDereferenceObject(VolumeExtension->TargetDeviceObject);
    }

    //
    // Delete the device object.
    //

    IoDeleteDevice(VolumeDeviceObject);
}

NTSTATUS
RawxMountVolume(
    IN PDEVICE_OBJECT TargetDeviceObject
    )
/*++

Routine Description:

    This routine is called by the I/O manager to attempt to mount this file
    system.

Arguments:

    TargetDeviceObject - Specifies the device object to attempt to mount.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    ULONG IoControlCode;
    DISK_GEOMETRY DiskGeometry;
    PDEVICE_OBJECT VolumeDeviceObject;
    PRAW_VOLUME_EXTENSION VolumeExtension;

    VolumeDeviceObject = NULL;

    RawxAcquireGlobalMutexExclusive();

    //
    // Get the drive geometry from the device.  We don't care about the result,
    // but this gives the device an opportunity to reset any state, such as the
    // number of accessible bytes.
    //

    IoControlCode = (TargetDeviceObject->DeviceType == FILE_DEVICE_CD_ROM) ?
        IOCTL_CDROM_GET_DRIVE_GEOMETRY : IOCTL_DISK_GET_DRIVE_GEOMETRY;

    IoSynchronousDeviceIoControlRequest(IoControlCode, TargetDeviceObject, NULL,
        0, &DiskGeometry, sizeof(DISK_GEOMETRY), NULL, FALSE);

    //
    // Create the volume's device object.
    //

    status = IoCreateDevice(&RawxDriverObject, sizeof(RAW_VOLUME_EXTENSION),
        NULL, FILE_DEVICE_DISK_FILE_SYSTEM, FALSE, &VolumeDeviceObject);

    if (!NT_SUCCESS(status)) {
        goto CleanupAndExit;
    }

    //
    // Increase the volume's IRP stack size for requests that we pass down to
    // the target device object.
    //

    VolumeDeviceObject->StackSize = (UCHAR)(VolumeDeviceObject->StackSize +
        TargetDeviceObject->StackSize);

    //
    // Ensure that the alignment for this device matches the requirements of the
    // target device.
    //

    if (VolumeDeviceObject->AlignmentRequirement < TargetDeviceObject->AlignmentRequirement) {
        VolumeDeviceObject->AlignmentRequirement = TargetDeviceObject->AlignmentRequirement;
    }

    //
    // If the target device object supports direct I/O, then indicate that we
    // can as well.
    //

    if (RawxIsFlagSet(TargetDeviceObject->Flags, DO_DIRECT_IO)) {
        VolumeDeviceObject->Flags |= DO_DIRECT_IO;
    }

    //
    // If the target device object supports scatter gather I/O, then indicate
    // that we can as well.
    //

    if (RawxIsFlagSet(TargetDeviceObject->Flags, DO_SCATTER_GATHER_IO)) {
        VolumeDeviceObject->Flags |= DO_SCATTER_GATHER_IO;
    }

    //
    // Set the size of a sector for this device.
    //

    VolumeDeviceObject->SectorSize = TargetDeviceObject->SectorSize;

    //
    // Increment the reference count on the target device object since we'll be
    // holding a pointer to it.
    //

    ObReferenceObject(TargetDeviceObject);

    //
    // Initialize the volume's device extension data.
    //

    VolumeExtension = (PRAW_VOLUME_EXTENSION)VolumeDeviceObject->DeviceExtension;

    VolumeExtension->TargetDeviceObject = TargetDeviceObject;

    //
    // Initialize the volume's instance lock.
    //

    ExInitializeReadWriteLock(&VolumeExtension->VolumeMutex);

    //
    // The device has finished initializing and is ready to accept requests.
    //

    VolumeDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Connect the volume device object to the target device object and return
    // success.
    //

    TargetDeviceObject->MountedOrSelfDevice = VolumeDeviceObject;

    status = STATUS_SUCCESS;

CleanupAndExit:
    RawxReleaseGlobalMutex();

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rawx\synch.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    synch.c

Abstract:

    This module implements routines which provide synchronization to the file
    system.

--*/

#include "rawx.h"

//
// All file system access is guarded by this single global lock.
//
INITIALIZED_CRITICAL_SECTION(RawxGlobalMutex);

VOID
RawxAcquireGlobalMutexExclusive(
    VOID
    )
/*++

Routine Description:

    This routine acquires the file system's global lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KeEnterCriticalRegion();
    RtlEnterCriticalSection(&RawxGlobalMutex);
}

VOID
RawxReleaseGlobalMutex(
    VOID
    )
/*++

Routine Description:

    This routine releases the file system's global lock.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RtlLeaveCriticalSection(&RawxGlobalMutex);
    KeLeaveCriticalRegion();
}

VOID
RawxAcquireVolumeMutexExclusive(
    IN PRAW_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine acquires the volume's lock for exclusive access.

Arguments:

    VolumeExtension - Specifies the volume to lock.

Return Value:

    None.

--*/
{
    KeEnterCriticalRegion();
    ExAcquireReadWriteLockExclusive(&VolumeExtension->VolumeMutex);
}

VOID
RawxAcquireVolumeMutexShared(
    IN PRAW_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine acquires the volume's lock for shared access.

Arguments:

    VolumeExtension - Specifies the volume to lock.

Return Value:

    None.

--*/
{
    KeEnterCriticalRegion();
    ExAcquireReadWriteLockShared(&VolumeExtension->VolumeMutex);
}

VOID
RawxReleaseVolumeMutex(
    IN PRAW_VOLUME_EXTENSION VolumeExtension
    )
/*++

Routine Description:

    This routine releases the volume's lock.

Arguments:

    VolumeExtension - Specifies the volume to unlock.

Return Value:

    None.

--*/
{
    ExReleaseReadWriteLock(&VolumeExtension->VolumeMutex);
    KeLeaveCriticalRegion();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rawx\fsctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fsctrl.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_FILE_SYSTEM_CONTROL.

--*/

#include "rawx.h"

NTSTATUS
RawxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    FSCTL_DISMOUNT_VOLUME requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

Return Value:

    Status of operation.

--*/
{
    PRAW_VOLUME_EXTENSION VolumeExtension;
    KIRQL OldIrql;
    ULONG FileObjectCount;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    RawxAcquireVolumeMutexExclusive(VolumeExtension);

    //
    // Check if the volume is already marked for dismount.  If not, mark it for
    // dismount.
    //

    if (VolumeExtension->Dismounted) {
        RawxReleaseVolumeMutex(VolumeExtension);
        return STATUS_VOLUME_DISMOUNTED;
    }

    VolumeExtension->Dismounted = TRUE;

    //
    // Synchronize access to the MountedOrSelfDevice with the I/O manager by
    // raising to DISPATCH_LEVEL.
    //
    // Clear out the target device object's MountedOrSelfDevice field.  That
    // will cause future accesses to the target device object to mount a new
    // file system device object.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    VolumeExtension->TargetDeviceObject->MountedOrSelfDevice = NULL;

    KeLowerIrql(OldIrql);

    //
    // Release the reference on the target device object.
    //

    ObDereferenceObject(VolumeExtension->TargetDeviceObject);
    VolumeExtension->TargetDeviceObject = NULL;

    //
    // Take a snapshot of the file object count, release the volume mutex, and
    // delete the volume device if the file object count is zero.  This won't
    // normally happen since there's probably an open handle in order to make
    // this dismount call, but it could happen if an IRP was submitted directly
    // to the device object.
    //
    // We'll print out a debug message if the file object count is greater than
    // two.  XUnmountMU dismounts a volume with two file objects outstanding, so
    // anything beyond that represents some user file that hasn't been closed.
    //

    FileObjectCount = VolumeExtension->ShareAccess.OpenCount;

    RawxReleaseVolumeMutex(VolumeExtension);

    if (FileObjectCount == 0) {
        RawxDeleteVolumeDevice(DeviceObject);
    } else if (FileObjectCount > 2) {
        RawxDbgPrint(("RAWX: dismounting volume %p with %d open file handles\n",
            VolumeExtension, FileObjectCount));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RawxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_FILE_SYSTEM_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

        case FSCTL_DISMOUNT_VOLUME:
            //
            // Note that we call indirect through our driver object so that the
            // generated code ends up being identical between GDFX/RAWX/UDFX.
            //

            status = DeviceObject->DriverObject->DriverDismountVolume(DeviceObject);
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rawx\volinfo.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    volinfo.c

Abstract:

    This module implements routines related to handling
    IRP_MJ_QUERY_VOLUME_INFORMATION.

--*/

#include "rawx.h"

NTSTATUS
RawxQueryVolumeSizeInformation(
    IN PRAW_VOLUME_EXTENSION VolumeExtension,
    OUT PFILE_FS_SIZE_INFORMATION SizeInformation
    )
/*++

Routine Description:

    This routine fills the information structure with the volume size
    information for the supplied volume extension.

Arguments:

    VolumeExtension - Specifies the extension that the I/O request is for.

    SizeInformation - Specifies the buffer to receive the volume size
        information.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    DISK_GEOMETRY DiskGeometry;
    PARTITION_INFORMATION PartitionInformation;

    //
    // Get the drive geometry from the device.  Note that this doesn't work for
    // non-disk devices, but that's the way the old RAW file system worked as
    // well.  If geometry information is required for non-disk devices, then
    // use IOCTLs to talk to the target device.
    //

    status = IoSynchronousDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
        VolumeExtension->TargetDeviceObject, NULL, 0, &DiskGeometry,
        sizeof(DISK_GEOMETRY), NULL, FALSE);

    if (NT_SUCCESS(status)) {

        //
        // Get the partition information from the device.
        //

        status = IoSynchronousDeviceIoControlRequest(IOCTL_DISK_GET_PARTITION_INFO,
            VolumeExtension->TargetDeviceObject, NULL, 0,
            &PartitionInformation, sizeof(PARTITION_INFORMATION), NULL, FALSE);

        if (NT_SUCCESS(status)) {

            SizeInformation->TotalAllocationUnits.QuadPart =
                PartitionInformation.PartitionLength.QuadPart /
                DiskGeometry.BytesPerSector;
            SizeInformation->AvailableAllocationUnits =
                SizeInformation->TotalAllocationUnits;
            SizeInformation->BytesPerSector = DiskGeometry.BytesPerSector;
            SizeInformation->SectorsPerAllocationUnit = 1;
        }
    }

    return status;
}

NTSTATUS
RawxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle
    IRP_MJ_QUERY_VOLUME_INFORMATION requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PRAW_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    ULONG BytesWritten;
    PFILE_FS_DEVICE_INFORMATION DeviceInformation;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInformation;

    VolumeExtension = (PRAW_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    RawxAcquireVolumeMutexShared(VolumeExtension);

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Clear the output buffer.
    //

    RtlZeroMemory(Irp->UserBuffer, IrpSp->Parameters.QueryVolume.Length);

    //
    // Dispatch the information class function.
    //

    status = STATUS_SUCCESS;

    switch (IrpSp->Parameters.QueryVolume.FsInformationClass) {

        case FileFsVolumeInformation:
            NOTHING;
            BytesWritten = FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel);
            break;

        case FileFsSizeInformation:
            status = RawxQueryVolumeSizeInformation(VolumeExtension,
                (PFILE_FS_SIZE_INFORMATION)Irp->UserBuffer);
            BytesWritten = sizeof(FILE_FS_SIZE_INFORMATION);
            break;

        case FileFsDeviceInformation:
            DeviceInformation = (PFILE_FS_DEVICE_INFORMATION)Irp->UserBuffer;
            DeviceInformation->DeviceType =
                VolumeExtension->TargetDeviceObject->DeviceType;
            DeviceInformation->Characteristics = 0;
            BytesWritten = sizeof(FILE_FS_DEVICE_INFORMATION);
            break;

        case FileFsAttributeInformation:
            AttributeInformation =
                (PFILE_FS_ATTRIBUTE_INFORMATION)Irp->UserBuffer;
            AttributeInformation->FileSystemNameLength = sizeof(OCHAR) * 4;

            if (IrpSp->Parameters.QueryVolume.Length <
                FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
                sizeof(OCHAR) * 4) {
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName);
                status = STATUS_BUFFER_OVERFLOW;
            } else {
                RtlCopyMemory(AttributeInformation->FileSystemName, OTEXT("RAWX"),
                    sizeof(OCHAR) * 4);
                BytesWritten = FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION,
                    FileSystemName) + sizeof(OCHAR) * 4;
            }
            break;

        default:
            BytesWritten = 0;
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    //
    // Fill in the number of bytes that we wrote to the user's buffer.
    //

    Irp->IoStatus.Information = BytesWritten;

    //
    // Check that we didn't overflow the user's buffer.  The I/O manager does
    // the initial check to make sure there's enough space for the static
    // structure for a given information class, but we might overflow the buffer
    // when copying in the variable length file name.
    //

    ASSERT(Irp->IoStatus.Information <= IrpSp->Parameters.QueryVolume.Length);

CleanupAndExit:
    RawxReleaseVolumeMutex(VolumeExtension);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rawx\rawx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    rawx.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the RAW file system driver.

--*/

#ifndef _RAWX_
#define _RAWX_

#include <ntos.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>

#include <pshpack4.h>

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define RawxDbgPrint(x)                         DbgPrint x
#else
#define RawxDbgPrint(x)
#endif

//
// Bit flag macros.
//

#define RawxIsFlagSet(flagset, flag)            (((flagset) & (flag)) != 0)
#define RawxIsFlagClear(flagset, flag)          (((flagset) & (flag)) == 0)

//
// Volume device extension data.
//

typedef struct _RAW_VOLUME_EXTENSION {
    PDEVICE_OBJECT TargetDeviceObject;
    SHARE_ACCESS ShareAccess;
    BOOLEAN Dismounted;
    ERWLOCK VolumeMutex;
} RAW_VOLUME_EXTENSION, *PRAW_VOLUME_EXTENSION;

//
// File system dismount routine.
//

NTSTATUS
RawxDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

//
// IRP dispatch routines.
//

NTSTATUS
RawxFsdCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxFsdCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxFsdFileSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxFsdQueryInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxFsdQueryVolumeInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxFsdSetInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
RawxPassIrpDownToTargetDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Synchronization routines.
//

VOID
RawxAcquireGlobalMutexExclusive(
    VOID
    );

VOID
RawxReleaseGlobalMutex(
    VOID
    );

VOID
RawxAcquireVolumeMutexExclusive(
    IN PRAW_VOLUME_EXTENSION VolumeExtension
    );

VOID
RawxAcquireVolumeMutexShared(
    IN PRAW_VOLUME_EXTENSION VolumeExtension
    );

VOID
RawxReleaseVolumeMutex(
    IN PRAW_VOLUME_EXTENSION VolumeExtension
    );

#define RawxDpcReleaseVolumeMutex(volume) \
    ExReleaseReadWriteLock(&(volume)->VolumeMutex)

//
// Miscellaneous routines.
//

VOID
RawxDeleteVolumeDevice(
    IN PDEVICE_OBJECT VolumeDeviceObject
    );

//
// External symbols.
//

extern DRIVER_OBJECT RawxDriverObject;

#include <poppack.h>

#endif  // RAWX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\recovery\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL,
            D3DLOCK_NOSYSLOCK | D3DLOCK_RAWDATA) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    PVOID pBits = Swizzler_GetUnswizzledBits(&lockRect, &desc);
    if (pBits == NULL)
    {
        assert(FALSE);
        pSurface->UnlockRect();
        return;
    }

    PVOID pBitsOld = lockRect.pBits;
    lockRect.pBits = pBits;

    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    lockRect.pBits = pBitsOld;
    Swizzler_SwizzleFromBits(pBits, &lockRect, &desc);

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\recovery\bootmbr.h ===
#define X86BOOTCODE_SIZE 512


unsigned char x86BootCode[] = {
51,192,142,208,188,0,124,251,80,7,80,31,252,190,27,124,
191,27,6,80,87,185,229,1,243,164,203,189,190,7,177,4,
56,110,0,124,9,117,19,131,197,16,226,244,205,24,139,245,
131,198,16,73,116,25,56,44,116,246,160,181,7,180,7,139,
240,172,60,0,116,252,187,7,0,180,14,205,16,235,242,136,
78,16,232,70,0,115,42,254,70,16,128,126,4,11,116,11,
128,126,4,12,116,5,160,182,7,117,210,128,70,2,6,131,
70,8,6,131,86,10,0,232,33,0,115,5,160,182,7,235,
188,129,62,254,125,85,170,116,11,128,126,16,0,116,200,160,
183,7,235,169,139,252,30,87,139,245,203,191,5,0,138,86,
0,180,8,205,19,114,35,138,193,36,63,152,138,222,138,252,
67,247,227,139,209,134,214,177,6,210,238,66,247,226,57,86,
10,119,35,114,5,57,70,8,115,28,184,1,2,187,0,124,
139,78,2,139,86,0,205,19,115,81,79,116,78,50,228,138,
86,0,205,19,235,228,138,86,0,96,187,170,85,180,65,205,
19,114,54,129,251,85,170,117,48,246,193,1,116,43,97,96,
106,0,106,0,255,118,10,255,118,8,106,0,104,0,124,106,
1,106,16,180,66,139,244,205,19,97,97,115,14,79,116,11,
50,228,138,86,0,205,19,235,214,97,249,195,73,110,118,97,
108,105,100,32,112,97,114,116,105,116,105,111,110,32,116,97,
98,108,101,0,69,114,114,111,114,32,108,111,97,100,105,110,
103,32,111,112,101,114,97,116,105,110,103,32,115,121,115,116,
101,109,0,77,105,115,115,105,110,103,32,111,112,101,114,97,
116,105,110,103,32,115,121,115,116,101,109,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,44,68,99,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,170
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\recovery\imagefile.h ===
#ifndef __ImageFile_H
#define __ImageFile_H

#include "constants.h"

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;

class BitmapFile {
private:
	int ImageSize;
	DWORD *pixels;
	int xpos, ypos;

	// Bitmap File Header
	WORD Type;
	DWORD FileSize;
	WORD Reserved1;
	WORD Reserved2;
	DWORD OffBits;
	
	// Bitmap Info Header
	DWORD InfoSize;
	DWORD Width;
	DWORD Height;
	WORD Planes;
	WORD BitCount;
	DWORD Compression;
	DWORD SizeImage;
	DWORD XPelsPerMeter;
	DWORD YPelsPerMeter;
	DWORD ClrUsed;
	DWORD ClrImportant;

public:
	BitmapFile(void);
	~BitmapFile(void);
	
	void write(char *file, int imageWidth, int imageHeight, DWORD *pixels);
	int imagesize(char *file);
	void read(int xloc, int yloc, char *file);
	bool render(IDirect3DDevice8 *d3dDevice);

    DWORD GetWidth() { return Width; };         // Get the Width of the bitmap file
    DWORD GetHeight() { return Height; };       // Get the Height of the bitmap file
    int   GetXPos() { return xpos; };           // Get the X Position of the bitmap file
    int   GetYPos() { return ypos; };           // Get the Y Position of the bitmap file
    void  SetXPos( int x ) { xpos = x; };       // Set the X Position of the bitmap file
    void  SetYPos( int y ) { ypos = y; };       // Set the Y Position of the bitmap file
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\recovery\constants.h ===
#ifndef _CONSTANTS_H_
#define _CONSTANTS_H_

#include <xtl.h>
#include <av.h>

#define APP_TITLE_NAME_A                        "Recovery"

// Screen Dimensions
#define SCREEN_WIDTH                            640
#define SCREEN_HEIGHT                           480
#define SCREEN_X_CENTER                         ( SCREEN_WIDTH / 2 )
#define SCREEN_Y_CENTER                         ( SCREEN_HEIGHT / 2 )

// Progress Bar Dimensions
#define PROGRESS_WIDTH                           200.0f
#define PROGRESS_HEIGHT                           32.0f
#define PROGRESS_BORDER_OUTER_OFFSET             7.0f
#define PROGRESS_BORDER_GAP                      3.0f
#define PROGRESS_BORDER_WIDTH                    5
#define PROGRESS_X1                               (SCREEN_X_CENTER - (PROGRESS_WIDTH / 2))
#define PROGRESS_X2                               (SCREEN_X_CENTER + (PROGRESS_WIDTH / 2))
#define PROGRESS_Y1                               264.0f
#define PROGRESS_Y2                               (PROGRESS_Y1 + PROGRESS_HEIGHT)

// Launcher Menu Item Information
#define MENU_LAUNCH_MACHINENAME_X1              SCREEN_X_CENTER             // This is not used, it is calculated
#define MENU_LAUNCH_MACHINENAME_Y1              ( SCREEN_HEIGHT - 65.0f )
#define MENU_LAUNCH_NUMXBES_Y1                  MENUBOX_MAINAREA_Y1 - 28.0f
#define MENU_LAUNCH_MACHINENAME_FONTHEIGHT      28
#define MENU_LAUNCH_TOP_BORDER_SIZE             10.0f
#define MENU_LAUNCH_UPARROW_X1                  113     // Bitmaps, use int
#define MENU_LAUNCH_UPARROW_Y1                  106     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_X1                113     // Bitmaps, use int
#define MENU_LAUNCH_DOWNARROW_Y1                380     // Bitmaps, use int

// Menubox constants
#define MENUBOX_MAINAREA_X1                      99.0f
#define MENUBOX_MAINAREA_Y1                     134.0f
#define MENUBOX_MAINAREA_X2                     535.0f
#define MENUBOX_MAINAREA_Y2                     375.0f

#define MENUBOX_SELECTBAR_X1                    MENUBOX_MAINAREA_X1
#define MENUBOX_SELECTBAR_X2                    ( MENUBOX_MAINAREA_X2 + 1 )

#define MENUBOX_TEXT_TOP_BORDER                   16.0f
#define MENUBOX_TEXT_BOTTOM_BORDER                0.0f
#define MENUBOX_TEXT_LSIDE_BORDER                 8.0f
#define MENUBOX_TEXT_RSIDE_BORDER                 8.0f

#define MENUBOX_TEXTAREA_X1                     ( MENUBOX_MAINAREA_X1 + MENUBOX_TEXT_LSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y1                     ( MENUBOX_MAINAREA_Y1 + MENUBOX_TEXT_TOP_BORDER )
#define MENUBOX_TEXTAREA_X2                     ( MENUBOX_MAINAREA_X2 - MENUBOX_TEXT_RSIDE_BORDER )
#define MENUBOX_TEXTAREA_Y2                     ( MENUBOX_MAINAREA_Y2 - MENUBOX_TEXT_BOTTOM_BORDER )

#define MENUBOX_BUILDNUM_Y1                     ( MENUBOX_TEXTAREA_Y2 - 22.0f )

// Behaviour constants
#define KEY_PRESS_INITIAL_DELAY                 400         // milliseconds
#define KEY_PRESS_REPEAT_DELAY                  50
#define EXECUTABLE_DIRECTORY_POLL_INTERVAL      5000        // 5 seconds
#define CLEAR_SCREEN_PAUSE_MS                   250         // milliseconds

// Font info
#define FONT_DEFAULT_HEIGHT                     20
#define FONT_DEFAULT_WIDTH                      8
#define FONT_ALIAS_LEVEL                        0
#define FONT_DEFAULT_STYLE                      XFONT_NORMAL // XFONT_BOLD | XFONT_ITALICS | XFONT_BOLDITALICS
#define FILE_DATA_DEFAULT_FONT_FILENAME         FILE_DATA_MEDIA_DIRECTORY L"\\tahoma.ttf"

// Screen Item Constants
#define SCREEN_ITEM_TEXT_LENGTH                 40

// Colors
#define COLOR_WHITE                             0xFFFFFFFF
#define COLOR_BLACK                             0xFF000000
#define COLOR_LIGHT_YELLOW                      0xFFDFF77F
#define COLOR_YELLOW                            0xFFFFFF00
#define COLOR_LIGHT_GRAY                        0xFFC8C8C8
#define COLOR_DARK_GRAY                         0xFF828282
#define COLOR_LIME_GREEN                        0xFF9BD351
#define COLOR_BRIGHT_GREEN                      0xFF73C034
#define COLOR_MEDIUM_GREEN                      0xFF57932E
#define COLOR_DARK_GREEN2                       0xFF357515
#define COLOR_DARK_GREEN                        0xFF2C531E

#define SCREEN_DEFAULT_BACKGROUND_COLOR         COLOR_BLACK
#define SCREEN_DEFAULT_TEXT_FG_COLOR            COLOR_LIGHT_YELLOW
#define SCREEN_DEFAULT_TEXT_BG_COLOR            SCREEN_DEFAULT_BACKGROUND_COLOR

// Menu Item constants
#define ITEM_SELECTOR_BORDER_SPACE              2
#define ITEM_VERT_SPACING                       7.0f
#define ITEM_SELECTOR_COLOR                     COLOR_LIME_GREEN
#define ITEM_XBELIST_FONT_HEIGHT                17 // 18

// Keypad and Keyboard location information
#define KEYBOARD_TOPROW_Y1                      225
#define KEYPAD_TOPROW_Y1                        225
#define MENU_DISPSET_BUTTON_Y1                  211

// File path and location constants
#define FILE_DATA_DRIVE                        L"d:"
#define FILE_DATA_DRIVE_A                       "d:"
#define FILE_DATA_MEDIA_DIRECTORY               FILE_DATA_DRIVE  L"\\recmedia"
#define FILE_DATA_MEDIA_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"
#define FILE_DATA_IMAGE_DIRECTORY_A             FILE_DATA_DRIVE_A "\\recmedia"

#endif // _CONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\recovery\recovpch.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <stdio.h>
#include <xtl.h>
#include "ntos.h"
#include <scsi.h>
#include <stdio.h>
#include <xdbg.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))
#define CONSTANT_OBJECT_STRING(s)   { sizeof( s ) - sizeof( OCHAR ), sizeof( s ), s }

#ifdef HDSETUPAPP
#define RECOVERYAPP 1
#define RECOVERYNOFLASH 1
#endif // HDSETUPAPP

#ifdef RECOVERYAPP

#define XFONT_TRUETYPE
#include <xfont.h>

HRESULT
FlashKernelImage(
    IN  PVOID  ImageBuffer,
    IN  SIZE_T ImageSize,
    OUT LPSTR  szResp,
    IN  DWORD  cchResp
    );

#endif // RECOVERYAPP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\recovery\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    draw.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>

#include "d3d8.h"
#include "bitfont.h"

//------------------------------------------------------------------------------
// Draw
//
// Handy little D3D encapsulation for simple 2D drawing.

class Draw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    Draw(INT width = 640, INT height = 480);

    ~Draw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};

//------------------------------------------------------------------------------
// Draw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* Draw::m_pDevice;

//------------------------------------------------------------------------------
// Draw constructor

Draw::Draw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// Draw::~Draw

Draw::~Draw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// Draw::FillRect

VOID Draw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

//------------------------------------------------------------------------------
// Draw::DrawText

VOID Draw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

//------------------------------------------------------------------------------
// Draw::Present
//
// Make the current back-buffer visible

VOID Draw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}

//------------------------------------------------------------------------------
// Test

extern "C" VOID DrawMessage(LPCWSTR pcszText, int iProgPercent)
{
    Draw draw;

    draw.FillRect(0, 0, 640, 480, 0x000080);            // Draw border in dark blue
    draw.FillRect(20, 20, 600, 440, 0);                 // Fill interior with black
    draw.DrawText(pcszText, 100, 100, 0xbbbbff);
    
    if (-1 != iProgPercent)
    {
        //
        // Draw progress bar background
        //

        draw.FillRect(215, 220, 210, 40, 0x000080);
        
        //
        // Draw progress bar
        //

        draw.FillRect(220, 225, 2 * min(iProgPercent, 100), 30, 0xbbbbff);
    }
    draw.Present();                                     // Show the buffer
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\recovery\recovstr.h ===
#pragma once

#ifdef HDSETUPAPP

static const PWSTR RStrings[] =
{
    L"[I] Xbox HD Setup version %hs (0x%02x)",
    L"Xbox HD Setup Version %hs",
    L"Xbox HD Setup has failed", L"because of an unexpected error (0x%08x).",
    L"because this Xbox is no longer supported.",
    L"This CD must be in the drive at power up.",
    L"Press any gamepad button to begin HD Setup.", L"(Warning: Hard disk will be erased.)",
    L"Lock the HD?", L"(Y button: lock, Any other button: don't lock)",
    L"Please wait.  Updating the ROM...", L"(Do not reboot or power off!)",
    L"Preparing the hard disk...",
    L"Copying files to the hard disk...",
    L"Please eject and remove the HD Setup CD.",
    L"Please remove the HD Setup CD and",
    L"press any gamepad button to reboot.",
};

#else  // HDSETUPAPP

static const PWSTR RStrings[] =
{
#ifdef ONLINEBETA
    L"Xbox Betakit version %hs (0x%02x)",
    L"Xbox Betakit version %hs (0x%02x)",
#else
    L"[Internal] Xbox version %hs (0x%02x)",
    L"Xbox version %hs",
#endif
    L"Xbox recovery has failed", L"because of an unexpected error (0x%08x).",
    L"because this Xbox is no longer supported.",
    L"This CD must be in the drive at power up.",
    L"Press any gamepad button to begin recovery.", L"(Warning: Hard disk will be erased.)",
    L"ROM is current.  Update anyway?", L"(Y: update, any other button: don't update)",
    L"A newer version of the ROM is available", L"Please run full recovery (any button to continue)",
    L"Recover as a retail Xbox or a dev kit Xbox?", L"(Y button: retail, Any other button: dev kit)",
    L"Please wait.  Updating the ROM...", L"(Do not reboot or power off!)",
    L"Preparing the hard disk...",
    L"Copying files to the hard disk...",
    L"Please eject and remove the recovery CD.",
    L"Please remove the recovery CD and",
    L"press any gamepad button to reboot.",
};

#endif // HDSETUPAPP

enum RECOVSTR_INDEX
{
    RS_BUILD_NUMBER_FORMAT_INTERNAL = 0,
    RS_BUILD_NUMBER_FORMAT,
    RS_FAILURE_LINE1,
    RS_FAILURE_LINE2_FORMAT,
    RS_FAILURE_LINE2_OLD_BOX,
    RS_FAILURE_LINE2_WARM_BOOT,
    RS_GAMEPAD_BEGIN_LINE1,
    RS_GAMEPAD_BEGIN_LINE2,
#ifndef HDSETUPAPP
    RS_OVERWRITEROM_LINE1,
    RS_OVERWRITEROM_LINE2,
    RS_NEWERROM_LINE1,
    RS_NEWERROM_LINE2,
#endif
    RS_RETAIL_LINE1,
    RS_RETAIL_LINE2,
    RS_FLASH_LINE1,
    RS_FLASH_LINE2,
    RS_PREPARING,
    RS_COPYING,
    RS_GAMEPAD_END_RETAIL,
    RS_GAMEPAD_END_LINE1,
    RS_GAMEPAD_END_LINE2,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\recovery\recovery.cpp ===
#include "recovpch.h"
#include "recovstr.h"
#include "xboxverp.h"
#include "xconfig.h"
#include "xboxp.h"
#include "xdisk.h"
#include "smcdef.h"
#include <xonlinep.h>


#ifdef HDSETUPAPP
#define HD_KEY "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"

typedef struct
{
    UINT FirstSector;
    UINT LastSector;
} HD_SECTORRANGE, *PHD_SECTORRANGE;

//
// Sector ranges used by the greystone duplicator when hard drives are imaged.
// These should be zero initialized prior to preparing a hard drive image.
//

HD_SECTORRANGE HardDriveSectorRanges[] =
{
    { 0x00000000, 0x000003FF }, // (reserved sectors)
    { 0x00465400, 0x0055F3FF }, // (dash partition)
    { 0x0055F400, 0x00567D97 }, // (data partition + 16 megabytes of files)
    { 0, 0 }
};

#endif // HDSETUPAPP

#ifdef RECOVERYAPP
#include "xboxvideo.h"
#include "imagefile.h"
#include "xcrypt.h"
#endif // RECOVERYAPP

#ifdef DASHLIB
#define RECOVERYNOFLASH 1
#endif // DASHLIB

#ifndef RECOVERYNOFLASH

#define ROM_SIZE                    (1024 * 1024)
#define ROM_VERSION_OFFSET          30 // In DWORDs (0x78 is the absolute offset)
#define ROM_VERSION_BYTE_OFFSET     0x78
#define ROM_VERSION_KDDELAY_FLAG    0x80000000
#define ROM_FLASH_RETRIES           25

//
// Lowest possible base address of flash ROM and region size
//

#define FLASH_BASE_ADDRESS      0xFFF00000
#define FLASH_REGION_SIZE       (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)

#define FlashReadByte(a) \
    (*(PBYTE)((ULONG_PTR)RomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))
#define FlashReadUlong(a) \
    (*(PULONG)((ULONG_PTR)RomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

#endif // ! RECOVERYNOFLASH

#define ZERO_KEY "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"

#ifdef RECOVERYAPP

#define QUICK_FORMAT TRUE

#endif // RECOVERYAPP

#ifdef DASHLIB

#define QUICK_FORMAT FALSE

#endif // DASHLIB

extern "C"
{
UCHAR
FASTCALL
RtlFindFirstSetRightMember(
    IN ULONG Set
    );

BOOL
WINAPI
XapiFormatFATVolume(
    POBJECT_STRING pcVolume
    );

#ifdef RECOVERYAPP

ULONG g_InitTableVer = 0;
BOOL g_fInternalCD;

#ifdef RECOVERY_KERNEL_VER
USHORT RecoveryVersion = RECOVERY_KERNEL_VER;
#else
USHORT RecoveryVersion = VER_PRODUCTBUILD;
#endif

extern DWORD D3D__AvInfo;

#endif // RECOVERYAPP

#ifdef DASHLIB

typedef VOID (CALLBACK *PFNRECPROGRESSCALLBACK)(UINT uPercent, ULONG_PTR Context);

ULONG WINAPI DashRecovery(PFNRECPROGRESSCALLBACK pfnCallback, ULONG_PTR Context);

#endif // DASHLIB

}

#ifdef RECOVERYAPP

ULONG g_FilesCopied = 0;

#if defined(ONLINEBETA) || defined(HDSETUPAPP)
#define APPROX_FILE_COUNT   150
#else
#define APPROX_FILE_COUNT   350
#endif

const POSTR g_RootDirExceptions[] =
{
    OTEXT("default.xbe"),
#if !defined(RECOVERYNOFLASH) || defined(HDSETUPAPP)
    OTEXT("xboxrom.bin"),
#endif // !defined(RECOVERYNOFLASH) || defined(HDSETUPAPP)
    OTEXT("xboxrom_dvt4.bin"),
    OTEXT("xboxrom_qt.bin"),
#ifdef ONLINEBETA
	OTEXT("xboxrom_beta.bin"),
	OTEXT("xbdm.dll"),
	OTEXT("beta.dat"),
#endif
    OTEXT("RETAIL"),
    OTEXT("RECMEDIA"),
    OTEXT("XDASH")
};

const POSTR g_RetailDashExceptions[] =
{
    OTEXT("3dinfo"),
    OTEXT("data"),
    OTEXT("media"),
    OTEXT("menus"),
    OTEXT("sounds"),
    OTEXT("xboxdash.xbe"),
    OTEXT("xshell.xbe"),
    OTEXT("dvdkeyd.bin")
};

CXBoxVideo* g_pVideo;
BitmapFile* g_pBackgroundBitmap;

#endif // RECOVERYAPP

COBJECT_STRING DVDDevice =         CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Cdrom0") );
COBJECT_STRING PrimaryHarddisk =   CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition0") );
COBJECT_STRING HdPartition1 =      CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition1") );
COBJECT_STRING HdPartition2 =      CONSTANT_OBJECT_STRING( OTEXT("\\Device\\Harddisk0\\partition2") );
COBJECT_STRING CDrive =            CONSTANT_OBJECT_STRING( OTEXT("\\??\\C:") );
COBJECT_STRING YDrive =            CONSTANT_OBJECT_STRING( OTEXT("\\??\\Y:") );

#define DASHBOARD_PARTITION_NUMBER 2

static const CHAR HdPartitionX[] = "\\Device\\Harddisk0\\partition%d";

#if defined(RECOVERYAPP) && !defined(HDSETUPAPP)

//
// Functions for dealing with the encrypted section of the EEPROM
//

//
// The EEPROM encrypted section is unencrypted if the confounder field is all 0's
//
inline BOOL IsEEPROMEncryptedSectionUnencrypted(const XBOX_ENCRYPTED_SETTINGS* encryptedSection)
{
    const UCHAR* conf = encryptedSection->Confounder;
    for (INT i=0; i < 8; i++)
        if (conf[i] != 0) return FALSE;
    return TRUE;
}

//
// Decrypted the encrypted section of the EEPROM
//
static DWORD DecryptEEPROMEncryptedSection(XBOX_ENCRYPTED_SETTINGS* encryptedSection)
{
    if (IsEEPROMEncryptedSectionUnencrypted(encryptedSection))
        return ERROR_SUCCESS;

    #define RC4_CONFOUNDER_LEN FIELD_SIZE(XBOX_ENCRYPTED_SETTINGS, Confounder)

    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
    UCHAR LocalKey[XC_SERVICE_DIGEST_SIZE];
    UCHAR Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
    UCHAR* Data;
    ULONG DataSize;
    XBOX_ENCRYPTED_SETTINGS EncryptedSettings;
    UCHAR* EepromKey = (UCHAR*) *XboxEEPROMKey;

    EncryptedSettings = *encryptedSection;
    Data = EncryptedSettings.HDKey;
    DataSize = EEPROM_ENCRYPTED_SECTION_SIZE - FIELD_OFFSET(XBOX_ENCRYPTED_SETTINGS, HDKey);
    memcpy(Confounder, EncryptedSettings.Confounder, RC4_CONFOUNDER_LEN);

    //
    // HMAC the checksum into the key
    //
    XcHMAC(
        EepromKey,
        XBOX_KEY_LENGTH,
        EncryptedSettings.Checksum,
        XC_SERVICE_DIGEST_SIZE,
        NULL,
        0,
        LocalKey);

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key(Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey);

    //
    // Decrypt confounder and data
    //
    XcRC4Crypt(Rc4KeyStruct, RC4_CONFOUNDER_LEN, Confounder);
    XcRC4Crypt(Rc4KeyStruct, DataSize, Data);

    //
    // Now verify the checksum.
    //
    XcHMAC(
        EepromKey,
        XBOX_KEY_LENGTH,
        Confounder,
        RC4_CONFOUNDER_LEN,
        Data,
        DataSize,
        Checksum);

    //
    // Decrypt is successful only if checksum matches
    //
    if (memcmp(Checksum, EncryptedSettings.Checksum, XC_SERVICE_DIGEST_SIZE) != 0)
        return ERROR_INVALID_PASSWORD;

    memset(encryptedSection, 0, sizeof(*encryptedSection));
    memcpy(encryptedSection->HDKey, EncryptedSettings.HDKey, XBOX_KEY_LENGTH);
    encryptedSection->GameRegion = EncryptedSettings.GameRegion;
    return ERROR_SUCCESS;
}

#ifdef ONLINEBETA

static UCHAR NewEEPROMKey[16];

typedef struct _XC_ENCFILE_HEADER {
	DWORD Sig;
	UCHAR MAC[XC_SERVICE_DIGEST_SIZE];
	UCHAR Confounder[RC4_CONFOUNDER_LEN];
	DWORD MsgLen;
	UCHAR unused[XC_SERVICE_DIGEST_SIZE];
} XC_ENCFILE_HEADER, *PXC_ENCFILE_HEADER;

static BOOL FLoadNewEEPROMKey(LPSTR szFilename, LPSTR szPasswd)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytes;
    BOOL fRet = FALSE;
    DWORD dwEncSize;
    PBYTE pEncBuffer = FALSE;
    PXC_ENCFILE_HEADER pEncHead;
    UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
    UCHAR Confounder[RC4_CONFOUNDER_LEN];
    UCHAR LocalKey[XC_SERVICE_DIGEST_SIZE];
    UCHAR Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
	UCHAR rgbEncryptedKey[sizeof(XC_ENCFILE_HEADER) + 76];
	int cbPasswd;

    hFile = CreateFile(szFilename, GENERIC_READ, FILE_SHARE_READ, NULL,
		OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        goto CleanupAndExit;

    dwEncSize = GetFileSize(hFile, NULL);
    if (dwEncSize != sizeof rgbEncryptedKey)
        goto CleanupAndExit;
    
    pEncHead = (PXC_ENCFILE_HEADER)rgbEncryptedKey;

    if (!ReadFile(hFile, rgbEncryptedKey, dwEncSize, &dwBytes, NULL))
        goto CleanupAndExit;

    if (pEncHead->Sig != 'k2ne' || pEncHead->MsgLen != (dwEncSize -
		sizeof(XC_ENCFILE_HEADER))) {
        goto CleanupAndExit;
    }

    //
    // Decrypt it
    //

	cbPasswd = strlen(szPasswd);
	XcHMAC((PUCHAR)szPasswd, cbPasswd, pEncHead->MAC, XC_SERVICE_DIGEST_SIZE,
		NULL, 0, LocalKey);
    XcRC4Key(Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey);
    XcRC4Crypt(Rc4KeyStruct, RC4_CONFOUNDER_LEN, pEncHead->Confounder);
    XcRC4Crypt(Rc4KeyStruct, pEncHead->MsgLen, (PUCHAR)(pEncHead + 1));
    XcHMAC((PUCHAR)szPasswd, cbPasswd, pEncHead->Confounder, RC4_CONFOUNDER_LEN,
		(PUCHAR)(pEncHead + 1),  pEncHead->MsgLen, Checksum);
    if (memcmp(Checksum, pEncHead->MAC, XC_SERVICE_DIGEST_SIZE) != 0)
        goto CleanupAndExit;

	//
	// At this point, assume the key is bytes 52-67 past the encrypted key
	// header -- this matches the xcrypt symmetric key format
	//

	memcpy(NewEEPROMKey, &rgbEncryptedKey[sizeof(XC_ENCFILE_HEADER) + 52],
		16);
	fRet = TRUE;

CleanupAndExit:
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }

    return fRet;
}

#endif // ONLINEBETA

//
// Encrypt the encrypted section of the EEPROM
//
static DWORD EncryptEEPROMEncryptedSection(XBOX_ENCRYPTED_SETTINGS* encryptedSection)
{
    if (!IsEEPROMEncryptedSectionUnencrypted(encryptedSection))
        return ERROR_SUCCESS;

    UCHAR Confounder[RC4_CONFOUNDER_LEN] = { 0x4c,0x70,0x33,0xcb,0x5b,0xb5,0x97,0xd2 };
    UCHAR LocalKey[XC_SERVICE_DIGEST_SIZE];
    UCHAR Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
    UCHAR* Data;
    ULONG DataSize;
#ifdef ONLINEBETA
    UCHAR* EepromKey = NewEEPROMKey;
#else
    UCHAR* EepromKey = (UCHAR*) *XboxEEPROMKey;
#endif

    Data = encryptedSection->HDKey;
    DataSize = EEPROM_ENCRYPTED_SECTION_SIZE - FIELD_OFFSET(XBOX_ENCRYPTED_SETTINGS, HDKey);

    //
    // Create the header - the confounder & checksum
    //
    memset(encryptedSection->Checksum, 0, sizeof(encryptedSection->Checksum));
    memcpy(encryptedSection->Confounder, Confounder, sizeof(encryptedSection->Confounder));

    //
    // Checksum everything but the checksum
    //
    XcHMAC(EepromKey,
           XBOX_KEY_LENGTH,
           encryptedSection->Confounder,
           RC4_CONFOUNDER_LEN,
           Data,
           DataSize,
           encryptedSection->Checksum);

    //
    // HMAC the checksum into the key
    //
    XcHMAC(EepromKey,
           XBOX_KEY_LENGTH,
           encryptedSection->Checksum,
           XC_SERVICE_DIGEST_SIZE,
           NULL,
           0,
           LocalKey);

    //
    // Use the generated key as the RC4 encryption key
    //
    XcRC4Key(Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey);

    //
    // Encrypt everything but the checksum
    //
    XcRC4Crypt(Rc4KeyStruct, RC4_CONFOUNDER_LEN, encryptedSection->Confounder);
    XcRC4Crypt(Rc4KeyStruct, DataSize, Data);

    return ERROR_SUCCESS;
}

//
// Make sure the encrypted section of the EEPROM is encrypted and that there is
// a region set
//
static DWORD PrepareEEPROM()
{
    EEPROM_LAYOUT eepromData;
    ULONG type, length;
    DWORD err;
    XBOX_ENCRYPTED_SETTINGS* encryptedSection =
        (XBOX_ENCRYPTED_SETTINGS*) eepromData.EncryptedSection;
	XBOX_USER_SETTINGS* userSettings =
		(XBOX_USER_SETTINGS*) eepromData.UserConfigSection;

    //
    // Read the existing content of the encrypted section
    //
    err = XQueryValue(XC_MAX_ALL, &type, &eepromData, sizeof(eepromData), &length);

    if (ERROR_SUCCESS != err)
    {
        return err;
    }

    if (!IsEEPROMEncryptedSectionUnencrypted(encryptedSection))
    {
        if (ERROR_SUCCESS != DecryptEEPROMEncryptedSection(encryptedSection))
        {
            memset(encryptedSection, 0, sizeof(*encryptedSection));
        }
    }

    if (0 == (encryptedSection->GameRegion & ~XC_GAME_REGION_MANUFACTURING))
    {
        encryptedSection->GameRegion = XC_GAME_REGION_NA;
    }
    else
    {
        encryptedSection->GameRegion &= ~XC_GAME_REGION_MANUFACTURING;
    }

    //
    // Always encrypt the EEPROM header (all post-July releases support this)
    //
    err = EncryptEEPROMEncryptedSection(encryptedSection);

    if (ERROR_SUCCESS != err)
    {
        return err;
    }

#ifdef ONLINEBETA
	// We need to zero out the user EEPROM settings as well
    RtlZeroMemory(userSettings, sizeof(*userSettings));
    userSettings->Checksum = ~XConfigChecksum(userSettings, sizeof(*userSettings));
#endif // ONLINEBETA

    return XSetValue(XC_MAX_ALL, REG_BINARY, &eepromData, sizeof(eepromData));
}


#endif // defined(RECOVERYAPP) && !defined(HDSETUPAPP)


#ifdef RECOVERYAPP

VOID
DrawMessage(LPCWSTR pcszTextLine1, LPCWSTR pcszTextLine2, int iProgPercent)
{
    ASSERT(g_pVideo && g_pBackgroundBitmap && pcszTextLine1);

    g_pVideo->ClearScreen(COLOR_BLACK);
    g_pBackgroundBitmap->render(g_pVideo->GetD3DDevicePtr());

    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_TEXTAREA_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       pcszTextLine1);

    if (NULL != pcszTextLine2)
    {
        g_pVideo->DrawText(SCREEN_X_CENTER,
                           MENUBOX_TEXTAREA_Y1 + FONT_DEFAULT_HEIGHT + ITEM_VERT_SPACING,
                           SCREEN_DEFAULT_TEXT_FG_COLOR,
                           SCREEN_DEFAULT_TEXT_BG_COLOR,
                           pcszTextLine2);
    }

    if (-1 != iProgPercent)
    {
        //
        // Draw progress bar background
        //

        g_pVideo->DrawBox(PROGRESS_X1 - PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_Y1 - PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_X2 + PROGRESS_BORDER_OUTER_OFFSET,
                          PROGRESS_Y2 + PROGRESS_BORDER_OUTER_OFFSET,
                          COLOR_BRIGHT_GREEN);

        //
        // Draw progress bar bkgnd
        //

        g_pVideo->DrawBox(PROGRESS_X1 - PROGRESS_BORDER_GAP,
                          PROGRESS_Y1 - PROGRESS_BORDER_GAP,
                          PROGRESS_X2 + PROGRESS_BORDER_GAP,
                          PROGRESS_Y2 + PROGRESS_BORDER_GAP,
                          COLOR_BLACK);

        //
        // Draw progress bar
        //

        g_pVideo->DrawBox(PROGRESS_X1,
                          PROGRESS_Y1,
                          PROGRESS_X1 + ((PROGRESS_WIDTH / 100) * min(iProgPercent, 100)),
                          PROGRESS_Y2,
                          SCREEN_DEFAULT_TEXT_FG_COLOR);
    }

    WCHAR szBuildString[64];

#ifdef ONLINEBETA
    wsprintfW(szBuildString,
              RStrings[RS_BUILD_NUMBER_FORMAT_INTERNAL],
              VER_PRODUCTVERSION_STR,
              g_InitTableVer & 0xFF);
#else
    if (g_fInternalCD)
    {
        wsprintfW(szBuildString,
                  RStrings[RS_BUILD_NUMBER_FORMAT_INTERNAL],
                  VER_PRODUCTVERSION_STR,
                  g_InitTableVer & 0xFF);
    }
    else
    {
        wsprintfW(szBuildString,
                  RStrings[RS_BUILD_NUMBER_FORMAT],
                  VER_PRODUCTVERSION_STR);
    }
#endif

    g_pVideo->DrawText(SCREEN_X_CENTER,
                       MENUBOX_BUILDNUM_Y1,
                       SCREEN_DEFAULT_TEXT_FG_COLOR,
                       SCREEN_DEFAULT_TEXT_BG_COLOR,
                       szBuildString);

    g_pVideo->ShowScreen();
}


VOID
EjectDVD()
{
    //
    // This requires matching SMC firmware and DVD firmware (DVT3 and onward)..
    //

    HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_DVD_TRAY_OPERATION,
        SMC_DVD_TRAY_OPERATION_OPEN);
}


DWORD ReadSMC(unsigned char addr)
{
    DWORD value = 0xCCCCCCCC;
    DWORD status = HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
}


VOID GetSMCVersion(PSTR pszSMCVersion, UINT cchSMCVersion)
{
    ASSERT(cchSMCVersion > 3);

    HalWriteSMBusValue(0x21, 0x01, FALSE, 0);

    pszSMCVersion[0] = (char)ReadSMC(0x01);
    pszSMCVersion[1] = (char)ReadSMC(0x01);
    pszSMCVersion[2] = (char)ReadSMC(0x01);
    pszSMCVersion[3] = '\0';
}

//
// Copies files from a source path to a destination path.  The source path
// is a filter that can be passed to FindFirstFile() and is currently required
// to end in "\\*".  The destination path should end with a trailing backslash ('\')
//

BOOL
CopyFiles(
    IN PCOSTR pcszSrcPath,
    IN PCOSTR pcszDestPath,
    IN BOOL fRootDir,
    IN const POSTR * ppszExceptionList,
    IN UINT cExceptionListItems
    )
{
    WIN32_FIND_DATA wfd;
    BOOL bRet = FALSE;
    int nSrcLen = ocslen(pcszSrcPath);
    int nDestLen = ocslen(pcszDestPath);
    HANDLE hFind = FindFirstFile(pcszSrcPath, &wfd);

    if (NULL == ppszExceptionList)
    {
        ppszExceptionList = g_RootDirExceptions;
        cExceptionListItems = ARRAYSIZE(g_RootDirExceptions);
    }

    if (INVALID_HANDLE_VALUE != hFind)
    {
        OCHAR szSrcFile[MAX_PATH], szDestFile[MAX_PATH];
        ocscpy(szSrcFile, pcszSrcPath);
        ocscpy(szDestFile, pcszDestPath);
        ASSERT((szSrcFile[nSrcLen - 1] == OTEXT('*')) &&
               (szSrcFile[nSrcLen - 2] == OTEXT('\\')));
        do
        {
            BOOL fCopyThis = TRUE;

            if (fRootDir)
            {
                int i;
                for (i = 0; i < (int) cExceptionListItems; i++)
                {
                    if (0 == _ocsicmp(wfd.cFileName, ppszExceptionList[i]))
                    {
                        fCopyThis = FALSE;
                        break;
                    }
                }
            }

            if (!fCopyThis)
            {
                continue;
            }

            lstrcpynO(&(szSrcFile[nSrcLen - 1]),
                      wfd.cFileName,
                      ARRAYSIZE(szSrcFile) - (nSrcLen - 1));
            lstrcpynO(&(szDestFile[nDestLen]),
                      wfd.cFileName,
                      ARRAYSIZE(szDestFile) - nDestLen);

            if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                int nFileLen = ocslen(wfd.cFileName);

                bRet = CreateDirectory(szDestFile, NULL);

                if (!bRet)
                {
                    break;
                }

                lstrcpynO(&(szSrcFile[nSrcLen + nFileLen - 1]),
                          OTEXT("\\*"),
                          ARRAYSIZE(szSrcFile) - (nSrcLen + nFileLen - 1));

                lstrcpynO(&(szDestFile[nDestLen + nFileLen]),
                          OTEXT("\\"),
                          ARRAYSIZE(szDestFile) - (nDestLen + nFileLen));

                bRet = CopyFiles(szSrcFile, szDestFile, FALSE, NULL, 0);

                if (!bRet)
                {
                    break;
                }
            }
            else
            {
                bRet = CopyFile(szSrcFile, szDestFile, FALSE);

                //
                // Files coming off of CD/DVD end up read-only, so clear
                // all of the attributes.. (otherwise dosnet won't work)
                //

                SetFileAttributes(szDestFile, FILE_ATTRIBUTE_NORMAL);

                if (!bRet)
                {
                    break;
                }

                DrawMessage(RStrings[RS_COPYING],
                            NULL,
                            5 + min((++g_FilesCopied * 90) / APPROX_FILE_COUNT, 90));
            }

        } while (FindNextFile(hFind, &wfd));

        FindClose(hFind);
    }
    else if (ERROR_FILE_NOT_FOUND == GetLastError())
    {
        bRet = TRUE;
    }

    return bRet;
}




#ifdef SECTORCOPY

#define RECASSERT(cond) do { \
            if (!(cond)) { \
                DbgPrint("ASSERT on line %d: %s\n", __LINE__, #cond); \
                DrawMessage(L"ASSERT", L ## #cond, 0); \
                DebugBreak(); \
            } \
        } while (0)

#define SECTORSIZE 512
#define MAXBUFSIZE (64*1024)
ULONG SectorRanges[] = {
    0x00000000, 0x000003FF,
    0x00465400, 0x0055F3FF,
    0x0055F400, 0x00567D97,
};

VOID ReadDiskSnapshot()
{
    OBJECT_STRING objname;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    HANDLE disk;

    RtlInitObjectString(&objname, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(
                &disk,
                GENERIC_ALL|SYNCHRONIZE,
                &oa,
                &iosb,
                0,
                FILE_SYNCHRONOUS_IO_ALERT);

    RECASSERT(NT_SUCCESS(status));

    VOID* buf = VirtualAlloc(NULL, MAXBUFSIZE, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
    RECASSERT(buf != NULL);

    HANDLE file = CreateFile(
                    "z:\\snapshot.dat",
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL);

    RECASSERT(file != INVALID_HANDLE_VALUE);

    // Write out the first sector
    memset(buf, 0, MAXBUFSIZE);
    memcpy(buf, SectorRanges, sizeof(SectorRanges));

    DWORD cb;
    BOOL writeok = WriteFile(file, buf, SECTORSIZE, &cb, NULL);
    RECASSERT(writeok);

    ULONG* p = SectorRanges;
    ULONG range_count = sizeof(SectorRanges) / (sizeof(ULONG)*2);
    ULONG total = 0;

    while (range_count--) {
        ULONG sector = p[0];
        ULONG sector_count = p[1] - p[0] + 1;
        p += 2;
        DbgPrint("Copying %d sectors starting from %x\n", sector_count, sector);

        total += sector_count;
        while (sector_count) {
            ULONG n = min(sector_count, MAXBUFSIZE/SECTORSIZE);
            LARGE_INTEGER offset;

            offset.QuadPart = sector;
            offset.QuadPart *= SECTORSIZE;
            status = NtReadFile(disk, 0, NULL, NULL, &iosb, buf, n*SECTORSIZE, &offset);
            RECASSERT(NT_SUCCESS(status));

            writeok = WriteFile(file, buf, n*SECTORSIZE, &cb, NULL);
            RECASSERT(writeok);

            sector += n;
            sector_count -= n;
        }
    }

    VirtualFree(buf, 0, MEM_RELEASE);
    CloseHandle(file);
    NtClose(disk);

    DbgPrint("Total of %d sectors copied\n", total);
}

VOID WriteDiskSnapshot()
{
    OBJECT_STRING objname;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    HANDLE disk;

    RtlInitObjectString(&objname, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(
                &disk,
                GENERIC_ALL|SYNCHRONIZE,
                &oa,
                &iosb,
                0,
                FILE_SYNCHRONOUS_IO_ALERT);

    RECASSERT(NT_SUCCESS(status));

    VOID* buf = VirtualAlloc(NULL, MAXBUFSIZE, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
    RECASSERT(buf != NULL);

    HANDLE file = CreateFile(
                    "D:\\snapshot.dat",
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL);

    RECASSERT(file != INVALID_HANDLE_VALUE);

    DWORD cb;
    BOOL readok = ReadFile(file, buf, SECTORSIZE, &cb, NULL);
    RECASSERT(readok);
    RECASSERT(memcmp(buf, SectorRanges, sizeof(SectorRanges)) == 0);

    ULONG* p = SectorRanges;
    ULONG range_count = sizeof(SectorRanges) / (sizeof(ULONG)*2);
    ULONG total = 0;

    while (range_count--) {
        ULONG sector = p[0];
        ULONG sector_count = p[1] - p[0] + 1;
        p += 2;
        DbgPrint("Copying %d sectors starting from %x\n", sector_count, sector);

        total += sector_count;
        while (sector_count) {
            ULONG n = min(sector_count, MAXBUFSIZE/SECTORSIZE);
            LARGE_INTEGER offset;
            offset.QuadPart = sector;
            offset.QuadPart *= SECTORSIZE;

            readok = ReadFile(file, buf, n*SECTORSIZE, &cb, NULL);
            RECASSERT(readok);

            status = NtWriteFile(disk, NULL, NULL, NULL, &iosb, buf, n*SECTORSIZE, &offset);
            RECASSERT(NT_SUCCESS(status));

            sector += n;
            sector_count -= n;
        }
    }

    VirtualFree(buf, 0, MEM_RELEASE);
    CloseHandle(file);
    NtClose(disk);

    DbgPrint("Total of %d sectors copied\n", total);
}

#endif // SECTORCOPY


BOOL AreOnlineSectorsOk(PBYTE pbMachineAcctSectorData)
{
    XC_ONLINE_MACHINE_ACCOUNT_STRUCT* pMachineAccount = 
            (XC_ONLINE_MACHINE_ACCOUNT_STRUCT*) pbMachineAcctSectorData;

    ASSERT(pbMachineAcctSectorData);

    if (0 != pMachineAccount->xuid.qwUserID)
    {
        return TRUE;
    }

    return FALSE;
}


#endif // RECOVERYAPP

#define XBOX_MACHINE_ACCT_SECTOR  (XBOX_CONFIG_SECTOR_INDEX + 1)
#define XBOX_USER_SECTOR1         (XBOX_CONFIG_SECTOR_INDEX + 2)
#define XBOX_USER_SECTOR2         (XBOX_CONFIG_SECTOR_INDEX + 3)


NTSTATUS
WriteFirstSectors(
    IN HANDLE hDisk
    )
{
    LARGE_INTEGER WriteOffset;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status = STATUS_SUCCESS;
    BYTE rgbSectorBytes[XBOX_HD_SECTOR_SIZE];
    PXBOX_CONFIG_SECTOR ConfigSector = (PXBOX_CONFIG_SECTOR) rgbSectorBytes;
    int i;

    BOOL fPreserveOnlineSectors = TRUE;

    RtlZeroMemory(rgbSectorBytes, sizeof(rgbSectorBytes));

#ifdef HDSETUPAPP

    //
    // Zero out all sectors used by the greystone duplicator before writing anything
    //

    for (i = 0;
         (HardDriveSectorRanges[i].FirstSector && HardDriveSectorRanges[i].LastSector);
         i++)
    {
        UINT j;

        for (j = HardDriveSectorRanges[i].FirstSector;
             j <= HardDriveSectorRanges[i].LastSector;
             j++)
        {
            WriteOffset.QuadPart = j * XBOX_HD_SECTOR_SIZE;

            NtWriteFile(hDisk,
                        NULL,
                        NULL,
                        NULL,
                        &ioStatus,
                        rgbSectorBytes,
                        XBOX_HD_SECTOR_SIZE,
                        &WriteOffset);
        }
    }

#endif // HDSETUPAPP

    //
    // Zero out sectors 0-2 and 4-7 (including cache db sector):
    //

    //
    // Sector 3 (XBOX_REFURB_INFO_SECTOR_INDEX) contains the refurb
    // information - leave it alone
    //

    //
    // In HDSETUP, we clear out all of the sectors, refurb, config, and all
    //

    for (i = XBOX_BOOT_SECTOR_INDEX;
#if defined(HDSETUPAPP) || defined(ONLINEBETA)
         i < (XBOX_CONFIG_SECTOR_INDEX + XBOX_NUM_CONFIG_SECTORS);
#else  // HDSETUPAPP
         i < XBOX_REFURB_INFO_SECTOR_INDEX;
#endif // HDSETUPAPP
         i++)
    {
        WriteOffset.QuadPart = i * XBOX_HD_SECTOR_SIZE;

        NtWriteFile(hDisk,
                    NULL,
                    NULL,
                    NULL,
                    &ioStatus,
                    rgbSectorBytes,
                    XBOX_HD_SECTOR_SIZE,
                    &WriteOffset);
    }

#if !defined(HDSETUPAPP) && !defined(ONLINEBETA)
    for (i = XBOX_CACHE_DB_SECTOR_INDEX;
         i < XBOX_CONFIG_SECTOR_INDEX;
         i++)
    {
        WriteOffset.QuadPart = i * XBOX_HD_SECTOR_SIZE;

        NtWriteFile(hDisk,
                    NULL,
                    NULL,
                    NULL,
                    &ioStatus,
                    rgbSectorBytes,
                    XBOX_HD_SECTOR_SIZE,
                    &WriteOffset);
    }

    //
    // Preserve config sectors sectors 8-15 (if valid), otherwise zero them:
    //

    for (i = XBOX_CONFIG_SECTOR_INDEX;
         i < (XBOX_CONFIG_SECTOR_INDEX + XBOX_NUM_CONFIG_SECTORS);
         i++)
    {
        WriteOffset.QuadPart = i * XBOX_HD_SECTOR_SIZE;

        status = NtReadFile(hDisk,
                            NULL,
                            NULL,
                            NULL,
                            &ioStatus,
                            ConfigSector,
                            XBOX_HD_SECTOR_SIZE,
                            &WriteOffset);

        if (NT_SUCCESS(status) &&
            (ConfigSector->SectorBeginSignature == XBOX_CONFIG_SECTOR_BEGIN_SIGNATURE) &&
            (ConfigSector->SectorEndSignature == XBOX_CONFIG_SECTOR_END_SIGNATURE) &&
            (XConfigChecksum(ConfigSector, sizeof(*ConfigSector)) == 0xffffffff)
#ifdef RECOVERYAPP
            &&
            ((XBOX_MACHINE_ACCT_SECTOR != i) || (fPreserveOnlineSectors = AreOnlineSectorsOk(ConfigSector->Data))) &&
            (((XBOX_USER_SECTOR1 != i) && (XBOX_USER_SECTOR2 != i)) || fPreserveOnlineSectors))
#else  // RECOVERYAPP
            )
#endif // RECOVERYAPP
        {
            XDBGWRN("RECOVERY", "Preserving config sector %d.", i);
        }
        else
        {
            XDBGWRN("RECOVERY", "Invalid config sector %d - not preserving.", i);

            RtlZeroMemory(ConfigSector, XBOX_HD_SECTOR_SIZE);

            NtWriteFile(hDisk,
                        NULL,
                        NULL,
                        NULL,
                        &ioStatus,
                        ConfigSector,
                        XBOX_HD_SECTOR_SIZE,
                        &WriteOffset);
        }
    }
#endif // !HDSETUPAPP

    return status;
}

#ifdef DASHLIB

//
// Reset user settings in EEPROM to their defaults (all zeros)
//

NTSTATUS ResetEEPROMUserSettings()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_USER_SETTINGS* userSettings;
    NTSTATUS status;
    DWORD type, size;

    eeprom = (EEPROM_LAYOUT*) buf;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);

    if (NT_SUCCESS(status))
    {
        RtlZeroMemory(userSettings, sizeof(*userSettings));
        userSettings->Checksum = ~XConfigChecksum(userSettings, sizeof(*userSettings));
        status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, sizeof(buf));
    }

    return status;
}

#endif // DASHLIB

#ifdef RECOVERYAPP

#ifdef CHECK_EEPROM_SETTINGS

//
// Generate the default EEPROM image
//  We assume the output buffer has already been
//  zero-initialized by the caller.
//
VOID DefaultNonVolatileSettings(EEPROM_LAYOUT* eeprom)
{
    XBOX_FACTORY_SETTINGS* factorySettings;
    XBOX_USER_SETTINGS* userSettings;
    LARGE_INTEGER systime;
    UCHAR* enetaddr;
    ULONG tick0;

    // Pick a random Ethernet address in the 1M range
    // of the 00-50-f2 address block. Only even addresses
    // are used here.
    __asm {
        rdtsc
        mov tick0, eax
    }
    KeQuerySystemTime(&systime);
    tick0 = (tick0 ^ systime.LowPart) & 0xffffe;

    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;

    enetaddr = factorySettings->EthernetAddr;
    enetaddr[0] = 0x00;
    enetaddr[1] = 0x50;
    enetaddr[2] = 0xf2;
    enetaddr[3] = (UCHAR) (tick0 >> 16);
    enetaddr[4] = (UCHAR) (tick0 >>  8);
    enetaddr[5] = (UCHAR) (tick0      );

    // The first 32 addresses are reserved.
    enetaddr[5] |= 0x20;

    factorySettings->AVRegion = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
    factorySettings->Checksum = ~XConfigChecksum(factorySettings, sizeof(*factorySettings));

    userSettings->Checksum = ~XConfigChecksum(userSettings, sizeof(*userSettings));
}

//
// Verify the non-volatile settings are valid
// and initialize them to default values if necessary.
//
NTSTATUS CheckNonVolatileSettings()
{
    BYTE buf[EEPROM_TOTAL_MEMORY_SIZE];
    EEPROM_LAYOUT* eeprom;
    XBOX_FACTORY_SETTINGS* factorySettings;
    XBOX_USER_SETTINGS* userSettings;
    NTSTATUS status;
    DWORD type, size;

    eeprom = (EEPROM_LAYOUT*) buf;
    factorySettings = (XBOX_FACTORY_SETTINGS*) &eeprom->FactorySection;
    userSettings = (XBOX_USER_SETTINGS*) &eeprom->UserConfigSection;
    status = ExQueryNonVolatileSetting(XC_MAX_ALL, &type, buf, sizeof(buf), &size);

    if (NT_SUCCESS(status) &&
        XConfigChecksum(factorySettings, sizeof(*factorySettings)) == 0xffffffff &&
        XConfigChecksum(userSettings, sizeof(*userSettings)) == 0xffffffff) {
        XDBGWRN("RECOVERY", "Preserving EEPROM settings.");
    } else if (XboxHardwareInfo->GpuRevision == 0xa1) {
        XDBGWRN("RECOVERY", "Initializing EEPROM settings (DVT2) ...");
        memset(buf, 0, sizeof(buf));

        DefaultNonVolatileSettings(eeprom);
        status = ExSaveNonVolatileSetting(XC_MAX_ALL, REG_BINARY, buf, sizeof(buf));

        if (!NT_SUCCESS(status)) {
            XDBGWRN("RECOVERY", "Failed to initialized EEPROM settings: %x.", status);
        }
    } else {
        XDBGWRN("RECOVERY", "!!!!!!!!!! Corrupted EEPROM on DVT3 box !!!!!!!!!!");
    }

    return status;
}

#endif // CHECK_EEPROM_SETTINGS

// Threshold for analog buttons
#define XINPUT_ANALOGBUTTONTHRESHOLD 32

//
// This function returns with *pdwNewVideoMode set to 0xFFFFFFFF if a regular
// controller button is pressed.
//
// It returns with *pdwNewVideoMode set to a valid video mode if a video mode
// change button sequence has been pressed:
// (both triggers + right thumbstick + some other button)
//

VOID
WaitForAnyButton(PDWORD pdwNewVideoMode, PBOOL pfYButton)
{
    BOOL fButtonPressed = FALSE;
    static DWORD dwPads = 0;
    DWORD dwInsertions, dwRemovals;
    static HANDLE hPads[XGetPortCount()] = { 0 };
    int i;

    ASSERT(pdwNewVideoMode);
    *pdwNewVideoMode = 0xFFFFFFFF;

    while (!fButtonPressed)
    {
        if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals))
        {
            dwPads |= dwInsertions;
            dwPads &= ~dwRemovals;

            for (i = 0; i < XGetPortCount(); i++)
            {
                if ((1 << i) & dwRemovals)
                {
                    if (NULL != hPads[i])
                    {
                        XInputClose(hPads[i]);
                        hPads[i] = NULL;
                    }
                }

                if ((1 << i) & dwInsertions)
                {
                    if (NULL == hPads[i])
                    {
                        hPads[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL);;
                    }
                }
            }
        }

        for (i = 0; i < XGetPortCount(); i++)
        {
            if ((1 << i) & dwPads)
            {
                if (NULL != hPads[i])
                {
                    XINPUT_STATE State;

                    if (ERROR_SUCCESS == XInputGetState(hPads[i], &State))
                    {
                        if ((State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > XINPUT_ANALOGBUTTONTHRESHOLD) &&
                            (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        {
                            if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP)
                            {
                                *pdwNewVideoMode = AV_STANDARD_PAL_I | AV_FLAGS_50Hz;
                            }
                            else if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
                            {
                                *pdwNewVideoMode = AV_STANDARD_NTSC_M | AV_FLAGS_60Hz;
                            }
                            else if (State.Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
                            {
                                *pdwNewVideoMode = AV_STANDARD_NTSC_J | AV_FLAGS_60Hz;
                            }
                        }
                        else if ((0 != ((XINPUT_GAMEPAD_START | XINPUT_GAMEPAD_BACK) & State.Gamepad.wButtons)) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > XINPUT_ANALOGBUTTONTHRESHOLD) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > XINPUT_ANALOGBUTTONTHRESHOLD))
                        {
                            fButtonPressed = TRUE;
                            
                            if (pfYButton)
                            {
                                *pfYButton = (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] >
                                                XINPUT_ANALOGBUTTONTHRESHOLD);
                            }
                        }
                    }
                }
            }

            if (fButtonPressed || (*pdwNewVideoMode != 0xFFFFFFFF))
            {
                fButtonPressed = TRUE;
                break;
            }
        }
    }
}

VOID
WaitForButtonPress(
    PBOOL YButton
    )
{
    ULONG VideoMode;

    //
    // Keep processing button presses.  If the video mode changes, then
    // deal with it.
    //

    for(;;) {
        WaitForAnyButton(&VideoMode, YButton);
        if(VideoMode == 0xFFFFFFFF)
            return;

        //
        // Reset video flags and re-init
        //

        ExSaveNonVolatileSetting(XC_FACTORY_AV_REGION, REG_DWORD, &VideoMode,
            sizeof(VideoMode));

        D3D__AvInfo = 0;

        g_pVideo->DeInitialize();

        g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

        g_pVideo->ClearScreen(COLOR_BLACK);
        g_pBackgroundBitmap->render(g_pVideo->GetD3DDevicePtr());
        g_pVideo->ShowScreen();
    }
}

#endif // RECOVERYAPP

#ifdef RECOVERYAPP

#define FAIL_RECOVERY(code)                                    \
{                                                              \
    WCHAR szMsg[128];                                          \
    wsprintfW(szMsg, RStrings[RS_FAILURE_LINE2_FORMAT], code); \
    DrawMessage(RStrings[RS_FAILURE_LINE1], szMsg, -1);        \
    XDBGWRN("RECOVERY", "Recovery failed (err 0x%08x)", code); \
    IDirect3DDevice8* pDevice = g_pVideo->GetD3DDevicePtr();   \
    ASSERT(pDevice);                                           \
    pDevice->BlockUntilIdle();                                 \
    Sleep(INFINITE);                                           \
    return;                                                    \
}

#endif // RECOVERYAPP

#ifndef RECOVERYNOFLASH

VOID
DetectInitTableVersion(
    VOID
    )
{
    PVOID RomBase;

    RomBase = MmMapIoSpace( FLASH_BASE_ADDRESS, FLASH_REGION_SIZE,
                                  PAGE_READWRITE | PAGE_NOCACHE );
    if (NULL == RomBase) {
        XDBGERR("RECOVERY", "Could not map ROM");
        FAIL_RECOVERY(4);
    }
    g_InitTableVer = FlashReadUlong(FLASH_BASE_ADDRESS +
        ROM_VERSION_BYTE_OFFSET);
    XDBGWRN("RECOVERY", "Detected init table version 0x%08x", g_InitTableVer);
    MmUnmapIoSpace( RomBase, FLASH_REGION_SIZE );
}

VOID
UpdateROMImage(
    BOOL RetailImage
    )
{
    BOOL ExternalROM;
    BOOL UpdateNeeded;
    BOOL YButton;
    PUCHAR ROMImage;
    PUCHAR ROMData;
    ULONG SizeOfDataReturned;
    PSTR ROMFileName;
    HANDLE ROMFileHandle;

#ifdef ONLINEBETA
	UpdateNeeded = TRUE;
#else

    //
    // Detect the current ROM version and flavor to see whether we need to
    // update it.
    //

    ExternalROM = (g_InitTableVer & ROM_VERSION_KDDELAY_FLAG) != 0;
    if(RetailImage && (XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL))
        UpdateNeeded = TRUE;
    else if(!RetailImage && !(XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL))
        UpdateNeeded = TRUE;
    else if(ExternalROM && g_fInternalCD)
        UpdateNeeded = TRUE;
    else if(!ExternalROM && !g_fInternalCD)
        UpdateNeeded = TRUE;
    else
        UpdateNeeded = ((g_InitTableVer >> 16) & 0x7FFF) < RecoveryVersion;
#endif

    //
    // If the ROM is current and we're doing internal recovery, we offer the
    // option to update anyway.
    //

    if(!UpdateNeeded) {
        if(!g_fInternalCD)
            return;
        DrawMessage(RStrings[RS_OVERWRITEROM_LINE1],
            RStrings[RS_OVERWRITEROM_LINE2], -1);
        Sleep(200);
        WaitForButtonPress(&YButton);
        if(!YButton)
            return;
    }

    //
    // Load the ROM image
    //

    ROMImage = (PUCHAR) LocalAlloc(LMEM_FIXED, ROM_SIZE);
    if (NULL == ROMImage) {
        XDBGERR("RECOVERY", "Could not allocate ROM image memory");
        FAIL_RECOVERY(1);
    }

#ifdef ONLINEBETA
    if ((g_InitTableVer & 0xFF) == 0x46 || (g_InitTableVer & 0xFF) == 0x70) 
        ROMFileName = NULL;
    else
        ROMFileName = "D:\\xboxrom_beta.bin";
#else
    if ((g_InitTableVer & 0xFF) == 0x46)
        ROMFileName = RetailImage ? "D:\\RETAIL\\xboxrom_dvt4.bin" : "D:\\xboxrom_dvt4.bin";
    else if ((g_InitTableVer & 0xFF) == 0x70) 
        ROMFileName = RetailImage ? "D:\\RETAIL\\xboxrom_qt.bin" : "D:\\xboxrom_qt.bin";
    else
        ROMFileName = RetailImage ? "D:\\RETAIL\\xboxrom.bin" : "D:\\xboxrom.bin";
#endif

    ROMFileHandle = CreateFile(ROMFileName, GENERIC_READ, 0, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    //
    // If the ROM image is missing from the drive, we need to advise the user,
    // but not fail recovery.
    //

    if (INVALID_HANDLE_VALUE == ROMFileHandle) {
        DWORD dwErr = GetLastError();
        XDBGWRN("RECOVERY", "Could not open ROM image file (%s), err=0x%08x", ROMFileName, dwErr);
#ifdef ONLINEBETA
		FAIL_RECOVERY(3);
#else
        DrawMessage(RStrings[RS_NEWERROM_LINE1],
            RStrings[RS_NEWERROM_LINE2], -1);
        WaitForButtonPress(&YButton);
        LocalFree(ROMImage);
        return;
#endif
    }

    //
    // Read in the ROM
    //

    ROMData = ROMImage;
    while (ReadFile(ROMFileHandle, ROMData, ROM_SIZE - (ROMData - ROMImage),
        &SizeOfDataReturned, NULL) && (0 != SizeOfDataReturned))
    {
        ROMData += SizeOfDataReturned;
    }
    CloseHandle(ROMFileHandle);

    if (ROM_SIZE != (ROMData - ROMImage)) {
        XDBGERR("RECOVERY", "Could not read ROM image file, read %d out of %d bytes",
            (ROMData - ROMImage), ROM_SIZE);
        FAIL_RECOVERY(3);
    }

    DrawMessage(RStrings[RS_FLASH_LINE1], RStrings[RS_FLASH_LINE2], -1);

    IDirect3DDevice8* pDevice = g_pVideo->GetD3DDevicePtr();
    ASSERT(pDevice);
    pDevice->BlockUntilIdle();

    XDBGWRN("RECOVERY", "Starting ROM Flash...");

    HRESULT hrFlash;

    for (int i = 0; i < ROM_FLASH_RETRIES; i++)
    {
        CHAR szResp[128];
        hrFlash = FlashKernelImage(ROMImage,
                                   ROM_SIZE,
                                   szResp,
                                   ARRAYSIZE(szResp));

        XDBGWRN("RECOVERY", "Flash Status (%d): hr=0x%08x (%s)", i, hrFlash, szResp);

        if (SUCCEEDED(hrFlash))
        {
            break;
        }
    }

    if (ROM_FLASH_RETRIES == i)
    {
        XDBGERR("RECOVERY", "Could not flash ROM, hr=0x%08x", hrFlash);
        FAIL_RECOVERY(hrFlash);
    }

    LocalFree(ROMImage);
}

#endif // RECOVERYNOFLASH

#ifdef DASHLIB

#define FAIL_RECOVERY(code)                                    \
{                                                              \
    XDBGWRN("RECOVERY", "Recovery failed (err 0x%08x)", code); \
    return code;                                               \
}

#endif // DASHLIB

#define MAX_SECS_PER_VERIFY 256

typedef
VOID
(CALLBACK *PFORMAT_PROGRESS_ROUTINE)(
    UINT uPercent
    );

BOOL
WINAPI
RecFormatFATVolume(
    POBJECT_STRING VolumePath,
    BOOL fQuickFormat,
    PFORMAT_PROGRESS_ROUTINE pFPR
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE VolumeHandle;
    DISK_GEOMETRY DiskGeometry;
    ULONG SectorShift;
    ULONG StructureAlignment;
    PARTITION_INFORMATION PartitionInformation;
    LARGE_INTEGER ByteOffset;

    if (pFPR)
    {
        pFPR(0);
    }

    InitializeObjectAttributes(&ObjectAttributes, VolumePath,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (!XapiFormatFATVolume(VolumePath))
    {
        return FALSE;
    }

    //
    // Open the volume for read/write access.
    //

    status = NtOpenFile(&VolumeHandle, SYNCHRONIZE | FILE_READ_DATA |
        FILE_WRITE_DATA, &ObjectAttributes, &IoStatusBlock, 0,
        FILE_SYNCHRONOUS_IO_ALERT | FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS(status)) {
        // XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Obtain the drive geometry for the target device.
    //

    status = NtDeviceIoControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &DiskGeometry,
        sizeof(DiskGeometry));

    if (!NT_SUCCESS(status)) {
        NtClose(VolumeHandle);
        // XapiSetLastNTError(status);
        return FALSE;
    }

    SectorShift = RtlFindFirstSetRightMember(DiskGeometry.BytesPerSector);

    //
    // Obtain the size of the partition for the target device.
    //

    status = NtDeviceIoControlFile(VolumeHandle, NULL, NULL, NULL, &IoStatusBlock,
        IOCTL_DISK_GET_PARTITION_INFO, NULL, 0, &PartitionInformation,
        sizeof(PartitionInformation));

    if (!NT_SUCCESS(status)) {
        NtClose(VolumeHandle);
        // XapiSetLastNTError(status);
        return FALSE;
    }

    //
    // Compute the alignment between the various file system structures.
    // Everything should be page aligned in order to maximum file system cache
    // efficiency.
    //

    StructureAlignment = ROUND_TO_PAGES(DiskGeometry.BytesPerSector);

    //
    // Now do the verify...
    //

    {
        DWORD dwAllSectors = (DWORD) PartitionInformation.PartitionLength.QuadPart >> SectorShift;
        DWORD dwSecsPerVerify = min((dwAllSectors / 20) + 1, MAX_SECS_PER_VERIFY);
        DWORD dwPercent = 0;

        // Do a full verify of the disk

        for (DWORD i = 0; i < dwAllSectors; i += dwSecsPerVerify)
        {
            VERIFY_INFORMATION vi;

            if ((i * 100) / dwAllSectors > dwPercent)
            {
                dwPercent = ((i * 100) / dwAllSectors);
                XDBGTRC("RECOVERY", "Format is %ld%% complete", dwPercent);
                if (pFPR)
                {
                    pFPR(dwPercent);
                }
            }

            vi.StartingOffset.QuadPart = i << SectorShift;
            vi.Length = min(dwSecsPerVerify, dwAllSectors - i) << SectorShift;

            ASSERT(dwSecsPerVerify < (0xFFFFFFFF >> SectorShift));

            status = NtDeviceIoControlFile(
                        VolumeHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        IOCTL_DISK_VERIFY,
                        &vi,
                        sizeof(vi),
                        NULL,
                        0
                        );

            if (!NT_SUCCESS(status))
            {
                XDBGERR("RECOVERY",
                        "NtDeviceIoControlFile() IOCTL_DISK_VERIFY failed - st=0x%08X",
                        status);
                break;
            }

            if ((0 == i) && fQuickFormat)
            {
                //
                // NOTE: modifying loop counter, ugly, I know.  But this is a
                // convenient way to make sure that quickformat verifies the
                // beginning and the end of the disk..
                //
                i = max(i + dwSecsPerVerify, dwAllSectors - dwSecsPerVerify);
            }
        }

        NtClose(VolumeHandle);

        if (!NT_SUCCESS(status))
        {
            return FALSE;
        }
    }

    if (pFPR)
    {
        pFPR(100);
    }

    return TRUE;
}

//
// Index of the partition that is currently being formatted (1-based)
//

UINT g_CurrentFormatPartition;

#ifdef RECOVERYAPP

VOID
CALLBACK
RecFormatProgress(
    UINT uPercent
    )
{
    UINT uPartitions = (XDISK_FIRST_CACHE_PARTITION - 1) + *HalDiskCachePartitionCount;
    DrawMessage(RStrings[RS_PREPARING],
                NULL,
                ((100 / uPartitions) * (g_CurrentFormatPartition - 1)) +
                    (uPercent / uPartitions));
}

BOOL HDSetPassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_SET_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
        SecurityData.Maximum = TRUE;
        SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDSetPassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDSetPassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

#ifndef INT2RETAIL
#ifndef HDSETUPAPP
    {
    //
    // Now that we've reset the HD password, we need to make sure the EEPROM
    // has the correct key
    //
    EEPROM_LAYOUT eepromData;
    ULONG type, length;
    DWORD err;
    XBOX_ENCRYPTED_SETTINGS* encryptedSection =
        (XBOX_ENCRYPTED_SETTINGS*) eepromData.EncryptedSection;

    //
    // Read the existing content of the encrypted section
    //
    err = XQueryValue(XC_MAX_ALL, &type, &eepromData, sizeof(eepromData), &length);

    if (ERROR_SUCCESS != err)
    {
        return FALSE;
    }

    //
    // By now, the EEPROM should have been encrypted
    //
    if (ERROR_SUCCESS != DecryptEEPROMEncryptedSection(encryptedSection))
    {
        return FALSE;
    }

    //
    // Copy in the HD key we used to lock the HD
    //
    memcpy(encryptedSection->HDKey, *XboxHDKey, XBOX_KEY_LENGTH);

    //
    // Reencrypt the EEPROM header
    //
    err = EncryptEEPROMEncryptedSection(encryptedSection);

    if (ERROR_SUCCESS != err)
    {
        return FALSE;
    }

    err = XSetValue(XC_MAX_ALL, REG_BINARY, &eepromData, sizeof(eepromData));

    if (ERROR_SUCCESS != err)
    {
        return FALSE;
    }
    }
#endif // HDSETUPAPP
#endif // INT2RETAIL

    return TRUE;
}



BOOL HDDisablePassword( BYTE* password, DWORD dwLen )
{
    NTSTATUS status;
    HANDLE h;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    OBJECT_STRING name;
    ULONG AtaPassThroughSize;
    ATA_PASS_THROUGH AtaPassThrough;
    IDE_SECURITY_DATA SecurityData;
    BOOL fReturn;
    DWORD cbBytes;

    RtlInitObjectString(&name, "\\Device\\Harddisk0\\Partition0");
    InitializeObjectAttributes(&obja, &name, 0, NULL, 0);

    status = NtOpenFile(&h, GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, &obja, &iosb,
        FILE_SHARE_WRITE | FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(&AtaPassThrough, sizeof(ATA_PASS_THROUGH));
        RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));

        AtaPassThrough.IdeReg.bHostSendsData = TRUE;
        AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_DISABLE_PASSWORD;
        AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
        AtaPassThrough.DataBuffer = &SecurityData;
        SecurityData.Maximum = TRUE;
        SecurityData.Master = FALSE;

        RtlCopyMemory(SecurityData.Password, password, dwLen);

        fReturn = DeviceIoControl(h, IOCTL_IDE_PASS_THROUGH,
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
            &cbBytes, NULL);

        if (!fReturn) {
            XDBGTRC("HDDisablePassword", "API error!");
            return FALSE;
        } else if (AtaPassThrough.IdeReg.bCommandReg & 1) {
            XDBGTRC("HDDisablePassword", "IDE error!");
            return FALSE;
        }

        NtClose(h);
    }

    return TRUE;
}




#ifdef INT2RETAIL
static 
void 
ProgramEEPROM()
{
    EEPROM_LAYOUT ExistingEEPROM;
    EEPROM_LAYOUT NewEEPROM;
    ULONG type;
    ULONG dwBytes;
    DWORD dwRetVal;
    HANDLE hFile;
    XBOX_FACTORY_SETTINGS* pNewFactorySettings;
    XBOX_FACTORY_SETTINGS* pExistingFactorySettings;

    DrawMessage(L"Programming EEPROM", L"Please wait", -1);

    //
    // Read the eeprom image from disk
    //
    hFile = CreateFile("D:\\eeprom.bin", GENERIC_READ, 0, NULL, OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        FAIL_RECOVERY(31);
    }

    if (!ReadFile(hFile, &NewEEPROM, sizeof(NewEEPROM), &dwBytes, NULL) || dwBytes != 256) {
        CloseHandle(hFile);
        FAIL_RECOVERY(32);
    }
    CloseHandle(hFile);

    //
    // Read the existing EEPROM
    //
    dwRetVal = XQueryValue(XC_MAX_ALL, &type, &ExistingEEPROM, sizeof(ExistingEEPROM), &dwBytes);
    if (dwRetVal != ERROR_SUCCESS) {
        FAIL_RECOVERY(33);
    }

    //
    // Copy the ehternet address from existing to new
    //

    pNewFactorySettings = (XBOX_FACTORY_SETTINGS*)&NewEEPROM.FactorySection;
    pExistingFactorySettings = (XBOX_FACTORY_SETTINGS*)&ExistingEEPROM.FactorySection;

    memcpy(pNewFactorySettings->EthernetAddr, pExistingFactorySettings->EthernetAddr, 6);

    //
    // Calculate the checksum
    //
    pNewFactorySettings->Checksum = 0;
    pNewFactorySettings->Checksum = ~XConfigChecksum(pNewFactorySettings, sizeof(XBOX_FACTORY_SETTINGS));

    //
    // Write out the new EEPROM
    //
    dwRetVal = XSetValue(XC_MAX_ALL, REG_BINARY, &NewEEPROM, sizeof(NewEEPROM));
    if (dwRetVal != ERROR_SUCCESS) {
        FAIL_RECOVERY(34);
    }

}

#endif  // INT2RETAIL


#endif // RECOVERYAPP

#ifdef DASHLIB

static PFNRECPROGRESSCALLBACK g_spDashCallback = NULL;
static ULONG_PTR g_DashContext = NULL;

VOID
CALLBACK
RecFormatProgress(
    UINT uPercent
    )
{
    //
    // Subtract out the dashboard partition (partition2)
    //

    UINT uPartitions = (XDISK_FIRST_CACHE_PARTITION - 1) + *HalDiskCachePartitionCount - 1;
    UINT uCurPartition = g_CurrentFormatPartition;

    if (uCurPartition >= DASHBOARD_PARTITION_NUMBER)
    {
        uCurPartition--;
    }


    UINT uOverallPercent = ((100 / uPartitions) * (uCurPartition - 1)) + (uPercent / uPartitions);

    XDBGWRN("RECOVERY",
            "Recovery format is %d%% complete",
            uOverallPercent);

    if (g_spDashCallback)
    {
        g_spDashCallback(uOverallPercent, g_DashContext);
    }
}

#endif // DASHLIB

#ifdef RECOVERYAPP

BOOL IsEEPROMKeyAllZeros()
{
    int i;
    UCHAR* EepromKey = (UCHAR*) *XboxEEPROMKey;

    //
    // Check to see if the EEPROM key is zero (which happens after warm reboots).
    //
    // If this is the case, we can't run recovery
    // (which needs to decrypt/encrypt the EEPROM)
    //

    for (i = 0; i < XBOX_KEY_LENGTH; i++)
    {
        if (0 != EepromKey[i])
        {
            return FALSE;
        }
    }

    return TRUE;
}

#endif // RECOVERYAPP

#ifdef RECOVERYAPP
void __cdecl main()
#endif // RECOVERYAPP
#ifdef DASHLIB
extern "C"
{
ULONG DashRecovery(PFNRECPROGRESSCALLBACK pfnCallback, ULONG_PTR Context)
#endif // DASHLIB
{
    IO_STATUS_BLOCK statusBlock;
    DISK_GEOMETRY diskGeometry;
    OBJECT_ATTRIBUTES oa;
    HANDLE hDisk;
    NTSTATUS Status;
    int i;
    
#ifdef DASHLIB
    g_spDashCallback = pfnCallback;
    g_DashContext = Context;
#endif // DASHLIB

#ifdef RECOVERYAPP
    WCHAR szText[128];
    DWORD dwVideoFlags;
    BOOL fRetail = FALSE;
    UINT WaitStep = 0;
    BYTE FinalHardDriveKey[XC_SERVICE_DIGEST_SIZE];
    BOOL fDiskHasRetail = (0xFFFFFFFF != GetFileAttributes("D:\\RETAIL"));
    DWORD dwNV2ARevision = *((DWORD*)0xFD000000);
    CHAR szSMCVersion[4];

    GetSMCVersion(szSMCVersion, ARRAYSIZE(szSMCVersion));
    
#ifdef ONLINEBETA
	g_fInternalCD = fDiskHasRetail = FALSE;
#else
    g_fInternalCD = (0xFFFFFFFF != GetFileAttributes("D:\\DEVKIT\\DXT\\CYDRIVE.DXT"));
#endif

    //
    // Initialize core peripheral port support
    //
    XInitDevices(0,NULL);

#ifdef CHECK_EEPROM_SETTINGS
    CheckNonVolatileSettings();
#endif

    g_pVideo = new CXBoxVideo;
    g_pBackgroundBitmap = new BitmapFile;

    if ((NULL == g_pVideo) || (NULL == g_pBackgroundBitmap))
    {
        XDBGERR("RECOVERY", "Couldn't allocate video objects");
        Sleep(INFINITE);
    }

    g_pBackgroundBitmap->read(0, 0, FILE_DATA_IMAGE_DIRECTORY_A "\\backgrnd.bmp");

    g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

#ifndef HDSETUPAPP

    DetectInitTableVersion();

    //
    // Init table version < 0x40: Old DVT 3 Boxes with NV2A A02 old metal 7 (NVCLK 155, CPU 665)
    // Init table version = 0x40: New DVT 3 Boxes with NV2A A02 new metal 7 (Faster)
    // Init table version = 0x46: DVT4, DVT5, XDK2 (FAB F)
    // Init table version = 0x60: DVT6+, XDK2 (FAB G/H)
    // Init table version = 0x70: QT (MCP C03)
    //

    //
    // SMC Versions starting with 'B' are no longer supported (DVT3=B2A, DVT4=B3B, etc.)
    //
    // DVT5/XDK2 and greater start with 'D' or 'P' (i.e. DVT5=DXB)
    //
    
    if (((g_InitTableVer & 0xFF) < 0x46) ||
        ((dwNV2ARevision & 0xFF) == 0xA1) ||
        ((dwNV2ARevision & 0xFF) == 0xA2) ||
        (szSMCVersion[0] == 'B'))
    {
        DrawMessage(RStrings[RS_FAILURE_LINE1], RStrings[RS_FAILURE_LINE2_OLD_BOX], -1);
        XDBGWRN("RECOVERY", "Recovery failed because this Xbox is no longer supported");

        XDBGWRN("RECOVERY", "Versions: 0x%08x, 0x%02x, %s",
                g_InitTableVer, (dwNV2ARevision & 0xFF), szSMCVersion);

        IDirect3DDevice8* pDevice = g_pVideo->GetD3DDevicePtr();
        ASSERT(pDevice);
        pDevice->BlockUntilIdle();

        Sleep(INFINITE);
        return;
    }

    if (IsEEPROMKeyAllZeros())
    {
        DrawMessage(RStrings[RS_FAILURE_LINE1], RStrings[RS_FAILURE_LINE2_WARM_BOOT], -1);
        XDBGWRN("RECOVERY", "Recovery failed because this Xbox needs to have been cold booted");

        IDirect3DDevice8* pDevice = g_pVideo->GetD3DDevicePtr();
        ASSERT(pDevice);
        pDevice->BlockUntilIdle();

        Sleep(INFINITE);
        return;
    }

#endif // ! HDSETUPAPP

#ifdef HDSETUPAPP
    if ((XboxKrnlVersion->Build < 3944) && (XboxKrnlVersion->Major == 1) && (XboxKrnlVersion->Minor == 0))
    {
        DrawMessage(RStrings[RS_FAILURE_LINE1], RStrings[RS_FAILURE_LINE2_OLD_BOX], -1);
        XDBGWRN("RECOVERY", "Recovery failed because this Xbox is no longer supported");

        IDirect3DDevice8* pDevice = g_pVideo->GetD3DDevicePtr();
        ASSERT(pDevice);
        pDevice->BlockUntilIdle();

        Sleep(INFINITE);
        return;
    }
#endif // HDSETUPAPP

    DrawMessage(RStrings[RS_GAMEPAD_BEGIN_LINE1], RStrings[RS_GAMEPAD_BEGIN_LINE2], -1);

    while (WaitStep < 2)
    {
        WaitForAnyButton(&dwVideoFlags, &fRetail);

        if (0xFFFFFFFF != dwVideoFlags)
        {
            //
            // Reset video flags and re-init
            //

            ExSaveNonVolatileSetting(XC_FACTORY_AV_REGION, REG_DWORD, &dwVideoFlags, sizeof(dwVideoFlags));

            D3D__AvInfo = 0;

            g_pVideo->DeInitialize();

            g_pVideo->Initialize( SCREEN_WIDTH, SCREEN_HEIGHT );

            g_pVideo->ClearScreen(COLOR_BLACK);
            g_pBackgroundBitmap->render(g_pVideo->GetD3DDevicePtr());
            g_pVideo->ShowScreen();
        }
        else
        {
            WaitStep++;
#ifndef HDSETUPAPP
            if (!fDiskHasRetail)
            {
                fRetail = FALSE;
                break;
            }
#endif // HDSETUPAPP
        }

        //
        // Wait for the button to go back up before asking for another button press
        //
        
        if ((WaitStep > 0) && (WaitStep < 2))
        {
            Sleep(200);
        }
        
        DrawMessage(RStrings[(0 == WaitStep) ? RS_GAMEPAD_BEGIN_LINE1 : RS_RETAIL_LINE1],
                    RStrings[(0 == WaitStep) ? RS_GAMEPAD_BEGIN_LINE2 : RS_RETAIL_LINE2],
                    -1);

    }

#ifdef ONLINEBETA
	if(!FLoadNewEEPROMKey("D:\\BETA.DAT", "Beta2002_key1set")) {
		XDBGWRN("RECOVERY", "Recovery failed because it could not load the new EEPROM key");
		FAIL_RECOVERY(25);
	}
#endif

#ifndef HDSETUPAPP
    if (ERROR_SUCCESS != PrepareEEPROM())
    {
        XDBGWRN("RECOVERY", "Recovery failed because it could not prepare the EEPROM");
        FAIL_RECOVERY(25);
    }
#endif // HDSETUPAPP

#ifndef RECOVERYNOFLASH
    UpdateROMImage(fRetail);
#endif

    DrawMessage(RStrings[RS_PREPARING], NULL, 0);

#endif // RECOVERYAPP



    //
    // Open a handle to the entire hard disk (aka Partition0)
    //

    InitializeObjectAttributes(&oa,
                               (POBJECT_STRING) &PrimaryHarddisk,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenFile(&hDisk,
                        SYNCHRONIZE | GENERIC_ALL,
                        &oa,
                        &statusBlock,
                        0,
                        FILE_SYNCHRONOUS_IO_ALERT);

    if (!NT_SUCCESS(Status))
    {
        XDBGERR("RECOVERY", "Could not open hard disk %Z (0x%08x).", &PrimaryHarddisk, Status);
        FAIL_RECOVERY(13);
    }

    Status = WriteFirstSectors(hDisk);

    if (!NT_SUCCESS(Status))
    {
        XDBGERR("RECOVERY",
                "WriteFirstSectors() failed (0x%08x) for hard disk %Z.",
                Status,
                &PrimaryHarddisk);
        FAIL_RECOVERY(14);
    }

    NtClose(hDisk);

    XDBGTRC("RECOVERY", "Formatting hard disk partitions...");

    for (g_CurrentFormatPartition = 1;
         g_CurrentFormatPartition < XDISK_FIRST_CACHE_PARTITION + *HalDiskCachePartitionCount;
         g_CurrentFormatPartition++)
    {
        OCHAR szPartition[MAX_PATH];
        OBJECT_STRING PartitionString;

#ifdef DASHLIB
        //
        // If we're running recovery from within the dash, don't reformat the dash partition:
        //

        if (DASHBOARD_PARTITION_NUMBER == g_CurrentFormatPartition)
        {
            continue;
        }
#endif // DASHLIB

        _snoprintf(szPartition,
                   ARRAYSIZE(szPartition),
                   HdPartitionX,
                   g_CurrentFormatPartition);

        RtlInitObjectString(&PartitionString, szPartition);

        if (!RecFormatFATVolume(
                &PartitionString,
                QUICK_FORMAT,
                RecFormatProgress))
        {
            XDBGERR("RECOVERY", "Could not format hard disk partition %d.", g_CurrentFormatPartition);
            FAIL_RECOVERY(100 + g_CurrentFormatPartition);
        }
    }

#ifdef DASHLIB

    //
    // We're assuming that the dash already has the C: drive mapped
    //
    
    if (!CreateDirectory("C:\\TDATA", NULL))
    {
        FAIL_RECOVERY(20);
    }
    
    if (!CreateDirectory("C:\\UDATA", NULL))
    {
        FAIL_RECOVERY(21);
    }

    Status = ResetEEPROMUserSettings();

    if (!NT_SUCCESS(Status))
    {
        XDBGERR("RECOVERY", "Dash recovery failed because ResetEEPROMUserSettings() failed");
        HalReturnToFirmware(HalFatalErrorRebootRoutine);
    }

#endif // DASHLIB

#ifdef RECOVERYAPP

    DrawMessage(RStrings[RS_COPYING], NULL, 5);

    
    //
    // Give the main partition a drive letter
    //

    if (!NT_SUCCESS(IoCreateSymbolicLink((POBJECT_STRING) &CDrive, (POBJECT_STRING) &HdPartition1)))
    {
        XDBGERR("RECOVERY", "Could not assign %Z to %Z", &CDrive, &HdPartition1);
        FAIL_RECOVERY(15);
    }

#ifdef SECTORCOPY

    WriteDiskSnapshot();

#else  // SECTORCOPY

#ifndef HDSETUPAPP
    if (fRetail)
    {
        if (!CreateDirectory("C:\\TDATA", NULL))
        {
            FAIL_RECOVERY(22);
        }
        
        if (!CreateDirectory("C:\\UDATA", NULL))
        {
            FAIL_RECOVERY(23);
        }
    }
    else
#endif // HDSETUPAPP
    {
        if (!CopyFiles(OTEXT("D:\\*"), OTEXT("C:\\"), TRUE, NULL, 0))
        {
            XDBGERR("RECOVERY", "Could not copy files to the hard disk (main partition)");
            FAIL_RECOVERY(16);
        }
    }

    //
    // Give the dash partition a drive letter
    //

    if (!NT_SUCCESS(IoCreateSymbolicLink((POBJECT_STRING) &YDrive, (POBJECT_STRING) &HdPartition2)))
    {
        XDBGERR("RECOVERY", "Could not assign %Z to %Z", &YDrive, &HdPartition2);
        FAIL_RECOVERY(17);
    }

    if (!CopyFiles(OTEXT("D:\\XDASH\\*"),
                   OTEXT("Y:\\"),
#ifdef HDSETUPAPP
                   FALSE, NULL, 0))
#else
                   fRetail,
                   fRetail ? g_RetailDashExceptions : NULL,
                   fRetail ? ARRAYSIZE(g_RetailDashExceptions) : 0))
#endif // HDSETUPAPP
    {
        XDBGERR("RECOVERY", "Could not copy files to the hard disk (dash partition)");
        FAIL_RECOVERY(18);
    }

#ifndef HDSETUPAPP

    if (fRetail)
    {
        //
        // Copy over the retail dash
        //

        if (!CopyFile("D:\\RETAIL\\xboxdash.xbe", "Y:\\xboxdash.xbe", FALSE))
        {
            FAIL_RECOVERY(24);
        }
    }

#endif // HDSETUPAPP

#endif // SECTORCOPY

#ifdef INT2RETAIL
    //
    // Unlock the hard drive
    //
    XcHMAC( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
        (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
        (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
        FinalHardDriveKey ) ;
    
    HDDisablePassword(FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE);

    //
    // Program the EEPROM
    //
    ProgramEEPROM();

    //
    // Lock the HDD
    //

    XcHMAC( (LPBYTE)"INT2RETAILHDKEY", XBOX_KEY_LENGTH,
        (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
        (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
        FinalHardDriveKey ) ;
 
    if (!HDSetPassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE )) {
        XDBGERR("RECOVERY", "Could not lock HD");
        FAIL_RECOVERY(26);
    }


#else // INT2RETAIL


#ifdef HDSETUPAPP

    //
    // Compute Key to use to lock hard drive
    //
    if(fRetail) {
        /* We're locking, so use the HD_KEY */
        XcHMAC( (LPBYTE) HD_KEY, XBOX_KEY_LENGTH,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey );
    } else {
        /* We're unlocking, so use the EEPROM key */
        XcHMAC( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey ) ;
        /* Now perform the unlock */
        HDDisablePassword(FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE);
    }

#else  // HDSETUPAPP

#ifndef ONLINEBETA
    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) != 0)
    {
        RtlZeroMemory( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH );
    }
#endif

    //
    // Compute Key to use to lock hard drive
    //
    XcHMAC( (LPBYTE)(*XboxHDKey), XBOX_KEY_LENGTH,
            (LPBYTE)HalDiskModelNumber->Buffer, HalDiskModelNumber->Length,
            (LPBYTE)HalDiskSerialNumber->Buffer, HalDiskSerialNumber->Length,
            FinalHardDriveKey ) ;

#endif // HDSETUPAPP

    if(
#ifdef HDSETUPAPP
        fRetail &&
#endif
        !HDSetPassword( FinalHardDriveKey, XC_SERVICE_DIGEST_SIZE ))
    {
        XDBGERR("RECOVERY", "Could not lock HD");
        FAIL_RECOVERY(26);
    }

#endif  // !INT2RETAIL

    DrawMessage(RStrings[RS_COPYING], NULL, 100);

    if ((XboxHardwareInfo->Flags & XBOX_HW_FLAG_DEVKIT_KERNEL) != 0)
    {
        XDBGTRC("RECOVERY", "\n\nPlease remove the recovery CD and then press any gamepad button to reboot...\n");

        DrawMessage(RStrings[RS_GAMEPAD_END_LINE1], RStrings[RS_GAMEPAD_END_LINE2], -1);

        EjectDVD();
    }
    else
    {
        //
        // We can't eject the CD if we're running on the retail kernel, so we have to ask the
        // user to eject instead...
        //
        
        XDBGTRC("RECOVERY", "\n\nPlease eject and remove the recovery CD and then press any gamepad button to reboot...\n");

        DrawMessage(RStrings[RS_GAMEPAD_END_RETAIL], NULL, -1);
    }

    WaitForAnyButton(&dwVideoFlags, NULL);

    if (0xFFFFFFFF != dwVideoFlags)
    {
        //
        // Reset video flags before rebooting
        //

        ExSaveNonVolatileSetting(XC_FACTORY_AV_REGION, REG_DWORD, &dwVideoFlags, sizeof(dwVideoFlags));
    }

    XDBGWRN("RECOVERY", "Recovery completed successfully.");

    HalReturnToFirmware( HalRebootRoutine );
}

#endif // RECOVERYAPP

#ifdef DASHLIB

    //
    // Return zero to indicate success
    //

    return 0;
}

}
#endif // DASHLIB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\recovery\imagefile.cpp ===
#include "recovpch.h"
#include "imagefile.h"

//////////////////////////////////////////////////////////////////////
// .BMP File format functions

BitmapFile::BitmapFile() {
	xpos = 0;
	ypos = 0;

	// Initialize Bitmap File Header
	Type	  = 19778;
	FileSize  = 192056;	//check this
	Reserved1 = 0;
	Reserved2 = 0;
	OffBits	  = 54;	//check this

	// Initialize Bitmap Info Header
	InfoSize	  = 40;
	Width		  = 0;
	Height		  = 0;
	Planes		  = 1;
	BitCount	  = 24;
	Compression	  = 0;
	SizeImage	  = 0;
	XPelsPerMeter = 2834;
	YPelsPerMeter = 2834;
	ClrUsed		  = 0;
	ClrImportant  = 0;
}

BitmapFile::~BitmapFile() {
    if( pixels )
    {
	    delete [] pixels;
        pixels = NULL;
    }
}

void BitmapFile::write(char *file, int imageWidth, int imageHeight, DWORD *pixels) {
	FILE *output;

	Width     = imageWidth;
	Height	  = imageHeight;
	ImageSize = imageWidth * imageHeight;

	//open the new bitmap file
	output = fopen(file, "wb");

	// Write the Bitmap File header information
	fwrite(&Type, sizeof(WORD), 1, output);
	fwrite(&FileSize, sizeof(DWORD), 1, output);
	fwrite(&Reserved1, sizeof(WORD), 1, output);
	fwrite(&Reserved2, sizeof(WORD), 1, output);
	fwrite(&OffBits, sizeof(DWORD), 1, output);

	//Write the Bitmap Info header information
	fwrite(&InfoSize, sizeof(DWORD), 1, output);
	fwrite(&Width, sizeof(DWORD), 1, output);
	fwrite(&Height, sizeof(DWORD), 1, output);
	fwrite(&Planes, sizeof(WORD), 1, output);
	fwrite(&BitCount, sizeof(WORD), 1, output);
	fwrite(&Compression, sizeof(DWORD), 1, output);
	fwrite(&SizeImage, sizeof(DWORD), 1, output);
	fwrite(&XPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&YPelsPerMeter, sizeof(DWORD), 1, output);
	fwrite(&ClrUsed, sizeof(DWORD), 1, output);
	fwrite(&ClrImportant, sizeof(DWORD), 1, output);

	fclose(output);
}

int BitmapFile::imagesize(char *file) {
	FILE *input;
	input = fopen(file, "rb");

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);

	fclose(input);

	return (Width * Height);
}

void BitmapFile::read(int xloc, int yloc, char *file) {
	FILE *input;
	xpos = xloc;
	ypos = yloc;

	//open the new bitmap file
	input = fopen(file, "rb");
    if( !input )
    {
        XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::read():fopen failed!! - '%s'\n", file );
        return;
    }

	// Read the Bitmap File header information
	fread(&Type, sizeof(WORD), 1, input);
	fread(&FileSize, sizeof(DWORD), 1, input);
	fread(&Reserved1, sizeof(WORD), 1, input);
	fread(&Reserved2, sizeof(WORD), 1, input);
	fread(&OffBits, sizeof(DWORD), 1, input);

	//Read the Bitmap Info header information
	fread(&InfoSize, sizeof(DWORD), 1, input);
	fread(&Width, sizeof(DWORD), 1, input);
	fread(&Height, sizeof(DWORD), 1, input);
	fread(&Planes, sizeof(WORD), 1, input);
	fread(&BitCount, sizeof(WORD), 1, input);
	fread(&Compression, sizeof(DWORD), 1, input);
	fread(&SizeImage, sizeof(DWORD), 1, input);
	fread(&XPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&YPelsPerMeter, sizeof(DWORD), 1, input);
	fread(&ClrUsed, sizeof(DWORD), 1, input);
	fread(&ClrImportant, sizeof(DWORD), 1, input);

	ImageSize = Width * Height;
	pixels = new DWORD[ImageSize];

	float remainer = (float)Width / 4;
	float delta = remainer - (int)remainer;

	BYTE blue, green, red;
	for(int y = (int)Height - 1; y >= 0 ; y--)
	{
		for(int x = 0; x < (int)Width; x++)
		{
			fread(&blue, sizeof(BYTE), 1, input);
			fread(&green, sizeof(BYTE), 1, input);
			fread(&red, sizeof(BYTE), 1, input);
			int position = (y * (int)Width) + x;
			pixels[position] = (0xff << 24) | (red << 16) | (green << 8) | (blue);
		}
		
		//account for the extra bytes in bitmap files
		if(delta == 0.25f) fseek(input, 1, SEEK_CUR);
		else if(delta == 0.50f) fseek(input, 2, SEEK_CUR);
		else if(delta == 0.75f) fseek(input, 3, SEEK_CUR);
	}

	fclose(input);
}

bool BitmapFile::render(IDirect3DDevice8 *d3dDevice) {
	HRESULT hr;
	IDirect3DSurface8 *backBuffer;
	D3DLOCKED_RECT backBufferInfo;
	hr = d3dDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &backBuffer);
	if( FAILED( hr ))
	{
		XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::render():Failed to get the backbuffer\n" );
		return false;
	}

	RECT container;
	container.top = ypos;
	container.left = xpos;
	container.bottom = ypos + Height;
	container.right = xpos + Width;	

	hr = backBuffer->LockRect(&backBufferInfo, &container, D3DLOCK_TILED);
	if( FAILED( hr ))
	{
		XDBGWRN( APP_TITLE_NAME_A, "BitmapFile::render():Failed to lock the backbuffer\n" );
        backBuffer->Release();
		return false;
	}

	int destPitch = backBufferInfo.Pitch;
	int sourcePitch = Width * 4;
	BYTE *s = (BYTE*)pixels;
	BYTE *p = (BYTE*)backBufferInfo.pBits;
	for(int y = 0; y < (int)Height; y++)
	{
		memcpy(p, s, sourcePitch);
		s += sourcePitch;
		p += destPitch;
	}

	backBuffer->UnlockRect();
    backBuffer->Release();
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\recovery\flash.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    flash.c

Abstract:

    This module implements function used to program kernel image to flash
    ROM on EVT and DVT machine.

--*/

#include "recovpch.h"
#include <pci.h>


//
// Manufacturer and chip identifiers
//

#define SST_ID                  0xBF
#define SST_49LF040             0x53

#define AMD_ID                  0x01
#define FUJITSU_ID              0x04
#define HYUNDAI_ID              0xAD
#define GENERIC_29F080          0xD5

#define ST_ID                   0x20
#define M29F080A                0xF1

typedef enum {
    FlashUnknownDevice = 0,
    FlashSST49LF040,
    FlashGeneric29F080
} FlashDeviceID;

typedef enum {
    FlashStatusReady,
    FlashStatusBusy,
    FlashStatusEraseSuspended,
    FlashStatusTimeout,
    FlashStatusError
} FlashStatus;

//
// Mapped virtual address of ROM region
//

PVOID KernelRomBase;

// SIZE_T
// FlashSize(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro returns size of flash ROM specified by device identifier id
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Size of flash ROM for specified device
//
// --

#define FlashSize( ID )         FlashSizeMap[(ID)]

SIZE_T FlashSizeMap[] = {
    0,
    512 * 1024,     // SST 49LF040 Firmware Hub
    1024 * 1024     // Generic 29F080
};

// ULONG_PTR
// FlashBaseAddress(
//     IN FlashDeviceID ID
//     )
// ++
//
// Routine Description:
//
//     This macro calculates the base address of flash ROM specified by ID,
//     based on the size of the chip
//
// Arguments:
//
//     ID - Device identifier returned by FlashDetectDevice
//
// Return Value:
//
//     Base address of flash ROM from top 4GB
//
// --

#define FlashBaseAddress( ID )  ((ULONG_PTR)(0xFFFFFFFF-FlashSize(ID)+1))

//
// Lowest possible base address of flash ROM and region size
//

#define FLASH_BASE_ADDRESS      0xFFF00000
#define FLASH_REGION_SIZE       (0xFFFFFFFF-FLASH_BASE_ADDRESS-1)

// BYTE
// FlashReadByte(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads one byte from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     A read byte from specified address
//
// --

#define FlashReadByte(a) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

// VOID
// FlashWriteByte(
//     IN ULONG_PTR Physical,
//     IN BYTE Byte
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and writes one byte to mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
//     Byte - Data to be written to
//
// Return Value:
//
//     None
//
// --

#define FlashWriteByte(a, d) \
    (*(PBYTE)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS) = d)

// WORD
// FlashReadWord(
//     IN ULONG_PTR Physical
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and reads two bytes from mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
// Return Value:
//
//     Two byte from specified address
//
// --

#define FlashReadWord(a) \
    (*(PWORD)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS))

// VOID
// FlashWriteWord(
//     IN ULONG_PTR Physical,
//     IN WORD Word
//     )
// ++
//
// Routine Description:
//
//     This macro maps specified physical address of flash ROM into mapped
//     virtual address and writes two bytes to mapped address.
//
// Arguments:
//
//     Physical - Physical address of flash ROM to be read
//
//     Word - Data to be written to
//
// Return Value:
//
//     None
//
// --

#define FlashWriteWord(a, d) \
    (*(PWORD)((ULONG_PTR)KernelRomBase+(ULONG_PTR)(a)-FLASH_BASE_ADDRESS) = d)

FlashStatus
FlashGetStatus(
    IN FlashDeviceID ID,
    IN ULONG_PTR Address OPTIONAL,
    IN BYTE Data
    )
/*++

Routine Description:

    This routine checks status of flash chip using data# polling method.
    The data# polling bit, DQ7, indicates whether the Embeded Algorithm
    is in progress or completed.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    Address - Physical address of flash ROM to be checked

    Data - Expected data at specified address

Return Value:

    Status of flash chip, see the definition of FlashStatus above.

--*/
{
    UCHAR retry=1, d, t;

    if ( !ARGUMENT_PRESENT(Address) ) {
        Address = FlashBaseAddress( ID );
    }

    if ( ID == FlashSST49LF040 ) {

        //
        // SST doesn't support Exceeded Timing Limits, DQ5
        //

        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if ( t == d ) {
            return FlashStatusReady;
        } else {
            return FlashStatusBusy;
        }

    } else {

again:
        d = FlashReadByte(Address) & 0x80;
        t = Data & 0x80;

        if ( t == d ) {
            return FlashStatusReady;        // data matches
        } else if ( d & 0x20 ) {            // Timeout?
            d = FlashReadByte(Address) & 0x80;
            if ( t == d ) {
                return FlashStatusReady;    // data matches
            }
            if ( retry-- ) {
                goto again;                 // may have been write completion
            }
            return FlashStatusTimeout;
        }

        if ( retry-- ) {
            goto again;                     // may have been write completion
        } else {
            return FlashStatusError;
        }
    }
}

VOID
FlashResetDevice(
    VOID
    )
/*++

Routine Description:

    This routine resets flash ROM back to read mode if device is in ID command
    mode or during a program or erase operation

Arguments:

    None

Return Value:

    None

--*/
{
    FlashWriteByte( 0xFFFF5555, 0xAA );
    FlashWriteByte( 0xFFFF2AAA, 0x55 );
    FlashWriteByte( 0xFFFF5555, 0xF0 );
    KeStallExecutionProcessor( 150000 );
}

FlashDeviceID
FlashDetectDevice(
    VOID
    )
/*++

Routine Description:

    This routine detects the device and manufacturer id of flash device on
    the system.  The device on Xbus will be detected first and if no device
    detected, LPC bus will be next.

Arguments:

    None

Return Value:

    Type of flash id installed in the system or FlashUnknownDevice

--*/
{
    BYTE byte;
    BYTE id1=0, id2=0;
    BOOL FirstTime = TRUE;
    PCI_SLOT_NUMBER PCISlotNumber;
    PCI_COMMON_CONFIG Configuration;

detect:

    FlashWriteByte( 0xFFFF5555, 0xAA );
    FlashWriteByte( 0xFFFF2AAA, 0x55 );
    FlashWriteByte( 0xFFFF5555, 0x90 );

    KeStallExecutionProcessor( 1 );

    id1 = FlashReadByte( 0xFFFF0000 );
    id2 = FlashReadByte( 0xFFFF0001 );

    FlashResetDevice();

    if ( id1 == SST_ID && id2 == SST_49LF040 ) {
        return FlashSST49LF040;
    }

    if ( (id1 == AMD_ID || id1 == HYUNDAI_ID || id1 == FUJITSU_ID) && \
         id2 == GENERIC_29F080 ) {
        return FlashGeneric29F080;
    }

    if ( id1 == ST_ID && id2 == M29F080A ) {
        return FlashGeneric29F080;
    }

    if ( FirstTime == TRUE ) {

        //
        // We are here because we couldn't find any flash ROM on Xbus.
        // Next thing is to see if this is a EVT board and enable ROM
        // write bus cycle to LPC interface.  By default the write cycle
        // to ROM will drop.
        //

        FirstTime = FALSE;

        //
        // Looking for PCI-to-LPC bridge
        //

        for ( byte=0x00; byte<=0xff; byte++ ) {
            PCISlotNumber.u.AsULONG = byte;
            HalReadPCISpace( 0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration) );
            if ( Configuration.BaseClass == 6 && Configuration.SubClass == 1 ) {
                break;
            }
        }

        //
        // If it is Nvidia PCI-to-LPC bridge, enable LPC ROM write
        //

        if ( Configuration.VendorID == 0x10DE && Configuration.DeviceID == 0x01B2 ) {
            byte = 0x01;
            HalWritePCISpace( 0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte) );
            goto detect;
        }

    } else {

        //
        // If we still couldn't find any flash ROM on LPC bus, disable LPC
        // ROM write
        //

        byte = 0x00;
        HalWritePCISpace( 0, PCISlotNumber.u.AsULONG, 0x45, &byte, sizeof(byte) );
    }

    return FlashUnknownDevice;
}

BOOL
FlashEraseChip(
    FlashDeviceID ID
    )
/*++

Routine Description:

    This routine erase the content of entire flash ROM to 0xFF.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    ULONG_PTR FlashPtr;
    BOOL fBlank = FALSE;
    SIZE_T Count, Retries=5;

    while ( Retries-- ) {

        FlashWriteByte( 0xFFFF5555, 0xAA );
        FlashWriteByte( 0xFFFF2AAA, 0x55 );
        FlashWriteByte( 0xFFFF5555, 0x80 );
        FlashWriteByte( 0xFFFF5555, 0xAA );
        FlashWriteByte( 0xFFFF2AAA, 0x55 );
        FlashWriteByte( 0xFFFF5555, 0x10 );

        FlashPtr = ~0L;

        //
        // Wait until flash chip is ready and completely erased.
        //

        Count = 0x100000;
        while ( FlashGetStatus(ID, FlashPtr, 0xFF) != FlashStatusReady && Count ) {
            Count--;
        }

        //
        // For some reasons in the FIB DVT, even the flash status is
        // ready but the actual data is not written to the chip.
        // We just have to poll the actual data and spin for a while
        // if it didn't get through.
        //

        Count = 0x100000;
        while ( FlashReadByte(FlashPtr) != 0xFF && Count ) {
            KeStallExecutionProcessor( 150000 );
            Count--;
        }

        //
        // Perform a blank check by compare all the content with 0xFF
        //

        Count = FlashSize( ID );
        FlashResetDevice();
        FlashPtr = FlashBaseAddress( ID );

        ASSERTMSG( "Size of flash ROM must be power of two", (Count & (Count-1)) == 0 );

        while ( Count ) {
            if ( FlashReadWord(FlashPtr) != 0xFFFF ) {
                DbgPrint( "FLASH: blank check failed (retries=%d)\n", Retries );
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if ( Count == 0 ) {
            fBlank = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fBlank;
}

BOOL
FlashProgramImage(
    IN FlashDeviceID ID,
    IN PVOID ImageBuffer
    )
/*++

Routine Description:

    This routine programs the content of flash ROM with new image.  The flash
    ROM has to be blank first before programming.

Arguments:

    ID - Device identifier returned by FlashDetectDevice

    ImageBuffer - Buffer contains the content to be programmed

Return Value:

    TRUE if operation success, FALSE otherwise

--*/
{
    BYTE b;
    PBYTE pb;
    PWORD pw;
    ULONG TimeOut;
    ULONG_PTR FlashPtr;
    BYTE TrueData, CurrData;
    BOOL Loop, fSuccess = FALSE;
    SIZE_T Count, Retries = 5;
    SIZE_T Again;

    while ( Retries-- ) {

        Count = FlashSize( ID );
        pb = (PBYTE)ImageBuffer;
        FlashPtr = FlashBaseAddress( ID );

        while ( Count-- ) {

            b = *pb++;

            if ( b != 0xFF ) {
                FlashWriteByte( 0xFFFF5555, 0xAA );
                FlashWriteByte( 0xFFFF2AAA, 0x55 );
                FlashWriteByte( 0xFFFF5555, 0xA0 );
                FlashWriteByte( FlashPtr, b );

                //
                // Wait until flash chip is ready for next command
                //

                Again = 0x100000;
                while ( FlashGetStatus(ID, FlashPtr, b) != FlashStatusReady && Again ) {
                    Again--;
                }

                //
                // For some reasons in the FIB DVT, even the flash status is
                // ready but the actual data is not written to the chip.
                // We just have to poll the actual data and spin for a while
                // if it didn't get through.
                //

                Again = 0x100000;
                while ( FlashReadByte(FlashPtr) != b && Again ) {
                    Again--;
                }
            }

            FlashPtr++;
        }

        //
        // Verify the content that just has been programmed
        //

        Count = FlashSize( ID );
        pw = (PWORD)ImageBuffer;
        FlashPtr = FlashBaseAddress( ID );
        FlashResetDevice();

        while ( Count ) {
            if ( FlashReadWord(FlashPtr) != *pw++ ) {
                DbgPrint( "FLASH: verification failed (retries=%d)\n", Retries );
                break;
            }

            Count -= sizeof(WORD);
            FlashPtr += sizeof(WORD);
        }

        if ( Count == 0 ) {
            fSuccess = TRUE;
            break;
        }

        FlashResetDevice();
    }

    return fSuccess;
}

UINT64
FASTCALL
FlashReadMSR(
    IN ULONG Address
    )
/*++

Routine Description:

    This routine reads Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

Return Value:

    64-bit value of specified MSR

--*/
{
    __asm {
        rdmsr
    }
}

VOID
FASTCALL
FlashWriteMSR(
    IN ULONG Address,
    IN UINT64 Value
    )
/*++

Routine Description:

    This routine writes Pentium III Model-Specific Register (MSR) specified
    by Address

Arguments:

    Address - Register address to read

    Value - 64-bit value to be written

Return Value:

    None

--*/
{
    __asm {
        mov     eax, DWORD PTR [Value]
        mov     edx, DWORD PTR [Value+4]
        wrmsr
    }
}

#ifdef FLASH_TIME

UINT64
FlashReadTSC(
    VOID
    )
/*++

Routine Description:

    This routine reads processor's time-stamp counter.  The time-stamp counter
    is contained in a 64-bit MSR.  The high-order of 32 bits MSR are loaded
    into the EDX register, and the low-order 32 bits are loaded into the EAX
    register.  The processor increments the time-stamp counter MSR every
    clock cycle and resets it to 0 whenever the processor reset.

Arguments:

    None

Return Value:

    64-bit MSR of time-stamp counter

--*/
{
    __asm {
        rdtsc
    }
}

#endif // FLASH_TIME

VOID
FlashChangeRomCaching(
    BOOL EnableCache
    )
/*++

Routine Description:

    This routine searches for ROM cache setting in MTRR and disable it.  It is
    necessary to disable and flash cache before changing MTRR.  The following
    steps are recommended by Intel in order to change MTRR settings. Save CR4,
    disable and flush processor cache, flush TLB, disable MTRR, change MTRR
    settings, flush cache and TLB, enable MTRR and restore CR4

Arguments:

    EnableCache - TRUE to enable caching, FALSE to disable

Return Value:

    None

--*/
{
    ULONG MTRR;
    UINT64 v, MTRRdeftype;
    ULONG Base, Type;


    __asm {
        push    ecx
        push    edx

        _emit   0fh                 ; mov  eax, cr4
        _emit   20h
        _emit   0e0h

        push    eax                 ; save content of cr4

        mov     eax, cr0            ; disable and flush cache
        push    eax                 ; save content of cr0
        or      eax, 060000000H
        mov     cr0, eax
        wbinvd

        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Save the content of MTRR deftype and disable MTRR
    //

    MTRRdeftype = FlashReadMSR( 0x2FF );
    FlashWriteMSR( 0x2FF, 0 );

    for ( MTRR=0x200; MTRR<0x20F; MTRR+=2 ) {
        v = FlashReadMSR( MTRR );
        Base = (ULONG)((v >> 12) & 0xFFFFFF);
        Type = (BYTE)v;

        //
        // Set or reset valid bit according to cache enable flag
        //

        if ( Base >= (FLASH_BASE_ADDRESS >> 12) && Type != 0 ) {
            v = FlashReadMSR( MTRR+1 );
            v = EnableCache ? (v | 0x800) : (v & (~0x800));
            FlashWriteMSR( MTRR+1, v );
        }
    }

    __asm {
        wbinvd                      ; flush cache
        mov     eax, cr3            ; flush TLB
        mov     cr3, eax
    }

    //
    // Restore content of MTRR deftype, MTRR should be re-enabled
    //

    FlashWriteMSR( 0x2FF, MTRRdeftype );

    __asm {
        pop     eax                 ; restore cr0
        mov     cr0, eax

        pop     eax                 ; restore cr4

        _emit   0fh                 ; mov  cr4, eax
        _emit   22h
        _emit   0e0h

        pop     edx
        pop     ecx
    }
}

HRESULT
FlashKernelImage(
    IN  PVOID  ImageBuffer,
    IN  SIZE_T ImageSize,
    OUT LPSTR  szResp,
    IN  DWORD  cchResp
    )
{
#ifdef FLASH_TIME
    UINT64 ClockTick;
#endif

    FlashDeviceID ID;
    HRESULT hr = S_OK;

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC();
#endif

    if ( IsBadReadPtr(ImageBuffer, ImageSize) || \
         IsBadWritePtr(szResp, cchResp) ) {
        return HRESULT_FROM_WIN32( ERROR_NOACCESS );
    }

    //
    // Map top 1MB of physical memory of ROM region (FFF00000-FFFFFFFF)
    //

    KernelRomBase = MmMapIoSpace( FLASH_BASE_ADDRESS, FLASH_REGION_SIZE,
                                  PAGE_READWRITE | PAGE_NOCACHE );

    if ( !KernelRomBase ) {
        _snprintf( szResp, cchResp, "unable to map i/o space" );
        return E_FAIL;
    }

    __asm cli

    XDBGWRN("RECOVERY", "FLASH: interrupts are now disabled" );

    //
    // Disable ROM caching
    //

    FlashChangeRomCaching( FALSE );

    ID = FlashDetectDevice();

    if ( ID == FlashUnknownDevice ) {
        _snprintf( szResp, cchResp, "Unknown flash device id" );
        hr = E_FAIL;
        goto cleanup;
    }

    if ( FlashSize(ID) != ImageSize ) {
        _snprintf( szResp, cchResp, "Invalid image size" );
        hr = E_FAIL;
        goto cleanup;
    }

    XDBGWRN("RECOVERY", "FLASH: erasing and blank checking..." );

    if ( !FlashEraseChip(ID) ) {
        _snprintf( szResp, cchResp, "Failed to erase flash chip" );
        hr = E_FAIL;
        goto cleanup;
    }

    XDBGWRN("RECOVERY", "FLASH: programming..." );

    if ( !FlashProgramImage(ID, ImageBuffer) ) {
        _snprintf( szResp, cchResp, "Failed to program kernel image (verify failed)" );
        hr = E_FAIL;
        goto cleanup;
    }

    XDBGWRN("RECOVERY", "FLASH: done" );

    if ( SUCCEEDED(hr) ) {
        _snprintf( szResp, cchResp, "Done, new image flashed" );
    }

    hr = S_OK;

cleanup:

    __asm sti

    XDBGWRN("RECOVERY", "FLASH: interrupts are now enabled" );

    MmUnmapIoSpace( KernelRomBase, FLASH_REGION_SIZE );

    //
    // Re-enable ROM caching as needed
    //

    FlashChangeRomCaching( TRUE );

#ifdef FLASH_TIME
    ClockTick = FlashReadTSC() - ClockTick;
    DbgPrint( "FLASH: elapsed time %I64u seconds\n", ClockTick / 733000000UI64 );
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\recovery\xboxvideo.h ===
/*****************************************************
*** xboxvideo.h
***
*** Header file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#ifndef _XBOXVIDEO_H_
#define _XBOXVIDEO_H_

#include "constants.h"

// Macros
#define CHECK(code) do { int _ret__; _ret__ = code; if(_ret__ != D3D_OK) XDBGWRN( APP_TITLE_NAME_A, #code "File %s Line %d, Failed: %d", __LINE__, __FILE__, _ret__); } while (0);

#define NUM_VB_VERTS            100

// XBox configuration
class CXBoxVideo
{
public:
    // Constructors and Destructors
    CXBoxVideo( void );
    ~CXBoxVideo( void );

    // Public Properties

    // Public Methods
    void Initialize( int width,                         // Initialize D3D for this screen -- height and width default
                     int height );
    
    void DeInitialize( void );                          // Free our objects
    void ClearScreen( DWORD color );                    // Clear the current screen
    
    void DrawBox( float x1,                             // Draw a box on the screen
                  float y1,
                  float x2,
                  float y2,
                  DWORD color );

    void DrawBitBlt( float fx,                          // Draw the inputed bit array to the screen
                     float fy,
                     ULONG ulWidth,
                     ULONG ulHeight,
                     const DWORD* pData );
    
    void DrawClearRect( float x1,                       // Draw a clear rectangle to the screen
                        float y1,
                        float x2,
                        float y2,
                        DWORD color );

    HRESULT DrawLine( float x1,                         // Draw a line on the screen
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    void DrawOutline( float x1,                         // Draw an outline at the current location with a specific border size
                      float y1,
                      float x2,
                      float y2,
                      float fLineWidth,
                      DWORD color );

    int DrawText( float x1,                             // Prints formatted text, using the default font size and color
                  float y1,
                  DWORD fgcolor,
                  DWORD bgcolor,
                  const TCHAR* format,
                  ... );

    int GetStringPixelWidth( IN LPCWSTR string,         // Get the pixel width of a string
                             IN int length = -1 );

    int GetStringPixelWidth( IN char* string,           // Get the pixel width of a char*
                             IN int length /*=-1*/ ); 

    void GetFontSize( unsigned int* pheight,            // Get the size of the currently selected font
                      unsigned int* pdecent );

    void LightenImage( int nWidth,                      // Lighten the image specified by "pBits"
                       int nHeight,
                       DWORD* pBits,
                       DWORD dwAddto );
    void DarkenImage( int nWidth,                       // Darken the image specified by "pBits"
                      int nHeight,
                      DWORD* pBits,
                      DWORD dwSubtract );

    HRESULT TruncateStringToFit( char* pString,         // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    HRESULT TruncateStringToFit( WCHAR* pString,        // Truncate a string to fit within a certain screen size
                                 unsigned int nStrSize,
                                 float x1,
                                 float x2 );

    IDirect3DDevice8* GetD3DDevicePtr() { return m_Device; }; // Return the D3DDevice pointer to the caller

    void ShowScreen();                                  // Display the current backbuffer on the screen

    HRESULT GetTransform( D3DTRANSFORMSTATETYPE State,  // Get the D3D Transform
                          D3DMATRIX* pMatrix );         // Set the D3D Transform

    HRESULT SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix );

    HRESULT SetVertexShader( DWORD Handle );            // Set the D3D Vertex Shader
    HRESULT GetVertexShader( DWORD* pHandle );          // Get the D3D Vertex Shader



private:
    // Vertext structure
    struct MYVERTEX
    {
	    D3DXVECTOR3 v;
	    float       fRHW;
	    D3DCOLOR    cDiffuse;
    };

    // Private Properties
    IDirect3DDevice8* m_Device;
    IDirect3DSurface8* m_BackBuffer;
    IDirect3DVertexBuffer8* m_VertexBuffer;
    int m_ScreenWidth; 
    int m_ScreenHeight;
    
    // Font Properties
    XFONT* m_Font;
    float m_FontWidth;
    float m_FontHeight;
    DWORD m_FontColor;
    DWORD m_FontBgColor;

    // Private Methods
};

#endif // _XBOXVIDEO_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\cnvint.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    cnvint.c

Abstract:

    Text to integer and integer to text converion routines.

Author:

    Steve Wood (stevewo) 23-Aug-1990

Revision History:

--*/

#include <ntrtlp.h>

const CHAR RtlpIntegerChars[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                                 '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

const WCHAR RtlpIntegerWChars[] = { L'0', L'1', L'2', L'3', L'4', L'5',
                                    L'6', L'7', L'8', L'9', L'A', L'B',
                                    L'C', L'D', L'E', L'F' };

NTSTATUS
RtlIntegerToChar (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR Result[ 33 ], *s;
    ULONG Shift, Mask, Digit, Length;

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:    Base = 10;
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
        }

    s = &Result[ 32 ];
    *s = '\0';
    do {
        if (Shift != 0) {
            Digit = Value & Mask;
            Value >>= Shift;
            }
        else {
            Digit = Value % Base;
            Value = Value / Base;
            }

        *--s = RtlpIntegerChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG) (&Result[ 32 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = '0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlMoveMemory( String, s, Length );

            if ((LONG)Length < OutputLength) {
                String[ Length ] = '\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}


NTSTATUS
RtlCharToInteger (
    IN PCSZ String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    CHAR c, Sign;
    ULONG Result, Digit, Shift;

    while ((Sign = *String++) <= ' ') {
        if (!*String) {
            String--;
            break;
            }
        }

    c = Sign;
    if (c == '-' || c == '+') {
        c = *String++;
        }

    if (!ARGUMENT_PRESENT( (ULONG_PTR)(Base) )) {
        Base = 10;
        Shift = 0;
        if (c == '0') {
            c = *String++;
            if (c == 'x') {
                Base = 16;
                Shift = 4;
                }
            else
            if (c == 'o') {
                Base = 8;
                Shift = 3;
                }
            else
            if (c == 'b') {
                Base = 2;
                Shift = 1;
                }
            else {
                String--;
                }

            c = *String++;
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( STATUS_INVALID_PARAMETER );
            }
        }

    Result = 0;
    while (c) {
        if (c >= '0' && c <= '9') {
            Digit = c - '0';
            }
        else
        if (c >= 'A' && c <= 'F') {
            Digit = c - 'A' + 10;
            }
        else
        if (c >= 'a' && c <= 'f') {
            Digit = c - 'a' + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        c = *String++;
        }

    if (Sign == '-') {
        Result = (ULONG)(-(LONG)Result);
        }

    try {
        *Value = Result;
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        return( GetExceptionCode() );
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlUnicodeStringToInteger (
    IN PUNICODE_STRING String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    PCWSTR s;
    WCHAR c, Sign;
    ULONG nChars, Result, Digit, Shift;

    s = String->Buffer;
    nChars = String->Length / sizeof( WCHAR );
    while (nChars-- && (Sign = *s++) <= ' ') {
        if (!nChars) {
            Sign = UNICODE_NULL;
            break;
            }
        }

    c = Sign;
    if (c == L'-' || c == L'+') {
        if (nChars) {
            nChars--;
            c = *s++;
            }
        else {
            c = UNICODE_NULL;
            }
        }

    if (!ARGUMENT_PRESENT( (ULONG_PTR)Base )) {
        Base = 10;
        Shift = 0;
        if (c == L'0') {
            if (nChars) {
                nChars--;
                c = *s++;
                if (c == L'x') {
                    Base = 16;
                    Shift = 4;
                    }
                else
                if (c == L'o') {
                    Base = 8;
                    Shift = 3;
                    }
                else
                if (c == L'b') {
                    Base = 2;
                    Shift = 1;
                    }
                else {
                    nChars++;
                    s--;
                    }
                }

            if (nChars) {
                nChars--;
                c = *s++;
                }
            else {
                c = UNICODE_NULL;
                }
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return( STATUS_INVALID_PARAMETER );
            }
        }

    Result = 0;
    while (c != UNICODE_NULL) {
        if (c >= L'0' && c <= L'9') {
            Digit = c - L'0';
            }
        else
        if (c >= L'A' && c <= L'F') {
            Digit = c - L'A' + 10;
            }
        else
        if (c >= L'a' && c <= L'f') {
            Digit = c - L'a' + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        if (!nChars) {
            break;
            }
        nChars--;
        c = *s++;
        }

    if (Sign == L'-') {
        Result = (ULONG)(-(LONG)Result);
        }

    try {
        *Value = Result;
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        return( GetExceptionCode() );
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlIntegerToUnicode (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR Result[ 33 ], *s;
    ULONG Shift, Mask, Digit, Length;

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:    Base = 10;
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
        }

    s = &Result[ 32 ];
    *s = L'\0';
    do {
        if (Shift != 0) {
            Digit = Value & Mask;
            Value >>= Shift;
            }
        else {
            Digit = Value % Base;
            Value = Value / Base;
            }

        *--s = RtlpIntegerWChars[ Digit ];
    } while (Value != 0);

    Length = (ULONG) (&Result[ 32 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = L'0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlMoveMemory( String, s, Length * sizeof( WCHAR ));

            if ((LONG)Length < OutputLength) {
                String[ Length ] = L'\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}


NTSTATUS
RtlIntegerToUnicodeString (
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    )
{
    NTSTATUS Status;
    UCHAR ResultBuffer[ 16 ];
    ANSI_STRING AnsiString;

    Status = RtlIntegerToChar( Value, Base, sizeof( ResultBuffer ), ResultBuffer );
    if (NT_SUCCESS( Status )) {
        AnsiString.Buffer = ResultBuffer;
        AnsiString.MaximumLength = sizeof( ResultBuffer );
        AnsiString.Length = (USHORT)strlen( ResultBuffer );
        Status = RtlAnsiStringToUnicodeString( String, &AnsiString, FALSE );
        }

    return( Status );
}


NTSTATUS
RtlLargeIntegerToChar (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PSZ String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    CHAR Result[ 100 ], *s;
    ULONG Shift, Mask, Digit, Length;

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
        }

    s = &Result[ 99 ];
    *s = '\0';
    if (Shift != 0) {
        ULONG LowValue,HighValue,HighShift,HighMask;

        LowValue = Value->LowPart;
        HighValue = Value->HighPart;
        HighShift = Shift - (sizeof(ULONG) % Shift);
        HighMask = 0xF >> (4 - HighShift);
        do {
            Digit = LowValue & Mask;
            LowValue = (LowValue >> Shift) | ((HighValue & HighMask) << (sizeof(ULONG) - HighShift));
            HighValue = HighValue >> HighShift;
            *--s = RtlpIntegerChars[ Digit ];
        } while ((LowValue | HighValue) != 0);
    } else {
        LARGE_INTEGER TempValue=*Value;
        do {
            TempValue = RtlExtendedLargeIntegerDivide(TempValue,Base,&Digit);
            *--s = RtlpIntegerChars[ Digit ];
        } while (TempValue.HighPart != 0 || TempValue.LowPart != 0);
    }

    Length = (ULONG)(&Result[ 99 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = '0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlMoveMemory( String, s, Length );

            if ((LONG)Length < OutputLength) {
                String[ Length ] = '\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}

NTSTATUS
RtlLargeIntegerToUnicode (
    IN PLARGE_INTEGER Value,
    IN ULONG Base OPTIONAL,
    IN LONG OutputLength,
    OUT PWSTR String
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    WCHAR Result[ 100 ], *s;
    ULONG Shift, Mask, Digit, Length;

    Shift = 0;
    switch( Base ) {
        case 16:    Shift = 4;  break;
        case  8:    Shift = 3;  break;
        case  2:    Shift = 1;  break;

        case  0:
        case 10:    Shift = 0;  break;
        default:    return( STATUS_INVALID_PARAMETER );
        }

    if (Shift != 0) {
        Mask = 0xF >> (4 - Shift);
        }

    s = &Result[ 99 ];
    *s = L'\0';
    if (Shift != 0) {
        ULONG LowValue,HighValue,HighShift,HighMask;

        LowValue = Value->LowPart;
        HighValue = Value->HighPart;
        HighShift = Shift - (sizeof(ULONG) % Shift);
        HighMask = 0xF >> (4 - HighShift);
        do {
            Digit = LowValue & Mask;
            LowValue = (LowValue >> Shift) | ((HighValue & HighMask) << (sizeof(ULONG) - HighShift));
            HighValue = HighValue >> HighShift;
            *--s = RtlpIntegerWChars[ Digit ];
        } while ((LowValue | HighValue) != 0);
    } else {
        LARGE_INTEGER TempValue=*Value;
        do {
            TempValue = RtlExtendedLargeIntegerDivide(TempValue,Base,&Digit);
            *--s = RtlpIntegerWChars[ Digit ];
        } while (TempValue.HighPart != 0 || TempValue.LowPart != 0);
    }

    Length = (ULONG)(&Result[ 99 ] - s);
    if (OutputLength < 0) {
        OutputLength = -OutputLength;
        while ((LONG)Length < OutputLength) {
            *--s = L'0';
            Length++;
            }
        }

    if ((LONG)Length > OutputLength) {
        return( STATUS_BUFFER_OVERFLOW );
        }
    else {
        try {
            RtlMoveMemory( String, s, Length * sizeof( WCHAR ));

            if ((LONG)Length < OutputLength) {
                String[ Length ] = L'\0';
                }
            }
        except( EXCEPTION_EXECUTE_HANDLER ) {
            return( GetExceptionCode() );
            }

        return( STATUS_SUCCESS );
        }
}

NTSTATUS
RtlInt64ToUnicodeString (
    IN ULONGLONG Value,
    IN ULONG Base OPTIONAL,
    IN OUT PUNICODE_STRING String
    )

{

    NTSTATUS Status;
    UCHAR ResultBuffer[32];
    ANSI_STRING AnsiString;
    LARGE_INTEGER Temp;

    Temp.QuadPart = Value;
    Status = RtlLargeIntegerToChar(&Temp,
                                   Base,
                                   sizeof(ResultBuffer),
                                   ResultBuffer);

    if (NT_SUCCESS(Status)) {
        AnsiString.Buffer = ResultBuffer;
        AnsiString.MaximumLength = sizeof(ResultBuffer);
        AnsiString.Length = (USHORT)strlen(ResultBuffer);
        Status = RtlAnsiStringToUnicodeString(String, &AnsiString, FALSE);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\error.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    error.c

Abstract:

    This module contains a routine for converting NT status codes
    to DOS/OS|2 error codes.

Author:

    David Treadwell (davidtr)   04-Apr-1991

Revision History:

--*/

#include <ntrtlp.h>
#include "winerror.h"
#include "error.h"

//
// Ensure that the Registry ERROR_SUCCESS error code and the
// NO_ERROR error code remain equal and zero.
//

#if ERROR_SUCCESS != 0 || NO_ERROR != 0
#error Invalid value for ERROR_SUCCESS.
#endif

ULONG
RtlNtStatusToDosError (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine converts an NT status code to its DOS/OS 2 equivalent
    and returns the translated value.

Arguments:

    Status - Supplies the status value to convert.

Return Value:

    The matching DOS/OS 2 error code.

--*/

{

    ULONG Offset;
    ULONG Entry;
    ULONG Index;

    //
    // Convert any HRESULTs to their original form of a NTSTATUS or a
    // WIN32 error
    //


    if (Status & 0x20000000) {

        //
        // The customer bit is set so lets just pass the
        // error code on thru
        //

        return Status;

    }
    else if ((Status & 0xffff0000) == 0x80070000) {

        //
        // The status code  was a win32 error already.
        //

        return(Status & 0x0000ffff);
    }
    else if ((Status & 0xf0000000) == 0xd0000000) {

        //
        // The status code is a HRESULT from NTSTATUS
        //

        Status &= 0xcfffffff;
    }

    //
    // Scan the run length table and compute the entry in the translation
    // table that maps the specified status code to a DOS error code.
    //

    Entry = 0;
    Index = 0;
    do {
        if ((ULONG)Status >= RtlpRunTable[Entry + 1].BaseCode) {
            Index += (RtlpRunTable[Entry].RunLength * RtlpRunTable[Entry].CodeSize);

        } else {
            Offset = (ULONG)Status - RtlpRunTable[Entry].BaseCode;
            if (Offset >= RtlpRunTable[Entry].RunLength) {
                break;

            } else {
                Index += (Offset * (ULONG)RtlpRunTable[Entry].CodeSize);
                if (RtlpRunTable[Entry].CodeSize == 1) {
                    return (ULONG)RtlpStatusTable[Index];

                } else {
                    return (((ULONG)RtlpStatusTable[Index + 1] << 16) |
                                                (ULONG)RtlpStatusTable[Index]);
                }
            }
        }

        Entry += 1;
    } while (Entry < (sizeof(RtlpRunTable) / sizeof(RUN_ENTRY)));

    //
    // The translation to a DOS error code failed.
    //
    // The redirector maps unknown OS/2 error codes by ORing 0xC001 into
    // the high 16 bits.  Detect this and return the low 16 bits if true.
    //

    if (((ULONG)Status >> 16) == 0xC001) {
        return ((ULONG)Status & 0xFFFF);
    }

#ifndef NTOS_KERNEL_RUNTIME
    DbgPrint("RTL: RtlNtStatusToDosError(0x%lx): No Valid Win32 Error Mapping\n",Status);
    DbgPrint("RTL: Edit ntos\\rtl\\generr.c to correct the problem\n");
    DbgPrint("RTL: ERROR_MR_MID_NOT_FOUND is being returned\n");

#if DBG
    DbgBreakPoint();
#endif // DBG

#endif // NTOS_KERNEL_RUNTIME

    return ERROR_MR_MID_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\debug.c ===
//      TITLE("Debug Support Functions")
//++
//
// Copyright (c) 1990  Microsoft Corporation
//
// Module Name:
//
//    debug.c
//
// Abstract:
//
//    This module implements functions to support debugging NT.  They call
//    architecture specific routines to do the actual work.
//
// Author:
//
//    Steven R. Wood (stevewo) 8-Nov-1994
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//--

#include "stdarg.h"
#include "stdio.h"
#include "ntrtlp.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include <ntdbg.h>


ULONG
DbgPrint(
    PCHAR Format,
    ...
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    Format     - printf style format string
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{
    va_list arglist;
    UCHAR Buffer[512];
    int cb;
    STRING Output;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);

    cb = _vsnprintf(Buffer, sizeof(Buffer), Format, arglist);

    va_end(arglist);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (cb == -1) {             // detect buffer overflow
        cb = sizeof(Buffer);
        Buffer[sizeof(Buffer) - 1] = '\n';
    }
    Output.Buffer = Buffer;
    Output.Length = (USHORT) cb;

    //
    // If APP is being debugged, raise an exception and the debugger
    // will catch and handle this. Otherwise, kernel debugger service
    // is called.
    //

    Status = DebugPrint( &Output );
    if (Status == STATUS_BREAKPOINT) {
        DbgBreakPointWithStatus(DBG_STATUS_CONTROL_C);
        Status = STATUS_SUCCESS;
    }
    return Status;
}

ULONG
DbgPrompt(
    IN PCHAR Prompt,
    OUT PCHAR Response,
    IN ULONG MaximumResponseLength
    )

//++
//
// Routine Description:
//
//    This function displays the prompt string on the debugging console and
//    then reads a line of text from the debugging console.  The line read
//    is returned in the memory pointed to by the second parameter.  The
//    third parameter specifies the maximum number of characters that can
//    be stored in the response area.
//
// Arguments:
//
//    Prompt - specifies the text to display as the prompt.
//
//    Response - specifies where to store the response read from the
//       debugging console.
//
//    Prompt - specifies the maximum number of characters that can be
//       stored in the Response buffer.
//
// Return Value:
//
//    Number of characters stored in the Response buffer.  Includes the
//    terminating newline character, but not the null character after
//    that.
//
//--

{

    STRING Input;
    STRING Output;

    //
    // Output the prompt string and read input.
    //

    Input.MaximumLength = (USHORT)MaximumResponseLength;
    Input.Buffer = Response;
    Output.Length = (USHORT)strlen( Prompt );
    Output.Buffer = Prompt;
    return DebugPrompt( &Output, &Input );
}

#if defined(NTOS_KERNEL_RUNTIME) || defined(BLDR_KERNEL_RUNTIME)


VOID
DbgLoadImageSymbols(
    IN PSTRING FileName,
    IN PVOID ImageBase,
    IN ULONG_PTR ProcessId
    )

//++
//
// Routine Description:
//
//    Tells the debugger about newly loaded symbols.
//
// Arguments:
//
// Return Value:
//
//--

{

    PIMAGE_NT_HEADERS NtHeaders;
    KD_SYMBOLS_INFO SymbolInfo;

    SymbolInfo.BaseOfDll = ImageBase;
    SymbolInfo.ProcessId = ProcessId;
    NtHeaders = RtlImageNtHeader( ImageBase );
    if (NtHeaders != NULL) {
        SymbolInfo.CheckSum = (ULONG)NtHeaders->OptionalHeader.CheckSum;
        SymbolInfo.SizeOfImage = (ULONG)NtHeaders->OptionalHeader.SizeOfImage;
    } else {
        SymbolInfo.SizeOfImage = 0;
        SymbolInfo.CheckSum    = 0;
    }

    DebugLoadImageSymbols( FileName, &SymbolInfo);

    return;
}


VOID
DbgUnLoadImageSymbols (
    IN PSTRING FileName,
    IN PVOID ImageBase,
    IN ULONG_PTR ProcessId
    )

//++
//
// Routine Description:
//
//    Tells the debugger about newly unloaded symbols.
//
// Arguments:
//
// Return Value:
//
//--

{
    KD_SYMBOLS_INFO SymbolInfo;

    SymbolInfo.BaseOfDll = ImageBase;
    SymbolInfo.ProcessId = ProcessId;
    SymbolInfo.CheckSum    = 0;
    SymbolInfo.SizeOfImage = 0;

    DebugUnLoadImageSymbols( FileName, &SymbolInfo );

    return;
}

#endif // defined(NTOS_KERNEL_RUNTIME)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\recovery\xboxvideo.cpp ===
/*****************************************************
*** xboxvideo.cpp
***
*** CPP file for our xboxvideo class.  This class
*** will initial D3D graphics, and allow the user to
*** draw text or graphics to the screen.
*** 
*** by James N. Helm
*** November 1st, 2000
*** 
*****************************************************/

#include "recovpch.h"
#include "xboxvideo.h"

// Constructor
CXBoxVideo::CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::CXBoxVideo()" );

    m_Device = NULL;
    m_BackBuffer = NULL;
    m_VertexBuffer = NULL;

    // Font properties
    m_Font = NULL;
    m_FontWidth = FONT_DEFAULT_WIDTH;
    m_FontHeight = FONT_DEFAULT_HEIGHT;
    m_FontColor = SCREEN_DEFAULT_TEXT_FG_COLOR;
    m_FontBgColor = SCREEN_DEFAULT_TEXT_BG_COLOR;

    m_ScreenWidth = SCREEN_WIDTH;       // Default the screen width to 640
    m_ScreenHeight = SCREEN_HEIGHT;     // Default the screen height to 480
}

// Destructor
CXBoxVideo::~CXBoxVideo( void )
{
    XDBGTRC( APP_TITLE_NAME_A, "CXBoxVideo::~CXBoxVideo()" );

    if( m_Device )
    {
        m_Device->Release();
        m_Device = NULL;
    }
    
    if( m_BackBuffer )
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_VertexBuffer )
    {
        m_VertexBuffer->Release();
        m_VertexBuffer = NULL;
    }
}

// Clear the screen
void CXBoxVideo::ClearScreen( DWORD color )
{
    if( FAILED( m_Device->Clear( 0, NULL, D3DCLEAR_TARGET, color, 1.0f, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXboxVideo::ClearScreen():Failed to clear the screen!!" );
    }
}


// Draw the inputed bit array to the screen
//
// Parameters:
//      fx - the upper left x coordinate on screen
//      fy - the upper left y coordinate on screen
//      ulWidth - the width of the bitmap
//      ulHeight - the height of the bitmap
//      pData - a pointer to the array of pixel values
void CXBoxVideo::DrawBitBlt( float fx, float fy, ULONG ulWidth, ULONG ulHeight, const DWORD* pData )
{
    // Check to make sure we received a valid pointer
    if( !pData )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawBitBlt():pData not a valid pointer!" );

        return;
    }

    // Draw the bitmap on the screen, pixel by pixel
	for ( ULONG y = 0; y < ulHeight; y++ )
	{
		for ( ULONG x = 0; x < ulWidth; x++ )
		{
			if ( 0 != pData[y * ulWidth + x] )
			{
				DrawLine( fx + x, fy + y, fx + x, fy + y, 1.0f, pData[y * ulWidth + x] );
			}
		}
	}
}

// Draw a box on the screen
void CXBoxVideo::DrawBox( float x1, float y1, float x2, float y2, DWORD color )
{
	MYVERTEX* pb;
	float maxx, minx;
	float maxy, miny;

	CHECK( m_Device->BeginScene() );
	CHECK( m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * 4, (BYTE**)&pb, 0 ) );
	
	if( IsBadWritePtr( pb, 128 ) )
	{
		XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawBox(): Lockreturned '%p', which is BAD!", pb );

		return;
	}

	if( x1 < x2 )
    {
		minx = x1;
		maxx = x2;
	}
    else
    {
		minx = x2;
		maxx = x1;
	}

	if( y1 < y2 )
    {
		miny = y1;
		maxy = y2;
	}
    else
    {
		miny = y2;
		maxy = y1;
	}

	if( x1 == x2 )
    {
		maxx++;
	}

	pb[0].v.x = minx; pb[0].v.y = miny; pb[0].v.z = .1f; pb[0].fRHW = .9f; pb[0].cDiffuse = color;
	pb[1].v.x = maxx; pb[1].v.y = miny; pb[1].v.z = .1f; pb[1].fRHW = .9f; pb[1].cDiffuse = color;
	pb[2].v.x = maxx; pb[2].v.y = maxy; pb[2].v.z = .1f; pb[2].fRHW = .9f; pb[2].cDiffuse = color;
	pb[3].v.x = minx; pb[3].v.y = maxy; pb[3].v.z = .1f; pb[3].fRHW = .9f; pb[3].cDiffuse = color;

	m_VertexBuffer->Unlock();

	m_Device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);
	m_Device->EndScene();
}


// Draw a clear rectangle to the screen
void CXBoxVideo::DrawClearRect( float x1, float y1, float x2, float y2, DWORD color ) 
{
	D3DRECT rect;

	if ( m_Device )
	{
		if( x1 < x2 )
        {
			rect.x1 = (long)x1; 
			rect.x2 = (long)x2 + 1;
		}
        else
        {
			rect.x1 = (long)x2; 
			rect.x2 = (long)x1 + 1;
		}

		if( y1 < y2 )
        {
			rect.y1 = (long)y1;
			rect.y2 = (long)y2 + 1;
		}
        else
        {
			rect.y1 = (long)y2;
			rect.y2 = (long)y1 + 1;
		}

		m_Device->Clear( 1, &rect, D3DCLEAR_TARGET, color, 0, 0 );
	}
}

// Draw a line to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      color          --- the RGBA color to draw the box with
HRESULT CXBoxVideo::DrawLine( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    HRESULT hr = S_OK;     // Return code for D3D functions that are called, and for the function
	MYVERTEX* pb;   // Vertex information

    // Set the line width
    if( FAILED( hr = m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Failed: m_Device->SetRenderState( D3DRS_LINEWIDTH, *(DWORD*)&fLineWidth )! - '%d'", hr );
    }

    // Before any rendering can be done, this must be called
	if( FAILED( hr = m_Device->BeginScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->BeginScene()! - '%d'", hr );
    }

    // Locks a range of vertex data and obtains a pointer to the vertex buffer memory.
	if( FAILED( hr = m_VertexBuffer->Lock( 0, sizeof( MYVERTEX ) * NUM_VB_VERTS, (BYTE**)&pb, 0 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Lock()! - '%d'", hr );
    }

    pb[0].v.x = x1;  pb[0].v.y = y1; pb[0].v.z = .1f;  pb[0].fRHW = .9f;  pb[0].cDiffuse = color;
	pb[1].v.x = x2;  pb[1].v.y = y2; pb[1].v.z = .1f;  pb[1].fRHW = .9f;  pb[1].cDiffuse = color;

    // Unlock the vertext data
	if( FAILED( hr = m_VertexBuffer->Unlock() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_VertexBuffer->Unlock()! - '%d'", hr );
        
        return hr;
    }

    // Renders a sequence of nonindexed, geometric primitives of the specified type from the current set of data input streams
    if( FAILED( hr = m_Device->DrawPrimitive( D3DPT_LINELIST, 0, 1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->DrawPrimitive()! - '%d'", hr );
    }

    // Once rendering is complete, this must be called
    // We should try this, even on a failure, in case BeginScene() was successful
    // We'll report it to the debugger, but will not return the fail/success code to the
    // caller
	if( FAILED( m_Device->EndScene() ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::DrawLine():Problem calling m_Device->EndScene()! - '%d'", hr );
    }

    return hr;
}

// Draw an outline to the screen
//
// Parameters:
//      x1, y1, x2, y2 --- the coordinates. Box is drawn from (x1,y1) to (x2,y2)
//      borderSize     --- width in pixels of the border
//      color          --- the RGBA color to draw the box with
void CXBoxVideo::DrawOutline( float x1, float y1, float x2, float y2, float fLineWidth, DWORD color )
{
    // Draw the box on the screen
    DrawLine( x1, y1, x1, y2, fLineWidth, color );     // Left Line
    DrawLine( x1, y2, x2, y2, fLineWidth, color );     // Bottom Line
    DrawLine( x2, y2, x2, y1, fLineWidth, color );     // Right Line
    DrawLine( x2, y1, x1, y1, fLineWidth, color );     // Top Line
}


// DeInitialize our Screen by freeing our objects
void CXBoxVideo::DeInitialize( void )
{
    if( m_BackBuffer)
    {
        m_BackBuffer->Release();
        m_BackBuffer = NULL;
    }

    if( m_Device )
    {
	    m_Device->Release();
        m_Device = NULL;
    }
}

// Prints formatted text using the default font to the screen
// Set colors to 0 to use default color
int CXBoxVideo::DrawText( float x1, float y1, DWORD fgcolor, DWORD bgcolor, const TCHAR* format, ... )
{
    if( !m_Font )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():The font is not set!!" );
        return -1;
    }

	int i;                  // Return Value
	HRESULT hr;             // Return Value for XFONT
	va_list v;              // Argument List
	TCHAR wstr[256];        // Honkin Buffer
    DWORD currentFGColor;   // Current FG Color
    DWORD currentBGColor;   // Current FG Color

    // Set our FONT colors if the user wishes to
    if( fgcolor || bgcolor )
    {
        // Set the foreground color if the user wants to
        if( fgcolor )
        {
            XFONT_SetTextColor( m_Font, fgcolor );
        }

        // Set the background color if the user wants to
        if( bgcolor )
        {
            XFONT_SetBkColor( m_Font, bgcolor );
        }
    }

	va_start( v, format );
	i = wvsprintf( wstr, format, v );

    // Print the Text to the backbuffer
    hr = XFONT_TextOut( m_Font, m_BackBuffer, wstr, i, (long)x1, (long)y1 );

    // If we have a valid font object, check the HRESULT
    if( FAILED( hr ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::DrawText():XFONT_TextOut failed!!  HRESULT: %x", hr );
    }

	va_end( v );
	
    return i;
}

// Get the size of the current font
void CXBoxVideo::GetFontSize( unsigned int* pheight, unsigned int* pdecent )
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():The font is not set!!" );

        return;
    }

    // Verify the parameters that were passed in are corred
    if( ( !pheight ) || ( !pdecent ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetFontSize():Invalid arguments passed!!" );

        return;
    }

    XFONT_GetFontMetrics( m_Font, pheight, pdecent );
}

// Get the pixel width of a string
//
// Parameters:
//      string -- The string to get the length in pixels
//      length -- OPTIONAL.  The length of the string (-1 if NULL terminated, this is default)
int CXBoxVideo::GetStringPixelWidth( IN LPCWSTR string, IN int length /*=-1*/ ) 
{
    // Make sure we have loaded a font
    if( !m_Font )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):The font is not set!!" );

        return -1;
    }
    
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( WCHAR* ):Invalid (string) pointer passed in!" );

        return -1;
    }

	unsigned int outlen = 0;        // Return value

	XFONT_GetTextExtent( m_Font, string, length, &outlen );
	
    return outlen;
}

// Get the width of the char*
int CXBoxVideo::GetStringPixelWidth( IN char* string, IN int length /*=-1*/ ) 
{
    if( !string )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::GetStringPixelWidth( char* ):Invalid pointer passed in!" );

        return -1;
    }

    int len = strlen( string );

    WCHAR newWStr[MAX_PATH];
    ZeroMemory( newWStr, MAX_PATH * sizeof( WCHAR ) );

    _snwprintf( newWStr, MAX_PATH - 1, L"%S", string );

    return GetStringPixelWidth( newWStr, length );
}

// Get a D3D Transform
HRESULT CXBoxVideo::GetTransform( D3DTRANSFORMSTATETYPE State, D3DMATRIX* pMatrix )
{
    return m_Device->GetTransform( State, pMatrix );
}

// Get the D3D Vertex Shader
HRESULT CXBoxVideo::GetVertexShader( DWORD* pHandle )
{
    return m_Device->GetVertexShader( pHandle );
}

// Lighten the image specified by "pBits"
void CXBoxVideo::LightenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwAddto )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwAddto];
		pshufw mm0, mm0, 01000100b
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		paddusb mm1, mm0 ;//add, saturating to 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Darken the image specified by "pBits"
void CXBoxVideo::DarkenImage( int nWidth, int nHeight, DWORD* pBits, DWORD dwSubtract )
{
	DWORD dwSize = nWidth * nHeight;
	_asm{
		mov ecx, [dwSize];
		shr ecx, 1;
		movd mm0, [dwSubtract];
		pshufw mm0, mm0, 01000100b ;;//propegate "subtract" into both dwords of mm0
		mov esi, [pBits]
theloop:
		movq mm1, [esi]
		psubusb mm1, mm0 ;//subtract, saturating to 0 or 255 if wrap would occur
		movq [esi], mm1
		add esi, 8
		dec ecx
		jnz theloop

        emms
	}
}

// Initialize D3D for this screen
void CXBoxVideo::Initialize( int width = SCREEN_WIDTH, int height = SCREEN_HEIGHT )
{
    IDirect3D8* pD3D = NULL;
    m_ScreenWidth = width;
    m_ScreenHeight = height;

	if ( m_Device == NULL )
	{
        // Create D3D 8.
		if( FAILED( pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize(): Failed to create pD3D!" );
			return;
        }

        // Set the screen mode.
		D3DPRESENT_PARAMETERS d3dpp;
		ZeroMemory( &d3dpp, sizeof( d3dpp ) );

		d3dpp.BackBufferWidth                 = width;
		d3dpp.BackBufferHeight                = height;
		d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
		d3dpp.BackBufferCount                 = 1;

        d3dpp.hDeviceWindow                   = NULL;                    // Ignored on Xbox
		d3dpp.Windowed                        = FALSE;                   // Must be false for Xbox
		d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
        d3dpp.EnableAutoDepthStencil          = FALSE; // TRUE;
        d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_DEFAULT;

    // Always do interlaced output on an HDTV.
    if (XGetAVPack() == XC_AV_PACK_HDTV)
    {
        d3dpp.Flags = D3DPRESENTFLAG_INTERLACED;
    }

		// Create the m_Device.
		if ( FAILED ( pD3D->CreateDevice( D3DADAPTER_DEFAULT,
                                          D3DDEVTYPE_HAL,
                                          NULL,      // Ignored on Xbox
                                          D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                          &d3dpp,
                                          &m_Device ) ) )
		{
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to CreateDevice!" );
			pD3D->Release();

			return;
		}

		// Now we no longer need the D3D interface so let's free it.
		pD3D->Release();
	}

    if( FAILED( m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_LIGHTING, FALSE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ) Failed!!" );
    }

    if( FAILED( m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE ) Failed!!" );
    }

    // Create our vertex buffer
	if( FAILED( m_Device->CreateVertexBuffer( sizeof( MYVERTEX ) * NUM_VB_VERTS, 0, D3DFVF_XYZRHW | D3DFVF_DIFFUSE, D3DPOOL_DEFAULT, &m_VertexBuffer ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to create the Vertex Buffer!!" );
    }

    // Set the stream source
	m_Device->SetStreamSource( 0, m_VertexBuffer, sizeof( MYVERTEX ) );

    // Set our initial vertex shader that is compatible with our 2D scene
	if( FAILED( m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->SetVertexShader( D3DFVF_XYZRHW | D3DFVF_DIFFUSE ) Failed!!" );
    }

    // Setup matricies
    // Setup our identity matrix
    D3DMATRIX mat;
    mat._11 = mat._22 = mat._33 = mat._44 = 1.0f;
    mat._12 = mat._13 = mat._14 = mat._41 = 0.0f;
    mat._21 = mat._23 = mat._24 = mat._42 = 0.0f;
    mat._31 = mat._32 = mat._34 = mat._43 = 0.0f;

    // World Matrix
    // The world matrix controls the position and orientation 
    // of the polygons in world space. We'll use it later to 
    // spin the triangle.
    D3DMATRIX WorldMatrix = mat;

    // Set the transforms for our 3D world
    if( FAILED( m_Device->SetTransform( D3DTS_WORLD, &WorldMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the World Matrix!!" );
    }
    
    // View Matrix
    // The view matrix defines the position and orientation of 
    // the camera. Here, we are just moving it back along the z-
    // axis by 10 units.
    D3DMATRIX ViewMatrix = mat;
    ViewMatrix._43 = 10.0f;

    if( FAILED( m_Device->SetTransform( D3DTS_VIEW, &ViewMatrix ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the View Matrix!!" );
    }

    // Projection Matrix
    // The projection matrix defines how the 3-D scene is "projected" 
    // onto the 2-D render target surface. 

    // Set up a very simple projection that scales x and y 
    // by 2, and translates z by -1.0.
    D3DXMATRIX ProjectionMatrix; //  = mat;
    D3DXMatrixPerspectiveFovLH( &ProjectionMatrix, 1.57f, 640.0f/480.0f, 0.001f, 30.0f );

    if( FAILED( m_Device->SetTransform( D3DTS_PROJECTION, &ProjectionMatrix ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set up the Projection Matrix!!" );
    }
    
    // Viewport
    D3DVIEWPORT8 D3DViewport;    // Direct3D Viewport

    D3DViewport.X      = 0;
    D3DViewport.Y      = 0;
    D3DViewport.Width  = width;  // rect.right - rect.left;
    D3DViewport.Height = height; // rect.bottom - rect.top;
    D3DViewport.MinZ   = 0.0f;
    D3DViewport.MaxZ   = 1.0f;

    // Set our Viewport
    if( FAILED( m_Device->SetViewport( &D3DViewport ) ) )
    {
        XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():Failed to set the viewport!!" );
    }
    
    XFONT_OpenTrueTypeFont( FILE_DATA_DEFAULT_FONT_FILENAME, 4096, &m_Font );

	if( m_Font )
    {
	    if( FAILED( m_Device->GetBackBuffer( 0, D3DBACKBUFFER_TYPE_MONO, &m_BackBuffer ) ) )
        {
            XDBGERR( APP_TITLE_NAME_A, "CXBoxVideo::Initialize():m_Device->GetBackBuffer() Failed!!" );
        }

        XFONT_SetTextColor( m_Font, SCREEN_DEFAULT_TEXT_FG_COLOR );
        XFONT_SetTextAlignment( m_Font, XFONT_CENTER );
        XFONT_SetBkColor( m_Font, SCREEN_DEFAULT_TEXT_BG_COLOR );
        XFONT_SetTextHeight( m_Font, FONT_DEFAULT_HEIGHT );
        XFONT_SetTextAntialiasLevel( m_Font, FONT_ALIAS_LEVEL );
        XFONT_SetTextStyle( m_Font, FONT_DEFAULT_STYLE );
    }
}


// Set a D3D Transform
HRESULT CXBoxVideo::SetTransform( D3DTRANSFORMSTATETYPE State, CONST D3DMATRIX* pMatrix )
{
    return m_Device->SetTransform( State, pMatrix );
};

// Display the current backbuffer on to the screen
void CXBoxVideo::ShowScreen()
{
	if( m_Device )
    {
		m_Device->Present( NULL, NULL, NULL, NULL );
	}
}


// Set the D3D Vertex Shader
HRESULT CXBoxVideo::SetVertexShader( DWORD Handle )
{
    return m_Device->SetVertexShader( Handle );
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( WCHAR* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[wcslen( pString ) - 1] = L'\0';

        // Ensure we don't end up in an endless loop
        if( L'\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}


// Truncate a string to fit within a certain screen size
HRESULT CXBoxVideo::TruncateStringToFit( char* pString, unsigned int nStrSize, float x1,float x2 )
{
    if( ( !pString ) || ( 0 > ( x2 - x1 ) ) )
    {
        XDBGWRN( APP_TITLE_NAME_A, "CXBoxVideo::TruncateStringToFit():Invalid argument!! x1 - '%f', x2 - '%f'", x1, x2 );

        return E_INVALIDARG;
    }

    float maxLen = x2 - x1;

    // If the string is to long, let's knock off characters
    while( GetStringPixelWidth( pString, -1 ) >= maxLen )
    {
        pString[strlen( pString ) - 1] = '\0';

        // Ensure we don't end up in an endless loop
        if( '\0' == pString[0] )
        {
            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\assert.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    assert.c

Abstract:

    This module implements the RtlAssert function that is referenced by the
    debugging version of the ASSERT macro defined in NTDEF.H

Author:

    Steve Wood (stevewo) 03-Oct-1989

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <zwapi.h>
#include "stdio.h"

NTSTATUS
PsTerminateSystemThread(
    IN NTSTATUS ExitStatus
    );

NTSTATUS
DebugService(
	ULONG ServiceClass,
	PVOID Arg1,
	PVOID Arg2
	);

//
// RtlAssert is not called unless the caller is compiled with DBG non-zero
// therefore it does no harm to always have this routin in the kernel.  
// This allows checked drivers to be thrown on the system and have their
// asserts be meaningful.
//

#define RTL_ASSERT_ALWAYS_ENABLED 1

VOID
RtlAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
#if DBG || RTL_ASSERT_ALWAYS_ENABLED
    char Response;
    CONTEXT Context;
	STRING String;
	UCHAR Buffer[512];

#ifndef BLDR_KERNEL_RUNTIME
    RtlCaptureContext( &Context );
#endif

	sprintf(Buffer, "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
				  );
    RtlInitAnsiString( &String, Buffer);

    while (TRUE) {
		Response = (CHAR)DebugService(BREAKPOINT_RTLASSERT, &String, 0);
        switch (Response) {
            case 'B':
            case 'b':
                DbgPrint( "Execute '!cxr %p' to dump context\n", &Context);
                DbgBreakPoint();
                break;

            case 'I':
            case 'i':
                return;

            case 'T':
            case 't':
                PsTerminateSystemThread( STATUS_UNSUCCESSFUL );
                break;
            }
        }

    DbgBreakPoint();
#endif
}

VOID
RtlRip(
    IN PVOID ApiName,
    IN PVOID Expression,
    IN PVOID Message
    )
{
#if DBG || RTL_ASSERT_ALWAYS_ENABLED
    UCHAR Buffer[512];
    char Colon;
    char OpenParen;
    char CloseParen;

    if(NULL == Message)
        Message = Expression != NULL ? "failed" : "unexpected failure";
    Colon = ApiName != NULL ? ':' : ' ';
    if(NULL != Expression) {
        OpenParen = '(';
        CloseParen = ')';
    } else
        OpenParen = CloseParen = ' ';

    _snprintf(Buffer, sizeof Buffer, "%s%c %c%s%c %s", ApiName ? ApiName : "",
        Colon, OpenParen, Expression ? Expression : "", CloseParen, Message);
    Buffer[sizeof Buffer - 1] = 0;
    DebugService(BREAKPOINT_RIP, Buffer, 0);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\error.h ===
//
// Define run length table entry structure type.
//

typedef struct _RUN_ENTRY {
    ULONG BaseCode;
    USHORT RunLength;
    USHORT CodeSize;
} RUN_ENTRY, *PRUN_ENTRY;

//
// Declare translation table array.
//

CONST USHORT RtlpStatusTable[] = {
    0x0000, 0x03e5, 0x00ea, 0x0514, 0x0515, 0x03fe, 0x0516, 
    0x0057, 0x0517, 0x0460, 0x03f6, 0x0461, 0x0518, 0x0720, 
    0x0779, 0x0001, 0x8000, 0x03e6, 0x0000, 0x0003, 0x8000, 
    0x0004, 0x8000, 0x00ea, 0x0000, 0x0012, 0x0000, 0x056f, 
    0x012b, 0x001c, 0x0015, 0x0015, 0x00aa, 0x0103, 0x00fe, 
    0x00ff, 0x00ff, 0x0456, 0x0103, 0x044d, 0x0456, 0x0457, 
    0x044c, 0x044e, 0x044f, 0x0450, 0x0962, 0x048d, 0x048e, 
    0x05aa, 0x0006, 0x0001, 0x0035, 0x054f, 0x0554, 0x0120, 
    0x0554, 0x0057, 0x0057, 0x0032, 0x0558, 0x052e, 0x0057, 
    0x0520, 0x0005, 0x0005, 0x051f, 0x0554, 0x06f8, 0x0057, 
    0x007a, 0x0574, 0x06fe, 0x0057, 0x0057, 0x0532, 0x1770, 
    0x1771, 0x0001, 0x001f, 0x0001, 0x0057, 0x0018, 0x03e6, 
    0x03e7, 0x05ae, 0x0006, 0x03e9, 0x00c1, 0x0057, 0x0057, 0x0000, 
    0x0002, 0x0000, 0x0002, 0x0000, 0x0001, 0x0000, 0x0026, 0x0000, 
    0x0022, 0x0000, 0x0015, 0x0000, 0x06f9, 0x0000, 0x001b, 0x0000, 
    0x00ea, 0x0000, 0x0008, 0x0000, 0x01e7, 0x0000, 0x01e7, 0x0000, 
    0x0057, 0x0000, 0x0057, 0x0000, 0x0001, 0x0000, 0x001d, 0xc000, 
    0x0005, 0x0000, 0x0005, 0x0000, 0x00c1, 0x0000, 0x0005, 0x0000, 
    0x0005, 0x0000, 0x007a, 0x0000, 0x0006, 0x0000, 0x0025, 0xc000, 
    0x0026, 0xc000, 0x009e, 0x0000, 0x002b, 0xc000, 0x01e7, 0x0000, 
    0x01e7, 0x0000, 0x0057, 0x0571, 0x007b, 0x0002, 0x00b7, 
    0x0006, 0x00a1, 0x0000, 0x0003, 0x0000, 0x00a1, 0x0000, 
    0x045d, 0x0000, 0x045d, 0x0000, 0x0017, 0x0000, 0x0017, 0x0000, 
    0x0008, 0x0000, 0x0005, 0x0000, 0x0006, 0x0000, 0x0020, 0x0000, 
    0x0718, 0x0000, 0x0057, 0x0000, 0x0120, 0x0000, 0x012a, 0x0000, 
    0x0057, 0x0000, 0x0057, 0x0000, 0x009c, 0x0000, 0x0005, 0x0000, 
    0x0057, 0x0000, 0x0057, 0x0000, 0x0057, 0x0000, 0x011a, 0x0000, 
    0x00ff, 0x0000, 0x0570, 0x0000, 0x0570, 0x0000, 0x0570, 0x0000, 
    0x0021, 0x0000, 0x0021, 0x0000, 0x0005, 0x0000, 0x0032, 0x0000, 
    0x0519, 0x0000, 0x051a, 0x0000, 0x051b, 0x0000, 0x051c, 0x0000, 
    0x051d, 0x0000, 0x051e, 0x0000, 0x051f, 0x0000, 0x0520, 0x0000, 
    0x0521, 0x0000, 0x0522, 0x0000, 0x0523, 0x0000, 0x0524, 0x0000, 
    0x0525, 0x0000, 0x0526, 0x0000, 0x0527, 0x0000, 0x0528, 0x0000, 
    0x0529, 0x0000, 0x052a, 0x0000, 0x0056, 0x0000, 0x052c, 0x0000, 
    0x052d, 0x0000, 0x052e, 0x0000, 0x052f, 0x0000, 0x0530, 0x0000, 
    0x0531, 0x0000, 0x0532, 0x0000, 0x0533, 0x0000, 0x0534, 0x0000, 
    0x0535, 0x0000, 0x0536, 0x0000, 0x0537, 0x0000, 0x0538, 0x0000, 
    0x0539, 0x0000, 0x053a, 0x0000, 0x007f, 0x0000, 0x00c1, 0x0000, 
    0x03f0, 0x0000, 0x053c, 0x0000, 0x009e, 0x0000, 0x0070, 0x0000, 
    0x053d, 0x0000, 0x053e, 0x0000, 0x0044, 0x0000, 0x0103, 0x0000, 
    0x053f, 0x0000, 0x0103, 0x0000, 0x009a, 0x0000, 0x000e, 0x0000, 
    0x01e7, 0x0000, 0x0714, 0x0000, 0x0715, 0x0000, 0x0716, 0x0000, 
    0x008c, 0xc000, 0x008d, 0xc000, 0x008e, 0xc000, 0x008f, 0xc000, 
    0x0090, 0xc000, 0x0091, 0xc000, 0x0092, 0xc000, 0x0093, 0xc000, 
    0x0094, 0xc000, 0x0216, 0x0000, 0x0096, 0xc000, 0x0008, 0x0000, 
    0x03ee, 0x0000, 0x0540, 0x0000, 0x05aa, 0x0000, 0x0003, 0x0000, 
    0x0017, 0x0000, 0x048f, 0x0000, 0x0015, 0x0000, 0x01e7, 0x0000, 
    0x01e7, 0x0000, 0x05ad, 0x0000, 0x0013, 0x0000, 0x0015, 0x0000, 
    0x0541, 0x0000, 0x0542, 0x0000, 0x0543, 0x0000, 0x0544, 0x0000, 
    0x0545, 0x0000, 0x0057, 0x0000, 0x00e7, 0x00e7, 0x00e6, 
    0x00e7, 0x0001, 0x00e9, 0x00e8, 0x0217, 0x0218, 0x00e6, 
    0x0079, 0x0026, 0x0005, 0x0032, 0x0033, 0x0034, 0x0035, 
    0x0036, 0x0037, 0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 
    0x003d, 0x003e, 0x003f, 0x0040, 0x0041, 0x0042, 0x0043, 
    0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0058, 0x0011, 
    0x0005, 0x00f0, 0x0546, 0x00e8, 0x0547, 0x0548, 0x0549, 
    0x054a, 0x054b, 0x054c, 0x054d, 0x012c, 0x012d, 0x054e, 
    0x054f, 0x0550, 0x0551, 0x06f8, 0x0552, 0x0553, 0x0057, 
    0x0057, 0x0057, 0x0057, 0x0057, 0x0057, 0x0057, 0x0057, 
    0x0057, 0x0057, 0x0057, 0x0057, 0x0003, 0x03e9, 0x0554, 
    0x00cb, 0x0091, 0x0570, 0x010b, 0x0555, 0x0556, 0x00ce, 
    0x0961, 0x0964, 0x013d, 0x0005, 0x0557, 0x0558, 0x0420, 
    0x05a4, 0x03ee, 0x0004, 0x03e3, 0x0005, 0x04ba, 0x0005, 
    0x055b, 0x055c, 0x055d, 0x055e, 0x0006, 0x055f, 0x05af, 
    0x00c1, 0x0576, 0x007e, 0x00b6, 0x007f, 0x0040, 0x0040, 
    0x0033, 0x003b, 0x003b, 0x003b, 0x003b, 0x045a, 0x007c, 
    0x0056, 0x006d, 0x03f1, 0x03f8, 0x03ed, 0x045e, 0x0560, 
    0x0561, 0x0562, 0x0563, 0x0564, 0x0565, 0x0566, 0x0567, 
    0x03ef, 0x0568, 0x0569, 0x03f9, 0x056a, 0x0459, 0x0466, 
    0x0467, 0x0468, 0x045f, 0x0451, 0x0452, 0x0453, 0x0454, 
    0x0455, 0x0469, 0x0458, 0x056b, 0x056c, 0x03fa, 0x03fb, 
    0x056d, 0x056e, 0x03fc, 0x03fd, 0x0057, 0x045d, 0x0016, 
    0x045d, 0x045d, 0x05de, 0x0013, 0x06fa, 0x06fb, 0x06fc, 
    0x06fd, 0x05dc, 0x05dd, 0x06fe, 0x0700, 0x0701, 0x046b, 
    0x04c3, 0x04c4, 0x05df, 0x070f, 0x0710, 0x0711, 0x0712, 
    0x0572, 0x003b, 0x003b, 0x0717, 0x046a, 0x06f8, 0x04be, 
    0x04be, 0x0044, 0x0034, 0x0040, 0x0040, 0x0040, 0x0044, 
    0x003b, 0x003b, 0x003b, 0x003b, 0x003b, 0x003b, 0x003b, 
    0x0032, 0x0032, 0x17e6, 0x046c, 0x00c1, 0x0773, 0x0490, 
    0x022a, 0xc000, 0x022b, 0xc000, 0x04d5, 0x0492, 0x0774, 
    0x0775, 0x0006, 0x04c9, 0x04ca, 0x04cb, 0x04cc, 0x04cd, 
    0x04ce, 0x04cf, 0x04d0, 0x04d1, 0x04d2, 0x04d3, 0x04d4, 
    0x04c8, 0x04d6, 0x04d7, 0x04d8, 0x00c1, 0x054f, 0x04d0, 
    0x0573, 0x0422, 0x00b6, 0x007f, 0x0120, 0x0476, 0x10fe, 
    0x07d1, 0x04b1, 0x0015, 0x0491, 0x1126, 0x1129, 0x112a, 
    0x1128, 0x0780, 0x0781, 0x00a1, 0x0488, 0x0489, 0x048a, 
    0x048b, 0x048c, 0x0005, 0x0005, 0x0005, 0x0005, 0x0005, 
    0x0005, 0x1777, 0x1778, 0x1772, 0x0001, 0x1127, 0x0651, 
    0x0575, 0x03e6, 0x10e8, 0x04e3, 0x0052, 0x06a4, 0x06a5, 
    0x0006, 0x06a7, 0x06a8, 0x06a9, 0x06aa, 0x06ab, 0x06ac, 
    0x06ad, 0x06ae, 0x06af, 0x06b0, 0x06b1, 0x06b2, 0x06b3, 
    0x06b4, 0x06b5, 0x06b6, 0x06b7, 0x06b8, 0x06b9, 0x06ba, 
    0x06bb, 0x06bc, 0x06bd, 0x06be, 0x06bf, 0x06c0, 0x06c2, 
    0x06c4, 0x06c5, 0x06c6, 0x06c7, 0x06c8, 0x06c9, 0x06cb, 
    0x06cc, 0x06cd, 0x06ce, 0x06cf, 0x06d0, 0x06d1, 0x06d2, 
    0x06d3, 0x06d4, 0x06d5, 0x06d6, 0x06d7, 0x06d8, 0x06d9, 
    0x06da, 0x06db, 0x06dc, 0x06dd, 0x06de, 0x06df, 0x06e0, 
    0x06e1, 0x06e2, 0x06e3, 0x06e4, 0x06e5, 0x06e6, 0x06e7, 
    0x06e8, 0x06e9, 0x06ea, 0x06eb, 0x06ff, 0x070e, 0x076a, 
    0x076b, 0x076c, 0x0719, 0x071a, 0x071b, 0x071c, 0x071d, 
    0x071e, 0x071f, 0x0721, 0x0722, 0x077a, 0x077b, 0x06ec, 
    0x06ed, 0x06ee, 0x0006, 0x0006, 0x06f1, 0x06f2, 0x06f3, 
    0x06f4, 0x06f5, 0x06f6, 0x06f7, 0x0723, 0x0724, 0x0725, 
    0x0726, 0x0728, 0x077c, 0x077d, 0x077e, 0x0037, 0x0037, 
    0x0037, 0x0000, 0x0};

//
// Declare run length table array.
//

CONST RUN_ENTRY RtlpRunTable[] = {
    {0x00000000, 0x0001, 0x0001},
    {0x00000103, 0x0001, 0x0001},
    {0x00000105, 0x0003, 0x0001},
    {0x0000010c, 0x0002, 0x0001},
    {0x40000002, 0x0001, 0x0001},
    {0x40000006, 0x0001, 0x0001},
    {0x40000008, 0x0002, 0x0001},
    {0x4000000c, 0x0002, 0x0001},
    {0x40020056, 0x0001, 0x0001},
    {0x400200af, 0x0001, 0x0001},
    {0x80000001, 0x0006, 0x0002},
    {0x8000000b, 0x0001, 0x0001},
    {0x8000000d, 0x000a, 0x0001},
    {0x8000001a, 0x0006, 0x0001},
    {0x80000021, 0x0002, 0x0001},
    {0x80000025, 0x0001, 0x0001},
    {0x80000288, 0x0002, 0x0001},
    {0x80090300, 0x0012, 0x0001},
    {0x80090316, 0x0001, 0x0001},
    {0x80090318, 0x0001, 0x0001},
    {0x80090320, 0x0003, 0x0001},
    {0x80090325, 0x0005, 0x0001},
    {0x80090330, 0x0002, 0x0001},
    {0xc0000001, 0x000b, 0x0001},
    {0xc000000d, 0x001a, 0x0002},
    {0xc000002a, 0x0004, 0x0002},
    {0xc0000030, 0x0001, 0x0001},
    {0xc0000032, 0x0004, 0x0001},
    {0xc0000037, 0x0001, 0x0001},
    {0xc0000039, 0x0071, 0x0002},
    {0xc00000ab, 0x000c, 0x0001},
    {0xc00000ba, 0x0019, 0x0001},
    {0xc00000d4, 0x0004, 0x0001},
    {0xc00000d9, 0x0002, 0x0001},
    {0xc00000dc, 0x000d, 0x0001},
    {0xc00000ed, 0x000f, 0x0001},
    {0xc00000fd, 0x0002, 0x0001},
    {0xc0000100, 0x000c, 0x0001},
    {0xc000010d, 0x0002, 0x0001},
    {0xc0000117, 0x0001, 0x0001},
    {0xc000011e, 0x000b, 0x0001},
    {0xc000012b, 0x0001, 0x0001},
    {0xc000012d, 0x0001, 0x0001},
    {0xc0000130, 0x0001, 0x0001},
    {0xc0000133, 0x0001, 0x0001},
    {0xc0000135, 0x0001, 0x0001},
    {0xc0000138, 0x0002, 0x0001},
    {0xc000013b, 0x0008, 0x0001},
    {0xc0000148, 0x0002, 0x0001},
    {0xc000014b, 0x0003, 0x0001},
    {0xc000014f, 0x000f, 0x0001},
    {0xc0000162, 0x0001, 0x0001},
    {0xc0000169, 0x0004, 0x0001},
    {0xc0000172, 0x0007, 0x0001},
    {0xc000017a, 0x000d, 0x0001},
    {0xc0000188, 0x0009, 0x0001},
    {0xc0000192, 0x000a, 0x0001},
    {0xc0000202, 0x0002, 0x0001},
    {0xc0000203, 0x0015, 0x0001},
    {0xc000021c, 0x0001, 0x0001},
    {0xc0000220, 0x0002, 0x0001},
    {0xc0000224, 0x0002, 0x0001},
    {0xc000022a, 0x0002, 0x0002},
    {0xc000022d, 0x0001, 0x0001},
    {0xc0000230, 0x0001, 0x0001},
    {0xc0000233, 0x000f, 0x0001},
    {0xc0000243, 0x0001, 0x0001},
    {0xc0000246, 0x0004, 0x0001},
    {0xc0000253, 0x0001, 0x0001},
    {0xc0000257, 0x0001, 0x0001},
    {0xc0000259, 0x0001, 0x0001},
    {0xc000025e, 0x0001, 0x0001},
    {0xc0000262, 0x0004, 0x0001},
    {0xc0000267, 0x0001, 0x0001},
    {0xc000026c, 0x0003, 0x0001},
    {0xc0000272, 0x0001, 0x0001},
    {0xc0000275, 0x0005, 0x0001},
    {0xc0000280, 0x0002, 0x0001},
    {0xc0000283, 0x0005, 0x0001},
    {0xc000028a, 0x0002, 0x0001},
    {0xc000028d, 0x0007, 0x0001},
    {0xc000029c, 0x0001, 0x0001},
    {0xc00002b2, 0x0001, 0x0001},
    {0xc00002b6, 0x0001, 0x0001},
    {0xc00002c3, 0x0001, 0x0001},
    {0xc00002c5, 0x0001, 0x0001},
    {0xc00002ca, 0x0001, 0x0001},
    {0xc00002cc, 0x0001, 0x0001},
    {0xc00002ea, 0x0001, 0x0001},
    {0xc0020001, 0x001d, 0x0001},
    {0xc002001f, 0x0001, 0x0001},
    {0xc0020021, 0x0006, 0x0001},
    {0xc0020028, 0x0026, 0x0001},
    {0xc002004f, 0x0007, 0x0001},
    {0xc0020057, 0x0002, 0x0001},
    {0xc0020062, 0x0002, 0x0001},
    {0xc0030001, 0x000c, 0x0001},
    {0xc0030059, 0x0004, 0x0001},
    {0xc003005e, 0x0004, 0x0001},
    {0xc0980001, 0x0002, 0x0001},
    {0xc0980008, 0x0001, 0x0001},
    {0xffffffff, 0x0001, 0x0001},
    {0x0, 0x0, 0x0}};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\generr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    generr.c

Abstract:

    This module contains code to generate the NT status code to DOS
    error code table that is used by the runtime to translate status
    codes.

Author:

    David N. Cutler (davec) 2-Dec-1992

Revision History:

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <status.h>
#include "stdio.h"
#include "stdarg.h"
#include "stdlib.h"

//
// Ensure that the Registry ERROR_SUCCESS error code and the
// NO_ERROR error code remain equal and zero.
//

#if ERROR_SUCCESS != 0 || NO_ERROR != 0
#error Invalid value for ERROR_SUCCESS.
#endif

//
// The following error code table contains paired entries in a singly
// dimensioned array. The first member of a paired entry is an NT status
// code and the second member is the DOS error code that it translates to.
//
// To add a value to this table simply insert the NT status/DOS error code
// pair anywhere is the table. If multiple NT status codes map to a single
// DOS error code, then insert a paired entry for each of the code pairs.
//
#ifdef i386
#pragma warning (4:4018)        // lower to -W4
#endif
LONG CodePairs[] = {

    //
    // First some marker entries so that generr.exe can locate this table
    // in generr.obj.  The following line must appear first in the table.
    //

    'Begi','n ge','nerr',' tbl',

    //
    // Exception codes defined in WINNT.H can map to themselves.
    //

    STATUS_BREAKPOINT, STATUS_BREAKPOINT,
    STATUS_SINGLE_STEP, STATUS_SINGLE_STEP,
    STATUS_ILLEGAL_INSTRUCTION, STATUS_ILLEGAL_INSTRUCTION,
    STATUS_NONCONTINUABLE_EXCEPTION, STATUS_NONCONTINUABLE_EXCEPTION,
    STATUS_INVALID_DISPOSITION, STATUS_INVALID_DISPOSITION,
    STATUS_PARITY_ERROR, STATUS_PARITY_ERROR,
    STATUS_ARRAY_BOUNDS_EXCEEDED, STATUS_ARRAY_BOUNDS_EXCEEDED,
    STATUS_FLOAT_DENORMAL_OPERAND, STATUS_FLOAT_DENORMAL_OPERAND,
    STATUS_FLOAT_DIVIDE_BY_ZERO, STATUS_FLOAT_DIVIDE_BY_ZERO,
    STATUS_FLOAT_INEXACT_RESULT, STATUS_FLOAT_INEXACT_RESULT,
    STATUS_FLOAT_INVALID_OPERATION, STATUS_FLOAT_INVALID_OPERATION,
    STATUS_FLOAT_OVERFLOW, STATUS_FLOAT_OVERFLOW,
    STATUS_FLOAT_STACK_CHECK, STATUS_FLOAT_STACK_CHECK,
    STATUS_FLOAT_UNDERFLOW, STATUS_FLOAT_UNDERFLOW,
    STATUS_INTEGER_DIVIDE_BY_ZERO, STATUS_INTEGER_DIVIDE_BY_ZERO,
    STATUS_PRIVILEGED_INSTRUCTION, STATUS_PRIVILEGED_INSTRUCTION,
    STATUS_GUARD_PAGE_VIOLATION, STATUS_GUARD_PAGE_VIOLATION,

    //
    // These are also defined in WINNT.H, but we are stuck with these
    // mappings.
    //

    STATUS_DATATYPE_MISALIGNMENT, ERROR_NOACCESS,
    STATUS_ACCESS_VIOLATION, ERROR_NOACCESS,
    STATUS_DATATYPE_MISALIGNMENT_ERROR, ERROR_NOACCESS,

    STATUS_CTL_FILE_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    STATUS_PORT_ALREADY_SET, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_NOT_IMAGE, ERROR_INVALID_PARAMETER,
    STATUS_BAD_WORKING_SET_LIMIT, ERROR_INVALID_PARAMETER,
    STATUS_WORKING_SET_LIMIT_RANGE, ERROR_INVALID_PARAMETER,
    STATUS_INCOMPATIBLE_FILE_MAP, ERROR_INVALID_PARAMETER,
    STATUS_PORT_DISCONNECTED, ERROR_INVALID_HANDLE,
    STATUS_NOT_LOCKED, ERROR_NOT_LOCKED,
    STATUS_NOT_MAPPED_VIEW, ERROR_INVALID_ADDRESS,
    STATUS_UNABLE_TO_FREE_VM, ERROR_INVALID_PARAMETER,
    STATUS_UNABLE_TO_DELETE_SECTION, ERROR_INVALID_PARAMETER,
    STATUS_MORE_PROCESSING_REQUIRED, ERROR_MORE_DATA,
    STATUS_INVALID_CID, ERROR_INVALID_PARAMETER,
    STATUS_STACK_OVERFLOW, ERROR_STACK_OVERFLOW,
    STATUS_BAD_INITIAL_STACK, ERROR_STACK_OVERFLOW,
    STATUS_INVALID_VOLUME_LABEL, ERROR_LABEL_TOO_LONG,
    STATUS_SECTION_NOT_EXTENDED, ERROR_OUTOFMEMORY,
    STATUS_NOT_MAPPED_DATA, ERROR_INVALID_ADDRESS,

    STATUS_NO_LDT, ERROR_INVALID_THREAD_ID,

    STATUS_INFO_LENGTH_MISMATCH, ERROR_BAD_LENGTH,
    STATUS_INVALID_INFO_CLASS, ERROR_INVALID_PARAMETER,

    STATUS_SUSPEND_COUNT_EXCEEDED, ERROR_SIGNAL_REFUSED,

    STATUS_NOTIFY_ENUM_DIR, ERROR_NOTIFY_ENUM_DIR,

    STATUS_REGISTRY_RECOVERED, ERROR_REGISTRY_RECOVERED,

    STATUS_REGISTRY_IO_FAILED, ERROR_REGISTRY_IO_FAILED,

    STATUS_NOT_REGISTRY_FILE, ERROR_NOT_REGISTRY_FILE,

    STATUS_KEY_DELETED, ERROR_KEY_DELETED,

    STATUS_NO_LOG_SPACE, ERROR_NO_LOG_SPACE,

    STATUS_KEY_HAS_CHILDREN, ERROR_KEY_HAS_CHILDREN,

    STATUS_CHILD_MUST_BE_VOLATILE, ERROR_CHILD_MUST_BE_VOLATILE,

    STATUS_REGISTRY_CORRUPT, ERROR_BADDB,

    STATUS_DLL_NOT_FOUND, ERROR_MOD_NOT_FOUND,

    STATUS_DLL_INIT_FAILED, ERROR_DLL_INIT_FAILED,

    STATUS_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_ORDINAL_NOT_FOUND, ERROR_INVALID_ORDINAL,
    STATUS_DRIVER_UNABLE_TO_LOAD, ERROR_BAD_DRIVER,

    STATUS_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,
    STATUS_DRIVER_ENTRYPOINT_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_PENDING, ERROR_IO_PENDING,

    STATUS_MORE_ENTRIES, ERROR_MORE_DATA,

    STATUS_INTEGER_OVERFLOW, ERROR_ARITHMETIC_OVERFLOW,

    STATUS_BUFFER_OVERFLOW, ERROR_MORE_DATA,

    STATUS_NO_MORE_FILES, ERROR_NO_MORE_FILES,

    STATUS_NO_INHERITANCE, ERROR_NO_INHERITANCE,

    STATUS_NO_MORE_EAS, ERROR_NO_MORE_ITEMS,
    STATUS_NO_MORE_ENTRIES, ERROR_NO_MORE_ITEMS,
    STATUS_GUIDS_EXHAUSTED, ERROR_NO_MORE_ITEMS,
    STATUS_AGENTS_EXHAUSTED, ERROR_NO_MORE_ITEMS,

    STATUS_UNSUCCESSFUL, ERROR_GEN_FAILURE,

    STATUS_TOO_MANY_LINKS, ERROR_TOO_MANY_LINKS,

    STATUS_NOT_IMPLEMENTED, ERROR_INVALID_FUNCTION,
    STATUS_ILLEGAL_FUNCTION, ERROR_INVALID_FUNCTION,

    STATUS_IN_PAGE_ERROR, ERROR_SWAPERROR,

    STATUS_PAGEFILE_QUOTA, ERROR_PAGEFILE_QUOTA,
    STATUS_COMMITMENT_LIMIT, ERROR_COMMITMENT_LIMIT,
    STATUS_SECTION_TOO_BIG, ERROR_NOT_ENOUGH_MEMORY,

    RPC_NT_SS_IN_NULL_CONTEXT, ERROR_INVALID_HANDLE,
    RPC_NT_INVALID_BINDING, ERROR_INVALID_HANDLE,
    STATUS_INVALID_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_OBJECT_TYPE_MISMATCH, ERROR_INVALID_HANDLE,
    STATUS_FILE_CLOSED, ERROR_INVALID_HANDLE,
    STATUS_INVALID_PORT_HANDLE, ERROR_INVALID_HANDLE,
    STATUS_HANDLE_NOT_CLOSABLE, ERROR_INVALID_HANDLE,

    STATUS_NOT_COMMITTED, ERROR_INVALID_ADDRESS,
    STATUS_PARTIAL_COPY, ERROR_PARTIAL_COPY,

    STATUS_LPC_REPLY_LOST, ERROR_INTERNAL_ERROR,
    STATUS_INVALID_PARAMETER, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_1, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_2, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_3, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_4, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_5, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_6, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_7, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_8, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_9, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_10, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_11, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_12, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PARAMETER_MIX, ERROR_INVALID_PARAMETER,
    STATUS_INVALID_PAGE_PROTECTION, ERROR_INVALID_PARAMETER,
    STATUS_SECTION_PROTECTION, ERROR_INVALID_PARAMETER,

    STATUS_RESOURCE_DATA_NOT_FOUND, ERROR_RESOURCE_DATA_NOT_FOUND,
    STATUS_RESOURCE_TYPE_NOT_FOUND, ERROR_RESOURCE_TYPE_NOT_FOUND,
    STATUS_RESOURCE_NAME_NOT_FOUND, ERROR_RESOURCE_NAME_NOT_FOUND,
    STATUS_RESOURCE_LANG_NOT_FOUND, ERROR_RESOURCE_LANG_NOT_FOUND,

    STATUS_NO_SUCH_DEVICE, ERROR_FILE_NOT_FOUND,
    STATUS_NO_SUCH_FILE, ERROR_FILE_NOT_FOUND,

    STATUS_INVALID_DEVICE_REQUEST, ERROR_INVALID_FUNCTION,
    STATUS_VOLUME_NOT_UPGRADED, ERROR_INVALID_FUNCTION,

    STATUS_END_OF_FILE, ERROR_HANDLE_EOF,
    STATUS_FILE_FORCED_CLOSED, ERROR_HANDLE_EOF,

    STATUS_WRONG_VOLUME, ERROR_WRONG_DISK,

    STATUS_NO_MEDIA, ERROR_NO_MEDIA_IN_DRIVE,

    STATUS_NO_MEDIA_IN_DEVICE, ERROR_NOT_READY,

    STATUS_VOLUME_DISMOUNTED, ERROR_NOT_READY,

    STATUS_NONEXISTENT_SECTOR, ERROR_SECTOR_NOT_FOUND,

    STATUS_WORKING_SET_QUOTA, ERROR_WORKING_SET_QUOTA,
    STATUS_NO_MEMORY, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_CONFLICTING_ADDRESSES, ERROR_INVALID_ADDRESS,

    STATUS_INVALID_SYSTEM_SERVICE, ERROR_INVALID_FUNCTION,

    STATUS_THREAD_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_PROCESS_IS_TERMINATING, ERROR_ACCESS_DENIED,
    STATUS_INVALID_LOCK_SEQUENCE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_VIEW_SIZE, ERROR_ACCESS_DENIED,
    STATUS_ALREADY_COMMITTED, ERROR_ACCESS_DENIED,
    STATUS_ACCESS_DENIED, ERROR_ACCESS_DENIED,
    STATUS_FILE_IS_A_DIRECTORY, ERROR_ACCESS_DENIED,
    STATUS_CANNOT_DELETE, ERROR_ACCESS_DENIED,
    STATUS_INVALID_COMPUTER_NAME, ERROR_INVALID_COMPUTERNAME,
    STATUS_FILE_DELETED, ERROR_ACCESS_DENIED,
    STATUS_FILE_RENAMED, ERROR_ACCESS_DENIED,
    STATUS_DELETE_PENDING, ERROR_ACCESS_DENIED,
    STATUS_PORT_CONNECTION_REFUSED, ERROR_ACCESS_DENIED,

    STATUS_NO_SUCH_PRIVILEGE, ERROR_NO_SUCH_PRIVILEGE,

    STATUS_PRIVILEGE_NOT_HELD, ERROR_PRIVILEGE_NOT_HELD,

    STATUS_CANNOT_IMPERSONATE, ERROR_CANNOT_IMPERSONATE,

    STATUS_LOGON_FAILURE, ERROR_LOGON_FAILURE,
    STATUS_MUTUAL_AUTHENTICATION_FAILED, ERROR_MUTUAL_AUTH_FAILED,
    STATUS_TIME_DIFFERENCE_AT_DC, ERROR_TIME_SKEW,

    STATUS_ACCOUNT_RESTRICTION, ERROR_ACCOUNT_RESTRICTION,

    STATUS_INVALID_LOGON_HOURS, ERROR_INVALID_LOGON_HOURS,

    STATUS_INVALID_WORKSTATION, ERROR_INVALID_WORKSTATION,

    STATUS_BUFFER_TOO_SMALL, ERROR_INSUFFICIENT_BUFFER,

    STATUS_UNABLE_TO_DECOMMIT_VM, ERROR_INVALID_ADDRESS,

    STATUS_DISK_CORRUPT_ERROR, ERROR_DISK_CORRUPT,

    STATUS_VARIABLE_NOT_FOUND, ERROR_ENVVAR_NOT_FOUND,

    STATUS_OBJECT_NAME_INVALID, ERROR_INVALID_NAME,

    STATUS_OBJECT_NAME_NOT_FOUND, ERROR_FILE_NOT_FOUND,

    STATUS_OBJECT_NAME_COLLISION, ERROR_ALREADY_EXISTS,

    STATUS_OBJECT_PATH_INVALID, ERROR_BAD_PATHNAME,

    STATUS_OBJECT_PATH_NOT_FOUND, ERROR_PATH_NOT_FOUND,
    STATUS_DFS_EXIT_PATH_FOUND, ERROR_PATH_NOT_FOUND,
    STATUS_DFS_UNAVAILABLE, ERROR_CONNECTION_UNAVAIL,

    STATUS_OBJECT_PATH_SYNTAX_BAD, ERROR_BAD_PATHNAME,

    STATUS_NAME_TOO_LONG, ERROR_FILENAME_EXCED_RANGE,

    STATUS_DATA_OVERRUN, ERROR_IO_DEVICE,
    STATUS_DATA_LATE_ERROR, ERROR_IO_DEVICE,
    STATUS_DATA_ERROR, ERROR_CRC,

    STATUS_CRC_ERROR, ERROR_CRC,

    STATUS_SHARING_VIOLATION, ERROR_SHARING_VIOLATION,

    STATUS_QUOTA_EXCEEDED, ERROR_NOT_ENOUGH_QUOTA,

    STATUS_MUTANT_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_SEMAPHORE_LIMIT_EXCEEDED, ERROR_TOO_MANY_POSTS,

    STATUS_DISK_FULL, ERROR_DISK_FULL,

    STATUS_LOCK_NOT_GRANTED, ERROR_LOCK_VIOLATION,

    STATUS_FILE_LOCK_CONFLICT, ERROR_LOCK_VIOLATION,  // FIX, FIX - is this right?

    STATUS_NOT_A_DIRECTORY, ERROR_DIRECTORY,          // FIX, FIX - is this right?

    STATUS_CANNOT_MAKE, ERROR_CANNOT_MAKE,

    STATUS_UNKNOWN_REVISION, ERROR_UNKNOWN_REVISION,

    STATUS_REVISION_MISMATCH, ERROR_REVISION_MISMATCH,

    STATUS_INVALID_OWNER, ERROR_INVALID_OWNER,

    STATUS_INVALID_PRIMARY_GROUP, ERROR_INVALID_PRIMARY_GROUP,

    STATUS_NO_IMPERSONATION_TOKEN, ERROR_NO_IMPERSONATION_TOKEN,

    STATUS_CANT_DISABLE_MANDATORY, ERROR_CANT_DISABLE_MANDATORY,

    STATUS_NO_LOGON_SERVERS, ERROR_NO_LOGON_SERVERS,
    STATUS_DOMAIN_CONTROLLER_NOT_FOUND, ERROR_DOMAIN_CONTROLLER_NOT_FOUND,

    STATUS_NO_SUCH_LOGON_SESSION, ERROR_NO_SUCH_LOGON_SESSION,

    STATUS_INVALID_ACCOUNT_NAME, ERROR_INVALID_ACCOUNT_NAME,

    STATUS_USER_EXISTS, ERROR_USER_EXISTS,

    STATUS_NO_SUCH_USER, ERROR_NO_SUCH_USER,

    STATUS_GROUP_EXISTS, ERROR_GROUP_EXISTS,

    STATUS_NO_SUCH_GROUP, ERROR_NO_SUCH_GROUP,

    STATUS_SPECIAL_GROUP, ERROR_SPECIAL_GROUP,

    STATUS_MEMBER_IN_GROUP, ERROR_MEMBER_IN_GROUP,

    STATUS_MEMBER_NOT_IN_GROUP, ERROR_MEMBER_NOT_IN_GROUP,

    STATUS_LAST_ADMIN, ERROR_LAST_ADMIN,

    STATUS_WRONG_PASSWORD, ERROR_INVALID_PASSWORD,
    STATUS_WRONG_PASSWORD_CORE, ERROR_INVALID_PASSWORD,

    STATUS_ILL_FORMED_PASSWORD, ERROR_ILL_FORMED_PASSWORD,

    STATUS_PASSWORD_RESTRICTION, ERROR_PASSWORD_RESTRICTION,

    STATUS_PASSWORD_EXPIRED, ERROR_PASSWORD_EXPIRED,
    STATUS_PASSWORD_MUST_CHANGE, ERROR_PASSWORD_MUST_CHANGE,

    STATUS_ACCOUNT_DISABLED, ERROR_ACCOUNT_DISABLED,
    STATUS_ACCOUNT_LOCKED_OUT, ERROR_ACCOUNT_LOCKED_OUT,

    STATUS_NONE_MAPPED, ERROR_NONE_MAPPED,

    STATUS_TOO_MANY_LUIDS_REQUESTED, ERROR_TOO_MANY_LUIDS_REQUESTED,

    STATUS_LUIDS_EXHAUSTED, ERROR_LUIDS_EXHAUSTED,

    STATUS_INVALID_SUB_AUTHORITY, ERROR_INVALID_SUB_AUTHORITY,

    STATUS_INVALID_ACL, ERROR_INVALID_ACL,

    STATUS_INVALID_SID, ERROR_INVALID_SID,

    STATUS_INVALID_SECURITY_DESCR, ERROR_INVALID_SECURITY_DESCR,

    STATUS_PROCEDURE_NOT_FOUND, ERROR_PROC_NOT_FOUND,

    STATUS_BAD_INITIAL_PC, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_FILE_FOR_SECTION, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_FORMAT, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_MP_UP_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_IMAGE_CHECKSUM_MISMATCH, ERROR_BAD_EXE_FORMAT,
    STATUS_INVALID_IMAGE_PROTECT, ERROR_BAD_EXE_FORMAT,

    STATUS_NO_TOKEN, ERROR_NO_TOKEN,

    STATUS_RANGE_NOT_LOCKED, ERROR_NOT_LOCKED,

    STATUS_SERVER_DISABLED, ERROR_SERVER_DISABLED,

    STATUS_SERVER_NOT_DISABLED, ERROR_SERVER_NOT_DISABLED,

    STATUS_INVALID_ID_AUTHORITY, ERROR_INVALID_ID_AUTHORITY,

    STATUS_ALLOTTED_SPACE_EXCEEDED, ERROR_ALLOTTED_SPACE_EXCEEDED,

    STATUS_TOO_MANY_PAGING_FILES, ERROR_NOT_ENOUGH_MEMORY,
    STATUS_INSUFFICIENT_RESOURCES, ERROR_NO_SYSTEM_RESOURCES,

    STATUS_INSUFF_SERVER_RESOURCES, ERROR_NOT_ENOUGH_SERVER_MEMORY,

    STATUS_FILE_INVALID, ERROR_FILE_INVALID,
    STATUS_MAPPED_FILE_SIZE_ZERO, ERROR_FILE_INVALID,

    STATUS_DEVICE_PAPER_EMPTY, ERROR_OUT_OF_PAPER,

    STATUS_DEVICE_POWERED_OFF, ERROR_NOT_READY,
    STATUS_DEVICE_OFF_LINE, ERROR_NOT_READY,

    STATUS_DEVICE_DATA_ERROR, ERROR_CRC,

    STATUS_DEVICE_NOT_READY, ERROR_NOT_READY,
    STATUS_DEVICE_NOT_CONNECTED, ERROR_DEVICE_NOT_CONNECTED,
    STATUS_DEVICE_POWER_FAILURE, ERROR_NOT_READY,

    STATUS_NOT_FOUND, ERROR_NOT_FOUND,
    STATUS_NO_MATCH, ERROR_NO_MATCH,
    STATUS_PROPSET_NOT_FOUND, ERROR_SET_NOT_FOUND,


    STATUS_DEVICE_BUSY, ERROR_BUSY,                   // FIX, FIX - is there a better choice?

    STATUS_FREE_VM_NOT_AT_BASE, ERROR_INVALID_ADDRESS,
    STATUS_MEMORY_NOT_ALLOCATED, ERROR_INVALID_ADDRESS,

    STATUS_NOT_SAME_DEVICE, ERROR_NOT_SAME_DEVICE,

    STATUS_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,

    STATUS_REMOTE_NOT_LISTENING, ERROR_REM_NOT_LIST,

    STATUS_DUPLICATE_NAME, ERROR_DUP_NAME,

    STATUS_BAD_NETWORK_PATH, ERROR_BAD_NETPATH,

    STATUS_NETWORK_BUSY, ERROR_NETWORK_BUSY,

    STATUS_ONLY_IF_CONNECTED, ERROR_ONLY_IF_CONNECTED,

    STATUS_DEVICE_DOES_NOT_EXIST, ERROR_DEV_NOT_EXIST,

    STATUS_TOO_MANY_COMMANDS, ERROR_TOO_MANY_CMDS,

    STATUS_ADAPTER_HARDWARE_ERROR, ERROR_ADAP_HDW_ERR,

    STATUS_REDIRECTOR_NOT_STARTED, ERROR_PATH_NOT_FOUND,

    STATUS_INVALID_EA_NAME, ERROR_INVALID_EA_NAME,

    STATUS_EA_LIST_INCONSISTENT, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EA_TOO_LARGE, ERROR_EA_LIST_INCONSISTENT,
    STATUS_INVALID_EA_FLAG, ERROR_EA_LIST_INCONSISTENT,
    STATUS_EAS_NOT_SUPPORTED, ERROR_EAS_NOT_SUPPORTED,

    STATUS_FILE_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_EA_CORRUPT_ERROR, ERROR_FILE_CORRUPT,
    STATUS_NONEXISTENT_EA_ENTRY, ERROR_FILE_CORRUPT,
    STATUS_NO_EAS_ON_FILE, ERROR_FILE_CORRUPT,

    STATUS_NOT_A_REPARSE_POINT, ERROR_NOT_A_REPARSE_POINT,
    STATUS_IO_REPARSE_TAG_INVALID, ERROR_REPARSE_TAG_INVALID,
    STATUS_IO_REPARSE_TAG_MISMATCH, ERROR_REPARSE_TAG_MISMATCH,
    STATUS_IO_REPARSE_TAG_NOT_HANDLED, ERROR_CANT_ACCESS_FILE,
    STATUS_REPARSE_POINT_NOT_RESOLVED, ERROR_CANT_RESOLVE_FILENAME,
    STATUS_DIRECTORY_IS_A_REPARSE_POINT, ERROR_BAD_PATHNAME,
    STATUS_REPARSE_ATTRIBUTE_CONFLICT, ERROR_REPARSE_ATTRIBUTE_CONFLICT,
    STATUS_IO_REPARSE_DATA_INVALID, ERROR_INVALID_REPARSE_DATA,

    STATUS_FILE_IS_OFFLINE, ERROR_FILE_OFFLINE,

    STATUS_INVALID_NETWORK_RESPONSE, ERROR_BAD_NET_RESP,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,
    STATUS_UNEXPECTED_NETWORK_ERROR, ERROR_UNEXP_NET_ERR,

    STATUS_USER_SESSION_DELETED, ERROR_UNEXP_NET_ERR,

    STATUS_BAD_REMOTE_ADAPTER, ERROR_BAD_REM_ADAP,

    STATUS_PRINT_QUEUE_FULL, ERROR_PRINTQ_FULL,

    STATUS_NO_SPOOL_SPACE, ERROR_NO_SPOOL_SPACE,

    STATUS_PRINT_CANCELLED, ERROR_PRINT_CANCELLED,

    STATUS_NETWORK_NAME_DELETED, ERROR_NETNAME_DELETED,

    STATUS_NETWORK_ACCESS_DENIED, ERROR_NETWORK_ACCESS_DENIED,

    STATUS_BAD_DEVICE_TYPE, ERROR_BAD_DEV_TYPE,

    STATUS_BAD_NETWORK_NAME, ERROR_BAD_NET_NAME,

    STATUS_TOO_MANY_NAMES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_GUIDS_REQUESTED, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_ADDRESSES, ERROR_TOO_MANY_NAMES,
    STATUS_TOO_MANY_NODES, ERROR_TOO_MANY_NAMES,

    STATUS_TOO_MANY_SESSIONS, ERROR_TOO_MANY_SESS,

    STATUS_SHARING_PAUSED, ERROR_SHARING_PAUSED,

    STATUS_REQUEST_NOT_ACCEPTED, ERROR_REQ_NOT_ACCEP,

    STATUS_REDIRECTOR_PAUSED, ERROR_REDIR_PAUSED,

    STATUS_NET_WRITE_FAULT, ERROR_NET_WRITE_FAULT,

    STATUS_VIRTUAL_CIRCUIT_CLOSED, ERROR_VC_DISCONNECTED,

    STATUS_INVALID_PIPE_STATE, ERROR_BAD_PIPE,
    STATUS_INVALID_READ_MODE, ERROR_BAD_PIPE,

    STATUS_PIPE_CLOSING, ERROR_NO_DATA,
    STATUS_PIPE_EMPTY, ERROR_NO_DATA,

    STATUS_PIPE_CONNECTED, ERROR_PIPE_CONNECTED,

    STATUS_PIPE_DISCONNECTED, ERROR_PIPE_NOT_CONNECTED,

    STATUS_PIPE_LISTENING, ERROR_PIPE_LISTENING,

    STATUS_PIPE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_INSTANCE_NOT_AVAILABLE, ERROR_PIPE_BUSY,
    STATUS_PIPE_BUSY, ERROR_PIPE_BUSY,

    STATUS_PIPE_BROKEN, ERROR_BROKEN_PIPE,

    STATUS_DIRECTORY_NOT_EMPTY, ERROR_DIR_NOT_EMPTY,

    STATUS_TOO_MANY_OPENED_FILES, ERROR_TOO_MANY_OPEN_FILES,

    STATUS_IO_TIMEOUT, ERROR_SEM_TIMEOUT,

    STATUS_CANCELLED, ERROR_OPERATION_ABORTED,

    STATUS_UNRECOGNIZED_MEDIA, ERROR_UNRECOGNIZED_MEDIA,

    STATUS_INVALID_LEVEL, ERROR_INVALID_LEVEL,

    STATUS_UNRECOGNIZED_VOLUME, ERROR_UNRECOGNIZED_VOLUME,

    STATUS_MEDIA_WRITE_PROTECTED, ERROR_WRITE_PROTECT,
    STATUS_TOO_LATE, ERROR_WRITE_PROTECT,

    STATUS_SUCCESS, NO_ERROR,

    STATUS_FULLSCREEN_MODE, ERROR_FULLSCREEN_MODE,

    STATUS_END_OF_MEDIA, ERROR_END_OF_MEDIA,

    STATUS_EOM_OVERFLOW, ERROR_EOM_OVERFLOW,

    STATUS_BEGINNING_OF_MEDIA, ERROR_BEGINNING_OF_MEDIA,

    STATUS_MEDIA_CHANGED, ERROR_MEDIA_CHANGED,

    STATUS_BUS_RESET, ERROR_BUS_RESET,

    STATUS_FILEMARK_DETECTED, ERROR_FILEMARK_DETECTED,

    STATUS_SETMARK_DETECTED, ERROR_SETMARK_DETECTED,

    STATUS_NO_DATA_DETECTED, ERROR_NO_DATA_DETECTED,

    STATUS_PARTITION_FAILURE, ERROR_PARTITION_FAILURE,

    STATUS_INVALID_BLOCK_LENGTH, ERROR_INVALID_BLOCK_LENGTH,

    STATUS_DEVICE_NOT_PARTITIONED, ERROR_DEVICE_NOT_PARTITIONED,

    STATUS_UNABLE_TO_LOCK_MEDIA, ERROR_UNABLE_TO_LOCK_MEDIA,

    STATUS_UNABLE_TO_UNLOAD_MEDIA, ERROR_UNABLE_TO_UNLOAD_MEDIA,

    STATUS_UNMAPPABLE_CHARACTER, ERROR_NO_UNICODE_TRANSLATION,

    STATUS_NOT_ALL_ASSIGNED, ERROR_NOT_ALL_ASSIGNED,

    STATUS_SOME_NOT_MAPPED, ERROR_SOME_NOT_MAPPED,

    STATUS_NO_QUOTAS_FOR_ACCOUNT, ERROR_NO_QUOTAS_FOR_ACCOUNT,

    STATUS_LOCAL_USER_SESSION_KEY, ERROR_LOCAL_USER_SESSION_KEY,

    STATUS_NULL_LM_PASSWORD, ERROR_NULL_LM_PASSWORD,

    STATUS_BAD_INHERITANCE_ACL, ERROR_BAD_INHERITANCE_ACL,

    STATUS_INVALID_GROUP_ATTRIBUTES, ERROR_INVALID_GROUP_ATTRIBUTES,

    STATUS_BAD_IMPERSONATION_LEVEL, ERROR_BAD_IMPERSONATION_LEVEL,

    STATUS_CANT_OPEN_ANONYMOUS, ERROR_CANT_OPEN_ANONYMOUS,

    STATUS_BAD_VALIDATION_CLASS, ERROR_BAD_VALIDATION_CLASS,

    STATUS_BAD_TOKEN_TYPE, ERROR_BAD_TOKEN_TYPE,

    STATUS_BAD_MASTER_BOOT_RECORD, ERROR_INVALID_PARAMETER,

    STATUS_NO_SECURITY_ON_OBJECT, ERROR_NO_SECURITY_ON_OBJECT,

    STATUS_CANT_ACCESS_DOMAIN_INFO, ERROR_CANT_ACCESS_DOMAIN_INFO,

    STATUS_INVALID_SERVER_STATE, ERROR_INVALID_SERVER_STATE,

    STATUS_INVALID_DOMAIN_STATE, ERROR_INVALID_DOMAIN_STATE,

    STATUS_INVALID_DOMAIN_ROLE, ERROR_INVALID_DOMAIN_ROLE,

    STATUS_NO_SUCH_DOMAIN, ERROR_NO_SUCH_DOMAIN,

    STATUS_DOMAIN_EXISTS, ERROR_DOMAIN_EXISTS,

    STATUS_DOMAIN_LIMIT_EXCEEDED, ERROR_DOMAIN_LIMIT_EXCEEDED,

    STATUS_OPLOCK_NOT_GRANTED, ERROR_OPLOCK_NOT_GRANTED,
    STATUS_INVALID_OPLOCK_PROTOCOL, ERROR_INVALID_OPLOCK_PROTOCOL,

    STATUS_INTERNAL_DB_CORRUPTION, ERROR_INTERNAL_DB_CORRUPTION,

    STATUS_INTERNAL_ERROR, ERROR_INTERNAL_ERROR,

    STATUS_GENERIC_NOT_MAPPED, ERROR_GENERIC_NOT_MAPPED,

    STATUS_BAD_DESCRIPTOR_FORMAT, ERROR_BAD_DESCRIPTOR_FORMAT,

    STATUS_NOT_LOGON_PROCESS, ERROR_NOT_LOGON_PROCESS,

    STATUS_LOGON_SESSION_EXISTS, ERROR_LOGON_SESSION_EXISTS,

    STATUS_NO_SUCH_PACKAGE, ERROR_NO_SUCH_PACKAGE,

    STATUS_BAD_LOGON_SESSION_STATE, ERROR_BAD_LOGON_SESSION_STATE,

    STATUS_LOGON_SESSION_COLLISION, ERROR_LOGON_SESSION_COLLISION,

    STATUS_INVALID_LOGON_TYPE, ERROR_INVALID_LOGON_TYPE,

    STATUS_SPECIAL_ACCOUNT, ERROR_SPECIAL_ACCOUNT,

    STATUS_SPECIAL_USER, ERROR_SPECIAL_USER,

    STATUS_MEMBERS_PRIMARY_GROUP, ERROR_MEMBERS_PRIMARY_GROUP,

    STATUS_TOKEN_ALREADY_IN_USE, ERROR_TOKEN_ALREADY_IN_USE,

    STATUS_NO_SUCH_ALIAS, ERROR_NO_SUCH_ALIAS,

    STATUS_MEMBER_NOT_IN_ALIAS, ERROR_MEMBER_NOT_IN_ALIAS,

    STATUS_MEMBER_IN_ALIAS, ERROR_MEMBER_IN_ALIAS,

    STATUS_ALIAS_EXISTS, ERROR_ALIAS_EXISTS,

    STATUS_LOGON_NOT_GRANTED, ERROR_LOGON_NOT_GRANTED,

    STATUS_TOO_MANY_SECRETS, ERROR_TOO_MANY_SECRETS,

    STATUS_SECRET_TOO_LONG, ERROR_SECRET_TOO_LONG,

    STATUS_INTERNAL_DB_ERROR, ERROR_INTERNAL_DB_ERROR,

    STATUS_TOO_MANY_CONTEXT_IDS, ERROR_TOO_MANY_CONTEXT_IDS,

    STATUS_LOGON_TYPE_NOT_GRANTED, ERROR_LOGON_TYPE_NOT_GRANTED,

    STATUS_NT_CROSS_ENCRYPTION_REQUIRED, ERROR_NT_CROSS_ENCRYPTION_REQUIRED,

    STATUS_NO_SUCH_MEMBER, ERROR_NO_SUCH_MEMBER,

    STATUS_INVALID_MEMBER, ERROR_INVALID_MEMBER,

    STATUS_TOO_MANY_SIDS, ERROR_TOO_MANY_SIDS,

    STATUS_LM_CROSS_ENCRYPTION_REQUIRED, ERROR_LM_CROSS_ENCRYPTION_REQUIRED,

    STATUS_MESSAGE_NOT_FOUND, ERROR_MR_MID_NOT_FOUND,

    STATUS_LOCAL_DISCONNECT, ERROR_NETNAME_DELETED,
    STATUS_REMOTE_DISCONNECT, ERROR_NETNAME_DELETED,

    STATUS_REMOTE_RESOURCES, ERROR_REM_NOT_LIST,

    STATUS_LINK_FAILED, ERROR_UNEXP_NET_ERR,
    STATUS_LINK_TIMEOUT, ERROR_UNEXP_NET_ERR,

    STATUS_INVALID_CONNECTION, ERROR_UNEXP_NET_ERR,
    STATUS_INVALID_ADDRESS, ERROR_UNEXP_NET_ERR,

    STATUS_IO_DEVICE_ERROR, ERROR_IO_DEVICE,
    STATUS_DEVICE_PROTOCOL_ERROR, ERROR_IO_DEVICE,
    STATUS_DRIVER_INTERNAL_ERROR, ERROR_IO_DEVICE,

    STATUS_INVALID_DEVICE_STATE, ERROR_BAD_COMMAND,

    STATUS_DEVICE_CONFIGURATION_ERROR, ERROR_INVALID_PARAMETER,

    STATUS_SOURCE_ELEMENT_EMPTY,       ERROR_SOURCE_ELEMENT_EMPTY,
    STATUS_DESTINATION_ELEMENT_FULL,   ERROR_DESTINATION_ELEMENT_FULL,
    STATUS_ILLEGAL_ELEMENT_ADDRESS,    ERROR_ILLEGAL_ELEMENT_ADDRESS,
    STATUS_MAGAZINE_NOT_PRESENT,       ERROR_MAGAZINE_NOT_PRESENT,
    STATUS_REINITIALIZATION_NEEDED,    ERROR_DEVICE_REINITIALIZATION_NEEDED,
    STATUS_DEVICE_REQUIRES_CLEANING,   ERROR_DEVICE_REQUIRES_CLEANING,
    STATUS_DEVICE_DOOR_OPEN,           ERROR_DEVICE_DOOR_OPEN,
    STATUS_TRANSPORT_FULL,             ERROR_TRANSPORT_FULL,

    STATUS_ENCRYPTION_FAILED,          ERROR_ACCESS_DENIED,
    STATUS_DECRYPTION_FAILED,          ERROR_ACCESS_DENIED,
    STATUS_NO_RECOVERY_POLICY,         ERROR_ACCESS_DENIED,
    STATUS_NO_EFS,                     ERROR_ACCESS_DENIED,
    STATUS_WRONG_EFS,                  ERROR_ACCESS_DENIED,
    STATUS_NO_USER_KEYS,               ERROR_ACCESS_DENIED,
    STATUS_FILE_NOT_ENCRYPTED,         ERROR_FILE_NOT_ENCRYPTED,
    STATUS_NOT_EXPORT_FORMAT,          ERROR_NOT_EXPORT_FORMAT,
    STATUS_FILE_ENCRYPTED,             ERROR_FILE_ENCRYPTED,

    STATUS_INVALID_USER_BUFFER, ERROR_INVALID_USER_BUFFER,

    STATUS_SERIAL_NO_DEVICE_INITED, ERROR_SERIAL_NO_DEVICE,

    STATUS_SHARED_IRQ_BUSY, ERROR_IRQ_BUSY,

    STATUS_SERIAL_MORE_WRITES, ERROR_MORE_WRITES,

    STATUS_SERIAL_COUNTER_TIMEOUT, ERROR_COUNTER_TIMEOUT,

    STATUS_DISK_RECALIBRATE_FAILED, ERROR_DISK_RECALIBRATE_FAILED,

    STATUS_DISK_OPERATION_FAILED, ERROR_DISK_OPERATION_FAILED,

    STATUS_DISK_RESET_FAILED, ERROR_DISK_RESET_FAILED,

    STATUS_EVENTLOG_FILE_CORRUPT, ERROR_EVENTLOG_FILE_CORRUPT,

    STATUS_EVENTLOG_CANT_START, ERROR_EVENTLOG_CANT_START,

    STATUS_NETLOGON_NOT_STARTED, ERROR_NETLOGON_NOT_STARTED,

    STATUS_ACCOUNT_EXPIRED, ERROR_ACCOUNT_EXPIRED,

    STATUS_NETWORK_CREDENTIAL_CONFLICT, ERROR_SESSION_CREDENTIAL_CONFLICT,

    STATUS_REMOTE_SESSION_LIMIT, ERROR_REMOTE_SESSION_LIMIT_EXCEEDED,

    STATUS_INVALID_BUFFER_SIZE, ERROR_INVALID_USER_BUFFER,

    STATUS_INVALID_ADDRESS_COMPONENT, ERROR_INVALID_NETNAME,
    STATUS_INVALID_ADDRESS_WILDCARD, ERROR_INVALID_NETNAME,

    STATUS_ADDRESS_ALREADY_EXISTS, ERROR_DUP_NAME,

    STATUS_ADDRESS_CLOSED, ERROR_NETNAME_DELETED,
    STATUS_CONNECTION_DISCONNECTED, ERROR_NETNAME_DELETED,

    STATUS_CONNECTION_RESET, ERROR_NETNAME_DELETED,

    STATUS_TRANSACTION_ABORTED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_TIMED_OUT, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_RELEASE, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_NO_MATCH, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_RESPONDED, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_ID, ERROR_UNEXP_NET_ERR,
    STATUS_TRANSACTION_INVALID_TYPE, ERROR_UNEXP_NET_ERR,

    STATUS_NOT_SERVER_SESSION, ERROR_NOT_SUPPORTED,
    STATUS_NOT_CLIENT_SESSION, ERROR_NOT_SUPPORTED,

    STATUS_USER_MAPPED_FILE, ERROR_USER_MAPPED_FILE,

    STATUS_PLUGPLAY_NO_DEVICE, ERROR_SERVICE_DISABLED,

    RPC_NT_SERVER_UNAVAILABLE, RPC_S_SERVER_UNAVAILABLE,

    RPC_NT_INVALID_STRING_BINDING, RPC_S_INVALID_STRING_BINDING,

    RPC_NT_WRONG_KIND_OF_BINDING, RPC_S_WRONG_KIND_OF_BINDING,

    RPC_NT_PROTSEQ_NOT_SUPPORTED, RPC_S_PROTSEQ_NOT_SUPPORTED,

    RPC_NT_INVALID_RPC_PROTSEQ, RPC_S_INVALID_RPC_PROTSEQ,

    RPC_NT_INVALID_STRING_UUID, RPC_S_INVALID_STRING_UUID,

    RPC_NT_INVALID_ENDPOINT_FORMAT, RPC_S_INVALID_ENDPOINT_FORMAT,

    RPC_NT_INVALID_NET_ADDR, RPC_S_INVALID_NET_ADDR,

    RPC_NT_NO_ENDPOINT_FOUND, RPC_S_NO_ENDPOINT_FOUND,

    RPC_NT_INVALID_TIMEOUT, RPC_S_INVALID_TIMEOUT,

    RPC_NT_OBJECT_NOT_FOUND, RPC_S_OBJECT_NOT_FOUND,

    RPC_NT_ALREADY_REGISTERED, RPC_S_ALREADY_REGISTERED,

    RPC_NT_TYPE_ALREADY_REGISTERED, RPC_S_TYPE_ALREADY_REGISTERED,

    RPC_NT_ALREADY_LISTENING, RPC_S_ALREADY_LISTENING,

    RPC_NT_NO_PROTSEQS_REGISTERED, RPC_S_NO_PROTSEQS_REGISTERED,

    RPC_NT_NOT_LISTENING, RPC_S_NOT_LISTENING,

    RPC_NT_UNKNOWN_MGR_TYPE, RPC_S_UNKNOWN_MGR_TYPE,

    RPC_NT_UNKNOWN_IF, RPC_S_UNKNOWN_IF,

    RPC_NT_NO_BINDINGS, RPC_S_NO_BINDINGS,

    RPC_NT_NO_MORE_BINDINGS, RPC_S_NO_MORE_BINDINGS,

    RPC_NT_NO_PROTSEQS, RPC_S_NO_PROTSEQS,

    RPC_NT_CANT_CREATE_ENDPOINT, RPC_S_CANT_CREATE_ENDPOINT,

    RPC_NT_OUT_OF_RESOURCES, RPC_S_OUT_OF_RESOURCES,

    RPC_NT_SERVER_TOO_BUSY, RPC_S_SERVER_TOO_BUSY,

    RPC_NT_INVALID_NETWORK_OPTIONS, RPC_S_INVALID_NETWORK_OPTIONS,

    RPC_NT_NO_CALL_ACTIVE, RPC_S_NO_CALL_ACTIVE,

    RPC_NT_CALL_FAILED, RPC_S_CALL_FAILED,

    RPC_NT_CALL_FAILED_DNE, RPC_S_CALL_FAILED_DNE,

    RPC_NT_PROTOCOL_ERROR, RPC_S_PROTOCOL_ERROR,

    RPC_NT_UNSUPPORTED_TRANS_SYN, RPC_S_UNSUPPORTED_TRANS_SYN,

    RPC_NT_UNSUPPORTED_TYPE, RPC_S_UNSUPPORTED_TYPE,

    RPC_NT_INVALID_TAG, RPC_S_INVALID_TAG,

    RPC_NT_INVALID_BOUND, RPC_S_INVALID_BOUND,

    RPC_NT_NO_ENTRY_NAME, RPC_S_NO_ENTRY_NAME,

    RPC_NT_INVALID_NAME_SYNTAX, RPC_S_INVALID_NAME_SYNTAX,

    RPC_NT_UNSUPPORTED_NAME_SYNTAX, RPC_S_UNSUPPORTED_NAME_SYNTAX,

    RPC_NT_UUID_NO_ADDRESS, RPC_S_UUID_NO_ADDRESS,

    RPC_NT_DUPLICATE_ENDPOINT, RPC_S_DUPLICATE_ENDPOINT,

    RPC_NT_UNKNOWN_AUTHN_TYPE, RPC_S_UNKNOWN_AUTHN_TYPE,

    RPC_NT_MAX_CALLS_TOO_SMALL, RPC_S_MAX_CALLS_TOO_SMALL,

    RPC_NT_STRING_TOO_LONG, RPC_S_STRING_TOO_LONG,

    RPC_NT_PROTSEQ_NOT_FOUND, RPC_S_PROTSEQ_NOT_FOUND,

    RPC_NT_PROCNUM_OUT_OF_RANGE, RPC_S_PROCNUM_OUT_OF_RANGE,

    RPC_NT_BINDING_HAS_NO_AUTH, RPC_S_BINDING_HAS_NO_AUTH,

    RPC_NT_UNKNOWN_AUTHN_SERVICE, RPC_S_UNKNOWN_AUTHN_SERVICE,

    RPC_NT_UNKNOWN_AUTHN_LEVEL, RPC_S_UNKNOWN_AUTHN_LEVEL,

    RPC_NT_INVALID_AUTH_IDENTITY, RPC_S_INVALID_AUTH_IDENTITY,

    RPC_NT_UNKNOWN_AUTHZ_SERVICE, RPC_S_UNKNOWN_AUTHZ_SERVICE,

    EPT_NT_INVALID_ENTRY, EPT_S_INVALID_ENTRY,

    EPT_NT_CANT_PERFORM_OP, EPT_S_CANT_PERFORM_OP,

    EPT_NT_NOT_REGISTERED, EPT_S_NOT_REGISTERED,

    RPC_NT_NOTHING_TO_EXPORT, RPC_S_NOTHING_TO_EXPORT,

    RPC_NT_INCOMPLETE_NAME, RPC_S_INCOMPLETE_NAME,

    RPC_NT_INVALID_VERS_OPTION, RPC_S_INVALID_VERS_OPTION,

    RPC_NT_NO_MORE_MEMBERS, RPC_S_NO_MORE_MEMBERS,

    RPC_NT_NOT_ALL_OBJS_UNEXPORTED, RPC_S_NOT_ALL_OBJS_UNEXPORTED,

    RPC_NT_INTERFACE_NOT_FOUND, RPC_S_INTERFACE_NOT_FOUND,

    RPC_NT_ENTRY_ALREADY_EXISTS, RPC_S_ENTRY_ALREADY_EXISTS,

    RPC_NT_ENTRY_NOT_FOUND, RPC_S_ENTRY_NOT_FOUND,

    RPC_NT_NAME_SERVICE_UNAVAILABLE, RPC_S_NAME_SERVICE_UNAVAILABLE,

    RPC_NT_INVALID_NAF_ID, RPC_S_INVALID_NAF_ID,

    RPC_NT_CANNOT_SUPPORT, RPC_S_CANNOT_SUPPORT,

    RPC_NT_NO_CONTEXT_AVAILABLE, RPC_S_NO_CONTEXT_AVAILABLE,

    RPC_NT_INTERNAL_ERROR, RPC_S_INTERNAL_ERROR,

    RPC_NT_ZERO_DIVIDE, RPC_S_ZERO_DIVIDE,

    RPC_NT_ADDRESS_ERROR, RPC_S_ADDRESS_ERROR,

    RPC_NT_FP_DIV_ZERO, RPC_S_FP_DIV_ZERO,

    RPC_NT_FP_UNDERFLOW, RPC_S_FP_UNDERFLOW,

    RPC_NT_FP_OVERFLOW, RPC_S_FP_OVERFLOW,

    RPC_NT_NO_MORE_ENTRIES, RPC_X_NO_MORE_ENTRIES,

    RPC_NT_SS_CHAR_TRANS_OPEN_FAIL, RPC_X_SS_CHAR_TRANS_OPEN_FAIL,

    RPC_NT_SS_CHAR_TRANS_SHORT_FILE, RPC_X_SS_CHAR_TRANS_SHORT_FILE,

    RPC_NT_SS_CONTEXT_MISMATCH, ERROR_INVALID_HANDLE,

    RPC_NT_SS_CONTEXT_DAMAGED, RPC_X_SS_CONTEXT_DAMAGED,

    RPC_NT_SS_HANDLES_MISMATCH, RPC_X_SS_HANDLES_MISMATCH,

    RPC_NT_SS_CANNOT_GET_CALL_HANDLE, RPC_X_SS_CANNOT_GET_CALL_HANDLE,

    RPC_NT_NULL_REF_POINTER, RPC_X_NULL_REF_POINTER,

    RPC_NT_ENUM_VALUE_OUT_OF_RANGE, RPC_X_ENUM_VALUE_OUT_OF_RANGE,

    RPC_NT_BYTE_COUNT_TOO_SMALL, RPC_X_BYTE_COUNT_TOO_SMALL,

    RPC_NT_BAD_STUB_DATA, RPC_X_BAD_STUB_DATA,

    RPC_NT_INVALID_OBJECT, RPC_S_INVALID_OBJECT,

    STATUS_NO_TRUST_LSA_SECRET, ERROR_NO_TRUST_LSA_SECRET,

    STATUS_NO_TRUST_SAM_ACCOUNT, ERROR_NO_TRUST_SAM_ACCOUNT,

    STATUS_TRUSTED_DOMAIN_FAILURE, ERROR_TRUSTED_DOMAIN_FAILURE,

    STATUS_TRUSTED_RELATIONSHIP_FAILURE, ERROR_TRUSTED_RELATIONSHIP_FAILURE,

    STATUS_TRUST_FAILURE, ERROR_TRUST_FAILURE,

    RPC_NT_CALL_IN_PROGRESS, RPC_S_CALL_IN_PROGRESS,

    STATUS_LOG_FILE_FULL, ERROR_LOG_FILE_FULL,

    STATUS_EVENTLOG_FILE_CHANGED, ERROR_EVENTLOG_FILE_CHANGED,

    STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT, ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT,

    STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT, ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT,

    STATUS_NOLOGON_SERVER_TRUST_ACCOUNT, ERROR_NOLOGON_SERVER_TRUST_ACCOUNT,

    STATUS_DOMAIN_TRUST_INCONSISTENT, ERROR_DOMAIN_TRUST_INCONSISTENT,

    STATUS_NO_USER_SESSION_KEY, ERROR_NO_USER_SESSION_KEY,

    STATUS_POSSIBLE_DEADLOCK, ERROR_POSSIBLE_DEADLOCK,

    STATUS_IMAGE_ALREADY_LOADED, ERROR_SERVICE_ALREADY_RUNNING,

    RPC_NT_GROUP_MEMBER_NOT_FOUND, RPC_S_GROUP_MEMBER_NOT_FOUND,

    RPC_NT_NO_INTERFACES, RPC_S_NO_INTERFACES,

    RPC_NT_CALL_CANCELLED, RPC_S_CALL_CANCELLED,

    RPC_NT_BINDING_INCOMPLETE, RPC_S_BINDING_INCOMPLETE,

    RPC_NT_COMM_FAILURE, RPC_S_COMM_FAILURE,

    RPC_NT_UNSUPPORTED_AUTHN_LEVEL, RPC_S_UNSUPPORTED_AUTHN_LEVEL,

    RPC_NT_NO_PRINC_NAME, RPC_S_NO_PRINC_NAME,

    RPC_NT_NOT_RPC_ERROR, RPC_S_NOT_RPC_ERROR,

    RPC_NT_UUID_LOCAL_ONLY, RPC_S_UUID_LOCAL_ONLY,

    RPC_NT_SEC_PKG_ERROR, RPC_S_SEC_PKG_ERROR,

    RPC_NT_NOT_CANCELLED, RPC_S_NOT_CANCELLED,

    RPC_NT_INVALID_ES_ACTION, RPC_X_INVALID_ES_ACTION,
    RPC_NT_WRONG_ES_VERSION, RPC_X_WRONG_ES_VERSION,
    RPC_NT_WRONG_STUB_VERSION, RPC_X_WRONG_STUB_VERSION,

    RPC_NT_INVALID_PIPE_OBJECT,    RPC_X_INVALID_PIPE_OBJECT,
//    RPC_NT_INVALID_PIPE_OPERATION, RPC_X_INVALID_PIPE_OPERATION,
    RPC_NT_WRONG_PIPE_VERSION,     RPC_X_WRONG_PIPE_VERSION,

    EPT_NT_CANT_CREATE,            EPT_S_CANT_CREATE,

    RPC_NT_SEND_INCOMPLETE,        RPC_S_SEND_INCOMPLETE,
    RPC_NT_INVALID_ASYNC_HANDLE,   RPC_S_INVALID_ASYNC_HANDLE,
    RPC_NT_INVALID_ASYNC_CALL,     RPC_S_INVALID_ASYNC_CALL,
    RPC_NT_PIPE_CLOSED,            RPC_X_PIPE_CLOSED,
    RPC_NT_PIPE_EMPTY,             RPC_X_PIPE_EMPTY,
    RPC_NT_PIPE_DISCIPLINE_ERROR,  RPC_X_PIPE_DISCIPLINE_ERROR,

    STATUS_NO_BROWSER_SERVERS_FOUND, ERROR_NO_BROWSER_SERVERS_FOUND,

    STATUS_MAPPED_ALIGNMENT, ERROR_MAPPED_ALIGNMENT,

    STATUS_CONNECTION_IN_USE, ERROR_DEVICE_IN_USE,

    STATUS_VERIFY_REQUIRED, ERROR_MEDIA_CHANGED,

    STATUS_ALREADY_DISCONNECTED, ERROR_ACTIVE_CONNECTIONS,

    STATUS_CONNECTION_REFUSED, ERROR_CONNECTION_REFUSED,

    STATUS_GRACEFUL_DISCONNECT, ERROR_GRACEFUL_DISCONNECT,

    STATUS_ADDRESS_ALREADY_ASSOCIATED, ERROR_ADDRESS_ALREADY_ASSOCIATED,

    STATUS_ADDRESS_NOT_ASSOCIATED, ERROR_ADDRESS_NOT_ASSOCIATED,

    STATUS_CONNECTION_INVALID, ERROR_CONNECTION_INVALID,

    STATUS_CONNECTION_ACTIVE, ERROR_CONNECTION_ACTIVE,

    STATUS_NETWORK_UNREACHABLE, ERROR_NETWORK_UNREACHABLE,

    STATUS_HOST_UNREACHABLE, ERROR_HOST_UNREACHABLE,

    STATUS_PROTOCOL_UNREACHABLE, ERROR_PROTOCOL_UNREACHABLE,

    STATUS_PORT_UNREACHABLE, ERROR_PORT_UNREACHABLE,

    STATUS_REQUEST_ABORTED, ERROR_REQUEST_ABORTED,

    STATUS_CONNECTION_ABORTED, ERROR_CONNECTION_ABORTED,

    STATUS_CONNECTION_COUNT_LIMIT, ERROR_CONNECTION_COUNT_LIMIT,

    STATUS_PATH_NOT_COVERED, ERROR_HOST_UNREACHABLE,

    STATUS_LOGIN_TIME_RESTRICTION, ERROR_LOGIN_TIME_RESTRICTION,
    STATUS_LOGIN_WKSTA_RESTRICTION, ERROR_LOGIN_WKSTA_RESTRICTION,
    STATUS_LICENSE_QUOTA_EXCEEDED, ERROR_LICENSE_QUOTA_EXCEEDED,

    STATUS_RESOURCE_NOT_OWNED, ERROR_NOT_OWNER,

    STATUS_DUPLICATE_OBJECTID, STATUS_DUPLICATE_OBJECTID,
    STATUS_OBJECTID_EXISTS, STATUS_OBJECTID_EXISTS,
    SEC_E_INSUFFICIENT_MEMORY, ERROR_NO_SYSTEM_RESOURCES,
    SEC_E_INVALID_HANDLE, ERROR_INVALID_HANDLE,
    SEC_E_UNSUPPORTED_FUNCTION, ERROR_INVALID_FUNCTION,
    SEC_E_TARGET_UNKNOWN, ERROR_BAD_NETPATH,
    SEC_E_INTERNAL_ERROR, ERROR_INTERNAL_ERROR,
    SEC_E_SECPKG_NOT_FOUND, ERROR_NO_SUCH_PACKAGE,
    SEC_E_NOT_OWNER, ERROR_NOT_OWNER,
    SEC_E_CANNOT_INSTALL, ERROR_NO_SUCH_PACKAGE,
    SEC_E_INVALID_TOKEN, ERROR_INVALID_PARAMETER,
    SEC_E_CANNOT_PACK, ERROR_INVALID_PARAMETER,
    SEC_E_QOP_NOT_SUPPORTED, ERROR_NOT_SUPPORTED,
    SEC_E_NO_IMPERSONATION, ERROR_CANNOT_IMPERSONATE,
    SEC_E_LOGON_DENIED, ERROR_LOGON_FAILURE,
    SEC_E_UNKNOWN_CREDENTIALS, ERROR_INVALID_PARAMETER,
    SEC_E_INCOMPLETE_CREDENTIALS, ERROR_INVALID_PARAMETER,
    SEC_E_NO_CREDENTIALS, ERROR_NO_SUCH_LOGON_SESSION,
    SEC_E_MESSAGE_ALTERED, ERROR_ACCESS_DENIED,
    SEC_E_OUT_OF_SEQUENCE, ERROR_ACCESS_DENIED,
    SEC_E_NO_AUTHENTICATING_AUTHORITY, ERROR_NO_LOGON_SERVERS,
    SEC_E_BAD_PKGID, ERROR_NO_SUCH_PACKAGE,
    SEC_E_WRONG_PRINCIPAL, ERROR_WRONG_TARGET_NAME,
    SEC_E_INCOMPLETE_MESSAGE, ERROR_INVALID_USER_BUFFER,
    SEC_E_BUFFER_TOO_SMALL, ERROR_INSUFFICIENT_BUFFER,
    SEC_E_UNTRUSTED_ROOT, ERROR_TRUST_FAILURE,
    SEC_E_ILLEGAL_MESSAGE, ERROR_INVALID_PARAMETER,
    SEC_E_CERT_UNKNOWN, ERROR_INVALID_PARAMETER,
    SEC_E_CERT_EXPIRED, ERROR_PASSWORD_EXPIRED,
    SEC_E_ENCRYPT_FAILURE, ERROR_ENCRYPTION_FAILED,
    SEC_E_DECRYPT_FAILURE, ERROR_DECRYPTION_FAILED,
    SEC_E_ALGORITHM_MISMATCH, ERROR_INVALID_FUNCTION,

    STATUS_DEVICE_REMOVED,ERROR_DEVICE_REMOVED,

    STATUS_RETRY,ERROR_RETRY,

    // Smb Server Entries

    STATUS_ENDPOINT_CLOSED,                 ERROR_DEV_NOT_EXIST,
    STATUS_DISCONNECTED,                    ERROR_DEV_NOT_EXIST,
    STATUS_NONEXISTENT_NET_NAME,            ERROR_DEV_NOT_EXIST,

    STATUS_FILES_OPEN,                      ERROR_OPEN_FILES,

    0xffffffff, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\heapdbg.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    heapdbg.c

Abstract:

    This module implements a debugging layer on top of heap allocator.

Author:

    Steve Wood (stevewo) 20-Sep-1994

Revision History:

--*/

#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"

BOOLEAN RtlpValidateHeapHdrsEnable = FALSE; // Set to TRUE if headers are being corrupted
BOOLEAN RtlpValidateHeapTagsEnable;         // Set to TRUE if tag counts are off and you want to know why

HEAP_STOP_ON_VALUES RtlpHeapStopOn;


const struct {

    ULONG Offset;
    LPSTR Description;

} RtlpHeapHeaderFieldOffsets[] = {

    FIELD_OFFSET( HEAP, Entry ),                        "Entry",
    FIELD_OFFSET( HEAP, Signature ),                    "Signature",
    FIELD_OFFSET( HEAP, Flags ),                        "Flags",
    FIELD_OFFSET( HEAP, ForceFlags ),                   "ForceFlags",
    FIELD_OFFSET( HEAP, VirtualMemoryThreshold ),       "VirtualMemoryThreshold",
    FIELD_OFFSET( HEAP, SegmentReserve ),               "SegmentReserve",
    FIELD_OFFSET( HEAP, SegmentCommit ),                "SegmentCommit",
    FIELD_OFFSET( HEAP, DeCommitFreeBlockThreshold ),   "DeCommitFreeBlockThreshold",
    FIELD_OFFSET( HEAP, DeCommitTotalFreeThreshold ),   "DeCommitTotalFreeThreshold",
    FIELD_OFFSET( HEAP, TotalFreeSize ),                "TotalFreeSize",
    FIELD_OFFSET( HEAP, MaximumAllocationSize ),        "MaximumAllocationSize",
    FIELD_OFFSET( HEAP, ProcessHeapsListIndex ),        "ProcessHeapsListIndex",
    FIELD_OFFSET( HEAP, HeaderValidateLength ),         "HeaderValidateLength",
    FIELD_OFFSET( HEAP, HeaderValidateCopy ),           "HeaderValidateCopy",
    FIELD_OFFSET( HEAP, NextAvailableTagIndex ),        "NextAvailableTagIndex",
    FIELD_OFFSET( HEAP, MaximumTagIndex ),              "MaximumTagIndex",
    FIELD_OFFSET( HEAP, TagEntries ),                   "TagEntries",
    FIELD_OFFSET( HEAP, UCRSegments ),                  "UCRSegments",
    FIELD_OFFSET( HEAP, UnusedUnCommittedRanges ),      "UnusedUnCommittedRanges",
    FIELD_OFFSET( HEAP, AlignRound ),                   "AlignRound",
    FIELD_OFFSET( HEAP, AlignMask ),                    "AlignMask",
    FIELD_OFFSET( HEAP, VirtualAllocdBlocks ),          "VirtualAllocdBlocks",
    FIELD_OFFSET( HEAP, Segments ),                     "Segments",
    FIELD_OFFSET( HEAP, u ),                            "FreeListsInUse",
    FIELD_OFFSET( HEAP, FreeListsInUseTerminate ),      "FreeListsInUseTerminate",
    FIELD_OFFSET( HEAP, AllocatorBackTraceIndex ),      "AllocatorBackTraceIndex",
    FIELD_OFFSET( HEAP, Reserved1 ),                    "Reserved1",
    FIELD_OFFSET( HEAP, PseudoTagEntries ),             "PseudoTagEntries",
    FIELD_OFFSET( HEAP, FreeLists ),                    "FreeLists",
    FIELD_OFFSET( HEAP, LockVariable ),                 "LockVariable",
    FIELD_OFFSET( HEAP, Lookaside ),                    "Lookaside",
    FIELD_OFFSET( HEAP, LookasideLockCount ),           "LookasideLockCount",
    sizeof( HEAP ),                                     "Uncommitted Ranges",
    0xFFFF, NULL
};


VOID
RtlpUpdateHeapListIndex (
    USHORT OldIndex,
    USHORT NewIndex
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (RtlpHeapStopOn.AllocTag.HeapIndex == OldIndex) {

        RtlpHeapStopOn.AllocTag.HeapIndex = NewIndex;
    }

    if (RtlpHeapStopOn.ReAllocTag.HeapIndex == OldIndex) {

        RtlpHeapStopOn.ReAllocTag.HeapIndex = NewIndex;
    }

    if (RtlpHeapStopOn.FreeTag.HeapIndex == OldIndex) {

        RtlpHeapStopOn.FreeTag.HeapIndex = NewIndex;
    }

    return;
}


BOOLEAN
RtlpValidateHeapHeaders (
    IN PHEAP Heap,
    IN BOOLEAN Recompute
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    ULONG i;
    SIZE_T n;
    SIZE_T nEqual;
    NTSTATUS Status;

    if (!RtlpValidateHeapHdrsEnable) {

        return TRUE;
    }

    if (Heap->HeaderValidateCopy == NULL) {

        n = Heap->HeaderValidateLength;

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &Heap->HeaderValidateCopy,
                                          0,
                                          &n,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return TRUE;
        }

        Recompute = TRUE;
    }

    n = Heap->HeaderValidateLength;

    if (!Recompute) {

        nEqual = RtlCompareMemory( Heap,
                                   Heap->HeaderValidateCopy,
                                   n );

    } else {

        RtlMoveMemory( Heap->HeaderValidateCopy,
                       Heap,
                       n );

        nEqual = n;
    }

    if (n != nEqual) {

        HeapDebugPrint(( "Heap %x - headers modified (%x is %x instead of %x)\n",
                         Heap,
                         (PCHAR)Heap + nEqual,
                         *(PULONG)((PCHAR)Heap + nEqual),
                         *(PULONG)((PCHAR)Heap->HeaderValidateCopy + nEqual)));

        for (i=0; RtlpHeapHeaderFieldOffsets[ i ].Description != NULL; i++) {

            if ((nEqual >= RtlpHeapHeaderFieldOffsets[ i ].Offset) &&
                (nEqual < RtlpHeapHeaderFieldOffsets[ i+1 ].Offset)) {

                DbgPrint( "    This is located in the %s field of the heap header.\n",
                                 RtlpHeapHeaderFieldOffsets[ i ].Description );

                break;
            }
        }

        return FALSE;

    } else {

        return TRUE;
    }
}


PVOID
RtlDebugCreateHeap (
    IN ULONG Flags,
    IN PVOID HeapBase OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize OPTIONAL,
    IN PVOID Lock OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap;
    NTSTATUS Status;
    MEMORY_BASIC_INFORMATION MemoryInformation;

    if (ReserveSize <= sizeof( HEAP_ENTRY )) {

        HeapDebugPrint(( "Invalid ReserveSize parameter - %lx\n", ReserveSize ));
        HeapDebugBreak( NULL );

        return NULL;
    }

    if (ReserveSize < CommitSize) {

        HeapDebugPrint(( "Invalid CommitSize parameter - %lx\n", CommitSize ));
        HeapDebugBreak( NULL );

        return NULL;
    }

    if ((Flags & HEAP_NO_SERIALIZE) && ARGUMENT_PRESENT( Lock )) {

        HeapDebugPrint(( "May not specify Lock parameter with HEAP_NO_SERIALIZE\n" ));
        HeapDebugBreak( NULL );

        return NULL;
    }

    if (ARGUMENT_PRESENT( HeapBase )) {

        Status = NtQueryVirtualMemory( NtCurrentProcess(),
                                       HeapBase,
                                       MemoryBasicInformation,
                                       &MemoryInformation,
                                       sizeof( MemoryInformation ),
                                       NULL );

        if (!NT_SUCCESS( Status )) {

            HeapDebugPrint(( "Specified HeapBase (%lx) invalid,  Status = %lx\n",
                             HeapBase,
                             Status ));

            HeapDebugBreak( NULL );

            return NULL;
        }

        if (MemoryInformation.BaseAddress != HeapBase) {

            HeapDebugPrint(( "Specified HeapBase (%lx) != to BaseAddress (%lx)\n",
                             HeapBase,
                             MemoryInformation.BaseAddress ));

            HeapDebugBreak( NULL );

            return NULL;
        }

        if (MemoryInformation.State == MEM_FREE) {

            HeapDebugPrint(( "Specified HeapBase (%lx) is free or not writable\n",
                             MemoryInformation.BaseAddress ));

            HeapDebugBreak( NULL );

            return NULL;
        }
    }

    Heap = RtlCreateHeap( Flags |
                            HEAP_SKIP_VALIDATION_CHECKS |
                            HEAP_TAIL_CHECKING_ENABLED  |
                            HEAP_FREE_CHECKING_ENABLED,
                          HeapBase,
                          ReserveSize,
                          CommitSize,
                          Lock,
                          Parameters );

    if (Heap != NULL) {

#if i386

        if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

            Heap->AllocatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();
        }

#endif // i386

        RtlpValidateHeapHeaders( Heap, TRUE );
    }

    return Heap;
}


BOOLEAN
RtlpSerializeHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_LOCK Lock;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapSerialize( HeapHandle ));

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    if (!RtlpCheckHeapSignature( Heap, "RtlpSerializeHeap" )) {

        return FALSE;
    }

    //
    //  Lock the heap.
    //

    if (Heap->Flags & HEAP_NO_SERIALIZE) {

        Lock = RtlAllocateHeap( HeapHandle, HEAP_NO_SERIALIZE, sizeof( *Lock ) );

        if ( Lock == NULL ) {

            return FALSE;
        }
    
        Status = RtlInitializeLockRoutine( Lock );

        if (!NT_SUCCESS( Status )) {

            RtlFreeHeap( HeapHandle, HEAP_NO_SERIALIZE, Lock );

            return FALSE;
        }

        Heap->LockVariable = Lock;
        Heap->Flags &= ~HEAP_NO_SERIALIZE;
        Heap->ForceFlags &= ~HEAP_NO_SERIALIZE;

        RtlpValidateHeapHeaders( Heap, TRUE );
    }

    return TRUE;
}


BOOLEAN
RtlDebugDestroyHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    LIST_ENTRY ListEntry;
    SIZE_T n;

    if (HeapHandle == NtCurrentPeb()->ProcessHeap) {

        HeapDebugPrint(( "May not destroy the process heap at %x\n", HeapHandle ));

        return FALSE;
    }

    if (!RtlpCheckHeapSignature( Heap, "RtlDestroyHeap" )) {

        return FALSE;
    }

    if (!RtlpValidateHeap( Heap, FALSE )) {

        return FALSE;
    }

    //
    //  Now mark the heap as invalid by zeroing the signature field.
    //

    Heap->Signature = 0;

    if (Heap->HeaderValidateCopy != NULL) {

        n = 0;
        NtFreeVirtualMemory( NtCurrentProcess(),
                             &Heap->HeaderValidateCopy,
                             &n,
                             MEM_RELEASE );
    }

    return TRUE;
}


PVOID
RtlDebugAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    PVOID ReturnValue = NULL;
    SIZE_T AllocationSize;
    USHORT TagIndex;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapAllocate( HeapHandle, Flags, Size ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlAllocateHeap" )) {

                ReturnValue = NULL;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SETTABLE_USER_VALUE | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Verify that the size did not wrap or exceed the limit for this heap.
            //

            AllocationSize = (((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask) +
                             sizeof( HEAP_ENTRY_EXTRA );

            if ((AllocationSize < Size) || (AllocationSize > Heap->MaximumAllocationSize)) {

                HeapDebugPrint(( "Invalid allocation size - %lx (exceeded %x)\n",
                                 Size,
                                 Heap->MaximumAllocationSize ));

                ReturnValue = NULL;
                leave;
            }

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            ReturnValue = RtlAllocateHeapSlowly( HeapHandle, Flags, Size );

            RtlpValidateHeapHeaders( Heap, TRUE );

            if (ReturnValue != NULL) {

                BusyBlock = (PHEAP_ENTRY)ReturnValue - 1;

                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

    #if i386

                    if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

                        ExtraStuff->AllocatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();

                    } else {

                        ExtraStuff->AllocatorBackTraceIndex = 0;
                    }

    #endif // i386

                    TagIndex = ExtraStuff->TagIndex;

                } else {

                    TagIndex = BusyBlock->SmallTagIndex;
                }

                if (Heap->Flags & HEAP_VALIDATE_ALL_ENABLED) {

                    RtlpValidateHeap( Heap, FALSE );
                }
            }

            if (ReturnValue != NULL) {

                if ((ULONG_PTR)ReturnValue == RtlpHeapStopOn.AllocAddress) {

                    HeapDebugPrint(( "Just allocated block at %lx for 0x%x bytes\n",
                                     RtlpHeapStopOn.AllocAddress,
                                     Size ));

                    HeapDebugBreak( NULL );

                } else if ((IS_HEAP_TAGGING_ENABLED()) &&
                           (TagIndex != 0) &&
                           (TagIndex == RtlpHeapStopOn.AllocTag.TagIndex) &&
                           (Heap->ProcessHeapsListIndex == RtlpHeapStopOn.AllocTag.HeapIndex)) {

                    HeapDebugPrint(( "Just allocated block at %lx for 0x%x bytes with tag %ws\n",
                                     ReturnValue,
                                     Size,
                                     RtlpGetTagName( Heap, TagIndex )));

                    HeapDebugBreak( NULL );
                }
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            ReturnValue = NULL;
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return ReturnValue;
}


PVOID
RtlDebugReAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    SIZE_T AllocationSize;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    BOOLEAN LockAcquired = FALSE;
    PVOID ReturnValue = NULL;
    USHORT TagIndex;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapReAllocate( HeapHandle, Flags, BaseAddress, Size ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlReAllocateHeap" )) {

                ReturnValue = NULL;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SETTABLE_USER_VALUE | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Verify that the size did not wrap or exceed the limit for this heap.
            //

            AllocationSize = (((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask) +
                             sizeof( HEAP_ENTRY_EXTRA );

            if (AllocationSize < Size || AllocationSize > Heap->MaximumAllocationSize) {

                HeapDebugPrint(( "Invalid allocation size - %lx (exceeded %x)\n",
                                 Size,
                                 Heap->MaximumAllocationSize ));

                HeapDebugBreak( NULL );

                ReturnValue = NULL;
                leave;
            }

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );
            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlReAllocateHeap" )) {

                if ((ULONG_PTR)BaseAddress == RtlpHeapStopOn.ReAllocAddress) {

                    HeapDebugPrint(( "About to reallocate block at %lx to 0x%x bytes\n",
                                     RtlpHeapStopOn.ReAllocAddress,
                                     Size ));

                    HeapDebugBreak( NULL );

                } else if (IS_HEAP_TAGGING_ENABLED() && RtlpHeapStopOn.ReAllocTag.HeapAndTagIndex != 0) {

                    if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );
                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = BusyBlock->SmallTagIndex;
                    }

                    if ((TagIndex != 0) &&
                        (TagIndex == RtlpHeapStopOn.ReAllocTag.TagIndex) &&
                        (Heap->ProcessHeapsListIndex == RtlpHeapStopOn.ReAllocTag.HeapIndex)) {

                        HeapDebugPrint(( "About to rellocate block at %lx to 0x%x bytes with tag %ws\n",
                                         BaseAddress,
                                         Size,
                                         RtlpGetTagName( Heap, TagIndex )));

                        HeapDebugBreak( NULL );
                    }
                }

                ReturnValue = RtlReAllocateHeap( HeapHandle, Flags, BaseAddress, Size );

                if (ReturnValue != NULL) {

                    BusyBlock = (PHEAP_ENTRY)ReturnValue - 1;

                    if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

    #if i386

                        if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

                            ExtraStuff->AllocatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();

                        } else {

                            ExtraStuff->AllocatorBackTraceIndex = 0;
                        }

    #endif // i386

                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = BusyBlock->SmallTagIndex;
                    }
                }

                RtlpValidateHeapHeaders( Heap, TRUE );
                RtlpValidateHeap( Heap, FALSE );
            }

            if (ReturnValue != NULL) {

                if ((ULONG_PTR)ReturnValue == RtlpHeapStopOn.ReAllocAddress) {

                    HeapDebugPrint(( "Just reallocated block at %lx to 0x%x bytes\n",
                                     RtlpHeapStopOn.ReAllocAddress,
                                     Size ));

                    HeapDebugBreak( NULL );

                } else if ((IS_HEAP_TAGGING_ENABLED()) &&
                           (TagIndex == RtlpHeapStopOn.ReAllocTag.TagIndex) &&
                           (Heap->ProcessHeapsListIndex == RtlpHeapStopOn.ReAllocTag.HeapIndex)) {

                    HeapDebugPrint(( "Just reallocated block at %lx to 0x%x bytes with tag %ws\n",
                                     ReturnValue,
                                     Size,
                                     RtlpGetTagName( Heap, TagIndex )));

                    HeapDebugBreak( NULL );
                }
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            ReturnValue = NULL;
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return ReturnValue;
}


BOOLEAN
RtlDebugFreeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T Size;
    BOOLEAN Result = FALSE;
    BOOLEAN LockAcquired = FALSE;
    USHORT TagIndex;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapFree( HeapHandle, Flags, BaseAddress ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlFreeHeap" )) {

                Result = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;
            Size = BusyBlock->Size << HEAP_GRANULARITY_SHIFT;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlFreeHeap" )) {

                if ((ULONG_PTR)BaseAddress == RtlpHeapStopOn.FreeAddress) {

                    HeapDebugPrint(( "About to free block at %lx\n",
                                     RtlpHeapStopOn.FreeAddress ));

                    HeapDebugBreak( NULL );

                } else if ((IS_HEAP_TAGGING_ENABLED()) && (RtlpHeapStopOn.FreeTag.HeapAndTagIndex != 0)) {

                    if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = BusyBlock->SmallTagIndex;
                    }

                    if ((TagIndex != 0) &&
                        (TagIndex == RtlpHeapStopOn.FreeTag.TagIndex) &&
                        (Heap->ProcessHeapsListIndex == RtlpHeapStopOn.FreeTag.HeapIndex)) {

                        HeapDebugPrint(( "About to free block at %lx with tag %ws\n",
                                         BaseAddress,
                                         RtlpGetTagName( Heap, TagIndex )));

                        HeapDebugBreak( NULL );
                    }
                }

                Result = RtlFreeHeapSlowly( HeapHandle, Flags, BaseAddress );

                RtlpValidateHeapHeaders( Heap, TRUE );
                RtlpValidateHeap( Heap, FALSE );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


BOOLEAN
RtlDebugGetUserInfoHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    OUT PVOID *UserValue OPTIONAL,
    OUT PULONG UserFlags OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN Result = FALSE;
    BOOLEAN LockAcquired = FALSE;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapGetUserInfo( HeapHandle, Flags, BaseAddress, UserValue, UserFlags ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlGetUserInfoHeap" )) {

                Result = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlGetUserInfoHeap" )) {

                Result = RtlGetUserInfoHeap( HeapHandle, Flags, BaseAddress, UserValue, UserFlags );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


BOOLEAN
RtlDebugSetUserValueHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UserValue
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN Result = FALSE;
    BOOLEAN LockAcquired = FALSE;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapSetUserValue( HeapHandle, Flags, BaseAddress, UserValue ));

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlSetUserValueHeap" )) {

                Result = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlSetUserValueHeap" )) {

                Result = RtlSetUserValueHeap( HeapHandle, Flags, BaseAddress, UserValue );

                RtlpValidateHeap( Heap, FALSE );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


BOOLEAN
RtlDebugSetUserFlagsHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN Result = FALSE;
    BOOLEAN LockAcquired = FALSE;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapSetUserFlags( HeapHandle, Flags, BaseAddress, UserFlagsReset, UserFlagsSet ));

    if ((UserFlagsReset & ~HEAP_SETTABLE_USER_FLAGS) ||
        (UserFlagsSet & ~HEAP_SETTABLE_USER_FLAGS)) {

        return FALSE;
    }

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlSetUserFlagsHeap" )) {

                Result = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlSetUserFlagsHeap" )) {

                Result = RtlSetUserFlagsHeap( HeapHandle, Flags, BaseAddress, UserFlagsReset, UserFlagsSet );

                RtlpValidateHeap( Heap, FALSE );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


SIZE_T
RtlDebugSizeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN LockAcquired = FALSE;
    SIZE_T BusySize;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapSize( HeapHandle, Flags, BaseAddress ));

    BusySize = 0xFFFFFFFF;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlSizeHeap" )) {

                BusySize = FALSE;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                Flags |= HEAP_NO_SERIALIZE;

                LockAcquired = TRUE;
            }

            RtlpValidateHeap( Heap, FALSE );

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            if (RtlpValidateHeapEntry( Heap, BusyBlock, "RtlSizeHeap" )) {

                BusySize = RtlSizeHeap( HeapHandle, Flags, BaseAddress );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return BusySize;
}


SIZE_T
RtlDebugCompactHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    SIZE_T LargestFreeSize;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapCompact( HeapHandle, Flags ));

    LargestFreeSize = 0;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlCompactHeap" )) {

                LargestFreeSize = 0;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            LargestFreeSize = RtlCompactHeap( HeapHandle, Flags );

            RtlpValidateHeapHeaders( Heap, TRUE );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return LargestFreeSize;
}


NTSTATUS
RtlDebugZeroHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    SIZE_T LargestFreeSize;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapZero( HeapHandle, Flags ));

    Status = STATUS_SUCCESS;
    LargestFreeSize = 0;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlZeroHeap" )) {

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            if (!RtlpValidateHeap( Heap, FALSE )) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                Status = RtlZeroHeap( HeapHandle, Flags );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Status;
}


NTSTATUS
RtlDebugCreateTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PWSTR TagPrefix OPTIONAL,
    IN PWSTR TagNames
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    ULONG TagIndex;

    TagIndex = 0;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (RtlpCheckHeapSignature( Heap, "RtlCreateTagHeap" )) {

                Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

                //
                //  Lock the heap
                //

                if (!(Flags & HEAP_NO_SERIALIZE)) {

                    RtlAcquireLockRoutine( Heap->LockVariable );

                    LockAcquired = TRUE;

                    Flags |= HEAP_NO_SERIALIZE;
                }

                if (RtlpValidateHeap( Heap, FALSE )) {

                    TagIndex = RtlCreateTagHeap( HeapHandle, Flags, TagPrefix, TagNames );
                }

                RtlpValidateHeapHeaders( Heap, TRUE );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return TagIndex;
}


NTSYSAPI
PWSTR
NTAPI
RtlDebugQueryTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN USHORT TagIndex,
    IN BOOLEAN ResetCounters,
    OUT PRTL_HEAP_TAG_INFO TagInfo OPTIONAL
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    PWSTR Result;

    Result = NULL;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (RtlpCheckHeapSignature( Heap, "RtlQueryTagHeap" )) {

                Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

                //
                //  Lock the heap
                //

                if (!(Flags & HEAP_NO_SERIALIZE)) {

                    RtlAcquireLockRoutine( Heap->LockVariable );

                    LockAcquired = TRUE;

                    Flags |= HEAP_NO_SERIALIZE;
                }

                if (RtlpValidateHeap( Heap, FALSE )) {

                    Result = RtlQueryTagHeap( HeapHandle, Flags, TagIndex, ResetCounters, TagInfo );
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


NTSTATUS
RtlDebugUsageHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    NTSTATUS Status;
    BOOLEAN LockAcquired = FALSE;

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapUsage( HeapHandle, Flags, Usage ));

    Status = STATUS_SUCCESS;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlUsageHeap" )) {

                Status = STATUS_INVALID_PARAMETER;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            if (!RtlpValidateHeap( Heap, FALSE )) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                Status = RtlUsageHeap( HeapHandle, Flags, Usage );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Status;
}


BOOLEAN
RtlDebugWalkHeap (
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN Result;

    //
    //  Assumed the caller has serialized via RtlLockHeap or their own locking mechanism.
    //

    Result = FALSE;

    try {

        if (RtlpCheckHeapSignature( Heap, "RtlWalkHeap" )) {

            Result = RtlpValidateHeap( Heap, FALSE );
        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        SET_LAST_STATUS( GetExceptionCode() );
    }

    return Result;
}


BOOLEAN
RtlpValidateHeapEntry (
    IN PHEAP Heap,
    IN PHEAP_ENTRY BusyBlock,
    IN PCHAR Reason
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    BOOLEAN Result;

    if ((BusyBlock == NULL)

            ||

        ((ULONG_PTR)BusyBlock & (HEAP_GRANULARITY-1))

            ||

        ((BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) &&
         ((ULONG_PTR)BusyBlock & (PAGE_SIZE-1)) != FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock ))

            ||

        (!(BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) &&
         ((BusyBlock->SegmentIndex >= HEAP_MAXIMUM_SEGMENTS) ||
          !(Segment = Heap->Segments[ BusyBlock->SegmentIndex ]) ||
          (BusyBlock < Segment->FirstEntry) ||
          (BusyBlock >= Segment->LastValidEntry)))

            ||

        !(BusyBlock->Flags & HEAP_ENTRY_BUSY)

            ||

        ((BusyBlock->Flags & HEAP_ENTRY_FILL_PATTERN) && !RtlpCheckBusyBlockTail( BusyBlock ))) {

InvalidBlock:

        HeapDebugPrint(( "Invalid Address specified to %s( %lx, %lx )\n",
                         Reason,
                         Heap,
                         BusyBlock + 1 ));

        HeapDebugBreak( BusyBlock );

        return FALSE;

    } else {

        if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

            Result = TRUE;

        } else {

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                if (Segment) {

                    if ((BusyBlock >= Segment->FirstEntry) &&
                        (BusyBlock < Segment->LastValidEntry)) {

                        Result = TRUE;
                        break;
                    }
                }
            }
        }

        if (!Result) {

            goto InvalidBlock;
        }

        return TRUE;
    }
}


BOOLEAN
RtlpValidateHeapSegment (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN UCHAR SegmentIndex,
    IN OUT PULONG CountOfFreeBlocks,
    IN OUT PSIZE_T TotalFreeSize,
    OUT PVOID *BadAddress,
    IN OUT PSIZE_T ComputedTagEntries,
    IN OUT PSIZE_T ComputedPseudoTagEntries
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP_ENTRY CurrentBlock, PreviousBlock;
    SIZE_T Size;
    USHORT PreviousSize, TagIndex;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;

    RTL_PAGED_CODE();

    NumberOfUnCommittedPages = 0;
    NumberOfUnCommittedRanges = 0;

    UnCommittedRange = Segment->UnCommittedRanges;

    if (Segment->BaseAddress == Heap) {

        CurrentBlock = &Heap->Entry;

    } else {

        CurrentBlock = &Segment->Entry;
    }

    while (CurrentBlock < Segment->LastValidEntry) {

        *BadAddress = CurrentBlock;

        if ((UnCommittedRange != NULL) &&
            ((ULONG_PTR)CurrentBlock >= UnCommittedRange->Address)) {

            HeapDebugPrint(( "Heap entry %lx is beyond uncommited range [%x .. %x)\n",
                             CurrentBlock,
                             UnCommittedRange->Address,
                             (PCHAR)UnCommittedRange->Address + UnCommittedRange->Size ));

            return FALSE;
        }

        PreviousSize = 0;

        while (CurrentBlock < Segment->LastValidEntry) {

            *BadAddress = CurrentBlock;

            if (PreviousSize != CurrentBlock->PreviousSize) {

                HeapDebugPrint(( "Heap entry %lx has incorrect PreviousSize field (%04x instead of %04x)\n",
                                 CurrentBlock, CurrentBlock->PreviousSize, PreviousSize ));

                return FALSE;
            }

            PreviousSize = CurrentBlock->Size;
            Size = (ULONG_PTR)CurrentBlock->Size << HEAP_GRANULARITY_SHIFT;

            if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {

                if (ComputedTagEntries != NULL) {

                    if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( CurrentBlock );
                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = CurrentBlock->SmallTagIndex;
                    }

                    if (TagIndex != 0) {

                        if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

                            TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

                            if (TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) {

                                ComputedPseudoTagEntries[ TagIndex ] += CurrentBlock->Size;
                            }

                        } else if (TagIndex & HEAP_GLOBAL_TAG) {

                            //
                            //  Ignore these since they are global across more than
                            //  one heap.
                            //

                        } else if (TagIndex < Heap->NextAvailableTagIndex) {

                            ComputedTagEntries[ TagIndex ] += CurrentBlock->Size;
                        }
                    }
                }

                if (CurrentBlock->Flags & HEAP_ENTRY_FILL_PATTERN) {

                    if (!RtlpCheckBusyBlockTail( CurrentBlock )) {

                        return FALSE;
                    }
                }

            } else {

                *CountOfFreeBlocks += 1;
                *TotalFreeSize += CurrentBlock->Size;

                if ((Heap->Flags & HEAP_FREE_CHECKING_ENABLED) &&
                    (CurrentBlock->Flags & HEAP_ENTRY_FILL_PATTERN)) {

                    SIZE_T cb, cbEqual;

                    cb = Size - sizeof( HEAP_FREE_ENTRY );

                    if ((CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) &&
                        (cb > sizeof( HEAP_FREE_ENTRY_EXTRA ))) {

                        cb -= sizeof( HEAP_FREE_ENTRY_EXTRA );
                    }

                    cbEqual = RtlCompareMemoryUlong( (PCHAR)((PHEAP_FREE_ENTRY)CurrentBlock + 1),
                                                     cb,
                                                     FREE_HEAP_FILL );

                    if (cbEqual != cb) {

                        HeapDebugPrint(( "Free Heap block %lx modified at %lx after it was freed\n",
                                         CurrentBlock,
                                         (PCHAR)(CurrentBlock + 1) + cbEqual ));

                        return FALSE;
                    }
                }
            }

            if (CurrentBlock->SegmentIndex != SegmentIndex) {

                HeapDebugPrint(( "Heap block at %lx has incorrect segment index (%x)\n",
                                 CurrentBlock,
                                 SegmentIndex ));

                return FALSE;
            }

            if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                CurrentBlock = (PHEAP_ENTRY)((PCHAR)CurrentBlock + Size);

                if (UnCommittedRange == NULL) {

                    if (CurrentBlock != Segment->LastValidEntry) {

                        HeapDebugPrint(( "Heap block at %lx is not last block in segment (%x)\n",
                                         CurrentBlock,
                                         Segment->LastValidEntry ));

                        return FALSE;
                    }

                } else if ((ULONG_PTR)CurrentBlock != UnCommittedRange->Address) {

                    HeapDebugPrint(( "Heap block at %lx does not match address of next uncommitted address (%x)\n",
                                     CurrentBlock,
                                     UnCommittedRange->Address ));

                    return FALSE;

                } else {

                    NumberOfUnCommittedPages += (ULONG) (UnCommittedRange->Size / PAGE_SIZE);
                    NumberOfUnCommittedRanges += 1;

                    CurrentBlock = (PHEAP_ENTRY)
                        ((PCHAR)UnCommittedRange->Address + UnCommittedRange->Size);

                    UnCommittedRange = UnCommittedRange->Next;
                }

                break;
            }

            CurrentBlock = (PHEAP_ENTRY)((PCHAR)CurrentBlock + Size);
        }
    }

    *BadAddress = Segment;

    if (Segment->NumberOfUnCommittedPages != NumberOfUnCommittedPages) {

        HeapDebugPrint(( "Heap Segment at %lx contains invalid NumberOfUnCommittedPages (%x != %x)\n",
                         Segment,
                         Segment->NumberOfUnCommittedPages,
                         NumberOfUnCommittedPages ));

        return FALSE;
    }

    if (Segment->NumberOfUnCommittedRanges != NumberOfUnCommittedRanges) {

        HeapDebugPrint(( "Heap Segment at %lx contains invalid NumberOfUnCommittedRanges (%x != %x)\n",
                         Segment,
                         Segment->NumberOfUnCommittedRanges,
                         NumberOfUnCommittedRanges ));

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
RtlpValidateHeap (
    IN PHEAP Heap,
    IN BOOLEAN AlwaysValidate
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    PHEAP_SEGMENT Segment;
    PLIST_ENTRY Head, Next;
    PHEAP_FREE_ENTRY FreeBlock;
    BOOLEAN EmptyFreeList;
    ULONG NumberOfFreeListEntries;
    ULONG CountOfFreeBlocks;
    SIZE_T TotalFreeSize;
    SIZE_T Size;
    USHORT PreviousSize;
    UCHAR SegmentIndex;
    PVOID BadAddress;
    PSIZE_T ComputedTagEntries = NULL;
    PSIZE_T ComputedPseudoTagEntries = NULL;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;
    USHORT TagIndex;

    RTL_PAGED_CODE();

    BadAddress = Heap;

    if (!RtlpValidateHeapHeaders( Heap, FALSE )) {

        goto errorExit;
    }

    if (!AlwaysValidate && !(Heap->Flags & HEAP_VALIDATE_ALL_ENABLED)) {

        goto exit;
    }

    NumberOfFreeListEntries = 0;
    Head = &Heap->FreeLists[ 0 ];

    for (Size = 0; Size < HEAP_MAXIMUM_FREELISTS; Size++) {

        if (Size != 0) {

            EmptyFreeList = (BOOLEAN)(IsListEmpty( Head ));
            BadAddress = &Heap->u.FreeListsInUseBytes[ Size / 8 ];

            if (Heap->u.FreeListsInUseBytes[ Size / 8 ] & (1 << (Size & 7)) ) {

                if (EmptyFreeList) {

                    HeapDebugPrint(( "dedicated (%04x) free list empty but marked as non-empty\n",
                                     Size ));

                    goto errorExit;
                }

            } else {

                if (!EmptyFreeList) {

                    HeapDebugPrint(( "dedicated (%04x) free list non-empty but marked as empty\n",
                                     Size ));

                    goto errorExit;
                }
            }
        }

        Next = Head->Flink;
        PreviousSize = 0;

        while (Head != Next) {

            FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );
            Next = Next->Flink;

            BadAddress = FreeBlock;

            if (FreeBlock->Flags & HEAP_ENTRY_BUSY) {

                HeapDebugPrint(( "dedicated (%04x) free list element %lx is marked busy\n",
                                 Size,
                                 FreeBlock ));

                goto errorExit;
            }

            if ((Size != 0) && (FreeBlock->Size != Size)) {

                HeapDebugPrint(( "Dedicated (%04x) free list element %lx is wrong size (%04x)\n",
                                 Size,
                                 FreeBlock,
                                 FreeBlock->Size ));

                goto errorExit;

            } else if ((Size == 0) && (FreeBlock->Size < HEAP_MAXIMUM_FREELISTS)) {

                HeapDebugPrint(( "Non-Dedicated free list element %lx with too small size (%04x)\n",
                                 FreeBlock,
                                 FreeBlock->Size ));

                goto errorExit;

            } else if ((Size == 0) && (FreeBlock->Size < PreviousSize)) {

                HeapDebugPrint(( "Non-Dedicated free list element %lx is out of order\n",
                                 FreeBlock ));

                goto errorExit;

            } else {

                PreviousSize = FreeBlock->Size;
            }

            NumberOfFreeListEntries++;
        }

        Head++;
    }

    Size = (HEAP_NUMBER_OF_PSEUDO_TAG + Heap->NextAvailableTagIndex + 1) * sizeof( SIZE_T );

    if ((RtlpValidateHeapTagsEnable) && (Heap->PseudoTagEntries != NULL)) {

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &ComputedPseudoTagEntries,
                                          0,
                                          &Size,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (NT_SUCCESS( Status )) {

            ComputedTagEntries = ComputedPseudoTagEntries + HEAP_NUMBER_OF_PSEUDO_TAG;
        }
    }

    Head = &Heap->VirtualAllocdBlocks;
    Next = Head->Flink;

    while (Head != Next) {

        VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

        if (ComputedTagEntries != NULL) {

            TagIndex = VirtualAllocBlock->ExtraStuff.TagIndex;

            if (TagIndex != 0) {

                if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

                    TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

                    if (TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) {

                        ComputedPseudoTagEntries[ TagIndex ] +=
                            VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT;
                    }

                } else if (TagIndex & HEAP_GLOBAL_TAG) {

                    //
                    //  Ignore these since they are global across more than
                    //  one heap.
                    //

                } else if (TagIndex < Heap->NextAvailableTagIndex) {

                    ComputedTagEntries[ TagIndex ] +=
                        VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT;
                }
            }
        }

        if (VirtualAllocBlock->BusyBlock.Flags & HEAP_ENTRY_FILL_PATTERN) {

            if (!RtlpCheckBusyBlockTail( &VirtualAllocBlock->BusyBlock )) {

                return FALSE;
            }
        }

        Next = Next->Flink;
    }

    CountOfFreeBlocks = 0;
    TotalFreeSize = 0;

    for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

        Segment = Heap->Segments[ SegmentIndex ];

        if (Segment) {

            if (!RtlpValidateHeapSegment( Heap,
                                          Segment,
                                          SegmentIndex,
                                          &CountOfFreeBlocks,
                                          &TotalFreeSize,
                                          &BadAddress,
                                          ComputedTagEntries,
                                          ComputedPseudoTagEntries )) {

                goto errorExit;
            }
        }
    }

    BadAddress = Heap;

    if (NumberOfFreeListEntries != CountOfFreeBlocks) {

        HeapDebugPrint(( "Number of free blocks in arena (%ld) does not match number in the free lists (%ld)\n",
                         CountOfFreeBlocks,
                         NumberOfFreeListEntries ));

        goto errorExit;
    }

    if (Heap->TotalFreeSize != TotalFreeSize) {

        HeapDebugPrint(( "Total size of free blocks in arena (%ld) does not match number total in heap header (%ld)\n",
                         TotalFreeSize,
                         Heap->TotalFreeSize ));

        goto errorExit;
    }

    if (ComputedPseudoTagEntries != NULL) {

        PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;
        PHEAP_TAG_ENTRY TagEntries;
        USHORT TagIndex;

        PseudoTagEntries = Heap->PseudoTagEntries;

        if (PseudoTagEntries != NULL) {

            for (TagIndex=1; TagIndex<HEAP_NUMBER_OF_PSEUDO_TAG; TagIndex++) {

                PseudoTagEntries += 1;

                if (ComputedPseudoTagEntries[ TagIndex ] != PseudoTagEntries->Size) {

                    HeapDebugPrint(( "Pseudo Tag %04x size incorrect (%x != %x) %x\n",
                                     TagIndex,
                                     PseudoTagEntries->Size,
                                     ComputedPseudoTagEntries[ TagIndex ]
                                     &ComputedPseudoTagEntries[ TagIndex ] ));

                    goto errorExit;
                }
            }
        }

        TagEntries = Heap->TagEntries;

        if (TagEntries != NULL) {

            for (TagIndex=1; TagIndex<Heap->NextAvailableTagIndex; TagIndex++) {

                TagEntries += 1;

                if (ComputedTagEntries[ TagIndex ] != TagEntries->Size) {

                    HeapDebugPrint(( "Tag %04x (%ws) size incorrect (%x != %x) %x\n",
                                     TagIndex,
                                     TagEntries->TagName,
                                     TagEntries->Size,
                                     ComputedTagEntries[ TagIndex ],
                                     &ComputedTagEntries[ TagIndex ] ));

                    goto errorExit;
                }
            }
        }

        Size = 0;

        NtFreeVirtualMemory( NtCurrentProcess(),
                             &ComputedPseudoTagEntries,
                             &Size,
                             MEM_RELEASE );
    }

exit:

    return TRUE;

errorExit:

    HeapDebugBreak( BadAddress );

    if (ComputedPseudoTagEntries != NULL) {

        Size = 0;

        NtFreeVirtualMemory( NtCurrentProcess(),
                             &ComputedPseudoTagEntries,
                             &Size,
                             MEM_RELEASE );
    }

    return FALSE;

}


BOOLEAN RtlpHeapInvalidBreakPoint;
PVOID RtlpHeapInvalidBadAddress;

VOID
RtlpBreakPointHeap (
    IN PVOID BadAddress
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (NtCurrentPeb()->BeingDebugged) {

        *(BOOLEAN volatile *)&RtlpHeapInvalidBreakPoint = TRUE;

        RtlpHeapInvalidBadAddress = BadAddress;

        DbgBreakPoint();

        *(BOOLEAN volatile *)&RtlpHeapInvalidBreakPoint = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\heap.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    This module implements a heap allocator.

Author:

    Steve Wood (stevewo) 20-Sep-1989 (Adapted from URTL\alloc.c)

Revision History:

--*/

#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"

ULONG NtGlobalFlag;

#ifdef NTHEAP_ENABLED
#include "heapp.h"
#endif // NTHEAP_ENABLED

#ifdef NTOS_KERNEL_RUNTIME

SIZE_T MmHeapSegmentReserve = 1024 * 1024;
SIZE_T MmHeapSegmentCommit = PAGE_SIZE * 2;
SIZE_T MmHeapDeCommitTotalFreeThreshold = 64 * 1024;
SIZE_T MmHeapDeCommitFreeBlockThreshold = PAGE_SIZE;

#else  // NTOS_KERNEL_RUNTIME

ULONG RtlpDisableHeapLookaside = 0;

#endif // NTOS_KERNEL_RUNTIME

//
//  If any of these flags are set, the fast allocator punts
//  to the slow do-everything allocator.
//

#define HEAP_SLOW_FLAGS (HEAP_DEBUG_FLAGS           | \
                         HEAP_SETTABLE_USER_FLAGS   | \
                         HEAP_NEED_EXTRA_FLAGS      | \
                         HEAP_CREATE_ALIGN_16       | \
                         HEAP_FREE_CHECKING_ENABLED | \
                         HEAP_TAIL_CHECKING_ENABLED)

#if DBG

UCHAR CheckHeapFillPattern[ CHECK_HEAP_TAIL_SIZE ] = {
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
#if defined(_WIN64) || defined(_XBOX)
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
#endif
    CHECK_HEAP_TAIL_FILL
};

#endif // DBG

//
//  An extra bitmap manipulation routine
//

#if i386

CCHAR
FASTCALL
RtlFindFirstSetRightMember(
    ULONG Set
    );

#else

#define RtlFindFirstSetRightMember(Set)                     \
    (((Set) & 0xFFFF) ?                                     \
        (((Set) & 0xFF) ?                                   \
            RtlpBitsClearLow[(Set) & 0xFF] :                \
            RtlpBitsClearLow[((Set) >> 8) & 0xFF] + 8) :    \
        ((((Set) >> 16) & 0xFF) ?                           \
            RtlpBitsClearLow[ ((Set) >> 16) & 0xFF] + 16 :  \
            RtlpBitsClearLow[ (Set) >> 24] + 24)            \
    )

#endif


//
//  These are procedure prototypes exported by heapdbg.c
//

#ifndef NTOS_KERNEL_RUNTIME

PVOID
RtlDebugCreateHeap (
    IN ULONG Flags,
    IN PVOID HeapBase OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize OPTIONAL,
    IN PVOID Lock OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
    );

BOOLEAN
RtlDebugDestroyHeap (
    IN PVOID HeapHandle
    );

PVOID
RtlDebugAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlDebugFreeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

ULONG
RtlDebugSizeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

NTSTATUS
RtlDebugZeroHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

#endif // NTOS_KERNEL_RUNTIME


//
//  Local procedure prototypes
//

BOOLEAN
RtlpGrowBlockInPlace (
    IN PHEAP Heap,
    IN ULONG Flags,
    IN PHEAP_ENTRY BusyBlock,
    IN SIZE_T Size,
    IN SIZE_T AllocationIndex
    );

PHEAP_UNCOMMMTTED_RANGE
RtlpCreateUnCommittedRange (
    IN PHEAP_SEGMENT Segment
    );

VOID
RtlpDestroyUnCommittedRange (
    IN PHEAP_SEGMENT Segment,
    IN PHEAP_UNCOMMMTTED_RANGE UnCommittedRange
    );

VOID
RtlpInsertUnCommittedPages (
    IN PHEAP_SEGMENT Segment,
    IN ULONG_PTR Address,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDestroyHeapSegment (
    IN PHEAP_SEGMENT Segment
    );

PHEAP_FREE_ENTRY
RtlpExtendHeap (
    IN PHEAP Heap,
    IN SIZE_T AllocationSize
    );


PVOID
RtlCreateHeap (
    IN ULONG Flags,
    IN PVOID HeapBase OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize OPTIONAL,
    IN PVOID Lock OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
    )

/*++

Routine Description:

    This routine initializes a heap.

Arguments:

    Flags - Specifies optional attributes of the heap.

        Valid Flags Values:

        HEAP_NO_SERIALIZE - if set, then allocations and deallocations on
                         this heap are NOT synchronized by these routines.

        HEAP_GROWABLE - if set, then the heap is a "sparse" heap where
                        memory is committed only as necessary instead of
                        being preallocated.

    HeapBase - if not NULL, this specifies the base address for memory
        to use as the heap.  If NULL, memory is allocated by these routines.

    ReserveSize - if not zero, this specifies the amount of virtual address
        space to reserve for the heap.

    CommitSize - if not zero, this specifies the amount of virtual address
        space to commit for the heap.  Must be less than ReserveSize.  If
        zero, then defaults to one page.

    Lock - if not NULL, this parameter points to the resource lock to
        use.  Only valid if HEAP_NO_SERIALIZE is NOT set.

    Parameters - optional heap parameters.

Return Value:

    PVOID - a pointer to be used in accessing the created heap.

--*/

{
    NTSTATUS Status;
    PHEAP Heap = NULL;
    PHEAP_SEGMENT Segment = NULL;
    PLIST_ENTRY FreeListHead;
    ULONG SizeOfHeapHeader;
    ULONG SegmentFlags;
    PVOID CommittedBase;
    PVOID UnCommittedBase;
    MEMORY_BASIC_INFORMATION MemoryInformation;
    ULONG n;
    ULONG InitialCountOfUnusedUnCommittedRanges;
    SIZE_T MaximumHeapBlockSize;
    PVOID NextHeapHeaderAddress;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;
    RTL_HEAP_PARAMETERS TempParameters;

#ifndef NTOS_KERNEL_RUNTIME

    PPEB Peb;

#endif // NTOS_KERNEL_RUNTIME

    RTL_PAGED_CODE();

#ifndef NTOS_KERNEL_RUNTIME
#ifdef NTHEAP_ENABLED
    {
        if (Flags & NTHEAP_ENABLED_FLAG) {

            Heap = RtlCreateNtHeap( Flags, NULL );

            if (Heap != NULL) {

                return Heap;
            }

            Flags &= ~NTHEAP_ENABLED_FLAG;
        }
    }
#endif // NTHEAP_ENABLED
#endif // NTOS_KERNEL_RUNTIME

    //
    //  Check if we should be using the page heap code.  If not then turn
    //  off any of the page heap flags before going on
    //

#ifdef DEBUG_PAGE_HEAP

    if ( RtlpDebugPageHeap && ( HeapBase == NULL ) && ( Lock == NULL )) {

        PVOID PageHeap;

        PageHeap = RtlpDebugPageHeapCreate(

            Flags,
            HeapBase,
            ReserveSize,
            CommitSize,
            Lock,
            Parameters );

        if (PageHeap != NULL) {
            return PageHeap;
        }

        //
        // A `-1' value signals a recursive call from page heap
        // manager. We set this to null and continue creating
        // a normal heap. This small hack is required so that we
        // minimize the dependencies between the normal and the page
        // heap manager.
        //

        if ((SIZE_T)Parameters == (SIZE_T)-1) {

            Parameters = NULL;
        }
    }

    Flags &= ~( HEAP_PROTECTION_ENABLED |
        HEAP_BREAK_WHEN_OUT_OF_VM |
        HEAP_NO_ALIGNMENT );

#endif // DEBUG_PAGE_HEAP

#if DBG
    //
    //  If the caller does not want to skip heap validiation checks then we
    //  need to validate the rest of the flags but simply masking out only
    //  those flags that want on a create heap call
    //

    if (!(Flags & HEAP_SKIP_VALIDATION_CHECKS)) {

        if (Flags & ~HEAP_CREATE_VALID_MASK) {

            HeapDebugPrint(( "Invalid flags (%08x) specified to RtlCreateHeap\n", Flags ));
            HeapDebugBreak( NULL );

            Flags &= HEAP_CREATE_VALID_MASK;
        }
    }
#endif // DBG

    //
    //  The maximum heap block size is really 0x7f000 which is 0x80000 minus a
    //  page.  Maximum block size is 0xfe00 and granularity shift is 3.
    //

    MaximumHeapBlockSize = HEAP_MAXIMUM_BLOCK_SIZE << HEAP_GRANULARITY_SHIFT;

    //
    //  Assume we're going to be successful until we're shown otherwise
    //

    Status = STATUS_SUCCESS;

    //
    //  This part of the routine builds up local variable containing all the
    //  parameters used to initialize the heap.  First thing we do is zero
    //  it out.
    //

    RtlZeroMemory( &TempParameters, sizeof( TempParameters ) );

    //
    //  If our caller supplied the optional heap parameters then we'll
    //  make sure the size is good and copy over them over to our
    //  local copy
    //

    if (ARGUMENT_PRESENT( Parameters )) {

        try {

            if (Parameters->Length == sizeof( *Parameters )) {

                RtlMoveMemory( &TempParameters, Parameters, sizeof( *Parameters ) );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

        if (!NT_SUCCESS( Status )) {

            return NULL;
        }
    }

    //
    //  Set the parameter block to the local copy
    //

    Parameters = &TempParameters;

    //
    //  If nt global flags tells us to always do tail or free checking
    //  or to disable coalescing then force those bits set in the user
    //  specified flags
    //

#if DBG
    if (NtGlobalFlag & FLG_HEAP_ENABLE_TAIL_CHECK) {

        Flags |= HEAP_TAIL_CHECKING_ENABLED;
    }

    if (NtGlobalFlag & FLG_HEAP_ENABLE_FREE_CHECK) {

        Flags |= HEAP_FREE_CHECKING_ENABLED;
    }
#endif // DBG

    if (NtGlobalFlag & FLG_HEAP_DISABLE_COALESCING) {

        Flags |= HEAP_DISABLE_COALESCE_ON_FREE;
    }

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case we also check if we should
    //  validate parameters, validate all, or do stack backtraces
    //

    Peb = NtCurrentPeb();

#if DBG
    if (NtGlobalFlag & FLG_HEAP_VALIDATE_PARAMETERS) {

        Flags |= HEAP_VALIDATE_PARAMETERS_ENABLED;
    }

    if (NtGlobalFlag & FLG_HEAP_VALIDATE_ALL) {

        Flags |= HEAP_VALIDATE_ALL_ENABLED;
    }

    if (NtGlobalFlag & FLG_USER_STACK_TRACE_DB) {

        Flags |= HEAP_CAPTURE_STACK_BACKTRACES;
    }
#endif // DBG

    //
    //  Also in the non kernel case the PEB will have some state
    //  variables that we need to set if the user hasn't specified
    //  otherwise
    //

    if (Parameters->SegmentReserve == 0) {

        Parameters->SegmentReserve = Peb->HeapSegmentReserve;
    }

    if (Parameters->SegmentCommit == 0) {

        Parameters->SegmentCommit = Peb->HeapSegmentCommit;
    }

    if (Parameters->DeCommitFreeBlockThreshold == 0) {

        Parameters->DeCommitFreeBlockThreshold = Peb->HeapDeCommitFreeBlockThreshold;
    }

    if (Parameters->DeCommitTotalFreeThreshold == 0) {

        Parameters->DeCommitTotalFreeThreshold = Peb->HeapDeCommitTotalFreeThreshold;
    }
#else // NTOS_KERNEL_RUNTIME

    //
    //  In the kernel case Mm has some global variables that we set
    //  into the paramters if the user hasn't specified otherwise
    //

    if (Parameters->SegmentReserve == 0) {

        Parameters->SegmentReserve = MmHeapSegmentReserve;
    }

    if (Parameters->SegmentCommit == 0) {

        Parameters->SegmentCommit = MmHeapSegmentCommit;
    }

    if (Parameters->DeCommitFreeBlockThreshold == 0) {

        Parameters->DeCommitFreeBlockThreshold = MmHeapDeCommitFreeBlockThreshold;
    }

    if (Parameters->DeCommitTotalFreeThreshold == 0) {

        Parameters->DeCommitTotalFreeThreshold = MmHeapDeCommitTotalFreeThreshold;
    }
#endif // NTOS_KERNEL_RUNTIME

    //
    //  If the user hasn't said what the largest allocation size is then
    //  we should compute it as the difference between the highest and lowest
    //  address less one page
    //

    if (Parameters->MaximumAllocationSize == 0) {

        Parameters->MaximumAllocationSize = ((ULONG_PTR)MM_HIGHEST_USER_ADDRESS -
                                             (ULONG_PTR)MM_LOWEST_USER_ADDRESS -
                                             PAGE_SIZE );
    }

    //
    //  Set the virtual memory threshold to be non zero and not more than the
    //  maximum heap block size of 0x7f000.  If the user specified one that is
    //  too large we automatically and silently drop it down.
    //

    if ((Parameters->VirtualMemoryThreshold == 0) ||
        (Parameters->VirtualMemoryThreshold > MaximumHeapBlockSize)) {

        Parameters->VirtualMemoryThreshold = MaximumHeapBlockSize;
    }

    //
    //  The default commit size is one page and the default reserve size is
    //  64 pages.
    //
    //  **** this doesn't check that commit size if specified is less than
    //  **** reserved size if specified
    //

    if (!ARGUMENT_PRESENT( CommitSize )) {

        CommitSize = PAGE_SIZE;

        if (!ARGUMENT_PRESENT( ReserveSize )) {

            ReserveSize = 64 * CommitSize;

        } else {

            ReserveSize = ROUND_UP_TO_POWER2( ReserveSize, PAGE_SIZE );
        }

    } else {

        //
        //  The heap actually uses space that is reserved and commited
        //  to store internal data structures (the LOCK,
        //  the HEAP_PSEUDO_TAG, etc.). These structures can be larger than
        //  4K especially on a 64-bit build. So, make sure the commit
        //  is at least 8K in length which is the minimal page size for
        //  64-bit systems
        //

        CommitSize = ROUND_UP_TO_POWER2(CommitSize, PAGE_SIZE);

        if (!ARGUMENT_PRESENT( ReserveSize )) {

            ReserveSize = ROUND_UP_TO_POWER2( CommitSize, 16 * PAGE_SIZE );

        } else {

            ReserveSize = ROUND_UP_TO_POWER2( ReserveSize, PAGE_SIZE );
        }

    }

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case check if we are creating a debug heap
    //  the test checks that skip validation checks is false.
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugCreateHeap( Flags,
                                   HeapBase,
                                   ReserveSize,
                                   CommitSize,
                                   Lock,
                                   Parameters );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  Compute the size of the heap which will be the
    //  heap struct itself and if we are to seralize with
    //  out own lock then add room for the lock.  If the
    //  user did not supply the lock then set the lock
    //  variable to -1.
    //

    SizeOfHeapHeader = sizeof( HEAP );

    if (!(Flags & HEAP_NO_SERIALIZE)) {

        if (ARGUMENT_PRESENT( Lock )) {

            Flags |= HEAP_LOCK_USER_ALLOCATED;

        } else {

            SizeOfHeapHeader += sizeof( HEAP_LOCK );
            Lock = (PHEAP_LOCK)-1;
        }

    } else if (ARGUMENT_PRESENT( Lock )) {

        //
        //  In this error case the call said not to seralize but also fed us
        //  a lock
        //

        return NULL;
    }

    //
    //  See if caller allocate the space for the heap.
    //

    if (ARGUMENT_PRESENT( HeapBase )) {

        //
        //  The call specified a heap base now check if there is
        //  a caller supplied commit routine
        //

        if (Parameters->CommitRoutine != NULL) {

            //
            //  The caller specified a commit routine so he caller
            //  also needs to have given us certain parameters and make
            //  sure the heap is not growable.  Otherwise it is an error
            //

            if ((Parameters->InitialCommit == 0) ||
                (Parameters->InitialReserve == 0) ||
                (Parameters->InitialCommit > Parameters->InitialReserve) ||
                (Flags & HEAP_GROWABLE)) {

                return NULL;
            }

            //
            //  Set the commited base and the uncommited base to the
            //  proper pointers within the heap.
            //

            CommittedBase = HeapBase;
            UnCommittedBase = (PCHAR)CommittedBase + Parameters->InitialCommit;
            ReserveSize = Parameters->InitialReserve;

            //
            //  Zero out a page of the heap where our first part goes
            //
            //  **** what if the size is less than a page
            //

            RtlZeroMemory( CommittedBase, PAGE_SIZE );

        } else {

            //
            //  The user gave us space but not commit routine
            //  So query the base to get its size
            //

            Status = ZwQueryVirtualMemory( HeapBase,
                                           &MemoryInformation );

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }

            //
            //  Make sure the user gave us a base address for this block
            //  and that the memory is not free
            //

            if (MemoryInformation.BaseAddress != HeapBase) {

                return NULL;
            }

            if (MemoryInformation.State == MEM_FREE) {

                return NULL;
            }

            //
            //  Set our commit base to the start of the range
            //

            CommittedBase = MemoryInformation.BaseAddress;

            //
            //  If the memory is commmitted then
            //  we can zero out a page worth
            //

            if (MemoryInformation.State == MEM_COMMIT) {

                RtlZeroMemory( CommittedBase, PAGE_SIZE );

                //
                //  Set the commit size and uncommited base according
                //  to the start of the vm
                //

                CommitSize = MemoryInformation.RegionSize;
                UnCommittedBase = (PCHAR)CommittedBase + CommitSize;

                //
                //  Find out the uncommited base is reserved and if so
                //  the update the reserve size accordingly.
                //

                Status = ZwQueryVirtualMemory( UnCommittedBase,
                                               &MemoryInformation );

                ReserveSize = CommitSize;

                if ((NT_SUCCESS( Status )) &&
                    (MemoryInformation.State == MEM_RESERVE)) {

                    ReserveSize += MemoryInformation.RegionSize;
                }

            } else {

                //
                //  The memory the user gave us is not committed so dummy
                //  up these small nummbers
                //

                CommitSize = PAGE_SIZE;
                UnCommittedBase = CommittedBase;
            }
        }

        //
        //  This user gave us a base and we've just taken care of the committed
        //  bookkeeping.  So mark this segment as user supplied and set the
        //  heap
        //

        SegmentFlags = HEAP_SEGMENT_USER_ALLOCATED;
        Heap = (PHEAP)HeapBase;

    } else {

        //
        //  The user did not specify a heap base so we have to allocate the
        //  vm here.  First make sure the user did not give us a commit routine
        //

        if (Parameters->CommitRoutine != NULL) {

            return NULL;
        }

        //
        //  Reserve the amount of virtual address space requested.
        //

        Status = ZwAllocateVirtualMemory( (PVOID *)&Heap,
                                          0,
                                          &ReserveSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return NULL;
        }

        //
        //  Indicate that this segment is not user supplied
        //

        SegmentFlags = 0;

        //
        //  Set the default commit size to one page
        //

        if (!ARGUMENT_PRESENT( CommitSize )) {

            CommitSize = PAGE_SIZE;
        }

        //
        //  Set the committed and uncommitted base to be the same the following
        //  code will actually commit the page for us
        //

        CommittedBase = Heap;
        UnCommittedBase = Heap;
    }

    //
    //  At this point we have a heap pointer, committed base, uncommitted base,
    //  segment flags, commit size, and reserve size.  If the committed and
    //  uncommited base are the same then we need to commit the amount
    //  specified by the commit size
    //

    if (CommittedBase == UnCommittedBase) {

        Status = ZwAllocateVirtualMemory( (PVOID *)&CommittedBase,
                                          0,
                                          &CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        //
        //  In the non successful case we need to back out any vm reservation
        //  we did earlier
        //

        if (!NT_SUCCESS( Status )) {

            if (!ARGUMENT_PRESENT(HeapBase)) {

                //
                //  Return the reserved virtual address space.
                //

                ZwFreeVirtualMemory( (PVOID *)&Heap,
                                     &ReserveSize,
                                     MEM_RELEASE );

            }

            return NULL;
        }

        //
        //  The new uncommitted base is not adjusted above what we just
        //  committed
        //

        UnCommittedBase = (PVOID)((PCHAR)UnCommittedBase + CommitSize);
    }

    //
    //  At this point we have memory for the start of the heap committed and
    //  ready to be initialized.  So now we need initialize the heap
    //

    //
    //  Calculate the end of the heap header and make room for 8 uncommitted
    //  range structures.  Once we have the room for them then chain them
    //  together and null terminate the chain
    //

    NextHeapHeaderAddress = Heap + 1;

    UnCommittedRange = (PHEAP_UNCOMMMTTED_RANGE)ROUND_UP_TO_POWER2( NextHeapHeaderAddress,
                                                                    sizeof( QUAD ) );

    InitialCountOfUnusedUnCommittedRanges = 8;

    SizeOfHeapHeader += InitialCountOfUnusedUnCommittedRanges * sizeof( *UnCommittedRange );

    //
    //  **** what a hack Pp is really a pointer to the next field of the
    //  **** uncommmtted range structure.  So we set next by setting through Pp
    //

    pp = &Heap->UnusedUnCommittedRanges;

    while (InitialCountOfUnusedUnCommittedRanges--) {

        *pp = UnCommittedRange;
        pp = &UnCommittedRange->Next;
        UnCommittedRange += 1;
    }

    NextHeapHeaderAddress = UnCommittedRange;

    *pp = NULL;

    //
    //  Check if tagging is enabled in global flags.  This check is always true
    //  in a debug build.
    //
    //  If tagging is enabled then make room for 129 pseudo tag heap entry.
    //  Which is one more than the number of free lists.  Also point the heap
    //  header to this array of pseudo tags entries.
    //

    if (IS_HEAP_TAGGING_ENABLED()) {

        Heap->PseudoTagEntries = (PHEAP_PSEUDO_TAG_ENTRY)ROUND_UP_TO_POWER2( NextHeapHeaderAddress,
                                                                             sizeof( QUAD ) );

        SizeOfHeapHeader += HEAP_NUMBER_OF_PSEUDO_TAG * sizeof( HEAP_PSEUDO_TAG_ENTRY );

        //
        //  **** this advancement of the next heap address doesn't seem right
        //  **** given that a pseudo heap entry is 12 ulongs in length and not
        //  **** a single byte

        NextHeapHeaderAddress = Heap->PseudoTagEntries + HEAP_NUMBER_OF_PSEUDO_TAG;
    }

    //
    //  Round the size of the heap header to the next 8 byte boundary
    //

    SizeOfHeapHeader = (ULONG) ROUND_UP_TO_POWER2( SizeOfHeapHeader,
                                                   HEAP_GRANULARITY );

    //
    //  If the sizeof the heap header is larger than the native
    //  page size, you have a problem. Further, if the CommitSize passed
    //  in was smaller than the SizeOfHeapHeader, you may not even make it
    //  this far before death...
    //
    //  HeapDbgPrint() doesn't work for IA64 yet.
    //
    //  HeapDbgPrint(("Size of the heap header is %u bytes, commit was %u bytes\n", SizeOfHeapHeader, (ULONG) CommitSize));
    //

    //
    //  Fill in the heap header fields
    //

    Heap->Entry.Size = (USHORT)(SizeOfHeapHeader >> HEAP_GRANULARITY_SHIFT);
    Heap->Entry.Flags = HEAP_ENTRY_BUSY;

    Heap->Signature = HEAP_SIGNATURE;
    Heap->Flags = Flags;
    Heap->ForceFlags = (Flags & (HEAP_NO_SERIALIZE |
                                 HEAP_GENERATE_EXCEPTIONS |
                                 HEAP_ZERO_MEMORY |
                                 HEAP_REALLOC_IN_PLACE_ONLY |
                                 HEAP_VALIDATE_PARAMETERS_ENABLED |
                                 HEAP_VALIDATE_ALL_ENABLED |
                                 HEAP_TAIL_CHECKING_ENABLED |
                                 HEAP_CREATE_ALIGN_16 |
                                 HEAP_FREE_CHECKING_ENABLED));

    Heap->FreeListsInUseTerminate = 0xFFFF;
    Heap->HeaderValidateLength = (USHORT)((PCHAR)NextHeapHeaderAddress - (PCHAR)Heap);
    Heap->HeaderValidateCopy = NULL;

    //
    //  Initialize the free list to be all empty
    //

    FreeListHead = &Heap->FreeLists[ 0 ];
    n = HEAP_MAXIMUM_FREELISTS;

    while (n--) {

        InitializeListHead( FreeListHead );
        FreeListHead++;
    }

    //
    //  Make it so that there a no big block allocations
    //

    InitializeListHead( &Heap->VirtualAllocdBlocks );

    //
    //  Initialize the cricital section that controls access to
    //  the free list.  If the lock variable is -1 then the caller
    //  did not supply a lock so we need to make room for one
    //  and initialize it.
    //

    if (Lock == (PHEAP_LOCK)-1) {

        Lock = (PHEAP_LOCK)NextHeapHeaderAddress;

        Status = RtlInitializeLockRoutine( Lock );

        if (!NT_SUCCESS( Status )) {

            return NULL;
        }

        NextHeapHeaderAddress = (PHEAP_LOCK)Lock + 1;
    }

    Heap->LockVariable = Lock;


    //
    //  Initialize the first segment for the heap
    //

    if (!RtlpInitializeHeapSegment( Heap,
                                    (PHEAP_SEGMENT)((PCHAR)Heap + SizeOfHeapHeader),
                                    0,
                                    SegmentFlags,
                                    CommittedBase,
                                    UnCommittedBase,
                                    (PCHAR)CommittedBase + ReserveSize )) {

        return NULL;
    }

    //
    //  Fill in additional heap entry fields
    //

    Heap->ProcessHeapsListIndex = 0;
    Heap->SegmentReserve = Parameters->SegmentReserve;
    Heap->SegmentCommit = Parameters->SegmentCommit;
    Heap->DeCommitFreeBlockThreshold = Parameters->DeCommitFreeBlockThreshold >> HEAP_GRANULARITY_SHIFT;
    Heap->DeCommitTotalFreeThreshold = Parameters->DeCommitTotalFreeThreshold >> HEAP_GRANULARITY_SHIFT;
    Heap->MaximumAllocationSize = Parameters->MaximumAllocationSize;

    Heap->VirtualMemoryThreshold = (ULONG) (ROUND_UP_TO_POWER2( Parameters->VirtualMemoryThreshold,
                                                       HEAP_GRANULARITY ) >> HEAP_GRANULARITY_SHIFT);

    Heap->CommitRoutine = Parameters->CommitRoutine;

    //
    //  We either align the heap at 16 or 8 byte boundaries.  The AlignRound
    //  and AlignMask are used to bring allocation sizes up to the next
    //  boundary.  The align round includes the heap header and the optional
    //  check tail size
    //

    if (Flags & HEAP_CREATE_ALIGN_16) {

        Heap->AlignRound = 15 + sizeof( HEAP_ENTRY );
        Heap->AlignMask = (ULONG)~15;

    } else {

        Heap->AlignRound = HEAP_GRANULARITY - 1 + sizeof( HEAP_ENTRY );
        Heap->AlignMask = (ULONG)~(HEAP_GRANULARITY - 1);
    }

#if DBG
    if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

        Heap->AlignRound += CHECK_HEAP_TAIL_SIZE;
    }
#endif // DBG

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case we need to add this heap to the processes heap
    //  list
    //

    RtlpAddHeapToProcessList( Heap );

    //
    //  Initialize the heap lookaide lists.  This is only for the user mode
    //  heap and the heap contains a pointer to the lookaside list array.
    //  The array is sized the same as the dedicated free list.  First we
    //  allocate space for the lookaside list and then we initialize each
    //  lookaside list.
    //
    //  But the caller asked for no serialize or asked for non growable
    //  heap then we won't enable the lookaside lists.
    //

    Heap->Lookaside = NULL;
    Heap->LookasideLockCount = 0;

    if ((!(Flags & HEAP_NO_SERIALIZE)) &&
        ( (Flags & HEAP_GROWABLE)) &&
        (!(RtlpDisableHeapLookaside))) {

        ULONG i;

        Heap->Lookaside = RtlAllocateHeap( Heap,
                                           Flags,
                                           sizeof(HEAP_LOOKASIDE) * HEAP_MAXIMUM_FREELISTS );

        if (Heap->Lookaside != NULL) {

            for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                RtlpInitializeHeapLookaside( &(((PHEAP_LOOKASIDE)(Heap->Lookaside))[i]),
                                             32 );
            }
        }
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  And return the fully initialized heap to our caller
    //

    return (PVOID)Heap;
}


PVOID
RtlDestroyHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is the opposite of Rtl Create Heap.  It tears down an
    existing heap structure.

Arguments:

    HeapHandle - Supplies a pointer to the heap being destroyed

Return Value:

    PVOID - Returns null if the heap was destroyed completely and a
        pointer back to the heap if for some reason the heap could
        not be destroyed.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_SEGMENT Segment;
    PHEAP_UCR_SEGMENT UCRSegments;
    PLIST_ENTRY Head, Next;
    PVOID BaseAddress;
    SIZE_T RegionSize;
    UCHAR SegmentIndex;

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    RTL_PAGED_CODE();

    if (HeapHandle == NULL) {
        HeapDebugPrint(( "Ignoring RtlDestroyHeap( NULL )\n" ));

        return NULL;
    }

#ifndef NTOS_KERNEL_RUNTIME
#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlDestroyNtHeap( HeapHandle );
        }
    }
#endif // NTHEAP_ENABLED
#endif // NTOS_KERNEL_RUNTIME

    //
    //  Check if this is the debug version of heap using page allocation
    //  with guard pages
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapDestroy( HeapHandle ));

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case check if this is the debug version of heap
    //  and of so then call the debug version to do the teardown
    //

    if (DEBUG_HEAP( Heap->Flags )) {

        if (!RtlDebugDestroyHeap( HeapHandle )) {

            return HeapHandle;
        }
    }

    //
    //  We are not allowed to destroy the process heap
    //

    if (HeapHandle == NtCurrentPeb()->ProcessHeap) {

        return HeapHandle;
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  For every big allocation we remove it from the list and free the
    //  vm
    //

    Head = &Heap->VirtualAllocdBlocks;
    Next = Head->Flink;

    while (Head != Next) {

        BaseAddress = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

        Next = Next->Flink;
        RegionSize = 0;

        ZwFreeVirtualMemory( (PVOID *)&BaseAddress,
                             &RegionSize,
                             MEM_RELEASE );
    }

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case we need to destory any heap tags we have setup
    //  and remove this heap from the process heap list
    //

    RtlpDestroyTags( Heap );
    RtlpRemoveHeapFromProcessList( Heap );

#endif // NTOS_KERNEL_RUNTIME

    //
    //  If the heap is serialized, delete the critical section created
    //  by RtlCreateHeap.
    //

    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {

        if (!(Heap->Flags & HEAP_LOCK_USER_ALLOCATED)) {

            RtlDeleteLockRoutine( Heap->LockVariable );
        }

        Heap->LockVariable = NULL;
    }

    //
    //  For every uncommitted segment we free its vm
    //

    UCRSegments = Heap->UCRSegments;
    Heap->UCRSegments = NULL;

    while (UCRSegments) {

        BaseAddress = UCRSegments;
        UCRSegments = UCRSegments->Next;
        RegionSize = 0;

        ZwFreeVirtualMemory( &BaseAddress,
                             &RegionSize,
                             MEM_RELEASE );
    }

    //
    //  For every segment in the heap we call a worker routine to
    //  destory the segment
    //

    SegmentIndex = HEAP_MAXIMUM_SEGMENTS;

    while (SegmentIndex--) {

        Segment = Heap->Segments[ SegmentIndex ];

        if (Segment) {

            RtlpDestroyHeapSegment( Segment );
        }
    }

    //
    //  And we return to our caller
    //

    return NULL;
}


PVOID
RtlAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine allocates a memory of the specified size from the specified
    heap.

Arguments:

    HeapHandle - Supplies a pointer to an initialized heap structure

    Flags - Specifies the set of flags to use to control the allocation

    Size - Specifies the size, in bytes, of the allocation

Return Value:

    PVOID - returns a pointer to the newly allocated block

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PULONG FreeListsInUse;
    ULONG FreeListsInUseUlong;
    SIZE_T AllocationSize;
    SIZE_T FreeSize, AllocationIndex;
    PLIST_ENTRY FreeListHead, Next;
    PHEAP_ENTRY BusyBlock;
    PHEAP_FREE_ENTRY FreeBlock, SplitBlock, SplitBlock2;
    ULONG InUseIndex;
    UCHAR FreeFlags;
    NTSTATUS Status;
    EXCEPTION_RECORD ExceptionRecord;
    PVOID ReturnValue;
    BOOLEAN LockAcquired = FALSE;

    RTL_PAGED_CODE();


#ifndef NTOS_KERNEL_RUNTIME
#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlAllocateNtHeap( HeapHandle,
                                      Flags,
                                      Size);
        }
    }
#endif // NTHEAP_ENABLED
#endif // NTOS_KERNEL_RUNTIME


    //
    //  Take the callers flags and add in the flags that we must forcibly set
    //  in the heap
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check for special features that force us to call the slow, do-everything
    //  version.  We do everything slow for any of the following flags.
    //
    //    HEAP_SLOW_FLAGS defined as           0x6f030f60
    //
    //      HEAP_DEBUG_FLAGS, defined as       0x69020000 (heappriv.h)
    //
    //        HEAP_VALIDATE_PARAMETERS_ENABLED 0x40000000 (heap.h)
    //
    //        HEAP_VALIDATE_ALL_ENABLED        0x20000000 (heap.h)
    //
    //        HEAP_CAPTURE_STACK_BACKTRACES    0x08000000 (heap.h)
    //
    //        HEAP_CREATE_ENABLE_TRACING       0x00020000 (ntrtl.h winnt obsolete)
    //
    //        HEAP_FLAG_PAGE_ALLOCS            0x01000000 (heappage.h)
    //
    //      HEAP_SETTABLE_USER_FLAGS           0x00000E00 (ntrtl.h)
    //
    //      HEAP_NEED_EXTRA_FLAGS              0x0f000100 (heap.h)
    //
    //      HEAP_CREATE_ALIGN_16               0x00010000 (ntrtl.h winnt obsolete)
    //
    //      HEAP_FREE_CHECKING_ENABLED         0x00000040 (ntrtl.h winnt)
    //
    //      HEAP_TAIL_CHECKING_ENABLED         0x00000020 (ntrtl.h winnt )
    //
    //  We also do everything slow if the size is greater than max long
    //

#if DBG
    if ((Flags & HEAP_SLOW_FLAGS) || (Size >= 0x80000000)) {

        return RtlAllocateHeapSlowly( HeapHandle, Flags, Size );
    }
#endif // DBG

    //
    //  At this point we know we are doing everything in this routine
    //  and not taking the slow route.
    //
    //  Round the requested size up to the allocation granularity.  Note
    //  that if the request is for 0 bytes, we still allocate memory, because
    //  we add in an extra 1 byte to protect ourselves from idiots.
    //
    //      Allocation size will be either 16, 24, 32, ...
    //      Allocation index will be 2, 3, 4, ...
    //
    //  Note that allocation size 8 is skipped and are indices 0 and 1
    //

    AllocationSize = ((Size ? Size : 1) + HEAP_GRANULARITY - 1 + sizeof( HEAP_ENTRY ))
        & ~(HEAP_GRANULARITY -1);
    AllocationIndex = AllocationSize >>  HEAP_GRANULARITY_SHIFT;

    //
    //  If there is a lookaside list and the index is within limits then
    //  try and allocate from the lookaside list.  We'll actually capture
    //  the lookaside pointer from the heap and only use the captured pointer.
    //  This will take care of the condition where a walk or lock heap can
    //  cause us to check for a non null pointer and then have it become null
    //  when we read it again.  If it is non null to start with then even if
    //  the user walks or locks the heap via another thread the pointer to
    //  still valid here so we can still try and do a lookaside list pop.
    //

#ifndef NTOS_KERNEL_RUNTIME

    {
        PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)Heap->Lookaside;

        if ((Lookaside != NULL) &&
            (Heap->LookasideLockCount == 0) &&
            (AllocationIndex < HEAP_MAXIMUM_FREELISTS)) {

            //
            //  If the number of operation elapsed operations is 128 times the
            //  lookaside depth then it is time to adjust the depth
            //

            if ((LONG)(Lookaside[AllocationIndex].TotalAllocates - Lookaside[AllocationIndex].LastTotalAllocates) >=
                      (Lookaside[AllocationIndex].Depth * 128)) {

                RtlpAdjustHeapLookasideDepth(&(Lookaside[AllocationIndex]));
            }

            ReturnValue = RtlpAllocateFromHeapLookaside(&(Lookaside[AllocationIndex]));

            if (ReturnValue != NULL) {

                PHEAP_ENTRY BusyBlock;

                BusyBlock = ((PHEAP_ENTRY)ReturnValue) - 1;
                BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);
                BusyBlock->SmallTagIndex = 0;

                if (Flags & HEAP_ZERO_MEMORY) {

                    RtlZeroMemory( ReturnValue, Size );
                }

                return ReturnValue;
            }
        }
    }

#endif // NTOS_KERNEL_RUNTIME

    try {

        //
        //  Check if we need to serialize our access to the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            //
            //  Lock the free list.
            //

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  If the allocation index is less than the maximum free list size
        //  then we can use the index to check the free list otherwise we have
        //  to either pull the entry off of the [0] index list or allocate
        //  memory directly for this request.
        //

        if (AllocationIndex < HEAP_MAXIMUM_FREELISTS) {

            //
            //  With a size that matches a free list size grab the head
            //  of the list and check if there is an available entry
            //

            FreeListHead = &Heap->FreeLists[ AllocationIndex ];

            if ( !IsListEmpty( FreeListHead ))  {

                //
                //  We're in luck the list has an entry so now get the free
                //  entry,  copy its flags, remove it from the free list
                //

                FreeBlock = CONTAINING_RECORD( FreeListHead->Blink,
                                               HEAP_FREE_ENTRY,
                                               FreeList );

                FreeFlags = FreeBlock->Flags;

                RtlpFastRemoveDedicatedFreeBlock( Heap, FreeBlock );

                //
                //  Adjust the total number of bytes free in the heap
                //

                Heap->TotalFreeSize -= AllocationIndex;

                //
                //  Mark the block as busy and and set the number of bytes
                //  unused and tag index.  Also if it is the last entry
                //  then keep that flag.
                //

                BusyBlock = (PHEAP_ENTRY)FreeBlock;
                BusyBlock->Flags = HEAP_ENTRY_BUSY | (FreeFlags & HEAP_ENTRY_LAST_ENTRY);
                BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);
                BusyBlock->SmallTagIndex = 0;

            } else {

                //
                //  The free list that matches our request is empty
                //
                //  Scan the free list in use vector to find the smallest
                //  available free block large enough for our allocations.
                //

                //
                //  Compute the index of the ULONG where the scan should begin
                //

                InUseIndex = (ULONG) (AllocationIndex >> 5);
                FreeListsInUse = &Heap->u.FreeListsInUseUlong[InUseIndex];

                //
                //  Mask off the bits in the first ULONG that represent allocations
                //  smaller than we need.
                //

                FreeListsInUseUlong = *FreeListsInUse++ & ~((1 << ((ULONG) AllocationIndex & 0x1f)) - 1);

                //
                //  Begin unrolled loop to scan bit vector.
                //

                switch (InUseIndex) {

                case 0:

                    if (FreeListsInUseUlong) {

                        FreeListHead = &Heap->FreeLists[0];
                        break;
                    }

                    FreeListsInUseUlong = *FreeListsInUse++;

                    //
                    //  deliberate fallthrough to next ULONG
                    //

                case 1:

                    if (FreeListsInUseUlong) {

                        FreeListHead = &Heap->FreeLists[32];
                        break;
                    }

                    FreeListsInUseUlong = *FreeListsInUse++;

                    //
                    //  deliberate fallthrough to next ULONG
                    //

                case 2:

                    if (FreeListsInUseUlong) {

                        FreeListHead = &Heap->FreeLists[64];
                        break;
                    }

                    FreeListsInUseUlong = *FreeListsInUse++;

                    //
                    //  deliberate fallthrough to next ULONG
                    //

                case 3:

                    if (FreeListsInUseUlong) {

                        FreeListHead = &Heap->FreeLists[96];
                        break;
                    }

                    //
                    //  deliberate fallthrough to non dedicated list
                    //

                default:

                    //
                    //  No suitable entry on the free list was found.
                    //

                    goto LookInNonDedicatedList;
                }

                //
                //  A free list has been found with a large enough allocation.
                //  FreeListHead contains the base of the vector it was found in.
                //  FreeListsInUseUlong contains the vector.
                //

                FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                //
                //  Grab the free block and remove it from the free list
                //

                FreeBlock = CONTAINING_RECORD( FreeListHead->Blink,
                                               HEAP_FREE_ENTRY,
                                               FreeList );

                RtlpFastRemoveDedicatedFreeBlock( Heap, FreeBlock );

    SplitFreeBlock:

                //
                //  Save the blocks flags and decrement the amount of
                //  free space left in the heap
                //

                FreeFlags = FreeBlock->Flags;
                Heap->TotalFreeSize -= FreeBlock->Size;

                //
                //  Mark the block busy
                //

                BusyBlock = (PHEAP_ENTRY)FreeBlock;
                BusyBlock->Flags = HEAP_ENTRY_BUSY;

                //
                //  Compute the size (i.e., index) of the amount from this block
                //  that we don't need and can return to the free list
                //

                FreeSize = BusyBlock->Size - AllocationIndex;

                //
                //  Finish setting up the rest of the new busy block
                //

                BusyBlock->Size = (USHORT)AllocationIndex;
                BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);
                BusyBlock->SmallTagIndex = 0;

                //
                //  Now if the size that we are going to free up is not zero
                //  then lets get to work and to the split.
                //

                if (FreeSize != 0) {

                    //
                    //  But first we won't ever bother doing a split that only
                    //  gives us 8 bytes back.  So if free size is one then just
                    //  bump up the size of the new busy block
                    //

                    if (FreeSize == 1) {

                        BusyBlock->Size += 1;
                        BusyBlock->UnusedBytes += sizeof( HEAP_ENTRY );

                    } else {

                        //
                        //  Get a pointer to where the new free block will be.
                        //  When we split a block the first part goes to the new
                        //  busy block and the second part goes back to the free
                        //  list
                        //

                        SplitBlock = (PHEAP_FREE_ENTRY)(BusyBlock + AllocationIndex);

                        //
                        //  Reset the flags that we copied from the original free list
                        //  header, and set it other size fields.
                        //

                        SplitBlock->Flags = FreeFlags;
                        SplitBlock->PreviousSize = (USHORT)AllocationIndex;
                        SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;
                        SplitBlock->Size = (USHORT)FreeSize;

                        //
                        //  If nothing else follows this entry then we will insert
                        //  this into the corresponding free list (and update
                        //  Segment->LastEntryInSegment)
                        //

                        if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                            RtlpFastInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize);
                            Heap->TotalFreeSize += FreeSize;

                        } else {

                            //
                            //  Otherwise we need to check the following block
                            //  and if it is busy then update its previous size
                            //  before inserting our new free block into the
                            //  free list
                            //

                            SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

                            if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                                SplitBlock2->PreviousSize = (USHORT)FreeSize;

                                RtlpFastInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );
                                Heap->TotalFreeSize += FreeSize;

                            } else {

                                //
                                //  The following block is free so we'll merge
                                //  these to blocks. by first merging the flags
                                //

                                SplitBlock->Flags = SplitBlock2->Flags;

                                //
                                //  Removing the second block from its free list
                                //

                                RtlpFastRemoveFreeBlock( Heap, SplitBlock2 );

                                //
                                //  Updating the free total number of free bytes
                                //  in the heap and updating the size of the new
                                //  free block
                                //

                                Heap->TotalFreeSize -= SplitBlock2->Size;
                                FreeSize += SplitBlock2->Size;

                                //
                                //  If the new free block is still less than the
                                //  maximum heap block size then we'll simply
                                //  insert it back in the free list
                                //

                                if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                                    SplitBlock->Size = (USHORT)FreeSize;

                                    //
                                    //  Again check if the new following block
                                    //  exists and if so then updsate is previous
                                    //  size
                                    //

                                    if (!(SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                        ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;
                                    }

                                    //
                                    //  Insert the new free block into the free
                                    //  list and update the free heap size
                                    //

                                    RtlpFastInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );
                                    Heap->TotalFreeSize += FreeSize;

                                } else {

                                    //
                                    //  The new free block is pretty large so we
                                    //  need to call a private routine to do the
                                    //  insert
                                    //

                                    RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                                }
                            }
                        }

                        //
                        //  Now that free flags made it back into a free block
                        //  we can zero out what we saved.
                        //

                        FreeFlags = 0;

                        //
                        //  If splitblock now last, update LastEntryInSegment
                        //

                        if (SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                            PHEAP_SEGMENT Segment;

                            Segment = Heap->Segments[SplitBlock->SegmentIndex];
                            Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                        }
                    }
                }

                //
                //  If there are no following entries then mark the new block as
                //  such
                //

                if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                    BusyBlock->Flags |= HEAP_ENTRY_LAST_ENTRY;
                }
            }

            //
            //  Return the address of the user portion of the allocated block.
            //  This is the byte following the header.
            //

            ReturnValue = BusyBlock + 1;

            //
            //  **** Release the lock before the zero memory call
            //

            if (LockAcquired) {

                RtlReleaseLockRoutine( Heap->LockVariable );

                LockAcquired = FALSE;
            }
            
            //
            //  If the flags indicate that we should zero memory then do it now
            //

            if (Flags & HEAP_ZERO_MEMORY) {

                RtlZeroMemory( ReturnValue, Size );
            }

            //
            //  And return the allocated block to our caller
            //

            leave;

        //
        //  Otherwise the allocation request is bigger than the last dedicated
        //  free list size.  Now check if the size is within our threshold.
        //  Meaning that it could be in the [0] free list
        //

        } else if (AllocationIndex <= Heap->VirtualMemoryThreshold) {

    LookInNonDedicatedList:

            //
            //  The following code cycles through the [0] free list until
            //  it finds a block that satisfies the request.  The list
            //  is sorted so the search is can be terminated early on success
            //

            FreeListHead = &Heap->FreeLists[0];
            
            //
            //  Check if the largest block in the list is smaller than the request
            //

            Next = FreeListHead->Blink;

            if (FreeListHead != Next) {
                
                FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                if (FreeBlock->Size >= AllocationIndex) {

                    //
                    //  Here we are sure there is at least a block here larger than
                    //  the requested size. Start searching from the first block
                    //

                    Next = FreeListHead->Flink;
                    
                    while (FreeListHead != Next) {

                        FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                        if (FreeBlock->Size >= AllocationIndex) {

                            //
                            //  We've found something that we can use so now remove
                            //  it from the free list and go to where we treat spliting
                            //  a free block.  Note that the block we found here might
                            //  actually be the exact size we need and that is why
                            //  in the split free block case we have to consider having
                            //  nothing free after the split
                            //

                            RtlpFastRemoveNonDedicatedFreeBlock( Heap, FreeBlock );

                            goto SplitFreeBlock;
                        }

                        Next = Next->Flink;
                    }
                }
            }

            //
            //  The [0] list is either empty or everything is too small
            //  so now extend the heap which should get us something less
            //  than or equal to the virtual memory threshold
            //

            FreeBlock = RtlpExtendHeap( Heap, AllocationSize );

            //
            //  And provided we got something we'll treat it just like the previous
            //  split free block cases
            //

            if (FreeBlock != NULL) {

                RtlpFastRemoveNonDedicatedFreeBlock( Heap, FreeBlock );

                goto SplitFreeBlock;
            }

            //
            //  We weren't able to extend the heap so we must be out of memory
            //

            Status = STATUS_NO_MEMORY;

        //
        //  At this point the allocation is way too big for any of the free lists
        //  and we can only satisfy this request if the heap is growable
        //

        } else if (Heap->Flags & HEAP_GROWABLE) {

            PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

            VirtualAllocBlock = NULL;

            //
            //  Compute how much memory we will need for this allocation which
            //  will include the allocation size plus a header, and then go
            //  get the committed memory
            //

            AllocationSize += FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

            Status = ZwAllocateVirtualMemory( (PVOID *)&VirtualAllocBlock,
                                              0,
                                              &AllocationSize,
                                              MEM_COMMIT | ((Flags & HEAP_ZERO_MEMORY) ? 0 : MEM_NOZERO),
                                              PAGE_READWRITE );

            if (NT_SUCCESS(Status)) {

                //
                //  Just committed, already zero.  Fill in the new block
                //  and insert it in the list of big allocation
                //
                RtlZeroMemory(VirtualAllocBlock, sizeof(*VirtualAllocBlock));

                VirtualAllocBlock->BusyBlock.Size = (USHORT)(AllocationSize - Size);
                VirtualAllocBlock->BusyBlock.Flags = HEAP_ENTRY_VIRTUAL_ALLOC | HEAP_ENTRY_EXTRA_PRESENT | HEAP_ENTRY_BUSY;
                VirtualAllocBlock->CommitSize = AllocationSize;
                VirtualAllocBlock->ReserveSize = AllocationSize;

                InsertTailList( &Heap->VirtualAllocdBlocks, (PLIST_ENTRY)VirtualAllocBlock );

                //
                //  Return the address of the user portion of the allocated block.
                //  This is the byte following the header.
                //

                ReturnValue = (PHEAP_ENTRY)(VirtualAllocBlock + 1);

                leave;
            }

        } else {

            Status = STATUS_BUFFER_TOO_SMALL;
        }

        //
        //  This is the error return.
        //

        if (Flags & HEAP_GENERATE_EXCEPTIONS) {

            //
            //  Construct an exception record.
            //

            ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
            ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
            ExceptionRecord.NumberParameters = 1;
            ExceptionRecord.ExceptionFlags = 0;
            ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;

            RtlRaiseException( &ExceptionRecord );
        }

        SET_LAST_STATUS(Status);

        ReturnValue = NULL;

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return ReturnValue;
}


PVOID
RtlAllocateHeapSlowly (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine does the equivalent of Rtl Allocate Heap but it does it will
    additional heap consistency checking logic and tagging.

Arguments:

    HeapHandle - Supplies a pointer to an initialized heap structure

    Flags - Specifies the set of flags to use to control the allocation

    Size - Specifies the size, in bytes, of the allocation

Return Value:

    PVOID - returns a pointer to the newly allocated block

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    PVOID ReturnValue = NULL;
    PULONG FreeListsInUse;
    ULONG FreeListsInUseUlong;
    SIZE_T AllocationSize;
    SIZE_T FreeSize, AllocationIndex;
    UCHAR EntryFlags, FreeFlags;
    PLIST_ENTRY FreeListHead, Next;
    PHEAP_ENTRY BusyBlock;
    PHEAP_FREE_ENTRY FreeBlock, SplitBlock, SplitBlock2;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    NTSTATUS Status;
    EXCEPTION_RECORD ExceptionRecord;
    SIZE_T ZeroSize = 0;

    RTL_PAGED_CODE();

    //
    //  Note that Flags has already been OR'd with Heap->ForceFlags.
    //

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case check if we should be using the debug version
    //  of heap allocation
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugAllocateHeap( HeapHandle, Flags, Size );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  If the size is greater than maxlong then say we can't allocate that
    //  much and return the error to our caller
    //

    if (Size > 0x7fffffff) {

        SET_LAST_STATUS( STATUS_NO_MEMORY );

        return NULL;
    }

    //
    //  Round up the requested size to the allocation granularity.  Note
    //  that if the request is for zero bytes we will still allocate memory,
    //
    //      Allocation size will be either 16, 24, 32, ...
    //      Allocation index will be 2, 3, 4, ...
    //

    AllocationSize = ((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask;

    //
    //  Generate the flags needed for this heap entry.  Mark it busy and add
    //  any user settable bits.  Also if the input flag indicates any entry
    //  extra fields and we have a tag to use then make room for the extra
    //  fields in the heap entry
    //

    EntryFlags = (UCHAR)(HEAP_ENTRY_BUSY | ((Flags & HEAP_SETTABLE_USER_FLAGS) >> 4));

    if ((Flags & HEAP_NEED_EXTRA_FLAGS) || (Heap->PseudoTagEntries != NULL)) {

        EntryFlags |= HEAP_ENTRY_EXTRA_PRESENT;
        AllocationSize += sizeof( HEAP_ENTRY_EXTRA );
    }

    AllocationIndex = AllocationSize >> HEAP_GRANULARITY_SHIFT;

    try {

        //
        //  Lock the free list.
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Do all the actual heap work under the protection of a try-except clause
        //  to protect us from corruption
        //

        try {

            //
            //  If the allocation index is less than the maximum free list size
            //  then we can use the index to check the free list otherwise we have
            //  to either pull the entry off of the [0] index list or allocate
            //  memory directly for this request.
            //

            if (AllocationIndex < HEAP_MAXIMUM_FREELISTS) {

                //
                //  With a size that matches a free list size grab the head
                //  of the list and check if there is an available entry
                //

                FreeListHead = &Heap->FreeLists[ AllocationIndex ];

                if ( !IsListEmpty( FreeListHead ))  {

                    //
                    //  We're in luck the list has an entry so now get the free
                    //  entry,  copy its flags, remove it from the free list
                    //

                    FreeBlock = CONTAINING_RECORD( FreeListHead->Flink,
                                                   HEAP_FREE_ENTRY,
                                                   FreeList );

                    FreeFlags = FreeBlock->Flags;

                    RtlpRemoveFreeBlock( Heap, FreeBlock );

                    //
                    //  Adjust the total number of bytes free in the heap
                    //

                    Heap->TotalFreeSize -= AllocationIndex;

                    //
                    //  Mark the block as busy and and set the number of bytes
                    //  unused and tag index.  Also if it is the last entry
                    //  then keep that flag.
                    //

                    BusyBlock = (PHEAP_ENTRY)FreeBlock;
                    BusyBlock->Flags = EntryFlags | (FreeFlags & HEAP_ENTRY_LAST_ENTRY);
                    BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);

                } else {

                    //
                    //  The free list that matches our request is empty.  We know
                    //  that there are 128 free lists managed by a 4 ulong bitmap.
                    //  The next big if-else-if statement will decide which ulong
                    //  we tackle
                    //
                    //  Check if the requested allocation index within the first
                    //  quarter of the free lists.
                    //

                    if (AllocationIndex < (HEAP_MAXIMUM_FREELISTS * 1) / 4) {

                        //
                        //  Grab a pointer to the corresponding bitmap ulong, and
                        //  then get the bit we're actually interested in to be the
                        //  first bit of the ulong.
                        //

                        FreeListsInUse = &Heap->u.FreeListsInUseUlong[ 0 ];
                        FreeListsInUseUlong = *FreeListsInUse++ >> ((ULONG) AllocationIndex & 0x1F);

                        //
                        //  If the remaining bitmap has any bits set then we know
                        //  there is a non empty list that is larger than our
                        //  requested index so find that bit and compute the list
                        //  head of the next non empty list
                        //

                        if (FreeListsInUseUlong) {

                            FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                        } else {

                            //
                            //  The rest of the first ulong is all zeros so we need
                            //  to move to the second ulong
                            //

                            FreeListsInUseUlong = *FreeListsInUse++;

                            //
                            //  Check if the second ulong has any bits set and if
                            //  so then compute the list head of the next non empty
                            //  list
                            //

                            if (FreeListsInUseUlong) {

                                FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 1) / 4) -
                                    (AllocationIndex & 0x1F)  +
                                    RtlFindFirstSetRightMember( FreeListsInUseUlong );

                            } else {

                                //
                                //  Do the same test for the third ulong
                                //

                                FreeListsInUseUlong = *FreeListsInUse++;

                                if (FreeListsInUseUlong) {

                                    FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 2) / 4) -
                                        (AllocationIndex & 0x1F) +
                                        RtlFindFirstSetRightMember( FreeListsInUseUlong );

                                } else {

                                    //
                                    //  Repeat the test for the forth ulong, and if
                                    //  that one is also empty then we need to grab
                                    //  the allocation off of the [0] index list
                                    //

                                    FreeListsInUseUlong = *FreeListsInUse++;

                                    if (FreeListsInUseUlong) {

                                        FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 3) / 4) -
                                            (AllocationIndex & 0x1F)  +
                                            RtlFindFirstSetRightMember( FreeListsInUseUlong );

                                    } else {

                                        goto LookInNonDedicatedList;
                                    }
                                }
                            }
                        }

                    //
                    //  Otherwise check if the requested allocation index lies
                    //  within the second quarter of the free lists.  We repeat the
                    //  test just like we did above on the second, third, and forth
                    //  bitmap ulongs.
                    //

                    } else if (AllocationIndex < (HEAP_MAXIMUM_FREELISTS * 2) / 4) {

                        FreeListsInUse = &Heap->u.FreeListsInUseUlong[ 1 ];
                        FreeListsInUseUlong = *FreeListsInUse++ >> ((ULONG) AllocationIndex & 0x1F);

                        if (FreeListsInUseUlong) {

                            FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                        } else {

                            FreeListsInUseUlong = *FreeListsInUse++;

                            if (FreeListsInUseUlong) {

                                FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 1) / 4) -
                                    (AllocationIndex & 0x1F)  +
                                    RtlFindFirstSetRightMember( FreeListsInUseUlong );

                            } else {

                                FreeListsInUseUlong = *FreeListsInUse++;

                                if (FreeListsInUseUlong) {

                                    FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 2) / 4) -
                                        (AllocationIndex & 0x1F)  +
                                        RtlFindFirstSetRightMember( FreeListsInUseUlong );

                                } else {

                                    goto LookInNonDedicatedList;
                                }
                            }
                        }

                    //
                    //  Otherwise check if the requested allocation index lies
                    //  within the third quarter of the free lists. We repeat the
                    //  test just like we did above on the third and forth bitmap
                    //  ulongs
                    //

                    } else if (AllocationIndex < (HEAP_MAXIMUM_FREELISTS * 3) / 4) {

                        FreeListsInUse = &Heap->u.FreeListsInUseUlong[ 2 ];
                        FreeListsInUseUlong = *FreeListsInUse++ >> ((ULONG) AllocationIndex & 0x1F);

                        if (FreeListsInUseUlong) {

                            FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                        } else {

                            FreeListsInUseUlong = *FreeListsInUse++;

                            if (FreeListsInUseUlong) {

                                FreeListHead += ((HEAP_MAXIMUM_FREELISTS * 1) / 4) -
                                    (AllocationIndex & 0x1F)  +
                                    RtlFindFirstSetRightMember( FreeListsInUseUlong );

                            } else {

                                goto LookInNonDedicatedList;
                            }
                        }

                    //
                    //  Lastly the requested allocation index must lie within the
                    //  last quarter of the free lists.  We repeat the test just
                    //  like we did above on the forth ulong
                    //

                    } else {

                        FreeListsInUse = &Heap->u.FreeListsInUseUlong[ 3 ];
                        FreeListsInUseUlong = *FreeListsInUse++ >> ((ULONG) AllocationIndex & 0x1F);

                        if (FreeListsInUseUlong) {

                            FreeListHead += RtlFindFirstSetRightMember( FreeListsInUseUlong );

                        } else {

                            goto LookInNonDedicatedList;
                        }
                    }

                    //
                    //  At this point the free list head points to a non empty free
                    //  list that is of greater size than we need.
                    //

                    FreeBlock = CONTAINING_RECORD( FreeListHead->Flink,
                                                   HEAP_FREE_ENTRY,
                                                   FreeList );

    SplitFreeBlock:

                    //
                    //  Remember the flags that go with this block and remove it
                    //  from its list
                    //

                    FreeFlags = FreeBlock->Flags;

                    RtlpRemoveFreeBlock( Heap, FreeBlock );

                    //
                    //  Adjust the amount free in the heap
                    //

                    Heap->TotalFreeSize -= FreeBlock->Size;

                    //
                    //  Mark the block busy
                    //

                    BusyBlock = (PHEAP_ENTRY)FreeBlock;
                    BusyBlock->Flags = EntryFlags;

                    //
                    //  Compute the size (i.e., index) of the amount from this
                    //  block that we don't need and can return to the free list
                    //

                    FreeSize = BusyBlock->Size - AllocationIndex;

                    //
                    //  Finish setting up the rest of the new busy block
                    //

                    BusyBlock->Size = (USHORT)AllocationIndex;
                    BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);

                    //
                    //  Now if the size that we are going to free up is not zero
                    //  then lets get to work and to the split.
                    //

                    if (FreeSize != 0) {

                        //
                        //  But first we won't ever bother doing a split that only
                        //  gives us 8 bytes back.  So if free size is one then
                        //  just bump up the size of the new busy block
                        //

                        if (FreeSize == 1) {

                            BusyBlock->Size += 1;
                            BusyBlock->UnusedBytes += sizeof( HEAP_ENTRY );

                        } else {

                            //
                            //  Get a pointer to where the new free block will be.
                            //  When we split a block the first part goes to the
                            //  new busy block and the second part goes back to the
                            //  free list
                            //

                            SplitBlock = (PHEAP_FREE_ENTRY)(BusyBlock + AllocationIndex);

                            //
                            //  Reset the flags that we copied from the original
                            //  free list header, and set it other size fields.
                            //

                            SplitBlock->Flags = FreeFlags;
                            SplitBlock->PreviousSize = (USHORT)AllocationIndex;
                            SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;
                            SplitBlock->Size = (USHORT)FreeSize;

                            //
                            //  If nothing else follows this entry then we will
                            //  insert this into the corresponding free list
                            //

                            if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                                RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                Heap->TotalFreeSize += FreeSize;

                            } else {

                                //
                                //  Otherwise we need to check the following block
                                //  and if it is busy then update its previous size
                                //  before inserting our new free block into the
                                //  free list
                                //

                                SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

                                if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                                    SplitBlock2->PreviousSize = (USHORT)FreeSize;

                                    RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                    Heap->TotalFreeSize += FreeSize;

                                } else {

                                    //
                                    //  The following block is free so we'll merge
                                    //  these to blocks. by first merging the flags
                                    //

                                    SplitBlock->Flags = SplitBlock2->Flags;

                                    //
                                    //  Removing the second block from its free
                                    //  list
                                    //

                                    RtlpRemoveFreeBlock( Heap, SplitBlock2 );

                                    //
                                    //  Updating the free total number of free
                                    //  bytes in the heap and updating the size of
                                    //  the new free block
                                    //

                                    Heap->TotalFreeSize -= SplitBlock2->Size;
                                    FreeSize += SplitBlock2->Size;

                                    //
                                    //  If the new free block is still less than
                                    //  the maximum heap block size then we'll
                                    //  simply insert it back in the free list
                                    //

                                    if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                                        SplitBlock->Size = (USHORT)FreeSize;

                                        //
                                        //  Again check if the new following block
                                        //  exists and if so then updsate is
                                        //  previous size
                                        //

                                        if (!(SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                            ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;
                                        }

                                        //
                                        //  Insert the new free block into the free
                                        //  list and update the free heap size
                                        //

                                        RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                        Heap->TotalFreeSize += FreeSize;

                                    } else {

                                        //
                                        //  The new free block is pretty large so
                                        //  we need to call a private routine to do
                                        //  the insert
                                        //

                                        RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                                    }
                                }
                            }

                            //
                            //  Now that free flags made it back into a free block
                            //  we can zero out what we saved.
                            //

                            FreeFlags = 0;

                            //
                            //  If splitblock now last, update LastEntryInSegment
                            //

                            if (SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                                PHEAP_SEGMENT Segment;

                                Segment = Heap->Segments[SplitBlock->SegmentIndex];
                                Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                            }

                        }
                    }

                    //
                    //  If there are no following entries then mark the new block
                    //  as such
                    //

                    if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                        BusyBlock->Flags |= HEAP_ENTRY_LAST_ENTRY;
                    }
                }

                //
                //  Return the address of the user portion of the allocated block.
                //  This is the byte following the header.
                //

                ReturnValue = BusyBlock + 1;

                //
                //  If the flags indicate that we should zero memory then
                //  remember how much to zero.  We'll do the zeroing later
                //

                if (Flags & HEAP_ZERO_MEMORY) {

                    ZeroSize = Size;

                //
                //  Otherwise if the flags indicate that we should fill heap then
                //  it it now.
                //

                }
#if DBG
                else if (Heap->Flags & HEAP_FREE_CHECKING_ENABLED) {

                    RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1), Size & ~0x3, ALLOC_HEAP_FILL );
                }

                //
                //  If the flags indicate that we should do tail checking then copy
                //  the fill pattern right after the heap block.
                //

                if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

                    RtlFillMemory( (PCHAR)ReturnValue + Size,
                                   CHECK_HEAP_TAIL_SIZE,
                                   CHECK_HEAP_TAIL_FILL );

                    BusyBlock->Flags |= HEAP_ENTRY_FILL_PATTERN;
                }
#endif // DBG

                BusyBlock->SmallTagIndex = 0;

                //
                //  If the flags indicate that there is an extra block persent then
                //  we'll fill it in
                //

                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                    RtlZeroMemory( ExtraStuff, sizeof( *ExtraStuff ));

    #ifndef NTOS_KERNEL_RUNTIME

                //
                //  In the non kernel case the tagging goes in either the extra
                //  stuff of the busy block small tag index
                //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        ExtraStuff->TagIndex = RtlpUpdateTagEntry( Heap,
                                                                   (USHORT)((Flags & HEAP_TAG_MASK) >> HEAP_TAG_SHIFT),
                                                                   0,
                                                                   BusyBlock->Size,
                                                                   AllocationAction );
                    }

                } else if (IS_HEAP_TAGGING_ENABLED()) {

                    BusyBlock->SmallTagIndex = (UCHAR)RtlpUpdateTagEntry( Heap,
                                                                          (USHORT)((Flags & HEAP_SMALL_TAG_MASK) >> HEAP_TAG_SHIFT),
                                                                          0,
                                                                          BusyBlock->Size,
                                                                          AllocationAction );

    #endif // NTOS_KERNEL_RUNTIME

                }

                //
                //  Return the address of the user portion of the allocated block.
                //  This is the byte following the header.
                //

                leave;

            //
            //  Otherwise the allocation request is bigger than the last dedicated
            //  free list size.  Now check if the size is within our threshold.
            //  Meaning that it could be in the [0] free list
            //

            } else if (AllocationIndex <= Heap->VirtualMemoryThreshold) {

    LookInNonDedicatedList:

                //
                //  The following code cycles through the [0] free list until
                //  it finds a block that satisfies the request.  The list
                //  is sorted so the search is can be terminated early on success
                //

                FreeListHead = &Heap->FreeLists[ 0 ];
                Next = FreeListHead->Flink;

                while (FreeListHead != Next) {

                    FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

                    if (FreeBlock->Size >= AllocationIndex) {

                        //
                        //  We've found something that we can use so now go to
                        //  where we treat spliting a free block.  Note that
                        //  the block we found here might actually be the exact
                        //  size we need and that is why in the split free block
                        //  case we have to consider having nothing free after the
                        //  split
                        //

                        goto SplitFreeBlock;

                    } else {

                        Next = Next->Flink;
                    }
                }

                //
                //  The [0] list is either empty or everything is too small
                //  so now extend the heap which should get us something less
                //  than or equal to the virtual memory threshold
                //

                FreeBlock = RtlpExtendHeap( Heap, AllocationSize );

                //
                //  And provided we got something we'll treat it just like the
                //  previous split free block cases
                //

                if (FreeBlock != NULL) {

                    goto SplitFreeBlock;
                }

                //
                //  We weren't able to extend the heap so we must be out of memory
                //

                Status = STATUS_NO_MEMORY;

            //
            //  At this point the allocation is way too big for any of the free
            //  lists and we can only satisfy this request if the heap is growable
            //

            } else if (Heap->Flags & HEAP_GROWABLE) {

                PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

                VirtualAllocBlock = NULL;

                //
                //  Compute how much memory we will need for this allocation which
                //  will include the allocation size plus a header, and then go
                //  get the committed memory
                //

                AllocationSize += FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                Status = ZwAllocateVirtualMemory( (PVOID *)&VirtualAllocBlock,
                                                  0,
                                                  &AllocationSize,
                                                  MEM_COMMIT,
                                                  PAGE_READWRITE );

                if (NT_SUCCESS( Status )) {

                    //
                    //  Just committed, already zero.  Fill in the new block
                    //  and insert it in the list of big allocation
                    //

                    VirtualAllocBlock->BusyBlock.Size = (USHORT)(AllocationSize - Size);
                    VirtualAllocBlock->BusyBlock.Flags = EntryFlags | HEAP_ENTRY_VIRTUAL_ALLOC | HEAP_ENTRY_EXTRA_PRESENT;
                    VirtualAllocBlock->CommitSize = AllocationSize;
                    VirtualAllocBlock->ReserveSize = AllocationSize;

    #ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  In the non kernel case see if we need to add heap tagging
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        VirtualAllocBlock->ExtraStuff.TagIndex =
                            RtlpUpdateTagEntry( Heap,
                                                (USHORT)((Flags & HEAP_SMALL_TAG_MASK) >> HEAP_TAG_SHIFT),
                                                0,
                                                VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT,
                                                VirtualAllocationAction );
                    }

    #endif // NTOS_KERNEL_RUNTIME

                    InsertTailList( &Heap->VirtualAllocdBlocks, (PLIST_ENTRY)VirtualAllocBlock );

                    //
                    //  Return the address of the user portion of the allocated
                    //  block.  This is the byte following the header.
                    //

                    ReturnValue = (PHEAP_ENTRY)(VirtualAllocBlock + 1);

                    leave;
                }

            //
            //  Otherwise we have an error condition
            //

            } else {

                Status = STATUS_BUFFER_TOO_SMALL;
            }

            SET_LAST_STATUS( Status );

            if (Flags & HEAP_GENERATE_EXCEPTIONS) {

                //
                //  Construct an exception record.
                //

                ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
                ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
                ExceptionRecord.NumberParameters = 1;
                ExceptionRecord.ExceptionFlags = 0;
                ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;

                RtlRaiseException( &ExceptionRecord );
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

        //
        //  Check if there is anything to zero out
        //

        if ( ZeroSize ) {

            RtlZeroMemory( ReturnValue, ZeroSize );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return ReturnValue;
}



PVOID
RtlReAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine will resize a user specified heap block.  The new size
    can either be smaller or larger than the current block size.

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of heap flags to augment those already
        enforced by the heap

    BaseAddress - Supplies the current address of a block allocated
        from heap.  We will try and resize this block at its current
        address, but it could possibly move if this heap structure
        allows for relocation

    Size - Supplies the size, in bytes, for the newly resized heap
        block

Return Value:

    PVOID - A pointer to the resized block.  If the block had to move
        then this address will not be equal to the input base address

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    SIZE_T AllocationSize;
    PHEAP_ENTRY BusyBlock, NewBusyBlock;
    PHEAP_ENTRY_EXTRA OldExtraStuff, NewExtraStuff;
    SIZE_T FreeSize;
    BOOLEAN LockAcquired = FALSE;
    PVOID NewBaseAddress;
    PHEAP_FREE_ENTRY SplitBlock, SplitBlock2;
    SIZE_T OldSize;
    SIZE_T AllocationIndex;
    SIZE_T OldAllocationIndex;
    UCHAR FreeFlags;
    NTSTATUS Status;
    PVOID DeCommitAddress;
    SIZE_T DeCommitSize;
    EXCEPTION_RECORD ExceptionRecord;

    //
    //  If there isn't an address to relocate the heap at then our work is done
    //

    if (BaseAddress == NULL) {

        SET_LAST_STATUS( STATUS_SUCCESS );

        return NULL;
    }

#ifndef NTOS_KERNEL_RUNTIME
#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlReAllocateNtHeap( HeapHandle, Flags, BaseAddress, Size );
        }
    }
#endif // NTHEAP_ENABLED
#endif

    //
    //  Augment the heap flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if we should simply call the debug version of heap to do the work
    //

#ifndef NTOS_KERNEL_RUNTIME
    if (DEBUG_HEAP( Flags)) {

        return RtlDebugReAllocateHeap( HeapHandle, Flags, BaseAddress, Size );
    }
#endif

    //
    //  Make sure we didn't get a negative heap size
    //

    if (Size > 0x7fffffff) {

        SET_LAST_STATUS( STATUS_NO_MEMORY );

        return NULL;
    }

    //
    //  Round the requested size up to the allocation granularity.  Note
    //  that if the request is for 0 bytes, we still allocate memory, because
    //  we add in an extra byte to protect ourselves from idiots.
    //

    AllocationSize = ((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask;

    if ((Flags & HEAP_NEED_EXTRA_FLAGS) ||
        (Heap->PseudoTagEntries != NULL) ||
        ((((PHEAP_ENTRY)BaseAddress)-1)->Flags & HEAP_ENTRY_EXTRA_PRESENT)) {

        AllocationSize += sizeof( HEAP_ENTRY_EXTRA );
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;

            //
            //  Because it is now zero the following statement will set the no
            //  serialize bit
            //

            Flags ^= HEAP_NO_SERIALIZE;
        }

        try {

            //
            //  Compute the heap block address for user specified block
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            //
            //  Check if the block is not in use then it is an error
            //

            if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

                //
                //  Bail if not a busy block.
                //

                leave;

            //
            //  We need the current (i.e., old) size and allocation of the
            //  block.  Check if the block is a big allocation.  The size
            //  field of a big block is really the unused by count
            //

            } else if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                OldSize = RtlpGetSizeOfBigBlock( BusyBlock );

                OldAllocationIndex = (OldSize + BusyBlock->Size) >> HEAP_GRANULARITY_SHIFT;

                //
                //  We'll need to adjust the new allocation size to account
                //  for the big block header and then round it up to a page
                //

                AllocationSize += FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );
                AllocationSize = ROUND_UP_TO_POWER2( AllocationSize, PAGE_SIZE );

            //
            //  Otherwise the block is in use and is a small allocation
            //

            } else {

                OldAllocationIndex = BusyBlock->Size;

                OldSize = (OldAllocationIndex << HEAP_GRANULARITY_SHIFT) -
                          BusyBlock->UnusedBytes;
            }

            //
            //  Compute the new allocation index
            //

            AllocationIndex = AllocationSize >> HEAP_GRANULARITY_SHIFT;

            //
            //  At this point we have the old size and index, and the new size
            //  and index
            //
            //  See if new size less than or equal to the current size.
            //

            if (AllocationIndex <= OldAllocationIndex) {

                //
                //  If the new allocation index is only one less then the current
                //  index then make the sizes equal
                //

                if (AllocationIndex + 1 == OldAllocationIndex) {

                    AllocationIndex += 1;
                    AllocationSize += sizeof( HEAP_ENTRY );
                }

                //
                //  Calculate new residual (unused) amount
                //

                if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                    //
                    //  In a big block the size is really the unused byte count
                    //

                    BusyBlock->Size = (USHORT)(AllocationSize - Size);

                } else if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    //
                    //  The extra stuff struct goes after the data.  So compute
                    //  the old and new extra stuff location and copy the data
                    //

                    OldExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size - 1);

                    NewExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + AllocationIndex - 1);

                    *NewExtraStuff = *OldExtraStuff;

#ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  If we're doing heap tagging then update the tag entry
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        NewExtraStuff->TagIndex =
                            RtlpUpdateTagEntry( Heap,
                                                NewExtraStuff->TagIndex,
                                                OldAllocationIndex,
                                                AllocationIndex,
                                                ReAllocationAction );
                    }
#endif

                    BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);

                } else {

                    //
                    //  If we're doing heap tagging then update the tag entry
                    //

#ifndef NTOS_KERNEL_RUNTIME

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        BusyBlock->SmallTagIndex = (UCHAR)
                            RtlpUpdateTagEntry( Heap,
                                                BusyBlock->SmallTagIndex,
                                                BusyBlock->Size,
                                                AllocationIndex,
                                                ReAllocationAction );
                    }

#endif

                    BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);
                }

                //
                //  Check if the block is getting bigger, then fill in the extra
                //  space.
                //
                //  **** how can this happen if the allocation index is less than or
                //  **** equal to the old allocation index
                //

                if (Size > OldSize) {

                    //
                    //  See if we should zero the extra space
                    //

                    if (Flags & HEAP_ZERO_MEMORY) {

                        RtlZeroMemory( (PCHAR)BaseAddress + OldSize,
                                       Size - OldSize );

                    //
                    //  Otherwise see if we should fill the extra space
                    //

                    }
#if DBG
                    else if (Heap->Flags & HEAP_FREE_CHECKING_ENABLED) {

                        SIZE_T PartialBytes, ExtraSize;

                        PartialBytes = OldSize & (sizeof( ULONG ) - 1);

                        if (PartialBytes) {

                            PartialBytes = 4 - PartialBytes;
                        }

                        if (Size > (OldSize + PartialBytes)) {

                            ExtraSize = (Size - (OldSize + PartialBytes)) & ~(sizeof( ULONG ) - 1);

                            if (ExtraSize != 0) {

                                RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1) + OldSize + PartialBytes,
                                                    ExtraSize,
                                                    ALLOC_HEAP_FILL );
                            }
                        }
                    }
#endif // DBG
                }

#if DBG
                if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

                    RtlFillMemory( (PCHAR)(BusyBlock + 1) + Size,
                                   CHECK_HEAP_TAIL_SIZE,
                                   CHECK_HEAP_TAIL_FILL );
                }
#endif // DBG
                //
                //  If amount of change is greater than the size of a free block,
                //  then need to free the extra space.  Otherwise, nothing else to
                //  do.
                //

                if (AllocationIndex != OldAllocationIndex) {

                    FreeFlags = BusyBlock->Flags & ~HEAP_ENTRY_BUSY;

                    if (FreeFlags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                        PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

                        VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

#ifndef NTOS_KERNEL_RUNTIME

                        if (IS_HEAP_TAGGING_ENABLED()) {

                            VirtualAllocBlock->ExtraStuff.TagIndex =
                                RtlpUpdateTagEntry( Heap,
                                                    VirtualAllocBlock->ExtraStuff.TagIndex,
                                                    OldAllocationIndex,
                                                    AllocationIndex,
                                                    VirtualReAllocationAction );
                        }

#endif

                        DeCommitAddress = (PCHAR)VirtualAllocBlock + AllocationSize;

                        DeCommitSize = (OldAllocationIndex << HEAP_GRANULARITY_SHIFT) -
                                       AllocationSize;

                        Status = ZwFreeVirtualMemory( (PVOID *)&DeCommitAddress,
                                                      &DeCommitSize,
                                                      MEM_RELEASE );

                        if (!NT_SUCCESS( Status )) {

                            HeapDebugPrint(( "Unable to release memory at %p for %p bytes - Status == %x\n",
                                             DeCommitAddress, DeCommitSize, Status ));

                            HeapDebugBreak( NULL );

                        } else {

                            VirtualAllocBlock->CommitSize -= DeCommitSize;
                        }

                    } else {

                        //
                        //  Otherwise, shrink size of this block to new size, and make extra
                        //  space at end free.
                        //

                        SplitBlock = (PHEAP_FREE_ENTRY)(BusyBlock + AllocationIndex);

                        SplitBlock->Flags = FreeFlags;

                        SplitBlock->PreviousSize = (USHORT)AllocationIndex;

                        SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;

                        FreeSize = BusyBlock->Size - AllocationIndex;

                        BusyBlock->Size = (USHORT)AllocationIndex;

                        BusyBlock->Flags &= ~HEAP_ENTRY_LAST_ENTRY;

                        //
                        //  If the following block is uncommitted then we only need to
                        //  add this new entry to its free list
                        //

                        if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                            PHEAP_SEGMENT Segment;

                            Segment = Heap->Segments[SplitBlock->SegmentIndex];
                            Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;

                            SplitBlock->Size = (USHORT)FreeSize;

                            RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                            Heap->TotalFreeSize += FreeSize;

                        } else {

                            //
                            //  Otherwise get the next block and check if it is busy.  If it
                            //  is in use then add this new entry to its free list
                            //

                            SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

                            if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                                SplitBlock->Size = (USHORT)FreeSize;

                                ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;

                                RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                Heap->TotalFreeSize += FreeSize;

                            } else {

                                //
                                //  Otherwise the next block is not in use so we
                                //  should be able to merge with it.  Remove the
                                //  second free block and if the combined size is
                                //  still okay then merge the two blocks and add
                                //  the single block back in.  Otherwise call a
                                //  routine that will actually break it apart
                                //  before insertion.
                                //

                                SplitBlock->Flags = SplitBlock2->Flags;

                                RtlpRemoveFreeBlock( Heap, SplitBlock2 );

                                Heap->TotalFreeSize -= SplitBlock2->Size;

                                FreeSize += SplitBlock2->Size;

                                if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                                    SplitBlock->Size = (USHORT)FreeSize;

                                    if (!(SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                        ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;

                                    } else {

                                        PHEAP_SEGMENT Segment;

                                        Segment = Heap->Segments[SplitBlock->SegmentIndex];
                                        Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                                    }

                                    RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                    Heap->TotalFreeSize += FreeSize;

                                } else {

                                    RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                                }
                            }
                        }
                    }
                }

            } else {

                //
                //  At this point the new size is greater than the current size
                //
                //  If the block is a big allocation or we're not able to grow
                //  the block in place then we have a lot of work to do
                //

                if ((BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) ||
                    !RtlpGrowBlockInPlace( Heap, Flags, BusyBlock, Size, AllocationIndex )) {

                    //
                    //  We're growing the block.  Allocate a new block with the bigger
                    //  size, copy the contents of the old block to the new block and then
                    //  free the old block.  Return the address of the new block.
                    //

                    if (Flags & HEAP_REALLOC_IN_PLACE_ONLY) {

                        // HeapDebugPrint(( "Failing ReAlloc because cant do it inplace.\n" ));

                        BaseAddress = NULL;

                    } else {

                        //
                        //  Clear the tag bits from the flags
                        //

                        Flags &= ~HEAP_TAG_MASK;

                        //
                        //  If there is an extra struct present then get the tag
                        //  index from the extra stuff and augment the flags with
                        //  the tag index.
                        //

                        if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                            Flags &= ~HEAP_SETTABLE_USER_FLAGS;

                            Flags |= HEAP_SETTABLE_USER_VALUE |
                                     ((BusyBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS) << 4);

                            OldExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                            try {

                                if ((OldExtraStuff->TagIndex != 0) &&
                                    !(OldExtraStuff->TagIndex & HEAP_PSEUDO_TAG_FLAG)) {

                                    Flags |= OldExtraStuff->TagIndex << HEAP_TAG_SHIFT;
                                }

                            } except (EXCEPTION_EXECUTE_HANDLER) {

                                BusyBlock->Flags &= ~HEAP_ENTRY_EXTRA_PRESENT;
                            }

                        } else if (BusyBlock->SmallTagIndex != 0) {

                            //
                            //  There is not an extra stuff struct, but block
                            //  does have a small tag index so now add this small
                            //  tag to the flags
                            //

                            Flags |= BusyBlock->SmallTagIndex << HEAP_TAG_SHIFT;
                        }

                        //
                        //  Allocate from the heap space for the reallocation
                        //

                        NewBaseAddress = RtlAllocateHeap( HeapHandle,
                                                          Flags & ~HEAP_ZERO_MEMORY,
                                                          Size );

                        if (NewBaseAddress != NULL) {

                            //
                            //  We were able to get the allocation so now back up
                            //  to the heap block and if the block has an extra
                            //  stuff struct then copy over the extra stuff
                            //

                            NewBusyBlock = (PHEAP_ENTRY)NewBaseAddress - 1;

                            if (NewBusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                                NewExtraStuff = RtlpGetExtraStuffPointer( NewBusyBlock );

                                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                                    OldExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                                    NewExtraStuff->Settable = OldExtraStuff->Settable;

                                } else {

                                    RtlZeroMemory( NewExtraStuff, sizeof( *NewExtraStuff ));
                                }
                            }

                            //
                            //  Copy over the user's data area to the new block
                            //

                            RtlMoveMemory( NewBaseAddress, BaseAddress, Size < OldSize ? Size : OldSize );

                            //
                            //  Check if we grew the block and we should zero
                            //  the remaining part.
                            //
                            //  **** is this first test always true because we're
                            //  **** in the part that grows blocks
                            //

                            if (Size > OldSize && (Flags & HEAP_ZERO_MEMORY)) {

                                RtlZeroMemory( (PCHAR)NewBaseAddress + OldSize,
                                               Size - OldSize );
                            }

                            //
                            //  Release the old block
                            //

                            RtlFreeHeap( HeapHandle,
                                         Flags,
                                         BaseAddress );
                        }

                        BaseAddress = NewBaseAddress;
                    }
                }
            }

            if ((BaseAddress == NULL) && (Flags & HEAP_GENERATE_EXCEPTIONS)) {

                //
                //  Construct an exception record.
                //

                ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
                ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
                ExceptionRecord.NumberParameters = 1;
                ExceptionRecord.ExceptionFlags = 0;
                ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;

                RtlRaiseException( &ExceptionRecord );
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
            BaseAddress = NULL;

        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return BaseAddress;
}


//
//  Local Support routine
//

BOOLEAN
RtlpGrowBlockInPlace (
    IN PHEAP Heap,
    IN ULONG Flags,
    IN PHEAP_ENTRY BusyBlock,
    IN SIZE_T Size,
    IN SIZE_T AllocationIndex
    )

/*++

Routine Description:

    This routine will try and grow a heap allocation block at its current
    location

Arguments:

    Heap - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags to augment those already enforced by
        the heap

    BusyBlock - Supplies a pointer to the block being resized

    Size - Supplies the size, in bytes, needed by the resized block

    AllocationIndex - Supplies the allocation index for the resized block
        Note that the size variable has not been rounded up to the next
        granular block size, but that allocation index has.

Return Value:

    BOOLEAN - TRUE if the block has been resized and FALSE otherwise

--*/

{
    SIZE_T FreeSize;
    SIZE_T OldSize;
    UCHAR EntryFlags, FreeFlags;
    PHEAP_FREE_ENTRY FreeBlock, SplitBlock, SplitBlock2;
    PHEAP_ENTRY_EXTRA OldExtraStuff, NewExtraStuff;

    //
    //  Check if the allocation index is too large for even the nondedicated
    //  free list (i.e., too large for list [0])
    //

    if (AllocationIndex > Heap->VirtualMemoryThreshold) {

        return FALSE;
    }

    //
    //  Get the flags for the current block and a pointer to the next
    //  block following the current block
    //

    EntryFlags = BusyBlock->Flags;

    FreeBlock = (PHEAP_FREE_ENTRY)(BusyBlock + BusyBlock->Size);

    //
    //  If the current block is the last entry before an uncommitted range
    //  we'll try and extend the uncommitted range to fit our new allocation
    //

    if (EntryFlags & HEAP_ENTRY_LAST_ENTRY) {

        //
        //  Calculate how must more we need beyond the current block
        //  size
        //

        FreeSize = (AllocationIndex - BusyBlock->Size) << HEAP_GRANULARITY_SHIFT;
        FreeSize = ROUND_UP_TO_POWER2( FreeSize, PAGE_SIZE );

        //
        //  Try and commit memory at the desired location
        //

        FreeBlock = RtlpFindAndCommitPages( Heap,
                                            Heap->Segments[ BusyBlock->SegmentIndex ],
                                            &FreeSize,
                                            (PHEAP_ENTRY)FreeBlock );

        //
        //  Check if the commit succeeded
        //

        if (FreeBlock == NULL) {

            return FALSE;
        }

        //
        //  New coalesce this newly committed space with whatever is free
        //  around it
        //

        FreeSize = FreeSize >> HEAP_GRANULARITY_SHIFT;

        FreeBlock = RtlpCoalesceFreeBlocks( Heap, FreeBlock, &FreeSize, FALSE );

        FreeFlags = FreeBlock->Flags;

        //
        //  If the newly allocated space plus the current block size is still
        //  not big enough for our resize effort then put this newly
        //  allocated block into the appropriate free list and tell our caller
        //  that a resize wasn't possible
        //

        if ((FreeSize + BusyBlock->Size) < AllocationIndex) {

            RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );

            Heap->TotalFreeSize += FreeSize;

#ifndef NTOS_KERNEL_RUNTIME
            if (DEBUG_HEAP(Flags)) {

                RtlpValidateHeapHeaders( Heap, TRUE );
            }
#endif

            return FALSE;
        }

        //
        //  We were able to generate enough space for the resize effort, so
        //  now free size will be the index for the current block plus the
        //  new free space
        //

        FreeSize += BusyBlock->Size;

    } else {

        //
        //  The following block is present so grab its flags and see if
        //  it is free or busy.  If busy then we cannot grow the current
        //  block
        //

        FreeFlags = FreeBlock->Flags;

        if (FreeFlags & HEAP_ENTRY_BUSY) {

            return FALSE;
        }

        //
        //  Compute the index if we combine current block with its following
        //  free block and check if it is big enough
        //

        FreeSize = BusyBlock->Size + FreeBlock->Size;

        if (FreeSize < AllocationIndex) {

            return FALSE;
        }

        //
        //  The two blocks together are big enough so now remove the free
        //  block from its free list, and update the heap's total free size
        //

        RtlpRemoveFreeBlock( Heap, FreeBlock );

        Heap->TotalFreeSize -= FreeBlock->Size;
    }

    //
    //  At this point we have a busy block followed by a free block that
    //  together have enough space for the resize.  The free block has been
    //  removed from its list and free size is the index of the two combined
    //  blocks.
    //
    //  Calculate the number of bytes in use in the old block
    //

    OldSize = (BusyBlock->Size << HEAP_GRANULARITY_SHIFT) - BusyBlock->UnusedBytes;

    //
    //  Calculate the index for whatever excess we'll have when we combine
    //  the two blocks
    //

    FreeSize -= AllocationIndex;

    //
    //  If the excess is not too much then put it back in our allocation
    //  (i.e., we don't want small free pieces left over)
    //

    if (FreeSize <= 2) {

        AllocationIndex += FreeSize;

        FreeSize = 0;
    }

    //
    //  If the busy block has an extra stuff struct present then copy over the
    //  extra stuff
    //

    if (EntryFlags & HEAP_ENTRY_EXTRA_PRESENT) {

        OldExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size - 1);
        NewExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + AllocationIndex - 1);

        *NewExtraStuff = *OldExtraStuff;

        //
        //  If heap tagging is enabled then update the heap tag from the extra
        //  stuff struct
        //

#ifndef NTOS_KERNEL_RUNTIME
        if (IS_HEAP_TAGGING_ENABLED()) {

            NewExtraStuff->TagIndex =
                RtlpUpdateTagEntry( Heap,
                                    NewExtraStuff->TagIndex,
                                    BusyBlock->Size,
                                    AllocationIndex,
                                    ReAllocationAction );
        }
#endif

    //
    //  Otherwise extra stuff is not in use so see if heap tagging is enabled
    //  and if so then update small tag index
    //

    }
#ifndef NTOS_KERNEL_RUNTIME
         else if (IS_HEAP_TAGGING_ENABLED()) {

        BusyBlock->SmallTagIndex = (UCHAR)
            RtlpUpdateTagEntry( Heap,
                                BusyBlock->SmallTagIndex,
                                BusyBlock->Size,
                                AllocationIndex,
                                ReAllocationAction );
    }
#endif

    //
    //  Check if we will have any free space to give back.
    //

    if (FreeSize == 0) {

        //
        //  No following free space so update the flags, size and byte counts
        //  for the resized block.  If the free block was a last entry
        //  then the busy block must also now be a last entry.
        //

        BusyBlock->Flags |= FreeFlags & HEAP_ENTRY_LAST_ENTRY;

        BusyBlock->Size = (USHORT)AllocationIndex;

        BusyBlock->UnusedBytes = (UCHAR)
            ((AllocationIndex << HEAP_GRANULARITY_SHIFT) - Size);

        //
        //  Update the previous size field of the following block if it exists
        //

        if (!(FreeFlags & HEAP_ENTRY_LAST_ENTRY)) {

            (BusyBlock + BusyBlock->Size)->PreviousSize = BusyBlock->Size;

        } else {

            PHEAP_SEGMENT Segment;

            Segment = Heap->Segments[BusyBlock->SegmentIndex];
            Segment->LastEntryInSegment = BusyBlock;
        }

    //
    //  Otherwise there is some free space to return to the heap
    //

    } else {

        //
        //  Update the size and byte counts for the resized block.
        //

        BusyBlock->Size = (USHORT)AllocationIndex;

        BusyBlock->UnusedBytes = (UCHAR)
            ((AllocationIndex << HEAP_GRANULARITY_SHIFT) - Size);

        //
        //  Determine where the new free block starts and fill in its fields
        //

        SplitBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)BusyBlock + AllocationIndex);

        SplitBlock->PreviousSize = (USHORT)AllocationIndex;

        SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;

        //
        //  If this new free block will be the last entry then update its
        //  flags and size and put it into the appropriate free list
        //

        if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

            PHEAP_SEGMENT Segment;

            Segment = Heap->Segments[SplitBlock->SegmentIndex];
            Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;

            SplitBlock->Flags = FreeFlags;
            SplitBlock->Size = (USHORT)FreeSize;

            RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

            Heap->TotalFreeSize += FreeSize;

        //
        //  The free block is followed by another valid block
        //

        } else {

            //
            //  Point to the block following our new free block
            //

            SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

            //
            //  If the block following the new free block is busy then
            //  update the flags and size for the new free block, update
            //  the following blocks previous size, and put the free block
            //  into the appropriate free list
            //

            if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                SplitBlock->Flags = FreeFlags & (~HEAP_ENTRY_LAST_ENTRY);
                SplitBlock->Size = (USHORT)FreeSize;

                //
                //  **** note that this test must be true because we are
                //  **** already in the else clause of the
                //  **** if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) statement
                //

                if (!(FreeFlags & HEAP_ENTRY_LAST_ENTRY)) {

                    ((PHEAP_ENTRY)SplitBlock + FreeSize)->PreviousSize = (USHORT)FreeSize;

                } else {

                    PHEAP_SEGMENT Segment;

                    Segment = Heap->Segments[SplitBlock->SegmentIndex];
                    Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                }

                RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                Heap->TotalFreeSize += FreeSize;

            //
            //  Otherwise the following block is also free so we can combine
            //  these two blocks
            //

            } else {

                //
                //  Remember the new free flags from the following block
                //

                FreeFlags = SplitBlock2->Flags;

                //
                //  Remove the following block from its free list
                //

                RtlpRemoveFreeBlock( Heap, SplitBlock2 );

                Heap->TotalFreeSize -= SplitBlock2->Size;

                //
                //  Calculate the size of the new combined free block
                //

                FreeSize += SplitBlock2->Size;

                //
                //  Give the new the its new flags
                //

                SplitBlock->Flags = FreeFlags;

                //
                //  If the combited block is not too large for the dedicated
                //  free lists then that where we'll put it
                //

                if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                    SplitBlock->Size = (USHORT)FreeSize;

                    //
                    //  If present update the previous size for the following block
                    //

                    if (!(FreeFlags & HEAP_ENTRY_LAST_ENTRY)) {

                        ((PHEAP_ENTRY)SplitBlock + FreeSize)->PreviousSize = (USHORT)FreeSize;

                    } else {

                        PHEAP_SEGMENT Segment;

                        Segment = Heap->Segments[SplitBlock->SegmentIndex];
                        Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                    }

                    //
                    //  Insert the new combined free block into the free list
                    //

                    RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                    Heap->TotalFreeSize += FreeSize;

                } else {

                    //
                    //  Otherwise the new free block is too large to go into
                    //  a dedicated free list so put it in the general free list
                    //  which might involve breaking it apart.
                    //

                    RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                }
            }
        }
    }

    //
    //  At this point the block has been resized and any extra space has been
    //  returned to the free list
    //
    //  Check if we should zero out the new space
    //

    if (Flags & HEAP_ZERO_MEMORY) {

        //
        //  **** this test is sort of bogus because we're resizing and the new
        //  **** size by definition must be larger than the old size
        //

        if (Size > OldSize) {

            RtlZeroMemory( (PCHAR)(BusyBlock + 1) + OldSize,
                           Size - OldSize );
        }

    //
    //  Check if we should be filling in heap after it as
    //  been freed, and if so then fill in the newly allocated
    //  space beyond the old bytes.
    //

    }
#if DBG
    else if (Heap->Flags & HEAP_FREE_CHECKING_ENABLED) {

        SIZE_T PartialBytes, ExtraSize;

        PartialBytes = OldSize & (sizeof( ULONG ) - 1);

        if (PartialBytes) {

            PartialBytes = 4 - PartialBytes;
        }

        if (Size > (OldSize + PartialBytes)) {

            ExtraSize = (Size - (OldSize + PartialBytes)) & ~(sizeof( ULONG ) - 1);

            if (ExtraSize != 0) {

                RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1) + OldSize + PartialBytes,
                                    ExtraSize,
                                    ALLOC_HEAP_FILL );
            }
        }
    }

    //
    //  If we are going tailing checking then fill in the space right beyond
    //  the new allocation
    //

    if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

        RtlFillMemory( (PCHAR)(BusyBlock + 1) + Size,
                       CHECK_HEAP_TAIL_SIZE,
                       CHECK_HEAP_TAIL_FILL );
    }
#endif // DBG

    //
    //  Give the resized block any user settable flags send in by the
    //  caller
    //

    BusyBlock->Flags &= ~HEAP_ENTRY_SETTABLE_FLAGS;
    BusyBlock->Flags |= ((Flags & HEAP_SETTABLE_USER_FLAGS) >> 4);

    //
    //  And return to our caller
    //

    return TRUE;
}



BOOLEAN
RtlFreeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine returns a previously allocated block back to its heap

Arguments:

    HeapHandle - Supplies a pointer to the owning heap structure

    Flags - Specifies the set of flags to use in the deallocation

    BaseAddress - Supplies a pointer to the block being freed

Return Value:

    BOOLEAN - TRUE if the block was properly freed and FALSE otherwise

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T FreeSize;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN ReturnValue = TRUE;

    RTL_PAGED_CODE();

    //
    //  First check if the address we're given is null and if so then
    //  there is really nothing to do so just return success
    //

    if (BaseAddress == NULL) {

        return TRUE;
    }

#ifndef NTOS_KERNEL_RUNTIME
#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlFreeNtHeap( HeapHandle,
                                  Flags,
                                  BaseAddress);
        }
    }
#endif // NTHEAP_ENABLED
#endif // NTOS_KERNEL_RUNTIME


    //
    //  Compliment the input flags with those enforced by the heap
    //

    Flags |= Heap->ForceFlags;

    //
    //  Now check if we should go the slow route
    //

#if DBG
    if (Flags & HEAP_SLOW_FLAGS) {

        return RtlFreeHeapSlowly(HeapHandle, Flags, BaseAddress);
    }
#endif // DBG

    //
    //  We can do everything in this routine. So now backup to get
    //  a pointer to the start of the block
    //

    BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

#if DBG
    //
    //  Protect ourselves from idiots by refusing to free blocks
    //  that do not have the busy bit set.
    //
    //  Also refuse to free blocks that are not eight-byte aligned.
    //  The specific idiot in this case is Office95, which likes
    //  to free a random pointer when you start Word95 from a desktop
    //  shortcut.
    //
    //  As further insurance against idiots, check the segment index
    //  to make sure it is less than HEAP_MAXIMUM_SEGMENTS (16). This
    //  should fix all the dorks who have ASCII or Unicode where the
    //  heap header is supposed to be.
    //

    try {
        if ((!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) ||
            (((ULONG_PTR)BaseAddress & 0x7) != 0) ||
            (BusyBlock->SegmentIndex >= HEAP_MAXIMUM_SEGMENTS)) {

            //
            //  Not a busy block, or it's not aligned or the segment is
            //  to big, meaning it's corrupt
            //

            ASSERTMSG("Bad pointer in RtlFreeHeap()\n", 0);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {

        ASSERTMSG("Bad pointer in RtlFreeHeap()\n", 0);
    }
#endif // DBG

    //
    //  If there is a lookaside list and the block is not a big allocation
    //  and the index is for a dedicated list then free the block to the
    //  lookaside list.  We'll actually capture
    //  the lookaside pointer from the heap and only use the captured pointer.
    //  This will take care of the condition where a walk or lock heap can
    //  cause us to check for a non null pointer and then have it become null
    //  when we read it again.  If it is non null to start with then even if
    //  the user walks or locks the heap via another thread the pointer to
    //  still valid here so we can still try and do a lookaside list push
    //

#ifndef NTOS_KERNEL_RUNTIME

    {
        PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)Heap->Lookaside;

        if ((Lookaside != NULL) &&
            (Heap->LookasideLockCount == 0) &&
            (!(BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC)) &&
            ((FreeSize = BusyBlock->Size) < HEAP_MAXIMUM_FREELISTS)) {

            if (RtlpFreeToHeapLookaside( &Lookaside[FreeSize], BaseAddress)) {

                return TRUE;
            }
        }
    }

#endif // NTOS_KERNEL_RUNTIME

    try {

        //
        //  Check if we need to lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Check if this is not a virtual block allocation meaning
        //  that we it is part of the heap free list structure and not
        //  one huge allocation that we got from vm
        //

        if (!(BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC)) {

            //
            //  This block is not a big allocation so we need to
            //  to get its size, and coalesce the blocks note that
            //  the user mode heap does this conditionally on a heap
            //  flag.  The coalesce function returns the newly formed
            //  free block and the new size.
            //

            FreeSize = BusyBlock->Size;

    #ifdef NTOS_KERNEL_RUNTIME

            BusyBlock = (PHEAP_ENTRY)RtlpCoalesceFreeBlocks( Heap,
                                                             (PHEAP_FREE_ENTRY)BusyBlock,
                                                             &FreeSize,
                                                             FALSE );

    #else // NTOS_KERNEL_RUNTIME

            if (!(Heap->Flags & HEAP_DISABLE_COALESCE_ON_FREE)) {

                BusyBlock = (PHEAP_ENTRY)RtlpCoalesceFreeBlocks( Heap,
                                                                 (PHEAP_FREE_ENTRY)BusyBlock,
                                                                 &FreeSize,
                                                                 FALSE );
            }

    #endif // NTOS_KERNEL_RUNTIME

            //
            //  Check for a small allocation that can go on a freelist
            //  first, these should never trigger a decommit.
            //

            HEAPASSERT(HEAP_MAXIMUM_FREELISTS < Heap->DeCommitFreeBlockThreshold);

            //
            //  If the allocation fits on a free list then insert it on
            //  the appropriate free list.  If the block is not the last
            //  entry then make sure that the next block knows our correct
            //  size, and update the heap free space counter.
            //

            if (FreeSize < HEAP_MAXIMUM_FREELISTS) {

                RtlpFastInsertDedicatedFreeBlockDirect( Heap,
                                                        (PHEAP_FREE_ENTRY)BusyBlock,
                                                        (USHORT)FreeSize );

                if (!(BusyBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                    HEAPASSERT((BusyBlock + FreeSize)->PreviousSize == (USHORT)FreeSize);
                }

                Heap->TotalFreeSize += FreeSize;

            //
            //  Otherwise the block is to big for one of the dedicated free list so
            //  see if the free size is under the decommit threshold by itself
            //  or the total free in the heap is under the decomit threshold then
            //  we'll put this into a free list
            //

            } else if ((FreeSize < Heap->DeCommitFreeBlockThreshold) ||
                       ((Heap->TotalFreeSize + FreeSize) < Heap->DeCommitTotalFreeThreshold)) {

                //
                //  Check if the block can go into the [0] index free list, and if
                //  so then do the insert and make sure the following block is
                //  needed knows our correct size, and update the heaps free space
                //  counter
                //

                if (FreeSize <= (ULONG)HEAP_MAXIMUM_BLOCK_SIZE) {

                    RtlpFastInsertNonDedicatedFreeBlockDirect( Heap,
                                                               (PHEAP_FREE_ENTRY)BusyBlock,
                                                               (USHORT)FreeSize );

                    if (!(BusyBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                        HEAPASSERT((BusyBlock + FreeSize)->PreviousSize == (USHORT)FreeSize);
                    }

                    Heap->TotalFreeSize += FreeSize;

                } else {

                    //
                    //  The block is too big to go on a free list in its
                    //  entirety but we don't want to decommit anything so
                    //  simply call a worker routine to hack up the block
                    //  into pieces that will fit on the free lists.
                    //

                    RtlpInsertFreeBlock( Heap, (PHEAP_FREE_ENTRY)BusyBlock, FreeSize );
                }

            //
            //  Otherwise the block is to big for any lists and we should decommit
            //  the block
            //

            } else {

                RtlpDeCommitFreeBlock( Heap, (PHEAP_FREE_ENTRY)BusyBlock, FreeSize );
            }

        } else {

            //
            //  This is a big virtual block allocation.  To free it we only have to
            //  remove it from the heaps list of virtual allocated blocks, unlock
            //  the heap, and return the block to vm
            //

            PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

            VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

            RemoveEntryList( &VirtualAllocBlock->Entry );

            //
            //  Release lock here as there is no reason to hold it across
            //  the system call.
            //

            if (LockAcquired) {

                RtlReleaseLockRoutine( Heap->LockVariable );
                LockAcquired = FALSE;
            }

            FreeSize = 0;

            Status = ZwFreeVirtualMemory( (PVOID *)&VirtualAllocBlock,
                                          &FreeSize,
                                          MEM_RELEASE );


            //
            //  Check if we had trouble freeing the block back to vm
            //  and return an error if necessary
            //

            if (!NT_SUCCESS( Status )) {

                SET_LAST_STATUS( Status );

                ReturnValue = FALSE;
            }
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  The block was freed successfully so return success to our
    //  caller
    //

    return ReturnValue;
}


BOOLEAN
RtlFreeHeapSlowly (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine returns a previously allocated block back to its heap.
    It is the slower version of Rtl Free Heap and does more checking and
    tagging control.

Arguments:

    HeapHandle - Supplies a pointer to the owning heap structure

    Flags - Specifies the set of flags to use in the deallocation

    BaseAddress - Supplies a pointer to the block being freed

Return Value:

    BOOLEAN - TRUE if the block was properly freed and FALSE otherwise

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T FreeSize;
    BOOLEAN Result;
    BOOLEAN LockAcquired = FALSE;

#ifndef NTOS_KERNEL_RUNTIME

    USHORT TagIndex;

#endif // NTOS_KERNEL_RUNTIME

    RTL_PAGED_CODE();

    //
    //  Note that Flags has already been OR'd with Heap->ForceFlags.
    //

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case see if we should be calling the debug version to
    //  free the heap
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugFreeHeap( HeapHandle, Flags, BaseAddress );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  Until we figure out otherwise we'll assume that this call will fail
    //

    Result = FALSE;

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        try {

            //
            //  Backup to get a pointer to the start of the block
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            //
            //  Protect ourselves from idiots by refusing to free blocks
            //  that do not have the busy bit set.
            //
            //  Also refuse to free blocks that are not eight-byte aligned.
            //  The specific idiot in this case is Office95, which likes
            //  to free a random pointer when you start Word95 from a desktop
            //  shortcut.
            //
            //  As further insurance against idiots, check the segment index
            //  to make sure it is less than HEAP_MAXIMUM_SEGMENTS (16). This
            //  should fix all the dorks who have ASCII or Unicode where the
            //  heap header is supposed to be.
            //
            //  Note that this test is just opposite from the test used in
            //  Rtl Free Heap
            //

            if ((BusyBlock->Flags & HEAP_ENTRY_BUSY) &&
                (((ULONG_PTR)BaseAddress & 0x7) == 0) &&
                (BusyBlock->SegmentIndex < HEAP_MAXIMUM_SEGMENTS)) {

                //
                //  Check if this is a virtual block allocation
                //

                if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

                    //
                    //  This is a big virtual block allocation.  To free it
                    //  we only have to remove it from the heaps list of
                    //  virtual allocated blocks, unlock the heap, and return
                    //  the block to vm
                    //

                    VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                    RemoveEntryList( &VirtualAllocBlock->Entry );

    #ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  In the non kernel case see if we need to free the tag
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        RtlpUpdateTagEntry( Heap,
                                            VirtualAllocBlock->ExtraStuff.TagIndex,
                                            VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT,
                                            0,
                                            VirtualFreeAction );
                    }

    #endif // NTOS_KERNEL_RUNTIME

                    FreeSize = 0;

                    Status = ZwFreeVirtualMemory( (PVOID *)&VirtualAllocBlock,
                                                  &FreeSize,
                                                  MEM_RELEASE );

                    //
                    //  Check if everything worked okay, if we had trouble freeing
                    //  the block back to vm return an error if necessary,
                    //

                    if (NT_SUCCESS( Status )) {

                        Result = TRUE;

                    } else {

                        SET_LAST_STATUS( Status );
                    }

                } else {

                    //
                    //  This block is not a big allocation so we need to
                    //  to get its size, and coalesce the blocks note that
                    //  the user mode heap does this conditionally on a heap
                    //  flag.  The coalesce function returns the newly formed
                    //  free block and the new size.
                    //

    #ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  First in the non kernel case remove any tagging we might
                    //  have been using.  Note that the will either be in
                    //  the heap header, or in the extra block if present
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                            ExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size - 1);

                            TagIndex = RtlpUpdateTagEntry( Heap,
                                                           ExtraStuff->TagIndex,
                                                           BusyBlock->Size,
                                                           0,
                                                           FreeAction );

                        } else {

                            TagIndex = RtlpUpdateTagEntry( Heap,
                                                           BusyBlock->SmallTagIndex,
                                                           BusyBlock->Size,
                                                           0,
                                                           FreeAction );
                        }

                    } else {

                        TagIndex = 0;
                    }

    #endif // NTOS_KERNEL_RUNTIME

                    //
                    //  This is the size of the block we are freeing
                    //

                    FreeSize = BusyBlock->Size;

    #ifndef NTOS_KERNEL_RUNTIME

                    //
                    //  In the non kernel case see if we should coalesce on free
                    //

                    if (!(Heap->Flags & HEAP_DISABLE_COALESCE_ON_FREE)) {

    #endif // NTOS_KERNEL_RUNTIME

                        //
                        //  In kernel case and in the tested user mode case we
                        //  now coalesce free blocks
                        //

                        BusyBlock = (PHEAP_ENTRY)RtlpCoalesceFreeBlocks( Heap, (PHEAP_FREE_ENTRY)BusyBlock, &FreeSize, FALSE );

    #ifndef NTOS_KERNEL_RUNTIME

                    }

    #endif // NTOS_KERNEL_RUNTIME

                    //
                    //  If the block should not be decommit then try and put it
                    //  on a free list
                    //

                    if ((FreeSize < Heap->DeCommitFreeBlockThreshold) ||
                        ((Heap->TotalFreeSize + FreeSize) < Heap->DeCommitTotalFreeThreshold)) {

                        //
                        //  Check if the block can fit on one of the dedicated free
                        //  lists
                        //

                        if (FreeSize <= (ULONG)HEAP_MAXIMUM_BLOCK_SIZE) {

                            //
                            //  It can fit on a dedicated free list so insert it on
                            //

                            RtlpInsertFreeBlockDirect( Heap, (PHEAP_FREE_ENTRY)BusyBlock, (USHORT)FreeSize );

                            //
                            //  If there is a following entry then make sure the
                            //  sizes agree
                            //

                            if (!(BusyBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                HEAPASSERT((BusyBlock + FreeSize)->PreviousSize == (USHORT)FreeSize);
                            }

                            //
                            //  Update the heap with the amount of free space
                            //  available
                            //

                            Heap->TotalFreeSize += FreeSize;

                        } else {

                            //
                            //  The block goes on the non dedicated free list
                            //

                            RtlpInsertFreeBlock( Heap, (PHEAP_FREE_ENTRY)BusyBlock, FreeSize );
                        }

    #ifndef NTOS_KERNEL_RUNTIME

                        //
                        //  In the non kernel case see if the there was tag and if
                        //  so then update the entry to show that it's been freed
                        //

                        if (TagIndex != 0) {

                            PHEAP_FREE_ENTRY_EXTRA FreeExtra;

                            BusyBlock->Flags |= HEAP_ENTRY_EXTRA_PRESENT;

                            FreeExtra = (PHEAP_FREE_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size) - 1;

                            FreeExtra->TagIndex = TagIndex;
                            FreeExtra->FreeBackTraceIndex = 0;

    #if i386 && DBG

                            //
                            //  In the x86 case we can also capture the stack
                            //  backtrace
                            //

                            if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

                                FreeExtra->FreeBackTraceIndex = (USHORT)RtlLogStackBackTrace();
                            }

    #endif // i386 && DBG

                        }

    #endif // NTOS_KERNEL_RUNTIME

                    } else {

                        //
                        //  Otherwise the block is big enough to decommit so have a
                        //  worker routine to do the decommit
                        //

                        RtlpDeCommitFreeBlock( Heap, (PHEAP_FREE_ENTRY)BusyBlock, FreeSize );
                    }

                    //
                    //  And say the free worked fine
                    //

                    Result = TRUE;
                }

            } else {

                //
                //  Not a busy block, or it's not aligned or the segment is
                //  to big, meaning it's corrupt
                //

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Result;
}


SIZE_T
RtlSizeHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine returns the size, in bytes, of the indicated block
    of heap storage.  The size only includes the number of bytes the
    original caller used to allocate the block and not any unused
    bytes at the end of the block.

Arguments:

    HeapHandle - Supplies a pointer to the heap that owns the block
        being queried

    Flags - Supplies a set of flags used to allocate the block

    BaseAddress - Supplies the address of the block being queried

Return Value:

    SIZE_T - returns the size, in bytes, of the queried block, or -1
        if the block is not in use.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    SIZE_T BusySize;

    //
    //  Compliment the input flags with those enforced by the heap
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if this is the nonkernel debug version of heap
    //

#ifndef NTOS_KERNEL_RUNTIME

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugSizeHeap( HeapHandle, Flags, BaseAddress );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  No lock is required since nothing is modified and nothing
    //  outside the busy block is read.  Backup to get a pointer
    //  to the heap entry
    //

    BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

    //
    //  If the block is not in use then the answer is -1 and
    //  we'll set the error status for the user mode thread
    //

    if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

        BusySize = -1;

        SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

    //
    //  Otherwise if the block is from our large allocation then
    //  we'll get the result from that routine
    //

    } else if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

        BusySize = RtlpGetSizeOfBigBlock( BusyBlock );

    //
    //  Otherwise the block must be one that we can handle so
    //  calculate its block size and then subtract what's not being
    //  used by the caller.
    //
    //  **** this seems to include the heap entry header in its
    //  **** calculation.  Is that what we really want?
    //

    } else {

        BusySize = (BusyBlock->Size << HEAP_GRANULARITY_SHIFT) -
                   BusyBlock->UnusedBytes;
    }

    //
    //  And return to our caller
    //

    return BusySize;
}


NTSTATUS
RtlZeroHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine zero's (or fills) in all the free blocks in a heap.
    It does not touch big allocations.

Arguments:

    HeapHandle - Supplies a pointer to the heap being zeroed

    Flags - Supplies a set of heap flags to compliment those already
        set in the heap

Return Value:

    NTSTATUS - An appropriate status code

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    NTSTATUS Status;
    BOOLEAN LockAcquired = FALSE;
    PHEAP_SEGMENT Segment;
    ULONG SegmentIndex;
    PHEAP_ENTRY CurrentBlock;
    PHEAP_FREE_ENTRY FreeBlock;
    SIZE_T Size;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;

    RTL_PAGED_CODE();

    //
    //  Compliment the input flags with those enforced by the heap
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if this is the nonkernel debug version of heap
    //

#ifndef NTOS_KERNEL_RUNTIME

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugZeroHeap( HeapHandle, Flags );
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  Unless something happens otherwise we'll assume that we'll
    //  be successful
    //

    Status = STATUS_SUCCESS;

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        try {

            //
            //  Zero fill all the free blocks in all the segements
            //

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                if (!Segment) {

                    continue;
                }

                UnCommittedRange = Segment->UnCommittedRanges;
                CurrentBlock = Segment->FirstEntry;

                //
                //  With the current segment we'll zoom through the
                //  blocks until we reach the end
                //

                while (CurrentBlock < Segment->LastValidEntry) {

                    Size = CurrentBlock->Size << HEAP_GRANULARITY_SHIFT;

                    //
                    //  If the block is not in use then we'll either zero
                    //  it or fill it.
                    //

                    if (!(CurrentBlock->Flags & HEAP_ENTRY_BUSY)) {

                        FreeBlock = (PHEAP_FREE_ENTRY)CurrentBlock;

#if DBG
                        if ((Heap->Flags & HEAP_FREE_CHECKING_ENABLED) &&
                            (CurrentBlock->Flags & HEAP_ENTRY_FILL_PATTERN)) {

                            RtlFillMemoryUlong( FreeBlock + 1,
                                                Size - sizeof( *FreeBlock ),
                                                FREE_HEAP_FILL );

                        } else
#endif // DBG
                                {

                            RtlFillMemoryUlong( FreeBlock + 1,
                                                Size - sizeof( *FreeBlock ),
                                                0 );
                        }
                    }

                    //
                    //  If the following entry is uncommited then we need to
                    //  skip over it.  This code strongly implies that the
                    //  uncommitted range list is in perfect sync with the
                    //  blocks in the segement
                    //

                    if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                        CurrentBlock += CurrentBlock->Size;

                        //
                        //  Check if the we've reached the end of the segment
                        //  and should just break out of the while loop
                        //
                        //
                        //  **** "break;" would probably be more clear here
                        //

                        if (UnCommittedRange == NULL) {

                            CurrentBlock = Segment->LastValidEntry;

                        //
                        //  Otherwise skip over the uncommitted range
                        //

                        } else {

                            CurrentBlock = (PHEAP_ENTRY)
                                ((PCHAR)UnCommittedRange->Address + UnCommittedRange->Size);

                            UnCommittedRange = UnCommittedRange->Next;
                        }

                    //
                    //  Otherwise the next block exists so advance to it
                    //

                    } else {

                        CurrentBlock += CurrentBlock->Size;
                    }
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Status = GetExceptionCode();
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Status;
}


//
//  Local Support Routine
//

PHEAP_UNCOMMMTTED_RANGE
RtlpCreateUnCommittedRange (
    IN PHEAP_SEGMENT Segment
    )

/*++

Routine Description:

    This routine add a new uncommitted range structure to the specified heap
    segment.  This routine works by essentially doing a pop of the stack of
    unused uncommitted range structures located off the heap structure.  If
    the stack is empty then we'll create some more before doing the pop.

Arguments:

    Segment - Supplies the heap segment being modified

Return Value:

    PHEAP_UNCOMMITTED_RANGE - returns a pointer to the newly created
        uncommitted range structure

--*/

{
    NTSTATUS Status;
    PVOID FirstEntry, LastEntry;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;
    SIZE_T ReserveSize, CommitSize;
    PHEAP_UCR_SEGMENT UCRSegment;

    RTL_PAGED_CODE();

    //
    //  Get a pointer to the unused uncommitted range structures for
    //  the specified heap
    //

    pp = &Segment->Heap->UnusedUnCommittedRanges;

    //
    //  If the list is null then we need to allocate some more to
    //  put on the list
    //

    if (*pp == NULL) {

        //
        //  Get the next uncommitted range segment from the heap
        //

        UCRSegment = Segment->Heap->UCRSegments;

        //
        //  If there are no more uncommitted range segments or
        //  the segemtns commited and reserved sizes are equal (meaning
        //  it's all used up) then we need to allocate another uncommitted
        //  range segment
        //

        if ((UCRSegment == NULL) ||
            (UCRSegment->CommittedSize == UCRSegment->ReservedSize)) {

            //
            //  We'll reserve 16 pages of memory and commit at this
            //  time one page of it.
            //

            ReserveSize = PAGE_SIZE * 16;
            UCRSegment = NULL;

            Status = ZwAllocateVirtualMemory( &UCRSegment,
                                              0,
                                              &ReserveSize,
                                              MEM_RESERVE,
                                              PAGE_READWRITE );

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }

            CommitSize = PAGE_SIZE;

            Status = ZwAllocateVirtualMemory( &UCRSegment,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE );

            if (!NT_SUCCESS( Status )) {

                ZwFreeVirtualMemory( &UCRSegment,
                                     &ReserveSize,
                                     MEM_RELEASE );

                return NULL;
            }

            //
            //  Add this new segment to the front of the UCR segments
            //

            UCRSegment->Next = Segment->Heap->UCRSegments;
            Segment->Heap->UCRSegments = UCRSegment;

            //
            //  Set the segments commit and reserve size
            //

            UCRSegment->ReservedSize = ReserveSize;
            UCRSegment->CommittedSize = CommitSize;

            //
            //  Point to the first free spot in the segment
            //

            FirstEntry = (PCHAR)(UCRSegment + 1);

        } else {

            //
            //  We have an existing UCR segment with available space
            //  So now try and commit another PAGE_SIZE bytes.  When we are done
            //  FirstEntry will point to the newly committed space
            //

            CommitSize = PAGE_SIZE;
            FirstEntry = (PCHAR)UCRSegment + UCRSegment->CommittedSize;

            Status = ZwAllocateVirtualMemory( &FirstEntry,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE );

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }

            //
            //  And update the amount committed in the segment
            //

            UCRSegment->CommittedSize += CommitSize;
        }

        //
        //  At this point UCR segment exists and First Entry points to the
        //  start of the available committed space.  We'll make Last Entry
        //  point to the end of the committed space
        //

        LastEntry = (PCHAR)UCRSegment + UCRSegment->CommittedSize;

        //
        //  Now the task is to push all of this new space unto the
        //  unused uncommitted range list off the heap, then we can
        //  do a regular pop
        //

        UnCommittedRange = (PHEAP_UNCOMMMTTED_RANGE)FirstEntry;

        pp = &Segment->Heap->UnusedUnCommittedRanges;

        while ((PCHAR)UnCommittedRange < (PCHAR)LastEntry) {

            *pp = UnCommittedRange;
            pp = &UnCommittedRange->Next;
            UnCommittedRange += 1;
        }

        //
        //  Null terminate the list
        //

        *pp = NULL;

        //
        //  And have Pp point the new top of the list
        //

        pp = &Segment->Heap->UnusedUnCommittedRanges;
    }

    //
    //  At this point the Pp points to a non empty list of unused uncommitted
    //  range structures.  So we pop the list and return the top to our caller
    //

    UnCommittedRange = *pp;
    *pp = UnCommittedRange->Next;

    return UnCommittedRange;
}


//
//  Local Support Routine
//

VOID
RtlpDestroyUnCommittedRange (
    IN PHEAP_SEGMENT Segment,
    IN PHEAP_UNCOMMMTTED_RANGE UnCommittedRange
    )

/*++

Routine Description:

    This routine returns an uncommitted range structure back to the unused
    uncommitted range list

Arguments:

    Segment - Supplies any segment in the heap being modified.  Most likely but
        not necessarily the segment containing the uncommitted range structure

    UnCommittedRange - Supplies a pointer to the uncommitted range structure
        being decommissioned.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    //
    //  This routine simply does a "push" of the uncommitted range structure
    //  onto the heap's stack of unused uncommitted ranges
    //

    UnCommittedRange->Next = Segment->Heap->UnusedUnCommittedRanges;
    Segment->Heap->UnusedUnCommittedRanges = UnCommittedRange;

    //
    //  For safety sake we'll also zero out the fields in the decommissioned
    //  structure
    //

    UnCommittedRange->Address = 0;
    UnCommittedRange->Size = 0;

    //
    //  And return to our caller
    //

    return;
}


//
//  Local Support Routine
//

VOID
RtlpInsertUnCommittedPages (
    IN PHEAP_SEGMENT Segment,
    IN ULONG_PTR Address,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine adds the specified range to the list of uncommitted pages
    in the segment.  When done the information will hang off the segments
    uncommitted ranges list.

Arguments:

    Segment - Supplies a segment whose uncommitted range is being modified

    Address - Supplies the base (start) address for the uncommitted range

    Size - Supplies the size, in bytes, of the uncommitted range

Return Value:

    None.

--*/

{
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;

    RTL_PAGED_CODE();

    //
    //  Get a pointer to the front of the segments uncommitted range list
    //  The list is sorted by ascending address
    //

    pp = &Segment->UnCommittedRanges;

    //
    //  While we haven't reached the end of the list we'll zoom through
    //  trying to find a fit
    //

    while (UnCommittedRange = *pp) {

        //
        //  If address we want is less than what we're pointing at then
        //  we've found where this new entry goes
        //

        if (UnCommittedRange->Address > Address) {

            //
            //  If the new block matches right up to the existing block
            //  then we can simply backup the existing block and add
            //  to its size
            //

            if ((Address + Size) == UnCommittedRange->Address) {

                UnCommittedRange->Address = Address;
                UnCommittedRange->Size += Size;

                //
                //  Check if we need to update our notion of what the
                //  largest uncommitted range is
                //

                if (UnCommittedRange->Size > Segment->LargestUnCommittedRange) {

                    Segment->LargestUnCommittedRange = UnCommittedRange->Size;
                }

                //
                //  And return to our caller
                //

                return;
            }

            //
            //  Pp is the address of the block right before us, and *Pp is the
            //  address of the block right after us.  So now fall out to where
            //  the insertion takes place.
            //

            break;

        //
        //  Otherwise if this existing block stops right where the new block
        //  starts then we get to modify this entry.
        //

        } else if ((UnCommittedRange->Address + UnCommittedRange->Size) == Address) {

            //
            //  Remember the starting address and compute the new larger size
            //

            Address = UnCommittedRange->Address;
            Size += UnCommittedRange->Size;

            //
            //  Remove this entry from the list and then return it to the
            //  unused uncommitted list
            //

            *pp = UnCommittedRange->Next;

            RtlpDestroyUnCommittedRange( Segment, UnCommittedRange );

            //
            //  Modify the segemnt counters and largest size state.  The next
            //  time through the loop should hit the first case above where
            //  we'll either merge with a list following us or add a new
            //  entry
            //

            Segment->NumberOfUnCommittedRanges -= 1;

            if (Size > Segment->LargestUnCommittedRange) {

                Segment->LargestUnCommittedRange = Size;
            }

        //
        //  Otherwise we'll continue search down the list
        //

        } else {

            pp = &UnCommittedRange->Next;
        }
    }

    //
    //  If we reach this point that means we've either fallen off the end of the
    //  list, or the list is empty, or we've located the spot where a new uncommitted
    //  range structure belongs.  So allocate a new uncommitted range structure,
    //  and make sure we got one.
    //
    //  Pp is the address of the block right before us and *Pp is the address of the
    //  block right after us
    //

    UnCommittedRange = RtlpCreateUnCommittedRange( Segment );

    if (UnCommittedRange == NULL) {

        HeapDebugPrint(( "Abandoning uncommitted range (%x for %x)\n", Address, Size ));
        // HeapDebugBreak( NULL );

        return;
    }

    //
    //  Fill in the new uncommitted range structure
    //

    UnCommittedRange->Address = Address;
    UnCommittedRange->Size = Size;

    //
    //  Insert it in the list for the segment
    //

    UnCommittedRange->Next = *pp;
    *pp = UnCommittedRange;

    //
    //  Update the segment counters and notion of the largest uncommitted range
    //

    Segment->NumberOfUnCommittedRanges += 1;

    if (Size >= Segment->LargestUnCommittedRange) {

        Segment->LargestUnCommittedRange = Size;
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in heappriv.h
//

PHEAP_FREE_ENTRY
RtlpFindAndCommitPages (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN OUT PSIZE_T Size,
    IN PVOID AddressWanted OPTIONAL
    )

/*++

Routine Description:

    This function searches the supplied segment for an uncommitted range that
    satisfies the specified size.  It commits the range and returns a heap entry
    for the range.

Arguments:

    Heap - Supplies the heap being maniuplated

    Segment - Supplies the segment being searched

    Size - Supplies the size of what we need to look for, on return it contains
        the size of what we're just found and committed.

    AddressWanted - Optionally gives an address where we would like the pages
        based.  If supplied the entry must start at this address

Return Value:

    PHEAP_FREE_ENTRY - Returns a pointer to the newly committed range that
        satisfies the given size requirement, or NULL if we could not find
        something large enough and/or based at the address wanted.

--*/

{
    NTSTATUS Status;
    PHEAP_ENTRY FirstEntry, LastEntry, PreviousLastEntry;
    PHEAP_UNCOMMMTTED_RANGE PreviousUnCommittedRange, UnCommittedRange, *pp;
    ULONG_PTR Address;
    SIZE_T Length;

    RTL_PAGED_CODE();

    //
    //  What the outer loop does is cycle through the uncommited ranges
    //  stored in in the specified segment
    //

    PreviousUnCommittedRange = NULL;
    pp = &Segment->UnCommittedRanges;

    while (UnCommittedRange = *pp) {

        //
        //  Check for the best of worlds, where the size of this current
        //  uncommitted range satisfies our size request and either the user
        //  didn't specify an address or the address match
        //

        if ((UnCommittedRange->Size >= *Size) &&
            (!ARGUMENT_PRESENT( AddressWanted ) || (UnCommittedRange->Address == (ULONG_PTR)AddressWanted ))) {

            //
            //  Calculate an address
            //

            Address = UnCommittedRange->Address;

            //
            //  Commit the memory.  If the heap doesn't have a commit
            //  routine then use the default mm supplied routine.
            //

            if (Heap->CommitRoutine != NULL) {

                Status = (Heap->CommitRoutine)( Heap,
                                                (PVOID *)&Address,
                                                Size );

            } else {

                Status = ZwAllocateVirtualMemory( (PVOID *)&Address,
                                                  0,
                                                  Size,
                                                  MEM_COMMIT,
                                                  PAGE_READWRITE );

            }

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }

            //
            //  At this point we have some committed memory, with Address and Size
            //  giving us the necessary details
            //
            //  Update the number of uncommitted pages in the segment and if necessary
            //  mark down the largest uncommitted range
            //

            Segment->NumberOfUnCommittedPages -= (ULONG) (*Size / PAGE_SIZE);

            if (Segment->LargestUnCommittedRange == UnCommittedRange->Size) {

                Segment->LargestUnCommittedRange = 0;
            }

            //
            //  First entry is the start of the newly committed range
            //

            FirstEntry = (PHEAP_ENTRY)Address;

            //
            //  We want last entry to point to the last real entry before
            //  this newly committed spot.  To do this we start by
            //  setting last entry to either the first entry for the
            //  segment or (if we can do better), to right after the last
            //  uncommitted range we examined.  Either way it points to
            //  some committed range
            //

            if ((Segment->LastEntryInSegment->Flags & HEAP_ENTRY_LAST_ENTRY) &&
                (ULONG_PTR)(Segment->LastEntryInSegment + Segment->LastEntryInSegment->Size) == UnCommittedRange->Address) {

                LastEntry = Segment->LastEntryInSegment;

            } else {

                if (PreviousUnCommittedRange == NULL) {

                    LastEntry = Segment->FirstEntry;

                } else {

                    LastEntry = (PHEAP_ENTRY)(PreviousUnCommittedRange->Address +
                                              PreviousUnCommittedRange->Size);
                }

                //
                //  Now we zoom through the entries until we find the one
                //  marked last
                //

                while (!(LastEntry->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                    PreviousLastEntry = LastEntry;
                    LastEntry += LastEntry->Size;

                    if (((PCHAR)LastEntry >= (PCHAR)Segment->LastValidEntry) || (LastEntry->Size == 0)) {

                        //
                        //  Check for the situation where the last entry in the
                        //  segment isn't marked as a last entry but does put
                        //  us right where the have a new committed range
                        //

                        if (LastEntry == (PHEAP_ENTRY)Address) {

                            LastEntry = PreviousLastEntry;

                            break;
                        }

                        HeapDebugPrint(( "Heap missing last entry in committed range near %x\n", PreviousLastEntry ));
                        HeapDebugBreak( PreviousLastEntry );

                        return NULL;
                    }
                }
            }

            //
            //  Turn off the last bit on this entry because what's following
            //  is no longer uncommitted
            //

            LastEntry->Flags &= ~HEAP_ENTRY_LAST_ENTRY;

            //
            //  Shrink the uncommited range by the size we've committed
            //

            UnCommittedRange->Address += *Size;
            UnCommittedRange->Size -= *Size;

            //
            //  Now if the size is zero then we've committed everything that there
            //  was in the range.  Otherwise make sure the first entry of what
            //  we've just committed knows that an uncommitted range follows.
            //

            if (UnCommittedRange->Size == 0) {

                //
                //  This uncommitted range is about to vanish.  Base on if the
                //  range is the last one in the segemnt then we know how to
                //  mark the committed range as being last or not.
                //

                if (UnCommittedRange->Address == (ULONG_PTR)Segment->LastValidEntry) {

                    FirstEntry->Flags = HEAP_ENTRY_LAST_ENTRY;

                    Segment->LastEntryInSegment = FirstEntry;

                } else {

                    FirstEntry->Flags = 0;

                    Segment->LastEntryInSegment = Segment->FirstEntry;
                }

                //
                //  Remove this zero sized range from the uncommitted range
                //  list, and update the segment counters
                //

                *pp = UnCommittedRange->Next;

                RtlpDestroyUnCommittedRange( Segment, UnCommittedRange );

                Segment->NumberOfUnCommittedRanges -= 1;

            } else {

                //
                //  Otherwise the range is not empty so we know what we committed
                //  is immediately followed by an uncommitted range
                //

                FirstEntry->Flags = HEAP_ENTRY_LAST_ENTRY;

                Segment->LastEntryInSegment = FirstEntry;
            }

            //
            //  Update the fields in the first entry, and optional
            //  following entry.
            //

            FirstEntry->SegmentIndex = LastEntry->SegmentIndex;
            FirstEntry->Size = (USHORT)(*Size >> HEAP_GRANULARITY_SHIFT);
            FirstEntry->PreviousSize = LastEntry->Size;

            if (!(FirstEntry->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                (FirstEntry + FirstEntry->Size)->PreviousSize = FirstEntry->Size;
            }

            //
            //  Now if we adjusted the largest uncommitted range to zero then
            //  we need to go back and find the largest uncommitted range
            //  To do that we simply zoom down the uncommitted range list
            //  remembering the largest one
            //

            if (Segment->LargestUnCommittedRange == 0) {

                UnCommittedRange = Segment->UnCommittedRanges;

                while (UnCommittedRange != NULL) {

                    if (UnCommittedRange->Size >= Segment->LargestUnCommittedRange) {

                        Segment->LargestUnCommittedRange = UnCommittedRange->Size;
                    }

                    UnCommittedRange = UnCommittedRange->Next;
                }
            }

            //
            //  And return the heap entry to our caller
            //

            return (PHEAP_FREE_ENTRY)FirstEntry;

        } else {

            //
            //  Otherwise the current uncommited range is too small or
            //  doesn't have the right address so go to the next uncommitted
            //  range entry
            //

            PreviousUnCommittedRange = UnCommittedRange;
            pp = &UnCommittedRange->Next;
        }
    }

    //
    //  At this point we did not find an uncommitted range entry that satisfied
    //  our requirements either because of size and/or address.  So return null
    //  to tell the user we didn't find anything.
    //

    return NULL;
}


//
//  Declared in heappriv.h
//

BOOLEAN
RtlpInitializeHeapSegment (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN UCHAR SegmentIndex,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UnCommittedAddress,
    IN PVOID CommitLimitAddress
    )

/*++

Routine Description:

    This routines initializes the internal structures for a heap segment.
    The caller supplies the heap and the memory for the segment being
    initialized

Arguments:

    Heap - Supplies the address of the heap owning this segment

    Segment - Supplies a pointer to the segment being initialized

    SegmentIndex - Supplies the segement index within the heap that this
        new segment is being assigned

    Flags - Supplies flags controlling the initialization of the segment
        Valid flags are:

            HEAP_SEGMENT_USER_ALLOCATED

    BaseAddress - Supplies the base address for the segment

    UnCommittedAddress - Supplies the address where the uncommited range starts

    CommitLimitAddress - Supplies the top address available to the segment

Return Value:

    BOOLEAN - TRUE if the initialization is successful and FALSE otherwise

--*/

{
    NTSTATUS Status;
    PHEAP_ENTRY FirstEntry;
    USHORT PreviousSize, Size;
    ULONG NumberOfPages;
    ULONG NumberOfCommittedPages;
    ULONG NumberOfUnCommittedPages;
    SIZE_T CommitSize;

    RTL_PAGED_CODE();

    //
    //  Compute the total number of pages possible in this segment
    //

    NumberOfPages = (ULONG) (((PCHAR)CommitLimitAddress - (PCHAR)BaseAddress) / PAGE_SIZE);

    //
    //  First entry points to the first possible segment entry after
    //  the segment header
    //

    FirstEntry = (PHEAP_ENTRY)ROUND_UP_TO_POWER2( Segment + 1,
                                                  HEAP_GRANULARITY );

    //
    //  Now if the heap is equal to the base address for the segment which
    //  it the case for the segment zero then the previous size is the
    //  heap header.  Otherwise there isn't a previous entry
    //

    if ((PVOID)Heap == BaseAddress) {

        PreviousSize = Heap->Entry.Size;

    } else {

        PreviousSize = 0;
    }

    //
    //  Compute the index size of the segement header
    //

    Size = (USHORT)(((PCHAR)FirstEntry - (PCHAR)Segment) >> HEAP_GRANULARITY_SHIFT);

    //
    //  If the first available heap entry is not committed and
    //  it is beyond the heap limit then we cannot initialize
    //

    if ((PCHAR)(FirstEntry + 1) >= (PCHAR)UnCommittedAddress) {

        if ((PCHAR)(FirstEntry + 1) >= (PCHAR)CommitLimitAddress) {

            return FALSE;
        }

        //
        //  Enough of the segment has not been committed so we
        //  will commit enough now to handle the first entry
        //

        CommitSize = (PCHAR)(FirstEntry + 1) - (PCHAR)UnCommittedAddress;

        Status = ZwAllocateVirtualMemory( (PVOID *)&UnCommittedAddress,
                                          0,
                                          &CommitSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return FALSE;
        }

        //
        //  Because we had to commit some memory we need to adjust
        //  the uncommited address
        //

        UnCommittedAddress = (PVOID)((PCHAR)UnCommittedAddress + CommitSize);
    }

    //
    //  At this point we know there is enough memory committed to handle the
    //  segment header and one heap entry
    //
    //  Now compute the number of uncommited pages and the number of committed
    //  pages
    //

    NumberOfUnCommittedPages = (ULONG)(((PCHAR)CommitLimitAddress - (PCHAR)UnCommittedAddress) / PAGE_SIZE);
    NumberOfCommittedPages = NumberOfPages - NumberOfUnCommittedPages;

    //
    //  Initialize the heap segment heap entry.  We
    //  calculated earlier if there was a previous entry
    //

    Segment->Entry.PreviousSize = PreviousSize;
    Segment->Entry.Size = Size;
    Segment->Entry.Flags = HEAP_ENTRY_BUSY;
    Segment->Entry.SegmentIndex = SegmentIndex;

#if i386 && !NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel x86 case see if we need to capture the callers stack
    //  backtrace
    //

    if (NtGlobalFlag & FLG_USER_STACK_TRACE_DB) {

        Segment->AllocatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();
    }

#endif // i386 && !NTOS_KERNEL_RUNTIME

    //
    //  Now initializes the heap segment
    //

    Segment->Signature = HEAP_SEGMENT_SIGNATURE;
    Segment->Flags = Flags;
    Segment->Heap = Heap;
    Segment->BaseAddress = BaseAddress;
    Segment->FirstEntry = FirstEntry;
    Segment->LastValidEntry = (PHEAP_ENTRY)((PCHAR)BaseAddress + (NumberOfPages * PAGE_SIZE));
    Segment->NumberOfPages = NumberOfPages;
    Segment->NumberOfUnCommittedPages = NumberOfUnCommittedPages;

    //
    //  If there are uncommitted pages then we need to insert them
    //  into the uncommitted ranges list
    //

    if (NumberOfUnCommittedPages) {

        RtlpInsertUnCommittedPages( Segment,
                                    (ULONG_PTR)UnCommittedAddress,
                                    NumberOfUnCommittedPages * PAGE_SIZE );
    }

    //
    //  Have the containing heap point to this segment via the specified index
    //

    Heap->Segments[ SegmentIndex ] = Segment;

    //
    //  Initialize the first free heap entry after the heap segment header and
    //  put it in the free list.  This first entry will be for whatever is left
    //  of the committed range
    //

    PreviousSize = Segment->Entry.Size;
    FirstEntry->Flags = HEAP_ENTRY_LAST_ENTRY;

    Segment->LastEntryInSegment = FirstEntry;

    FirstEntry->PreviousSize = PreviousSize;
    FirstEntry->SegmentIndex = SegmentIndex;

    RtlpInsertFreeBlock( Heap,
                         (PHEAP_FREE_ENTRY)FirstEntry,
                         (PHEAP_ENTRY)UnCommittedAddress - FirstEntry);

    //
    //  And return to our caller
    //

    return TRUE;
}


//
//  Local Support Routine
//

NTSTATUS
RtlpDestroyHeapSegment (
    IN PHEAP_SEGMENT Segment
    )

/*++

Routine Description:

    This routine removes an existing heap segment.  After the call it
    is as if the segment never existed

Arguments:

    Segment - Supplies a pointer to the heap segment being destroyed

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    PVOID BaseAddress;
    SIZE_T BytesToFree;

    RTL_PAGED_CODE();

    //
    //  We actually only have work to do if the segment is not
    //  user allocated.  If the segement is user allocated then
    //  we'll assume knows how to get rid of the memory
    //

    if (!(Segment->Flags & HEAP_SEGMENT_USER_ALLOCATED)) {

        BaseAddress = Segment->BaseAddress;
        BytesToFree = 0;

        //
        //  Free all the virtual memory for the segment and return
        //  to our caller.
        //

        return ZwFreeVirtualMemory( (PVOID *)&BaseAddress,
                                    &BytesToFree,
                                    MEM_RELEASE );

    } else {

        //
        //  User allocated segments are a noop
        //

        return STATUS_SUCCESS;
    }
}



//
//  Local Support Routine
//

PHEAP_FREE_ENTRY
RtlpExtendHeap (
    IN PHEAP Heap,
    IN SIZE_T AllocationSize
    )

/*++

Routine Description:

    This routine is used to extend the amount of committed memory in a heap

Arguments:

    Heap - Supplies the heap being modified

    AllocationSize - Supplies the size, in bytes, that we need to extend the
        heap

Return Value:

    PHEAP_FREE_ENTRY - Returns a pointer to the newly created heap entry
        of the specified size, or NULL if we weren't able to extend the heap

--*/

{
    NTSTATUS Status;
    PHEAP_SEGMENT Segment;
    PHEAP_FREE_ENTRY FreeBlock;
    UCHAR SegmentIndex, EmptySegmentIndex;
    ULONG NumberOfPages;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    SIZE_T FreeSize;

    RTL_PAGED_CODE();

    //
    //  Compute the number of pages need to hold this extension
    //  And then compute the real free, still in bytes, based on
    //  the page count
    //

    NumberOfPages = (ULONG) ((AllocationSize + PAGE_SIZE - 1) / PAGE_SIZE);
    FreeSize = NumberOfPages * PAGE_SIZE;

    //
    //  For every segment we're either going to look for an existing
    //  heap segment that we can get some pages out of or we will
    //  identify a free heap segment index where we'll try and create a new
    //  segment
    //

    EmptySegmentIndex = HEAP_MAXIMUM_SEGMENTS;

    for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

        Segment = Heap->Segments[ SegmentIndex ];

        //
        //  If the segment exists and number of uncommitted pages will
        //  satisfy our reguest and the largest uncommitted range will
        //  also satisfy our request then we'll try and segment
        //
        //  **** note that this second test seems unnecessary given that
        //  **** the largest uncommitted range is also being tested
        //

        if ((Segment) &&
            (NumberOfPages <= Segment->NumberOfUnCommittedPages) &&
            (FreeSize <= Segment->LargestUnCommittedRange)) {

            //
            //  Looks like a good segment so try and commit the
            //  amount we need
            //

            FreeBlock = RtlpFindAndCommitPages( Heap,
                                                Segment,
                                                &FreeSize,
                                                NULL );

            //
            //  If we were successful the we will coalesce it with adjacent
            //  free blocks and put it in the free list then return the
            //  the free block
            //

            if (FreeBlock != NULL) {

                //
                //  **** gdk ****
                //  **** this doesn't seem right given that coalesece should take
                //  **** byte count and not heap entry count
                //

                FreeSize = FreeSize >> HEAP_GRANULARITY_SHIFT;

                FreeBlock = RtlpCoalesceFreeBlocks( Heap, FreeBlock, &FreeSize, FALSE );

                RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );

                return FreeBlock;
            }

        //
        //  Otherwise if the segment index is not in use and we haven't
        //  yet identified a unused segment index then remembeer this
        //  index
        //

        } else if ((Segment == NULL) &&
                   (EmptySegmentIndex == HEAP_MAXIMUM_SEGMENTS)) {

            EmptySegmentIndex = SegmentIndex;
        }
    }

    //
    //  At this point we weren't able to get the memory from an existing
    //  heap segment so now check if we found an unused segment index
    //  and if we're alowed to grow the heap.
    //

    if ((EmptySegmentIndex != HEAP_MAXIMUM_SEGMENTS) &&
        (Heap->Flags & HEAP_GROWABLE)) {

        Segment = NULL;

        //
        //  Calculate a reserve size for the new segment, we might
        //  need to fudge it up if the allocation size we're going for
        //  right now is already beyond the default reserve size
        //

        if ((AllocationSize + PAGE_SIZE) > Heap->SegmentReserve) {

            ReserveSize = AllocationSize + PAGE_SIZE;

        } else {

            ReserveSize = Heap->SegmentReserve;
        }

        //
        //  Try and reserve some vm
        //

        Status = ZwAllocateVirtualMemory( (PVOID *)&Segment,
                                          0,
                                          &ReserveSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE );

        //
        //  If we get back status no memory then we should trim back the
        //  request to something reasonable and try again.  We'll half
        //  the amount until we it either succeeds or until we reach
        //  the allocation size.  In the latter case we are really
        //  out of memory.
        //

        while ((!NT_SUCCESS( Status )) && (ReserveSize != (AllocationSize + PAGE_SIZE))) {

            ReserveSize = ReserveSize / 2;

            if( ReserveSize < (AllocationSize + PAGE_SIZE) ) {

                ReserveSize = (AllocationSize + PAGE_SIZE);
            }

            Status = ZwAllocateVirtualMemory( (PVOID *)&Segment,
                                              0,
                                              &ReserveSize,
                                              MEM_RESERVE,
                                              PAGE_READWRITE );
        }

        if (NT_SUCCESS( Status )) {

            //
            //  Adjust the heap state information
            //

            Heap->SegmentReserve += ReserveSize;

            //
            //  Compute the commit size to be either the default, or if
            //  that's not big enough then make it big enough to handle
            //  this current request
            //

            if ((AllocationSize + PAGE_SIZE) > Heap->SegmentCommit) {

                CommitSize = AllocationSize + PAGE_SIZE;

            } else {

                CommitSize = Heap->SegmentCommit;
            }

            //
            //  Try and commit the memory
            //

            Status = ZwAllocateVirtualMemory( (PVOID *)&Segment,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE );

            //
            //  If the commit is successful but we were not able to
            //  initialize the heap segment then still make the status
            //  and error value
            //

            if (NT_SUCCESS( Status ) &&
                !RtlpInitializeHeapSegment( Heap,
                                            Segment,
                                            EmptySegmentIndex,
                                            0,
                                            Segment,
                                            (PCHAR)Segment + CommitSize,
                                            (PCHAR)Segment + ReserveSize)) {

                Status = STATUS_NO_MEMORY;
            }

            //
            //  If we've been successful so far then we're done and we
            //  can return the first entry in the segment to our caller
            //

            if (NT_SUCCESS(Status)) {

                return (PHEAP_FREE_ENTRY)Segment->FirstEntry;
            }

            //
            //  Otherwise either the commit or heap segment initialization failed
            //  so we'll release the memory which will also decommit it if necessary
            //

            ZwFreeVirtualMemory( (PVOID *)&Segment,
                                 &ReserveSize,
                                 MEM_RELEASE );
        }
    }

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  In the non kernel case we disabled coaleseing on free then what we'll
    //  do as a last resort is coalesce the heap and see if a block comes out
    //  that we can use
    //

    if (Heap->Flags & HEAP_DISABLE_COALESCE_ON_FREE) {

        FreeBlock = RtlpCoalesceHeap( Heap );

        if ((FreeBlock != NULL) && (FreeBlock->Size >= AllocationSize)) {

            return FreeBlock;
        }
    }

#endif // NTOS_KERNEL_RUNTIME

    //
    //  Either the heap cannot grow or we out of resources of some type
    //  so we're going to return null
    //

    return NULL;
}


//
//  Declared in heappriv.h
//

PHEAP_FREE_ENTRY
RtlpCoalesceFreeBlocks (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN OUT PSIZE_T FreeSize,
    IN BOOLEAN RemoveFromFreeList
    )

/*++

Routine Description:

    This routine coalesces the free block together.

Arguments:

    Heap - Supplies a pointer to the heap being manipulated

    FreeBlock - Supplies a pointer to the free block that we want coalesced

    FreeSize - Supplies the size, in bytes, of the free block.  On return it
        contains the size, in bytes, of the of the newly coalesced free block

    RemoveFromFreeList - Indicates if the input free block is already on a
        free list and needs to be removed to before coalescing

Return Value:

    PHEAP_FREE_ENTRY - returns a pointer to the newly coalesced free block

--*/

{
    PHEAP_FREE_ENTRY FreeBlock1, NextFreeBlock;

    RTL_PAGED_CODE();

    //
    //  Point to the preceding block
    //

    FreeBlock1 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)FreeBlock - FreeBlock->PreviousSize);

    //
    //  Check if there is a preceding block, and if it is free, and the two sizes
    //  put together will still fit on a free lists.
    //

    if ((FreeBlock1 != FreeBlock) &&
        !(FreeBlock1->Flags & HEAP_ENTRY_BUSY) &&
        ((*FreeSize + FreeBlock1->Size) <= HEAP_MAXIMUM_BLOCK_SIZE)) {

        //
        //  We are going to merge ourselves with the preceding block
        //

        HEAPASSERT(FreeBlock->PreviousSize == FreeBlock1->Size);

        //
        //  Check if we need to remove the input block from the free list
        //

        if (RemoveFromFreeList) {

            RtlpRemoveFreeBlock( Heap, FreeBlock );

            Heap->TotalFreeSize -= FreeBlock->Size;

            //
            //  We're removed so we don't have to do it again
            //

            RemoveFromFreeList = FALSE;
        }

        //
        //  Remove the preceding block from its free list
        //

        RtlpRemoveFreeBlock( Heap, FreeBlock1 );

        //
        //  Copy over the last entry flag if necessary from what we're freeing
        //  to the preceding block
        //

        FreeBlock1->Flags = FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY;

        if( FreeBlock1->Flags & HEAP_ENTRY_LAST_ENTRY ) {

            PHEAP_SEGMENT Segment;

            Segment = Heap->Segments[FreeBlock1->SegmentIndex];
            Segment->LastEntryInSegment = (PHEAP_ENTRY)FreeBlock1;
        }

        //
        //  Point to the preceding block, and adjust the sizes for the
        //  new free block.  It is the total of both blocks.
        //

        FreeBlock = FreeBlock1;

        *FreeSize += FreeBlock1->Size;

        Heap->TotalFreeSize -= FreeBlock1->Size;

        FreeBlock->Size = (USHORT)*FreeSize;

        //
        //  Check if we need to update the previous size of the next
        //  entry
        //

        if (!(FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

            ((PHEAP_ENTRY)FreeBlock + *FreeSize)->PreviousSize = (USHORT)*FreeSize;
        }
    }

    //
    //  Check if there is a following block.
    //

    if (!(FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

        //
        //  There is a following block so now get a pointer to it
        //  and check if it is free and if putting the two blocks together
        //  still fits on a free list
        //

        NextFreeBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)FreeBlock + *FreeSize);

        if (!(NextFreeBlock->Flags & HEAP_ENTRY_BUSY) &&
            ((*FreeSize + NextFreeBlock->Size) <= HEAP_MAXIMUM_BLOCK_SIZE)) {

            //
            //  We are going to merge ourselves with the following block
            //

            HEAPASSERT(*FreeSize == NextFreeBlock->PreviousSize);

            //
            //  Check if we need to remove the input block from the free list
            //

            if (RemoveFromFreeList) {

                RtlpRemoveFreeBlock( Heap, FreeBlock );

                Heap->TotalFreeSize -= FreeBlock->Size;

                //
                //  **** this assignment isn't necessary because there isn't
                //  **** any more merging after this one
                //

                RemoveFromFreeList = FALSE;
            }

            //
            //  Copy up the last entry flag if necessary from the following
            //  block to our input block
            //

            FreeBlock->Flags = NextFreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY;

            if( FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY ) {

                PHEAP_SEGMENT Segment;

                Segment = Heap->Segments[FreeBlock->SegmentIndex];
                Segment->LastEntryInSegment = (PHEAP_ENTRY)FreeBlock;
            }

            //
            //  Remove the following block from its free list
            //

            RtlpRemoveFreeBlock( Heap, NextFreeBlock );

            //
            //  Adjust the size for the newly combined block
            //

            *FreeSize += NextFreeBlock->Size;

            Heap->TotalFreeSize -= NextFreeBlock->Size;

            FreeBlock->Size = (USHORT)*FreeSize;

            //
            //  Check if we need to update the previous size of the next block
            //

            if (!(FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                ((PHEAP_ENTRY)FreeBlock + *FreeSize)->PreviousSize = (USHORT)*FreeSize;
            }
        }
    }

    //
    //  And return the free block to our caller
    //

    return FreeBlock;
}


//
//  Declared in heappriv.h
//

VOID
RtlpDeCommitFreeBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN SIZE_T FreeSize
    )

/*++

Routine Description:

    This routine takes a free block and decommits it.  This is usually called
    because the block is beyond the decommit threshold

Arguments:

    Heap - Supplies a pointer to the heap being manipulated

    FreeBlock - Supplies a pointer to the block being decommitted

    FreeSize - Supplies the size, in bytes, of the free block being decommitted

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ULONG_PTR DeCommitAddress;
    SIZE_T DeCommitSize;
    USHORT LeadingFreeSize, TrailingFreeSize;
    PHEAP_SEGMENT Segment;
    PHEAP_FREE_ENTRY LeadingFreeBlock, TrailingFreeBlock;
    PHEAP_ENTRY LeadingBusyBlock, TrailingBusyBlock;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;

    RTL_PAGED_CODE();

    //
    //  If the heap has a user specified decommit routine then we won't really
    //  decommit anything instead we'll call a worker routine to chop it up
    //  into pieces that will fit on the free lists
    //

    if (Heap->CommitRoutine != NULL) {

        RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );

        return;
    }

    //
    //  Get a pointer to the owning segment
    //

    Segment = Heap->Segments[ FreeBlock->SegmentIndex ];

    //
    //  The leading busy block identifies the preceding in use block before
    //  what we are trying to decommit.  It is only used if what we are trying
    //  decommit is right on a page boundary and then it is the block right
    //  before us if it exists.
    //
    //  The leading free block is used to identify whatever space is needed
    //  to round up the callers specified address to a page address.  If the
    //  caller already gave us a page aligned address then the free block
    //  address is identical to what the caller supplied.
    //

    LeadingBusyBlock = NULL;
    LeadingFreeBlock = FreeBlock;

    //
    //  Make sure the block we are trying to decommit start on the next full
    //  page boundary.  The leading free size is the size of whatever it takes
    //  to round up the free block to the next page specified in units of
    //  heap entries.
    //

    DeCommitAddress = ROUND_UP_TO_POWER2( LeadingFreeBlock, PAGE_SIZE );
    LeadingFreeSize = (USHORT)((PHEAP_ENTRY)DeCommitAddress - (PHEAP_ENTRY)LeadingFreeBlock);

    //
    //  If we leading free size only has space for one heap entry then we'll
    //  bump it up to include the next page, because we don't want to leave
    //  anything that small laying around.  Otherwise if we have a preceding
    //  block and the leading free size is zero then identify the preceding
    //  block as the leading busy block
    //

    if (LeadingFreeSize == 1) {

        DeCommitAddress += PAGE_SIZE;
        LeadingFreeSize += PAGE_SIZE >> HEAP_GRANULARITY_SHIFT;

    } else if (LeadingFreeBlock->PreviousSize != 0) {

        if (DeCommitAddress == (ULONG_PTR)LeadingFreeBlock) {

            LeadingBusyBlock = (PHEAP_ENTRY)LeadingFreeBlock - LeadingFreeBlock->PreviousSize;
        }
    }

    //
    //  The trailing busy block identifies the block immediately after the one
    //  we are trying to decommit provided what we are decommitting ends right
    //  on a page boundary otherwise the trailing busy block stays null and
    //  the trailing free block value is used.
    //
    //  **** gdk ****
    //  **** the assignment of tailing free block doesn't seem right because
    //  **** Free size should be in bytes, and not heap entries
    //

    TrailingBusyBlock = NULL;
    TrailingFreeBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)FreeBlock + FreeSize);

    //
    //  Make sure the block we are trying to decommit ends on a page boundary.
    //
    //  And compute how many heap entries we had to backup to make it land on a
    //  page boundary.
    //

    DeCommitSize = ROUND_DOWN_TO_POWER2( (ULONG_PTR)TrailingFreeBlock, PAGE_SIZE );
    TrailingFreeSize = (USHORT)((PHEAP_ENTRY)TrailingFreeBlock - (PHEAP_ENTRY)DeCommitSize);

    //
    //  If the trailing free size is exactly one heap in size then we will
    //  nibble off a bit more from the decommit size because free block of
    //  exactly one heap entry in size are useless.  Otherwise if we actually
    //  ended on a page boundary and there is a block after us then indicate
    //  that we have a trailing busy block
    //

    if (TrailingFreeSize == (sizeof( HEAP_ENTRY ) >> HEAP_GRANULARITY_SHIFT)) {

        DeCommitSize -= PAGE_SIZE;
        TrailingFreeSize += PAGE_SIZE >> HEAP_GRANULARITY_SHIFT;

    } else if ((TrailingFreeSize == 0) && !(FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

        TrailingBusyBlock = (PHEAP_ENTRY)TrailingFreeBlock;
    }

    //
    //  Now adjust the trailing free block to compensate for the trailing free size
    //  we just computed.
    //

    TrailingFreeBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)TrailingFreeBlock - TrailingFreeSize);

    //
    //  Right now DeCommit size is really a pointer.  If it points at is beyond
    //  the decommit address then make the size really be just the byte count
    //  to decommit.  Otherwise the decommit size is zero.
    //

    if (DeCommitSize > DeCommitAddress) {

        DeCommitSize -= DeCommitAddress;

    } else {

        DeCommitSize = 0;
    }

    //
    //  **** this next test is bogus given the if-then-else that just preceded it
    //
    //  Now check if we still have something to decommit
    //

    if (DeCommitSize != 0) {

        //
        //  Before freeing the memory to MM we have to be sure we can create 
        //  a PHEAP_UNCOMMMTTED_RANGE later. So we do it right now
        //

        UnCommittedRange = RtlpCreateUnCommittedRange(Segment);

        if (UnCommittedRange == NULL) {
            
            HeapDebugPrint(( "Failing creating uncommitted range (%x for %x)\n", DeCommitAddress, DeCommitSize ));

            //
            //  We weren't successful in the decommit so now simply
            //  add the leading free block to the free list
            //

            RtlpInsertFreeBlock( Heap, LeadingFreeBlock, FreeSize );

            return;
        }

        //
        //  Decommit the memory
        //

        Status = ZwFreeVirtualMemory( (PVOID *)&DeCommitAddress,
                                      &DeCommitSize,
                                      MEM_DECOMMIT );

        //
        //  Push back the UnCommittedRange structure. Now the insert cannot fail
        //

        RtlpDestroyUnCommittedRange( Segment, UnCommittedRange );

        if (NT_SUCCESS( Status )) {

            //
            //  Insert information regarding the pages we just decommitted
            //  to the lsit of uncommited pages in the segment
            //

            RtlpInsertUnCommittedPages( Segment,
                                        DeCommitAddress,
                                        DeCommitSize );
            //
            //  Adjust the segments count of uncommitted pages
            //

            Segment->NumberOfUnCommittedPages += (ULONG)(DeCommitSize / PAGE_SIZE);

            //
            //  If we have a leading free block then mark its proper state
            //  update the heap, and put it on the free list
            //

            if (LeadingFreeSize != 0) {

                LeadingFreeBlock->Flags = HEAP_ENTRY_LAST_ENTRY;
                LeadingFreeBlock->Size = LeadingFreeSize;
                Heap->TotalFreeSize += LeadingFreeSize;

                Segment->LastEntryInSegment = (PHEAP_ENTRY)LeadingFreeBlock;

                RtlpInsertFreeBlockDirect( Heap, LeadingFreeBlock, LeadingFreeSize );

            //
            //  Otherwise if we actually have a leading busy block then
            //  make sure the busy block knows we're uncommitted
            //

            } else if (LeadingBusyBlock != NULL) {

                LeadingBusyBlock->Flags |= HEAP_ENTRY_LAST_ENTRY;

                Segment->LastEntryInSegment = LeadingBusyBlock;

            } else if ((Segment->LastEntryInSegment >= (PHEAP_ENTRY)DeCommitAddress)
                            &&
                       ((PCHAR)Segment->LastEntryInSegment < ((PCHAR)DeCommitAddress + DeCommitSize))) {

                     Segment->LastEntryInSegment = Segment->FirstEntry;
            }

            //
            //  If there is a trailing free block then sets its state,
            //  update the heap, and insert it on a free list
            //

            if (TrailingFreeSize != 0) {

                TrailingFreeBlock->PreviousSize = 0;
                TrailingFreeBlock->SegmentIndex = Segment->Entry.SegmentIndex;
                TrailingFreeBlock->Flags = 0;
                TrailingFreeBlock->Size = TrailingFreeSize;

                ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)TrailingFreeBlock + TrailingFreeSize))->PreviousSize = (USHORT)TrailingFreeSize;

                RtlpInsertFreeBlockDirect( Heap, TrailingFreeBlock, TrailingFreeSize );

                Heap->TotalFreeSize += TrailingFreeSize;

            //
            //  Otherwise if we actually have a succeeding block then
            //  make it know we are uncommitted
            //

            } else if (TrailingBusyBlock != NULL) {

                TrailingBusyBlock->PreviousSize = 0;
            }

        } else {

            //
            //  We weren't successful in the decommit so now simply
            //  add the leading free block to the free list
            //

            RtlpInsertFreeBlock( Heap, LeadingFreeBlock, FreeSize );
        }

    } else {

        //
        //  There is nothing left to decommit to take our leading free block
        //  and put it on a free list
        //

        RtlpInsertFreeBlock( Heap, LeadingFreeBlock, FreeSize );
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in heappriv.h
//

VOID
RtlpInsertFreeBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN SIZE_T FreeSize
    )

/*++

Routine Description:

    This routines take a piece of committed memory and adds to the
    the appropriate free lists for the heap.  If necessary this
    routine will divide up the free block to sizes that fit
    on the free list


Arguments:

    Heap - Supplies a pointer to the owning heap

    FreeBlock - Supplies a pointer to the block being freed

    FreeSize - Supplies the size, in bytes, of the block being freed

Return Value:

    None.

--*/

{
    USHORT PreviousSize, Size;
    UCHAR Flags;
    UCHAR SegmentIndex;
    PHEAP_SEGMENT Segment;

    RTL_PAGED_CODE();

    //
    //  Get the size of the previous block, the index of the segment
    //  containing this block, and the flags specific to the block
    //

    PreviousSize = FreeBlock->PreviousSize;

    SegmentIndex = FreeBlock->SegmentIndex;
    Segment = Heap->Segments[ SegmentIndex ];

    Flags = FreeBlock->Flags;

    //
    //  Adjust the total amount free in the heap
    //

    Heap->TotalFreeSize += FreeSize;

    //
    //  Now, while there is still something left to add to the free list
    //  we'll process the information
    //

    while (FreeSize != 0) {

        //
        //  If the size is too big for our free lists then we'll
        //  chop it down.
        //

        if (FreeSize > (ULONG)HEAP_MAXIMUM_BLOCK_SIZE) {

            Size = HEAP_MAXIMUM_BLOCK_SIZE;

            //
            //  This little adjustment is so that we don't have a remainder
            //  that is too small to be useful on the next iteration
            //  through the loop
            //

            if (FreeSize == ((ULONG)HEAP_MAXIMUM_BLOCK_SIZE + 1)) {

                Size -= 16;
            }

            //
            //  Guarantee that Last entry does not get set in this
            //  block.
            //

            FreeBlock->Flags = 0;

        } else {

            Size = (USHORT)FreeSize;

            //
            //  This could propagate the last entry flag
            //

            FreeBlock->Flags = Flags;
        }

        //
        //  Update the block sizes and then insert this
        //  block into a free list
        //

        FreeBlock->PreviousSize = PreviousSize;
        FreeBlock->SegmentIndex = SegmentIndex;
        FreeBlock->Size = Size;

        RtlpInsertFreeBlockDirect( Heap, FreeBlock, Size );

        //
        //  Note the size of what we just freed, and then update
        //  our state information for the next time through the
        //  loop
        //

        PreviousSize = Size;

        FreeSize -= Size;
        FreeBlock = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)FreeBlock + Size);

        //
        //  Check if we're done with the free block based on the
        //  segment information, otherwise go back up and check size
        //  Note that is means that we can get called with a very
        //  large size and still work.
        //

        if ((PHEAP_ENTRY)FreeBlock >= Segment->LastValidEntry) {

            return;
        }
    }

    //
    //  If the block we're freeing did not think it was the last entry
    //  then tell the next block our real size.
    //

    if (!(Flags & HEAP_ENTRY_LAST_ENTRY)) {

        FreeBlock->PreviousSize = PreviousSize;
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in heappriv.h
//

PHEAP_ENTRY_EXTRA
RtlpGetExtraStuffPointer (
    PHEAP_ENTRY BusyBlock
    )

/*++

Routine Description:

    This routine calculates where the extra stuff record will be given
    the busy block and returns a pointer to it.  The caller must have
    already checked that the entry extry field is present

Arguments:

    BusyBlock - Supplies the busy block whose extra stuff we are seeking

Return Value:

    PHEAP_ENTRY_EXTRA - returns a pointer to the extra stuff record.

--*/

{
    ULONG AllocationIndex;

    //
    //  On big blocks the extra stuff is automatically part of the
    //  block
    //

    if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

        PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

        VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

        return &VirtualAllocBlock->ExtraStuff;

    } else {

        //
        //  On non big blocks the extra stuff follows immediately after
        //  the allocation itself.
        //
        //  **** What a hack
        //  **** We do some funny math here because the busy block
        //  **** stride is 8 bytes we know we can stride it by its
        //  **** index minus one to get to the end of the allocation
        //

        AllocationIndex = BusyBlock->Size;

        return (PHEAP_ENTRY_EXTRA)(BusyBlock + AllocationIndex - 1);
    }
}


//
//  Declared in heappriv.h
//

SIZE_T
RtlpGetSizeOfBigBlock (
    IN PHEAP_ENTRY BusyBlock
    )

/*++

Routine Description:

    This routine returns the size, in bytes, of the big allocation block

Arguments:

    BusyBlock - Supplies a pointer to the block being queried

Return Value:

    SIZE_T - Returns the size, in bytes, that was allocated to the big
        block

--*/

{
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

    RTL_PAGED_CODE();

    //
    //  Get a pointer to the block header itself
    //

    VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

    //
    //  The size allocated to the block is actually the difference between the
    //  commit size stored in the virtual alloc block and the size stored in
    //  in the block.
    //

    return VirtualAllocBlock->CommitSize - BusyBlock->Size;
}


//
//  Declared in heappriv.h
//

BOOLEAN
RtlpCheckBusyBlockTail (
    IN PHEAP_ENTRY BusyBlock
    )

/*++

Routine Description:

    This routine checks to see if the bytes beyond the user specified
    allocation have been modified.  It does this by checking for a tail
    fill pattern

Arguments:

    BusyBlock - Supplies the heap block being queried

Return Value:

    BOOLEAN - TRUE if the tail is still okay and FALSE otherwise

--*/

{
    PCHAR Tail;
    SIZE_T Size, cbEqual;

    RTL_PAGED_CODE();

    //
    //  Compute the user allocated size of the input heap block
    //

    if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

        Size = RtlpGetSizeOfBigBlock( BusyBlock );

    } else {

        Size = (BusyBlock->Size << HEAP_GRANULARITY_SHIFT) - BusyBlock->UnusedBytes;
    }

    //
    //  Compute a pointer to the tail of the input block.  This would
    //  be the space right after the user allocated portion
    //

    Tail = (PCHAR)(BusyBlock + 1) + Size;

    //
    //  Check if the tail fill pattern is still there
    //

    cbEqual = RtlCompareMemory( Tail,
                                CheckHeapFillPattern,
                                CHECK_HEAP_TAIL_SIZE );

    //
    //  If the number we get back isn't equal to the tail size then
    //  someone modified the block beyond its user specified allocation
    //  size
    //

    if (cbEqual != CHECK_HEAP_TAIL_SIZE) {

        //
        //  Do some debug printing
        //

        HeapDebugPrint(( "Heap block at %p modified at %p past requested size of %lx\n",
                         BusyBlock,
                         Tail + cbEqual,
                         Size ));

        HeapDebugBreak( BusyBlock );

        //
        //  And tell our caller there was an error
        //

        return FALSE;

    } else {

        //
        //  And return to our caller that the tail is fine
        //

        return TRUE;
    }
}

#if DBG

BOOLEAN RtlpValidateHeapHdrsEnable = FALSE; // Set to TRUE if headers are being corrupted
BOOLEAN RtlpValidateHeapTagsEnable;         // Set to TRUE if tag counts are off and you want to know why

HEAP_STOP_ON_VALUES RtlpHeapStopOn;


const struct {

    ULONG Offset;
    LPSTR Description;

} RtlpHeapHeaderFieldOffsets[] = {

    FIELD_OFFSET( HEAP, Entry ),                        "Entry",
    FIELD_OFFSET( HEAP, Signature ),                    "Signature",
    FIELD_OFFSET( HEAP, Flags ),                        "Flags",
    FIELD_OFFSET( HEAP, ForceFlags ),                   "ForceFlags",
    FIELD_OFFSET( HEAP, VirtualMemoryThreshold ),       "VirtualMemoryThreshold",
    FIELD_OFFSET( HEAP, SegmentReserve ),               "SegmentReserve",
    FIELD_OFFSET( HEAP, SegmentCommit ),                "SegmentCommit",
    FIELD_OFFSET( HEAP, DeCommitFreeBlockThreshold ),   "DeCommitFreeBlockThreshold",
    FIELD_OFFSET( HEAP, DeCommitTotalFreeThreshold ),   "DeCommitTotalFreeThreshold",
    FIELD_OFFSET( HEAP, TotalFreeSize ),                "TotalFreeSize",
    FIELD_OFFSET( HEAP, MaximumAllocationSize ),        "MaximumAllocationSize",
    FIELD_OFFSET( HEAP, ProcessHeapsListIndex ),        "ProcessHeapsListIndex",
    FIELD_OFFSET( HEAP, HeaderValidateLength ),         "HeaderValidateLength",
    FIELD_OFFSET( HEAP, HeaderValidateCopy ),           "HeaderValidateCopy",
    FIELD_OFFSET( HEAP, NextAvailableTagIndex ),        "NextAvailableTagIndex",
    FIELD_OFFSET( HEAP, MaximumTagIndex ),              "MaximumTagIndex",
    FIELD_OFFSET( HEAP, TagEntries ),                   "TagEntries",
    FIELD_OFFSET( HEAP, UCRSegments ),                  "UCRSegments",
    FIELD_OFFSET( HEAP, UnusedUnCommittedRanges ),      "UnusedUnCommittedRanges",
    FIELD_OFFSET( HEAP, AlignRound ),                   "AlignRound",
    FIELD_OFFSET( HEAP, AlignMask ),                    "AlignMask",
    FIELD_OFFSET( HEAP, VirtualAllocdBlocks ),          "VirtualAllocdBlocks",
    FIELD_OFFSET( HEAP, Segments ),                     "Segments",
    FIELD_OFFSET( HEAP, u ),                            "FreeListsInUse",
    FIELD_OFFSET( HEAP, FreeListsInUseTerminate ),      "FreeListsInUseTerminate",
    FIELD_OFFSET( HEAP, AllocatorBackTraceIndex ),      "AllocatorBackTraceIndex",
    FIELD_OFFSET( HEAP, Reserved1 ),                    "Reserved1",
    FIELD_OFFSET( HEAP, PseudoTagEntries ),             "PseudoTagEntries",
    FIELD_OFFSET( HEAP, FreeLists ),                    "FreeLists",
    FIELD_OFFSET( HEAP, LockVariable ),                 "LockVariable",
    FIELD_OFFSET( HEAP, Lookaside ),                    "Lookaside",
    FIELD_OFFSET( HEAP, LookasideLockCount ),           "LookasideLockCount",
    sizeof( HEAP ),                                     "Uncommitted Ranges",
    0xFFFF, NULL
};

//
//  Declared in heappriv.h
//

BOOLEAN
RtlpCheckHeapSignature (
    IN PHEAP Heap,
    IN PCHAR Caller
    )

/*++

Routine Description:

    This routine verifies that it is being called with a properly identified
    heap.

Arguments:

    Heap - Supplies a pointer to the heap being checked

    Caller - Supplies a string that can be used to identify the caller

Return Value:

    BOOLEAN - TRUE if the heap signature is present, and FALSE otherwise

--*/

{
    //
    //  If the heap signature matches then that is the only
    //  checking we do
    //

    if (Heap->Signature == HEAP_SIGNATURE) {

        return TRUE;

    } else {

        //
        //  We have a bad heap signature.  Print out some information, break
        //  into the debugger, and then return false
        //

        HeapDebugPrint(( "Invalid heap signature for heap at %x", Heap ));

        if (Caller != NULL) {

            DbgPrint( ", passed to %s", Caller );
        }

        DbgPrint( "\n" );

        HeapDebugBreak( &Heap->Signature );

        return FALSE;
    }
}



BOOLEAN
RtlpValidateHeapHeaders (
    IN PHEAP Heap,
    IN BOOLEAN Recompute
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    ULONG i;
    SIZE_T n;
    SIZE_T nEqual;
    NTSTATUS Status;

    if (!RtlpValidateHeapHdrsEnable) {

        return TRUE;
    }

    if (Heap->HeaderValidateCopy == NULL) {

        n = Heap->HeaderValidateLength;

        Status = NtAllocateVirtualMemory( &Heap->HeaderValidateCopy,
                                          0,
                                          &n,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return TRUE;
        }

        Recompute = TRUE;
    }

    n = Heap->HeaderValidateLength;

    if (!Recompute) {

        nEqual = RtlCompareMemory( Heap,
                                   Heap->HeaderValidateCopy,
                                   n );

    } else {

        RtlMoveMemory( Heap->HeaderValidateCopy,
                       Heap,
                       n );

        nEqual = n;
    }

    if (n != nEqual) {

        HeapDebugPrint(( "Heap %x - headers modified (%x is %x instead of %x)\n",
                         Heap,
                         (PCHAR)Heap + nEqual,
                         *(PULONG)((PCHAR)Heap + nEqual),
                         *(PULONG)((PCHAR)Heap->HeaderValidateCopy + nEqual)));

        for (i=0; RtlpHeapHeaderFieldOffsets[ i ].Description != NULL; i++) {

            if ((nEqual >= RtlpHeapHeaderFieldOffsets[ i ].Offset) &&
                (nEqual < RtlpHeapHeaderFieldOffsets[ i+1 ].Offset)) {

                DbgPrint( "    This is located in the %s field of the heap header.\n",
                                 RtlpHeapHeaderFieldOffsets[ i ].Description );

                break;
            }
        }

        return FALSE;

    } else {

        return TRUE;
    }
}



BOOLEAN
RtlpValidateHeapSegment (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN UCHAR SegmentIndex,
    IN OUT PULONG CountOfFreeBlocks,
    IN OUT PSIZE_T TotalFreeSize,
    OUT PVOID *BadAddress,
    IN OUT PSIZE_T ComputedTagEntries,
    IN OUT PSIZE_T ComputedPseudoTagEntries
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP_ENTRY CurrentBlock, PreviousBlock;
    SIZE_T Size;
    USHORT PreviousSize, TagIndex;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;

    RTL_PAGED_CODE();

    NumberOfUnCommittedPages = 0;
    NumberOfUnCommittedRanges = 0;

    UnCommittedRange = Segment->UnCommittedRanges;

    if (Segment->BaseAddress == Heap) {

        CurrentBlock = &Heap->Entry;

    } else {

        CurrentBlock = &Segment->Entry;
    }

    while (CurrentBlock < Segment->LastValidEntry) {

        *BadAddress = CurrentBlock;

        if ((UnCommittedRange != NULL) &&
            ((ULONG_PTR)CurrentBlock >= UnCommittedRange->Address)) {

            HeapDebugPrint(( "Heap entry %lx is beyond uncommited range [%x .. %x)\n",
                             CurrentBlock,
                             UnCommittedRange->Address,
                             (PCHAR)UnCommittedRange->Address + UnCommittedRange->Size ));

            return FALSE;
        }

        PreviousSize = 0;

        while (CurrentBlock < Segment->LastValidEntry) {

            *BadAddress = CurrentBlock;

            if (PreviousSize != CurrentBlock->PreviousSize) {

                HeapDebugPrint(( "Heap entry %lx has incorrect PreviousSize field (%04x instead of %04x)\n",
                                 CurrentBlock, CurrentBlock->PreviousSize, PreviousSize ));

                return FALSE;
            }

            PreviousSize = CurrentBlock->Size;
            Size = (ULONG_PTR)CurrentBlock->Size << HEAP_GRANULARITY_SHIFT;

            if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {

                if (ComputedTagEntries != NULL) {

                    if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                        ExtraStuff = RtlpGetExtraStuffPointer( CurrentBlock );
                        TagIndex = ExtraStuff->TagIndex;

                    } else {

                        TagIndex = CurrentBlock->SmallTagIndex;
                    }

                    if (TagIndex != 0) {

                        if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

                            TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

                            if (TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) {

                                ComputedPseudoTagEntries[ TagIndex ] += CurrentBlock->Size;
                            }

                        } else if (TagIndex & HEAP_GLOBAL_TAG) {

                            //
                            //  Ignore these since they are global across more than
                            //  one heap.
                            //

                        } else if (TagIndex < Heap->NextAvailableTagIndex) {

                            ComputedTagEntries[ TagIndex ] += CurrentBlock->Size;
                        }
                    }
                }

                if (CurrentBlock->Flags & HEAP_ENTRY_FILL_PATTERN) {

                    if (!RtlpCheckBusyBlockTail( CurrentBlock )) {

                        return FALSE;
                    }
                }

            } else {

                *CountOfFreeBlocks += 1;
                *TotalFreeSize += CurrentBlock->Size;

                if ((Heap->Flags & HEAP_FREE_CHECKING_ENABLED) &&
                    (CurrentBlock->Flags & HEAP_ENTRY_FILL_PATTERN)) {

                    SIZE_T cb, cbEqual;

                    cb = Size - sizeof( HEAP_FREE_ENTRY );

                    if ((CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) &&
                        (cb > sizeof( HEAP_FREE_ENTRY_EXTRA ))) {

                        cb -= sizeof( HEAP_FREE_ENTRY_EXTRA );
                    }

                    cbEqual = RtlCompareMemoryUlong( (PCHAR)((PHEAP_FREE_ENTRY)CurrentBlock + 1),
                                                     cb,
                                                     FREE_HEAP_FILL );

                    if (cbEqual != cb) {

                        HeapDebugPrint(( "Free Heap block %lx modified at %lx after it was freed\n",
                                         CurrentBlock,
                                         (PCHAR)(CurrentBlock + 1) + cbEqual ));

                        return FALSE;
                    }
                }
            }

            if (CurrentBlock->SegmentIndex != SegmentIndex) {

                HeapDebugPrint(( "Heap block at %lx has incorrect segment index (%x)\n",
                                 CurrentBlock,
                                 SegmentIndex ));

                return FALSE;
            }

            if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                CurrentBlock = (PHEAP_ENTRY)((PCHAR)CurrentBlock + Size);

                if (UnCommittedRange == NULL) {

                    if (CurrentBlock != Segment->LastValidEntry) {

                        HeapDebugPrint(( "Heap block at %lx is not last block in segment (%x)\n",
                                         CurrentBlock,
                                         Segment->LastValidEntry ));

                        return FALSE;
                    }

                } else if ((ULONG_PTR)CurrentBlock != UnCommittedRange->Address) {

                    HeapDebugPrint(( "Heap block at %lx does not match address of next uncommitted address (%x)\n",
                                     CurrentBlock,
                                     UnCommittedRange->Address ));

                    return FALSE;

                } else {

                    NumberOfUnCommittedPages += (ULONG) (UnCommittedRange->Size / PAGE_SIZE);
                    NumberOfUnCommittedRanges += 1;

                    CurrentBlock = (PHEAP_ENTRY)
                        ((PCHAR)UnCommittedRange->Address + UnCommittedRange->Size);

                    UnCommittedRange = UnCommittedRange->Next;
                }

                break;
            }

            CurrentBlock = (PHEAP_ENTRY)((PCHAR)CurrentBlock + Size);
        }
    }

    *BadAddress = Segment;

    if (Segment->NumberOfUnCommittedPages != NumberOfUnCommittedPages) {

        HeapDebugPrint(( "Heap Segment at %lx contains invalid NumberOfUnCommittedPages (%x != %x)\n",
                         Segment,
                         Segment->NumberOfUnCommittedPages,
                         NumberOfUnCommittedPages ));

        return FALSE;
    }

    if (Segment->NumberOfUnCommittedRanges != NumberOfUnCommittedRanges) {

        HeapDebugPrint(( "Heap Segment at %lx contains invalid NumberOfUnCommittedRanges (%x != %x)\n",
                         Segment,
                         Segment->NumberOfUnCommittedRanges,
                         NumberOfUnCommittedRanges ));

        return FALSE;
    }

    return TRUE;
}



BOOLEAN
RtlpValidateHeapEntry (
    IN PHEAP Heap,
    IN PHEAP_ENTRY BusyBlock,
    IN PCHAR Reason
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    BOOLEAN Result;

    if ((BusyBlock == NULL)

            ||

        ((ULONG_PTR)BusyBlock & (HEAP_GRANULARITY-1))

            ||

        ((BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) &&
         ((ULONG_PTR)BusyBlock & (PAGE_SIZE-1)) != FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock ))

            ||

        (!(BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) &&
         ((BusyBlock->SegmentIndex >= HEAP_MAXIMUM_SEGMENTS) ||
          !(Segment = Heap->Segments[ BusyBlock->SegmentIndex ]) ||
          (BusyBlock < Segment->FirstEntry) ||
          (BusyBlock >= Segment->LastValidEntry)))

            ||

        !(BusyBlock->Flags & HEAP_ENTRY_BUSY)

            ||

        ((BusyBlock->Flags & HEAP_ENTRY_FILL_PATTERN) && !RtlpCheckBusyBlockTail( BusyBlock ))) {

InvalidBlock:

        HeapDebugPrint(( "Invalid Address specified to %s( %lx, %lx )\n",
                         Reason,
                         Heap,
                         BusyBlock + 1 ));

        HeapDebugBreak( BusyBlock );

        return FALSE;

    } else {

        if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

            Result = TRUE;

        } else {

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                if (Segment) {

                    if ((BusyBlock >= Segment->FirstEntry) &&
                        (BusyBlock < Segment->LastValidEntry)) {

                        Result = TRUE;
                        break;
                    }
                }
            }
        }

        if (!Result) {

            goto InvalidBlock;
        }

        return TRUE;
    }
}



BOOLEAN
RtlpValidateHeap (
    IN PHEAP Heap,
    IN BOOLEAN AlwaysValidate
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;
    PHEAP_SEGMENT Segment;
    PLIST_ENTRY Head, Next;
    PHEAP_FREE_ENTRY FreeBlock;
    BOOLEAN EmptyFreeList;
    ULONG NumberOfFreeListEntries;
    ULONG CountOfFreeBlocks;
    SIZE_T TotalFreeSize;
    SIZE_T Size;
    USHORT PreviousSize;
    UCHAR SegmentIndex;
    PVOID BadAddress;
    PSIZE_T ComputedTagEntries = NULL;
    PSIZE_T ComputedPseudoTagEntries = NULL;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;
    USHORT TagIndex;

    RTL_PAGED_CODE();

    BadAddress = Heap;

    if (!RtlpValidateHeapHeaders( Heap, FALSE )) {

        goto errorExit;
    }

    if (!AlwaysValidate && !(Heap->Flags & HEAP_VALIDATE_ALL_ENABLED)) {

        goto exit;
    }

    NumberOfFreeListEntries = 0;
    Head = &Heap->FreeLists[ 0 ];

    for (Size = 0; Size < HEAP_MAXIMUM_FREELISTS; Size++) {

        if (Size != 0) {

            EmptyFreeList = (BOOLEAN)(IsListEmpty( Head ));
            BadAddress = &Heap->u.FreeListsInUseBytes[ Size / 8 ];

            if (Heap->u.FreeListsInUseBytes[ Size / 8 ] & (1 << (Size & 7)) ) {

                if (EmptyFreeList) {

                    HeapDebugPrint(( "dedicated (%04x) free list empty but marked as non-empty\n",
                                     Size ));

                    goto errorExit;
                }

            } else {

                if (!EmptyFreeList) {

                    HeapDebugPrint(( "dedicated (%04x) free list non-empty but marked as empty\n",
                                     Size ));

                    goto errorExit;
                }
            }
        }

        Next = Head->Flink;
        PreviousSize = 0;

        while (Head != Next) {

            FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );
            Next = Next->Flink;

            BadAddress = FreeBlock;

            if (FreeBlock->Flags & HEAP_ENTRY_BUSY) {

                HeapDebugPrint(( "dedicated (%04x) free list element %lx is marked busy\n",
                                 Size,
                                 FreeBlock ));

                goto errorExit;
            }

            if ((Size != 0) && (FreeBlock->Size != Size)) {

                HeapDebugPrint(( "Dedicated (%04x) free list element %lx is wrong size (%04x)\n",
                                 Size,
                                 FreeBlock,
                                 FreeBlock->Size ));

                goto errorExit;

            } else if ((Size == 0) && (FreeBlock->Size < HEAP_MAXIMUM_FREELISTS)) {

                HeapDebugPrint(( "Non-Dedicated free list element %lx with too small size (%04x)\n",
                                 FreeBlock,
                                 FreeBlock->Size ));

                goto errorExit;

            } else if ((Size == 0) && (FreeBlock->Size < PreviousSize)) {

                HeapDebugPrint(( "Non-Dedicated free list element %lx is out of order\n",
                                 FreeBlock ));

                goto errorExit;

            } else {

                PreviousSize = FreeBlock->Size;
            }

            NumberOfFreeListEntries++;
        }

        Head++;
    }

    Size = (HEAP_NUMBER_OF_PSEUDO_TAG + Heap->NextAvailableTagIndex + 1) * sizeof( SIZE_T );

    if ((RtlpValidateHeapTagsEnable) && (Heap->PseudoTagEntries != NULL)) {

        Status = NtAllocateVirtualMemory( &ComputedPseudoTagEntries,
                                          0,
                                          &Size,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (NT_SUCCESS( Status )) {

            ComputedTagEntries = ComputedPseudoTagEntries + HEAP_NUMBER_OF_PSEUDO_TAG;
        }
    }

    Head = &Heap->VirtualAllocdBlocks;
    Next = Head->Flink;

    while (Head != Next) {

        VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

        if (ComputedTagEntries != NULL) {

            TagIndex = VirtualAllocBlock->ExtraStuff.TagIndex;

            if (TagIndex != 0) {

                if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

                    TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

                    if (TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) {

                        ComputedPseudoTagEntries[ TagIndex ] +=
                            VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT;
                    }

                } else if (TagIndex & HEAP_GLOBAL_TAG) {

                    //
                    //  Ignore these since they are global across more than
                    //  one heap.
                    //

                } else if (TagIndex < Heap->NextAvailableTagIndex) {

                    ComputedTagEntries[ TagIndex ] +=
                        VirtualAllocBlock->CommitSize >> HEAP_GRANULARITY_SHIFT;
                }
            }
        }

        if (VirtualAllocBlock->BusyBlock.Flags & HEAP_ENTRY_FILL_PATTERN) {

            if (!RtlpCheckBusyBlockTail( &VirtualAllocBlock->BusyBlock )) {

                return FALSE;
            }
        }

        Next = Next->Flink;
    }

    CountOfFreeBlocks = 0;
    TotalFreeSize = 0;

    for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

        Segment = Heap->Segments[ SegmentIndex ];

        if (Segment) {

            if (!RtlpValidateHeapSegment( Heap,
                                          Segment,
                                          SegmentIndex,
                                          &CountOfFreeBlocks,
                                          &TotalFreeSize,
                                          &BadAddress,
                                          ComputedTagEntries,
                                          ComputedPseudoTagEntries )) {

                goto errorExit;
            }
        }
    }

    BadAddress = Heap;

    if (NumberOfFreeListEntries != CountOfFreeBlocks) {

        HeapDebugPrint(( "Number of free blocks in arena (%ld) does not match number in the free lists (%ld)\n",
                         CountOfFreeBlocks,
                         NumberOfFreeListEntries ));

        goto errorExit;
    }

    if (Heap->TotalFreeSize != TotalFreeSize) {

        HeapDebugPrint(( "Total size of free blocks in arena (%ld) does not match number total in heap header (%ld)\n",
                         TotalFreeSize,
                         Heap->TotalFreeSize ));

        goto errorExit;
    }

    if (ComputedPseudoTagEntries != NULL) {

        PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;
        PHEAP_TAG_ENTRY TagEntries;
        USHORT TagIndex;

        PseudoTagEntries = Heap->PseudoTagEntries;

        if (PseudoTagEntries != NULL) {

            for (TagIndex=1; TagIndex<HEAP_NUMBER_OF_PSEUDO_TAG; TagIndex++) {

                PseudoTagEntries += 1;

                if (ComputedPseudoTagEntries[ TagIndex ] != PseudoTagEntries->Size) {

                    HeapDebugPrint(( "Pseudo Tag %04x size incorrect (%x != %x) %x\n",
                                     TagIndex,
                                     PseudoTagEntries->Size,
                                     ComputedPseudoTagEntries[ TagIndex ]
                                     &ComputedPseudoTagEntries[ TagIndex ] ));

                    goto errorExit;
                }
            }
        }

        TagEntries = Heap->TagEntries;

        if (TagEntries != NULL) {

            for (TagIndex=1; TagIndex<Heap->NextAvailableTagIndex; TagIndex++) {

                TagEntries += 1;

                if (ComputedTagEntries[ TagIndex ] != TagEntries->Size) {

                    HeapDebugPrint(( "Tag %04x (%ws) size incorrect (%x != %x) %x\n",
                                     TagIndex,
                                     TagEntries->TagName,
                                     TagEntries->Size,
                                     ComputedTagEntries[ TagIndex ],
                                     &ComputedTagEntries[ TagIndex ] ));

                    goto errorExit;
                }
            }
        }

        Size = 0;

        NtFreeVirtualMemory( &ComputedPseudoTagEntries,
                             &Size,
                             MEM_RELEASE );
    }

exit:

    return TRUE;

errorExit:

    HeapDebugBreak( BadAddress );

    if (ComputedPseudoTagEntries != NULL) {

        Size = 0;

        NtFreeVirtualMemory( &ComputedPseudoTagEntries,
                             &Size,
                             MEM_RELEASE );
    }

    return FALSE;

}



BOOLEAN
RtlDebugWalkHeap (
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN Result;

    //
    //  Assumed the caller has serialized via RtlLockHeap or their own locking mechanism.
    //

    Result = FALSE;

    try {

        if (RtlpCheckHeapSignature( Heap, "RtlWalkHeap" )) {

            Result = RtlpValidateHeap( Heap, FALSE );
        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        SET_LAST_STATUS( GetExceptionCode() );
    }

    return Result;
}



//
//  Declared in nturtl.h
//

NTSTATUS
RtlWalkHeap (
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    )

/*++

Routine Description:

    This routine is used to enumerate all the entries within a heap.  For each
    call it returns a new information in entry.

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Entry - Supplies storage for the entry information.  If the DataAddress field
        is null then the enumeration starts over from the beginning otherwise it
        resumes from where it left off

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    PHEAP_ENTRY CurrentBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;
    PLIST_ENTRY Next, Head;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

#if 0
    //
    //  Check if we should be using the guard page verion of heap
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapWalk( HeapHandle, Entry ));
                                    
#endif // 0

    //
    //  If this is the debug version of heap then validate the heap
    //  before we go on
    //

    if (DEBUG_HEAP( Heap->Flags )) {

        if (!RtlDebugWalkHeap( HeapHandle, Entry )) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    Status = STATUS_SUCCESS;

#ifndef NTOS_KERNEL_RUNTIME

    //
    //  If there is an active lookaside list then drain and remove it.
    //  By setting the lookaside field in the heap to null we guarantee
    //  that the call the free heap will not try and use the lookaside
    //  list logic.
    //
    //  We'll actually capture the lookaside pointer from the heap and
    //  only use the captured pointer.  This will take care of the
    //  condition where another walk or lock heap can cause us to check
    //  for a non null pointer and then have it become null when we read
    //  it again.  If it is non null to start with then even if the
    //  user walks or locks the heap via another thread the pointer to
    //  still valid here so we can still try and do a lookaside list pop.
    //

    {
        PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)Heap->Lookaside;

        if (Lookaside != NULL) {

            ULONG i;
            PVOID Block;

            Heap->Lookaside = NULL;

            for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                while ((Block = RtlpAllocateFromHeapLookaside(&(Lookaside[i]))) != NULL) {

                    RtlFreeHeap( HeapHandle, 0, Block );
                }
            }
        }
    }
    
#endif // NTOS_KERNEL_RUNTIME

    //
    //  Check if this is the first time we've been called to walk the heap
    //

    if (Entry->DataAddress == NULL) {

        //
        //  Start with the first segement in the heap
        //

        SegmentIndex = 0;

nextSegment:

        CurrentBlock = NULL;

        //
        //  Now find the next in use segment for the heap
        //

        Segment = NULL;

        while ((SegmentIndex < HEAP_MAXIMUM_SEGMENTS) &&
               ((Segment = Heap->Segments[ SegmentIndex ]) == NULL)) {

            SegmentIndex += 1;
        }

        //
        //  If there are no more valid segments then we'll try the big
        //  allocation
        //

        if (Segment == NULL) {

            Head = &Heap->VirtualAllocdBlocks;
            Next = Head->Flink;

            if (Next == Head) {

                Status = STATUS_NO_MORE_ENTRIES;

            } else {

                VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

                CurrentBlock = &VirtualAllocBlock->BusyBlock;
            }

        //
        //  Otherwise we'll grab information about the segment.  Note that
        //  the current block is still null so when we fall out of this
        //  block we'll return directly to our caller with this segment
        //  information
        //

        } else {

            Entry->DataAddress = Segment;

            Entry->DataSize = 0;

            Entry->OverheadBytes = sizeof( *Segment );

            Entry->Flags = RTL_HEAP_SEGMENT;

            Entry->SegmentIndex = SegmentIndex;

            Entry->Segment.CommittedSize = (Segment->NumberOfPages -
                                            Segment->NumberOfUnCommittedPages) * PAGE_SIZE;

            Entry->Segment.UnCommittedSize = Segment->NumberOfUnCommittedPages * PAGE_SIZE;

            Entry->Segment.FirstEntry = (Segment->FirstEntry->Flags & HEAP_ENTRY_BUSY) ?
                ((PHEAP_ENTRY)Segment->FirstEntry + 1) :
                (PHEAP_ENTRY)((PHEAP_FREE_ENTRY)Segment->FirstEntry + 1);

            Entry->Segment.LastEntry = Segment->LastValidEntry;
        }

    //
    //  This is not the first time through.  Check if last time we gave back
    //  an heap segement or an uncommitted range
    //

    } else if (Entry->Flags & (RTL_HEAP_SEGMENT | RTL_HEAP_UNCOMMITTED_RANGE)) {

        //
        //  Check that the segment index is still valid
        //

        if ((SegmentIndex = Entry->SegmentIndex) >= HEAP_MAXIMUM_SEGMENTS) {

            Status = STATUS_INVALID_ADDRESS;

            CurrentBlock = NULL;

        } else {

            //
            //  Check that the segment is still in use
            //

            Segment = Heap->Segments[ SegmentIndex ];

            if (Segment == NULL) {

                Status = STATUS_INVALID_ADDRESS;

                CurrentBlock = NULL;

            //
            //  The segment is still in use if what we returned last time
            //  as the segment header then this time we'll return the
            //  segments first entry
            //

            } else if (Entry->Flags & RTL_HEAP_SEGMENT) {

                CurrentBlock = (PHEAP_ENTRY)Segment->FirstEntry;

            //
            //  Otherwise what we returned last time as an uncommitted
            //  range so now we need to get the next block
            //

            } else {

                CurrentBlock = (PHEAP_ENTRY)((PCHAR)Entry->DataAddress + Entry->DataSize);

                //
                //  Check if we are beyond this segment and need to get the
                //  next one
                //

                if (CurrentBlock >= Segment->LastValidEntry) {

                    SegmentIndex += 1;

                    goto nextSegment;
                }
            }
        }

    //
    //  Otherwise this is not the first time through and last time we gave back a
    //  valid heap entry
    //

    } else {

        //
        //  Check if the last entry we gave back was in use
        //

        if (Entry->Flags & HEAP_ENTRY_BUSY) {

            //
            //  Get the last entry we returned
            //

            CurrentBlock = ((PHEAP_ENTRY)Entry->DataAddress - 1);

            //
            //  If the last entry was for a big allocation then
            //  get the next big block if there is one otherwise
            //  say there are no more entries
            //

            if (CurrentBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                Head = &Heap->VirtualAllocdBlocks;

                VirtualAllocBlock = CONTAINING_RECORD( CurrentBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                Next = VirtualAllocBlock->Entry.Flink;

                if (Next == Head) {

                    Status = STATUS_NO_MORE_ENTRIES;

                } else {

                    VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

                    CurrentBlock = &VirtualAllocBlock->BusyBlock;
                }

            //
            //  Our previous result is a busy normal block
            //

            } else {

                //
                //  Get the segment and make sure it it still valid and in use
                //
                //  **** this should also check that segment index is not
                //  **** greater than HEAP MAXIMUM SEGMENTS
                //

                Segment = Heap->Segments[ SegmentIndex = CurrentBlock->SegmentIndex ];

                if (Segment == NULL) {

                    Status = STATUS_INVALID_ADDRESS;

                    CurrentBlock = NULL;

                //
                //  The segment is still in use, check if what we returned
                //  previously was a last entry
                //

                } else if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

findUncommittedRange:

                    //
                    //  We are at a last entry so now if the segment is done
                    //  then go get another segment
                    //

                    CurrentBlock += CurrentBlock->Size;

                    if (CurrentBlock >= Segment->LastValidEntry) {

                        SegmentIndex += 1;

                        goto nextSegment;
                    }

                    //
                    //  Otherwise we will find the uncommitted range entry that
                    //  immediately follows this last entry
                    //

                    pp = &Segment->UnCommittedRanges;

                    while ((UnCommittedRange = *pp) && UnCommittedRange->Address != (ULONG_PTR)CurrentBlock ) {

                        pp = &UnCommittedRange->Next;
                    }

                    if (UnCommittedRange == NULL) {

                        Status = STATUS_INVALID_PARAMETER;

                    } else {

                        //
                        //  Now fill in the entry to denote that uncommitted
                        //  range information
                        //

                        Entry->DataAddress = (PVOID)UnCommittedRange->Address;

                        Entry->DataSize = UnCommittedRange->Size;

                        Entry->OverheadBytes = 0;

                        Entry->SegmentIndex = SegmentIndex;

                        Entry->Flags = RTL_HEAP_UNCOMMITTED_RANGE;
                    }

                    //
                    //  Null out the current block because we've just filled in
                    //  the entry
                    //

                    CurrentBlock = NULL;

                } else {

                    //
                    //  Otherwise the entry has a following entry so now
                    //  advance to the next entry
                    //

                    CurrentBlock += CurrentBlock->Size;
                }
            }

        //
        //  Otherwise the previous entry we returned is not in use
        //

        } else {

            //
            //  Get the last entry we returned
            //

            CurrentBlock = (PHEAP_ENTRY)((PHEAP_FREE_ENTRY)Entry->DataAddress - 1);

            //
            //  Get the segment and make sure it it still valid and in use
            //
            //  **** this should also check that segment index is not
            //  **** greater than HEAP MAXIMUM SEGMENTS
            //

            Segment = Heap->Segments[ SegmentIndex = CurrentBlock->SegmentIndex ];

            if (Segment == NULL) {

                Status = STATUS_INVALID_ADDRESS;

                CurrentBlock = NULL;

            //
            //  If the block is the last entry then go find the next uncommitted
            //  range or segment
            //

            } else if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                goto findUncommittedRange;

            //
            //  Otherwise we'll just move on to the next entry
            //

            } else {

                CurrentBlock += CurrentBlock->Size;
            }
        }
    }

    //
    //  At this point if current block is not null then we've found another
    //  entry to return.  We could also have found a segment or uncommitted
    //  range but those are handled separately above and keep current block
    //  null
    //

    if (CurrentBlock != NULL) {

        //
        //  Check if the block is in use
        //

        if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {

            //
            //  Fill in the entry field for this block
            //

            Entry->DataAddress = (CurrentBlock+1);

            if (CurrentBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                Entry->DataSize = RtlpGetSizeOfBigBlock( CurrentBlock );

                Entry->OverheadBytes = (UCHAR)( sizeof( *VirtualAllocBlock ) + CurrentBlock->Size);

                Entry->SegmentIndex = HEAP_MAXIMUM_SEGMENTS;

                Entry->Flags = RTL_HEAP_BUSY |  HEAP_ENTRY_VIRTUAL_ALLOC;

            } else {

                Entry->DataSize = (CurrentBlock->Size << HEAP_GRANULARITY_SHIFT) -
                                  CurrentBlock->UnusedBytes;

                Entry->OverheadBytes = CurrentBlock->UnusedBytes;

                Entry->SegmentIndex = CurrentBlock->SegmentIndex;

                Entry->Flags = RTL_HEAP_BUSY;
            }

            if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                ExtraStuff = RtlpGetExtraStuffPointer( CurrentBlock );

                Entry->Block.Settable = ExtraStuff->Settable;
#if i386

                Entry->Block.AllocatorBackTraceIndex = ExtraStuff->AllocatorBackTraceIndex;

#endif // i386

                if (!IS_HEAP_TAGGING_ENABLED()) {

                    Entry->Block.TagIndex = 0;

                } else {

                    Entry->Block.TagIndex = ExtraStuff->TagIndex;
                }

                Entry->Flags |= RTL_HEAP_SETTABLE_VALUE;

            } else {

                if (!IS_HEAP_TAGGING_ENABLED()) {

                    Entry->Block.TagIndex = 0;

                } else {

                    Entry->Block.TagIndex = CurrentBlock->SmallTagIndex;
                }
            }

            Entry->Flags |= CurrentBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS;

        //
        //  Otherwise the block is not in use
        //

        } else {

            Entry->DataAddress = ((PHEAP_FREE_ENTRY)CurrentBlock+1);

            Entry->DataSize = (CurrentBlock->Size << HEAP_GRANULARITY_SHIFT) -
                              sizeof( HEAP_FREE_ENTRY );

            Entry->OverheadBytes = sizeof( HEAP_FREE_ENTRY );

            Entry->SegmentIndex = CurrentBlock->SegmentIndex;

            Entry->Flags = 0;
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}



//
//  Declared in nturtl.h
//

BOOLEAN
RtlLockHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is used by lock access to a specific heap structure

Arguments:

    HeapHandle - Supplies a pointer to the heap being locked

Return Value:

    BOOLEAN - TRUE if the heap is now locked and FALSE otherwise (i.e.,
        the heap is ill-formed).  TRUE is returned even if the heap is
        not lockable.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;

    RTL_PAGED_CODE();

#if 0

    //
    //  Check for the heap protected by guard pages
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapLock( HeapHandle ));

#endif // 0

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    if (!RtlpCheckHeapSignature( Heap, "RtlLockHeap" )) {

        return FALSE;
    }

    //
    //  Lock the heap.  And disable the lookaside list by incrementing
    //  its lock count.
    //

    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {

        RtlAcquireLockRoutine( Heap->LockVariable );

#ifndef NTOS_KERNEL_RUNTIME
        Heap->LookasideLockCount += 1;
#endif // NTOS_KERNEL_RUNTIME
    }

    return TRUE;
}



//
//  Declared in nturtl.h
//

BOOLEAN
RtlUnlockHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is used to unlock access to a specific heap structure

Arguments:

    HeapHandle - Supplies a pointer to the heep being unlocked

Return Value:

    BOOLEAN - TRUE if the heap is now unlocked and FALSE otherwise (i.e.,
        the heap is ill-formed).  TRUE is also returned if the heap was
        never locked to begin with because it is not seralizable.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;

    RTL_PAGED_CODE();

#if 0

    //
    //  Check for the heap protected by guard pages
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapUnlock( HeapHandle ));

#endif // 0

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    if (!RtlpCheckHeapSignature( Heap, "RtlUnlockHeap" )) {

        return FALSE;
    }

    //
    //  Unlock the heap.  And enable the lookaside logic by decrementing
    //  its lock count
    //

    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {

#ifndef NTOS_KERNEL_RUNTIME
        Heap->LookasideLockCount -= 1;
#endif // NTOS_KERNEL_RUNTIME

        RtlReleaseLockRoutine( Heap->LockVariable );
    }

    return TRUE;
}



//
//  Declared in nturtl.h
//

BOOLEAN
RtlValidateHeap (
    PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine verifies the structure of a heap and/or heap block

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Flags - Supplies a set of flags used to augment those already
        enforced by the heap

    BaseAddress - Optionally supplies a pointer to the heap block
        that should be individually validated

Return Value:

    BOOLEAN - TRUE if the heap/block is okay and FALSE otherwise

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result;

    try {

        try {

#if 0
            //
            //  Check for the guard page version of heap
            //

            if ( IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle )) {

                Result = RtlpDebugPageHeapValidate( HeapHandle, Flags, BaseAddress );

            } else
            
#endif // 0

            {

#ifndef NTOS_KERNEL_RUNTIME

                //
                //  If there is an active lookaside list then drain and remove it.
                //  By setting the lookaside field in the heap to null we guarantee
                //  that the call the free heap will not try and use the lookaside
                //  list logic.
                //
                //  We'll actually capture the lookaside pointer from the heap and
                //  only use the captured pointer.  This will take care of the
                //  condition where another walk or lock heap can cause us to check
                //  for a non null pointer and then have it become null when we read
                //  it again.  If it is non null to start with then even if the
                //  user walks or locks the heap via another thread the pointer to
                //  still valid here so we can still try and do a lookaside list pop.
                //

                PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)Heap->Lookaside;

                if (Lookaside != NULL) {

                    ULONG i;
                    PVOID Block;

                    Heap->Lookaside = NULL;

                    for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                        while ((Block = RtlpAllocateFromHeapLookaside(&(Lookaside[i]))) != NULL) {

                            RtlFreeHeap( HeapHandle, 0, Block );
                        }
                    }
                }

#endif // NTOS_KERNEL_RUNTIME

                Result = FALSE;

                //
                //  Validate that HeapAddress points to a HEAP structure.
                //

                if (RtlpCheckHeapSignature( Heap, "RtlValidateHeap" )) {

                    Flags |= Heap->ForceFlags;

                    //
                    //  Lock the heap
                    //

                    if (!(Flags & HEAP_NO_SERIALIZE)) {

                        RtlAcquireLockRoutine( Heap->LockVariable );

                        LockAcquired = TRUE;
                    }

                    //
                    //  If the user did not supply a base address then verify
                    //  the complete heap otherwise just do a single heap
                    //  entry
                    //

                    if (BaseAddress == NULL) {

                        Result = RtlpValidateHeap( Heap, TRUE );

                    } else {

                        Result = RtlpValidateHeapEntry( Heap, (PHEAP_ENTRY)BaseAddress - 1, "RtlValidateHeap" );
                    }
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Result;
}



//
//  Declared in heappriv.h
//

PHEAP_FREE_ENTRY
RtlpCoalesceHeap (
    IN PHEAP Heap
    )

/*++

Routine Description:

    This routine scans through heap and coalesces its free blocks

Arguments:

    Heap - Supplies a pointer to the heap being modified

Return Value:

    PHEAP_FREE_ENTRY - returns a pointer to the largest free block
        in the heap

--*/

{
    SIZE_T OldFreeSize;
    SIZE_T FreeSize;
    ULONG n;
    PHEAP_FREE_ENTRY FreeBlock, LargestFreeBlock;
    PLIST_ENTRY FreeListHead, Next;

    RTL_PAGED_CODE();

    LargestFreeBlock = NULL;

    //
    //  For every free list in the heap, going from smallest to
    //  largest and skipping the zero index one we will
    //  scan the free list coalesceing the free blocks
    //

    FreeListHead = &Heap->FreeLists[ 1 ];

    n = HEAP_MAXIMUM_FREELISTS;

    while (n--) {

        //
        //  Scan the individual free list
        //

        Next = FreeListHead->Blink;

        while (FreeListHead != Next) {

            //
            //  Get a pointer to the current free list entry, and remember its
            //  next and size
            //

            FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

            Next = Next->Flink;
            OldFreeSize = FreeSize = FreeBlock->Size;

            //
            //  Coalesce the block
            //

            FreeBlock = RtlpCoalesceFreeBlocks( Heap,
                                                FreeBlock,
                                                &FreeSize,
                                                TRUE );

            //
            //  If the new free size is not equal to the old free size
            //  then we actually did some changes otherwise the coalesce
            //  calll was essentialy a noop
            //

            if (FreeSize != OldFreeSize) {

                //
                //  Check if we should decommit this block because it is too
                //  large and it is either at the beginning or end of a
                //  committed run.  Otherwise just insert the new sized
                //  block into its corresponding free list.  We'll hit this
                //  block again when we visit larger free lists.
                //

                if (FreeBlock->Size >= (PAGE_SIZE >> HEAP_GRANULARITY_SHIFT)

                        &&

                    (FreeBlock->PreviousSize == 0 ||
                     (FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY))) {

                    RtlpDeCommitFreeBlock( Heap, FreeBlock, FreeSize );

                } else {

                    RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );
                }

                Next = FreeListHead->Blink;

            } else {

                //
                //  Remember the largest free block we've found so far
                //

                if ((LargestFreeBlock == NULL) ||
                    (LargestFreeBlock->Size < FreeBlock->Size)) {

                    LargestFreeBlock = FreeBlock;
                }
            }
        }

        //
        //  Go to the next free list.  When we hit the largest dedicated
        //  size free list we'll fall back to the [0] index list
        //

        if (n == 1) {

            FreeListHead = &Heap->FreeLists[ 0 ];

        } else {

            FreeListHead++;
        }
    }

    //
    //  And return to our caller
    //

    return LargestFreeBlock;
}



SIZE_T
RtlDebugCompactHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    SIZE_T LargestFreeSize;

#if 0

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapCompact( HeapHandle, Flags ));

#endif // 0

    LargestFreeSize = 0;

    try {

        try {

            //
            //  Validate that HeapAddress points to a HEAP structure.
            //

            if (!RtlpCheckHeapSignature( Heap, "RtlCompactHeap" )) {

                LargestFreeSize = 0;
                leave;
            }

            Flags |= Heap->ForceFlags | HEAP_SKIP_VALIDATION_CHECKS;

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;

                Flags |= HEAP_NO_SERIALIZE;
            }

            RtlpValidateHeap( Heap, FALSE );

            LargestFreeSize = RtlCompactHeap( HeapHandle, Flags );

            RtlpValidateHeapHeaders( Heap, TRUE );

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return LargestFreeSize;
}



//
//  Declared in nturtl.h
//

SIZE_T
NTAPI
RtlCompactHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine compacts the specified heap by coalescing all the free block.
    It also determines the size of the largest available free block and
    returns its, in bytes, back to the caller.

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags used to augment those already
        enforced by the heap

Return Value:

    SIZE_T - Returns the size, in bytes, of the largest free block
        available in the heap

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_FREE_ENTRY FreeBlock;
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    SIZE_T LargestFreeSize;
    BOOLEAN LockAcquired = FALSE;

    //
    //  Augment the heap flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if this is a debug version of heap
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugCompactHeap( HeapHandle, Flags );
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        LargestFreeSize = 0;

        try {

            //
            //  Coalesce the heap into its largest free blocks possible
            //  and get the largest free block in the heap
            //

            FreeBlock = RtlpCoalesceHeap( (PHEAP)HeapHandle );

            //
            //  If there is a free block then compute its byte size
            //

            if (FreeBlock != NULL) {

                LargestFreeSize = FreeBlock->Size << HEAP_GRANULARITY_SHIFT;
            }

            //
            //  Scan every segment in the heap looking at its largest uncommitted
            //  range.  Remember the largest range if its bigger than anything
            //  we've found so far
            //

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                if (Segment && Segment->LargestUnCommittedRange > LargestFreeSize) {

                    LargestFreeSize = Segment->LargestUnCommittedRange;
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return the largest free size to our caller
    //

    return LargestFreeSize;
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\heappage.h ===
//
//  heappage.h
//

#ifndef _HEAP_PAGE_H_
#define _HEAP_PAGE_H_

//
//  #defining DEBUG_PAGE_HEAP will cause the page heap manager
//  to be compiled.  Only #define this flag if NOT kernel mode.
//  Probably want to define this just for checked-build (DBG).
//

#ifndef NTOS_KERNEL_RUNTIME
//    #if DBG
        #define DEBUG_PAGE_HEAP 1
//    #endif
#endif

#include "heappagi.h"

#ifndef DEBUG_PAGE_HEAP

//
//  These macro-based hooks should be defined to nothing so they
//  simply "go away" during compile if the debug heap manager is
//  not desired (retail builds).
//

#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) FALSE
#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )
#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )
#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )

#define HEAP_FLAG_PAGE_ALLOCS 0

#define RtlpDebugPageHeapValidate( HeapHandle, Flags, Address ) TRUE

#else // DEBUG_PAGE_HEAP

//
//  The following definitions and prototypes are the external interface
//  for hooking the debug heap manager in the retail heap manager.
//

#define HEAP_FLAG_PAGE_ALLOCS       0x01000000

#define HEAP_PROTECTION_ENABLED     0x02000000
#define HEAP_BREAK_WHEN_OUT_OF_VM   0x04000000
#define HEAP_NO_ALIGNMENT           0x08000000


#define IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle ) \
            (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS )


#define IF_DEBUG_PAGE_HEAP_THEN_RETURN( Handle, ReturnThis )                \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                return ReturnThis;                                          \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_CALL( Handle, CallThis )                    \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                CallThis;                                                   \
                return;                                                     \
                }                                                           \
            }


#define IF_DEBUG_PAGE_HEAP_THEN_BREAK( Handle, Text, ReturnThis )           \
            {                                                               \
            if ( IS_DEBUG_PAGE_HEAP_HANDLE( Handle ))                       \
                {                                                           \
                RtlpDebugPageHeapBreak( Text );                             \
                return ReturnThis;                                          \
                }                                                           \
            }


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG Flags,
    IN PVOID HeapBase,
    IN SIZE_T ReserveSize,
    IN SIZE_T CommitSize,
    IN PVOID Lock,
    IN PRTL_HEAP_PARAMETERS Parameters
    );

PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN SIZE_T Size
    );

PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    );

SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    );

ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    );

NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    );

BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    );

BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    );

BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    );

NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    );

NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    );

VOID
RtlpDebugPageHeapBreak(
    PCH Text
    );


#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\heappage.c ===
//
//  heappage.c
//
//  Implementation of NT RtlHeap family of APIs for debugging
//  applications with heap usage bugs.  Each allocation returned to
//  the calling app is placed at the end of a virtual page such that
//  the following virtual page is protected (ie, NO_ACCESS).
//  So, when the errant app attempts to reference or modify memory
//  beyond the allocated portion of a heap block, an access violation
//  is immediately caused.  This facilitates debugging the app
//  because the access violation occurs at the exact point in the
//  app where the heap corruption or abuse would occur.  Note that
//  significantly more memory (pagefile) is required to run an app
//  using this heap implementation as opposed to the retail heap
//  manager.
//
//  Author:  Tom McGuire (tommcg)
//    Date:  01/06/1995
//
//  Copyright (C) 1994-1996, Microsoft
//

#include "ntrtlp.h"
#include "heappage.h"       // external interface (hooks) to debug heap manager

int __cdecl sprintf(char *, const char *, ...);

//
//  Remainder of entire file is wrapped with #ifdef DEBUG_PAGE_HEAP so that
//  it will compile away to nothing if DEBUG_PAGE_HEAP is not defined in
//  heappage.h
//

#ifdef DEBUG_PAGE_HEAP

#if defined(_X86_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 8
#elif defined(_MIPS_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 8
#elif defined(_PPC_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x1000
    #endif
    #define USER_ALIGNMENT 8
#elif defined(_IA64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x2000
    #endif
    #define USER_ALIGNMENT 16
#elif defined(_AXP64_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x2000
    #endif
    #define USER_ALIGNMENT 16
#elif defined(_ALPHA_)
    #ifndef PAGE_SIZE
    #define PAGE_SIZE   0x2000
    #endif
    #define USER_ALIGNMENT 8
#else
    #error  // platform not defined
#endif


#define DPH_HEAP_ROOT_SIGNATURE  0xFFEEDDCC
#define FILL_BYTE                0xEE
#define HEAD_FILL_SIZE           0x10
#define RESERVE_SIZE             0x800000
#define VM_UNIT_SIZE             0x10000
#define POOL_SIZE                0x4000
#define INLINE                   __inline
#define LOCAL_FUNCTION           // static   // no coff symbols on static functions
#define MIN_FREE_LIST_LENGTH     8


#define ROUNDUP2( x, n ) ((( x ) + (( n ) - 1 )) & ~(( n ) - 1 ))

#if INTERNAL_DEBUG
    #define DEBUG_CODE( a ) a
#else
    #define DEBUG_CODE( a )
#endif

#define RETAIL_ASSERT( a ) ( (a) ? TRUE : \
            RtlpDebugPageHeapAssert( "PAGEHEAP: ASSERTION FAILED: (" #a ")\n" ))

#define DEBUG_ASSERT( a ) DEBUG_CODE( RETAIL_ASSERT( a ))

#define HEAP_HANDLE_FROM_ROOT( HeapRoot ) \
            ((PVOID)(((PCHAR)(HeapRoot)) - PAGE_SIZE ))

#define IF_GENERATE_EXCEPTION( Flags, Status ) {                \
            if (( Flags ) & HEAP_GENERATE_EXCEPTIONS )          \
                RtlpDebugPageHeapException((ULONG)(Status));    \
            }

#define OUT_OF_VM_BREAK( Flags, szText ) {                      \
            if (( Flags ) & HEAP_BREAK_WHEN_OUT_OF_VM )         \
                RtlpDebugPageHeapBreak(( szText ));             \
            }

#define ENQUEUE_HEAD( Node, Head, Tail ) {          \
            (Node)->pNextAlloc = (Head);            \
            if ((Head) == NULL )                    \
                (Tail) = (Node);                    \
            (Head) = (Node);                        \
            }

#define ENQUEUE_TAIL( Node, Head, Tail ) {          \
            if ((Tail) == NULL )                    \
                (Head) = (Node);                    \
            else                                    \
                (Tail)->pNextAlloc = (Node);        \
            (Tail) = (Node);                        \
            }

#define DEQUEUE_NODE( Node, Prev, Head, Tail ) {    \
            PVOID Next = (Node)->pNextAlloc;        \
            if ((Head) == (Node))                   \
                (Head) = Next;                      \
            if ((Tail) == (Node))                   \
                (Tail) = (Prev);                    \
            if ((Prev) != (NULL))                   \
                (Prev)->pNextAlloc = Next;          \
            }

#define PROTECT_HEAP_STRUCTURES( HeapRoot ) {                           \
            if ((HeapRoot)->HeapFlags & HEAP_PROTECTION_ENABLED )       \
                RtlpDebugPageHeapProtectStructures( (HeapRoot) );       \
            }

#define UNPROTECT_HEAP_STRUCTURES( HeapRoot ) {                         \
            if ((HeapRoot)->HeapFlags & HEAP_PROTECTION_ENABLED )       \
                RtlpDebugPageHeapUnProtectStructures( (HeapRoot) );     \
            }


BOOLEAN              RtlpDebugPageHeap;                         // exported via extern
BOOLEAN              RtlpDebugPageHeapListHasBeenInitialized;
RTL_CRITICAL_SECTION RtlpDebugPageHeapListCritSect;
PDPH_HEAP_ROOT       RtlpDebugPageHeapListHead;
PDPH_HEAP_ROOT       RtlpDebugPageHeapListTail;
ULONG                RtlpDebugPageHeapListCount;

//
// `RtlpDebugPageHeapGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation.
//


ULONG RtlpDebugPageHeapGlobalFlags =
    
    PAGE_HEAP_ENABLE_PAGE_HEAP       |
#if DBG
    PAGE_HEAP_COLLECT_STACK_TRACES   |
#endif
    0;

//
// The values below are taken into consideration if MinimizeMemoryImpact
// flag is used. They control how are we going to try and minimize the
// memory impact and how we decide which blocks will get allocated
// in the page heap.
//
// `MinimizeCriteria' gives the percentage of available memory (page file)
// out of total memory below which all alocations are done with the normal heap. 
// The valid value is in the range 0..100. A value of 0 will force all allocations
// in the page heap whereas a value of 100 will force all allocations in the
// normal heap.
//
// `VerifyProbability' specifies the probability that the allocation is made in
// the page heap. The valid value is in range 1..100. A value of 100 means all
// allocations are done in the page heap. A value of zero has a special meaning,
// namely we will allocate in the page heap only blocks with the size in range
// `RangeStart'..`RangeEnd'.
//

ULONG RtlpDebugPageHeapVerifyProbability = 25;
ULONG RtlpDebugPageHeapMinimizeCriteria = 50;
ULONG RtlpDebugPageHeapVerifyRangeStart;
ULONG RtlpDebugPageHeapVerifyRangeEnd;

//
// `PageHeapDebugLevel' controls debug messages in the code.
// The value should always be zero for the retail bits.
//

ULONG PageHeapDebugLevel;

//
//  Supporting functions
//

VOID
RtlpDebugPageHeapBreak(
    IN PCH Text
    )
    {
    DbgPrint( Text );
    DbgBreakPoint();
    }


LOCAL_FUNCTION
BOOLEAN
RtlpDebugPageHeapAssert(
    IN PCH Text
    )
    {
    RtlpDebugPageHeapBreak( Text );
    return FALSE;
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapEnterCritSect(
    IN PDPH_HEAP_ROOT HeapRoot,
    IN ULONG          Flags
    )
    {
    if ( Flags & HEAP_NO_SERIALIZE ) {

        if ( ! RtlTryEnterCriticalSection( HeapRoot->HeapCritSect )) {

            if ( HeapRoot->nRemoteLockAcquired == 0 ) {

                //
                //  Another thread owns the CritSect.  This is an application
                //  bug since multithreaded access to heap was attempted with
                //  the HEAP_NO_SERIALIZE flag specified.
                //

                RtlpDebugPageHeapBreak( "PAGEHEAP: Multithreaded access with HEAP_NO_SERIALIZE\n" );

                //
                //  In the interest of allowing the errant app to continue,
                //  we'll force serialization and continue.
                //

                HeapRoot->HeapFlags &= ~HEAP_NO_SERIALIZE;

                }

            RtlEnterCriticalSection( HeapRoot->HeapCritSect );

            }
        }
    else {
        RtlEnterCriticalSection( HeapRoot->HeapCritSect );
        }
    }


LOCAL_FUNCTION
INLINE
VOID
RtlpDebugPageHeapLeaveCritSect(
    IN PDPH_HEAP_ROOT HeapRoot
    )
    {
    RtlLeaveCriticalSection( HeapRoot->HeapCritSect );
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapException(
    IN ULONG ExceptionCode
    )
    {
    EXCEPTION_RECORD ER;

    ER.ExceptionCode    = ExceptionCode;
    ER.ExceptionFlags   = 0;
    ER.ExceptionRecord  = NULL;
    ER.ExceptionAddress = RtlpDebugPageHeapException;
    ER.NumberParameters = 0;
    RtlRaiseException( &ER );

    }


LOCAL_FUNCTION
PVOID
RtlpDebugPageHeapPointerFromHandle(
    IN PVOID HeapHandle
    )
    {
    try {
        if (((PHEAP)(HeapHandle))->ForceFlags & HEAP_FLAG_PAGE_ALLOCS ) {

            PDPH_HEAP_ROOT HeapRoot = (PVOID)(((PCHAR)(HeapHandle)) + PAGE_SIZE );

            if ( HeapRoot->Signature == DPH_HEAP_ROOT_SIGNATURE ) {
                return HeapRoot;
                }
            }
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        }

    RtlpDebugPageHeapBreak( "PAGEHEAP: Bad heap handle\n" );
    return NULL;
    }


LOCAL_FUNCTION
PCCH
RtlpDebugPageHeapProtectionText(
    IN     ULONG Access,
    IN OUT PCHAR Buffer
    )
    {
    switch ( Access ) {
        case PAGE_NOACCESS:          return "PAGE_NOACCESS";
        case PAGE_READONLY:          return "PAGE_READONLY";
        case PAGE_READWRITE:         return "PAGE_READWRITE";
        case PAGE_WRITECOPY:         return "PAGE_WRITECOPY";
        case PAGE_EXECUTE:           return "PAGE_EXECUTE";
        case PAGE_EXECUTE_READ:      return "PAGE_EXECUTE_READ";
        case PAGE_EXECUTE_READWRITE: return "PAGE_EXECUTE_READWRITE";
        case PAGE_EXECUTE_WRITECOPY: return "PAGE_EXECUTE_WRITECOPY";
        case PAGE_GUARD:             return "PAGE_GUARD";
        case 0:                      return "UNKNOWN";
        default:                     sprintf( Buffer, "0x%08X", Access );
                                     return Buffer;
        }
    }


LOCAL_FUNCTION
BOOLEAN
RtlpDebugPageHeapRobustProtectVM(
    IN PVOID   VirtualBase,
    IN SIZE_T  VirtualSize,
    IN ULONG   NewAccess,
    IN BOOLEAN Recursion
    )
    {
    PVOID  CopyOfVirtualBase = VirtualBase;
    SIZE_T CopyOfVirtualSize = VirtualSize;
    ULONG  OldAccess;
    NTSTATUS Status;

    Status = ZwProtectVirtualMemory(
                 NtCurrentProcess(),
                 &CopyOfVirtualBase,
                 &CopyOfVirtualSize,
                 NewAccess,
                 &OldAccess
                 );

    if ( NT_SUCCESS( Status ))
        return TRUE;

    if ( ! Recursion ) {

        //
        //  We failed to change the protection on a range of memory.
        //  This can happen if if the range of memory spans more than
        //  one adjancent blocks allocated by separate calls to
        //  ZwAllocateVirtualMemory.  It also seems fails occasionally
        //  for reasons unknown to me, but always when attempting to
        //  change the protection on more than one page in a single call.
        //  So, fall back to changing pages individually in this range.
        //  This should be rare, so it should not be a performance problem.
        //

        PCHAR VirtualExtent = (PCHAR)ROUNDUP2((ULONG_PTR)((PCHAR)VirtualBase + VirtualSize ), PAGE_SIZE );
        PCHAR VirtualPage   = (PCHAR)((ULONG_PTR)VirtualBase & ~( PAGE_SIZE - 1 ));
        BOOLEAN SuccessAll  = TRUE;
        BOOLEAN SuccessOne;

        while ( VirtualPage < VirtualExtent ) {

            SuccessOne = RtlpDebugPageHeapRobustProtectVM(
                             VirtualPage,
                             PAGE_SIZE,
                             NewAccess,
                             TRUE
                             );

            if ( ! SuccessOne ) {
                SuccessAll = FALSE;
                }

            VirtualPage += PAGE_SIZE;

            }

        return SuccessAll;      // TRUE if all succeeded, FALSE if any failed
        }

    else {

        MEMORY_BASIC_INFORMATION mbi;
        CHAR OldProtectionText[ 12 ];     // big enough for "0x12345678"
        CHAR NewProtectionText[ 12 ];     // big enough for "0x12345678"

        mbi.Protect = 0;    // in case ZwQueryVirtualMemory fails

        ZwQueryVirtualMemory(
            NtCurrentProcess(),
            VirtualBase,
            MemoryBasicInformation,
            &mbi,
            sizeof( mbi ),
            NULL
            );

        DbgPrint(
            "PAGEHEAP: Failed changing VM at %08X size 0x%X\n"
            "          from %s to %s (Status %08X)\n",
            VirtualBase,
            VirtualSize,
            RtlpDebugPageHeapProtectionText( mbi.Protect, OldProtectionText ),
            RtlpDebugPageHeapProtectionText( NewAccess, NewProtectionText ),
            Status
            );
        }

    return FALSE;
    }


LOCAL_FUNCTION
INLINE
BOOLEAN
RtlpDebugPageHeapProtectVM(
    IN PVOID   VirtualBase,
    IN SIZE_T  VirtualSize,
    IN ULONG   NewAccess
    )
    {
    return RtlpDebugPageHeapRobustProtectVM( VirtualBase, VirtualSize, NewAccess, FALSE );
    }


LOCAL_FUNCTION
INLINE
PVOID
RtlpDebugPageHeapAllocateVM(
    IN SIZE_T nSize
    )
    {
    NTSTATUS Status;
    PVOID pVirtual;

    pVirtual = NULL;

    Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                      &pVirtual,
                                      0,
                                      &nSize,
                                      MEM_COMMIT,
                                      PAGE_NOACCESS );

    return NT_SUCCESS( Status ) ? pVirtual : NULL;
    }


LOCAL_FUNCTION
INLINE
BOOLEAN
RtlpDebugPageHeapReleaseVM(
    IN PVOID pVirtual
    )

{
    SIZE_T nSize = 0;

    return NT_SUCCESS( ZwFreeVirtualMemory( NtCurrentProcess(),
                                            &pVirtual,
                                            &nSize,
                                            MEM_RELEASE ));
}


LOCAL_FUNCTION
PDPH_HEAP_ALLOCATION
RtlpDebugPageHeapTakeNodeFromUnusedList(
    IN PDPH_HEAP_ROOT pHeap
    )
    {
    PDPH_HEAP_ALLOCATION pNode = pHeap->pUnusedNodeListHead;
    PDPH_HEAP_ALLOCATION pPrev = NULL;

    //
    //  UnusedNodeList is LIFO with most recent entry at head of list.
    //

    if ( pNode ) {

        DEQUEUE_NODE( pNode, pPrev, pHeap->pUnusedNodeListHead, pHeap->pUnusedNodeListTail );

        --pHeap->nUnusedNodes;

        }

    return pNode;
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapReturnNodeToUnusedList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode
    )
    {

    //
    //  UnusedNodeList is LIFO with most recent entry at head of list.
    //

    ENQUEUE_HEAD( pNode, pHeap->pUnusedNodeListHead, pHeap->pUnusedNodeListTail );

    ++pHeap->nUnusedNodes;

    }


LOCAL_FUNCTION
PDPH_HEAP_ALLOCATION
RtlpDebugPageHeapFindBusyMem(
    IN  PDPH_HEAP_ROOT        pHeap,
    IN  PVOID                 pUserMem,
    OUT PDPH_HEAP_ALLOCATION *pPrevAlloc
    )
    {
    PDPH_HEAP_ALLOCATION pNode = pHeap->pBusyAllocationListHead;
    PDPH_HEAP_ALLOCATION pPrev = NULL;

    while ( pNode != NULL ) {

        if ( pNode->pUserAllocation == pUserMem ) {

            if ( pPrevAlloc )
                *pPrevAlloc = pPrev;

            return pNode;
            }

        pPrev = pNode;
        pNode = pNode->pNextAlloc;
        }

    return NULL;
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapRemoveFromAvailableList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode,
    IN PDPH_HEAP_ALLOCATION pPrev
    )
    {

    DEQUEUE_NODE( pNode, pPrev, pHeap->pAvailableAllocationListHead, pHeap->pAvailableAllocationListTail );

    pHeap->nAvailableAllocations--;
    pHeap->nAvailableAllocationBytesCommitted -= pNode->nVirtualBlockSize;

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapPlaceOnFreeList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pAlloc
    )
    {

    //
    //  FreeAllocationList is stored FIFO to enhance finding
    //  reference-after-freed bugs by keeping previously freed
    //  allocations on the free list as long as possible.
    //

    pAlloc->pNextAlloc = NULL;

    ENQUEUE_TAIL( pAlloc, pHeap->pFreeAllocationListHead, pHeap->pFreeAllocationListTail );

    pHeap->nFreeAllocations++;
    pHeap->nFreeAllocationBytesCommitted += pAlloc->nVirtualBlockSize;

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapRemoveFromFreeList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode,
    IN PDPH_HEAP_ALLOCATION pPrev
    )
    {

    DEQUEUE_NODE( pNode, pPrev, pHeap->pFreeAllocationListHead, pHeap->pFreeAllocationListTail );

    pHeap->nFreeAllocations--;
    pHeap->nFreeAllocationBytesCommitted -= pNode->nVirtualBlockSize;

#if DPH_CAPTURE_STACK_TRACE

    pNode->pStackTrace = NULL;

#endif // DPH_CAPTURE_STACK_TRACE

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapPlaceOnVirtualList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode
    )
    {

    //
    //  VirtualStorageList is LIFO so that releasing VM blocks will
    //  occur in exact reverse order.
    //

    ENQUEUE_HEAD( pNode, pHeap->pVirtualStorageListHead, pHeap->pVirtualStorageListTail );

    pHeap->nVirtualStorageRanges++;
    pHeap->nVirtualStorageBytes += pNode->nVirtualBlockSize;

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapPlaceOnBusyList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode
    )
    {

    //
    //  BusyAllocationList is LIFO to achieve better temporal locality
    //  of reference (older allocations are farther down the list).
    //

    ENQUEUE_HEAD( pNode, pHeap->pBusyAllocationListHead, pHeap->pBusyAllocationListTail );

    pHeap->nBusyAllocations++;
    pHeap->nBusyAllocationBytesCommitted  += pNode->nVirtualBlockSize;
    pHeap->nBusyAllocationBytesAccessible += pNode->nVirtualAccessSize;

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapRemoveFromBusyList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode,
    IN PDPH_HEAP_ALLOCATION pPrev
    )
    {

    DEQUEUE_NODE( pNode, pPrev, pHeap->pBusyAllocationListHead, pHeap->pBusyAllocationListTail );

    pHeap->nBusyAllocations--;
    pHeap->nBusyAllocationBytesCommitted  -= pNode->nVirtualBlockSize;
    pHeap->nBusyAllocationBytesAccessible -= pNode->nVirtualAccessSize;

    }


LOCAL_FUNCTION
PDPH_HEAP_ALLOCATION
RtlpDebugPageHeapSearchAvailableMemListForBestFit(
    IN  PDPH_HEAP_ROOT        pHeap,
    IN  SIZE_T                nSize,
    OUT PDPH_HEAP_ALLOCATION *pPrevAvailNode
    )
    {
    PDPH_HEAP_ALLOCATION pAvail, pFound, pAvailPrev, pFoundPrev;
    SIZE_T               nAvail, nFound;

    nFound     = 0x7FFFFFFF;
    pFound     = NULL;
    pFoundPrev = NULL;
    pAvailPrev = NULL;
    pAvail     = pHeap->pAvailableAllocationListHead;

    while (( pAvail != NULL ) && ( nFound > nSize )) {

        nAvail = pAvail->nVirtualBlockSize;

        if (( nAvail >= nSize ) && ( nAvail < nFound )) {
            nFound     = nAvail;
            pFound     = pAvail;
            pFoundPrev = pAvailPrev;
            }

        pAvailPrev = pAvail;
        pAvail     = pAvail->pNextAlloc;
        }

    *pPrevAvailNode = pFoundPrev;
    return pFound;
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapCoalesceNodeIntoAvailable(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode
    )
    {
    PDPH_HEAP_ALLOCATION pPrev    = NULL;
    PDPH_HEAP_ALLOCATION pNext    = pHeap->pAvailableAllocationListHead;
    PUCHAR               pVirtual = pNode->pVirtualBlock;
    SIZE_T               nVirtual = pNode->nVirtualBlockSize;

    pHeap->nAvailableAllocationBytesCommitted += nVirtual;
    pHeap->nAvailableAllocations++;

    //
    //  Walk list to insertion point.
    //

    while (( pNext ) && ( pNext->pVirtualBlock < pVirtual )) {
        pPrev = pNext;
        pNext = pNext->pNextAlloc;
        }

    if ( pPrev ) {

        if (( pPrev->pVirtualBlock + pPrev->nVirtualBlockSize ) == pVirtual ) {

            //
            //  pPrev and pNode are adjacent, so simply add size of
            //  pNode entry to pPrev entry.
            //

            pPrev->nVirtualBlockSize += nVirtual;

            RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pNode );

            pHeap->nAvailableAllocations--;

            pNode    = pPrev;
            pVirtual = pPrev->pVirtualBlock;
            nVirtual = pPrev->nVirtualBlockSize;

            }

        else {

            //
            //  pPrev and pNode are not adjacent, so insert the pNode
            //  block into the list after pPrev.
            //

            pNode->pNextAlloc = pPrev->pNextAlloc;
            pPrev->pNextAlloc = pNode;

            }
        }

    else {

        //
        //  pNode should be inserted at head of list.
        //

        pNode->pNextAlloc = pHeap->pAvailableAllocationListHead;
        pHeap->pAvailableAllocationListHead = pNode;

        }


    if ( pNext ) {

        if (( pVirtual + nVirtual ) == pNext->pVirtualBlock ) {

            //
            //  pNode and pNext are adjacent, so simply add size of
            //  pNext entry to pNode entry and remove pNext entry
            //  from the list.
            //

            pNode->nVirtualBlockSize += pNext->nVirtualBlockSize;

            pNode->pNextAlloc = pNext->pNextAlloc;

            if ( pHeap->pAvailableAllocationListTail == pNext )
                 pHeap->pAvailableAllocationListTail = pNode;

            RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pNext );

            pHeap->nAvailableAllocations--;

            }
        }

    else {

        //
        //  pNode is tail of list.
        //

        pHeap->pAvailableAllocationListTail = pNode;

        }
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapCoalesceFreeIntoAvailable(
    IN PDPH_HEAP_ROOT pHeap,
    IN ULONG          nLeaveOnFreeList
    )
    {
    PDPH_HEAP_ALLOCATION pNode = pHeap->pFreeAllocationListHead;
    SIZE_T               nFree = pHeap->nFreeAllocations;
    PDPH_HEAP_ALLOCATION pNext;

    DEBUG_ASSERT( nFree >= nLeaveOnFreeList );

    while (( pNode ) && ( nFree-- > nLeaveOnFreeList )) {

        pNext = pNode->pNextAlloc;  // preserve next pointer across shuffling

        RtlpDebugPageHeapRemoveFromFreeList( pHeap, pNode, NULL );

        RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pNode );

        pNode = pNext;

        }

    DEBUG_ASSERT(( nFree = (volatile SIZE_T)( pHeap->nFreeAllocations )) >= nLeaveOnFreeList );
    DEBUG_ASSERT(( pNode != NULL ) || ( nFree == 0 ));

    }


LOCAL_FUNCTION
BOOLEAN
RtlpDebugPageHeapGrowVirtual(
    IN PDPH_HEAP_ROOT pHeap,
    IN SIZE_T         nSize
    );


LOCAL_FUNCTION
PDPH_HEAP_ALLOCATION
RtlpDebugPageHeapFindAvailableMem(
    IN  PDPH_HEAP_ROOT        pHeap,
    IN  SIZE_T                nSize,
    OUT PDPH_HEAP_ALLOCATION *pPrevAvailNode,
    IN  BOOLEAN               bGrowVirtual
    )
    {
    PDPH_HEAP_ALLOCATION pAvail;
    ULONG                nLeaveOnFreeList;

    //
    //  First search existing AvailableList for a "best-fit" block
    //  (the smallest block that will satisfy the request).
    //

    pAvail = RtlpDebugPageHeapSearchAvailableMemListForBestFit(
                 pHeap,
                 nSize,
                 pPrevAvailNode
                 );

    while (( pAvail == NULL ) && ( pHeap->nFreeAllocations > MIN_FREE_LIST_LENGTH )) {

        //
        //  Failed to find sufficient memory on AvailableList.  Coalesce
        //  3/4 of the FreeList memory to the AvailableList and try again.
        //  Continue this until we have sufficient memory in AvailableList,
        //  or the FreeList length is reduced to MIN_FREE_LIST_LENGTH entries.
        //  We don't shrink the FreeList length below MIN_FREE_LIST_LENGTH
        //  entries to preserve the most recent MIN_FREE_LIST_LENGTH entries
        //  for reference-after-freed purposes.
        //

        nLeaveOnFreeList = pHeap->nFreeAllocations / 4;

        if ( nLeaveOnFreeList < MIN_FREE_LIST_LENGTH )
             nLeaveOnFreeList = MIN_FREE_LIST_LENGTH;

        RtlpDebugPageHeapCoalesceFreeIntoAvailable( pHeap, nLeaveOnFreeList );

        pAvail = RtlpDebugPageHeapSearchAvailableMemListForBestFit(
                     pHeap,
                     nSize,
                     pPrevAvailNode
                     );

        }


    if (( pAvail == NULL ) && ( bGrowVirtual )) {

        //
        //  After coalescing FreeList into AvailableList, still don't have
        //  enough memory (large enough block) to satisfy request, so we
        //  need to allocate more VM.
        //

        if ( RtlpDebugPageHeapGrowVirtual( pHeap, nSize )) {

            pAvail = RtlpDebugPageHeapSearchAvailableMemListForBestFit(
                         pHeap,
                         nSize,
                         pPrevAvailNode
                         );

            if ( pAvail == NULL ) {

                //
                //  Failed to satisfy request with more VM.  If remainder
                //  of free list combined with available list is larger
                //  than the request, we might still be able to satisfy
                //  the request by merging all of the free list onto the
                //  available list.  Note we lose our MIN_FREE_LIST_LENGTH
                //  reference-after-freed insurance in this case, but it
                //  is a rare case, and we'd prefer to satisfy the allocation.
                //

                if (( pHeap->nFreeAllocationBytesCommitted +
                      pHeap->nAvailableAllocationBytesCommitted ) >= nSize ) {

                    RtlpDebugPageHeapCoalesceFreeIntoAvailable( pHeap, 0 );

                    pAvail = RtlpDebugPageHeapSearchAvailableMemListForBestFit(
                                 pHeap,
                                 nSize,
                                 pPrevAvailNode
                                 );
                    }
                }
            }
        }

    return pAvail;
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapPlaceOnPoolList(
    IN PDPH_HEAP_ROOT       pHeap,
    IN PDPH_HEAP_ALLOCATION pNode
    )
    {

    //
    //  NodePoolList is FIFO.
    //

    pNode->pNextAlloc = NULL;

    ENQUEUE_TAIL( pNode, pHeap->pNodePoolListHead, pHeap->pNodePoolListTail );

    pHeap->nNodePoolBytes += pNode->nVirtualBlockSize;
    pHeap->nNodePools     += 1;

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapAddNewPool(
    IN PDPH_HEAP_ROOT pHeap,
    IN PVOID          pVirtual,
    IN SIZE_T         nSize,
    IN BOOLEAN        bAddToPoolList
    )
    {
    PDPH_HEAP_ALLOCATION pNode, pFirst;
    ULONG n, nCount;

    //
    //  Assume pVirtual points to committed block of nSize bytes.
    //

    pFirst = pVirtual;
    nCount = (ULONG)(nSize  / sizeof( DPH_HEAP_ALLOCATION ));

    for ( n = nCount - 1, pNode = pFirst; n > 0; pNode++, n-- )
        pNode->pNextAlloc = pNode + 1;

    pNode->pNextAlloc = NULL;

    //
    //  Now link this list into the tail of the UnusedNodeList
    //

    ENQUEUE_TAIL( pFirst, pHeap->pUnusedNodeListHead, pHeap->pUnusedNodeListTail );

    pHeap->pUnusedNodeListTail = pNode;

    pHeap->nUnusedNodes += nCount;

    if ( bAddToPoolList ) {

        //
        //  Now add an entry on the PoolList by taking a node from the
        //  UnusedNodeList, which should be guaranteed to be non-empty
        //  since we just added new nodes to it.
        //

        pNode = RtlpDebugPageHeapTakeNodeFromUnusedList( pHeap );

        DEBUG_ASSERT( pNode != NULL );

        pNode->pVirtualBlock     = pVirtual;
        pNode->nVirtualBlockSize = nSize;

        RtlpDebugPageHeapPlaceOnPoolList( pHeap, pNode );

        }

    }


LOCAL_FUNCTION
PDPH_HEAP_ALLOCATION
RtlpDebugPageHeapAllocateNode(
    IN PDPH_HEAP_ROOT pHeap
    )
    {
    PDPH_HEAP_ALLOCATION pNode, pPrev, pReturn;
    PUCHAR pVirtual;
    SIZE_T nVirtual;
    SIZE_T nRequest;

    DEBUG_ASSERT( ! pHeap->InsideAllocateNode );
    DEBUG_CODE( pHeap->InsideAllocateNode = TRUE );

    pReturn = NULL;

    if ( pHeap->pUnusedNodeListHead == NULL ) {

        //
        //  We're out of nodes -- allocate new node pool
        //  from AvailableList.  Set bGrowVirtual to FALSE
        //  since growing virtual will require new nodes, causing
        //  recursion.  Note that simply calling FindAvailableMem
        //  might return some nodes to the pUnusedNodeList, even if
        //  the call fails, so we'll check that the UnusedNodeList
        //  is still empty before we try to use or allocate more
        //  memory.
        //

        nRequest = POOL_SIZE;

        pNode = RtlpDebugPageHeapFindAvailableMem(
                    pHeap,
                    nRequest,
                    &pPrev,
                    FALSE
                    );

        if (( pHeap->pUnusedNodeListHead == NULL ) && ( pNode == NULL )) {

            //
            //  Reduce request size to PAGE_SIZE and see if
            //  we can find at least a page on the available
            //  list.
            //

            nRequest = PAGE_SIZE;

            pNode = RtlpDebugPageHeapFindAvailableMem(
                        pHeap,
                        nRequest,
                        &pPrev,
                        FALSE
                        );

            }

        if ( pHeap->pUnusedNodeListHead == NULL ) {

            if ( pNode == NULL ) {

                //
                //  Insufficient memory on Available list.  Try allocating a
                //  new virtual block.
                //

                nRequest = POOL_SIZE;
                nVirtual = RESERVE_SIZE;
                pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

                if ( pVirtual == NULL ) {

                    //
                    //  Unable to allocate full RESERVE_SIZE block,
                    //  so reduce request to single VM unit (64K)
                    //  and try again.
                    //

                    nVirtual = VM_UNIT_SIZE;
                    pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

                    if ( pVirtual == NULL ) {

                        //
                        //  Can't allocate any VM.
                        //

                        goto EXIT;
                        }
                    }
                }

            else {

                RtlpDebugPageHeapRemoveFromAvailableList( pHeap, pNode, pPrev );

                pVirtual = pNode->pVirtualBlock;
                nVirtual = pNode->nVirtualBlockSize;

                }

            //
            //  We now have allocated VM referenced by pVirtual,nVirtual.
            //  Make nRequest portion of VM accessible for new node pool.
            //

            if ( ! RtlpDebugPageHeapProtectVM( pVirtual, nRequest, PAGE_READWRITE )) {

                if ( pNode == NULL ) {
                    RtlpDebugPageHeapReleaseVM( pVirtual );
                    }
                else {
                    RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pNode );
                    }

                goto EXIT;
                }

            //
            //  Now we have accessible memory for new pool.  Add the
            //  new memory to the pool.  If the new memory came from
            //  AvailableList versus fresh VM, zero the memory first.
            //

            if ( pNode != NULL )
                RtlZeroMemory( pVirtual, nRequest );

            RtlpDebugPageHeapAddNewPool( pHeap, pVirtual, nRequest, TRUE );

            //
            //  If any memory remaining, put it on available list.
            //

            if ( pNode == NULL ) {

                //
                //  Memory came from new VM -- add appropriate list entries
                //  for new VM and add remainder of VM to free list.
                //

                pNode = RtlpDebugPageHeapTakeNodeFromUnusedList( pHeap );
                DEBUG_ASSERT( pNode != NULL );
                pNode->pVirtualBlock     = pVirtual;
                pNode->nVirtualBlockSize = nVirtual;
                RtlpDebugPageHeapPlaceOnVirtualList( pHeap, pNode );

                pNode = RtlpDebugPageHeapTakeNodeFromUnusedList( pHeap );
                DEBUG_ASSERT( pNode != NULL );
                pNode->pVirtualBlock     = pVirtual + nRequest;
                pNode->nVirtualBlockSize = nVirtual - nRequest;

                RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pNode );

                }

            else {

                if ( pNode->nVirtualBlockSize > nRequest ) {

                    pNode->pVirtualBlock     += nRequest;
                    pNode->nVirtualBlockSize -= nRequest;

                    RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pNode );
                    }

                else {

                    //
                    //  Used up entire available block -- return node to
                    //  unused list.
                    //

                    RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pNode );

                    }
                }
            }
        }

    pReturn = RtlpDebugPageHeapTakeNodeFromUnusedList( pHeap );
    DEBUG_ASSERT( pReturn != NULL );

EXIT:

    DEBUG_CODE( pHeap->InsideAllocateNode = FALSE );
    return pReturn;
    }


LOCAL_FUNCTION
BOOLEAN
RtlpDebugPageHeapGrowVirtual(
    IN PDPH_HEAP_ROOT pHeap,
    IN SIZE_T         nSize
    )
    {
    PDPH_HEAP_ALLOCATION pVirtualNode;
    PDPH_HEAP_ALLOCATION pAvailNode;
    PVOID  pVirtual;
    SIZE_T nVirtual;

    pVirtualNode = RtlpDebugPageHeapAllocateNode( pHeap );

    if ( pVirtualNode == NULL ) {
        return FALSE;
        }

    pAvailNode = RtlpDebugPageHeapAllocateNode( pHeap );

    if ( pAvailNode == NULL ) {
        RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pVirtualNode );
        return FALSE;
        }

    nSize    = ROUNDUP2( nSize, VM_UNIT_SIZE );
    nVirtual = ( nSize > RESERVE_SIZE ) ? nSize : RESERVE_SIZE;
    pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

    if (( pVirtual == NULL ) && ( nSize < RESERVE_SIZE )) {
        nVirtual = nSize;
        pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );
        }

    if ( pVirtual == NULL ) {
        RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pVirtualNode );
        RtlpDebugPageHeapReturnNodeToUnusedList( pHeap, pAvailNode );
        return FALSE;
        }

    pVirtualNode->pVirtualBlock     = pVirtual;
    pVirtualNode->nVirtualBlockSize = nVirtual;
    RtlpDebugPageHeapPlaceOnVirtualList( pHeap, pVirtualNode );

    pAvailNode->pVirtualBlock     = pVirtual;
    pAvailNode->nVirtualBlockSize = nVirtual;
    RtlpDebugPageHeapCoalesceNodeIntoAvailable( pHeap, pAvailNode );

    return TRUE;
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapProtectStructures(
    IN PDPH_HEAP_ROOT pHeap
    )
    {
    PDPH_HEAP_ALLOCATION pNode;

    //
    //  Assume CritSect is owned so we're the only thread twiddling
    //  the protection.
    //

    DEBUG_ASSERT( pHeap->HeapFlags & HEAP_PROTECTION_ENABLED );

    if ( --pHeap->nUnProtectionReferenceCount == 0 ) {

        pNode = pHeap->pNodePoolListHead;

        while ( pNode != NULL ) {

            RtlpDebugPageHeapProtectVM( pNode->pVirtualBlock,
                                        pNode->nVirtualBlockSize,
                                        PAGE_READONLY );

            pNode = pNode->pNextAlloc;

            }
        }
    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapUnProtectStructures(
    IN PDPH_HEAP_ROOT pHeap
    )
    {
    PDPH_HEAP_ALLOCATION pNode;

    DEBUG_ASSERT( pHeap->HeapFlags & HEAP_PROTECTION_ENABLED );

    if ( pHeap->nUnProtectionReferenceCount == 0 ) {

        pNode = pHeap->pNodePoolListHead;

        while ( pNode != NULL ) {

            RtlpDebugPageHeapProtectVM( pNode->pVirtualBlock,
                                        pNode->nVirtualBlockSize,
                                        PAGE_READWRITE );

            pNode = pNode->pNextAlloc;

            }
        }

    ++pHeap->nUnProtectionReferenceCount;

    }


LOCAL_FUNCTION
INLINE
PUCHAR
RtlpDebugPageHeapScanForFillCorruption(
    IN PUCHAR Address,
    IN UCHAR  ExpectedValue,
    IN SIZE_T Length
    )
    {
    PUCHAR End;

    for ( End = Address + Length; Address < End; Address++ ) {
        if ( *Address != ExpectedValue )
            return Address;
        }

    return NULL;
    }


LOCAL_FUNCTION
BOOLEAN
RtlpDebugPageHeapDetectFillCorruption(
    IN PDPH_HEAP_ALLOCATION pNode
    )
    {
    PUCHAR p;

    p = RtlpDebugPageHeapScanForFillCorruption(
            pNode->pUserAllocation + pNode->nUserRequestedSize,
            FILL_BYTE,
            pNode->nUserActualSize - pNode->nUserRequestedSize );

    if ( p != NULL ) {

        DbgPrint( "PAGEHEAP: Tail fill corruption detected:\n"
                  "          Allocation at  0x%08X\n"
                  "          Requested size 0x%08X\n"
                  "          Allocated size 0x%08X\n"
                  "          Corruption at  0x%08X\n",
                  pNode->pUserAllocation,
                  pNode->nUserRequestedSize,
                  pNode->nUserActualSize,
                  p );

        RtlpDebugPageHeapBreak( "" );
        return TRUE;
        }

    return FALSE;
    }


#if INTERNAL_DEBUG

LOCAL_FUNCTION
VOID
RtlpDebugPageHeapVerifyList(
    IN PDPH_HEAP_ALLOCATION pListHead,
    IN PDPH_HEAP_ALLOCATION pListTail,
    IN SIZE_T               nExpectedLength,
    IN SIZE_T               nExpectedVirtual,
    IN PCCH                 pListName
    )
    {
    PDPH_HEAP_ALLOCATION pPrev = NULL;
    PDPH_HEAP_ALLOCATION pNode = pListHead;
    PDPH_HEAP_ALLOCATION pTest = pListHead ? pListHead->pNextAlloc : NULL;
    ULONG                nNode = 0;
    SIZE_T               nSize = 0;

    while ( pNode ) {

        if ( pNode == pTest ) {
            DbgPrint( "PAGEHEAP: Internal %s list is circular\n", pListName );
            RtlpDebugPageHeapBreak( "" );
            return;
            }

        nNode++;
        nSize += pNode->nVirtualBlockSize;

        if ( pTest ) {
            pTest = pTest->pNextAlloc;
            if ( pTest ) {
                pTest = pTest->pNextAlloc;
                }
            }

        pPrev = pNode;
        pNode = pNode->pNextAlloc;

        }

    if ( pPrev != pListTail ) {
        DbgPrint( "PAGEHEAP: Internal %s list has incorrect tail pointer\n", pListName );
        RtlpDebugPageHeapBreak( "" );
        }

    if (( nExpectedLength != 0xFFFFFFFF ) && ( nExpectedLength != nNode )) {
        DbgPrint( "PAGEHEAP: Internal %s list has incorrect length\n", pListName );
        RtlpDebugPageHeapBreak( "" );
        }

    if (( nExpectedVirtual != 0xFFFFFFFF ) && ( nExpectedVirtual != nSize )) {
        DbgPrint( "PAGEHEAP: Internal %s list has incorrect virtual size\n", pListName );
        RtlpDebugPageHeapBreak( "" );
        }

    }


LOCAL_FUNCTION
VOID
RtlpDebugPageHeapVerifyIntegrity(
    IN PDPH_HEAP_ROOT pHeap
    )
    {

    RtlpDebugPageHeapVerifyList(
        pHeap->pVirtualStorageListHead,
        pHeap->pVirtualStorageListTail,
        pHeap->nVirtualStorageRanges,
        pHeap->nVirtualStorageBytes,
        "VIRTUAL"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pBusyAllocationListHead,
        pHeap->pBusyAllocationListTail,
        pHeap->nBusyAllocations,
        pHeap->nBusyAllocationBytesCommitted,
        "BUSY"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pFreeAllocationListHead,
        pHeap->pFreeAllocationListTail,
        pHeap->nFreeAllocations,
        pHeap->nFreeAllocationBytesCommitted,
        "FREE"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pAvailableAllocationListHead,
        pHeap->pAvailableAllocationListTail,
        pHeap->nAvailableAllocations,
        pHeap->nAvailableAllocationBytesCommitted,
        "AVAILABLE"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pUnusedNodeListHead,
        pHeap->pUnusedNodeListTail,
        pHeap->nUnusedNodes,
        0xFFFFFFFF,
        "FREENODE"
        );

    RtlpDebugPageHeapVerifyList(
        pHeap->pNodePoolListHead,
        pHeap->pNodePoolListTail,
        pHeap->nNodePools,
        pHeap->nNodePoolBytes,
        "NODEPOOL"
        );

    }

#endif // INTERNAL_DEBUG


#if DPH_CAPTURE_STACK_TRACE


VOID
RtlpDebugPageHeapRemoteThreadLock(
    IN PVOID HeapBaseAddress
    )
    {
    PDPH_HEAP_ROOT HeapRoot;
    LARGE_INTEGER  Delay;

    try {

        HeapRoot = HeapBaseAddress;

        if ( HeapRoot->Signature == DPH_HEAP_ROOT_SIGNATURE ) {

            RtlpDebugPageHeapEnterCritSect( HeapRoot, 0 );

            (volatile ULONG)( HeapRoot->nRemoteLockAcquired ) = 1;

            Delay.QuadPart = -1000000;  // 100ms, relative to now

            do  {
                ZwDelayExecution( FALSE, &Delay );
                }
            while ((volatile ULONG)( HeapRoot->nRemoteLockAcquired ) == 1 );

            RtlpDebugPageHeapLeaveCritSect( HeapRoot );

            }
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        }

    //
    //  Note that TerminateThread will not free thread's stack --
    //  that will be done by remote caller after thread wait is
    //  satisfied by this termination call.
    //

    ZwTerminateThread( NtCurrentThread(), 0 );
    }

//
//  Since RtlpDebugPageHeapRemoteThreadLock is not called from any code in
//  ntdll, the linker will discard it unless we create a reference to it.
//

PVOID RtlpDebugPageHeapRemoteThreadLockAddress = RtlpDebugPageHeapRemoteThreadLock;


LOCAL_FUNCTION
PDPH_STACK_TRACE_NODE
RtlpDebugPageHeapNewStackTraceStorage(
    IN PDPH_HEAP_ROOT HeapRoot,
    IN SIZE_T         Length
    )
    {
    PDPH_HEAP_ALLOCATION  pAvailNode, pPrevNode, pStackNode;
    PDPH_STACK_TRACE_NODE Return;
    PUCHAR                pVirtual;
    SIZE_T                nRequest;
    SIZE_T                Size;

    Size = sizeof( DPH_STACK_TRACE_NODE ) + ( Length * sizeof( PVOID ));

    if ( Size > HeapRoot->nStackTraceStorage ) {

        nRequest = POOL_SIZE;

        pAvailNode = RtlpDebugPageHeapFindAvailableMem(
                         HeapRoot,
                         nRequest,
                         &pPrevNode,
                         TRUE
                         );

        if ( pAvailNode == NULL ) {

            //
            //  Reduce request size to PAGE_SIZE and see if
            //  we can find at least a page on the available
            //  list.
            //

            nRequest = PAGE_SIZE;

            pAvailNode = RtlpDebugPageHeapFindAvailableMem(
                             HeapRoot,
                             nRequest,
                             &pPrevNode,
                             TRUE
                             );

            }

        if ( pAvailNode == NULL )
            return NULL;

        pVirtual = pAvailNode->pVirtualBlock;

        if ( ! RtlpDebugPageHeapProtectVM( pVirtual, nRequest, PAGE_READWRITE )) {
            return NULL;
            }

        //
        //  pAvailNode (still on avail list) points to block large enough
        //  to satisfy request, but it might be large enough to split
        //  into two blocks -- one for request, remainder leave on
        //  avail list.
        //

        if ( pAvailNode->nVirtualBlockSize > nRequest ) {

            //
            //  Adjust pVirtualBlock and nVirtualBlock size of existing
            //  node in avail list.  The node will still be in correct
            //  address space order on the avail list.  This saves having
            //  to remove and then re-add node to avail list.  Note since
            //  we're changing sizes directly, we need to adjust the
            //  avail list counters manually.
            //
            //  Note: since we're leaving at least one page on the
            //  available list, we are guaranteed that AllocateNode
            //  will not fail.
            //

            pAvailNode->pVirtualBlock                    += nRequest;
            pAvailNode->nVirtualBlockSize                -= nRequest;
            HeapRoot->nAvailableAllocationBytesCommitted -= nRequest;

            pStackNode = RtlpDebugPageHeapAllocateNode( HeapRoot );

            DEBUG_ASSERT( pStackNode != NULL );

            pStackNode->pVirtualBlock     = pVirtual;
            pStackNode->nVirtualBlockSize = nRequest;

            }

        else {

            //
            //  Entire avail block is needed, so simply remove it from avail list.
            //

            RtlpDebugPageHeapRemoveFromAvailableList( HeapRoot, pAvailNode, pPrevNode );

            pStackNode = pAvailNode;

            }

        HeapRoot->nStackTraceBytesWasted    += HeapRoot->nStackTraceStorage;
        HeapRoot->nStackTraceBytesCommitted += nRequest;

        //
        //  Note: we're wasting the remaining HeapRoot->nStackTraceStorage
        //  bytes here.
        //

        HeapRoot->pStackTraceStorage = pVirtual;
        HeapRoot->nStackTraceStorage = nRequest;

        RtlpDebugPageHeapPlaceOnPoolList( HeapRoot, pStackNode );

        }

    Return = (PVOID) HeapRoot->pStackTraceStorage;

    HeapRoot->pStackTraceStorage += Size;
    HeapRoot->nStackTraceStorage -= Size;
    HeapRoot->nStackTraceBNodes++;

    return Return;
    }


LOCAL_FUNCTION
PDPH_STACK_TRACE_NODE
RtlpDebugPageHeapFindOrAddStackTrace(
    IN PDPH_HEAP_ROOT HeapRoot,
    IN ULONG          HashValue,
    IN SIZE_T         Length,
    IN PVOID*         Address
    )
    {
    PDPH_STACK_TRACE_NODE Node;
    PDPH_STACK_TRACE_NODE NewNode;
    ULONG                 Depth;

    Node    = HeapRoot->pStackTraceRoot;        // assume non-NULL
    NewNode = NULL;
    Depth   = 0;

    for (;;) {

        Depth++;

        if ( Node->Hash > HashValue ) {         // go left
            if ( Node->Left ) {
                Node = Node->Left;
                }
            else {

                NewNode = RtlpDebugPageHeapNewStackTraceStorage(
                              HeapRoot,
                              Length
                              );

                Node->Left = NewNode;
                break;
                }
            }

        else if ( Node->Hash < HashValue ) {    // go right
            if ( Node->Right ) {
                Node = Node->Right;
                }
            else {

                NewNode = RtlpDebugPageHeapNewStackTraceStorage(
                              HeapRoot,
                              Length
                              );

                Node->Right = NewNode;
                break;
                }
            }
        else {  // ( Node->Hash == HashValue ), verify matching data or rehash

            if (( Node->Length == Length ) &&
                ( RtlCompareMemory( Node->Address, Address, Length ) == Length )) {

                //
                //  Complete match, return this Node.
                //

                return Node;
                }

            else {

                //
                //  Not a match, increment hash value by one and search again
                //  (slow linear-rehashing, but don't expect many collisions).
                //

                HashValue++;
                Node  = HeapRoot->pStackTraceRoot;
                Depth = 0;

                HeapRoot->nStackTraceBHashCollisions++;

                }
            }
        }

    if ( NewNode != NULL ) {

        NewNode->Left      = NULL;
        NewNode->Right     = NULL;
        NewNode->Hash      = HashValue;
        NewNode->Length    = Length;
        NewNode->BusyCount = 0;
        NewNode->BusyBytes = 0;

        RtlCopyMemory( NewNode->Address, Address, Length * sizeof( PVOID ));

        if ( ++Depth > HeapRoot->nStackTraceBDepth ) {
            HeapRoot->nStackTraceBDepth = Depth;
            }
        }

    return NewNode;
    }


#if (( i386 ) && ( FPO ))
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif

LOCAL_FUNCTION
UCHAR
RtlpDebugPageHeapCaptureStackTrace(
    IN  UCHAR  FramesToSkip,
    IN  UCHAR  FramesToCapture,
    OUT PVOID* TraceBuffer,
    OUT PULONG HashValue
    )
{
    ULONG Index;
    PVOID Callers [32];
    ULONG Depth;
    ULONG Result;
    ULONG Hash;

    //
    // Make sure output buffer is clean.
    //

    RtlZeroMemory( TraceBuffer, FramesToCapture * sizeof( PVOID ));
    
    //
    // Figure out what is the depth of the stack
    // we want to search.
    //

    Depth = FramesToCapture + FramesToSkip;

    if (Depth > 32) {
        Depth = 32;
    }
    
    //
    // Get the maximum possible stack trace.
    //

    Result = RtlWalkFrameChain (
        Callers,
        Depth,
        0);

    //
    // Move identified callers into the output buffer and compute
    // a simplistic hash value.
    //

    for (Index = FramesToSkip, Hash = 0; Index < Result; Index++) {
                    
        TraceBuffer[Index - FramesToSkip] = Callers[Index];
        Hash += PtrToUlong(TraceBuffer[Index]);
    }

    //
    // Set hash value and return number of callers identified.
    //

    *HashValue = Hash;

    if (Result > FramesToSkip) {
        return (UCHAR)(Result - FramesToSkip);
    }
    else {
        return 0;
    }

#if 0 //bugbug: silviuc: should delete this code.

    UCHAR FramesCaptured;

    RtlZeroMemory( TraceBuffer, FramesToCapture * sizeof( PVOID ));


    *HashValue = 0;

    try {

        FramesCaptured = (UCHAR) RtlCaptureStackBackTrace(
                                    (UCHAR)( FramesToSkip + 1 ),
                                    FramesToCapture,
                                    TraceBuffer,
                                    HashValue
                                    );

        //
        //  Sometimes the final frame is NULL: if so, we'll strip it
        //  for smaller storage.
        //

        if (( FramesCaptured ) && ( ! TraceBuffer[ FramesCaptured - 1 ] )) {
            --FramesCaptured;
            }

        }

    except( EXCEPTION_EXECUTE_HANDLER ) {

        FramesCaptured = 0;

        while (( FramesCaptured < FramesToCapture ) &&
               ( TraceBuffer[ FramesCaptured ] != NULL )) {

            FramesCaptured++;

            }
        }

    return FramesCaptured;
#endif
}


LOCAL_FUNCTION
PDPH_STACK_TRACE_NODE
RtlpDebugPageHeapCaptureAndStoreStackTrace(
    IN PDPH_HEAP_ROOT HeapRoot,
    IN UCHAR          FramesToSkip
    )
    {
    PVOID TraceBuffer[ DPH_MAX_STACK_LENGTH ];
    ULONG HashValue;
    ULONG FramesCaptured;

    FramesCaptured = RtlpDebugPageHeapCaptureStackTrace(
                         (UCHAR)( FramesToSkip + 1 ),
                         (UCHAR)( DPH_MAX_STACK_LENGTH ),
                         TraceBuffer,
                         &HashValue
                         );

    if ( FramesCaptured ) {

        return RtlpDebugPageHeapFindOrAddStackTrace(
                   HeapRoot,
                   HashValue,
                   FramesCaptured,
                   TraceBuffer
                   );
        }

    return NULL;

    }


#if (( i386 ) && ( FPO ))
#pragma optimize( "", on )      // restore original optimizations
#endif

#endif // DPH_CAPTURE_STACK_TRACE


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////



//
//  Here's where the exported interface functions are defined.
//

#if (( DPH_CAPTURE_STACK_TRACE ) && ( i386 ) && ( FPO ))
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif


PVOID
RtlpDebugPageHeapCreate(
    IN ULONG  Flags,
    IN PVOID  HeapBase    OPTIONAL,
    IN SIZE_T ReserveSize OPTIONAL,
    IN SIZE_T CommitSize  OPTIONAL,
    IN PVOID  Lock        OPTIONAL,
    IN PRTL_HEAP_PARAMETERS Parameters OPTIONAL
    )
    {
    SYSTEM_BASIC_INFORMATION SystemInfo;
    PDPH_HEAP_ALLOCATION     Node;
    PDPH_HEAP_ROOT           HeapRoot;
    PVOID                    HeapHandle;
    PUCHAR                   pVirtual;
    SIZE_T                   nVirtual;
    SIZE_T                   Size;
    NTSTATUS                 Status;

    //
    // Do we want a page heap for this heap? If we don't we return
    // null and the normal heap manager will continue by creating
    // a normal heap;
    //

    if (! (RtlpDebugPageHeapGlobalFlags & PAGE_HEAP_ENABLE_PAGE_HEAP)) {
        return NULL;
    }

    //
    // If `Parameters' is -1 then this is a recursive call to
    // RtlpDebugPageHeapCreate and we will return NULL so that
    // the normal heap manager will create a normal heap.
    // I agree this is a hack but we need this so that we maintain
    // a very loose dependency between the normal and page heap
    // manager.
    //

    if ((SIZE_T)Parameters == (SIZE_T)-1) {
        return NULL;                                        
    }

    //
    //  We don't handle heaps where HeapBase is already allocated
    //  from user or where Lock is provided by user.
    //

    DEBUG_ASSERT( HeapBase == NULL );
    DEBUG_ASSERT( Lock == NULL );

    if (( HeapBase != NULL ) || ( Lock != NULL ))
        return NULL;

    //
    //  Note that we simply ignore ReserveSize, CommitSize, and
    //  Parameters as we always have a growable heap with our
    //  own thresholds, etc.
    //

    ZwQuerySystemInformation( SystemBasicInformation,
                              &SystemInfo,
                              sizeof( SystemInfo ),
                              NULL );

    RETAIL_ASSERT( SystemInfo.PageSize == PAGE_SIZE );
    RETAIL_ASSERT( SystemInfo.AllocationGranularity == VM_UNIT_SIZE );
    DEBUG_ASSERT(( PAGE_SIZE + POOL_SIZE + PAGE_SIZE ) < VM_UNIT_SIZE );

    nVirtual = RESERVE_SIZE;
    pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

    if ( pVirtual == NULL ) {

        nVirtual = VM_UNIT_SIZE;
        pVirtual = RtlpDebugPageHeapAllocateVM( nVirtual );

        if ( pVirtual == NULL ) {
            OUT_OF_VM_BREAK( Flags, "PAGEHEAP: Insufficient memory to create heap\n" );
            IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
            return NULL;
            }
        }

    if ( ! RtlpDebugPageHeapProtectVM( pVirtual, PAGE_SIZE + POOL_SIZE + PAGE_SIZE, PAGE_READWRITE )) {
        RtlpDebugPageHeapReleaseVM( pVirtual );
        IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
        return NULL;
        }

    //
    //  Out of our initial allocation, the initial page is the fake
    //  retail HEAP structure.  The second page begins our DPH_HEAP_ROOT
    //  structure followed by (POOL_SIZE-sizeof(DPH_HEAP_ROOT)) bytes for
    //  the initial pool.  The next page contains out CRIT_SECT
    //  variable, which must always be READWRITE.  Beyond that, the
    //  remainder of the virtual allocation is placed on the available
    //  list.
    //
    //  |_____|___________________|_____|__ _ _ _ _ _ _ _ _ _ _ _ _ __|
    //
    //  ^pVirtual
    //
    //  ^FakeRetailHEAP
    //
    //        ^HeapRoot
    //
    //            ^InitialNodePool
    //
    //                            ^CRITICAL_SECTION
    //
    //                                  ^AvailableSpace
    //
    //
    //
    //  Our DPH_HEAP_ROOT structure starts at the page following the
    //  fake retail HEAP structure pointed to by the "heap handle".
    //  For the fake HEAP structure, we'll fill it with 0xEEEEEEEE
    //  except for the Heap->Flags and Heap->ForceFlags fields,
    //  which we must set to include our HEAP_FLAG_PAGE_ALLOCS flag,
    //  and then we'll make the whole page read-only.
    //

    RtlFillMemory( pVirtual, PAGE_SIZE, FILL_BYTE );

    ((PHEAP)pVirtual)->Flags      = Flags | HEAP_FLAG_PAGE_ALLOCS;
    ((PHEAP)pVirtual)->ForceFlags = Flags | HEAP_FLAG_PAGE_ALLOCS;

    if ( ! RtlpDebugPageHeapProtectVM( pVirtual, PAGE_SIZE, PAGE_READONLY )) {
        RtlpDebugPageHeapReleaseVM( pVirtual );
        IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
        return NULL;
        }

    HeapRoot = (PDPH_HEAP_ROOT)( pVirtual + PAGE_SIZE );

    HeapRoot->Signature    = DPH_HEAP_ROOT_SIGNATURE;
    HeapRoot->HeapFlags    = Flags;
    HeapRoot->HeapCritSect = (PVOID)((PCHAR)HeapRoot + POOL_SIZE );

    //
    // Copy the page heap global flags into per heap flags.
    //

    HeapRoot->ExtraFlags = RtlpDebugPageHeapGlobalFlags;

    //
    // We have to do a little bit of decoding for the GlobalFlags.
    // 
    // bugbug (silviuc) We need to validate the flags because some
    // bit combinations are not valid and might confuse the heap
    // manager.
    //

    if ((RtlpDebugPageHeapGlobalFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
        
        RtlpDebugPageHeapMinimizeCriteria = 
            (RtlpDebugPageHeapGlobalFlags >> 8) & 0x00FF;

        if ((RtlpDebugPageHeapGlobalFlags & PAGE_HEAP_VERIFY_RANDOMLY)) {

            RtlpDebugPageHeapVerifyProbability =
                RtlpDebugPageHeapGlobalFlags >> 24;
        }
        else {

            RtlpDebugPageHeapVerifyProbability = 0;

            RtlpDebugPageHeapVerifyRangeStart =
                RtlpDebugPageHeapGlobalFlags >> 24;
            
            RtlpDebugPageHeapVerifyRangeEnd =
                (RtlpDebugPageHeapGlobalFlags >> 16) & 0x00FF;
        }
    }

    //
    // Initialize the seed for the random generator used to decide
    // from where should we make allocations if minimize memory
    // impact flag is used. In case the query of performance counter
    // fails (used to give the "random" seed value of the generator)
    // we will default to ABCDDCBA as initial seed value.
    //

    {
        LARGE_INTEGER PerformanceCounter;

        PerformanceCounter.LowPart = 0xABCDDCBA;

        NtQueryPerformanceCounter (
            &PerformanceCounter,
            NULL);
        
        HeapRoot->Seed = PerformanceCounter.LowPart;
    }

    HeapRoot->Counter[0] = 0;
    HeapRoot->Counter[1] = 0;
    HeapRoot->Counter[2] = 0;
    HeapRoot->Counter[3] = 0;
    HeapRoot->Counter[4] = 0;

    //
    // Initialize the normal heap if the global flags combination
    // requires one.
    //

    if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {

        HeapRoot->NormalHeap = RtlCreateHeap( 

            Flags,
            HeapBase,
            ReserveSize,
            CommitSize,
            Lock,
            (PRTL_HEAP_PARAMETERS)-1 );

    }
    else {
        HeapRoot->NormalHeap = NULL;
    }

    RtlInitializeCriticalSection( HeapRoot->HeapCritSect );

    //
    //  On the page that contains our DPH_HEAP_ROOT structure, use
    //  the remaining memory beyond the DPH_HEAP_ROOT structure as
    //  pool for allocating heap nodes.
    //

    RtlpDebugPageHeapAddNewPool( HeapRoot,
                                 HeapRoot + 1,
                                 POOL_SIZE - sizeof( DPH_HEAP_ROOT ),
                                 FALSE
                               );

    //
    //  Make initial PoolList entry by taking a node from the
    //  UnusedNodeList, which should be guaranteed to be non-empty
    //  since we just added new nodes to it.
    //

    Node = RtlpDebugPageHeapAllocateNode( HeapRoot );
    DEBUG_ASSERT( Node != NULL );
    Node->pVirtualBlock     = (PVOID)HeapRoot;
    Node->nVirtualBlockSize = POOL_SIZE;
    RtlpDebugPageHeapPlaceOnPoolList( HeapRoot, Node );

    //
    //  Make VirtualStorageList entry for initial VM allocation
    //

    Node = RtlpDebugPageHeapAllocateNode( HeapRoot );
    DEBUG_ASSERT( Node != NULL );
    Node->pVirtualBlock     = pVirtual;
    Node->nVirtualBlockSize = nVirtual;
    RtlpDebugPageHeapPlaceOnVirtualList( HeapRoot, Node );

    //
    //  Make AvailableList entry containing remainder of initial VM
    //  and add to (create) the AvailableList.
    //

    Node = RtlpDebugPageHeapAllocateNode( HeapRoot );
    DEBUG_ASSERT( Node != NULL );
    Node->pVirtualBlock     = pVirtual + ( PAGE_SIZE + POOL_SIZE + PAGE_SIZE );
    Node->nVirtualBlockSize = nVirtual - ( PAGE_SIZE + POOL_SIZE + PAGE_SIZE );
    RtlpDebugPageHeapCoalesceNodeIntoAvailable( HeapRoot, Node );

#if DPH_CAPTURE_STACK_TRACE

    if (HeapRoot->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES) {
        
        HeapRoot->pStackTraceRoot = RtlpDebugPageHeapNewStackTraceStorage( HeapRoot, 0 );
        DEBUG_ASSERT( HeapRoot->pStackTraceRoot != NULL );
        HeapRoot->pStackTraceRoot->Left      = NULL;
        HeapRoot->pStackTraceRoot->Right     = NULL;
        HeapRoot->pStackTraceRoot->Hash      = 0;
        HeapRoot->pStackTraceRoot->BusyCount = 0;
        HeapRoot->pStackTraceRoot->BusyBytes = 0;
        HeapRoot->pStackTraceCreator = RtlpDebugPageHeapCaptureAndStoreStackTrace( HeapRoot, 1 );
    }
    else {

        HeapRoot->pStackTraceRoot = NULL;
        HeapRoot->pStackTraceCreator = NULL;
    }


#endif // DPH_CAPTURE_STACK_TRACE

    //
    //  Initialize heap internal structure protection.
    //

    HeapRoot->nUnProtectionReferenceCount = 1;          // initialize

    //
    //  If this is the first heap creation in this process, then we
    //  need to initialize the process heap list critical section.
    //

    if ( ! RtlpDebugPageHeapListHasBeenInitialized ) {
        RtlpDebugPageHeapListHasBeenInitialized = TRUE;
        RtlInitializeCriticalSection( &RtlpDebugPageHeapListCritSect );
        }

    //
    //  Add this heap entry to the process heap linked list.
    //

    RtlEnterCriticalSection( &RtlpDebugPageHeapListCritSect );

    if ( RtlpDebugPageHeapListHead == NULL ) {
        RtlpDebugPageHeapListHead = HeapRoot;
        RtlpDebugPageHeapListTail = HeapRoot;
        }
    else {
        HeapRoot->pPrevHeapRoot = RtlpDebugPageHeapListTail;
        UNPROTECT_HEAP_STRUCTURES(RtlpDebugPageHeapListTail);
        RtlpDebugPageHeapListTail->pNextHeapRoot = HeapRoot;
        PROTECT_HEAP_STRUCTURES(RtlpDebugPageHeapListTail);
        RtlpDebugPageHeapListTail                = HeapRoot;
        }

    PROTECT_HEAP_STRUCTURES( HeapRoot );                // now protected

    RtlpDebugPageHeapListCount++;

    RtlLeaveCriticalSection( &RtlpDebugPageHeapListCritSect );

    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));

    DbgPrint( "PAGEHEAP: process 0x%X created debug heap %p (flags 0x%X, %u, %u, %u, %u)\n",
              NtCurrentTeb()->ClientId.UniqueProcess,
              HEAP_HANDLE_FROM_ROOT( HeapRoot ),
              HeapRoot->ExtraFlags,
              RtlpDebugPageHeapMinimizeCriteria,
              RtlpDebugPageHeapVerifyProbability,
              RtlpDebugPageHeapVerifyRangeStart,
              RtlpDebugPageHeapVerifyRangeEnd);

    return HEAP_HANDLE_FROM_ROOT( HeapRoot );       // same as pVirtual

}


PVOID
RtlpDebugPageHeapAllocate(
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN SIZE_T Size
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION pAvailNode;
    PDPH_HEAP_ALLOCATION pPrevAvailNode;
    PDPH_HEAP_ALLOCATION pBusyNode;
    SIZE_T               nBytesAllocate;
    SIZE_T               nBytesAccess;
    SIZE_T               nActual;
    PVOID                pVirtual;
    PVOID                pReturn;
    PUCHAR               pBlockHeader;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return NULL;

    Flags |= HeapRoot->HeapFlags;

    //
    // Figure out if we need to minimize memory impact. This
    // might trigger an allocation in the normal heap.
    //

    if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
        
        SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
        NTSTATUS Status;
        ULONG Random;

        RETAIL_ASSERT (HeapRoot->NormalHeap);

        Status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &PerfInfo,
                    sizeof(PerfInfo),
                    NULL
                    );
        
        if(! NT_SUCCESS(Status)) {

            HeapRoot->Counter[0]++;

            return RtlAllocateHeap (

                HeapRoot->NormalHeap,
                Flags,
                Size); 
        }

        //
        // If less than `MinimizeCriteria'% of memory is available we will use
        // the normal heap.
        //

        {
            ULONG Percentage;

            if (PerfInfo.CommitLimit == 0) {

                //
                // Instead of getting divide by zero allocate in normal heap
                //

                Percentage = 100; 
            }
            else {

                //
                // Compute percentage of available memory.
                //

                Percentage = 100 - (((PerfInfo.CommittedPages) * 100)
                              / (PerfInfo.CommitLimit));

                if (PageHeapDebugLevel & 1) {
                    DbgPrint ("Percentage: %u (%08X, %08X) \n", 
                              Percentage, PerfInfo.CommittedPages, PerfInfo.CommitLimit);    
                }
            }

            if (Percentage <= RtlpDebugPageHeapMinimizeCriteria) {

                if (PageHeapDebugLevel & 1) {
                    DbgPrint ("Normal allocation forced by percentage of availmem \n");    
                }

                HeapRoot->Counter[1]++;

                return RtlAllocateHeap (

                    HeapRoot->NormalHeap,
                    Flags,
                    Size); 
            }
        }

        //
        // Generate a random number to decide if we need to
        // allocate from normal or verifier pool if the
        // `VerifyProbability' variable is 1..100.
        // If the value is zero we will make the decision from where
        // to allocate based on the size of the block requested.
        //

        if (RtlpDebugPageHeapVerifyProbability != 0) {
            
            RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
            UNPROTECT_HEAP_STRUCTURES( HeapRoot );
            Random = RtlRandom (& (HeapRoot->Seed));
            PROTECT_HEAP_STRUCTURES( HeapRoot );
            RtlpDebugPageHeapLeaveCritSect( HeapRoot );

            //
            // With a `VerifyProbability' probability we should allocate in page heap.
            //

            if (PageHeapDebugLevel & 1) {
                DbgPrint ("Random number %u\n", Random % 100);    
            }

            if ((Random % 100) >= RtlpDebugPageHeapVerifyProbability) {

                if (PageHeapDebugLevel & 1) {
                    DbgPrint ("Normal allocation due to random choice \n");    
                }
                
                HeapRoot->Counter[2]++;

                return RtlAllocateHeap (

                    HeapRoot->NormalHeap,
                    Flags,
                    Size); 
            }
        }
        else {

            if (! (Size >= RtlpDebugPageHeapVerifyRangeStart
                && Size <= RtlpDebugPageHeapVerifyRangeEnd)) {
                
                if (PageHeapDebugLevel & 1) {
                    DbgPrint ("Normal allocation due to the verified range \n");    
                }

                HeapRoot->Counter[3]++;

                return RtlAllocateHeap (

                    HeapRoot->NormalHeap,
                    Flags,
                    Size); 
            }
        }

        //
        // For all the other cases control will just flow and
        // we will allocate from page heap.
        //

        if (PageHeapDebugLevel & 1) {
            DbgPrint ("Verified allocation with minimize memory impact flag on \n");    
        }
        
        HeapRoot->Counter[4]++;
    }

    //
    //  Acquire the heap CritSect and unprotect the structures
    //

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    pReturn = NULL;

    //
    //  Validate requested size so we don't overflow
    //  while rounding up size computations.  We do this
    //  after we've acquired the critsect so we can still
    //  catch serialization problems.
    //

    if ( Size > 0x7FFF0000 ) {
        OUT_OF_VM_BREAK( Flags, "PAGEHEAP: Invalid allocation size\n" );
        goto EXIT;
        }

    //
    //  Determine number of pages needed for READWRITE portion
    //  of allocation and add an extra page for the NO_ACCESS
    //  memory beyond the READWRITE page(s).
    //

    nBytesAccess  = ROUNDUP2( Size, PAGE_SIZE );
    nBytesAllocate = nBytesAccess + PAGE_SIZE;

    //
    //  RtlpDebugPageHeapFindAvailableMem will first attempt to satisfy
    //  the request from memory on the Available list.  If that fails,
    //  it will coalesce some of the Free list memory into the Available
    //  list and try again.  If that still fails, new VM is allocated and
    //  added to the Available list.  If that fails, the function will
    //  finally give up and return NULL.
    //

    pAvailNode = RtlpDebugPageHeapFindAvailableMem(
                     HeapRoot,
                     nBytesAllocate,
                     &pPrevAvailNode,
                     TRUE
                     );

    if ( pAvailNode == NULL ) {
        OUT_OF_VM_BREAK( Flags, "PAGEHEAP: Unable to allocate virtual memory\n" );
        goto EXIT;
        }

    //
    //  Now can't call AllocateNode until pAvailNode is
    //  adjusted and/or removed from Avail list since AllocateNode
    //  might adjust the Avail list.
    //

    pVirtual = pAvailNode->pVirtualBlock;

    if ( nBytesAccess > 0 ) {

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
            
            if ( ! RtlpDebugPageHeapProtectVM( (PUCHAR)pVirtual + PAGE_SIZE, nBytesAccess, PAGE_READWRITE )) {
                goto EXIT;
            }
        }
        else {

            if ( ! RtlpDebugPageHeapProtectVM( pVirtual, nBytesAccess, PAGE_READWRITE )) {
                goto EXIT;
            }
        }
    }

    //
    //  pAvailNode (still on avail list) points to block large enough
    //  to satisfy request, but it might be large enough to split
    //  into two blocks -- one for request, remainder leave on
    //  avail list.
    //

    if ( pAvailNode->nVirtualBlockSize > nBytesAllocate ) {

        //
        //  Adjust pVirtualBlock and nVirtualBlock size of existing
        //  node in avail list.  The node will still be in correct
        //  address space order on the avail list.  This saves having
        //  to remove and then re-add node to avail list.  Note since
        //  we're changing sizes directly, we need to adjust the
        //  avail and busy list counters manually.
        //
        //  Note: since we're leaving at least one page on the
        //  available list, we are guaranteed that AllocateNode
        //  will not fail.
        //

        pAvailNode->pVirtualBlock                    += nBytesAllocate;
        pAvailNode->nVirtualBlockSize                -= nBytesAllocate;
        HeapRoot->nAvailableAllocationBytesCommitted -= nBytesAllocate;

        pBusyNode = RtlpDebugPageHeapAllocateNode( HeapRoot );

        DEBUG_ASSERT( pBusyNode != NULL );

        pBusyNode->pVirtualBlock     = pVirtual;
        pBusyNode->nVirtualBlockSize = nBytesAllocate;

        }

    else {

        //
        //  Entire avail block is needed, so simply remove it from avail list.
        //

        RtlpDebugPageHeapRemoveFromAvailableList( HeapRoot, pAvailNode, pPrevAvailNode );

        pBusyNode = pAvailNode;

        }

    //
    //  Now pBusyNode points to our committed virtual block.
    //

    if ( HeapRoot->HeapFlags & HEAP_NO_ALIGNMENT )
        nActual = Size;
    else
        nActual = ROUNDUP2( Size, USER_ALIGNMENT );

    pBusyNode->nVirtualAccessSize = nBytesAccess;
    pBusyNode->nUserRequestedSize = Size;
    pBusyNode->nUserActualSize    = nActual;
    
    if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
        
        pBusyNode->pUserAllocation    = pBusyNode->pVirtualBlock
                                      + PAGE_SIZE;
    }
    else {

        pBusyNode->pUserAllocation    = pBusyNode->pVirtualBlock
                                      + pBusyNode->nVirtualAccessSize
                                      - nActual;
    }
    
    pBusyNode->UserValue          = NULL;
    pBusyNode->UserFlags          = Flags & HEAP_SETTABLE_USER_FLAGS;

#if DPH_CAPTURE_STACK_TRACE

    //
    //  RtlpDebugPageHeapAllocate gets called from RtlDebugAllocateHeap,
    //  which gets called from RtlAllocateHeapSlowly, which gets called
    //  from RtlAllocateHeap.  To keep from wasting lots of stack trace
    //  storage, we'll skip the bottom 3 entries, leaving RtlAllocateHeap
    //  as the first recorded entry.
    //

    if (HeapRoot->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES) {
        pBusyNode->pStackTrace = RtlpDebugPageHeapCaptureAndStoreStackTrace( HeapRoot, 3 );
    }
    else {
        pBusyNode->pStackTrace = NULL;
    }

    if ( pBusyNode->pStackTrace ) {
         pBusyNode->pStackTrace->BusyCount += 1;
         pBusyNode->pStackTrace->BusyBytes += pBusyNode->nUserRequestedSize;
         }

#endif

    RtlpDebugPageHeapPlaceOnBusyList( HeapRoot, pBusyNode );

    pReturn = pBusyNode->pUserAllocation;

    //
    //  For requests the specify HEAP_ZERO_MEMORY, we'll fill the
    //  user-requested portion of the block with zeros, but the
    //  16 bytes (HEAD_FILL_SIZE) before the block and the odd
    //  alignment bytes beyond the requested size up to the end of
    //  the page are filled with 0xEEEEEEEE.  For requests that
    //  don't specify HEAP_ZERO_MEMORY, we fill the whole request
    //  including the 16 bytes before the block and the alignment
    //  bytes beyond the block with 0xEEEEEEEE.
    //

    if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
    
        if ( Flags & HEAP_ZERO_MEMORY ) {
            RtlZeroMemory( pBusyNode->pUserAllocation, Size );
        }
    }
    else {

        pBlockHeader = pBusyNode->pUserAllocation - HEAD_FILL_SIZE;

        if ( pBlockHeader < pBusyNode->pVirtualBlock )
            pBlockHeader = pBusyNode->pVirtualBlock;

        if ( Flags & HEAP_ZERO_MEMORY ) {

            RtlFillMemory( pBlockHeader,
                           pBusyNode->pUserAllocation - pBlockHeader,
                           FILL_BYTE );

            RtlZeroMemory( pBusyNode->pUserAllocation, Size );

            RtlFillMemory( pBusyNode->pUserAllocation + Size,
                           nActual - Size,
                           FILL_BYTE );
            }
        else {

            RtlFillMemory( pBlockHeader,
                           pBusyNode->pUserAllocation + nActual - pBlockHeader,
                           FILL_BYTE );

            }
    }

EXIT:

    PROTECT_HEAP_STRUCTURES( HeapRoot );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    if ( pReturn == NULL ) {
        IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
        }

    return pReturn;

    }


BOOLEAN
RtlpDebugPageHeapFree(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    )
    {

    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION Node, Prev;
    BOOLEAN              Success;
    PCH                  p;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    if ( Address == NULL )
        return TRUE;            // for C++ apps that delete NULL

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Success = FALSE;

    Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, &Prev );

    if ( Node == NULL ) {

        //
        // No wonder we did not find the block in the page heap
        // structures because the block was probably allocated
        // from the normal heap. Or there is a real bug.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
            
            RETAIL_ASSERT (HeapRoot->NormalHeap);
                                                        
            Success = RtlFreeHeap (

                HeapRoot->NormalHeap,
                Flags,
                Address);

            if (Success == FALSE) {
                RtlpDebugPageHeapBreak( "PAGEHEAP: Normal heap free operation failed\n" );
            }
        }
        else {
            RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to reference block which is not allocated\n" );
        }
    
        //
        // Jump to end where we have to release critical section and
        // protect back heap structures.
        //

        goto EXIT;
    }

    //
    //  If tail was allocated, make sure filler not overwritten
    //

    if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {
    
        if ( Node->nVirtualAccessSize > 0 ) {
            RtlpDebugPageHeapProtectVM( Node->pVirtualBlock + PAGE_SIZE,
                                        Node->nVirtualAccessSize,
                                        PAGE_NOACCESS );
            }
    }
    else {

        if ( Node->nUserActualSize > Node->nUserRequestedSize ) {
            RtlpDebugPageHeapDetectFillCorruption( Node );
            }

        if ( Node->nVirtualAccessSize > 0 ) {
            RtlpDebugPageHeapProtectVM( Node->pVirtualBlock,
                                        Node->nVirtualAccessSize,
                                        PAGE_NOACCESS );
            }
    }

    RtlpDebugPageHeapRemoveFromBusyList( HeapRoot, Node, Prev );

    RtlpDebugPageHeapPlaceOnFreeList( HeapRoot, Node );

#if DPH_CAPTURE_STACK_TRACE

    //
    //  RtlpDebugPageHeapFree gets called from RtlDebugFreeHeap, which
    //  gets called from RtlFreeHeapSlowly, which gets called from
    //  RtlFreeHeap.  To keep from wasting lots of stack trace storage,
    //  we'll skip the bottom 3 entries, leaving RtlFreeHeap as the
    //  first recorded entry.
    //

    if ( Node->pStackTrace ) {
         if ( Node->pStackTrace->BusyCount > 0 ) {
              Node->pStackTrace->BusyCount -= 1;
              Node->pStackTrace->BusyBytes -= Node->nUserRequestedSize;
              }
         }

    if (HeapRoot->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES) {
        Node->pStackTrace = RtlpDebugPageHeapCaptureAndStoreStackTrace( HeapRoot, 3 );
    }
    else {
        Node->pStackTrace = NULL;
    }

#endif

    Success = TRUE;

EXIT:

    PROTECT_HEAP_STRUCTURES( HeapRoot );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    if ( ! Success ) {
        IF_GENERATE_EXCEPTION( Flags, STATUS_ACCESS_VIOLATION );
        }

    return Success;
    }


PVOID
RtlpDebugPageHeapReAllocate(
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN PVOID  Address,
    IN SIZE_T Size
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION OldNode, OldPrev, NewNode;
    PVOID                NewAddress;
    PUCHAR               p;
    SIZE_T               CopyDataSize;
    ULONG                SaveFlags;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return NULL;

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    NewAddress = NULL;

    //
    //  Check Flags for non-moveable reallocation and fail it
    //  unconditionally.  Apps that specify this flag should be
    //  prepared to deal with failure anyway.
    //

    if ( Flags & HEAP_REALLOC_IN_PLACE_ONLY ) {
        goto EXIT;
        }

    //
    //  Validate requested size so we don't overflow
    //  while rounding up size computations.  We do this
    //  after we've acquired the critsect so we can still
    //  catch serialization problems.
    //

    if ( Size > 0x7FFF0000 ) {
        OUT_OF_VM_BREAK( Flags, "PAGEHEAP: Invalid allocation size\n" );
        goto EXIT;
        }

    OldNode = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, &OldPrev );

    if ( OldNode == NULL ) {

        //
        // No wonder we did not find the block in the page heap
        // structures because the block was probably allocated
        // from the normal heap. Or there is a real bug.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
                                                        
            RETAIL_ASSERT (HeapRoot->NormalHeap);

            NewAddress = RtlReAllocateHeap (

                HeapRoot->NormalHeap,
                Flags,
                Address,
                Size);

            if (NewAddress == NULL) {
                RtlpDebugPageHeapBreak( "PAGEHEAP: Normal heap realloc operation failed\n" );
            }
        }
        else {
            RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to reference block which is not allocated\n" );
        }
    
        //
        // Jump to end where we have to release critical section and
        // protect back heap structures.
        //

        goto EXIT;
    }

    //
    //  If tail was allocated, make sure filler not overwritten
    //

    if ((HeapRoot->ExtraFlags & PAGE_HEAP_CATCH_BACKWARD_OVERRUNS)) {

        // nothing
    }
    else {

        if ( OldNode->nUserActualSize > OldNode->nUserRequestedSize ) {
            RtlpDebugPageHeapDetectFillCorruption( OldNode );
        }
    }

    //
    //  Before allocating a new block, remove the old block from
    //  the busy list.  When we allocate the new block, the busy
    //  list pointers will change, possibly leaving our acquired
    //  Prev pointer invalid.
    //

    RtlpDebugPageHeapRemoveFromBusyList( HeapRoot, OldNode, OldPrev );

    //
    //  Allocate new memory for new requested size.  Use try/except
    //  to trap exception if Flags caused out-of-memory exception.
    //

    try {

        //
        // In case we have flags that can force allocations into normal heap
        // we have to temporarily disable them so that we force a
        // page heap allocation.
        //

        SaveFlags = 0;

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
                    
            SaveFlags = HeapRoot->ExtraFlags;
            HeapRoot->ExtraFlags = PAGE_HEAP_ENABLE_PAGE_HEAP;

            if ((SaveFlags & PAGE_HEAP_COLLECT_STACK_TRACES)) {
                HeapRoot->ExtraFlags |= PAGE_HEAP_COLLECT_STACK_TRACES;
            }
        }

        NewAddress = RtlpDebugPageHeapAllocate( HeapHandle, Flags, Size );
    
        if ((SaveFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
                    
            HeapRoot->ExtraFlags = SaveFlags;
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
    }

    if ( NewAddress ) {

        CopyDataSize = OldNode->nUserRequestedSize;

        if ( CopyDataSize > Size ) {
             CopyDataSize = Size;
             }

        if ( CopyDataSize > 0 ) {

            RtlCopyMemory(
                NewAddress,
                Address,
                CopyDataSize
                );
            }

        NewNode = RtlpDebugPageHeapFindBusyMem( HeapRoot, NewAddress, NULL );

        //
        // This block could not be in normal heap therefore from this
        // respect the call above should always succeed.
        //

        if (PageHeapDebugLevel & 2) {
            RETAIL_ASSERT (NewNode != NULL);
        }

        DEBUG_ASSERT( NewNode != NULL );

        NewNode->UserValue = OldNode->UserValue;
        NewNode->UserFlags = ( Flags & HEAP_SETTABLE_USER_FLAGS ) ?
                             ( Flags & HEAP_SETTABLE_USER_FLAGS ) :
                             OldNode->UserFlags;

        if ( OldNode->nVirtualAccessSize > 0 ) {
            RtlpDebugPageHeapProtectVM( OldNode->pVirtualBlock,
                                        OldNode->nVirtualAccessSize,
                                        PAGE_NOACCESS );
            }

        RtlpDebugPageHeapPlaceOnFreeList( HeapRoot, OldNode );

#if DPH_CAPTURE_STACK_TRACE

        //
        //  RtlpDebugPageHeapReAllocate gets called from RtlDebugReAllocateHeap,
        //  which gets called from RtlReAllocateHeap.  To keep from wasting
        //  lots of stack trace storage, we'll skip the bottom 2 entries,
        //  leaving RtlReAllocateHeap as the first recorded entry in the
        //  freed stack trace.
        //

        if ( OldNode->pStackTrace ) {
            if ( OldNode->pStackTrace->BusyCount > 0 ) {
                 OldNode->pStackTrace->BusyCount -= 1;
                 OldNode->pStackTrace->BusyBytes -= OldNode->nUserRequestedSize;
                 }
            }

        if (HeapRoot->ExtraFlags & PAGE_HEAP_COLLECT_STACK_TRACES) {
            OldNode->pStackTrace = RtlpDebugPageHeapCaptureAndStoreStackTrace( HeapRoot, 2 );
        }
        else {
            OldNode->pStackTrace = NULL;
        }

#endif
        }

    else {

        //
        //  Failed to allocate a new block.  Return old block to busy list.
        //

        RtlpDebugPageHeapPlaceOnBusyList( HeapRoot, OldNode );

        }

EXIT:

    PROTECT_HEAP_STRUCTURES( HeapRoot );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    if ( NewAddress == NULL ) {
        IF_GENERATE_EXCEPTION( Flags, STATUS_NO_MEMORY );
        }

    return NewAddress;
    }


#if (( DPH_CAPTURE_STACK_TRACE ) && ( i386 ) && ( FPO ))
#pragma optimize( "", on )      // restore original optimizations
#endif


PVOID
RtlpDebugPageHeapDestroy(
    IN PVOID HeapHandle
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ROOT       PrevHeapRoot;
    PDPH_HEAP_ROOT       NextHeapRoot;
    PDPH_HEAP_ALLOCATION Node;
    PDPH_HEAP_ALLOCATION Next;
    ULONG                Flags;
    PUCHAR               p;

    if ( HeapHandle == RtlProcessHeap() ) {
        RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to destroy process heap\n" );
        return NULL;
        }

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return NULL;

    Flags = HeapRoot->HeapFlags | HEAP_NO_SERIALIZE;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    //
    //  Walk all busy allocations and check for tail fill corruption
    //

    Node = HeapRoot->pBusyAllocationListHead;

    while ( Node ) {

        if ( Node->nUserActualSize > Node->nUserRequestedSize ) {
            RtlpDebugPageHeapDetectFillCorruption( Node );
            }

        Node = Node->pNextAlloc;
        }

    //
    //  Remove this heap entry from the process heap linked list.
    //

    RtlEnterCriticalSection( &RtlpDebugPageHeapListCritSect );

    if ( HeapRoot->pPrevHeapRoot ) {
         HeapRoot->pPrevHeapRoot->pNextHeapRoot = HeapRoot->pNextHeapRoot;
         }
    else {
         RtlpDebugPageHeapListHead = HeapRoot->pNextHeapRoot;
         }

    if ( HeapRoot->pNextHeapRoot ) {
         HeapRoot->pNextHeapRoot->pPrevHeapRoot = HeapRoot->pPrevHeapRoot;
         }
    else {
         RtlpDebugPageHeapListTail = HeapRoot->pPrevHeapRoot;
         }

    RtlpDebugPageHeapListCount--;

    RtlLeaveCriticalSection( &RtlpDebugPageHeapListCritSect );


    //
    //  Must release critical section before deleting it; otherwise,
    //  checked build Teb->CountOfOwnedCriticalSections gets out of sync.
    //

    RtlLeaveCriticalSection( HeapRoot->HeapCritSect );
    RtlDeleteCriticalSection( HeapRoot->HeapCritSect );

    //
    //  This is weird.  A virtual block might contain storage for
    //  one of the nodes necessary to walk this list.  In fact,
    //  we're guaranteed that the root node contains at least one
    //  virtual alloc node.
    //
    //  Each time we alloc new VM, we make that the head of the
    //  of the VM list, like a LIFO structure.  I think we're ok
    //  because no VM list node should be on a subsequently alloc'd
    //  VM -- only a VM list entry might be on its own memory (as
    //  is the case for the root node).  We read pNode->pNextAlloc
    //  before releasing the VM in case pNode existed on that VM.
    //  I think this is safe -- as long as the VM list is LIFO and
    //  we don't do any list reorganization.
    //

    Node = HeapRoot->pVirtualStorageListHead;

    while ( Node ) {
        Next = Node->pNextAlloc;
        if ( ! RtlpDebugPageHeapReleaseVM( Node->pVirtualBlock )) {
            RtlpDebugPageHeapBreak( "PAGEHEAP: Unable to release virtual memory\n" );
            }
        Node = Next;
        }

    //
    //  That's it.  All the VM, including the root node, should now
    //  be released.  RtlDestroyHeap always returns NULL.
    //

    return NULL;

    }


SIZE_T
RtlpDebugPageHeapSize(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION Node;
    SIZE_T               Size;

    Size = 0xFFFFFFFF;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL ) {
        return Size;
        }

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL );

    if ( Node == NULL ) {

        //
        // No wonder we did not find the block in the page heap
        // structures because the block was probably allocated
        // from the normal heap. Or there is a real bug.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
                                                        
            RETAIL_ASSERT (HeapRoot->NormalHeap);

            Size = RtlSizeHeap (

                HeapRoot->NormalHeap,
                Flags,
                Address);

            // bugbug: should we use -1?
            if (Size == 0xFFFFFFFF) {
                RtlpDebugPageHeapBreak( "PAGEHEAP: Normal heap size operation failed\n" );
            }
        }
        else {
            RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to reference block which is not allocated\n" );
        }
    
        //
        // Jump to end where we have to release critical section and
        // protect back heap structures.
        //

        goto EXIT;
    }
    else {
        Size = Node->nUserRequestedSize;
    }

EXIT:
    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    // bugbug: should we use -1?
    if ( Size == 0xFFFFFFFF ) {
        IF_GENERATE_EXCEPTION( Flags, STATUS_ACCESS_VIOLATION );
        }

    return Size;
    }


ULONG
RtlpDebugPageHeapGetProcessHeaps(
    ULONG NumberOfHeaps,
    PVOID *ProcessHeaps
    )
    {
    PDPH_HEAP_ROOT HeapRoot;
    ULONG          Count;

    //
    //  Although we'd expect GetProcessHeaps never to be called
    //  before at least the very first heap creation, we should
    //  still be safe and initialize the critical section if
    //  necessary.
    //

    if ( ! RtlpDebugPageHeapListHasBeenInitialized ) {
        RtlpDebugPageHeapListHasBeenInitialized = TRUE;
        RtlInitializeCriticalSection( &RtlpDebugPageHeapListCritSect );
        }

    RtlEnterCriticalSection( &RtlpDebugPageHeapListCritSect );

    if ( RtlpDebugPageHeapListCount <= NumberOfHeaps ) {

        for ( HeapRoot  = RtlpDebugPageHeapListHead, Count = 0;
              HeapRoot != NULL;
              HeapRoot  = HeapRoot->pNextHeapRoot, Count++ ) {

            *ProcessHeaps++ = HEAP_HANDLE_FROM_ROOT( HeapRoot );
            }

        if ( Count != RtlpDebugPageHeapListCount ) {
            RtlpDebugPageHeapBreak( "PAGEHEAP: BUG: process heap list count wrong\n" );
            }

        }
    else {

        //
        //  User's buffer is too small.  Return number of entries
        //  necessary for subsequent call to succeed.  Buffer
        //  remains untouched.
        //

        Count = RtlpDebugPageHeapListCount;

        }

    RtlLeaveCriticalSection( &RtlpDebugPageHeapListCritSect );

    return Count;
    }


ULONG
RtlpDebugPageHeapCompact(
    IN PVOID HeapHandle,
    IN ULONG Flags
    )
    {
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return 0;

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );

    //
    //  Don't do anything, but we did want to acquire the critsect
    //  in case this was called with HEAP_NO_SERIALIZE while another
    //  thread is in the heap code.
    //

    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return 0;

    }



BOOLEAN
RtlpDebugPageHeapValidate(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION Node;
    BOOLEAN Result = FALSE;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    DEBUG_CODE( RtlpDebugPageHeapVerifyIntegrity( HeapRoot ));
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Node = Address ? RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL ) : NULL;

    if (Node == NULL) {
        
        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {
                                                        
            RETAIL_ASSERT (HeapRoot->NormalHeap);

            Result = RtlValidateHeap (

                HeapRoot->NormalHeap,
                Flags,
                Address);
        }
    }

    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    if (Address) {
        if (Node) {
            return TRUE;
        }
        else {
            return Result;
        }
    }
    else {
        return TRUE;
    }
}


NTSTATUS
RtlpDebugPageHeapWalk(
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    )
    {
    return STATUS_NOT_IMPLEMENTED;
    }


BOOLEAN
RtlpDebugPageHeapLock(
    IN PVOID HeapHandle
    )
    {
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, HeapRoot->HeapFlags );

    return TRUE;
    }


BOOLEAN
RtlpDebugPageHeapUnlock(
    IN PVOID HeapHandle
    )
    {
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return TRUE;
    }


BOOLEAN
RtlpDebugPageHeapSetUserValue(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN PVOID UserValue
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION Node;
    BOOLEAN              Success;

    Success = FALSE;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return Success;

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL );

    if ( Node == NULL ) {

        //
        // If we cannot find the node in page heap structures it might be
        // because it has been allocated from normal heap.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {

            Success = RtlSetUserValueHeap (
                HeapRoot->NormalHeap,
                Flags,
                Address,
                UserValue);

            goto EXIT;
        }
        else {

            RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to reference block which is not allocated\n" );
        }
    }
    else {
        Node->UserValue = UserValue;
        Success = TRUE;
        }

    EXIT:
    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return Success;
    }


BOOLEAN
RtlpDebugPageHeapGetUserInfo(
    IN  PVOID  HeapHandle,
    IN  ULONG  Flags,
    IN  PVOID  Address,
    OUT PVOID* UserValue,
    OUT PULONG UserFlags
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION Node;
    BOOLEAN              Success;

    Success = FALSE;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return Success;

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL );

    if ( Node == NULL ) {

        //
        // If we cannot find the node in page heap structures it might be
        // because it has been allocated from normal heap.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {

            Success = RtlGetUserInfoHeap (

                HeapRoot->NormalHeap,
                Flags,
                Address,
                UserValue,
                UserFlags);

            goto EXIT;
        }
        else {

            RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to reference block which is not allocated\n" );
        }
    }
    else {
        if ( UserValue != NULL )
            *UserValue = Node->UserValue;
        if ( UserFlags != NULL )
            *UserFlags = Node->UserFlags;
        Success = TRUE;
        }

    EXIT:
    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return Success;
    }


BOOLEAN
RtlpDebugPageHeapSetUserFlags(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Address,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    )
    {
    PDPH_HEAP_ROOT       HeapRoot;
    PDPH_HEAP_ALLOCATION Node;
    BOOLEAN              Success;

    Success = FALSE;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return Success;

    Flags |= HeapRoot->HeapFlags;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, Flags );
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Node = RtlpDebugPageHeapFindBusyMem( HeapRoot, Address, NULL );

    if ( Node == NULL ) {
        
        //
        // If we cannot find the node in page heap structures it might be
        // because it has been allocated from normal heap.
        //

        if ((HeapRoot->ExtraFlags & PAGE_HEAP_MINIMIZE_MEMORY_IMPACT)) {

            Success = RtlSetUserFlagsHeap (

                HeapRoot->NormalHeap,
                Flags,
                Address,
                UserFlagsReset,
                UserFlagsSet);

            goto EXIT;
        }
        else {

            RtlpDebugPageHeapBreak( "PAGEHEAP: Attempt to reference block which is not allocated\n" );
        }
    }
    else {
        Node->UserFlags &= ~( UserFlagsReset );
        Node->UserFlags |=    UserFlagsSet;
        Success = TRUE;
        }

    EXIT:
    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return Success;
    }


BOOLEAN
RtlpDebugPageHeapSerialize(
    IN PVOID HeapHandle
    )
    {
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    RtlpDebugPageHeapEnterCritSect( HeapRoot, 0 );
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    HeapRoot->HeapFlags &= ~HEAP_NO_SERIALIZE;

    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return TRUE;
    }


NTSTATUS
RtlpDebugPageHeapExtend(
    IN PVOID  HeapHandle,
    IN ULONG  Flags,
    IN PVOID  Base,
    IN SIZE_T Size
    )
    {
    return STATUS_SUCCESS;
    }


NTSTATUS
RtlpDebugPageHeapZero(
    IN PVOID HeapHandle,
    IN ULONG Flags
    )
    {
    return STATUS_SUCCESS;
    }


NTSTATUS
RtlpDebugPageHeapReset(
    IN PVOID HeapHandle,
    IN ULONG Flags
    )
    {
    return STATUS_SUCCESS;
    }


NTSTATUS
RtlpDebugPageHeapUsage(
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    )
    {
    PDPH_HEAP_ROOT HeapRoot;

    //
    //  Partial implementation since this information is kind of meaningless.
    //

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return STATUS_INVALID_PARAMETER;

    if ( Usage->Length != sizeof( RTL_HEAP_USAGE ))
        return STATUS_INFO_LENGTH_MISMATCH;

    memset( Usage, 0, sizeof( RTL_HEAP_USAGE ));
    Usage->Length = sizeof( RTL_HEAP_USAGE );

    RtlpDebugPageHeapEnterCritSect( HeapRoot, 0 );
    UNPROTECT_HEAP_STRUCTURES( HeapRoot );

    Usage->BytesAllocated       = HeapRoot->nBusyAllocationBytesAccessible;
    Usage->BytesCommitted       = HeapRoot->nVirtualStorageBytes;
    Usage->BytesReserved        = HeapRoot->nVirtualStorageBytes;
    Usage->BytesReservedMaximum = HeapRoot->nVirtualStorageBytes;

    PROTECT_HEAP_STRUCTURES( HeapRoot );
    RtlpDebugPageHeapLeaveCritSect( HeapRoot );

    return STATUS_SUCCESS;
    }


BOOLEAN
RtlpDebugPageHeapIsLocked(
    IN PVOID HeapHandle
    )
    {
    PDPH_HEAP_ROOT HeapRoot;

    HeapRoot = RtlpDebugPageHeapPointerFromHandle( HeapHandle );
    if ( HeapRoot == NULL )
        return FALSE;

    if ( RtlTryEnterCriticalSection( HeapRoot->HeapCritSect )) {
        RtlLeaveCriticalSection( HeapRoot->HeapCritSect );
        return FALSE;
        }
    else {
        return TRUE;
        }
    }


#endif // DEBUG_PAGE_HEAP

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\heappriv.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heappriv.h

Abstract:

    Private include file used by heap allocator (heap.c, heapdll.c and
    heapdbg.c)

Author:

    Steve Wood (stevewo) 25-Oct-1994

Revision History:

--*/

#ifndef _RTL_HEAP_PRIVATE_
#define _RTL_HEAP_PRIVATE_

#include "heappage.h"

//
//  Disable FPO optimization so even retail builds get somewhat reasonable
//  stack backtraces
//

#if i386
// #pragma optimize("y",off)
#endif

#if DBG
#define HEAPASSERT(exp) if (!(exp)) RtlAssert( #exp, __FILE__, __LINE__, NULL )
#else
#define HEAPASSERT(exp)
#endif

//
//  This variable contains the fill pattern used for heap tail checking
//

UCHAR CheckHeapFillPattern[ CHECK_HEAP_TAIL_SIZE ];


//
//  Here are the locking routines for the heap (kernel and user)
//

//
//  User mode heap uses the critical section package for locking
//

#define RtlInitializeLockRoutine(L) (RtlInitializeCriticalSection((PRTL_CRITICAL_SECTION)(L)), STATUS_SUCCESS)
#define RtlAcquireLockRoutine(L)    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)(L))
#define RtlReleaseLockRoutine(L)    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)(L))
#define RtlDeleteLockRoutine(L)     RtlDeleteCriticalSection((PRTL_CRITICAL_SECTION)(L))
#define RtlOkayToLockRoutine(L)     NtdllOkayToLockRoutine((PVOID)(L))


//
//  Here are some debugging macros for the heap
//

#ifdef NTOS_KERNEL_RUNTIME

#define HEAP_DEBUG_FLAGS   0
#define DEBUG_HEAP(F)      FALSE
#define SET_LAST_STATUS(S) NOTHING;

#else // #ifdef NTOS_KERNEL_ROUTINE

#define HEAP_DEBUG_FLAGS   (HEAP_VALIDATE_PARAMETERS_ENABLED | \
                            HEAP_VALIDATE_ALL_ENABLED        | \
                            HEAP_CAPTURE_STACK_BACKTRACES    | \
                            HEAP_CREATE_ENABLE_TRACING       | \
                            HEAP_FLAG_PAGE_ALLOCS)
#define DEBUG_HEAP(F)      ((F & HEAP_DEBUG_FLAGS) && !(F & HEAP_SKIP_VALIDATION_CHECKS))
#define SET_LAST_STATUS(S) {NtCurrentTeb()->LastErrorValue = RtlNtStatusToDosError( NtCurrentTeb()->LastStatusValue = (ULONG)(S) );}

#endif // #ifdef NTOS_KERNEL_RUNTIME


//
//  Here are the macros used for debug printing and breakpoints
//

#if DBG

#ifdef NTOS_KERNEL_RUNTIME

#define HeapDebugPrint( _x_ ) {DbgPrint _x_;}

#define HeapDebugBreak( _x_ ) {if (KdDebuggerEnabled) DbgBreakPoint();}

#else // #ifdef NTOS_KERNEL_ROUTINE

#define HeapDebugPrint( _x_ )                                   \
{                                                               \
    PLIST_ENTRY _Module;                                        \
    PLDR_DATA_TABLE_ENTRY _Entry;                               \
                                                                \
    _Module = NtCurrentPeb()->Ldr->InLoadOrderModuleList.Flink; \
    _Entry = CONTAINING_RECORD( _Module,                        \
                                LDR_DATA_TABLE_ENTRY,           \
                                InLoadOrderLinks);              \
    DbgPrint("HEAP[%wZ]: ", &_Entry->BaseDllName);              \
    DbgPrint _x_;                                               \
}

#define HeapDebugBreak( _x_ )                    \
{                                                \
    VOID RtlpBreakPointHeap( PVOID BadAddress ); \
                                                 \
    RtlpBreakPointHeap( (_x_) );                 \
}

#endif // #ifdef NTOS_KERNEL_RUNTIME

#else  // DBG

#define HeapDebugPrint( _x_ )

#define HeapDebugBreak( _x_ )

#endif // DBG


//
//  Implemented in heap.c
//

BOOLEAN
RtlpInitializeHeapSegment (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN UCHAR SegmentIndex,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UnCommittedAddress,
    IN PVOID CommitLimitAddress
    );

PHEAP_FREE_ENTRY
RtlpCoalesceFreeBlocks (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN OUT PSIZE_T FreeSize,
    IN BOOLEAN RemoveFromFreeList
    );

VOID
RtlpDeCommitFreeBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN SIZE_T FreeSize
    );

VOID
RtlpInsertFreeBlock (
    IN PHEAP Heap,
    IN PHEAP_FREE_ENTRY FreeBlock,
    IN SIZE_T FreeSize
    );

PHEAP_FREE_ENTRY
RtlpFindAndCommitPages (
    IN PHEAP Heap,
    IN PHEAP_SEGMENT Segment,
    IN OUT PSIZE_T Size,
    IN PVOID AddressWanted OPTIONAL
    );

PVOID
RtlAllocateHeapSlowly (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN SIZE_T Size
    );

BOOLEAN
RtlFreeHeapSlowly (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    );

SIZE_T
RtlpGetSizeOfBigBlock (
    IN PHEAP_ENTRY BusyBlock
    );

PHEAP_ENTRY_EXTRA
RtlpGetExtraStuffPointer (
    PHEAP_ENTRY BusyBlock
    );

BOOLEAN
RtlpCheckBusyBlockTail (
    IN PHEAP_ENTRY BusyBlock
    );


//
//  Implemented in heapdll.c
//

VOID
RtlpAddHeapToProcessList (
    IN PHEAP Heap
    );

VOID
RtlpRemoveHeapFromProcessList (
    IN PHEAP Heap
    );

PHEAP_FREE_ENTRY
RtlpCoalesceHeap (
    IN PHEAP Heap
    );

BOOLEAN
RtlpCheckHeapSignature (
    IN PHEAP Heap,
    IN PCHAR Caller
    );


//
//  Implemented in heapdbg.c
//

BOOLEAN
RtlpValidateHeapEntry (
    IN PHEAP Heap,
    IN PHEAP_ENTRY BusyBlock,
    IN PCHAR Reason
    );

BOOLEAN
RtlpValidateHeap (
    IN PHEAP Heap,
    IN BOOLEAN AlwaysValidate
    );

VOID
RtlpUpdateHeapListIndex (
    USHORT OldIndex,
    USHORT NewIndex
    );

BOOLEAN
RtlpValidateHeapHeaders(
    IN PHEAP Heap,
    IN BOOLEAN Recompute
    );


//
//  Macro for setting a bit in the freelist vector to indicate entries are
//  present.
//

#define SET_FREELIST_BIT( H, FB )                                     \
{                                                                     \
    ULONG _Index_;                                                    \
    ULONG _Bit_;                                                      \
                                                                      \
    HEAPASSERT((FB)->Size < HEAP_MAXIMUM_FREELISTS);                  \
                                                                      \
    _Index_ = (FB)->Size >> 3;                                        \
    _Bit_ = (1 << ((FB)->Size & 7));                                  \
                                                                      \
    HEAPASSERT(((H)->u.FreeListsInUseBytes[ _Index_ ] & _Bit_) == 0); \
                                                                      \
    (H)->u.FreeListsInUseBytes[ _Index_ ] |= _Bit_;                   \
}

//
//  Macro for clearing a bit in the freelist vector to indicate entries are
//  not present.
//

#define CLEAR_FREELIST_BIT( H, FB )                            \
{                                                              \
    ULONG _Index_;                                             \
    ULONG _Bit_;                                               \
                                                               \
    HEAPASSERT((FB)->Size < HEAP_MAXIMUM_FREELISTS);           \
                                                               \
    _Index_ = (FB)->Size >> 3;                                 \
    _Bit_ = (1 << ((FB)->Size & 7));                           \
                                                               \
    HEAPASSERT((H)->u.FreeListsInUseBytes[ _Index_ ] & _Bit_); \
    HEAPASSERT(IsListEmpty(&(H)->FreeLists[ (FB)->Size ]));    \
                                                               \
    (H)->u.FreeListsInUseBytes[ _Index_ ] ^= _Bit_;            \
}


//
//  This macro inserts a free block into the appropriate free list including
//  the [0] index list with entry filling if necessary
//
#if DBG

#define RtlpInsertFreeBlockDirect( H, FB, SIZE )                          \
{                                                                         \
    PLIST_ENTRY _HEAD, _NEXT;                                             \
    PHEAP_FREE_ENTRY _FB1;                                                \
                                                                          \
    HEAPASSERT((FB)->Size == (SIZE));                                     \
    (FB)->Flags &= ~(HEAP_ENTRY_FILL_PATTERN |                            \
                     HEAP_ENTRY_EXTRA_PRESENT |                           \
                     HEAP_ENTRY_BUSY);                                    \
                                                                          \
    if ((H)->Flags & HEAP_FREE_CHECKING_ENABLED) {                        \
                                                                          \
        RtlFillMemoryUlong( (PCHAR)((FB) + 1),                            \
                            ((SIZE) << HEAP_GRANULARITY_SHIFT) -          \
                                sizeof( *(FB) ),                          \
                            FREE_HEAP_FILL );                             \
                                                                          \
        (FB)->Flags |= HEAP_ENTRY_FILL_PATTERN;                           \
    }                                                                     \
                                                                          \
    if ((SIZE) < HEAP_MAXIMUM_FREELISTS) {                                \
                                                                          \
        _HEAD = &(H)->FreeLists[ (SIZE) ];                                \
                                                                          \
        if (IsListEmpty(_HEAD)) {                                         \
                                                                          \
            SET_FREELIST_BIT( H, FB );                                    \
        }                                                                 \
                                                                          \
    } else {                                                              \
                                                                          \
        _HEAD = &(H)->FreeLists[ 0 ];                                     \
        _NEXT = _HEAD->Flink;                                             \
                                                                          \
        while (_HEAD != _NEXT) {                                          \
                                                                          \
            _FB1 = CONTAINING_RECORD( _NEXT, HEAP_FREE_ENTRY, FreeList ); \
                                                                          \
            if ((SIZE) <= _FB1->Size) {                                   \
                                                                          \
                break;                                                    \
                                                                          \
            } else {                                                      \
                                                                          \
                _NEXT = _NEXT->Flink;                                     \
            }                                                             \
        }                                                                 \
                                                                          \
        _HEAD = _NEXT;                                                    \
    }                                                                     \
                                                                          \
    InsertTailList( _HEAD, &(FB)->FreeList );                             \
}

#else  // DBG

#define RtlpInsertFreeBlockDirect( H, FB, SIZE )                          \
{                                                                         \
    PLIST_ENTRY _HEAD, _NEXT;                                             \
    PHEAP_FREE_ENTRY _FB1;                                                \
                                                                          \
    HEAPASSERT((FB)->Size == (SIZE));                                     \
    (FB)->Flags &= ~(HEAP_ENTRY_FILL_PATTERN |                            \
                     HEAP_ENTRY_EXTRA_PRESENT |                           \
                     HEAP_ENTRY_BUSY);                                    \
                                                                          \
    if ((SIZE) < HEAP_MAXIMUM_FREELISTS) {                                \
                                                                          \
        _HEAD = &(H)->FreeLists[ (SIZE) ];                                \
                                                                          \
        if (IsListEmpty(_HEAD)) {                                         \
                                                                          \
            SET_FREELIST_BIT( H, FB );                                    \
        }                                                                 \
                                                                          \
    } else {                                                              \
                                                                          \
        _HEAD = &(H)->FreeLists[ 0 ];                                     \
        _NEXT = _HEAD->Flink;                                             \
                                                                          \
        while (_HEAD != _NEXT) {                                          \
                                                                          \
            _FB1 = CONTAINING_RECORD( _NEXT, HEAP_FREE_ENTRY, FreeList ); \
                                                                          \
            if ((SIZE) <= _FB1->Size) {                                   \
                                                                          \
                break;                                                    \
                                                                          \
            } else {                                                      \
                                                                          \
                _NEXT = _NEXT->Flink;                                     \
            }                                                             \
        }                                                                 \
                                                                          \
        _HEAD = _NEXT;                                                    \
    }                                                                     \
                                                                          \
    InsertTailList( _HEAD, &(FB)->FreeList );                             \
}

#endif // DBG

//
//  This version of RtlpInsertFreeBlockDirect does no filling.
//

#define RtlpFastInsertFreeBlockDirect( H, FB, SIZE )              \
{                                                                 \
    if ((SIZE) < HEAP_MAXIMUM_FREELISTS) {                        \
                                                                  \
        RtlpFastInsertDedicatedFreeBlockDirect( H, FB, SIZE );    \
                                                                  \
    } else {                                                      \
                                                                  \
        RtlpFastInsertNonDedicatedFreeBlockDirect( H, FB, SIZE ); \
    }                                                             \
}

//
//  This version of RtlpInsertFreeBlockDirect only works for dedicated free
//  lists and doesn't do any filling.
//

#define RtlpFastInsertDedicatedFreeBlockDirect( H, FB, SIZE )             \
{                                                                         \
    PLIST_ENTRY _HEAD;                                                    \
                                                                          \
    HEAPASSERT((FB)->Size == (SIZE));                                     \
                                                                          \
    if (!((FB)->Flags & HEAP_ENTRY_LAST_ENTRY)) {                         \
                                                                          \
        HEAPASSERT(((PHEAP_ENTRY)(FB) + (SIZE))->PreviousSize == (SIZE)); \
    }                                                                     \
                                                                          \
    (FB)->Flags &= HEAP_ENTRY_LAST_ENTRY;                                 \
                                                                          \
    _HEAD = &(H)->FreeLists[ (SIZE) ];                                    \
                                                                          \
    if (IsListEmpty(_HEAD)) {                                             \
                                                                          \
        SET_FREELIST_BIT( H, FB );                                        \
    }                                                                     \
                                                                          \
    InsertTailList( _HEAD, &(FB)->FreeList );                             \
}

//
//  This version of RtlpInsertFreeBlockDirect only works for nondedicated free
//  lists and doesn't do any filling.
//

#define RtlpFastInsertNonDedicatedFreeBlockDirect( H, FB, SIZE )          \
{                                                                         \
    PLIST_ENTRY _HEAD, _NEXT;                                             \
    PHEAP_FREE_ENTRY _FB1;                                                \
                                                                          \
    HEAPASSERT((FB)->Size == (SIZE));                                     \
                                                                          \
    if (!((FB)->Flags & HEAP_ENTRY_LAST_ENTRY)) {                         \
                                                                          \
        HEAPASSERT(((PHEAP_ENTRY)(FB) + (SIZE))->PreviousSize == (SIZE)); \
    }                                                                     \
                                                                          \
    (FB)->Flags &= (HEAP_ENTRY_LAST_ENTRY);                               \
                                                                          \
    _HEAD = &(H)->FreeLists[ 0 ];                                         \
    _NEXT = _HEAD->Flink;                                                 \
                                                                          \
    while (_HEAD != _NEXT) {                                              \
                                                                          \
        _FB1 = CONTAINING_RECORD( _NEXT, HEAP_FREE_ENTRY, FreeList );     \
                                                                          \
        if ((SIZE) <= _FB1->Size) {                                       \
                                                                          \
            break;                                                        \
                                                                          \
        } else {                                                          \
                                                                          \
            _NEXT = _NEXT->Flink;                                         \
        }                                                                 \
    }                                                                     \
                                                                          \
    InsertTailList( _NEXT, &(FB)->FreeList );                             \
}


//
//  This macro removes a block from its free list with fill checking if
//  necessary
//

#define RtlpRemoveFreeBlock( H, FB )                                              \
{                                                                                 \
    RtlpFastRemoveFreeBlock( H, FB )                                              \
                                                                                  \
    if ((FB)->Flags & HEAP_ENTRY_FILL_PATTERN) {                                  \
                                                                                  \
        SIZE_T cb, cbEqual;                                                       \
        PVOID p;                                                                  \
                                                                                  \
        cb = ((FB)->Size << HEAP_GRANULARITY_SHIFT) - sizeof( *(FB) );            \
                                                                                  \
        if ((FB)->Flags & HEAP_ENTRY_EXTRA_PRESENT &&                             \
            cb > sizeof( HEAP_FREE_ENTRY_EXTRA )) {                               \
                                                                                  \
            cb -= sizeof( HEAP_FREE_ENTRY_EXTRA );                                \
        }                                                                         \
                                                                                  \
        cbEqual = RtlCompareMemoryUlong( (PCHAR)((FB) + 1),                       \
                                                 cb,                              \
                                                 FREE_HEAP_FILL );                \
                                                                                  \
        if (cbEqual != cb) {                                                      \
                                                                                  \
            HeapDebugPrint((                                                      \
                "HEAP: Free Heap block %lx modified at %lx after it was freed\n", \
                (FB),                                                             \
                (PCHAR)((FB) + 1) + cbEqual ));                                   \
                                                                                  \
            HeapDebugBreak((FB));                                                 \
        }                                                                         \
    }                                                                             \
}

//
//  This version of RtlpRemoveFreeBlock does no fill checking
//

#define RtlpFastRemoveFreeBlock( H, FB )         \
{                                                \
    PLIST_ENTRY _EX_Blink;                       \
    PLIST_ENTRY _EX_Flink;                       \
                                                 \
    _EX_Flink = (FB)->FreeList.Flink;            \
    _EX_Blink = (FB)->FreeList.Blink;            \
                                                 \
    _EX_Blink->Flink = _EX_Flink;                \
    _EX_Flink->Blink = _EX_Blink;                \
                                                 \
    if ((_EX_Flink == _EX_Blink) &&              \
        ((FB)->Size < HEAP_MAXIMUM_FREELISTS)) { \
                                                 \
        CLEAR_FREELIST_BIT( H, FB );             \
    }                                            \
}

//
//  This version of RtlpRemoveFreeBlock only works for dedicated free lists
//  (where we know that (FB)->Mask != 0) and doesn't do any fill checking
//

#define RtlpFastRemoveDedicatedFreeBlock( H, FB ) \
{                                                 \
    PLIST_ENTRY _EX_Blink;                        \
    PLIST_ENTRY _EX_Flink;                        \
                                                  \
    _EX_Flink = (FB)->FreeList.Flink;             \
    _EX_Blink = (FB)->FreeList.Blink;             \
                                                  \
    _EX_Blink->Flink = _EX_Flink;                 \
    _EX_Flink->Blink = _EX_Blink;                 \
                                                  \
    if (_EX_Flink == _EX_Blink) {                 \
                                                  \
        CLEAR_FREELIST_BIT( H, FB );              \
    }                                             \
}

//
//  This version of RtlpRemoveFreeBlock only works for dedicated free lists
//  (where we know that (FB)->Mask == 0) and doesn't do any fill checking
//

#define RtlpFastRemoveNonDedicatedFreeBlock( H, FB ) \
{                                                    \
    RemoveEntryList(&(FB)->FreeList)                 \
}


//
//  Heap tagging routines implemented in heapdll.c
//

#if DBG

#define IS_HEAP_TAGGING_ENABLED() (TRUE)

#else

#define IS_HEAP_TAGGING_ENABLED() (NtGlobalFlag & FLG_HEAP_ENABLE_TAGGING)

#endif // DBG

//
//  ORDER IS IMPORTANT HERE...SEE RtlpUpdateTagEntry sources
//

typedef enum _HEAP_TAG_ACTION {

    AllocationAction,
    VirtualAllocationAction,
    FreeAction,
    VirtualFreeAction,
    ReAllocationAction,
    VirtualReAllocationAction

} HEAP_TAG_ACTION;

PWSTR
RtlpGetTagName (
    PHEAP Heap,
    USHORT TagIndex
    );

USHORT
RtlpUpdateTagEntry (
    PHEAP Heap,
    USHORT TagIndex,
    SIZE_T OldSize,      // Only valid for ReAllocation and Free actions
    SIZE_T NewSize,      // Only valid for ReAllocation and Allocation actions
    HEAP_TAG_ACTION Action
    );

VOID
RtlpResetTags (
    PHEAP Heap
    );

VOID
RtlpDestroyTags (
    PHEAP Heap
    );


//
// Define heap lookaside list allocation functions.
//

typedef struct _HEAP_LOOKASIDE {
    SLIST_HEADER ListHead;

    USHORT Depth;
    USHORT MaximumDepth;

    ULONG TotalAllocates;
    ULONG AllocateMisses;
    ULONG TotalFrees;
    ULONG FreeMisses;

    ULONG LastTotalAllocates;
    ULONG LastAllocateMisses;

    ULONG Future[2];

} HEAP_LOOKASIDE, *PHEAP_LOOKASIDE;

NTKERNELAPI
VOID
RtlpInitializeHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside,
    IN USHORT Depth
    );

NTKERNELAPI
VOID
RtlpDeleteHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside
    );

VOID
RtlpAdjustHeapLookasideDepth (
    IN PHEAP_LOOKASIDE Lookaside
    );

NTKERNELAPI
PVOID
RtlpAllocateFromHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside
    );

NTKERNELAPI
BOOLEAN
RtlpFreeToHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside,
    IN PVOID Entry
    );

#endif // _RTL_HEAP_PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\heapdll.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    heapdll.c

Abstract:

    This module implements the user mode only portions of the heap allocator.

Author:

    Steve Wood (stevewo) 20-Sep-1994

Revision History:

--*/

#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"

#ifdef NTHEAP_ENABLED
#include "heapp.h"
#endif // NTHEAP_ENABLED


//
//  This structure is used by RtlUsageHeap to keep track of heap usage
//  between calls.  This package typecasts an extra reserved buffer passed
//  in by the user to hold this information
//

typedef struct _RTL_HEAP_USAGE_INTERNAL {
    PVOID Base;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    PRTL_HEAP_USAGE_ENTRY FreeList;
    PRTL_HEAP_USAGE_ENTRY LargeEntriesSentinal;
    ULONG Reserved;
} RTL_HEAP_USAGE_INTERNAL, *PRTL_HEAP_USAGE_INTERNAL;


//
//  Note that the following variables are specific to each process
//
//
//  This is a lock used to protect access the this processes heap list
//

HEAP_LOCK RtlpProcessHeapsListLock;

//
//  This is a specific list of heaps initialized and used by the process
//

#define RTLP_STATIC_HEAP_LIST_SIZE 16

PHEAP RtlpProcessHeapsListBuffer[ RTLP_STATIC_HEAP_LIST_SIZE ];

//
//  This variable stores a pointer to the heap used to storage global heap
//  tags
//

PHEAP RtlpGlobalTagHeap = NULL;

//
//  This varible is used by the process as work space to build up names for
//  pseudo tags
//

static WCHAR RtlpPseudoTagNameBuffer[ 24 ];


BOOLEAN
RtlpGrowBlockInPlace (
    IN PHEAP Heap,
    IN ULONG Flags,
    IN PHEAP_ENTRY BusyBlock,
    IN SIZE_T Size,
    IN SIZE_T AllocationIndex
    );

PVOID
RtlDebugReAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    );

BOOLEAN
RtlDebugGetUserInfoHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    OUT PVOID *UserValue OPTIONAL,
    OUT PULONG UserFlags OPTIONAL
    );

BOOLEAN
RtlDebugSetUserValueHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UserValue
    );

BOOLEAN
RtlDebugSetUserFlagsHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    );

SIZE_T
RtlDebugCompactHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    );

NTSTATUS
RtlDebugCreateTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PWSTR TagPrefix OPTIONAL,
    IN PWSTR TagNames
    );

PWSTR
RtlDebugQueryTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN USHORT TagIndex,
    IN BOOLEAN ResetCounters,
    OUT PRTL_HEAP_TAG_INFO TagInfo OPTIONAL
    );

NTSTATUS
RtlDebugUsageHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    );

BOOLEAN
RtlDebugWalkHeap (
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    );

PHEAP_TAG_ENTRY
RtlpAllocateTags (
    PHEAP Heap,
    ULONG NumberOfTags
    );

PRTL_HEAP_USAGE_ENTRY
RtlpFreeHeapUsageEntry (
    PRTL_HEAP_USAGE_INTERNAL Buffer,
    PRTL_HEAP_USAGE_ENTRY p
    );

NTSTATUS
RtlpAllocateHeapUsageEntry (
    PRTL_HEAP_USAGE_INTERNAL Buffer,
    PRTL_HEAP_USAGE_ENTRY *pp
    );

//
//  Declared in ntrtl.h
//

NTSTATUS
RtlInitializeHeapManager(
    VOID
    )

/*++

Routine Description:

    This routine is used to initialize the heap manager for the current process

Arguments:

    None.

Return Value:

    None.

--*/

{
    PPEB Peb = NtCurrentPeb();

#if DBG

    //
    //  Sanity check the sizes of the header entry structures
    //

    if (sizeof( HEAP_ENTRY ) != sizeof( HEAP_ENTRY_EXTRA )) {

        HeapDebugPrint(( "Heap header and extra header sizes disagree\n" ));

        HeapDebugBreak( NULL );
    }

    if (sizeof( HEAP_ENTRY ) != CHECK_HEAP_TAIL_SIZE) {

        HeapDebugPrint(( "Heap header and tail fill sizes disagree\n" ));

        HeapDebugBreak( NULL );
    }

    if (sizeof( HEAP_FREE_ENTRY ) != (2 * sizeof( HEAP_ENTRY ))) {

        HeapDebugPrint(( "Heap header and free header sizes disagree\n" ));

        HeapDebugBreak( NULL );
    }

#endif // DBG

    //
    //  Initialize the heap specific structures in the current peb
    //

    Peb->NumberOfHeaps = 0;
    Peb->MaximumNumberOfHeaps = RTLP_STATIC_HEAP_LIST_SIZE;
    Peb->ProcessHeaps = RtlpProcessHeapsListBuffer;

#ifdef NTHEAP_ENABLED
    {
        (VOID) RtlInitializeNtHeapManager();
    }
#endif // NTHEAP_ENABLED

    //
    //  Initialize the lock and return to our caller
    //

    return RtlInitializeLockRoutine( &RtlpProcessHeapsListLock.Lock );
}


//
//  Declared in ntrtl.h
//

VOID
RtlProtectHeap (
    IN PVOID HeapHandle,
    IN BOOLEAN MakeReadOnly
    )

/*++

Routine Description:

    This routine will change the protection on all the pages in a heap
    to be either readonly or readwrite

Arguments:

    HeapHandle - Supplies a pointer to the heap being altered

    MakeReadOnly - Specifies if the heap is to be made readonly or
        readwrite

Return Value:

    None.

--*/

{
    PHEAP Heap;
    UCHAR SegmentIndex;
    PHEAP_SEGMENT Segment;
    MEMORY_BASIC_INFORMATION VaInfo;
    NTSTATUS Status;
    PVOID Address;
    PVOID ProtectAddress;
    SIZE_T Size;
    ULONG OldProtect;
    ULONG NewProtect;

    Heap = (PHEAP)HeapHandle;

    //
    //  For every valid segment in the heap we will zoom through all its
    //  regions and for those that are committed we'll change it protection
    //

    for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

        Segment = Heap->Segments[ SegmentIndex ];

        if ( Segment ) {

            //
            //  Starting from the first address for the segment and going to
            //  the last address in the segment we'll step through by regions
            //

            Address = Segment->BaseAddress;

            while ((ULONG_PTR)Address < (ULONG_PTR)(Segment->LastValidEntry)) {

                //
                //  Query the current region to get its state and size
                //

                Status = ZwQueryVirtualMemory( NtCurrentProcess(),
                                               Address,
                                               MemoryBasicInformation,
                                               &VaInfo,
                                               sizeof(VaInfo),
                                               NULL );

                if (!NT_SUCCESS( Status )) {

                    HeapDebugPrint(( "VirtualQuery Failed 0x%08x %x\n", Address, Status ));

                    return;
                }

                //
                //  If we found a commited block then set its protection
                //

                if (VaInfo.State == MEM_COMMIT) {

                    Size = VaInfo.RegionSize;

                    ProtectAddress = Address;

                    if (MakeReadOnly) {

                        NewProtect = PAGE_READONLY;

                    } else {

                        NewProtect = PAGE_READWRITE;
                    }

                    Status = ZwProtectVirtualMemory( NtCurrentProcess(),
                                                     &ProtectAddress,
                                                     &Size,
                                                     NewProtect,
                                                     &OldProtect );

                    if (!NT_SUCCESS( Status )) {

                        HeapDebugPrint(( "VirtualProtect Failed 0x%08x %x\n", Address, Status ));

                        return;
                    }
                }

                //
                //  Now calculate the address of the next region in the segment
                //

                Address = (PVOID)((PCHAR)Address + VaInfo.RegionSize);
            }
        }
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlLockHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is used by lock access to a specific heap structure

Arguments:

    HeapHandle - Supplies a pointer to the heap being locked

Return Value:

    BOOLEAN - TRUE if the heap is now locked and FALSE otherwise (i.e.,
        the heap is ill-formed).  TRUE is returned even if the heap is
        not lockable.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;

    RTL_PAGED_CODE();

    //
    //  Check for the heap protected by guard pages
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapLock( HeapHandle ));

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    if (!RtlpCheckHeapSignature( Heap, "RtlLockHeap" )) {

        return FALSE;
    }

    //
    //  Lock the heap.  And disable the lookaside list by incrementing
    //  its lock count.
    //

    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {

        RtlAcquireLockRoutine( Heap->LockVariable );

        Heap->LookasideLockCount += 1;
    }

    return TRUE;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlUnlockHeap (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is used to unlock access to a specific heap structure

Arguments:

    HeapHandle - Supplies a pointer to the heep being unlocked

Return Value:

    BOOLEAN - TRUE if the heap is now unlocked and FALSE otherwise (i.e.,
        the heap is ill-formed).  TRUE is also returned if the heap was
        never locked to begin with because it is not seralizable.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;

    RTL_PAGED_CODE();

    //
    //  Check for the heap protected by guard pages
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapUnlock( HeapHandle ));

    //
    //  Validate that HeapAddress points to a HEAP structure.
    //

    if (!RtlpCheckHeapSignature( Heap, "RtlUnlockHeap" )) {

        return FALSE;
    }

    //
    //  Unlock the heap.  And enable the lookaside logic by decrementing
    //  its lock count
    //

    if (!(Heap->Flags & HEAP_NO_SERIALIZE)) {

        Heap->LookasideLockCount -= 1;

        RtlReleaseLockRoutine( Heap->LockVariable );
    }

    return TRUE;
}


//
//  Declared in nturtl.h
//

PVOID
RtlReAllocateHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine will resize a user specified heap block.  The new size
    can either be smaller or larger than the current block size.

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of heap flags to augment those already
        enforced by the heap

    BaseAddress - Supplies the current address of a block allocated
        from heap.  We will try and resize this block at its current
        address, but it could possibly move if this heap structure
        allows for relocation

    Size - Supplies the size, in bytes, for the newly resized heap
        block

Return Value:

    PVOID - A pointer to the resized block.  If the block had to move
        then this address will not be equal to the input base address

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    SIZE_T AllocationSize;
    PHEAP_ENTRY BusyBlock, NewBusyBlock;
    PHEAP_ENTRY_EXTRA OldExtraStuff, NewExtraStuff;
    SIZE_T FreeSize;
    BOOLEAN LockAcquired = FALSE;
    PVOID NewBaseAddress;
    PHEAP_FREE_ENTRY SplitBlock, SplitBlock2;
    SIZE_T OldSize;
    SIZE_T AllocationIndex;
    SIZE_T OldAllocationIndex;
    UCHAR FreeFlags;
    NTSTATUS Status;
    PVOID DeCommitAddress;
    SIZE_T DeCommitSize;
    EXCEPTION_RECORD ExceptionRecord;

    //
    //  If there isn't an address to relocate the heap at then our work is done
    //

    if (BaseAddress == NULL) {

        SET_LAST_STATUS( STATUS_SUCCESS );

        return NULL;
    }

#ifdef NTHEAP_ENABLED
    {
        if (Heap->Flags & NTHEAP_ENABLED_FLAG) {

            return RtlReAllocateNtHeap( HeapHandle, Flags, BaseAddress, Size );
        }
    }
#endif // NTHEAP_ENABLED

    //
    //  Augment the heap flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if we should simply call the debug version of heap to do the work
    //

    if (DEBUG_HEAP( Flags)) {

        return RtlDebugReAllocateHeap( HeapHandle, Flags, BaseAddress, Size );
    }

    //
    //  Make sure we didn't get a negative heap size
    //

    if (Size > 0x7fffffff) {

        SET_LAST_STATUS( STATUS_NO_MEMORY );

        return NULL;
    }

    //
    //  Round the requested size up to the allocation granularity.  Note
    //  that if the request is for 0 bytes, we still allocate memory, because
    //  we add in an extra byte to protect ourselves from idiots.
    //

    AllocationSize = ((Size ? Size : 1) + Heap->AlignRound) & Heap->AlignMask;

    if ((Flags & HEAP_NEED_EXTRA_FLAGS) ||
        (Heap->PseudoTagEntries != NULL) ||
        ((((PHEAP_ENTRY)BaseAddress)-1)->Flags & HEAP_ENTRY_EXTRA_PRESENT)) {

        AllocationSize += sizeof( HEAP_ENTRY_EXTRA );
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;

            //
            //  Because it is now zero the following statement will set the no
            //  serialize bit
            //

            Flags ^= HEAP_NO_SERIALIZE;
        }

        try {

            //
            //  Compute the heap block address for user specified block
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            //
            //  Check if the block is not in use then it is an error
            //

            if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

                //
                //  Bail if not a busy block.
                //

                leave;

            //
            //  We need the current (i.e., old) size and allocation of the
            //  block.  Check if the block is a big allocation.  The size
            //  field of a big block is really the unused by count
            //

            } else if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                OldSize = RtlpGetSizeOfBigBlock( BusyBlock );

                OldAllocationIndex = (OldSize + BusyBlock->Size) >> HEAP_GRANULARITY_SHIFT;

                //
                //  We'll need to adjust the new allocation size to account
                //  for the big block header and then round it up to a page
                //

                AllocationSize += FIELD_OFFSET( HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );
                AllocationSize = ROUND_UP_TO_POWER2( AllocationSize, PAGE_SIZE );

            //
            //  Otherwise the block is in use and is a small allocation
            //

            } else {

                OldAllocationIndex = BusyBlock->Size;

                OldSize = (OldAllocationIndex << HEAP_GRANULARITY_SHIFT) -
                          BusyBlock->UnusedBytes;
            }

            //
            //  Compute the new allocation index
            //

            AllocationIndex = AllocationSize >> HEAP_GRANULARITY_SHIFT;

            //
            //  At this point we have the old size and index, and the new size
            //  and index
            //
            //  See if new size less than or equal to the current size.
            //

            if (AllocationIndex <= OldAllocationIndex) {

                //
                //  If the new allocation index is only one less then the current
                //  index then make the sizes equal
                //

                if (AllocationIndex + 1 == OldAllocationIndex) {

                    AllocationIndex += 1;
                    AllocationSize += sizeof( HEAP_ENTRY );
                }

                //
                //  Calculate new residual (unused) amount
                //

                if (BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                    //
                    //  In a big block the size is really the unused byte count
                    //

                    BusyBlock->Size = (USHORT)(AllocationSize - Size);

                } else if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    //
                    //  The extra stuff struct goes after the data.  So compute
                    //  the old and new extra stuff location and copy the data
                    //

                    OldExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + BusyBlock->Size - 1);

                    NewExtraStuff = (PHEAP_ENTRY_EXTRA)(BusyBlock + AllocationIndex - 1);

                    *NewExtraStuff = *OldExtraStuff;

                    //
                    //  If we're doing heap tagging then update the tag entry
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        NewExtraStuff->TagIndex =
                            RtlpUpdateTagEntry( Heap,
                                                NewExtraStuff->TagIndex,
                                                OldAllocationIndex,
                                                AllocationIndex,
                                                ReAllocationAction );
                    }

                    BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);

                } else {

                    //
                    //  If we're doing heap tagging then update the tag entry
                    //

                    if (IS_HEAP_TAGGING_ENABLED()) {

                        BusyBlock->SmallTagIndex = (UCHAR)
                            RtlpUpdateTagEntry( Heap,
                                                BusyBlock->SmallTagIndex,
                                                BusyBlock->Size,
                                                AllocationIndex,
                                                ReAllocationAction );
                    }

                    BusyBlock->UnusedBytes = (UCHAR)(AllocationSize - Size);
                }

                //
                //  Check if the block is getting bigger, then fill in the extra
                //  space.
                //
                //  **** how can this happen if the allocation index is less than or
                //  **** equal to the old allocation index
                //

                if (Size > OldSize) {

                    //
                    //  See if we should zero the extra space
                    //

                    if (Flags & HEAP_ZERO_MEMORY) {

                        RtlZeroMemory( (PCHAR)BaseAddress + OldSize,
                                       Size - OldSize );

                    //
                    //  Otherwise see if we should fill the extra space
                    //

                    } else if (Heap->Flags & HEAP_FREE_CHECKING_ENABLED) {

                        SIZE_T PartialBytes, ExtraSize;

                        PartialBytes = OldSize & (sizeof( ULONG ) - 1);

                        if (PartialBytes) {

                            PartialBytes = 4 - PartialBytes;
                        }

                        if (Size > (OldSize + PartialBytes)) {

                            ExtraSize = (Size - (OldSize + PartialBytes)) & ~(sizeof( ULONG ) - 1);

                            if (ExtraSize != 0) {

                                RtlFillMemoryUlong( (PCHAR)(BusyBlock + 1) + OldSize + PartialBytes,
                                                    ExtraSize,
                                                    ALLOC_HEAP_FILL );
                            }
                        }
                    }
                }

                if (Heap->Flags & HEAP_TAIL_CHECKING_ENABLED) {

                    RtlFillMemory( (PCHAR)(BusyBlock + 1) + Size,
                                   CHECK_HEAP_TAIL_SIZE,
                                   CHECK_HEAP_TAIL_FILL );
                }

                //
                //  If amount of change is greater than the size of a free block,
                //  then need to free the extra space.  Otherwise, nothing else to
                //  do.
                //

                if (AllocationIndex != OldAllocationIndex) {

                    FreeFlags = BusyBlock->Flags & ~HEAP_ENTRY_BUSY;

                    if (FreeFlags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                        PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

                        VirtualAllocBlock = CONTAINING_RECORD( BusyBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                        if (IS_HEAP_TAGGING_ENABLED()) {

                            VirtualAllocBlock->ExtraStuff.TagIndex =
                                RtlpUpdateTagEntry( Heap,
                                                    VirtualAllocBlock->ExtraStuff.TagIndex,
                                                    OldAllocationIndex,
                                                    AllocationIndex,
                                                    VirtualReAllocationAction );
                        }

                        DeCommitAddress = (PCHAR)VirtualAllocBlock + AllocationSize;

                        DeCommitSize = (OldAllocationIndex << HEAP_GRANULARITY_SHIFT) -
                                       AllocationSize;

                        Status = ZwFreeVirtualMemory( NtCurrentProcess(),
                                                      (PVOID *)&DeCommitAddress,
                                                      &DeCommitSize,
                                                      MEM_RELEASE );

                        if (!NT_SUCCESS( Status )) {

                            HeapDebugPrint(( "Unable to release memory at %p for %p bytes - Status == %x\n",
                                             DeCommitAddress, DeCommitSize, Status ));

                            HeapDebugBreak( NULL );

                        } else {

                            VirtualAllocBlock->CommitSize -= DeCommitSize;
                        }

                    } else {

                        //
                        //  Otherwise, shrink size of this block to new size, and make extra
                        //  space at end free.
                        //

                        SplitBlock = (PHEAP_FREE_ENTRY)(BusyBlock + AllocationIndex);

                        SplitBlock->Flags = FreeFlags;

                        SplitBlock->PreviousSize = (USHORT)AllocationIndex;

                        SplitBlock->SegmentIndex = BusyBlock->SegmentIndex;

                        FreeSize = BusyBlock->Size - AllocationIndex;

                        BusyBlock->Size = (USHORT)AllocationIndex;

                        BusyBlock->Flags &= ~HEAP_ENTRY_LAST_ENTRY;

                        //
                        //  If the following block is uncommitted then we only need to
                        //  add this new entry to its free list
                        //

                        if (FreeFlags & HEAP_ENTRY_LAST_ENTRY) {

                            PHEAP_SEGMENT Segment;

                            Segment = Heap->Segments[SplitBlock->SegmentIndex];
                            Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;

                            SplitBlock->Size = (USHORT)FreeSize;

                            RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                            Heap->TotalFreeSize += FreeSize;

                        } else {

                            //
                            //  Otherwise get the next block and check if it is busy.  If it
                            //  is in use then add this new entry to its free list
                            //

                            SplitBlock2 = (PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize);

                            if (SplitBlock2->Flags & HEAP_ENTRY_BUSY) {

                                SplitBlock->Size = (USHORT)FreeSize;

                                ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;

                                RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                Heap->TotalFreeSize += FreeSize;

                            } else {

                                //
                                //  Otherwise the next block is not in use so we
                                //  should be able to merge with it.  Remove the
                                //  second free block and if the combined size is
                                //  still okay then merge the two blocks and add
                                //  the single block back in.  Otherwise call a
                                //  routine that will actually break it apart
                                //  before insertion.
                                //

                                SplitBlock->Flags = SplitBlock2->Flags;

                                RtlpRemoveFreeBlock( Heap, SplitBlock2 );

                                Heap->TotalFreeSize -= SplitBlock2->Size;

                                FreeSize += SplitBlock2->Size;

                                if (FreeSize <= HEAP_MAXIMUM_BLOCK_SIZE) {

                                    SplitBlock->Size = (USHORT)FreeSize;

                                    if (!(SplitBlock->Flags & HEAP_ENTRY_LAST_ENTRY)) {

                                        ((PHEAP_FREE_ENTRY)((PHEAP_ENTRY)SplitBlock + FreeSize))->PreviousSize = (USHORT)FreeSize;

                                    } else {

                                        PHEAP_SEGMENT Segment;

                                        Segment = Heap->Segments[SplitBlock->SegmentIndex];
                                        Segment->LastEntryInSegment = (PHEAP_ENTRY)SplitBlock;
                                    }

                                    RtlpInsertFreeBlockDirect( Heap, SplitBlock, (USHORT)FreeSize );

                                    Heap->TotalFreeSize += FreeSize;

                                } else {

                                    RtlpInsertFreeBlock( Heap, SplitBlock, FreeSize );
                                }
                            }
                        }
                    }
                }

            } else {

                //
                //  At this point the new size is greater than the current size
                //
                //  If the block is a big allocation or we're not able to grow
                //  the block in place then we have a lot of work to do
                //

                if ((BusyBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) ||
                    !RtlpGrowBlockInPlace( Heap, Flags, BusyBlock, Size, AllocationIndex )) {

                    //
                    //  We're growing the block.  Allocate a new block with the bigger
                    //  size, copy the contents of the old block to the new block and then
                    //  free the old block.  Return the address of the new block.
                    //

                    if (Flags & HEAP_REALLOC_IN_PLACE_ONLY) {

#if DBG
                        // HeapDebugPrint(( "Failing ReAlloc because cant do it inplace.\n" ));
#endif

                        BaseAddress = NULL;

                    } else {

                        //
                        //  Clear the tag bits from the flags
                        //

                        Flags &= ~HEAP_TAG_MASK;

                        //
                        //  If there is an extra struct present then get the tag
                        //  index from the extra stuff and augment the flags with
                        //  the tag index.
                        //

                        if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                            Flags &= ~HEAP_SETTABLE_USER_FLAGS;

                            Flags |= HEAP_SETTABLE_USER_VALUE |
                                     ((BusyBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS) << 4);

                            OldExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                            try {

                                if ((OldExtraStuff->TagIndex != 0) &&
                                    !(OldExtraStuff->TagIndex & HEAP_PSEUDO_TAG_FLAG)) {

                                    Flags |= OldExtraStuff->TagIndex << HEAP_TAG_SHIFT;
                                }

                            } except (EXCEPTION_EXECUTE_HANDLER) {

                                BusyBlock->Flags &= ~HEAP_ENTRY_EXTRA_PRESENT;
                            }

                        } else if (BusyBlock->SmallTagIndex != 0) {

                            //
                            //  There is not an extra stuff struct, but block
                            //  does have a small tag index so now add this small
                            //  tag to the flags
                            //

                            Flags |= BusyBlock->SmallTagIndex << HEAP_TAG_SHIFT;
                        }

                        //
                        //  Allocate from the heap space for the reallocation
                        //

                        NewBaseAddress = RtlAllocateHeap( HeapHandle,
                                                          Flags & ~HEAP_ZERO_MEMORY,
                                                          Size );

                        if (NewBaseAddress != NULL) {

                            //
                            //  We were able to get the allocation so now back up
                            //  to the heap block and if the block has an extra
                            //  stuff struct then copy over the extra stuff
                            //

                            NewBusyBlock = (PHEAP_ENTRY)NewBaseAddress - 1;

                            if (NewBusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                                NewExtraStuff = RtlpGetExtraStuffPointer( NewBusyBlock );

                                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                                    OldExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                                    NewExtraStuff->Settable = OldExtraStuff->Settable;

                                } else {

                                    RtlZeroMemory( NewExtraStuff, sizeof( *NewExtraStuff ));
                                }
                            }

                            //
                            //  Copy over the user's data area to the new block
                            //

                            RtlMoveMemory( NewBaseAddress, BaseAddress, Size < OldSize ? Size : OldSize );

                            //
                            //  Check if we grew the block and we should zero
                            //  the remaining part.
                            //
                            //  **** is this first test always true because we're
                            //  **** in the part that grows blocks
                            //

                            if (Size > OldSize && (Flags & HEAP_ZERO_MEMORY)) {

                                RtlZeroMemory( (PCHAR)NewBaseAddress + OldSize,
                                               Size - OldSize );
                            }

                            //
                            //  Release the old block
                            //

                            RtlFreeHeap( HeapHandle,
                                         Flags,
                                         BaseAddress );
                        }

                        BaseAddress = NewBaseAddress;
                    }
                }
            }

            if ((BaseAddress == NULL) && (Flags & HEAP_GENERATE_EXCEPTIONS)) {

                //
                //  Construct an exception record.
                //

                ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
                ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
                ExceptionRecord.NumberParameters = 1;
                ExceptionRecord.ExceptionFlags = 0;
                ExceptionRecord.ExceptionInformation[ 0 ] = AllocationSize;

                RtlRaiseException( &ExceptionRecord );
            }

        } except( GetExceptionCode() == STATUS_NO_MEMORY ? EXCEPTION_CONTINUE_SEARCH :
                                                           EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
            BaseAddress = NULL;

        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return BaseAddress;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlGetUserInfoHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    OUT PVOID *UserValue OPTIONAL,
    OUT PULONG UserFlags OPTIONAL
    )

/*++

Routine Description:

    This routine returns to the user the set of user flags
    and user values for the specified heap entry.  The user value
    is set via a set call and the user flags is part of the
    user settable flags used when communicating with the heap package
    and can also be set via a set call

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Flags - Supplies a set of flags to agument those already in the heap

    BaseAddress - Supplies a pointer to the users heap entry being
        queried

    UserValue - Optionally supplies a pointer to recieve the heap entry
        value

    UserFlasg - Optionally supplies a pointer to recieve the heap flags

Return Value:

    BOOLEAN - TRUE if the query is successful and FALSE otherwise

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result;

    //
    //  Build up a set of real flags to use in this operation
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if we should be going the debug route
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugGetUserInfoHeap( HeapHandle, Flags, BaseAddress, UserValue, UserFlags );
    }

    Result = FALSE;

    try {

        try {

            //
            //  Lock the heap
            //

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;
            }

            //
            //  Backup the pointer to the heap entry
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            //
            //  If the entry is not in use then it is an error
            //

            if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

            } else {

                //
                //  The heap entry is in use so now check if there is
                //  any extra information present
                //

                if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                    //
                    //  Get a pointer to the extra information and if the
                    //  user asked for user values then that field from the
                    //  extra stuff
                    //

                    ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

                    if (ARGUMENT_PRESENT( UserValue )) {

                        *UserValue = (PVOID)ExtraStuff->Settable;
                    }
                }

                //
                //  If the user asked for user flags then return the flags
                //  from the heap entry that are user setable
                //

                if (ARGUMENT_PRESENT( UserFlags )) {

                    *UserFlags = (BusyBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS) << 4;
                }

                //
                //  Now that the assignments are done we can say that
                //  we were successful
                //

                Result = TRUE;
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlSetUserValueHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN PVOID UserValue
    )

/*++

Routine Description:

    This routine is used to set the user settable value for a heap entry

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags needed to augment those already enforced
        by the heap

    BaseAddress - Supplies a pointer to the heap entry allocation being
        modified

    UserValue - Supplies the value to store in the extra stuff space of
        the heap entry

Return Value:

    BOOLEAN - TRUE if the setting worked, and FALSE otherwise.  It could be
        FALSE if the base address is invalid, or if there is not room for
        the extra stuff

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result;

    //
    //  Augment the set of flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check to see if we should be going the debug route
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugSetUserValueHeap( HeapHandle, Flags, BaseAddress, UserValue );
    }

    Result = FALSE;

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Get a pointer to the owning heap entry
        //

        BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

        //
        //  If the entry is not in use then its is an error
        //

        if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

            SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

        //
        //  Otherwise we only can set the value if the entry has space
        //  for the extra stuff
        //

        } else if (BusyBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

            ExtraStuff = RtlpGetExtraStuffPointer( BusyBlock );

            ExtraStuff->Settable = (ULONG_PTR)UserValue;

            Result = TRUE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlSetUserFlagsHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress,
    IN ULONG UserFlagsReset,
    IN ULONG UserFlagsSet
    )

/*++

Routine Description:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags needed to augment those already enforced
        by the heap

    BaseAddress - Supplies a pointer to the heap entry allocation being
        modified

    UserFlagsReset - Supplies a mask of flags that the user wants cleared

    UserFlagsSet- Supplies a mask of flags that the user wants set

Return Value:

    BOOLEAN - TRUE if the operation is a success and FALSE otherwise

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_ENTRY BusyBlock;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result = FALSE;

    //
    //  Augment the set of flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check to see if we should be going the debug route
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugSetUserFlagsHeap( HeapHandle, Flags, BaseAddress, UserFlagsReset, UserFlagsSet );
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        try {

            //
            //  Get a pointer to the owning heap entry
            //

            BusyBlock = (PHEAP_ENTRY)BaseAddress - 1;

            //
            //  If the entry is not in use then it is an error
            //

            if (!(BusyBlock->Flags & HEAP_ENTRY_BUSY)) {

                SET_LAST_STATUS( STATUS_INVALID_PARAMETER );

            } else {

                //
                //  Otherwise modify the flags in the block
                //
                //  **** this is terrible error prone if the user passes in
                //  **** flags that aren't 0x200 0x400 or 0x800 only.
                //

                BusyBlock->Flags &= ~(UserFlagsReset >> 4);
                BusyBlock->Flags |= (UserFlagsSet >> 4);

                Result = TRUE;
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    return Result;
}


//
//  Declared in nturtl.h
//

ULONG
RtlCreateTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PWSTR TagPrefix OPTIONAL,
    IN PWSTR TagNames
    )

/*++

Routine Description:

    This routine create a tag heap for either the specified heap or
    for the global tag heap.

Arguments:

    HeapHandle - Optionally supplies a pointer to the heap that we
        want modified.  If null then the global tag heap is used

    Flags - Supplies a list of flags to augment the flags already
        enforced by the heap

    TagPrefix - Optionally supplies a null terminated wchar string
        of a prefix to add to each tag

    TagNames - Supplies a list of tag names separated by null and terminated
        by a double null.  If the first name in the list start with
        a "!" then it is interpreted as the heap name.  The syntax
        for the tag name is

            [!<heapname> nul ] {<tagname> nul}* nul

Return Value:

    ULONG - returns the index of the last tag create shifted to the high
        order word.

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    ULONG TagIndex;
    ULONG NumberOfTags, MaxTagNameLength, TagPrefixLength;
    PWSTR s, s1, HeapName;
    PHEAP_TAG_ENTRY TagEntry;
    ULONG Result;

    //
    //  Check if tagging is disable and so this call is a noop
    //

    if (!IS_HEAP_TAGGING_ENABLED()) {

        return 0;
    }

    //
    //  If the processes global tag heap has not been created yet then
    //  allocate a global tag heap
    //

    if (RtlpGlobalTagHeap == NULL) {

        RtlpGlobalTagHeap = RtlAllocateHeap( RtlProcessHeap( ), HEAP_ZERO_MEMORY, sizeof( HEAP ));

        if (RtlpGlobalTagHeap == NULL) {

            return 0;
        }
    }

    try {

        //
        //  If the user passed in a heap then we'll use the lock from that
        //  heap to synchronize our work.  Otherwise we're unsynchronized
        //

        if (Heap != NULL) {

            //
            //  Tagging is not part of the guard page heap package
            //

            IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle, 0 );

            //
            //  Check if we should be calling the debug version of the heap package
            //

            if (DEBUG_HEAP( Flags )) {

                Result = RtlDebugCreateTagHeap( HeapHandle, Flags, TagPrefix, TagNames );
                leave;
            }

            //
            //  Augment the flags and lock the specified heap
            //

            Flags |= Heap->ForceFlags;

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;
            }
        }

        //
        //  We start off with zero tags
        //

        TagIndex = 0;
        NumberOfTags = 0;

        //
        //  With tag names that start with "!" we assume what follows
        //  is a heap name.
        //

        if (*TagNames == L'!') {

            HeapName = TagNames + 1;

            //
            //  Move up to the following tag name after the heap name
            //  separated by a null
            //

            while (*TagNames++) { NOTHING; }

        } else {

            HeapName = NULL;
        }

        //
        //  Gobble up each tag name keeping count of how many we find
        //

        s = TagNames;

        while (*s) {

            while (*s++) { NOTHING; }

            NumberOfTags += 1;
        }

        //
        //  Now we will only continue on if we were supplied tag names
        //

        if (NumberOfTags > 0) {

            //
            //  Allocate heap entries for the number of tags we need and
            //  only proceed if this allocation succeeded.   The following
            //  call also makes room for the heap name as tag index 0.  Note
            //  that is heap is null then we assume we're using the global
            //  tag heap
            //

            TagEntry = RtlpAllocateTags( Heap, NumberOfTags );

            if (TagEntry != NULL) {

                MaxTagNameLength = (sizeof( TagEntry->TagName ) / sizeof( WCHAR )) - 1;

                TagIndex = TagEntry->TagIndex;

                //
                //  If the first tag index is zero then we'll make this tag entry
                //  the heap name.
                //

                if (TagIndex == 0) {

                    if (HeapName != NULL ) {

                        //
                        //  Copy over the heap name and pad it out with nulls up
                        //  to the end of the name buffer
                        //

                        wcsncpy( TagEntry->TagName, HeapName, MaxTagNameLength );
                    }

                    //
                    //  Whether we add a heap name or not we'll move on to the
                    //  next tag entry and index
                    //

                    TagEntry += 1;

                    TagIndex = TagEntry->TagIndex;

                //
                //  This isn't the first index for a specified heap, but see if
                //  it is the first index for the global heap.  If so then put
                //  name of the global tags into the 0 index
                //

                } else if (TagIndex == HEAP_GLOBAL_TAG) {

                    wcsncpy( TagEntry->TagName, L"GlobalTags", MaxTagNameLength );

                    TagEntry += 1;

                    TagIndex = TagEntry->TagIndex;
                }

                //
                //  Now we've taken case of the 0 index we'll go on to the rest of
                //  the tags.  If there is tag prefix and it is not zero length
                //  then we'll use this tag prefix provided that is leaves us at
                //  least 4 characters for the tag name itself.  Otherwise we'll
                //  ignore the tag prefix (by setting the variable to null).
                //

                if ((ARGUMENT_PRESENT( TagPrefix )) &&
                    (TagPrefixLength = wcslen( TagPrefix ))) {

                    if (TagPrefixLength >= MaxTagNameLength-4) {

                        TagPrefix = NULL;

                    } else {

                        MaxTagNameLength -= TagPrefixLength;
                    }

                } else {

                    TagPrefix = NULL;
                }

                //
                //  For every tag name (note that this varable has already been
                //  advanced beyond the heap name) we'll put it in a tag entry
                //  by copying in the prefix and then appending on the tag itself
                //
                //   s points to the current users supplied tag name
                //  s1 points to the tag name buffer in the current tag entry
                //

                s = TagNames;

                while (*s) {

                    s1 = TagEntry->TagName;

                    //
                    //  Copy in the optional tag prefix and update s1
                    //

                    if (ARGUMENT_PRESENT( TagPrefix )) {

                        wcscpy( s1, TagPrefix );

                        s1 += TagPrefixLength;
                    }

                    //
                    //  Copy over the remaining tag name padding it with nulls
                    //  up to the end of the name buffer
                    //

                    wcsncpy( s1, s, MaxTagNameLength );

                    //
                    //  Skip to the next tag name
                    //

                    while (*s++) { NOTHING; }

                    //
                    //  Skip to the next tag entry
                    //

                    TagEntry += 1;
                }
            }
        }

        Result = TagIndex << HEAP_TAG_SHIFT;

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller.  The answer we return is the last tag index
    //  stored in the high word of a ulong result
    //

    return Result;
}


//
//  Declared in nturtl.h
//

PWSTR
RtlQueryTagHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN USHORT TagIndex,
    IN BOOLEAN ResetCounters,
    OUT PRTL_HEAP_TAG_INFO TagInfo OPTIONAL
    )

/*++

Routine Description:

    This routine returns the name and optional statistics for a given
    tag index.

Arguments:

        **** note that some of the code looks like it can handle the
        **** global tag heap but other places look rather wrong

    HeapHandle - Specifies the heap being queried.  If null then the
        global tag heap is used.

    Flags - Supplies a set flags to augment those enforced by the
        heap

    TagIndex - Specifies the tag index that we want to query

    ResetCounter - Specifies if this routine should reset the counter
        for the tag after the query

    TagInfo - Optionally supplies storage where the output tag information
        should be stored

Return Value:

    PWSTR - Returns a pointer to the tag name or NULL if the index
        doesn't exist

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    PHEAP_TAG_ENTRY TagEntry;
    PWSTR Result;

    //
    //  Tagging is not part of the guard page heap package
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle, NULL );

    //
    //  Check if tagging is disabled
    //

    if (!IS_HEAP_TAGGING_ENABLED()) {

        return NULL;
    }

    try {

        //
        //  Check if the caller has given us a heap to query
        //

        if (Heap != NULL) {

            //
            //  Check if we should be using the debug version of the
            //  heap package
            //

            if (DEBUG_HEAP( Flags )) {

                Result = RtlDebugQueryTagHeap( HeapHandle, Flags, TagIndex, ResetCounters, TagInfo );
                leave;
            }

            //
            //  Lock the heap
            //

            Flags |= Heap->ForceFlags;

            if (!(Flags & HEAP_NO_SERIALIZE)) {

                RtlAcquireLockRoutine( Heap->LockVariable );

                LockAcquired = TRUE;
            }
        }

        Result = NULL;

        //
        //  **** note that the next test assumes that heap is not null
        //
        //  Check that the specified tag index is valid and that the
        //  this heap does actually have some tag entries
        //

        if ((TagIndex < Heap->NextAvailableTagIndex) &&
            (Heap->TagEntries != NULL)) {

            //
            //  Stride over to the specific tag entry and if the caller gave us
            //  an output buffer then fill in the details
            //

            TagEntry = Heap->TagEntries + TagIndex;

            if (ARGUMENT_PRESENT( TagInfo )) {

                TagInfo->NumberOfAllocations = TagEntry->Allocs;
                TagInfo->NumberOfFrees = TagEntry->Frees;
                TagInfo->BytesAllocated = TagEntry->Size << HEAP_GRANULARITY_SHIFT;
            }

            //
            //  Check if we should reset the counters
            //

            if (ResetCounters) {

                TagEntry->Allocs = 0;
                TagEntry->Frees = 0;
                TagEntry->Size = 0;
            }

            //
            //  Point to the tag name
            //

            Result = &TagEntry->TagName[ 0 ];

        //
        //  If the tag index has the psuedo tag bit set then recalulate the
        //  tag index and if this heap has pseudo tags than that is what
        //  we'll return
        //

        } else if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

            //
            //  Clear the bit
            //

            TagIndex ^= HEAP_PSEUDO_TAG_FLAG;

            if ((TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) &&
                (Heap->PseudoTagEntries != NULL)) {

                //
                //  Stride over to the specific pseudo tag entry and if the
                //  caller gave us an output buffer then fill in the details
                //

                TagEntry = (PHEAP_TAG_ENTRY)(Heap->PseudoTagEntries + TagIndex);

                if (ARGUMENT_PRESENT( TagInfo )) {

                    TagInfo->NumberOfAllocations = TagEntry->Allocs;
                    TagInfo->NumberOfFrees = TagEntry->Frees;
                    TagInfo->BytesAllocated = TagEntry->Size << HEAP_GRANULARITY_SHIFT;
                }

                //
                //  Check if we should reset the counters
                //

                if (ResetCounters) {

                    TagEntry->Allocs = 0;
                    TagEntry->Frees = 0;
                    TagEntry->Size = 0;
                }

                //
                //  Pseudo tags do not have names
                //

                Result = L"";
            }
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return the tag name to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

NTSTATUS
RtlExtendHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID Base,
    IN SIZE_T Size
    )

/*++

Routine Description:

    This routine grows the specified heap by adding a new segment to its
    storage.  The memory for the segment is supplied by the caller.

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags used to augment those already
        enforced by the heap

    Base - Supplies the starting address for the new segment being added
        to the input heap

    Size - Supplies the size, in bytes, of the new segment. Note that this
        routine will actually use more memory than specified by this
        variable.  It will use whatever is committed and reserved provided
        the amount is greater than or equal to "Size"

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    NTSTATUS Status;
    PHEAP_SEGMENT Segment;
    BOOLEAN LockAcquired = FALSE;
    UCHAR SegmentIndex, EmptySegmentIndex;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    ULONG SegmentFlags;
    PVOID CommittedBase;
    PVOID UnCommittedBase;
    MEMORY_BASIC_INFORMATION MemoryInformation;

    //
    //  Check if the guard page version of heap can do the work
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapExtend( HeapHandle, Flags, Base, Size ));

    //
    //  See what Mm thinks about the base address we were passed in.
    //  The address must not be free.
    //

    Status = NtQueryVirtualMemory( NtCurrentProcess(),
                                   Base,
                                   MemoryBasicInformation,
                                   &MemoryInformation,
                                   sizeof( MemoryInformation ),
                                   NULL );

    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    if (MemoryInformation.State == MEM_FREE) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  If what we were passed in as a base address is not on a page boundary then
    //  adjust the information supplied by MM to the page boundary right after
    //  the input base address
    //

    if (MemoryInformation.BaseAddress != Base) {

        MemoryInformation.BaseAddress = (PCHAR)MemoryInformation.BaseAddress + PAGE_SIZE;
        MemoryInformation.RegionSize -= PAGE_SIZE;
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Scan the heap's segment list for a free segment.  And make sure the address
        //  of all the segment does not contain the input base address
        //

        Status = STATUS_INSUFFICIENT_RESOURCES;

        EmptySegmentIndex = HEAP_MAXIMUM_SEGMENTS;

        for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

            Segment = Heap->Segments[ SegmentIndex ];

            if (Segment) {

                if (((ULONG_PTR)Base >= (ULONG_PTR)Segment) &&
                    ((ULONG_PTR)Base < (ULONG_PTR)(Segment->LastValidEntry))) {

                    Status = STATUS_INVALID_PARAMETER;

                    break;
                }

            } else if ((Segment == NULL) &&
                       (EmptySegmentIndex == HEAP_MAXIMUM_SEGMENTS)) {

                EmptySegmentIndex = SegmentIndex;

                Status = STATUS_SUCCESS;
            }
        }

        //
        //  At this point if status is success then the empty segment index
        //  is available for us to use and base address doesn't overlap an
        //  existing segment.
        //

        if (NT_SUCCESS( Status )) {

            //
            //  Indicate that this segment is user supplied
            //

            SegmentFlags = HEAP_SEGMENT_USER_ALLOCATED;

            CommittedBase = MemoryInformation.BaseAddress;

            //
            //  If the start of the memory supplied by the use is already
            //  committed then check the state of the following
            //  uncommitted piece of memory to see if it is reserved
            //

            if (MemoryInformation.State == MEM_COMMIT) {

                CommitSize = MemoryInformation.RegionSize;

                UnCommittedBase = (PCHAR)CommittedBase + CommitSize;

                Status = NtQueryVirtualMemory( NtCurrentProcess(),
                                               UnCommittedBase,
                                               MemoryBasicInformation,
                                               &MemoryInformation,
                                               sizeof( MemoryInformation ),
                                               NULL );

                ReserveSize = CommitSize;

                if ((NT_SUCCESS( Status )) &&
                    (MemoryInformation.State == MEM_RESERVE)) {

                    ReserveSize += MemoryInformation.RegionSize;
                }

            } else {

                //
                //  Otherwise the user hasn't committed anything in the
                //  the address they gave us and we know it is not free
                //  so it must be reserved.
                //

                UnCommittedBase = CommittedBase;

                ReserveSize = MemoryInformation.RegionSize;
            }

            //
            //  Now if the reserved size is smaller than a page size or
            //  the user specified size is greater than the reserved size
            //  then the buffer we're given is too small to be a segment
            //  of heap
            //

            if ((ReserveSize < PAGE_SIZE) ||
                (Size > ReserveSize)) {

                Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                //
                //  Otherwise the size is okay, now check if we need
                //  to do the commit of the base.  If so we'll commit
                //  one page

                if (UnCommittedBase == CommittedBase) {

                    CommitSize = PAGE_SIZE;

                    Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                                      (PVOID *)&Segment,
                                                      0,
                                                      &CommitSize,
                                                      MEM_COMMIT,
                                                      PAGE_READWRITE );
                }
            }

            //
            //  At this point the if status is good then memory is all set up
            //  with at least one page of committed memory to start with.  So
            //  initialize the heap segment and we're done.
            //

            if (NT_SUCCESS( Status )) {

                if (RtlpInitializeHeapSegment( Heap,
                                               Segment,
                                               EmptySegmentIndex,
                                               0,
                                               Segment,
                                               (PCHAR)Segment + CommitSize,
                                               (PCHAR)Segment + ReserveSize )) {

                    Status = STATUS_NO_MEMORY;
                }
            }
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Declared in nturtl.h
//

SIZE_T
NTAPI
RtlCompactHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine compacts the specified heap by coalescing all the free block.
    It also determines the size of the largest available free block and
    returns its, in bytes, back to the caller.

Arguments:

    HeapHandle - Supplies a pointer to the heap being modified

    Flags - Supplies a set of flags used to augment those already
        enforced by the heap

Return Value:

    SIZE_T - Returns the size, in bytes, of the largest free block
        available in the heap

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_FREE_ENTRY FreeBlock;
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    SIZE_T LargestFreeSize;
    BOOLEAN LockAcquired = FALSE;

    //
    //  Augment the heap flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if this is a debug version of heap
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugCompactHeap( HeapHandle, Flags );
    }

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        LargestFreeSize = 0;

        try {

            //
            //  Coalesce the heap into its largest free blocks possible
            //  and get the largest free block in the heap
            //

            FreeBlock = RtlpCoalesceHeap( (PHEAP)HeapHandle );

            //
            //  If there is a free block then compute its byte size
            //

            if (FreeBlock != NULL) {

                LargestFreeSize = FreeBlock->Size << HEAP_GRANULARITY_SHIFT;
            }

            //
            //  Scan every segment in the heap looking at its largest uncommitted
            //  range.  Remember the largest range if its bigger than anything
            //  we've found so far
            //

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                if (Segment && Segment->LargestUnCommittedRange > LargestFreeSize) {

                    LargestFreeSize = Segment->LargestUnCommittedRange;
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return the largest free size to our caller
    //

    return LargestFreeSize;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlValidateHeap (
    PVOID HeapHandle,
    IN ULONG Flags,
    IN PVOID BaseAddress
    )

/*++

Routine Description:

    This routine verifies the structure of a heap and/or heap block

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Flags - Supplies a set of flags used to augment those already
        enforced by the heap

    BaseAddress - Optionally supplies a pointer to the heap block
        that should be individually validated

Return Value:

    BOOLEAN - TRUE if the heap/block is okay and FALSE otherwise

--*/

{
    PHEAP Heap = (PHEAP)HeapHandle;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN Result;

    try {

        try {

            //
            //  Check for the guard page version of heap
            //

            if ( IS_DEBUG_PAGE_HEAP_HANDLE( HeapHandle )) {

                Result = RtlpDebugPageHeapValidate( HeapHandle, Flags, BaseAddress );

            } else {

                //
                //  If there is an active lookaside list then drain and remove it.
                //  By setting the lookaside field in the heap to null we guarantee
                //  that the call the free heap will not try and use the lookaside
                //  list logic.
                //
                //  We'll actually capture the lookaside pointer from the heap and
                //  only use the captured pointer.  This will take care of the
                //  condition where another walk or lock heap can cause us to check
                //  for a non null pointer and then have it become null when we read
                //  it again.  If it is non null to start with then even if the
                //  user walks or locks the heap via another thread the pointer to
                //  still valid here so we can still try and do a lookaside list pop.
                //

                PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)Heap->Lookaside;

                if (Lookaside != NULL) {

                    ULONG i;
                    PVOID Block;

                    Heap->Lookaside = NULL;

                    for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                        while ((Block = RtlpAllocateFromHeapLookaside(&(Lookaside[i]))) != NULL) {

                            RtlFreeHeap( HeapHandle, 0, Block );
                        }
                    }
                }

                Result = FALSE;

                //
                //  Validate that HeapAddress points to a HEAP structure.
                //

                if (RtlpCheckHeapSignature( Heap, "RtlValidateHeap" )) {

                    Flags |= Heap->ForceFlags;

                    //
                    //  Lock the heap
                    //

                    if (!(Flags & HEAP_NO_SERIALIZE)) {

                        RtlAcquireLockRoutine( Heap->LockVariable );

                        LockAcquired = TRUE;
                    }

                    //
                    //  If the user did not supply a base address then verify
                    //  the complete heap otherwise just do a single heap
                    //  entry
                    //

                    if (BaseAddress == NULL) {

                        Result = RtlpValidateHeap( Heap, TRUE );

                    } else {

                        Result = RtlpValidateHeapEntry( Heap, (PHEAP_ENTRY)BaseAddress - 1, "RtlValidateHeap" );
                    }
                }
            }

        } except( EXCEPTION_EXECUTE_HANDLER ) {

            SET_LAST_STATUS( GetExceptionCode() );

            Result = FALSE;
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

BOOLEAN
RtlValidateProcessHeaps (
    VOID
    )

/*++

Routine Description:

    This routine cycles through all and validates each heap in the current
    process.

Arguments:

    None.

Return Value:

    BOOLEAN - TRUE if all the heap verify okay and FALSE for any other
        reason.

--*/

{
    NTSTATUS Status;
    ULONG i, NumberOfHeaps;
    PVOID HeapsArray[ 512 ];
    PVOID *Heaps;
    SIZE_T Size;
    BOOLEAN Result;

    Result = TRUE;

    Heaps = &HeapsArray[ 0 ];

    //
    //  By default we can handle 512 heaps per process any more than
    //  that and we'll need to allocate storage to do the processing
    //
    //  So now determine how many heaps are in the current process
    //

    NumberOfHeaps = RtlGetProcessHeaps( 512, Heaps );

    //
    //  **** this is bogus because the preceeding routine will
    //  **** never return more than 512.  Either this routine
    //  **** needs to get the heap count from the peb itself
    //  **** or the called routine needs to return the actual
    //  **** number of heaps in the process, Then we have to know
    //  **** not to to beyond the heap array size
    //

    if (NumberOfHeaps > 512) {

        //
        //  The number of heaps is greater than 512 so
        //  allocate extra memory to store the array of
        //  heap pointers
        //

        Heaps = NULL;
        Size = NumberOfHeaps * sizeof( PVOID );

        Status = ZwAllocateVirtualMemory( NtCurrentProcess(),
                                          (PVOID *)&Heaps,
                                          0,
                                          &Size,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return FALSE;
        }

        //
        //  And retry getting the heaps
        //
        //  **** this won't work again because it still uses 512
        //

        NumberOfHeaps = RtlGetProcessHeaps( 512, Heaps );
    }

    //
    //  Now for each heap in our heap array we'll validate
    //  that heap
    //

    for (i=0; i<NumberOfHeaps; i++) {

        if (!RtlValidateHeap( Heaps[i], 0, NULL )) {

            Result = FALSE;
        }
    }

    //
    //  Check if we need to return the memory that we use for
    //  an enlarged heap array
    //

    if (Heaps != &HeapsArray[ 0 ]) {

        ZwFreeVirtualMemory( NtCurrentProcess(),
                             (PVOID *)&Heaps,
                             &Size,
                             MEM_RELEASE );
    }

    //
    //  And return to our caller
    //

    return Result;
}


//
//  Declared in nturtl.h
//

ULONG
RtlGetProcessHeaps (
    ULONG NumberOfHeapsToReturn,
    PVOID *ProcessHeaps
    )

/*++

Routine Description:

    This routine determines how many individual heaps there are in the
    current process and fills an array with pointers to each heap.

Arguments:

    NumberOfHeapsToReturn - Indicates how many heaps the caller
        is willing to accept in the second parameter

    ProcessHeaps - Supplies a pointer to an array of heap pointer
        to be filled in by this routine.  The maximum size of this
        array is specified by the first parameter

Return Value:

    ULONG - Returns the smaller of the actual number of heaps in the
        the process or the size of the output buffer

--*/

{
    PPEB Peb = NtCurrentPeb();
    ULONG NumberOfHeapsToCopy;
    ULONG TotalHeaps;

    RtlAcquireLockRoutine( &RtlpProcessHeapsListLock.Lock );

    try {

        //
        //  Return no more than the number of heaps currently in use
        //

        TotalHeaps = Peb->NumberOfHeaps;

        if (TotalHeaps > NumberOfHeapsToReturn) {

            NumberOfHeapsToCopy = NumberOfHeapsToReturn;

        } else {

            NumberOfHeapsToCopy = TotalHeaps;

        }

        //
        //  Return the heap pointers to the caller
        //

        RtlMoveMemory( ProcessHeaps,
                       Peb->ProcessHeaps,
                       NumberOfHeapsToCopy * sizeof( *ProcessHeaps ));

        ProcessHeaps += NumberOfHeapsToCopy;
        NumberOfHeapsToReturn -= NumberOfHeapsToCopy;

    } finally {

        RtlReleaseLockRoutine( &RtlpProcessHeapsListLock.Lock );
    }

#ifdef DEBUG_PAGE_HEAP

    //
    //  If we have debugging page heaps, go return what we can from them
    //

    if ( RtlpDebugPageHeap ) {

        TotalHeaps +=
            RtlpDebugPageHeapGetProcessHeaps( NumberOfHeapsToReturn, ProcessHeaps );

    }

#endif

    return TotalHeaps;
}


//
//  Declared in nturtl.h
//

NTSTATUS
RtlEnumProcessHeaps (
    PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
    PVOID Parameter
    )

/*++

Routine Description:

    This routine cycles through all the heaps in a process and
    invokes the specified call back routine for that heap

Arguments:

    EnumRoutine - Supplies the callback to invoke for each heap
        in the process

    Parameter - Provides an additional parameter to pass to the
        callback routine

Return Value:

    NTSTATUS - returns success or the first error status returned
        by the callback routine

--*/

{
    PPEB Peb = NtCurrentPeb();
    NTSTATUS Status;
    ULONG i;

    Status = STATUS_SUCCESS;

    //
    //  Lock the heap
    //

    RtlAcquireLockRoutine( &RtlpProcessHeapsListLock.Lock );

    try {

        //
        //  For each heap in the process invoke the callback routine
        //  and if the callback returns anything other than success
        //  then break out and return immediately to our caller
        //

        for (i=0; i<Peb->NumberOfHeaps; i++) {

            Status = (*EnumRoutine)( (PHEAP)(Peb->ProcessHeaps[ i ]), Parameter );

            if (!NT_SUCCESS( Status )) {

                break;
            }
        }

    } finally {

        //
        //  Unlock the heap
        //

        RtlReleaseLockRoutine( &RtlpProcessHeapsListLock.Lock );
    }

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Declared in nturtl.h
//

NTSTATUS
RtlUsageHeap (
    IN PVOID HeapHandle,
    IN ULONG Flags,
    IN OUT PRTL_HEAP_USAGE Usage
    )

/*++

Routine Description:

    This is a rather bizzare routine.  It models heap usage in that it returns
    to the caller the various heap sizes, but it also return three lists.  One
    is a list of entries for each active allocation in the heap.  The next two
    are used for tracking difference between usage calls.  There is a list of
    what was added and a list of what was removed.

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Flags - Supplies a set of flags needed to augment those enforced
        by the heap.

        HEAP_USAGE_ALLOCATED_BLOCKS - Denotes that the calls wants the list
            of allocated entries.

        HEAP_USAGE_FREE_BUFFER - Denotes the last call to this procedure and
            that any temporary storage can now be freed

    Usage - Receives the current usage statistics for the heap.  This variable
        is also used to store state information between calls to this routine.

Return Value:

    NTSTATUS - An appropriate status value.  STATUS_SUCCESS if the heap has
        not changed at all between calls and STATUS_MORE_ENTRIES if thep changed
        between two calls.

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PRTL_HEAP_USAGE_INTERNAL Buffer;
    PHEAP_SEGMENT Segment;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange;
    PHEAP_ENTRY CurrentBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    PLIST_ENTRY Head, Next;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;
    SIZE_T BytesFree;
    UCHAR SegmentIndex;
    BOOLEAN LockAcquired = FALSE;
    BOOLEAN VirtualAllocBlockSeen;
    PRTL_HEAP_USAGE_ENTRY pOldEntries, pNewEntries, pNewEntry;
    PRTL_HEAP_USAGE_ENTRY *ppEntries, *ppAddedEntries, *ppRemovedEntries, *pp;
    PVOID DataAddress;
    SIZE_T DataSize;

    //
    //  Augment the heap flags
    //

    Flags |= Heap->ForceFlags;

    //
    //  Check if we should be using the debug version of heap
    //

    if (DEBUG_HEAP( Flags )) {

        return RtlDebugUsageHeap( HeapHandle, Flags, Usage );
    }

    //
    //  Make sure that the size of the input buffer is correct
    //

    if (Usage->Length != sizeof( RTL_HEAP_USAGE )) {

        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    //  Zero out the output fields
    //

    Usage->BytesAllocated = 0;
    Usage->BytesCommitted = 0;
    Usage->BytesReserved = 0;
    Usage->BytesReservedMaximum = 0;

    //
    //  Use the reserved area of the output buffer as an internal
    //  heap usage storage space between calls
    //

    Buffer = (PRTL_HEAP_USAGE_INTERNAL)&Usage->Reserved[ 0 ];

    //
    //  Check if there is not a base buffer and we should allocate
    //  one then do so now
    //

    if ((Buffer->Base == NULL) &&
        (Flags & HEAP_USAGE_ALLOCATED_BLOCKS)) {

        Buffer->ReservedSize = 4 * 1024 * 1024;

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &Buffer->Base,
                                          0,
                                          &Buffer->ReservedSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        Buffer->CommittedSize = 0;
        Buffer->FreeList = NULL;
        Buffer->LargeEntriesSentinal = NULL;

    //
    //  Otherwise check if there already is a base buffer
    //  and we should free it now
    //

    } else if ((Buffer->Base != NULL) &&
               (Flags & HEAP_USAGE_FREE_BUFFER)) {

        Buffer->ReservedSize = 0;

        Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                      &Buffer->Base,
                                      &Buffer->ReservedSize,
                                      MEM_RELEASE );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        RtlZeroMemory( Buffer, sizeof( *Buffer ) );
    }

    //
    //  **** Augment the heap flags again
    //

    Flags |= Heap->ForceFlags;

    try {

        //
        //  Lock the heap
        //

        if (!(Flags & HEAP_NO_SERIALIZE)) {

            RtlAcquireLockRoutine( Heap->LockVariable );

            LockAcquired = TRUE;
        }

        //
        //  Scan through the heap segments and for every in-use segment
        //  we add it to the amount of committed and reserved bytes
        //  If the segment is not in use and the heap is growable then
        //  we just add it to the reserved maximum
        //

        for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

            Segment = Heap->Segments[ SegmentIndex ];

            if (Segment) {

                Usage->BytesCommitted += (Segment->NumberOfPages -
                                          Segment->NumberOfUnCommittedPages) * PAGE_SIZE;

                Usage->BytesReserved += Segment->NumberOfPages * PAGE_SIZE;

            } else if (Heap->Flags & HEAP_GROWABLE) {

                Usage->BytesReservedMaximum += Heap->SegmentReserve;
            }
        }

        Usage->BytesReservedMaximum += Usage->BytesReserved;
        Usage->BytesAllocated = Usage->BytesCommitted - (Heap->TotalFreeSize << HEAP_GRANULARITY_SHIFT);

        //
        //  Scan through the big allocations and add those amounts to the
        //  usage statistics
        //

        Head = &Heap->VirtualAllocdBlocks;
        Next = Head->Flink;

        while (Head != Next) {

            VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

            Usage->BytesAllocated += VirtualAllocBlock->CommitSize;
            Usage->BytesCommitted += VirtualAllocBlock->CommitSize;

            Next = Next->Flink;
        }

        Status = STATUS_SUCCESS;

        //
        //  Now check if we have a base buffer and we are suppose to account
        //  for allocated blocks
        //

        if ((Buffer->Base != NULL) &&
            (Flags & HEAP_USAGE_ALLOCATED_BLOCKS)) {

            //
            //  Setup a pointer to the old entries, added entries, and removed
            //  entries in the usage struct.  Also drain the added entries
            //  and removed entries list
            //

            pOldEntries = Usage->Entries;

            ppEntries = &Usage->Entries;

            *ppEntries = NULL;

            ppAddedEntries = &Usage->AddedEntries;

            while (*ppAddedEntries = RtlpFreeHeapUsageEntry( Buffer, *ppAddedEntries )) { NOTHING; }

            ppRemovedEntries = &Usage->RemovedEntries;

            while (*ppRemovedEntries = RtlpFreeHeapUsageEntry( Buffer, *ppRemovedEntries )) { NOTHING; }

            //
            //  The way the code works is that ppEntries, ppAddedEntries, and
            //  ppRemovedEntries point to the tail of their respective lists.  If
            //  the list is empty then they point to the head.
            //

            //
            //  Process every segment in the heap
            //

            for (SegmentIndex=0; SegmentIndex<HEAP_MAXIMUM_SEGMENTS; SegmentIndex++) {

                Segment = Heap->Segments[ SegmentIndex ];

                //
                //  Only deal with segments that are in use
                //

                if (Segment) {

                    //
                    //  The current block is really the first block in current
                    //  segment.  We need to special case the computation to
                    //  account for the first heap segment.
                    //

                    if (Segment->BaseAddress == Heap) {

                        CurrentBlock = &Heap->Entry;

                    } else {

                        CurrentBlock = &Segment->Entry;
                    }

                    //
                    //  Now for every busy block in the segment we'll check if
                    //  we need to allocate a heap usage entry and put it in the
                    //  the entries list
                    //

                    while (CurrentBlock < Segment->LastValidEntry) {

                        if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {

                            //
                            //  Compute the users data address and size
                            //

                            DataAddress = (CurrentBlock+1);
                            DataSize = (CurrentBlock->Size << HEAP_GRANULARITY_SHIFT) -
                                       CurrentBlock->UnusedBytes;

    keepLookingAtOldEntries:

                            //
                            //  The first time through this routine will have
                            //  both of these variables null so we'll start off
                            //  by looking at new entries.
                            //

                            if (pOldEntries == Buffer->LargeEntriesSentinal) {

                                goto keepLookingAtNewEntries;
                            }

                            //
                            //  Check if this entry hasn't changed.
                            //
                            //  If the old entry is equal to this data block
                            //  then move the old entry back to the entries
                            //  list and go on to the next block.
                            //

                            if ((pOldEntries->Address == DataAddress) &&
                                (pOldEntries->Size == DataSize)) {

                                //
                                //  Same block, keep in entries list
                                //

                                *ppEntries = pOldEntries;
                                pOldEntries = pOldEntries->Next;
                                ppEntries = &(*ppEntries)->Next;

                                *ppEntries = NULL;

                            //
                            //  Check if an entry was removed
                            //
                            //  If this entry is beyond the old entry then move
                            //  the old entry to the removed entry list and keep
                            //  looking at the old entry list without advancing
                            //  the current data block
                            //

                            } else if (pOldEntries->Address <= DataAddress) {

                                *ppRemovedEntries = pOldEntries;
                                pOldEntries = pOldEntries->Next;
                                ppRemovedEntries = &(*ppRemovedEntries)->Next;

                                *ppRemovedEntries = NULL;

                                goto keepLookingAtOldEntries;

                            //
                            //  Otherwise the we want to process the current data block
                            //

                            } else {

    keepLookingAtNewEntries:

                                //
                                //  Allocate a new heap usage entry
                                //

                                pNewEntry = NULL;

                                Status = RtlpAllocateHeapUsageEntry( Buffer, &pNewEntry );

                                if (!NT_SUCCESS( Status )) {

                                    break;
                                }

                                //
                                //  And fill in the new entry
                                //

                                pNewEntry->Address = DataAddress;
                                pNewEntry->Size = DataSize;

                                //
                                //  If there is an extra stuff struct then fill it in
                                //  with the stack backtrace, and appropriate tag index
                                //

                                if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                                    ExtraStuff = RtlpGetExtraStuffPointer( CurrentBlock );

    #if i386

                                    pNewEntry->AllocatorBackTraceIndex = ExtraStuff->AllocatorBackTraceIndex;

    #endif // i386

                                    if (!IS_HEAP_TAGGING_ENABLED()) {

                                        pNewEntry->TagIndex = 0;

                                    } else {

                                        pNewEntry->TagIndex = ExtraStuff->TagIndex;
                                    }

                                } else {

                                    //
                                    //  Otherwise there is no extra stuff so there is
                                    //  no backtrace and the tag is from the small index
                                    //

    #if i386

                                    pNewEntry->AllocatorBackTraceIndex = 0;

    #endif // i386

                                    if (!IS_HEAP_TAGGING_ENABLED()) {

                                        pNewEntry->TagIndex = 0;

                                    } else {

                                        pNewEntry->TagIndex = CurrentBlock->SmallTagIndex;
                                    }
                                }

                                //
                                //  Allocate another new heap usage entry as part of the added
                                //  entry list
                                //

                                Status = RtlpAllocateHeapUsageEntry( Buffer, ppAddedEntries );

                                if (!NT_SUCCESS( Status )) {

                                    break;
                                }

                                //
                                //  Copy over the contents of the new entry to the added entry
                                //

                                **ppAddedEntries = *pNewEntry;

                                //
                                //  Advance the added entry pointer to the next slot
                                //

                                ppAddedEntries = &((*ppAddedEntries)->Next);

                                *ppAddedEntries = NULL;

                                pNewEntry->Next = NULL;

                                //
                                //  Add the new entry to the entries list
                                //

                                *ppEntries = pNewEntry;
                                ppEntries = &pNewEntry->Next;
                            }
                        }

                        //
                        //  Now advance to the next block in the segment
                        //
                        //  If the next block doesn't exist then zoom through the
                        //  uncommitted ranges in the segment until we find a
                        //  match and can recompute the next real block
                        //

                        if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                            CurrentBlock += CurrentBlock->Size;

                            if (CurrentBlock < Segment->LastValidEntry) {

                                UnCommittedRange = Segment->UnCommittedRanges;

                                while ((UnCommittedRange != NULL) &&
                                       (UnCommittedRange->Address != (ULONG_PTR)CurrentBlock)) {

                                    UnCommittedRange = UnCommittedRange->Next;
                                }

                                if (UnCommittedRange == NULL) {

                                    CurrentBlock = Segment->LastValidEntry;

                                } else {

                                    CurrentBlock = (PHEAP_ENTRY)(UnCommittedRange->Address +
                                                                 UnCommittedRange->Size);
                                }
                            }

                        } else {

                            //
                            //  Otherwise the next block exists and so point
                            //  directly at it
                            //

                            CurrentBlock += CurrentBlock->Size;
                        }
                    }
                }
            }

            //
            //  At this point we've scanned through every segment in the heap
            //
            //  The first time through we now have two lists one of entries and
            //  another of added entries.  In each case Usage->Entries, and
            //  Usage->AddedEntries points to the start of the list and ppEntries,
            //  and ppAddedEntries points to the tail of the list.  The first
            //  time through we has seem to have a one-to-one correspondence
            //  between Entries and AddedEntries, but the AddedEntries records
            //  do not contain anything useful
            //

            if (NT_SUCCESS( Status )) {

                //
                //  Now we'll examine each big allocation, and for each big allocation
                //  we'll make a heap usage entry
                //

                Head = &Heap->VirtualAllocdBlocks;
                Next = Head->Flink;
                VirtualAllocBlockSeen = FALSE;

                while (Head != Next) {

                    VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

                    //
                    //  Allocate a new heap usage entry
                    //

                    pNewEntry = NULL;

                    Status = RtlpAllocateHeapUsageEntry( Buffer, &pNewEntry );

                    if (!NT_SUCCESS( Status )) {

                        break;
                    }

                    VirtualAllocBlockSeen = TRUE;

                    //
                    //  Fill in the new heap usage entry
                    //

                    pNewEntry->Address = (VirtualAllocBlock + 1);
                    pNewEntry->Size = VirtualAllocBlock->CommitSize - VirtualAllocBlock->BusyBlock.Size;

    #if i386

                    pNewEntry->AllocatorBackTraceIndex = VirtualAllocBlock->ExtraStuff.AllocatorBackTraceIndex;

    #endif // i386

                    if (!IS_HEAP_TAGGING_ENABLED()) {

                        pNewEntry->TagIndex = 0;

                    } else {

                        pNewEntry->TagIndex = VirtualAllocBlock->ExtraStuff.TagIndex;
                    }

                    //
                    //  Search the heap usage entries list until we find the address
                    //  that right after the new entry address and then insert
                    //  this new entry.  This will keep the entries list sorted in
                    //  assending addresses
                    //
                    //
                    //  The first time through this function ppEntries will point
                    //  to the tail and so *pp should actually start off as null,
                    //  which means that the big allocation simply get tacked on
                    //  the end of the entries list.  We do not augment the
                    //  AddedEntries list for these big allocations.
                    //

                    pp = ppEntries;

                    while (*pp) {

                        if ((*pp)->Address >= pNewEntry->Address) {

                            break;
                        }

                        pp = &(*pp)->Next;
                    }

                    pNewEntry->Next = *pp;
                    *pp = pNewEntry;

                    //
                    //  Get the next big allocation block
                    //

                    Next = Next->Flink;
                }

                //
                //  At this point we've scanned through the heap segments and the
                //  big allocations.
                //
                //  The first time through this procedure we have built two lists
                //  the Entries and the AddedEntries
                //

                if (NT_SUCCESS( Status )) {

                    pOldEntries = Buffer->LargeEntriesSentinal;
                    Buffer->LargeEntriesSentinal = *ppEntries;

                    //
                    //  Now we'll process the previous large entries sentinal list
                    //
                    //  This path is not taken the first time through this procedure
                    //

                    while (pOldEntries != NULL) {

                        //
                        //  If we have new entries and the entry is equal to the
                        //  entry in the previous large sentinal list then
                        //  we move one down on the new list and remove the previous
                        //  sentinal entry
                        //

                        if ((*ppEntries != NULL) &&
                            (pOldEntries->Address == (*ppEntries)->Address) &&
                            (pOldEntries->Size == (*ppEntries)->Size)) {

                            ppEntries = &(*ppEntries)->Next;

                            pOldEntries = RtlpFreeHeapUsageEntry( Buffer, pOldEntries );

                        //
                        //  If we do now have any new entries or the previous
                        //  sentinal entry is comes before this new entry then
                        //  we'll add the sentinal entry to the remove list
                        //

                        } else if ((*ppEntries == NULL) ||
                                   (pOldEntries->Address < (*ppEntries)->Address)) {

                            *ppRemovedEntries = pOldEntries;

                            pOldEntries = pOldEntries->Next;

                            ppRemovedEntries = &(*ppRemovedEntries)->Next;

                            *ppRemovedEntries = NULL;

                        //
                        //  Otherwise the old sentinal entry is put on the added
                        //  entries list
                        //

                        } else {

                            *ppAddedEntries = pOldEntries;

                            pOldEntries = pOldEntries->Next;

                            **ppAddedEntries = **ppEntries;

                            ppAddedEntries = &(*ppAddedEntries)->Next;

                            *ppAddedEntries = NULL;
                        }
                    }

                    //
                    //  This path is not taken the first time through this procedure
                    //

                    while (pNewEntry = *ppEntries) {

                        Status = RtlpAllocateHeapUsageEntry( Buffer, ppAddedEntries );

                        if (!NT_SUCCESS( Status )) {

                            break;
                        }

                        **ppAddedEntries = *pNewEntry;

                        ppAddedEntries = &(*ppAddedEntries)->Next;

                        *ppAddedEntries = NULL;

                        ppEntries = &pNewEntry->Next;
                    }

                    //
                    //  Tell the user that something has changed between the
                    //  previous call and this one
                    //

                    if ((Usage->AddedEntries != NULL) || (Usage->RemovedEntries != NULL)) {

                        Status = STATUS_MORE_ENTRIES;
                    }
                }
            }
        }

    } finally {

        //
        //  Unlock the heap
        //

        if (LockAcquired) {

            RtlReleaseLockRoutine( Heap->LockVariable );
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Declared in nturtl.h
//

NTSTATUS
RtlWalkHeap (
    IN PVOID HeapHandle,
    IN OUT PRTL_HEAP_WALK_ENTRY Entry
    )

/*++

Routine Description:

    This routine is used to enumerate all the entries within a heap.  For each
    call it returns a new information in entry.

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

    Entry - Supplies storage for the entry information.  If the DataAddress field
        is null then the enumeration starts over from the beginning otherwise it
        resumes from where it left off

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status;
    PHEAP Heap = (PHEAP)HeapHandle;
    PHEAP_SEGMENT Segment;
    UCHAR SegmentIndex;
    PHEAP_ENTRY CurrentBlock;
    PHEAP_ENTRY_EXTRA ExtraStuff;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRange, *pp;
    PLIST_ENTRY Next, Head;
    PHEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocBlock;

    //
    //  Check if we should be using the guard page verion of heap
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapWalk( HeapHandle, Entry ));

    //
    //  If this is the debug version of heap then validate the heap
    //  before we go on
    //

    if (DEBUG_HEAP( Heap->Flags )) {

        if (!RtlDebugWalkHeap( HeapHandle, Entry )) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    Status = STATUS_SUCCESS;

    //
    //  If there is an active lookaside list then drain and remove it.
    //  By setting the lookaside field in the heap to null we guarantee
    //  that the call the free heap will not try and use the lookaside
    //  list logic.
    //
    //  We'll actually capture the lookaside pointer from the heap and
    //  only use the captured pointer.  This will take care of the
    //  condition where another walk or lock heap can cause us to check
    //  for a non null pointer and then have it become null when we read
    //  it again.  If it is non null to start with then even if the
    //  user walks or locks the heap via another thread the pointer to
    //  still valid here so we can still try and do a lookaside list pop.
    //

    {
        PHEAP_LOOKASIDE Lookaside = (PHEAP_LOOKASIDE)Heap->Lookaside;

        if (Lookaside != NULL) {

            ULONG i;
            PVOID Block;

            Heap->Lookaside = NULL;

            for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i += 1) {

                while ((Block = RtlpAllocateFromHeapLookaside(&(Lookaside[i]))) != NULL) {

                    RtlFreeHeap( HeapHandle, 0, Block );
                }
            }
        }
    }

    //
    //  Check if this is the first time we've been called to walk the heap
    //

    if (Entry->DataAddress == NULL) {

        //
        //  Start with the first segement in the heap
        //

        SegmentIndex = 0;

nextSegment:

        CurrentBlock = NULL;

        //
        //  Now find the next in use segment for the heap
        //

        Segment = NULL;

        while ((SegmentIndex < HEAP_MAXIMUM_SEGMENTS) &&
               ((Segment = Heap->Segments[ SegmentIndex ]) == NULL)) {

            SegmentIndex += 1;
        }

        //
        //  If there are no more valid segments then we'll try the big
        //  allocation
        //

        if (Segment == NULL) {

            Head = &Heap->VirtualAllocdBlocks;
            Next = Head->Flink;

            if (Next == Head) {

                Status = STATUS_NO_MORE_ENTRIES;

            } else {

                VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

                CurrentBlock = &VirtualAllocBlock->BusyBlock;
            }

        //
        //  Otherwise we'll grab information about the segment.  Note that
        //  the current block is still null so when we fall out of this
        //  block we'll return directly to our caller with this segment
        //  information
        //

        } else {

            Entry->DataAddress = Segment;

            Entry->DataSize = 0;

            Entry->OverheadBytes = sizeof( *Segment );

            Entry->Flags = RTL_HEAP_SEGMENT;

            Entry->SegmentIndex = SegmentIndex;

            Entry->Segment.CommittedSize = (Segment->NumberOfPages -
                                            Segment->NumberOfUnCommittedPages) * PAGE_SIZE;

            Entry->Segment.UnCommittedSize = Segment->NumberOfUnCommittedPages * PAGE_SIZE;

            Entry->Segment.FirstEntry = (Segment->FirstEntry->Flags & HEAP_ENTRY_BUSY) ?
                ((PHEAP_ENTRY)Segment->FirstEntry + 1) :
                (PHEAP_ENTRY)((PHEAP_FREE_ENTRY)Segment->FirstEntry + 1);

            Entry->Segment.LastEntry = Segment->LastValidEntry;
        }

    //
    //  This is not the first time through.  Check if last time we gave back
    //  an heap segement or an uncommitted range
    //

    } else if (Entry->Flags & (RTL_HEAP_SEGMENT | RTL_HEAP_UNCOMMITTED_RANGE)) {

        //
        //  Check that the segment index is still valid
        //

        if ((SegmentIndex = Entry->SegmentIndex) >= HEAP_MAXIMUM_SEGMENTS) {

            Status = STATUS_INVALID_ADDRESS;

            CurrentBlock = NULL;

        } else {

            //
            //  Check that the segment is still in use
            //

            Segment = Heap->Segments[ SegmentIndex ];

            if (Segment == NULL) {

                Status = STATUS_INVALID_ADDRESS;

                CurrentBlock = NULL;

            //
            //  The segment is still in use if what we returned last time
            //  as the segment header then this time we'll return the
            //  segments first entry
            //

            } else if (Entry->Flags & RTL_HEAP_SEGMENT) {

                CurrentBlock = (PHEAP_ENTRY)Segment->FirstEntry;

            //
            //  Otherwise what we returned last time as an uncommitted
            //  range so now we need to get the next block
            //

            } else {

                CurrentBlock = (PHEAP_ENTRY)((PCHAR)Entry->DataAddress + Entry->DataSize);

                //
                //  Check if we are beyond this segment and need to get the
                //  next one
                //

                if (CurrentBlock >= Segment->LastValidEntry) {

                    SegmentIndex += 1;

                    goto nextSegment;
                }
            }
        }

    //
    //  Otherwise this is not the first time through and last time we gave back a
    //  valid heap entry
    //

    } else {

        //
        //  Check if the last entry we gave back was in use
        //

        if (Entry->Flags & HEAP_ENTRY_BUSY) {

            //
            //  Get the last entry we returned
            //

            CurrentBlock = ((PHEAP_ENTRY)Entry->DataAddress - 1);

            //
            //  If the last entry was for a big allocation then
            //  get the next big block if there is one otherwise
            //  say there are no more entries
            //

            if (CurrentBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                Head = &Heap->VirtualAllocdBlocks;

                VirtualAllocBlock = CONTAINING_RECORD( CurrentBlock, HEAP_VIRTUAL_ALLOC_ENTRY, BusyBlock );

                Next = VirtualAllocBlock->Entry.Flink;

                if (Next == Head) {

                    Status = STATUS_NO_MORE_ENTRIES;

                } else {

                    VirtualAllocBlock = CONTAINING_RECORD( Next, HEAP_VIRTUAL_ALLOC_ENTRY, Entry );

                    CurrentBlock = &VirtualAllocBlock->BusyBlock;
                }

            //
            //  Our previous result is a busy normal block
            //

            } else {

                //
                //  Get the segment and make sure it it still valid and in use
                //
                //  **** this should also check that segment index is not
                //  **** greater than HEAP MAXIMUM SEGMENTS
                //

                Segment = Heap->Segments[ SegmentIndex = CurrentBlock->SegmentIndex ];

                if (Segment == NULL) {

                    Status = STATUS_INVALID_ADDRESS;

                    CurrentBlock = NULL;

                //
                //  The segment is still in use, check if what we returned
                //  previously was a last entry
                //

                } else if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

findUncommittedRange:

                    //
                    //  We are at a last entry so now if the segment is done
                    //  then go get another segment
                    //

                    CurrentBlock += CurrentBlock->Size;

                    if (CurrentBlock >= Segment->LastValidEntry) {

                        SegmentIndex += 1;

                        goto nextSegment;
                    }

                    //
                    //  Otherwise we will find the uncommitted range entry that
                    //  immediately follows this last entry
                    //

                    pp = &Segment->UnCommittedRanges;

                    while ((UnCommittedRange = *pp) && UnCommittedRange->Address != (ULONG_PTR)CurrentBlock ) {

                        pp = &UnCommittedRange->Next;
                    }

                    if (UnCommittedRange == NULL) {

                        Status = STATUS_INVALID_PARAMETER;

                    } else {

                        //
                        //  Now fill in the entry to denote that uncommitted
                        //  range information
                        //

                        Entry->DataAddress = (PVOID)UnCommittedRange->Address;

                        Entry->DataSize = UnCommittedRange->Size;

                        Entry->OverheadBytes = 0;

                        Entry->SegmentIndex = SegmentIndex;

                        Entry->Flags = RTL_HEAP_UNCOMMITTED_RANGE;
                    }

                    //
                    //  Null out the current block because we've just filled in
                    //  the entry
                    //

                    CurrentBlock = NULL;

                } else {

                    //
                    //  Otherwise the entry has a following entry so now
                    //  advance to the next entry
                    //

                    CurrentBlock += CurrentBlock->Size;
                }
            }

        //
        //  Otherwise the previous entry we returned is not in use
        //

        } else {

            //
            //  Get the last entry we returned
            //

            CurrentBlock = (PHEAP_ENTRY)((PHEAP_FREE_ENTRY)Entry->DataAddress - 1);

            //
            //  Get the segment and make sure it it still valid and in use
            //
            //  **** this should also check that segment index is not
            //  **** greater than HEAP MAXIMUM SEGMENTS
            //

            Segment = Heap->Segments[ SegmentIndex = CurrentBlock->SegmentIndex ];

            if (Segment == NULL) {

                Status = STATUS_INVALID_ADDRESS;

                CurrentBlock = NULL;

            //
            //  If the block is the last entry then go find the next uncommitted
            //  range or segment
            //

            } else if (CurrentBlock->Flags & HEAP_ENTRY_LAST_ENTRY) {

                goto findUncommittedRange;

            //
            //  Otherwise we'll just move on to the next entry
            //

            } else {

                CurrentBlock += CurrentBlock->Size;
            }
        }
    }

    //
    //  At this point if current block is not null then we've found another
    //  entry to return.  We could also have found a segment or uncommitted
    //  range but those are handled separately above and keep current block
    //  null
    //

    if (CurrentBlock != NULL) {

        //
        //  Check if the block is in use
        //

        if (CurrentBlock->Flags & HEAP_ENTRY_BUSY) {

            //
            //  Fill in the entry field for this block
            //

            Entry->DataAddress = (CurrentBlock+1);

            if (CurrentBlock->Flags & HEAP_ENTRY_VIRTUAL_ALLOC) {

                Entry->DataSize = RtlpGetSizeOfBigBlock( CurrentBlock );

                Entry->OverheadBytes = (UCHAR)( sizeof( *VirtualAllocBlock ) + CurrentBlock->Size);

                Entry->SegmentIndex = HEAP_MAXIMUM_SEGMENTS;

                Entry->Flags = RTL_HEAP_BUSY |  HEAP_ENTRY_VIRTUAL_ALLOC;

            } else {

                Entry->DataSize = (CurrentBlock->Size << HEAP_GRANULARITY_SHIFT) -
                                  CurrentBlock->UnusedBytes;

                Entry->OverheadBytes = CurrentBlock->UnusedBytes;

                Entry->SegmentIndex = CurrentBlock->SegmentIndex;

                Entry->Flags = RTL_HEAP_BUSY;
            }

            if (CurrentBlock->Flags & HEAP_ENTRY_EXTRA_PRESENT) {

                ExtraStuff = RtlpGetExtraStuffPointer( CurrentBlock );

                Entry->Block.Settable = ExtraStuff->Settable;
#if i386

                Entry->Block.AllocatorBackTraceIndex = ExtraStuff->AllocatorBackTraceIndex;

#endif // i386

                if (!IS_HEAP_TAGGING_ENABLED()) {

                    Entry->Block.TagIndex = 0;

                } else {

                    Entry->Block.TagIndex = ExtraStuff->TagIndex;
                }

                Entry->Flags |= RTL_HEAP_SETTABLE_VALUE;

            } else {

                if (!IS_HEAP_TAGGING_ENABLED()) {

                    Entry->Block.TagIndex = 0;

                } else {

                    Entry->Block.TagIndex = CurrentBlock->SmallTagIndex;
                }
            }

            Entry->Flags |= CurrentBlock->Flags & HEAP_ENTRY_SETTABLE_FLAGS;

        //
        //  Otherwise the block is not in use
        //

        } else {

            Entry->DataAddress = ((PHEAP_FREE_ENTRY)CurrentBlock+1);

            Entry->DataSize = (CurrentBlock->Size << HEAP_GRANULARITY_SHIFT) -
                              sizeof( HEAP_FREE_ENTRY );

            Entry->OverheadBytes = sizeof( HEAP_FREE_ENTRY );

            Entry->SegmentIndex = CurrentBlock->SegmentIndex;

            Entry->Flags = 0;
        }
    }

    //
    //  And return to our caller
    //

    return Status;
}


//
//  Declared in heappriv.h
//

BOOLEAN
RtlpCheckHeapSignature (
    IN PHEAP Heap,
    IN PCHAR Caller
    )

/*++

Routine Description:

    This routine verifies that it is being called with a properly identified
    heap.

Arguments:

    Heap - Supplies a pointer to the heap being checked

    Caller - Supplies a string that can be used to identify the caller

Return Value:

    BOOLEAN - TRUE if the heap signature is present, and FALSE otherwise

--*/

{
    //
    //  If the heap signature matches then that is the only
    //  checking we do
    //

    if (Heap->Signature == HEAP_SIGNATURE) {

        return TRUE;

    } else {

        //
        //  We have a bad heap signature.  Print out some information, break
        //  into the debugger, and then return false
        //

        HeapDebugPrint(( "Invalid heap signature for heap at %x", Heap ));

        if (Caller != NULL) {

            DbgPrint( ", passed to %s", Caller );
        }

        DbgPrint( "\n" );

        HeapDebugBreak( &Heap->Signature );

        return FALSE;
    }
}


//
//  Declared in heappriv.h
//

PHEAP_FREE_ENTRY
RtlpCoalesceHeap (
    IN PHEAP Heap
    )

/*++

Routine Description:

    This routine scans through heap and coalesces its free blocks

Arguments:

    Heap - Supplies a pointer to the heap being modified

Return Value:

    PHEAP_FREE_ENTRY - returns a pointer to the largest free block
        in the heap

--*/

{
    SIZE_T OldFreeSize;
    SIZE_T FreeSize;
    ULONG n;
    PHEAP_FREE_ENTRY FreeBlock, LargestFreeBlock;
    PLIST_ENTRY FreeListHead, Next;

    RTL_PAGED_CODE();

    LargestFreeBlock = NULL;

    //
    //  For every free list in the heap, going from smallest to
    //  largest and skipping the zero index one we will
    //  scan the free list coalesceing the free blocks
    //

    FreeListHead = &Heap->FreeLists[ 1 ];

    n = HEAP_MAXIMUM_FREELISTS;

    while (n--) {

        //
        //  Scan the individual free list
        //

        Next = FreeListHead->Blink;

        while (FreeListHead != Next) {

            //
            //  Get a pointer to the current free list entry, and remember its
            //  next and size
            //

            FreeBlock = CONTAINING_RECORD( Next, HEAP_FREE_ENTRY, FreeList );

            Next = Next->Flink;
            OldFreeSize = FreeSize = FreeBlock->Size;

            //
            //  Coalesce the block
            //

            FreeBlock = RtlpCoalesceFreeBlocks( Heap,
                                                FreeBlock,
                                                &FreeSize,
                                                TRUE );

            //
            //  If the new free size is not equal to the old free size
            //  then we actually did some changes otherwise the coalesce
            //  calll was essentialy a noop
            //

            if (FreeSize != OldFreeSize) {

                //
                //  Check if we should decommit this block because it is too
                //  large and it is either at the beginning or end of a
                //  committed run.  Otherwise just insert the new sized
                //  block into its corresponding free list.  We'll hit this
                //  block again when we visit larger free lists.
                //

                if (FreeBlock->Size >= (PAGE_SIZE >> HEAP_GRANULARITY_SHIFT)

                        &&

                    (FreeBlock->PreviousSize == 0 ||
                     (FreeBlock->Flags & HEAP_ENTRY_LAST_ENTRY))) {

                    RtlpDeCommitFreeBlock( Heap, FreeBlock, FreeSize );

                } else {

                    RtlpInsertFreeBlock( Heap, FreeBlock, FreeSize );
                }

                Next = FreeListHead->Blink;

            } else {

                //
                //  Remember the largest free block we've found so far
                //

                if ((LargestFreeBlock == NULL) ||
                    (LargestFreeBlock->Size < FreeBlock->Size)) {

                    LargestFreeBlock = FreeBlock;
                }
            }
        }

        //
        //  Go to the next free list.  When we hit the largest dedicated
        //  size free list we'll fall back to the [0] index list
        //

        if (n == 1) {

            FreeListHead = &Heap->FreeLists[ 0 ];

        } else {

            FreeListHead++;
        }
    }

    //
    //  And return to our caller
    //

    return LargestFreeBlock;
}


//
//  Declared in heappriv.h
//

VOID
RtlpAddHeapToProcessList (
    IN PHEAP Heap
    )

/*++

Routine Description:

    This routine adds the specified heap to the heap list for the
    current process

Arguments:

    Heap - Supplies a pointer to the heap being added

Return Value:

    None.

--*/

{
    PPEB Peb = NtCurrentPeb();
    PHEAP *NewList;

    //
    //  Lock the processes heap list
    //

    RtlAcquireLockRoutine( &RtlpProcessHeapsListLock.Lock );

    try {

        //
        //  If the processes heap list is already full then we'll
        //  double the size of the heap list for the process
        //

        if (Peb->NumberOfHeaps == Peb->MaximumNumberOfHeaps) {

            //
            //  Double the size
            //

            Peb->MaximumNumberOfHeaps *= 2;

            //
            //  Allocate space for the new list
            //

            NewList = RtlAllocateHeap( RtlProcessHeap(),
                                       0,
                                       Peb->MaximumNumberOfHeaps * sizeof( *NewList ));

            if (NewList == NULL) {

                leave;
            }

            //
            //  Copy over the old buffer to the new buffer
            //

            RtlMoveMemory( NewList,
                           Peb->ProcessHeaps,
                           Peb->NumberOfHeaps * sizeof( *NewList ));

            //
            //  Check if we should free the previous heap list buffer
            //

            if (Peb->ProcessHeaps != RtlpProcessHeapsListBuffer) {

                RtlFreeHeap( RtlProcessHeap(), 0, Peb->ProcessHeaps );
            }

            //
            //  Set the new list
            //

            Peb->ProcessHeaps = NewList;
        }

        //
        //  Add the input heap to the next free heap list slot, and note that
        //  the processes heap list index is really one beyond the actualy
        //  index used to get the processes heap
        //

        Peb->ProcessHeaps[ Peb->NumberOfHeaps++ ] = Heap;
        Heap->ProcessHeapsListIndex = (USHORT)Peb->NumberOfHeaps;

    } finally {

        //
        //  Unlock the processes heap list
        //

        RtlReleaseLockRoutine( &RtlpProcessHeapsListLock.Lock );
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Delcared in heappriv.h
//

VOID
RtlpRemoveHeapFromProcessList (
    IN PHEAP Heap
    )

/*++

Routine Description:

    This routine removes the specified heap to the heap list for the
    current process

Arguments:

    Heap - Supplies a pointer to the heap being removed

Return Value:

    None.

--*/

{
    PPEB Peb = NtCurrentPeb();
    PHEAP *p, *p1;
    ULONG n;

    //
    //  Lock the current processes heap list lock
    //

    RtlAcquireLockRoutine( &RtlpProcessHeapsListLock.Lock );

    try {

        //
        //  We only want to the the work if the current process actually has some
        //  heaps, the index stored in the heap is within the range for active
        //  heaps.  Note that the heaps stored index is bias by one.
        //

        if ((Peb->NumberOfHeaps != 0) &&
            (Heap->ProcessHeapsListIndex != 0) &&
            (Heap->ProcessHeapsListIndex <= Peb->NumberOfHeaps)) {

            //
            //  Establish a pointer into the array of process heaps at the
            //  current heap location and one beyond
            //

            p = (PHEAP *)&Peb->ProcessHeaps[ Heap->ProcessHeapsListIndex - 1 ];

            p1 = p + 1;

            //
            //  Calculate the number of heaps that exist beyond the current
            //  heap in the array including the current heap location
            //

            n = Peb->NumberOfHeaps - (Heap->ProcessHeapsListIndex - 1);

            //
            //  For every heap beyond the current one that we are removing
            //  we'll move that heap down to the previous index.
            //

            while (--n) {

                //
                //  Copy the heap process array entry of the next entry to
                //  the current entry, and move p1 to the next next entry
                //

                *p = *p1++;

                //
                //  This is simply a debugging call
                //

                RtlpUpdateHeapListIndex( (*p)->ProcessHeapsListIndex,
                                         (USHORT)((*p)->ProcessHeapsListIndex - 1));

                //
                //  Assign the moved heap its new heap index
                //

                (*p)->ProcessHeapsListIndex -= 1;

                //
                //  Move on to the next heap entry
                //

                p += 1;
            }

            //
            //  Zero out the last process heap pointer, update the count, and
            //  make the heap we just removed realize it has been removed by
            //  zeroing out its process heap list index
            //

            Peb->ProcessHeaps[ --Peb->NumberOfHeaps ] = NULL;
            Heap->ProcessHeapsListIndex = 0;
        }

    } finally {

        //
        //  Unlock the current processes heap list lock
        //

        RtlReleaseLockRoutine( &RtlpProcessHeapsListLock.Lock );
    }

    return;
}



//
//  Local support routine
//

PHEAP_TAG_ENTRY
RtlpAllocateTags (
    PHEAP Heap,
    ULONG NumberOfTags
    )

/*++

Routine Description:

    This routine is used to allocate space for additional tags within
    a heap

Arguments:

    Heap - Supplies a pointer to the heap being modified.  If not specified
        then the processes global tag heap is used

    NumberOfTags - Supplies the number of tags that we want stored in the
        heap.  This is the number to grow the tag list by.

Return Value:

    PHEAP_TAG_ENTRY - Returns a pointer to the next available tag entry in the
        heap

--*/

{
    NTSTATUS Status;
    ULONG TagIndex;
    SIZE_T ReserveSize;
    SIZE_T CommitSize;
    PHEAP_TAG_ENTRY TagEntry;
    USHORT CreatorBackTraceIndex;
    USHORT MaximumTagIndex;
    USHORT TagIndexFlag;

    //
    //  Check if the process has a global tag heap.  If not then there is
    //  nothing for us to do
    //

    if (RtlpGlobalTagHeap == NULL) {

        return NULL;
    }

    //
    //  If the user didn't give us a heap then use the processes global
    //  tag heap
    //

    if (Heap == NULL) {

        RtlpGlobalTagHeap->Signature = HEAP_SIGNATURE;

        RtlpGlobalTagHeap->Flags = HEAP_NO_SERIALIZE;

        TagIndexFlag = HEAP_GLOBAL_TAG;

        Heap = RtlpGlobalTagHeap;

    } else {

        TagIndexFlag = 0;
    }

    //
    //  Grab the stack backtrace if possible and if we should
    //

    CreatorBackTraceIndex = 0;

#if i386

    if (Heap->Flags & HEAP_CAPTURE_STACK_BACKTRACES) {

        CreatorBackTraceIndex = (USHORT)RtlLogStackBackTrace();
    }

#endif // i386

    //
    //  If the heap does not already have tag entries then we'll
    //  reserve space for them
    //

    if (Heap->TagEntries == NULL) {

        MaximumTagIndex = HEAP_MAXIMUM_TAG & ~HEAP_GLOBAL_TAG;

        ReserveSize = MaximumTagIndex * sizeof( HEAP_TAG_ENTRY );

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &Heap->TagEntries,
                                          0,
                                          &ReserveSize,
                                          MEM_RESERVE,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return NULL;
        }

        Heap->MaximumTagIndex = MaximumTagIndex;

        Heap->NextAvailableTagIndex = 0;

        //
        // Add one for zero tag, as that is always reserved for heap name
        //

        NumberOfTags += 1;
    }

    //
    //  At this point we have a space reserved for tag entries.  If the number
    //  of tags that we need to grow is too large then tell the user we can't
    //  do it.
    //

    if (NumberOfTags > (ULONG)(Heap->MaximumTagIndex - Heap->NextAvailableTagIndex)) {

        return NULL;
    }

    //
    //  Get a pointer to the next available tag entry, and for
    //  every tag entry that we want to grow by we'll commit
    //  the page containing the tag entry.  We only need to do
    //  this for every page just once.  We'll determine this
    //  by seeing when the tag entry crosses a page boundary
    //

    TagEntry = Heap->TagEntries + Heap->NextAvailableTagIndex;

    for (TagIndex = Heap->NextAvailableTagIndex;
         TagIndex < Heap->NextAvailableTagIndex + NumberOfTags;
         TagIndex++ ) {

        if (((((ULONG_PTR)TagEntry + sizeof(*TagEntry)) & (PAGE_SIZE-1)) <=
            sizeof(*TagEntry))) {

            CommitSize = PAGE_SIZE;

            Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                              &TagEntry,
                                              0,
                                              &CommitSize,
                                              MEM_COMMIT,
                                              PAGE_READWRITE );

            if (!NT_SUCCESS( Status )) {

                return NULL;
            }
        }

        //
        //  Bias the tag index if this is the global tag heap
        //

        TagEntry->TagIndex = (USHORT)TagIndex | TagIndexFlag;

        //
        //  Set the stack back trace
        //

        TagEntry->CreatorBackTraceIndex = CreatorBackTraceIndex;

        //
        //  Move on to the next tag entry
        //

        TagEntry += 1;
    }

    //
    //  At this point we've build the new tag list so now pop off the next
    //  available tag entry
    //

    TagEntry = Heap->TagEntries + Heap->NextAvailableTagIndex;

    Heap->NextAvailableTagIndex += (USHORT)NumberOfTags;

    //
    //  And return to our caller
    //

    return TagEntry;
}


//
//  Declared in heappriv.h
//

PWSTR
RtlpGetTagName (
    PHEAP Heap,
    USHORT TagIndex
    )

/*++

Routine Description:

    This routine returns the name of the tag denoted by the heap, tagindex
    tuple.

    This routine is only called by heapdbg when doing a debug print to
    generate a tag name for printing

Arguments:

    Heap - Supplies the tag being queried

    TagIndex - Supplies the index for the tag being queried

Return Value:

    PWSTR - returns the name of the indicated tag

--*/

{
    //
    //  If the processes global tag heap has not been initialized then
    //  not tag has a name
    //

    if (RtlpGlobalTagHeap == NULL) {

        return NULL;
    }

    //
    //  We only deal with non zero tag indices
    //

    if (TagIndex != 0) {

        //
        //  If the tag index is for a pseudo tag then we clear the
        //  the psuedo bit and generate a pseudo tag name
        //

        if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

            TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

            //
            //  Check that the tag index is valid and that the heap
            //  has some psuedo tag entries
            //

            if ((TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) &&
                (Heap->PseudoTagEntries != NULL)) {

                //
                //  A pseudo tag index of zero denote objects
                //

                if (TagIndex == 0) {

                    swprintf( RtlpPseudoTagNameBuffer, L"Objects>%4u",
                              HEAP_MAXIMUM_FREELISTS << HEAP_GRANULARITY_SHIFT );

                //
                //  A psuedo tag index less than the free list maximum
                //  denotes the dedicated free list
                //

                } else if (TagIndex < HEAP_MAXIMUM_FREELISTS) {

                    swprintf( RtlpPseudoTagNameBuffer, L"Objects=%4u", TagIndex << HEAP_GRANULARITY_SHIFT );

                //
                //  Otherwise the pseudo tag is for the big allocations
                //

                } else {

                    swprintf( RtlpPseudoTagNameBuffer, L"VirtualAlloc" );
                }

                return RtlpPseudoTagNameBuffer;
            }

        //
        //  Otherwise if the tag index is for a global tag then we pull
        //  the name off of the global heap.  Provided the index is valid
        //  and the heap does have some tag entries
        //

        } else if (TagIndex & HEAP_GLOBAL_TAG) {

            TagIndex &= ~HEAP_GLOBAL_TAG;

            if ((TagIndex < RtlpGlobalTagHeap->NextAvailableTagIndex) &&
                (RtlpGlobalTagHeap->TagEntries != NULL)) {

                return RtlpGlobalTagHeap->TagEntries[ TagIndex ].TagName;
            }

        //
        //  Otherwise we'll pull the name off of the input heap
        //  provided the index is valid and the heap does have some
        //  tag entries
        //

        } else if ((TagIndex < Heap->NextAvailableTagIndex) &&
                   (Heap->TagEntries != NULL)) {

            return Heap->TagEntries[ TagIndex ].TagName;
        }
    }

    return NULL;
}


//
//  Declared in heappriv.h
//

USHORT
RtlpUpdateTagEntry (
    PHEAP Heap,
    USHORT TagIndex,
    SIZE_T OldSize,              // Only valid for ReAllocation and Free actions
    SIZE_T NewSize,              // Only valid for ReAllocation and Allocation actions
    HEAP_TAG_ACTION Action
    )

/*++

Routine Description:

    This routine is used to modify a tag entry

Arguments:

    Heap - Supplies a pointer to the heap being modified

    TagIndex - Supplies the tag being modified

    OldSize - Supplies the old allocation index of the block associated with the tag

    NewSize - Supplies the new allocation index of the block associated with the tag

    Action - Supplies the type of action being performed on the heap tag

Return Value:

    USHORT - Returns a tag index for the newly updated tag

--*/

{
    PHEAP_TAG_ENTRY TagEntry;

    //
    //  If the processes tag heap does not exist then we'll return a zero index
    //  right away
    //

    if (RtlpGlobalTagHeap == NULL) {

        return 0;
    }

    //
    //  If the action is greater than or equal to free action then it is
    //  either FreeAction, VirtualFreeAction, ReAllocationAction, or
    //  VirtualReAllocationAction.  Which means we already should have a tag
    //  that is simply being modified
    //

    if (Action >= FreeAction) {

        //
        //  If the tag index is zero then there is nothing for us to do
        //

        if (TagIndex == 0) {

            return 0;
        }

        //
        //  If this is a pseudo tag then make sure the rest of the tag index
        //  after we remove the psuedo bit is valid and that the heap is
        //  actually maintaining pseudo tags
        //

        if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

            TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;

            if ((TagIndex < HEAP_NUMBER_OF_PSEUDO_TAG) &&
                (Heap->PseudoTagEntries != NULL)) {

                TagEntry = (PHEAP_TAG_ENTRY)(Heap->PseudoTagEntries + TagIndex);

                TagIndex |= HEAP_PSEUDO_TAG_FLAG;

            } else {

                return 0;
            }

        //
        //  Otherwise if this is a global tag then make sure the tag index
        //  after we remove the global bit is valid and that the global tag
        //  heap has some tag entries
        //

        } else if (TagIndex & HEAP_GLOBAL_TAG) {

            TagIndex &= ~HEAP_GLOBAL_TAG;

            if ((TagIndex < RtlpGlobalTagHeap->NextAvailableTagIndex) &&
                (RtlpGlobalTagHeap->TagEntries != NULL)) {

                TagEntry = &RtlpGlobalTagHeap->TagEntries[ TagIndex ];

                TagIndex |= HEAP_GLOBAL_TAG;

            } else {

                return 0;
            }

        //
        //  Otherwise we have a regular tag index that we need to make sure
        //  is a valid value and that the heap has some tag entries
        //

        } else if ((TagIndex < Heap->NextAvailableTagIndex) &&
                   (Heap->TagEntries != NULL)) {

            TagEntry = &Heap->TagEntries[ TagIndex ];

        } else {

            return 0;
        }

        //
        //  At this point we have a tag entry and tag index.  Increment the
        //  number of frees we've done on the tag, and decrement the size by
        //  the number of bytes we've just freed
        //

        TagEntry->Frees += 1;

        TagEntry->Size -= OldSize;

        //
        //  Now if the action is either ReAllocationAction or
        //  VirtualReAllocationAction.  Then we get to add back in the
        //  new size and the allocation count
        //

        if (Action >= ReAllocationAction) {

            //
            //  If the this is a pseudo tag then we tag entry goes off the
            //  pseudo tag list
            //

            if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {

                TagIndex = (USHORT)(NewSize < HEAP_MAXIMUM_FREELISTS ?
                                        NewSize :
                                        (Action == VirtualReAllocationAction ? HEAP_MAXIMUM_FREELISTS : 0));

                TagEntry = (PHEAP_TAG_ENTRY)(Heap->PseudoTagEntries + TagIndex);

                TagIndex |= HEAP_PSEUDO_TAG_FLAG;
            }

            TagEntry->Allocs += 1;

            TagEntry->Size += NewSize;
        }

    //
    //  The action is either AllocationAction or VirtualAllocationAction
    //

    } else {

        //
        //  Check if the supplied tag index is a regular tag and that it is
        //  valid for the tags in this heap
        //

        if ((TagIndex != 0) &&
            (TagIndex < Heap->NextAvailableTagIndex) &&
            (Heap->TagEntries != NULL)) {

            TagEntry = &Heap->TagEntries[ TagIndex ];

        //
        //  Otherwise if this is a global tag then make sure that it is a
        //  valid global index
        //

        } else if (TagIndex & HEAP_GLOBAL_TAG) {

            TagIndex &= ~HEAP_GLOBAL_TAG;

            Heap = RtlpGlobalTagHeap;

            if ((TagIndex < Heap->NextAvailableTagIndex) &&
                (Heap->TagEntries != NULL)) {

                TagEntry = &Heap->TagEntries[ TagIndex ];

                TagIndex |= HEAP_GLOBAL_TAG;

            } else {

                return 0;
            }

        //
        //  Otherwise if this is a pseudo tag then build a valid tag index
        //  based on the new size of the allocation
        //

        } else if (Heap->PseudoTagEntries != NULL) {

            TagIndex = (USHORT)(NewSize < HEAP_MAXIMUM_FREELISTS ?
                                    NewSize :
                                    (Action == VirtualAllocationAction ? HEAP_MAXIMUM_FREELISTS : 0));

            TagEntry = (PHEAP_TAG_ENTRY)(Heap->PseudoTagEntries + TagIndex);

            TagIndex |= HEAP_PSEUDO_TAG_FLAG;

        //
        //  Otherwise the user didn't call us with a valid tag
        //

        } else {

            return 0;
        }

        //
        //  At this point we have a valid tag entry and tag index, so
        //  update the tag entry state to reflect this new allocation
        //

        TagEntry->Allocs += 1;

        TagEntry->Size += NewSize;
    }

    //
    //  And return to our caller with the new tag index
    //

    return TagIndex;
}


//
//  Declared in heappriv.h
//

VOID
RtlpResetTags (
    PHEAP Heap
    )

/*++

Routine Description:

    This routine is used to reset all the tag entries in a heap

Arguments:

    Heap - Supplies a pointer to the heap being modified

Return Value:

    None.

--*/

{
    PHEAP_TAG_ENTRY TagEntry;
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntry;
    ULONG i;

    //
    //  We only have work to do if the heap has any allocated tag entries
    //

    TagEntry = Heap->TagEntries;

    if (TagEntry != NULL) {

        //
        //  For every tag entry in the heap we will zero out its counters
        //

        for (i=0; i<Heap->NextAvailableTagIndex; i++) {

            TagEntry->Allocs = 0;
            TagEntry->Frees = 0;
            TagEntry->Size = 0;

            //
            //  Advance to the next tag entry
            //

            TagEntry += 1;
        }
    }

    //
    //  We will only reset the pseudo tags if they exist
    //

    PseudoTagEntry = Heap->PseudoTagEntries;

    if (PseudoTagEntry != NULL) {

        //
        //  For every pseudo tag entry in the heap we will zero out its
        //  counters
        //

        for (i=0; i<HEAP_NUMBER_OF_PSEUDO_TAG; i++) {

            PseudoTagEntry->Allocs = 0;
            PseudoTagEntry->Frees = 0;
            PseudoTagEntry->Size = 0;

            //
            //  Advance to the next pseudo tag entry
            //

            PseudoTagEntry += 1;
        }
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Declared in heappriv.h
//

VOID
RtlpDestroyTags (
    PHEAP Heap
    )

/*++

Routine Description:

    This routine is used to completely remove all the normal tag entries
    in use by a heap

Arguments:

    Heap - Supplies a pointer to the heap being modified

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    SIZE_T RegionSize;

    //
    //  We will only do the action if the heap has some tag entries
    //

    if (Heap->TagEntries != NULL) {

        //
        //  Release all the memory used by the tag entries
        //

        RegionSize = 0;

        Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                      &Heap->TagEntries,
                                      &RegionSize,
                                      MEM_RELEASE );

        if (NT_SUCCESS( Status )) {

            Heap->TagEntries = NULL;
        }
    }

    //
    //  And return to our caller
    //

    return;
}


//
//  Local support routine
//

NTSTATUS
RtlpAllocateHeapUsageEntry (
    PRTL_HEAP_USAGE_INTERNAL Buffer,
    PRTL_HEAP_USAGE_ENTRY *pp
    )

/*++

Routine Description:

    This routine is used to allocate an new heap usage entry
    from the internal heap usage buffer

Arguments:

    Buffer - Supplies a pointer to the internal heap usage
        buffer from which to allocate an entry

    pp - Receives a pointer to the newly allocated heap
        usage entry.  If pp is already pointing to an existing
        heap usage entry then on return we'll have this old
        entry point to the new entry, but still return the new
        entry.

Return Value:

    NTSTATUS - An appropriate status value

--*/

{
    NTSTATUS Status;
    PRTL_HEAP_USAGE_ENTRY p;
    PVOID CommitAddress;
    SIZE_T PageSize;

    //
    //  Check if the free list is empty and then we have to allocate more
    //  memory for the free list
    //

    if (Buffer->FreeList == NULL) {

        //
        //  We cannot grow the buffer any larger than the reserved size
        //

        if (Buffer->CommittedSize >= Buffer->ReservedSize) {

            return STATUS_NO_MEMORY;
        }

        //
        //  Try and add one page of committed memory to the buffer
        //  starting right after the currently committed space
        //

        PageSize = PAGE_SIZE;

        CommitAddress = (PCHAR)Buffer->Base + Buffer->CommittedSize;

        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &CommitAddress,
                                          0,
                                          &PageSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE );

        if (!NT_SUCCESS( Status )) {

            return Status;
        }

        //
        //  Update the committed buffer size
        //

        Buffer->CommittedSize += PageSize;

        //
        //  Add the newly allocated space to the free list and
        //  build up the free list
        //

        Buffer->FreeList = CommitAddress;

        p = Buffer->FreeList;

        while (PageSize != 0) {

            p->Next = (p+1);
            p += 1;
            PageSize -= sizeof( *p );
        }

        //
        //  Null terminate the next pointer in the last free entry
        //

        p -= 1;
        p->Next = NULL;
    }

    //
    //  At this point the free list contains at least one entry
    //  so simply pop the entry.
    //

    p = Buffer->FreeList;

    Buffer->FreeList = p->Next;

    p->Next = NULL;

    //
    //  Now if the caller supplied an existing heap entry then
    //  we'll make the old heap entry point to this new entry
    //

    if (*pp) {

        (*pp)->Next = p;
    }

    //
    //  And then return the new entry to our caller
    //

    *pp = p;

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

PRTL_HEAP_USAGE_ENTRY
RtlpFreeHeapUsageEntry (
    PRTL_HEAP_USAGE_INTERNAL Buffer,
    PRTL_HEAP_USAGE_ENTRY p
    )

/*++

Routine Description:

    This routine moves a heap usage entry from its current
    list onto the free list and returns a pointer to the
    next heap usage entry in the list.  It is like doing a pop
    of the list denoted by "p"

Arguments:

    Buffer - Supplies a pointer to the internal heap usage buffer
        being modified

    p - Supplies a pointer to the entry being moved.  Okay if
        it's null

Return Value:

    PRTL_HEAP_USAGE_ENTRY - Returns a pointer to the next heap usage
        entry

--*/

{
    PRTL_HEAP_USAGE_ENTRY pTmp;

    //
    //  Check if we have a non null heap entry and if so then add
    //  the entry to the front of the free list and return the next
    //  entry in the list
    //

    if (p != NULL) {

        pTmp = p->Next;

        p->Next = Buffer->FreeList;

        Buffer->FreeList = p;

    } else {

        pTmp = NULL;
    }

    return pTmp;
}


//
//  Declared in heap.h
//

BOOLEAN
RtlpHeapIsLocked (
    IN PVOID HeapHandle
    )

/*++

Routine Description:

    This routine is used to determine if a heap is locked

Arguments:

    HeapHandle - Supplies a pointer to the heap being queried

Return Value:

    BOOLEAN - TRUE if the heap is locked and FALSE otherwise

--*/

{
    PHEAP Heap;

    //
    //  Check if this is guard page version of heap
    //

    IF_DEBUG_PAGE_HEAP_THEN_RETURN( HeapHandle,
                                    RtlpDebugPageHeapIsLocked( HeapHandle ));

    Heap = (PHEAP)HeapHandle;

    //
    //  The heap is locked if there is a lock variable, and it has an
    //  owning thread or the lockcount is not -1
    //

    return (( Heap->LockVariable != NULL ) &&
            ( Heap->LockVariable->Lock.CriticalSection.OwningThread ||
              Heap->LockVariable->Lock.CriticalSection.LockCount != -1 ));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\heappagi.h ===
//
//  heappagi.h
//
//  The following definitions are internal to the debug heap manager,
//  but are placed in this include file so that debugger extensions
//  can reference the same structure definitions.  The following
//  definitions are not intended to be referenced externally except
//  by debugger extensions.
//

#ifndef _HEAP_PAGE_I_
#define _HEAP_PAGE_I_

#ifdef DEBUG_PAGE_HEAP

#include "heap.h"

#define DPH_INTERNAL_DEBUG      0   // change to 0 or #undef for production code

#define DPH_MAX_STACK_LENGTH   20

//
// Capture stacktraces in any context (x86/alpha, fre/chk). On alpha
// the stack acquisition function will fail and no stack trace will be
// acquired but in case we will find a better algorithm the page heap
// code will automatically take advantage of that.
//

#define DPH_CAPTURE_STACK_TRACE 1

//
// Page Heap Global Flags
//
// These flags are kept in a global variable that can be set from
// debugger. During heap creation these flags are stored in a per heap
// structure and control the behavior of that particular heap.
//
// PAGE_HEAP_ENABLE_PAGE_HEAP
//
//     This flag is set by default. It means that page heap allocations
//     should be used always. The flag is useful if we want to use page
//     heap only for certain heaps and stick with normal heaps for the
//     others.
//
// PAGE_HEAP_COLLECT_STACK_TRACES
//
//     This flag is disabled in free builds and enabled in checked builds.
//     If it is set the page heap manager will collect stack traces for
//     all important events (create, alloc, free, etc.).    
//
// PAGE_HEAP_MINIMIZE_MEMORY_IMPACT
//
//     This flags is disabled by default. If it is set then if the
//     memory available is less than 50% of total memory the allocation
//     will be done in a normal heap instead of page heap. Special care
//     is taken during free operations to figure out from what kind of
//     heap the block came.
//
// PAGE_HEAP_VERIFY_RANDOMLY
//
//     This is used in conjuction with MinimizeMemoryImpact flag.
//     It forces only a certain amount of allocations (randomly chosen)
//     into page heap. The probability is specified in the most significant
//     byte of the RtlpDebugPageHeapGlobalFlags.
//          
//     If the bit is reset and MinimizeMemoryImpact flag is set
//     it forces only a certain amount of allocations (with size in range)
//     into page heap. The range ([start..end]) is specified in the first
//     two most significant bytes of RtlpDebugPageHeapGlobalFlags.
//
//     For both cases the third byte (bits 15-8) represent the percentage
//     of available memory below which allocations will be done in normal heap
//     independent of other criteria.
//
// PAGE_HEAP_CATCH_BACKWARD_OVERRUNS
//
//     Places the NA page at the beginning of the block.
//

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_MINIMIZE_MEMORY_IMPACT    0x0004
#define PAGE_HEAP_VERIFY_RANDOMLY           0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010

//
// `RtlpDebugPageHeapGlobalFlags' stores the global page heap flags.
// The value of this variable is copied into the per heap
// flags (ExtraFlags field) during heap creation.
//

extern ULONG RtlpDebugPageHeapGlobalFlags;

//
// DPH_STACK_TRACE_NODE
//

#if DPH_CAPTURE_STACK_TRACE

typedef struct _DPH_STACK_TRACE_NODE DPH_STACK_TRACE_NODE, *PDPH_STACK_TRACE_NODE;

struct _DPH_STACK_TRACE_NODE {

    PDPH_STACK_TRACE_NODE Left;         //  B-tree on Hash
    PDPH_STACK_TRACE_NODE Right;        //  B-tree on Hash

    ULONG                 Hash;         //  simple sum of PVOIDs in stack trace
    SIZE_T                Length;       //  number of PVOIDs in stack trace

    ULONG                 BusyCount;    //  number of busy allocations
    SIZE_T                BusyBytes;    //  total user size of busy allocations

    PVOID                 Address[ 0 ]; //  variable length array of addresses
};

#endif // DPH_CAPTURE_STACK_TRACE

//
// DPH_HEAP_ALLOCATION
//

typedef struct _DPH_HEAP_ALLOCATION DPH_HEAP_ALLOCATION, *PDPH_HEAP_ALLOCATION;

struct _DPH_HEAP_ALLOCATION {

    //
    //  Singly linked list of allocations (pNextAlloc must be
    //  first member in structure).
    //

    PDPH_HEAP_ALLOCATION pNextAlloc;

    //
    //   | PAGE_READWRITE          | PAGE_NOACCESS           |
    //   |____________________|___||_________________________|
    //
    //   ^pVirtualBlock       ^pUserAllocation
    //
    //   |---------------- nVirtualBlockSize ----------------|
    //
    //   |---nVirtualAccessSize----|
    //
    //                        |---|  nUserRequestedSize
    //
    //                        |----|  nUserActualSize
    //

    PUCHAR pVirtualBlock;
    SIZE_T  nVirtualBlockSize;

    SIZE_T  nVirtualAccessSize;
    PUCHAR pUserAllocation;
    SIZE_T  nUserRequestedSize;
    SIZE_T  nUserActualSize;
    PVOID  UserValue;
    ULONG  UserFlags;

#if DPH_CAPTURE_STACK_TRACE

    PDPH_STACK_TRACE_NODE pStackTrace;

#endif

    };


typedef struct _DPH_HEAP_ROOT DPH_HEAP_ROOT, *PDPH_HEAP_ROOT;

struct _DPH_HEAP_ROOT {

    //
    //  Maintain a signature (DPH_HEAP_ROOT_SIGNATURE) as the
    //  first value in the heap root structure.
    //

    ULONG                 Signature;
    ULONG                 HeapFlags;

    //
    //  Access to this heap is synchronized with a critical section.
    //

    PRTL_CRITICAL_SECTION HeapCritSect;
    ULONG                 nRemoteLockAcquired;

    //
    //  The "VirtualStorage" list only uses the pVirtualBlock,
    //  nVirtualBlockSize, and nVirtualAccessSize fields of the
    //  HEAP_ALLOCATION structure.  This is the list of virtual
    //  allocation entries that all the heap allocations are
    //  taken from.
    //

    PDPH_HEAP_ALLOCATION  pVirtualStorageListHead;
    PDPH_HEAP_ALLOCATION  pVirtualStorageListTail;
    ULONG                 nVirtualStorageRanges;
    SIZE_T                 nVirtualStorageBytes;

    //
    //  The "Busy" list is the list of active heap allocations.
    //  It is stored in LIFO order to improve temporal locality
    //  for linear searches since most initial heap allocations
    //  tend to remain permanent throughout a process's lifetime.
    //

    PDPH_HEAP_ALLOCATION  pBusyAllocationListHead;
    PDPH_HEAP_ALLOCATION  pBusyAllocationListTail;
    ULONG                 nBusyAllocations;
    SIZE_T                 nBusyAllocationBytesCommitted;

    //
    //  The "Free" list is the list of freed heap allocations, stored
    //  in FIFO order to increase the length of time a freed block
    //  remains on the freed list without being used to satisfy an
    //  allocation request.  This increases the odds of catching
    //  a reference-after-freed bug in an app.
    //

    PDPH_HEAP_ALLOCATION  pFreeAllocationListHead;
    PDPH_HEAP_ALLOCATION  pFreeAllocationListTail;
    ULONG                 nFreeAllocations;
    SIZE_T                 nFreeAllocationBytesCommitted;

    //
    //  The "Available" list is stored in address-sorted order to facilitate
    //  coalescing.  When an allocation request cannot be satisfied from the
    //  "Available" list, it is attempted from the free list.  If it cannot
    //  be satisfied from the free list, the free list is coalesced into the
    //  available list.  If the request still cannot be satisfied from the
    //  coalesced available list, new VM is added to the available list.
    //

    PDPH_HEAP_ALLOCATION  pAvailableAllocationListHead;
    PDPH_HEAP_ALLOCATION  pAvailableAllocationListTail;
    ULONG                 nAvailableAllocations;
    SIZE_T                 nAvailableAllocationBytesCommitted;

    //
    //  The "UnusedNode" list is simply a list of available node
    //  entries to place "Busy", "Free", or "Virtual" entries.
    //  When freed nodes get coalesced into a single free node,
    //  the other "unused" node goes on this list.  When a new
    //  node is needed (like an allocation not satisfied from the
    //  free list), the node comes from this list if it's not empty.
    //

    PDPH_HEAP_ALLOCATION  pUnusedNodeListHead;
    PDPH_HEAP_ALLOCATION  pUnusedNodeListTail;
    ULONG                 nUnusedNodes;

    SIZE_T                 nBusyAllocationBytesAccessible;

    //
    //  Node pools need to be tracked so they can be protected
    //  from app scribbling on them.
    //

    PDPH_HEAP_ALLOCATION  pNodePoolListHead;
    PDPH_HEAP_ALLOCATION  pNodePoolListTail;
    ULONG                 nNodePools;
    SIZE_T                 nNodePoolBytes;

    //
    //  Doubly linked list of DPH heaps in process is tracked through this.
    //

    PDPH_HEAP_ROOT        pNextHeapRoot;
    PDPH_HEAP_ROOT        pPrevHeapRoot;

    ULONG                 nUnProtectionReferenceCount;
    ULONG                 InsideAllocateNode;           // only for debugging

#if DPH_CAPTURE_STACK_TRACE

    PUCHAR                pStackTraceStorage;
    SIZE_T                nStackTraceStorage;

    PDPH_STACK_TRACE_NODE pStackTraceRoot;              // B-tree root
    PDPH_STACK_TRACE_NODE pStackTraceCreator;

    SIZE_T                nStackTraceBytesCommitted;
    SIZE_T                nStackTraceBytesWasted;

    SIZE_T                nStackTraceBNodes;
    SIZE_T                nStackTraceBDepth;
    SIZE_T                nStackTraceBHashCollisions;

#endif // DPH_CAPTURE_STACK_TRACE

    //
    // These are extra flags used to control page heap behavior.
    // During heap creation the current value of the global page heap
    // flags (process wise) is written into this field.
    //

    ULONG                 ExtraFlags;

    //
    // Seed for the random generator used to decide from where
    // should we make an allocation (normal or verified heap).
    // The field is protected by the critical section associated
    // with each page heap.
    //

    ULONG                  Seed;
    ULONG                  Counter[5];

    //
    // `NormalHeap' is used in case we want to combine verified allocations
    // with normal ones. This is useful to minimize memory impact. Without
    // this feature certain processes that are very heap intensive cannot
    // be verified at all.
    //

    PVOID                 NormalHeap;
    };


#endif // DEBUG_PAGE_HEAP

#endif // _HEAP_PAGE_I_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\imagedir.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imagedir.c

Abstract:

    The module contains the code to translate an image directory type to
    the address of the data for that entry.

Author:

    Steve Wood (stevewo) 18-Aug-1989

Environment:

    User Mode or Kernel Mode

Revision History:

--*/

#include "ntrtlp.h"

PIMAGE_NT_HEADERS
RtlImageNtHeader (
    IN PVOID Base
    )

/*++

Routine Description:

    This function returns the address of the NT Header.

Arguments:

    Base - Supplies the base of the image.

Return Value:

    Returns the address of the NT Header.

--*/

{
#if defined (BLDR_KERNEL_RUNTIME) || defined(NTOS_KERNEL_RUNTIME)
    PIMAGE_NT_HEADERS NtHeaders = NULL;

    if (Base != NULL && Base != (PVOID)-1) {
        if (((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) {
            NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);

#if defined(NTOS_KERNEL_RUNTIME)
            if (Base < MM_HIGHEST_USER_ADDRESS) {
                if ((PVOID)NtHeaders >= MM_HIGHEST_USER_ADDRESS) {
                    return NULL;
                }
                if ((PVOID)((PCHAR)NtHeaders + sizeof (IMAGE_NT_HEADERS)) >= MM_HIGHEST_USER_ADDRESS) {
                    return NULL;
                }
            }
#endif

            if (NtHeaders->Signature != IMAGE_NT_SIGNATURE) {
                NtHeaders = NULL;
            }
        }
    }

    return NtHeaders;
#else
    return RtlpImageNtHeader( Base );
#endif
}


PIMAGE_SECTION_HEADER
RtlSectionTableFromVirtualAddress (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Address
    )

/*++

Routine Description:

    This function locates a VirtualAddress within the image header
    of a file that is mapped as a file and returns a pointer to the
    section table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Address - Supplies the virtual address to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the pointer of the section entry containing the data.

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if ((ULONG)Address >= NtSection->VirtualAddress &&
            (ULONG)Address < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}


PVOID
RtlAddressInSectionTable (
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Address
    )

/*++

Routine Description:

    This function locates a VirtualAddress within the image header
    of a file that is mapped as a file and returns the seek address
    of the data the Directory describes.

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.

    Address - Supplies the virtual address to locate.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = RtlSectionTableFromVirtualAddress( NtHeaders,
                                                   Base,
                                                   Address
                                                 );
    if (NtSection != NULL) {
        return( ((PCHAR)Base + ((ULONG_PTR)Address - NtSection->VirtualAddress) + NtSection->PointerToRawData) );
        }
    else {
        return( NULL );
        }
}


PVOID
RtlpImageDirectoryEntryToData32 (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size,
    PIMAGE_NT_HEADERS32 NtHeaders
    )
{
    ULONG DirectoryAddress;

    if (DirectoryEntry >= NtHeaders->OptionalHeader.NumberOfRvaAndSizes) {
        return( NULL );
    }

    if (!(DirectoryAddress = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].VirtualAddress)) {
        return( NULL );
    }

#if defined(NTOS_KERNEL_RUNTIME)
    if (Base < MM_HIGHEST_USER_ADDRESS) {
        if ((PVOID)((PCHAR)Base + DirectoryAddress) >= MM_HIGHEST_USER_ADDRESS) {
            return( NULL );
        }
    }
#endif

    *Size = NtHeaders->OptionalHeader.DataDirectory[ DirectoryEntry ].Size;
    if (MappedAsImage || DirectoryAddress < NtHeaders->OptionalHeader.SizeOfHeaders) {
        return( (PVOID)((PCHAR)Base + DirectoryAddress) );
    }

    return( RtlAddressInSectionTable((PIMAGE_NT_HEADERS)NtHeaders, Base, DirectoryAddress ));
}


PVOID
RtlImageDirectoryEntryToData (
    IN PVOID Base,
    IN BOOLEAN MappedAsImage,
    IN USHORT DirectoryEntry,
    OUT PULONG Size
    )

/*++

Routine Description:

    This function locates a Directory Entry within the image header
    and returns either the virtual address or seek address of the
    data the Directory describes.

Arguments:

    Base - Supplies the base of the image or data file.

    MappedAsImage - FALSE if the file is mapped as a data file.
                  - TRUE if the file is mapped as an image.

    DirectoryEntry - Supplies the directory entry to locate.

    Size - Return the size of the directory.

Return Value:

    NULL - The file does not contain data for the specified directory entry.

    NON-NULL - Returns the address of the raw data the directory describes.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;

    if ((ULONG_PTR)Base & 0x00000001) {
        Base = (PVOID)((ULONG_PTR)Base & ~0x00000001);
        MappedAsImage = FALSE;
        }

    NtHeaders = RtlImageNtHeader(Base);

    if (!NtHeaders)
        return NULL;

    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
        return (RtlpImageDirectoryEntryToData32(Base,
                                                MappedAsImage,
                                                DirectoryEntry,
                                                Size,
                                                (PIMAGE_NT_HEADERS32)NtHeaders));
    } else {
        return (NULL);
    }
}


#if !defined(NTOS_KERNEL_RUNTIME) && !defined(BLDR_KERNEL_RUNTIME)

PIMAGE_SECTION_HEADER
RtlImageRvaToSection(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file
    that is mapped as a file and returns a pointer to the section
    table entry for that virtual address

Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.  The image
        was mapped as a data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

Return Value:

    NULL - The RVA was not found within any of the sections of the image.

    NON-NULL - Returns the pointer to the image section that contains
               the RVA

--*/

{
    ULONG i;
    PIMAGE_SECTION_HEADER NtSection;

    NtSection = IMAGE_FIRST_SECTION( NtHeaders );
    for (i=0; i<NtHeaders->FileHeader.NumberOfSections; i++) {
        if (Rva >= NtSection->VirtualAddress &&
            Rva < NtSection->VirtualAddress + NtSection->SizeOfRawData
           ) {
            return NtSection;
            }
        ++NtSection;
        }

    return NULL;
}



PVOID
RtlImageRvaToVa(
    IN PIMAGE_NT_HEADERS NtHeaders,
    IN PVOID Base,
    IN ULONG Rva,
    IN OUT PIMAGE_SECTION_HEADER *LastRvaSection OPTIONAL
    )

/*++

Routine Description:

    This function locates an RVA within the image header of a file that
    is mapped as a file and returns the virtual addrees of the
    corresponding byte in the file.


Arguments:

    NtHeaders - Supplies the pointer to the image or data file.

    Base - Supplies the base of the image or data file.  The image
        was mapped as a data file.

    Rva - Supplies the relative virtual address (RVA) to locate.

    LastRvaSection - Optional parameter that if specified, points
        to a variable that contains the last section value used for
        the specified image to translate and RVA to a VA.

Return Value:

    NULL - The file does not contain the specified RVA

    NON-NULL - Returns the virtual addrees in the mapped file.

--*/

{
    PIMAGE_SECTION_HEADER NtSection;

    if (!ARGUMENT_PRESENT( LastRvaSection ) ||
        (NtSection = *LastRvaSection) == NULL ||
        Rva < NtSection->VirtualAddress ||
        Rva >= NtSection->VirtualAddress + NtSection->SizeOfRawData
       ) {
        NtSection = RtlImageRvaToSection( NtHeaders,
                                          Base,
                                          Rva
                                        );
        }

    if (NtSection != NULL) {
        if (LastRvaSection != NULL) {
            *LastRvaSection = NtSection;
            }

        return (PVOID)((PCHAR)Base +
                       (Rva - NtSection->VirtualAddress) +
                       NtSection->PointerToRawData
                      );
        }
    else {
        return NULL;
        }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\lookasid.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    lookasid.c

Abstract:

    This module implements heap lookaside list function.

Author:

    David N. Cutler (davec) 19-Feb-1995

Revision History:

--*/

#include "ntrtlp.h"
#include "heap.h"
#include "heappriv.h"


//
// Define Minimum lookaside list depth.
//

#define MINIMUM_LOOKASIDE_DEPTH 4

//
// Define minimum allocation threshold.
//

#define MINIMUM_ALLOCATION_THRESHOLD 25

//
// Define forward referenced function prototypes.
//



VOID
RtlpInitializeHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside,
    IN USHORT Depth
    )

/*++

Routine Description:

    This function initializes a heap lookaside list structure

Arguments:

    Lookaside - Supplies a pointer to a heap lookaside list structure.

    Allocate - Supplies a pointer to an allocate function.

    Free - Supplies a pointer to a free function.

    HeapHandle - Supplies a pointer to the heap that backs this lookaside list

    Flags - Supplies a set of heap flags.

    Size - Supplies the size for the lookaside list entries.

    Depth - Supplies the maximum depth of the lookaside list.

Return Value:

    None.

--*/

{

    //
    // Initialize the lookaside list structure.
    //

    RtlpInitializeSListHead(&Lookaside->ListHead);

    Lookaside->Depth = MINIMUM_LOOKASIDE_DEPTH;
    Lookaside->MaximumDepth = 256; //Depth;
    Lookaside->TotalAllocates = 0;
    Lookaside->AllocateMisses = 0;
    Lookaside->TotalFrees = 0;
    Lookaside->FreeMisses = 0;

    Lookaside->LastTotalAllocates = 0;
    Lookaside->LastAllocateMisses = 0;

    return;
}


VOID
RtlpDeleteHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside
    )

/*++

Routine Description:

    This function frees any entries specified by the lookaside structure.

Arguments:

    Lookaside - Supplies a pointer to a heap lookaside list structure.

Return Value:

    None.

--*/

{

    PVOID Entry;

    return;
}


VOID
RtlpAdjustHeapLookasideDepth (
    IN PHEAP_LOOKASIDE Lookaside
    )

/*++

Routine Description:

    This function is called periodically to adjust the maximum depth of
    a single heap lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a heap lookaside list structure.

Return Value:

    None.

--*/

{
    ULONG Allocates;
    ULONG Misses;

    //
    // Compute the total number of allocations and misses for this scan
    // period.
    //

    Allocates = Lookaside->TotalAllocates - Lookaside->LastTotalAllocates;
    Lookaside->LastTotalAllocates = Lookaside->TotalAllocates;
    Misses = Lookaside->AllocateMisses - Lookaside->LastAllocateMisses;
    Lookaside->LastAllocateMisses = Lookaside->AllocateMisses;

    //
    // Compute target depth of lookaside list.
    //

    {
        ULONG Ratio;
        ULONG Target;

        //
        // If the allocate rate is less than the mimimum threshold, then lower
        // the maximum depth of the lookaside list. Otherwise, if the miss rate
        // is less than .5%, then lower the maximum depth. Otherwise, raise the
        // maximum depth based on the miss rate.
        //

        if (Misses >= Allocates) {
            Misses = Allocates;
        }

        if (Allocates == 0) {
            Allocates = 1;
        }

        Ratio = (Misses * 1000) / Allocates;
        Target = Lookaside->Depth;
        if (Allocates < MINIMUM_ALLOCATION_THRESHOLD) {
            if (Target > (MINIMUM_LOOKASIDE_DEPTH + 10)) {
                Target -= 10;

            } else {
                Target = MINIMUM_LOOKASIDE_DEPTH;
            }

        } else if (Ratio < 5) {
            if (Target > (MINIMUM_LOOKASIDE_DEPTH + 1)) {
                Target -= 1;

            } else {
                Target = MINIMUM_LOOKASIDE_DEPTH;
            }

        } else {
            Target += ((Ratio * Lookaside->MaximumDepth) / (1000 * 2)) + 5;
            if (Target > Lookaside->MaximumDepth) {
                Target = Lookaside->MaximumDepth;
            }
        }

        Lookaside->Depth = (USHORT)Target;
    }

    return;
}



PVOID
RtlpAllocateFromHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    heap lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->TotalAllocates += 1;

    //
    //  We need to protect ourselves from a second thread that can cause us
    //  to fault on the pop. If we do fault then we'll just do a regular pop
    //  operation
    //

#if defined(_X86_)

    if (USER_SHARED_DATA->ProcessorFeatures[PF_COMPARE_EXCHANGE_DOUBLE]) {

#endif // defined(_X86_)

        try {

            Entry = RtlpInterlockedPopEntrySList(&Lookaside->ListHead);

        } except (EXCEPTION_EXECUTE_HANDLER) {

            Entry = NULL;
        }

        if (Entry != NULL) {

            return Entry;
        }
#if defined(_X86_)

    }

#endif // defined(_X86_)

    Lookaside->AllocateMisses += 1;
    return NULL;
}


BOOLEAN
RtlpFreeToHeapLookaside (
    IN PHEAP_LOOKASIDE Lookaside,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    paged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a paged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    BOOLEAN - TRUE if the entry was put on the lookaside list and FALSE
        otherwise.

--*/

{
    Lookaside->TotalFrees += 1;

#if defined(_X86_)

    if (USER_SHARED_DATA->ProcessorFeatures[PF_COMPARE_EXCHANGE_DOUBLE]) {

#endif // defined(_X86_)

        if (RtlpQueryDepthSList(&Lookaside->ListHead) < Lookaside->Depth) {

            //
            //  We need to protect ourselves from a second thread that can
            //  cause us to fault on the push.  If we do fault then we'll
            //  just do a regular free operation
            //

            try {

                RtlpInterlockedPushEntrySList(&Lookaside->ListHead,
                                              (PSINGLE_LIST_ENTRY)Entry);

            } except (EXCEPTION_EXECUTE_HANDLER) {

                Lookaside->FreeMisses += 1;

                return FALSE;
            }

            return TRUE;
        }

#if defined(_X86_)

    }

#endif // defined(_X86_)

    Lookaside->FreeMisses += 1;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\ldrreloc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

   ldrreloc.c

Abstract:

    This module contains the code to relocate an image when
    the preferred base isn't available. This is called by the
    boot loader, device driver loader, and system loader.

Author:

    Mike O'Leary (mikeol) 03-Feb-1992

Revision History:

--*/

#include "ntrtlp.h"

ULONG
LdrRelocateImage (
    IN PVOID NewBase,
    IN PUCHAR LoaderName,
    IN ULONG Success,
    IN ULONG Conflict,
    IN ULONG Invalid
    )

/*++

Routine Description:

    This routine relocates an image file that was not loaded into memory
    at the preferred address.

Arguments:

    NewBase - Supplies a pointer to the image base.

    LoaderName - Indicates which loader routine is being called from.

    Success - Value to return if relocation successful.

    Conflict - Value to return if can't relocate.

    Invalid - Value to return if relocations are invalid.

Return Value:

    Success if image is relocated.
    Conflict if image can't be relocated.
    Invalid if image contains invalid fixups.

--*/

{
    LONG_PTR Diff;
    ULONG TotalCountBytes;
    ULONG_PTR VA;
    ULONG_PTR OldBase;
    ULONG SizeOfBlock;
    PUCHAR FixupVA;
    USHORT Offset;
    PUSHORT NextOffset;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_BASE_RELOCATION NextBlock;

    RTL_PAGED_CODE();

    NtHeaders = RtlImageNtHeader( NewBase );
    if ( NtHeaders ) {
        OldBase = NtHeaders->OptionalHeader.ImageBase;
        }
    else {
        return Invalid;
        }

    //
    // Locate the relocation section.
    //

    NextBlock = (PIMAGE_BASE_RELOCATION)RtlImageDirectoryEntryToData(
            NewBase, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &TotalCountBytes);

    if (!NextBlock || !TotalCountBytes) {

        //
        // The image does not contain a relocation table, and therefore
        // cannot be relocated.
        //
#if DBG
        DbgPrint("%s: Image can't be relocated, no fixup information.\n", LoaderName);
#endif // DBG
        return Conflict;
    }

    //
    // If the image has a relocation table, then apply the specified fixup
    // information to the image.
    //

    while (TotalCountBytes) {
        SizeOfBlock = NextBlock->SizeOfBlock;
        TotalCountBytes -= SizeOfBlock;
        SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
        SizeOfBlock /= sizeof(USHORT);
        NextOffset = (PUSHORT)((PCHAR)NextBlock + sizeof(IMAGE_BASE_RELOCATION));

        VA = (ULONG_PTR)NewBase + NextBlock->VirtualAddress;
        Diff = (PCHAR)NewBase - (PCHAR)OldBase;

        if ( !(NextBlock = LdrProcessRelocationBlock(VA,SizeOfBlock,NextOffset,Diff)) ) {
#if DBG
            DbgPrint("%s: Unknown base relocation type\n", LoaderName);
#endif
            return Invalid;
        }
    }

    return Success;
}

PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlock(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff
    )
{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;

    RTL_PAGED_CODE();

    while (SizeOfBlock--) {

       Offset = *NextOffset & (USHORT)0xfff;
       FixupVA = (PUCHAR)(VA + Offset);

       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHLOW :
                //
                // HighLow - (32-bits) relocate the high and low half
                //      of an address.
                //
                *(LONG UNALIGNED *)FixupVA += (ULONG) Diff;
                break;

            case IMAGE_REL_BASED_HIGH :
                //
                // High - (16-bits) relocate the high half of an address.
                //
                Temp = *(PUSHORT)FixupVA << 16;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                break;

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //

                Temp = *(PUSHORT)FixupVA << 16;
                ++NextOffset;
                --SizeOfBlock;
                Temp += (LONG)(*(PSHORT)NextOffset);
                Temp += (ULONG) Diff;
                Temp += 0x8000;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);

                break;

            case IMAGE_REL_BASED_LOW :
                //
                // Low - (16-bit) relocate the low half of an address.
                //
                Temp = *(PSHORT)FixupVA;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)Temp;
                break;

            case IMAGE_REL_BASED_ABSOLUTE :
                //
                // Absolute - no fixup required.
                //
                break;

            case IMAGE_REL_BASED_SECTION :
                //
                // Section Relative reloc.  Ignore for now.
                //
                break;

            case IMAGE_REL_BASED_REL32 :
                //
                // Relative intrasection. Ignore for now.
                //
                break;

            default :
                //
                // Illegal - illegal relocation type.
                //

                return (PIMAGE_BASE_RELOCATION)NULL;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\lznt1.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LZNT1.c

Abstract:

    This module implements the LZNT1 compression engine.

Author:

    Gary Kimura     [GaryKi]    21-Jan-1994

Revision History:                                                

--*/

#include "ntrtlp.h"

#include <stdio.h>


//
//  Boolean which controls whether the asserts will fire.
//

#if DBG && !BLDR_KERNEL_RUNTIME
BOOLEAN Lznt1Break = TRUE;
#else
BOOLEAN Lznt1Break = FALSE;
#endif

//
//  Declare the internal workspace that we need
//

typedef struct _LZNT1_STANDARD_WORKSPACE {

    PUCHAR UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1;
    ULONG  MaxLength;
    PUCHAR MatchedString;

    PUCHAR IndexPTable[4096][2];

} LZNT1_STANDARD_WORKSPACE, *PLZNT1_STANDARD_WORKSPACE;

typedef struct _LZNT1_MAXIMUM_WORKSPACE {

    PUCHAR UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1;
    ULONG  MaxLength;
    PUCHAR MatchedString;

} LZNT1_MAXIMUM_WORKSPACE, *PLZNT1_MAXIMUM_WORKSPACE;

typedef struct _LZNT1_FRAGMENT_WORKSPACE {

    UCHAR Buffer[0x1000];

} LZNT1_FRAGMENT_WORKSPACE, *PLZNT1_FRAGMENT_WORKSPACE;

//
//  Now define the local procedure prototypes.
//

typedef ULONG (*PLZNT1_MATCH_FUNCTION) (
    );

NTSTATUS
LZNT1CompressChunk (
    IN PLZNT1_MATCH_FUNCTION MatchFunction,
    IN PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    OUT PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalCompressedChunkSize,
    IN PVOID WorkSpace
    );

NTSTATUS
LZNT1DecompressChunk (
    OUT PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    IN PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalUncompressedChunkSize
    );

ULONG
LZNT1FindMatchStandard (
    IN PUCHAR ZivString,
    IN PLZNT1_STANDARD_WORKSPACE WorkSpace
    );

ULONG
LZNT1FindMatchMaximum (
    IN PUCHAR ZivString,
    IN PVOID WorkSpace
    );


//
//  Local data structures
//

//
//  The compressed chunk header is the structure that starts every
//  new chunk in the compressed data stream.  In our definition here
//  we union it with a ushort to make setting and retrieving the chunk
//  header easier.  The header stores the size of the compressed chunk,
//  its signature, and if the data stored in the chunk is compressed or
//  not.
//
//  Compressed Chunk Size:
//
//      The actual size of a compressed chunk ranges from 4 bytes (2 byte
//      header, 1 flag byte, and 1 literal byte) to 4098 bytes (2 byte
//      header, and 4096 bytes of uncompressed data).  The size is encoded
//      in a 12 bit field biased by 3.  A value of 1 corresponds to a chunk
//      size of 4, 2 => 5, ..., 4095 => 4098.  A value of zero is special
//      because it denotes the ending chunk header.
//
//  Chunk Signature:
//
//      The only valid signature value is 3.  This denotes a 4KB uncompressed
//      chunk using with the 4/12 to 12/4 sliding offset/length encoding.
//
//  Is Chunk Compressed:
//
//      If the data in the chunk is compressed this field is 1 otherwise
//      the data is uncompressed and this field is 0.
//
//  The ending chunk header in a compressed buffer contains the a value of
//  zero (space permitting).
//

typedef union _COMPRESSED_CHUNK_HEADER {

    struct {

        USHORT CompressedChunkSizeMinus3 : 12;
        USHORT ChunkSignature            :  3;
        USHORT IsChunkCompressed         :  1;

    } Chunk;

    USHORT Short;

} COMPRESSED_CHUNK_HEADER, *PCOMPRESSED_CHUNK_HEADER;

#define MAX_UNCOMPRESSED_CHUNK_SIZE (4096)

//
//  USHORT
//  GetCompressedChunkSize (
//      IN COMPRESSED_CHUNK_HEADER ChunkHeader
//      );
//
//  USHORT
//  GetUncompressedChunkSize (
//      IN COMPRESSED_CHUNK_HEADER ChunkHeader
//      );
//
//  VOID
//  SetCompressedChunkHeader (
//      IN OUT COMPRESSED_CHUNK_HEADER ChunkHeader,
//      IN USHORT CompressedChunkSize,
//      IN BOOLEAN IsChunkCompressed
//      );
//

#define GetCompressedChunkSize(CH)   (       \
    (CH).Chunk.CompressedChunkSizeMinus3 + 3 \
)

#define GetUncompressedChunkSize(CH) (MAX_UNCOMPRESSED_CHUNK_SIZE)

#define SetCompressedChunkHeader(CH,CCS,ICC) {        \
    ASSERT((CCS) >= 4 && (CCS) <= 4098);              \
    (CH).Chunk.CompressedChunkSizeMinus3 = (CCS) - 3; \
    (CH).Chunk.ChunkSignature = 3;                    \
    (CH).Chunk.IsChunkCompressed = (ICC);             \
}


//
//  Local macros
//

#define FlagOn(F,SF)    ((F) & (SF))
#define SetFlag(F,SF)   { (F) |= (SF); }
#define ClearFlag(F,SF) { (F) &= ~(SF); }

#define Minimum(A,B)    ((A) < (B) ? (A) : (B))
#define Maximum(A,B)    ((A) > (B) ? (A) : (B))

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)

#pragma alloc_text(PAGE, RtlCompressWorkSpaceSizeLZNT1)
#pragma alloc_text(PAGE, RtlCompressBufferLZNT1)
#pragma alloc_text(PAGE, RtlDecompressBufferLZNT1)
#pragma alloc_text(PAGE, RtlDecompressFragmentLZNT1)
#pragma alloc_text(PAGE, RtlDescribeChunkLZNT1)
#pragma alloc_text(PAGE, RtlReserveChunkLZNT1)

#pragma alloc_text(PAGE, LZNT1CompressChunk)

#if !defined(_ALPHA_)
#if !defined(_MIPS_)
#if !defined(_PPC_)
#if !defined(i386)
#pragma alloc_text(PAGE, LZNT1DecompressChunk)
#endif
#endif
#endif
#endif

#pragma alloc_text(PAGE, LZNT1FindMatchStandard)
#pragma alloc_text(PAGE, LZNT1FindMatchMaximum)

#endif


NTSTATUS
RtlCompressWorkSpaceSizeLZNT1 (
    IN USHORT Engine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    if (Engine == COMPRESSION_ENGINE_STANDARD) {

        *CompressBufferWorkSpaceSize = sizeof(LZNT1_STANDARD_WORKSPACE);
        *CompressFragmentWorkSpaceSize = sizeof(LZNT1_FRAGMENT_WORKSPACE);

        return STATUS_SUCCESS;

    } else if (Engine == COMPRESSION_ENGINE_MAXIMUM) {

        *CompressBufferWorkSpaceSize = sizeof(LZNT1_MAXIMUM_WORKSPACE);
        *CompressFragmentWorkSpaceSize = sizeof(LZNT1_FRAGMENT_WORKSPACE);

        return STATUS_SUCCESS;

    } else {

        return STATUS_NOT_SUPPORTED;
    }
}


NTSTATUS
RtlCompressBufferLZNT1 (
    IN USHORT Engine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed buffer and produces
    its compressed equivalent provided the compressed data fits within
    the specified destination buffer.

    An output variable indicates the number of bytes used to store
    the compressed buffer.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed data.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to where the compressed data
        is to be stored.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    UncompressedChunkSize - Ignored.

    FinalCompressedSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed data.

    WorkSpace - Mind your own business, just give it to me.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input buffer was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    NTSTATUS Status;

    PLZNT1_MATCH_FUNCTION MatchFunction;

    PUCHAR UncompressedChunk;
    PUCHAR CompressedChunk;
    LONG CompressedChunkSize;

    //
    //  The following variable is used to tell if we have processed an entire
    //  buffer of zeros and that we should return an alternate status value
    //

    BOOLEAN AllZero = TRUE;

    //
    //  The following variables are pointers to the byte following the
    //  end of each appropriate buffer.
    //

    PUCHAR EndOfUncompressedBuffer = UncompressedBuffer + UncompressedBufferSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;

    //
    //  Get the match function we are to be using
    //

    if (Engine == COMPRESSION_ENGINE_STANDARD) {

        MatchFunction = LZNT1FindMatchStandard;

    } else if (Engine == COMPRESSION_ENGINE_MAXIMUM) {

        MatchFunction = LZNT1FindMatchMaximum;

    } else {

        return STATUS_NOT_SUPPORTED;
    }

    //
    //  For each uncompressed chunk (even the odd sized ending buffer) we will
    //  try and compress the chunk
    //

    for (UncompressedChunk = UncompressedBuffer, CompressedChunk = CompressedBuffer;
         UncompressedChunk < EndOfUncompressedBuffer;
         UncompressedChunk += MAX_UNCOMPRESSED_CHUNK_SIZE, CompressedChunk += CompressedChunkSize) {

        ASSERT(EndOfUncompressedBuffer >= UncompressedChunk);
        ASSERT(EndOfCompressedBuffer >= CompressedChunk);

        //
        //  Call the appropriate engine to compress one chunk. and
        //  return an error if we got one.
        //

        if (!NT_SUCCESS(Status = LZNT1CompressChunk( MatchFunction,
                                                     UncompressedChunk,
                                                     EndOfUncompressedBuffer,
                                                     CompressedChunk,
                                                     EndOfCompressedBuffer,
                                                     &CompressedChunkSize,
                                                     WorkSpace ))) {

            return Status;
        }

        //
        //  See if we stay all zeros.  If not then all zeros will become
        //  false and stay that way no matter what we later compress
        //

        AllZero = AllZero && (Status == STATUS_BUFFER_ALL_ZEROS);
    }

    //
    //  If we are not within two bytes of the end of the compressed buffer then we
    //  need to zero out two more for the ending compressed header and update
    //  the compressed chunk pointer value.  Don't include these bytes in
    //  the count however, as that may force our caller to allocate an unneeded
    //  cluster, since on decompress we will terminate either on these two
    //  bytes of 0, or byte count.
    //

    if (CompressedChunk <= (EndOfCompressedBuffer - 2)) {

        *(CompressedChunk) = 0;
        *(CompressedChunk + 1) = 0;
    }

    //
    //  The final compressed size is the difference between the start of the
    //  compressed buffer and where the compressed chunk pointer was left
    //

    *FinalCompressedSize = (ULONG)(CompressedChunk - CompressedBuffer);

    //
    //  Check if the input buffer was all zeros and return the alternate status
    //  if appropriate
    //

    if (AllZero) { return STATUS_BUFFER_ALL_ZEROS; }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDecompressBufferLZNT1 (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer and produces
    its uncompressed equivalent provided the uncompressed data fits
    within the specified destination buffer.

    An output variable indicates the number of bytes used to store the
    uncompressed data.

Arguments:

    UncompressedBuffer - Supplies a pointer to where the uncompressed
        data is to be stored.

    UncompressedBufferSize - Supplies the size, in bytes, of the
        uncompressed buffer.

    CompressedBuffer - Supplies a pointer to the compressed data.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    FinalUncompressedSize - Receives the number of bytes needed in
        the uncompressed buffer to store the uncompressed data.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

--*/

{
    NTSTATUS Status;

    PUCHAR CompressedChunk = CompressedBuffer;
    PUCHAR UncompressedChunk = UncompressedBuffer;

    COMPRESSED_CHUNK_HEADER ChunkHeader;
    LONG SavedChunkSize;

    LONG UncompressedChunkSize;
    LONG CompressedChunkSize;

    //
    //  The following to variables are pointers to the byte following the
    //  end of each appropriate buffer.  This saves us from doing the addition
    //  for each loop check
    //

    PUCHAR EndOfUncompressedBuffer = UncompressedBuffer + UncompressedBufferSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;

    //
    //  Make sure that the compressed buffer is at least four bytes long to
    //  start with, and then get the first chunk header and make sure it
    //  is not an ending chunk header.
    //

    ASSERT(CompressedChunk <= EndOfCompressedBuffer - 4);

    RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

    ASSERT( (ChunkHeader.Short != 0) || !Lznt1Break );

    //
    //  Now while there is space in the uncompressed buffer to store data
    //  we will loop through decompressing chunks
    //

    while (TRUE) {

        ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

        CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);

        //
        //  Check that the chunk actually fits in the buffer supplied
        //  by the caller
        //

        if (CompressedChunk + CompressedChunkSize > EndOfCompressedBuffer) {

            ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);

            *FinalUncompressedSize = PtrToUlong(CompressedChunk);

            return STATUS_BAD_COMPRESSION_BUFFER;
        }

        //
        //  First make sure the chunk contains compressed data
        //

        if (ChunkHeader.Chunk.IsChunkCompressed) {

            //
            //  Decompress a chunk and return if we get an error
            //

            if (!NT_SUCCESS(Status = LZNT1DecompressChunk( UncompressedChunk,
                                                           EndOfUncompressedBuffer,
                                                           CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                                                           CompressedChunk + CompressedChunkSize,
                                                           &UncompressedChunkSize ))) {

                *FinalUncompressedSize = UncompressedChunkSize;

                return Status;
            }

        } else {

            //
            //  The chunk does not contain compressed data so we need to simply
            //  copy over the uncompressed data
            //

            UncompressedChunkSize = GetUncompressedChunkSize( ChunkHeader );

            //
            //  Make sure the data will fit into the output buffer
            //

            if (UncompressedChunk + UncompressedChunkSize > EndOfUncompressedBuffer) {

                UncompressedChunkSize = (ULONG)(EndOfUncompressedBuffer - UncompressedChunk);
            }

            //
            //  Check that the compressed chunk has this many bytes to copy.
            //

            if (CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER) + UncompressedChunkSize > EndOfCompressedBuffer) {

                ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);
                *FinalUncompressedSize = PtrToUlong(CompressedChunk);
                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            RtlCopyMemory( UncompressedChunk,
                           CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                           UncompressedChunkSize );
        }

        //
        //  Now update the compressed and uncompressed chunk pointers with
        //  the size of the compressed chunk and the number of bytes we
        //  decompressed into, and then make sure we didn't exceed our buffers
        //

        CompressedChunk += CompressedChunkSize;
        UncompressedChunk += UncompressedChunkSize;

        ASSERT( CompressedChunk <= EndOfCompressedBuffer );
        ASSERT( UncompressedChunk <= EndOfUncompressedBuffer );

        //
        //  Now if the uncompressed is full then we are done
        //

        if (UncompressedChunk == EndOfUncompressedBuffer) { break; }

        //
        //  Otherwise we need to get the next chunk header.  We first
        //  check if there is one, save the old chunk size for the
        //  chunk we just read in, get the new chunk, and then check
        //  if it is the ending chunk header
        //

        if (CompressedChunk > EndOfCompressedBuffer - 2) { break; }

        SavedChunkSize = GetUncompressedChunkSize(ChunkHeader);

        RtlRetrieveUshort( &ChunkHeader, CompressedChunk );
        if (ChunkHeader.Short == 0) { break; }

        //
        //  At this point we are not at the end of the uncompressed buffer
        //  and we have another chunk to process.  But before we go on we
        //  need to see if the last uncompressed chunk didn't fill the full
        //  uncompressed chunk size.
        //

        if (UncompressedChunkSize < SavedChunkSize) {

            LONG t1;
            PUCHAR t2;

            //
            //  Now we only need to zero out data if the really are going
            //  to process another chunk, to test for that we check if
            //  the zero will go beyond the end of the uncompressed buffer
            //

            if ((t2 = (UncompressedChunk +
                       (t1 = (SavedChunkSize -
                              UncompressedChunkSize)))) >= EndOfUncompressedBuffer) {

                break;
            }

            RtlZeroMemory( UncompressedChunk, t1);
            UncompressedChunk = t2;
        }
    }

    //
    //  If we got out of the loop with the compressed chunk pointer beyond the
    //  end of compressed buffer then the compression buffer is ill formed.
    //

    if (CompressedChunk > EndOfCompressedBuffer) {

        *FinalUncompressedSize = PtrToUlong(CompressedChunk);

        return STATUS_BAD_COMPRESSION_BUFFER;
    }

    //
    //  The final uncompressed size is the difference between the start of the
    //  uncompressed buffer and where the uncompressed chunk pointer was left
    //

    *FinalUncompressedSize = (ULONG)(UncompressedChunk - UncompressedBuffer);

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDecompressFragmentLZNT1 (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PLZNT1_FRAGMENT_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer and extract an
    uncompressed fragment.

    Output bytes are copied to the fragment buffer until either the
    fragment buffer is full or the end of the uncompressed buffer is
    reached.

    An output variable indicates the number of bytes used to store the
    uncompressed fragment.

Arguments:

    UncompressedFragment - Supplies a pointer to where the uncompressed
        fragment is to be stored.

    UncompressedFragmentSize - Supplies the size, in bytes, of the
        uncompressed fragment buffer.

    CompressedBuffer - Supplies a pointer to the compressed data buffer.

    CompressedBufferSize - Supplies the size, in bytes, of the
        compressed buffer.

    FragmentOffset - Supplies the offset (zero based) where the uncompressed
        fragment is being extract from.  The offset is the position within
        the original uncompressed buffer.

    FinalUncompressedSize - Receives the number of bytes needed in
        the Uncompressed fragment buffer to store the data.

    WorkSpace - Stop looking.

Return Value:

    STATUS_SUCCESS - the operation worked without a hitch.

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

--*/

{
    NTSTATUS Status;

    PUCHAR CompressedChunk = CompressedBuffer;

    COMPRESSED_CHUNK_HEADER ChunkHeader;
    ULONG UncompressedChunkSize;
    ULONG CompressedChunkSize;

    PUCHAR EndOfUncompressedFragment = UncompressedFragment + UncompressedFragmentSize;
    PUCHAR EndOfCompressedBuffer = CompressedBuffer + CompressedBufferSize;
    PUCHAR CurrentUncompressedFragment;

    ULONG CopySize;

    ASSERT(UncompressedFragmentSize > 0);

    //
    //  Get the chunk header for the first chunk in the
    //  compressed buffer and extract the uncompressed and
    //  the compressed chunk sizes
    //

    ASSERT(CompressedChunk <= EndOfCompressedBuffer - 2);

    RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

    ASSERT( (ChunkHeader.Short != 0) || !Lznt1Break );
    ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

    UncompressedChunkSize = GetUncompressedChunkSize(ChunkHeader);
    CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);

    //
    //  Now we want to skip over chunks that precede the fragment
    //  we're after.  To do that we'll loop until the fragment
    //  offset is within the current chunk.  If it is not within
    //  the current chunk then we'll skip to the next chunk and
    //  subtract the uncompressed chunk size from the fragment offset
    //

    while (FragmentOffset >= UncompressedChunkSize) {

        //
        //  Check that the chunk actually fits in the buffer supplied
        //  by the caller
        //

        if (CompressedChunk + CompressedChunkSize > EndOfCompressedBuffer) {

            ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);

            *FinalUncompressedSize = PtrToUlong(CompressedChunk);

            return STATUS_BAD_COMPRESSION_BUFFER;
        }

        //
        //  Adjust the fragment offset and move the compressed
        //  chunk pointer to the next chunk
        //

        FragmentOffset -= UncompressedChunkSize;
        CompressedChunk += CompressedChunkSize;

        //
        //  Get the next chunk header and if it is not in use
        //  then the fragment that the user wants is beyond the
        //  compressed data so we'll return a zero sized fragment
        //

        if (CompressedChunk > EndOfCompressedBuffer - 2) {

            *FinalUncompressedSize = 0;
            return STATUS_SUCCESS;
        }

        RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

        if (ChunkHeader.Short == 0) {

            *FinalUncompressedSize = 0;
            return STATUS_SUCCESS;
        }

        ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

        //
        //  Decode the chunk sizes for the new current chunk
        //

        UncompressedChunkSize = GetUncompressedChunkSize(ChunkHeader);
        CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);
    }

    //
    //  At this point the current chunk contains the starting point
    //  for the fragment.  Now we'll loop extracting data until
    //  we've filled up the uncompressed fragment buffer or until
    //  we've run out of chunks.  Both test are done near the end of
    //  the loop
    //

    CurrentUncompressedFragment = UncompressedFragment;

    while (TRUE) {

        //
        //  Check that the chunk actually fits in the buffer supplied
        //  by the caller
        //

        if (CompressedChunk + CompressedChunkSize > EndOfCompressedBuffer) {

            ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);

            *FinalUncompressedSize = PtrToUlong(CompressedChunk);

            return STATUS_BAD_COMPRESSION_BUFFER;
        }


        //
        //  Now we need to compute the amount of data to copy from the
        //  chunk.  It will be based on either to the end of the chunk
        //  size or the amount of data the user specified
        //

        CopySize = Minimum( UncompressedChunkSize - FragmentOffset, UncompressedFragmentSize );

        //
        //  Now check if the chunk contains compressed data
        //

        if (ChunkHeader.Chunk.IsChunkCompressed) {

            //
            //  The chunk is compressed but now check if the amount
            //  we need to get is the entire chunk and if so then
            //  we can do the decompress straight into the caller's
            //  buffer
            //

            if ((FragmentOffset == 0) && (CopySize == UncompressedChunkSize)) {

                if (!NT_SUCCESS(Status = LZNT1DecompressChunk( CurrentUncompressedFragment,
                                                               EndOfUncompressedFragment,
                                                               CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                                                               CompressedChunk + CompressedChunkSize,
                                                               &CopySize ))) {

                    *FinalUncompressedSize = CopySize;

                    return Status;
                }

            } else {

                //
                //  The caller wants only a portion of this compressed chunk
                //  so we need to read it into our work buffer and then copy
                //  the parts from the work buffer into the caller's buffer
                //

                if (!NT_SUCCESS(Status = LZNT1DecompressChunk( (PUCHAR)WorkSpace,
                                                               &WorkSpace->Buffer[0] + sizeof(LZNT1_FRAGMENT_WORKSPACE),
                                                               CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER),
                                                               CompressedChunk + CompressedChunkSize,
                                                               &UncompressedChunkSize ))) {

                    *FinalUncompressedSize = UncompressedChunkSize;

                    return Status;
                }

                //
                //  If we got less than we were looking for then we are at the
                //  end of the file.  Remember the real uncompressed size and
                //  break out of the loop.
                //

                if ((UncompressedChunkSize - FragmentOffset) < CopySize) {

                    RtlCopyMemory( CurrentUncompressedFragment,
                                   &WorkSpace->Buffer[ FragmentOffset ],
                                   (UncompressedChunkSize - FragmentOffset) );

                    CurrentUncompressedFragment += (UncompressedChunkSize - FragmentOffset);
                    break;
                }

                RtlCopyMemory( CurrentUncompressedFragment,
                               &WorkSpace->Buffer[ FragmentOffset ],
                               CopySize );
            }

        } else {

            //
            //  The chunk is not compressed so we can do a simple copy of the
            //  data.  First verify that the compressed buffer holds this much
            //  data.
            //

            if (CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER) + FragmentOffset + CopySize > EndOfCompressedBuffer) {

                ASSERTMSG("CompressedBuffer is too small", !Lznt1Break);
                *FinalUncompressedSize = PtrToUlong(CompressedChunk);
                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            RtlCopyMemory( CurrentUncompressedFragment,
                           CompressedChunk + sizeof(COMPRESSED_CHUNK_HEADER) + FragmentOffset,
                           CopySize );
        }

        //
        //  Now that we've done at least one copy make sure the fragment
        //  offset is set to zero so the next time through the loop will
        //  start at the right offset
        //

        FragmentOffset = 0;

        //
        //  Adjust the uncompressed fragment information by moving the
        //  pointer up by the copy size and subtracting copy size from
        //  the amount of data the user wants
        //

        CurrentUncompressedFragment += CopySize;
        UncompressedFragmentSize -= CopySize;

        //
        //  Now if the uncompressed fragment size is zero then we're
        //  done
        //

        if (UncompressedFragmentSize == 0) { break; }

        //
        //  Otherwise the user wants more data so we'll move to the
        //  next chunk, and then check if the chunk is is use.  If
        //  it is not in use then we the user is trying to read beyond
        //  the end of compressed data so we'll break out of the loop
        //

        CompressedChunk += CompressedChunkSize;

        if (CompressedChunk > EndOfCompressedBuffer - 2) { break; }

        RtlRetrieveUshort( &ChunkHeader, CompressedChunk );

        if (ChunkHeader.Short == 0) { break; }

        ASSERT( (ChunkHeader.Chunk.ChunkSignature == 3) || !Lznt1Break );

        //
        //  Decode the chunk sizes for the new current chunk
        //

        UncompressedChunkSize = GetUncompressedChunkSize(ChunkHeader);
        CompressedChunkSize = GetCompressedChunkSize(ChunkHeader);
    }

    //
    //  Now either we finished filling up the caller's buffer (and
    //  uncompressed fragment size is zero) or we've exhausted the
    //  compresed buffer (and chunk header is zero).  In either case
    //  we're done and we can now compute the size of the fragment
    //  that we're returning to the caller it is simply the difference
    //  between the start of the buffer and the current position
    //

    *FinalUncompressedSize = (ULONG)(CurrentUncompressedFragment - UncompressedFragment);

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDescribeChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    )

/*++

Routine Description:

    This routine takes as input a compressed buffer, and returns
    a description of the current chunk in that buffer, updating
    the CompressedBuffer pointer to point to the next chunk (if
    there is one).

Arguments:

    CompressedBuffer - Supplies a pointer to the current chunk in
        the compressed data, and returns pointing to the next chunk

    EndOfCompressedBufferPlus1 - Points at first byte beyond
        compressed buffer

    ChunkBuffer - Receives a pointer to the chunk, if ChunkSize
        is nonzero, else undefined

    ChunkSize - Receives the size of the current chunk pointed
        to by CompressedBuffer.  Returns 0 if STATUS_NO_MORE_ENTRIES.

Return Value:

    STATUS_SUCCESS - the chunk size is being returned

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

    STATUS_NO_MORE_ENTRIES - There is no chunk at the current pointer.

--*/

{
    COMPRESSED_CHUNK_HEADER ChunkHeader;
    NTSTATUS Status = STATUS_NO_MORE_ENTRIES;

    //
    //  First initialize outputs
    //

    *ChunkBuffer = *CompressedBuffer;
    *ChunkSize = 0;

    //
    //  Make sure that the compressed buffer is at least four bytes long to
    //  start with, otherwise just return a zero chunk.
    //

    if (*CompressedBuffer <= EndOfCompressedBufferPlus1 - 4) {

        RtlRetrieveUshort( &ChunkHeader, *CompressedBuffer );

        //
        //  Check for end of chunks, terminated by USHORT of 0.
        //  First assume there are no more.
        //

        if (ChunkHeader.Short != 0) {

            Status = STATUS_SUCCESS;

            *ChunkSize = GetCompressedChunkSize(ChunkHeader);
            *CompressedBuffer += *ChunkSize;

            //
            //  Check that the chunk actually fits in the buffer supplied
            //  by the caller.  If not, restore *CompressedBuffer for debug!
            //

            if ((*CompressedBuffer > EndOfCompressedBufferPlus1) ||
                (ChunkHeader.Chunk.ChunkSignature != 3)) {

                ASSERTMSG("CompressedBuffer is bad or too small", !Lznt1Break);

                *CompressedBuffer -= *ChunkSize;

                Status = STATUS_BAD_COMPRESSION_BUFFER;

            //
            //  First make sure the chunk contains compressed data
            //

            } else if (!ChunkHeader.Chunk.IsChunkCompressed) {

                //
                //  The uncompressed chunk must be exactly this size!
                //  If not, restore *CompressedBuffer for debug!
                //

                if (*ChunkSize != MAX_UNCOMPRESSED_CHUNK_SIZE + 2) {

                    ASSERTMSG("Uncompressed chunk is wrong size", !Lznt1Break);

                    *CompressedBuffer -= *ChunkSize;

                    Status = STATUS_BAD_COMPRESSION_BUFFER;

                //
                //  The chunk does not contain compressed data so we need to
                //  remove the chunk header from the chunk description.
                //

                } else {

                    *ChunkBuffer += 2;
                    *ChunkSize -= 2;
                }

            //
            //  Otherwise we have a compressed chunk, and we only need to
            //  see if it is all zeros!  Since the header is already interpreted,
            //  we only have to see if there is exactly one literal and if it
            //  is zero - it doesn't matter what the copy token says - we have
            //  a chunk of zeros!
            //

            } else if ((*ChunkSize == 6) && (*(*ChunkBuffer + 2) == 2) && (*(*ChunkBuffer + 3) == 0)) {

                *ChunkSize = 0;
            }
        }
    }

    return Status;
}


NTSTATUS
RtlReserveChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    )

/*++

Routine Description:

    This routine reserves space for a chunk of the specified
    size in the buffer, writing in a chunk header if necessary
    (uncompressed or all zeros case).  On return the CompressedBuffer
    pointer points to the next chunk.

Arguments:

    CompressedBuffer - Supplies a pointer to the current chunk in
        the compressed data, and returns pointing to the next chunk

    EndOfCompressedBufferPlus1 - Points at first byte beyond
        compressed buffer

    ChunkBuffer - Receives a pointer to the chunk, if ChunkSize
        is nonzero, else undefined

    ChunkSize - Supplies the compressed size of the chunk to be received.
                Two special values are 0 and MAX_UNCOMPRESSED_CHUNK_SIZE (4096).
                0 means the chunk should be filled with a pattern that equates
                to 4096 0's.  4096 implies that the compression routine should
                prepare to receive all of the data in uncompressed form.

Return Value:

    STATUS_SUCCESS - the chunk size is being returned

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    COMPRESSED_CHUNK_HEADER ChunkHeader;
    BOOLEAN Compressed;
    PUCHAR Tail, NextChunk, DontCare;
    ULONG Size;
    NTSTATUS Status;

    ASSERT(ChunkSize <= MAX_UNCOMPRESSED_CHUNK_SIZE);

    //
    //  Calculate the address of the tail of this buffer and its
    //  size, so it can be moved before we store anything.
    //

    Tail = NextChunk = *CompressedBuffer;
    while (NT_SUCCESS(Status = RtlDescribeChunkLZNT1( &NextChunk,
                                                      EndOfCompressedBufferPlus1,
                                                      &DontCare,
                                                      &Size))) {

        //
        //  First time through the loop, capture the address of the next chunk.
        //

        if (Tail == *CompressedBuffer) {
            Tail = NextChunk;
        }
    }

    //
    //  The buffer could be invalid.
    //

    if (Status == STATUS_NO_MORE_ENTRIES) {

        //
        //  The only way to successfully terminate the loop is by finding a USHORT
        //  terminator of 0.  Now calculate the size including the final USHORT
        //  we stopped on.
        //

        Size = (ULONG) (NextChunk - Tail + sizeof(USHORT));

        //
        //  First initialize outputs
        //

        Status = STATUS_BUFFER_TOO_SMALL;
        *ChunkBuffer = *CompressedBuffer;

        //
        //  Make sure that the compressed buffer is at least four bytes long to
        //  start with, otherwise just return a zero chunk.
        //

        if (*CompressedBuffer <= (EndOfCompressedBufferPlus1 - ChunkSize)) {

            //
            //  If the chunk is uncompressed, then we have to adjust the
            //  chunk description for the header.
            //

            if (ChunkSize == MAX_UNCOMPRESSED_CHUNK_SIZE) {

                //
                //  Increase ChunkSize to include header.
                //

                ChunkSize += 2;

                //
                //  Move the tail now that we know where to put it.
                //

                if ((*CompressedBuffer + ChunkSize + Size) <= EndOfCompressedBufferPlus1) {

                    RtlMoveMemory( *CompressedBuffer + ChunkSize, Tail, Size );

                    //
                    //  Build the header and store it for an uncompressed chunk.
                    //

                    SetCompressedChunkHeader( ChunkHeader,
                                              MAX_UNCOMPRESSED_CHUNK_SIZE + 2,
                                              FALSE );

                    RtlStoreUshort( (*CompressedBuffer), ChunkHeader.Short );

                    //
                    //  Advance to where the uncompressed data goes.
                    //

                    *ChunkBuffer += 2;

                    Status = STATUS_SUCCESS;
                }

            //
            //  Otherwise, if this is a zero chunk we have to build it.
            //

            } else if (ChunkSize == 0) {

                //
                //  It takes 6 bytes to describe a chunk of zeros.
                //

                ChunkSize = 6;

                if ((*CompressedBuffer + ChunkSize + Size) <= EndOfCompressedBufferPlus1) {

                    //
                    //  Move the tail now that we know where to put it.
                    //

                    RtlMoveMemory( *CompressedBuffer + ChunkSize, Tail, Size );

                    //
                    //  Build the header and store it
                    //

                    SetCompressedChunkHeader( ChunkHeader,
                                              6,
                                              TRUE );

                    RtlStoreUshort( (*CompressedBuffer), ChunkHeader.Short );

                    //
                    //  Now store the mask byte with one literal and the literal
                    //  is 0.
                    //

                    RtlStoreUshort( (*CompressedBuffer + 2), (USHORT)2 );

                    //
                    //  Now store the copy token for copying 4095 bytes from
                    //  the preceding byte (stored as offset 0).
                    //

                    RtlStoreUshort( (*CompressedBuffer + 4), (USHORT)(4095-3));

                    Status = STATUS_SUCCESS;
                }

            //
            //  Otherwise we have a normal compressed chunk.
            //

            } else {

                //
                //  Move the tail now that we know where to put it.
                //

                if ((*CompressedBuffer + ChunkSize + Size) <= EndOfCompressedBufferPlus1) {

                    RtlMoveMemory( *CompressedBuffer + ChunkSize, Tail, Size );

                    Status = STATUS_SUCCESS;
                }
            }

            //
            //  Advance the *CompressedBuffer before return
            //

            *CompressedBuffer += ChunkSize;
        }
    }

    return Status;
}


//
//  The Copy token is two bytes in size.
//  Our definition uses a union to make it easier to set and retrieve token values.
//
//  Copy Token
//
//          Length            Displacement
//
//      12 bits 3 to 4098    4 bits 1 to 16
//      11 bits 3 to 2050    5 bits 1 to 32
//      10 bits 3 to 1026    6 bits 1 to 64
//       9 bits 3 to 514     7 bits 1 to 128
//       8 bits 3 to 258     8 bits 1 to 256
//       7 bits 3 to 130     9 bits 1 to 512
//       6 bits 3 to 66     10 bits 1 to 1024
//       5 bits 3 to 34     11 bits 1 to 2048
//       4 bits 3 to 18     12 bits 1 to 4096
//

#define FORMAT412 0
#define FORMAT511 1
#define FORMAT610 2
#define FORMAT79  3
#define FORMAT88  4
#define FORMAT97  5
#define FORMAT106 6
#define FORMAT115 7
#define FORMAT124 8

//                                4/12  5/11  6/10   7/9   8/8   9/7  10/6  11/5  12/4

ULONG FormatMaxLength[]       = { 4098, 2050, 1026,  514,  258,  130,   66,   34,   18 };
ULONG FormatMaxDisplacement[] = {   16,   32,   64,  128,  256,  512, 1024, 2048, 4096 };

typedef union _LZNT1_COPY_TOKEN {

    struct { USHORT Length : 12; USHORT Displacement :  4; } Fields412;
    struct { USHORT Length : 11; USHORT Displacement :  5; } Fields511;
    struct { USHORT Length : 10; USHORT Displacement :  6; } Fields610;
    struct { USHORT Length :  9; USHORT Displacement :  7; } Fields79;
    struct { USHORT Length :  8; USHORT Displacement :  8; } Fields88;
    struct { USHORT Length :  7; USHORT Displacement :  9; } Fields97;
    struct { USHORT Length :  6; USHORT Displacement : 10; } Fields106;
    struct { USHORT Length :  5; USHORT Displacement : 11; } Fields115;
    struct { USHORT Length :  4; USHORT Displacement : 12; } Fields124;

    UCHAR Bytes[2];

} LZNT1_COPY_TOKEN, *PLZNT1_COPY_TOKEN;

//
//  USHORT
//  GetLZNT1Length (
//      IN COPY_TOKEN_FORMAT Format,
//      IN LZNT1_COPY_TOKEN CopyToken
//      );
//
//  USHORT
//  GetLZNT1Displacement (
//      IN COPY_TOKEN_FORMAT Format,
//      IN LZNT1_COPY_TOKEN CopyToken
//      );
//
//  VOID
//  SetLZNT1 (
//      IN COPY_TOKEN_FORMAT Format,
//      IN LZNT1_COPY_TOKEN CopyToken,
//      IN USHORT Length,
//      IN USHORT Displacement
//      );
//

#define GetLZNT1Length(F,CT) (                   \
    ( F == FORMAT412 ? (CT).Fields412.Length + 3 \
    : F == FORMAT511 ? (CT).Fields511.Length + 3 \
    : F == FORMAT610 ? (CT).Fields610.Length + 3 \
    : F == FORMAT79  ? (CT).Fields79.Length  + 3 \
    : F == FORMAT88  ? (CT).Fields88.Length  + 3 \
    : F == FORMAT97  ? (CT).Fields97.Length  + 3 \
    : F == FORMAT106 ? (CT).Fields106.Length + 3 \
    : F == FORMAT115 ? (CT).Fields115.Length + 3 \
    :                  (CT).Fields124.Length + 3 \
    )                                            \
)

#define GetLZNT1Displacement(F,CT) (                   \
    ( F == FORMAT412 ? (CT).Fields412.Displacement + 1 \
    : F == FORMAT511 ? (CT).Fields511.Displacement + 1 \
    : F == FORMAT610 ? (CT).Fields610.Displacement + 1 \
    : F == FORMAT79  ? (CT).Fields79.Displacement  + 1 \
    : F == FORMAT88  ? (CT).Fields88.Displacement  + 1 \
    : F == FORMAT97  ? (CT).Fields97.Displacement  + 1 \
    : F == FORMAT106 ? (CT).Fields106.Displacement + 1 \
    : F == FORMAT115 ? (CT).Fields115.Displacement + 1 \
    :                  (CT).Fields124.Displacement + 1 \
    )                                                  \
)

#define SetLZNT1(F,CT,L,D) {                                                                             \
    if      (F == FORMAT412) { (CT).Fields412.Length = (L) - 3; (CT).Fields412.Displacement = (D) - 1; } \
    else if (F == FORMAT511) { (CT).Fields511.Length = (L) - 3; (CT).Fields511.Displacement = (D) - 1; } \
    else if (F == FORMAT610) { (CT).Fields610.Length = (L) - 3; (CT).Fields610.Displacement = (D) - 1; } \
    else if (F == FORMAT79)  { (CT).Fields79.Length  = (L) - 3; (CT).Fields79.Displacement  = (D) - 1; } \
    else if (F == FORMAT88)  { (CT).Fields88.Length  = (L) - 3; (CT).Fields88.Displacement  = (D) - 1; } \
    else if (F == FORMAT97)  { (CT).Fields97.Length  = (L) - 3; (CT).Fields97.Displacement  = (D) - 1; } \
    else if (F == FORMAT106) { (CT).Fields106.Length = (L) - 3; (CT).Fields106.Displacement = (D) - 1; } \
    else if (F == FORMAT115) { (CT).Fields115.Length = (L) - 3; (CT).Fields115.Displacement = (D) - 1; } \
    else                     { (CT).Fields124.Length = (L) - 3; (CT).Fields124.Displacement = (D) - 1; } \
}



//
//  Local support routine
//

NTSTATUS
LZNT1CompressChunk (
    IN PLZNT1_MATCH_FUNCTION MatchFunction,
    IN PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    OUT PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalCompressedChunkSize,
    IN PVOID WorkSpace
    )

/*++

Routine Description:

    This routine takes as input an uncompressed chunk and produces
    one compressed chunk provided the compressed data fits within
    the specified destination buffer.

    The LZNT1 format used to store the compressed buffer.

    An output variable indicates the number of bytes used to store
    the compressed chunk.

Arguments:

    UncompressedBuffer - Supplies a pointer to the uncompressed chunk.

    EndOfUncompressedBufferPlus1 - Supplies a pointer to the next byte
        following the end of the uncompressed buffer.  This is supplied
        instead of the size in bytes because our caller and ourselves
        test against the pointer and by passing the pointer we get to
        skip the code to compute it each time.

    CompressedBuffer - Supplies a pointer to where the compressed chunk
        is to be stored.

    EndOfCompressedBufferPlus1 - Supplies a pointer to the next
        byte following the end of the compressed buffer.

    FinalCompressedChunkSize - Receives the number of bytes needed in
        the compressed buffer to store the compressed chunk.

Return Value:

    STATUS_SUCCESS - the compression worked without a hitch.

    STATUS_BUFFER_ALL_ZEROS - the compression worked without a hitch and in
        addition the input chunk was all zeros.

    STATUS_BUFFER_TOO_SMALL - the compressed buffer is too small to hold the
        compressed data.

--*/

{
    PUCHAR EndOfCompressedChunkPlus1;

    PUCHAR InputPointer;
    PUCHAR OutputPointer;

    PUCHAR FlagPointer;
    UCHAR FlagByte;
    ULONG FlagBit;

    LONG Length;
    LONG Displacement;

    LZNT1_COPY_TOKEN CopyToken;

    COMPRESSED_CHUNK_HEADER ChunkHeader;

    UCHAR NullCharacter = 0;

    ULONG Format = FORMAT412;

    //
    //  First adjust the end of the uncompressed buffer pointer to the smaller
    //  of what we're passed in and the uncompressed chunk size.  We use this
    //  to make sure we never compress more than a chunk worth at a time
    //

    if ((UncompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE) < EndOfUncompressedBufferPlus1) {

        EndOfUncompressedBufferPlus1 = UncompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE;
    }

    //
    //  Now set the end of the compressed chunk pointer to be the smaller of the
    //  compressed size necessary to hold the data in an uncompressed form and
    //  the compressed buffer size.  We use this to decide if we can't compress
    //  any more because the buffer is too small or just because the data
    //  doesn't compress very well.
    //

    if ((CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE - 1) < EndOfCompressedBufferPlus1) {

        EndOfCompressedChunkPlus1 = CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE - 1;

    } else {

        EndOfCompressedChunkPlus1 = EndOfCompressedBufferPlus1;
    }

    //
    //  Now set the input and output pointers to the next byte we are
    //  go to process and asser that the user gave use buffers that were
    //  large enough to hold the minimum size chunks
    //

    InputPointer = UncompressedBuffer;
    OutputPointer = CompressedBuffer + sizeof(COMPRESSED_CHUNK_HEADER);

    ASSERT(InputPointer < EndOfUncompressedBufferPlus1);
    //**** ASSERT(OutputPointer + 2 <= EndOfCompressedChunkPlus1);

    //
    //  The flag byte stores a copy of the flags for the current
    //  run and the flag bit denotes the current bit position within
    //  the flag that we are processing.  The Flag pointer denotes
    //  where in the compressed buffer we will store the current
    //  flag byte
    //

    FlagPointer = OutputPointer++;
    FlagBit = 0;
    FlagByte = 0;

    ChunkHeader.Short = 0;

    //
    //  While there is some more data to be compressed we will do the
    //  following loop
    //

    ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->UncompressedBuffer = UncompressedBuffer;
    ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->EndOfUncompressedBufferPlus1 = EndOfUncompressedBufferPlus1;
    ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->MaxLength = FormatMaxLength[FORMAT412];

    while (InputPointer < EndOfUncompressedBufferPlus1) {

        while (UncompressedBuffer + FormatMaxDisplacement[Format] < InputPointer) {

            Format += 1;
            ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->MaxLength = FormatMaxLength[Format];
        }

        //
        //  Search for a string in the Lempel
        //

        Length = 0;
        if ((InputPointer + 3) <= EndOfUncompressedBufferPlus1) {

            Length = (MatchFunction)( InputPointer, WorkSpace );
        }

        //
        //  If the return length is zero then we need to output
        //  a literal.  We clear the flag bit to denote the literal
        //  output the charcter and build up a character bits
        //  composite that if it is still zero when we are done then
        //  we know the uncompressed buffer contained only zeros.
        //

        if (!Length) {

            //
            //  There is more data to output now make sure the output
            //  buffer is not already full and can contain at least one
            //  more byte
            //

            if (OutputPointer >= EndOfCompressedChunkPlus1) { break; }

            ClearFlag(FlagByte, (1 << FlagBit));

            NullCharacter |= *(OutputPointer++) = *(InputPointer++);

        } else {

            //
            //  We need to output two byte, now make sure that
            //  the output buffer can contain at least two more
            //  bytes.
            //

            if ((OutputPointer+1) >= EndOfCompressedChunkPlus1) { break; }

            //
            //  Compute the displacement from the current pointer
            //  to the matched string
            //

            Displacement = (ULONG)(InputPointer - ((PLZNT1_STANDARD_WORKSPACE)WorkSpace)->MatchedString);

            SetFlag(FlagByte, (1 << FlagBit));

            SetLZNT1(Format, CopyToken, (USHORT)Length, (USHORT)Displacement);

            *(OutputPointer++) = CopyToken.Bytes[0];
            *(OutputPointer++) = CopyToken.Bytes[1];

            InputPointer += Length;
        }

        //
        //  Now adjust the flag bit and check if the flag byte
        //  should now be output.  If so output the flag byte
        //  and scarf up a new byte in the output buffer for the
        //  next flag byte.  Do not advance OutputPointer if we
        //  have no more input anyway!
        //

        FlagBit = (FlagBit + 1) % 8;

        if (!FlagBit && (InputPointer < EndOfUncompressedBufferPlus1)) {

            *FlagPointer = FlagByte;
            FlagByte = 0;

            FlagPointer = (OutputPointer++);
        }
    }

    //
    //  We've exited the preceeding loop because either the input buffer is
    //  all compressed or because we ran out of space in the output buffer.
    //  Check here if the input buffer is not exhasted (i.e., we ran out
    //  of space)
    //

    if (InputPointer < EndOfUncompressedBufferPlus1) {

        //
        //  We ran out of space, but now if the total space available
        //  for the compressed chunk is equal to the uncompressed data plus
        //  the header then we will make this an uncompressed chunk and copy
        //  over the uncompressed data
        //

        if ((CompressedBuffer + MAX_UNCOMPRESSED_CHUNK_SIZE + sizeof(COMPRESSED_CHUNK_HEADER)) <= EndOfCompressedBufferPlus1) {

            RtlCopyMemory( CompressedBuffer + sizeof(COMPRESSED_CHUNK_HEADER),
                           UncompressedBuffer,
                           MAX_UNCOMPRESSED_CHUNK_SIZE );

            *FinalCompressedChunkSize = MAX_UNCOMPRESSED_CHUNK_SIZE + sizeof(COMPRESSED_CHUNK_HEADER);

            SetCompressedChunkHeader( ChunkHeader,
                                      (USHORT)*FinalCompressedChunkSize,
                                      FALSE );

            RtlStoreUshort( CompressedBuffer, ChunkHeader.Short );

            return STATUS_SUCCESS;
        }

        //
        //  Otherwise the input buffer really is too small to store the
        //  compressed chuunk
        //

        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  At this point the entire input buffer has been compressed so we need
    //  to output the last flag byte, provided it fits in the compressed buffer,
    //  set and store the chunk header.  Now if the Flag pointer doesn't fit
    //  in the output buffer that is because it is one beyond the end and
    //  we incremented output pointer too far so now bring output pointer
    //  back down.
    //

    if (FlagPointer < EndOfCompressedChunkPlus1) {

        *FlagPointer = FlagByte;

    } else {

        OutputPointer--;
    }

    *FinalCompressedChunkSize = (ULONG)(OutputPointer - CompressedBuffer);

    SetCompressedChunkHeader( ChunkHeader,
                              (USHORT)*FinalCompressedChunkSize,
                              TRUE );

    RtlStoreUshort( CompressedBuffer, ChunkHeader.Short );

    //
    //  Now if the only literal we ever output was a null then the
    //  input buffer was all zeros.
    //

    if (!NullCharacter) {

        return STATUS_BUFFER_ALL_ZEROS;
    }

    //
    //  Otherwise return to our caller
    //

    return STATUS_SUCCESS;
}


#if !defined(_ALPHA_)
#if !defined(_MIPS_)
#if !defined(_PPC_)
#if !defined(i386)
//
//  Local support routine
//

NTSTATUS
LZNT1DecompressChunk (
    OUT PUCHAR UncompressedBuffer,
    IN PUCHAR EndOfUncompressedBufferPlus1,
    IN PUCHAR CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PULONG FinalUncompressedChunkSize
    )

/*++

Routine Description:

    This routine takes as input a compressed chunk and produces its
    uncompressed equivalent chunk provided the uncompressed data fits
    within the specified destination buffer.

    The compressed buffer must be stored in the LZNT1 format.

    An output variable indicates the number of bytes used to store the
    uncompressed data.

Arguments:

    UncompressedBuffer - Supplies a pointer to where the uncompressed
        chunk is to be stored.

    EndOfUncompressedBufferPlus1 - Supplies a pointer to the next byte
        following the end of the uncompressed buffer.  This is supplied
        instead of the size in bytes because our caller and ourselves
        test against the pointer and by passing the pointer we get to
        skip the code to compute it each time.

    CompressedBuffer - Supplies a pointer to the compressed chunk.  (This
        pointer has already been adjusted to point past the chunk header.)

    EndOfCompressedBufferPlus1 - Supplies a pointer to the next
        byte following the end of the compressed buffer.

    FinalUncompressedChunkSize - Receives the number of bytes needed in
        the uncompressed buffer to store the uncompressed chunk.

Return Value:

    STATUS_SUCCESS - the decompression worked without a hitch.

    STATUS_BAD_COMPRESSION_BUFFER - the input compressed buffer is
        ill-formed.

--*/

{
    PUCHAR OutputPointer;
    PUCHAR InputPointer;

    UCHAR FlagByte;
    ULONG FlagBit;

    ULONG Format = FORMAT412;

    //
    //  The two pointers will slide through our input and input buffer.
    //  For the input buffer we skip over the chunk header.
    //

    OutputPointer = UncompressedBuffer;
    InputPointer = CompressedBuffer;

    //
    //  The flag byte stores a copy of the flags for the current
    //  run and the flag bit denotes the current bit position within
    //  the flag that we are processing
    //

    FlagByte = *(InputPointer++);
    FlagBit = 0;

    //
    //  While we haven't exhausted either the input or output buffer
    //  we will do some more decompression
    //

    while ((OutputPointer < EndOfUncompressedBufferPlus1) && (InputPointer < EndOfCompressedBufferPlus1)) {

        while (UncompressedBuffer + FormatMaxDisplacement[Format] < OutputPointer) { Format += 1; }

        //
        //  Check the current flag if it is zero then the current
        //  input token is a literal byte that we simply copy over
        //  to the output buffer
        //

        if (!FlagOn(FlagByte, (1 << FlagBit))) {

            *(OutputPointer++) = *(InputPointer++);

        } else {

            LZNT1_COPY_TOKEN CopyToken;
            LONG Displacement;
            LONG Length;

            //
            //  The current input is a copy token so we'll get the
            //  copy token into our variable and extract the
            //  length and displacement from the token
            //

            if (InputPointer+1 >= EndOfCompressedBufferPlus1) {

                *FinalUncompressedChunkSize = PtrToUlong(InputPointer);

                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            //
            //  Now grab the next input byte and extract the
            //  length and displacement from the copy token
            //

            CopyToken.Bytes[0] = *(InputPointer++);
            CopyToken.Bytes[1] = *(InputPointer++);

            Displacement = GetLZNT1Displacement(Format, CopyToken);
            Length = GetLZNT1Length(Format, CopyToken);

            //
            //  At this point we have the length and displacement
            //  from the copy token, now we need to make sure that the
            //  displacement doesn't send us outside the uncompressed buffer
            //

            if (Displacement > (OutputPointer - UncompressedBuffer)) {

                *FinalUncompressedChunkSize = PtrToUlong(InputPointer);

                return STATUS_BAD_COMPRESSION_BUFFER;
            }

            //
            //  We also need to adjust the length to keep the copy from
            //  overflowing the output buffer
            //

            if ((OutputPointer + Length) >= EndOfUncompressedBufferPlus1) {

                Length = (ULONG)(EndOfUncompressedBufferPlus1 - OutputPointer);
            }

            //
            //  Now we copy bytes.  We cannot use Rtl Move Memory here because
            //  it does the copy backwards from what the LZ algorithm needs.
            //

            while (Length > 0) {

                *(OutputPointer) = *(OutputPointer-Displacement);

                Length -= 1;
                OutputPointer += 1;
            }
        }

        //
        //  Before we go back to the start of the loop we need to adjust the
        //  flag bit value (it goes from 0, 1, ... 7) and if the flag bit
        //  is back to zero we need to read in the next flag byte.  In this
        //  case we are at the end of the input buffer we'll just break out
        //  of the loop because we're done.
        //

        FlagBit = (FlagBit + 1) % 8;

        if (!FlagBit) {

            if (InputPointer >= EndOfCompressedBufferPlus1) { break; }

            FlagByte = *(InputPointer++);
        }
    }

    //
    //  The decompression is done so now set the final uncompressed
    //  chunk size and return success to our caller
    //

    *FinalUncompressedChunkSize = (ULONG)(OutputPointer - UncompressedBuffer);

    return STATUS_SUCCESS;
}
#endif // i386
#endif // _MIPS_
#endif // _PPC_
#endif // _ALPHA_


//
//  Local support routine
//

ULONG
LZNT1FindMatchStandard (
    IN PUCHAR ZivString,
    IN PLZNT1_STANDARD_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine does the compression lookup.  It locates
    a match for the ziv within a specified uncompressed buffer.

Arguments:

    ZivString - Supplies a pointer to the Ziv in the uncompressed buffer.
        The Ziv is the string we want to try and find a match for.

Return Value:

    Returns the length of the match if the match is greater than three
    characters otherwise return 0.

--*/

{
    PUCHAR UncompressedBuffer = WorkSpace->UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1 = WorkSpace->EndOfUncompressedBufferPlus1;
    ULONG MaxLength = WorkSpace->MaxLength;

    ULONG Index;

    PUCHAR FirstEntry;
    ULONG  FirstLength;

    PUCHAR SecondEntry;
    ULONG  SecondLength;

    //
    //  First check if the Ziv is within two bytes of the end of
    //  the uncompressed buffer, if so then we can't match
    //  three or more characters
    //

    Index = ((40543*((((ZivString[0]<<4)^ZivString[1])<<4)^ZivString[2]))>>4) & 0xfff;

    FirstEntry  = WorkSpace->IndexPTable[Index][0];
    FirstLength = 0;

    SecondEntry  = WorkSpace->IndexPTable[Index][1];
    SecondLength = 0;

    //
    //  Check if first entry is good, and if so then get its length
    //

    if ((FirstEntry >= UncompressedBuffer) &&    //  is it within the uncompressed buffer?
        (FirstEntry < ZivString)           &&

        (FirstEntry[0] == ZivString[0])    &&    //  do at least 3 characters match?
        (FirstEntry[1] == ZivString[1])    &&
        (FirstEntry[2] == ZivString[2])) {

        FirstLength = 3;

        while ((FirstLength < MaxLength)

                 &&

               (ZivString + FirstLength < EndOfUncompressedBufferPlus1)

                 &&

               (ZivString[FirstLength] == FirstEntry[FirstLength])) {

            FirstLength++;
        }
    }

    //
    //  Check if second entry is good, and if so then get its length
    //

    if ((SecondEntry >= UncompressedBuffer) &&    //  is it within the uncompressed buffer?
        (SecondEntry < ZivString)           &&

        (SecondEntry[0] == ZivString[0])    &&    //  do at least 3 characters match?
        (SecondEntry[1] == ZivString[1])    &&
        (SecondEntry[2] == ZivString[2])) {

        SecondLength = 3;

        while ((SecondLength < MaxLength)

                 &&

               (ZivString + SecondLength< EndOfUncompressedBufferPlus1)

                 &&

               (ZivString[SecondLength] == SecondEntry[SecondLength])) {

            SecondLength++;
        }
    }

    if ((FirstLength >= SecondLength)) {

        WorkSpace->IndexPTable[Index][1] = FirstEntry;
        WorkSpace->IndexPTable[Index][0] = ZivString;

        WorkSpace->MatchedString = FirstEntry;
        return FirstLength;
    }

    WorkSpace->IndexPTable[Index][1] = FirstEntry;
    WorkSpace->IndexPTable[Index][0] = ZivString;

    WorkSpace->MatchedString = SecondEntry;
    return SecondLength;
}


//
//  Local support routine
//

ULONG
LZNT1FindMatchMaximum (
    IN PUCHAR ZivString,
    IN PLZNT1_MAXIMUM_WORKSPACE WorkSpace
    )

/*++

Routine Description:

    This routine does the compression lookup.  It locates
    a match for the ziv within a specified uncompressed buffer.

    If the matched string is two or more characters long then this
    routine does not update the lookup state information.

Arguments:

    ZivString - Supplies a pointer to the Ziv in the uncompressed buffer.
        The Ziv is the string we want to try and find a match for.

Return Value:

    Returns the length of the match if the match is greater than three
    characters otherwise return 0.

--*/

{
    PUCHAR UncompressedBuffer = WorkSpace->UncompressedBuffer;
    PUCHAR EndOfUncompressedBufferPlus1 = WorkSpace->EndOfUncompressedBufferPlus1;
    ULONG MaxLength = WorkSpace->MaxLength;

    ULONG i;
    ULONG BestMatchedLength;
    PUCHAR q;

    //
    //  First check if the Ziv is within two bytes of the end of
    //  the uncompressed buffer, if so then we can't match
    //  three or more characters
    //

    BestMatchedLength = 0;

    for (q = UncompressedBuffer; q < ZivString; q += 1) {

        i = 0;

        while ((i < MaxLength)

                 &&

               (ZivString + i < EndOfUncompressedBufferPlus1)

                 &&

               (ZivString[i] == q[i])) {

            i++;
        }

        if (i >= BestMatchedLength) {

            BestMatchedLength = i;
            WorkSpace->MatchedString = q;
        }
    }

    if (BestMatchedLength < 3) {

        return 0;

    } else {

        return BestMatchedLength;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\nlsxlat.c ===
/****************************** Module Header ******************************\
* Module Name: nlsxlat.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* This modules contains the private routines for character translation:
* 8-bit <=> Unicode.
*
* History:
* 03-Jan-1992    gregoryw
* 16-Feb-1993    JulieB      Added Upcase Routines & Macros.
* 17-Feb-1993    JulieB      Fixed Tables; Fixed DBCS Code.
* 08-Mar-1993    JulieB      Moved Upcase Macro to ntrtlp.h.
\***************************************************************************/

#include "ntrtlp.h"

/*
 * Global data used by the translation routines.
 *
 */

//
// Upcase and Lowercase data
//
const UCHAR Nls844UnicodeCaseTableLevel1[] = {
    0x00,0x10,0x20,0x30,0x40,0x50,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x00
    0x70,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x80,0x90,  // 0x10
    0x60,0xa0,0x60,0x60,0xb0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x20
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x30
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x40
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x50
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x60
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x70
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x80
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0x90
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0xa0
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0xb0
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0xc0
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0xd0
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,  // 0xe0
    0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0xc0,  // 0xf0
};

const UCHAR Nls844UnicodeUpcaseTableLevel2[] = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x91,  // 0x00
    0x95,0x95,0x95,0x99,0x9c,0x95,0x95,0x17,0xa0,0xa4,0xa8,0xac,0xb0,0xb4,0x95,0xb8,  // 0x10
    0x95,0xbb,0x00,0x00,0x00,0xbf,0xc3,0xc7,0xcb,0xcf,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x20
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd0,0x04,0xd4,0x00,0xd8,0x00,  // 0x30
    0x00,0x00,0x00,0x0a,0x0a,0x47,0x95,0x95,0xdc,0x95,0x95,0x95,0xe0,0x95,0x96,0xe4,  // 0x40
    0x00,0x00,0x00,0x00,0x00,0x00,0x57,0x58,0x5b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x50
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x60
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x70
    0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0xdb,0x95,0x95,0x95,0x95,0x95,0xda,  // 0x80
    0x6c,0x70,0x6c,0x6c,0x70,0x74,0x6c,0xe8,0x00,0x00,0x00,0xec,0x00,0xec,0xf0,0x00,  // 0x90
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x87,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0xa0
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8d,0xf4,0x00,  // 0xb0
    0x00,0x00,0x00,0x00,0x04,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0xc0
};

const UCHAR Nls844UnicodeLowercaseTableLevel2[] = {
    0x00,0x00,0x00,0x00,0x04,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x0d,0x00,0x00,  // 0x00
    0x11,0x11,0x11,0x15,0x17,0x11,0x11,0x1a,0x1e,0x22,0x26,0x2a,0x2e,0x31,0x11,0x35,  // 0x10
    0x11,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x20
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3b,0x04,0x3f,0x00,0x00,0x00,0x43,0x00,  // 0x30
    0x47,0x0a,0x0a,0x00,0x00,0x00,0x11,0x11,0x4b,0x11,0x11,0x11,0x4f,0x11,0x12,0x53,  // 0x40
    0x00,0x00,0x00,0x57,0x58,0x5b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x50
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0x60
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x58,0x5f,0x00,0x00,0x00,  // 0x70
    0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x63,0x11,0x11,0x11,0x11,0x11,0x67,  // 0x80
    0x6a,0x6e,0x6a,0x6a,0x6e,0x72,0x6a,0x00,0x00,0x00,0x00,0x76,0x79,0x7c,0x7f,0x83,  // 0x90
    0x00,0x00,0x00,0x00,0x00,0x00,0x87,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0xa0
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x8b,0x8d,0x00,0x00,0x00,  // 0xb0
    0x00,0x00,0x04,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  // 0xc0
};

const USHORT Nls844UnicodeCaseTableLevel3[] = {
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x00
    0x0000,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,  // 0x01
    0x0020,0x0020,0x0020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,  // 0x02
    0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0000,0x0020,0x0020,0x0020,0x0020,  // 0x03
    0x0020,0x0020,0x0020,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,  // 0x04
    0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,0x0001,  // 0x05
    0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,  // 0x06
    0xff87,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x00d2,0x0001,0x0000,0x0001,0x0000,0x00ce,0x0001,  // 0x07
    0x0000,0x00cd,0x00cd,0x0001,0x0000,0x0000,0x004f,0x00ca,0x00cb,0x0001,0x0000,0x00cd,0x00cf,0x0000,0x00d3,0x00d1,  // 0x08
    0x0001,0x0000,0x0000,0x0000,0x00d3,0x00d5,0x0000,0x00d6,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,  // 0x09
    0x0000,0x00da,0x0000,0x0000,0x0001,0x0000,0x00da,0x0001,0x0000,0x00d9,0x00d9,0x0001,0x0000,0x0001,0x0000,0x00db,  // 0x0a
    0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0002,0x0000,0x0000,0x0002,  // 0x0b
    0x0000,0x0000,0x0002,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,  // 0x0c
    0x0000,0x0000,0x0001,0x0000,0x0000,0x0002,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,  // 0x0d
    0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x0e
    0x0000,0x0000,0x0026,0x0000,0x0025,0x0025,0x0025,0x0000,0x0040,0x0000,0x003f,0x003f,0x0020,0x0020,0x0000,0x0020,  // 0x0f
    0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,  // 0x10
    0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0050,0x0050,0x0050,  // 0x11
    0x0050,0x0050,0x0050,0x0050,0x0050,0x0050,0x0050,0x0050,0x0050,0x0000,0x0050,0x0050,0x0001,0x0000,0x0000,0x0000,  // 0x12
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,  // 0x13
    0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,  // 0x14
    0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0030,0x0030,0x0030,  // 0x15
    0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,0x0030,  // 0x16
    0x0030,0x0030,0x0030,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0030,0x0030,0x0030,0x0030,  // 0x17
    0x0030,0x0030,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,  // 0x18
    0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,  // 0x19
    0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x1a
    0xfff8,0xfff8,0xfff8,0xfff8,0xfff8,0xfff8,0xfff8,0xfff8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x1b
    0xfff8,0xfff8,0xfff8,0xfff8,0xfff8,0xfff8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x1c
    0x0000,0xfff8,0x0000,0xfff8,0x0000,0xfff8,0x0000,0xfff8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x1d
    0xfff8,0xfff8,0xffb6,0xffb6,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xffaa,0xffaa,0xffaa,0xffaa,  // 0x1e
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0xfff8,0xfff8,0xff9c,0xff9c,0x0000,0x0000,0x0000,0x0000,  // 0x1f
    0x0000,0x0000,0x0000,0x0000,0xfff8,0xfff8,0xff90,0xff90,0xfff9,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x20
    0x0000,0x0000,0x0000,0x0000,0xff80,0xff80,0xff82,0xff82,0x0000,0x0000,0x0000,0x0000,0x0010,0x0010,0x0010,0x0010,  // 0x21
    0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0010,0x0000,0x0000,0x0000,0x0000,  // 0x22
    0x0000,0x0000,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,  // 0x23
    0x001a,0x001a,0x001a,0x001a,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0000,0x0020,0x0020,0x0020,0x0020,  // 0x24
    0x0020,0x0020,0x0020,0xff87,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,  // 0x25
    0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,  // 0x26
    0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,  // 0x27
    0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,  // 0x28
    0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x29
    0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,  // 0x2a
    0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,  // 0x2b
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0002,0x0000,0x0000,0x0002,0x0000,0x0000,0x0002,0x0000,0x0001,0x0000,  // 0x2c
    0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x004f,0x0000,0x0001,  // 0x2d
    0x0000,0x0000,0x0000,0x0002,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,  // 0x2e
    0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x00d2,  // 0x2f
    0x00ce,0x0000,0x00cd,0x00cd,0x0000,0x00ca,0x0000,0x00cb,0x0000,0x0000,0x0000,0x0000,0x00cd,0x0000,0x0000,0x00cf,  // 0x30
    0x0000,0x0000,0x0000,0x0000,0x00d1,0x00d3,0x0000,0x0000,0x0000,0x0000,0x0000,0x00d3,0x0000,0x0000,0x00d5,0x0000,  // 0x31
    0x0000,0x00d6,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x00da,  // 0x32
    0x0000,0x0000,0x0000,0x0000,0x00da,0x0000,0x00d9,0x00d9,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x00db,0x0000,  // 0x33
    0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0026,0x0025,0x0025,0x0025,  // 0x34
    0x0020,0x0020,0x001f,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0020,0x0040,0x003f,0x003f,0x0000,  // 0x35
    0x0000,0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,  // 0x36
    0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x37
    0x0000,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,  // 0x38
    0x0000,0x0001,0x0000,0x0001,0x0000,0x0001,0x0000,0x0000,0x0000,0x0001,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x39
    0xffb6,0xffb6,0xffaa,0xffaa,0xffaa,0xffaa,0xff9c,0xff9c,0xff80,0xff80,0xff90,0xff90,0xff82,0xff82,0x0000,0x0000,  // 0x3a
    0xfff8,0xfff8,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x3b
    0xfff8,0xfff8,0x0000,0x0000,0x0000,0xfff9,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x3c
    0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x001a,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,  // 0x3d
};


NTSTATUS
RtlMultiByteToUnicodeN(
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCH MultiByteString,
    IN ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    ANSI Code Page (ACP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the ansi source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of MultiByteString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    MultiByteString - Supplies the ansi source string that is to be
        converted to unicode.  For single-byte character sets, this address
        CAN be the same as UnicodeString.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful.


--*/

{
    ULONG LoopCount;
    ULONG MaxCharsInUnicodeString;

    RTL_PAGED_CODE();

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
                 MaxCharsInUnicodeString : BytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInUnicodeString))
        *BytesInUnicodeString = LoopCount * sizeof(WCHAR);

    while (LoopCount) {

        *UnicodeString = (WCHAR)(UCHAR)(*MultiByteString);

        UnicodeString++;
        MultiByteString++;
        LoopCount--;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlMultiByteToUnicodeSize(
    OUT PULONG BytesInUnicodeString,
    IN PCH MultiByteString,
    IN ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions determines how many bytes would be needed to represent
    the specified ANSI source string in Unicode string (not counting the
    null terminator)
    The translation is done with respect to the ANSI Code Page (ACP) installed
    at boot time.  Single byte characters in the range 0x00 - 0x7f are simply
    zero extended as a performance enhancement.  In some far eastern code pages
    0x5c is defined as the Yen sign.  For system translation we always want to
    consider 0x5c to be the backslash character.  We get this for free by zero
    extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    BytesInUnicodeString - Returns the number of bytes a Unicode translation
        of the ANSI string pointed to by MultiByteString would contain.

    MultiByteString - Supplies the ansi source string whose Unicode length
        is to be calculated.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful


--*/

{
    RTL_PAGED_CODE();

    *BytesInUnicodeString = BytesInMultiByteString * sizeof(WCHAR);

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUnicodeToMultiByteSize(
    OUT PULONG BytesInMultiByteString,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions determines how many bytes would be needed to represent
    the specified Unicode source string as an ANSI string (not counting the
    null terminator)

Arguments:

    BytesInMultiByteString - Returns the number of bytes an ANSI translation
        of the Unicode string pointed to by UnicodeString would contain.

    UnicodeString - Supplies the unicode source string whose ANSI length
        is to be calculated.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The conversion failed.  A unicode character was encountered
        that has no translation for the current ANSI Code Page (ACP).

--*/

{
    RTL_PAGED_CODE();

    *BytesInMultiByteString = BytesInUnicodeString / sizeof(WCHAR);

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG LoopCount;
    ULONG CharsInUnicodeString;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                 CharsInUnicodeString : MaxBytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInMultiByteString))
        *BytesInMultiByteString = LoopCount;

    while (LoopCount) {

        *MultiByteString = (*UnicodeString < 256) ? (UCHAR)*UnicodeString : '?';

        UnicodeString++;
        MultiByteString++;
        LoopCount--;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
RtlUpcaseUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    converts it into an ansi string. The translation is done with respect
    to the ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        upper case of the unicode source string.  If the translation can
        not be done, an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG LoopCount;
    ULONG CharsInUnicodeString;
    WCHAR UnicodeChar;

    RTL_PAGED_CODE();

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                 CharsInUnicodeString : MaxBytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInMultiByteString))
        *BytesInMultiByteString = LoopCount;

    while (LoopCount) {

        //
        // Convert to ANSI and back to Unicode before upper casing
        // to ensure the visual best fits are converted and
        // upper cased properly.
        //
        UnicodeChar = (*UnicodeString < 256) ? *UnicodeString : L'?';
        UnicodeChar = NLS_UPCASE(UnicodeChar);

        *MultiByteString = (UnicodeChar < 256) ? (UCHAR)UnicodeChar : '?';

        UnicodeString++;
        MultiByteString++;
        LoopCount--;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\random.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Random.c

Abstract:

    This module implements a simple random number generator

Author:

    Gary Kimura     [GaryKi]    26-May-1989

Environment:

    Pure utility routine

Revision History:

--*/

#include <ntrtlp.h>

#define Multiplier ((ULONG)(0x80000000ul - 19)) // 2**31 - 19
#define Increment  ((ULONG)(0x80000000ul - 61)) // 2**31 - 61
#define Modulus    ((ULONG)(0x80000000ul - 1))  // 2**31 - 1

ULONG RtlpRandomConstantVector[128] = {
    0x4c8bc0aa, 0x4c022957, 0x2232827a, 0x2f1e7626, 0x7f8bdafb, 0x5c37d02a, 0x0ab48f72, 0x2f0c4ffa,
    0x290e1954, 0x6b635f23, 0x5d3885c0, 0x74b49ff8, 0x5155fa54, 0x6214ad3f, 0x111e9c29, 0x242a3a09,
    0x75932ae1, 0x40ac432e, 0x54f7ba7a, 0x585ccbd5, 0x6df5c727, 0x0374dad1, 0x7112b3f1, 0x735fc311,
    0x404331a9, 0x74d97781, 0x64495118, 0x323e04be, 0x5974b425, 0x4862e393, 0x62389c1d, 0x28a68b82,
    0x0f95da37, 0x7a50bbc6, 0x09b0091c, 0x22cdb7b4, 0x4faaed26, 0x66417ccd, 0x189e4bfa, 0x1ce4e8dd,
    0x5274c742, 0x3bdcf4dc, 0x2d94e907, 0x32eac016, 0x26d33ca3, 0x60415a8a, 0x31f57880, 0x68c8aa52,
    0x23eb16da, 0x6204f4a1, 0x373927c1, 0x0d24eb7c, 0x06dd7379, 0x2b3be507, 0x0f9c55b1, 0x2c7925eb,
    0x36d67c9a, 0x42f831d9, 0x5e3961cb, 0x65d637a8, 0x24bb3820, 0x4d08e33d, 0x2188754f, 0x147e409e,
    0x6a9620a0, 0x62e26657, 0x7bd8ce81, 0x11da0abb, 0x5f9e7b50, 0x23e444b6, 0x25920c78, 0x5fc894f0,
    0x5e338cbb, 0x404237fd, 0x1d60f80f, 0x320a1743, 0x76013d2b, 0x070294ee, 0x695e243b, 0x56b177fd,
    0x752492e1, 0x6decd52f, 0x125f5219, 0x139d2e78, 0x1898d11e, 0x2f7ee785, 0x4db405d8, 0x1a028a35,
    0x63f6f323, 0x1f6d0078, 0x307cfd67, 0x3f32a78a, 0x6980796c, 0x462b3d83, 0x34b639f2, 0x53fce379,
    0x74ba50f4, 0x1abc2c4b, 0x5eeaeb8d, 0x335a7a0d, 0x3973dd20, 0x0462d66b, 0x159813ff, 0x1e4643fd,
    0x06bc5c62, 0x3115e3fc, 0x09101613, 0x47af2515, 0x4f11ec54, 0x78b99911, 0x3db8dd44, 0x1ec10b9b,
    0x5b5506ca, 0x773ce092, 0x567be81a, 0x5475b975, 0x7a2cde1a, 0x494536f5, 0x34737bb4, 0x76d9750b,
    0x2a1f6232, 0x2e49644d, 0x7dddcbe7, 0x500cebdb, 0x619dab9e, 0x48c626fe, 0x1cda3193, 0x52dabe9d
    };

#if !defined(NTOS_KERNEL_RUNTIME)
ULONG
RtlUniform (
    IN OUT PULONG Seed
    )

/*++

Routine Description:

    A simple uniform random number generator, based on D.H. Lehmer's 1948
    alrogithm.

Arguments:

    Seed - Supplies a pointer to the random number generator seed.

Return Value:

    ULONG - returns a random number uniformly distributed over [0..MAXLONG]

--*/

{
    *Seed = ((Multiplier * (*Seed)) + Increment) % Modulus;
    return *Seed;
}
#endif

#define UniformMacro(Seed) (                                 \
    *Seed = (((Multiplier * (*Seed)) + Increment) % Modulus) \
    )


ULONG
RtlRandom (
    IN OUT PULONG Seed
    )

/*++

Routine Description:

    An every better random number generator based on MacLaren and Marsaglia.

Arguments:

    Seed - Supplies a pointer to the random number generator seed.

Return Value:

    ULONG - returns a random number uniformly distributed over [0..MAXLONG]

--*/

{
    ULONG X;
    ULONG Y;
    ULONG j;
    ULONG Result;

    // RTL_PAGED_CODE();

    X = UniformMacro(Seed);
    Y = UniformMacro(Seed);

    j = Y % 128;

    Result = RtlpRandomConstantVector[j];

    RtlpRandomConstantVector[j] = X;

    return Result;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\resource.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    Resource.c

Abstract:

    This module implements the executive functions to acquire and release
    a shared resource.

--*/

#include "ntrtlp.h"

VOID
RtlInitializeCriticalSection(
    IN PRTL_CRITICAL_SECTION CriticalSection
    )

/*++

Routine Description:

    This routine initializes the input critial section variable

Arguments:

    CriticalSection - Supplies the resource variable being initialized

Return Value:

    TBD - Status of semaphore creation.

--*/

{
    ASSERT(sizeof(CriticalSection->Synchronization.RawEvent) == sizeof(KEVENT));

    KeInitializeEvent((PKEVENT)&CriticalSection->Synchronization.RawEvent,
        SynchronizationEvent, FALSE);

    CriticalSection->LockCount = -1;
    CriticalSection->RecursionCount = 0;
    CriticalSection->OwningThread = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\ntrtlp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntrtlp.h

Abstract:

    Include file for NT runtime routines that are callable by both
    kernel mode code in the executive and user mode code in various
    NT subsystems, but which are private interfaces.

Author:

    David N. Cutler (davec) 15-Aug-1989

Environment:

    These routines are statically linked in the caller's executable and
    are callable in either kernel mode or user mode.

Revision History:

--*/

#ifndef _NTRTLP_
#define _NTRTLP_
#include <ntos.h>
#include <nturtl.h>
#include <zwapi.h>

#ifdef _X86_
#include    "i386\ntrtl386.h"
#endif

#ifdef BLDR_KERNEL_RUNTIME
#undef try
#define try if(1)
#undef except
#define except(a) else if (0)
#undef finally
#define finally if (1)
#undef GetExceptionCode
#define GetExceptionCode() 1
#define finally if (1)
#endif

#ifdef NTOS_KERNEL_RUNTIME
#define RtlAllocateStringRoutine(cb) ExAllocatePoolWithTag((cb), 'grtS')
#define RtlFreeStringRoutine(pv) ExFreePool(pv)
#endif

#include "string.h"
#include "wchar.h"

//
//  Machine state reporting.  See machine specific includes for more.
//

VOID
RtlpGetStackLimits (
    OUT PULONG_PTR LowLimit,
    OUT PULONG_PTR HighLimit
    );

LONG
LdrpCompareResourceNames(
    IN ULONG ResourceName,
    IN PIMAGE_RESOURCE_DIRECTORY ResourceDirectory,
    IN PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry
    );

NTSTATUS
LdrpSearchResourceSection(
    IN PVOID DllHandle,
    IN PULONG_PTR ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN BOOLEAN FindDirectoryEntry,
    OUT PVOID *ResourceDirectoryOrData
    );

LONG
LdrpCompareResourceNames_U(
    IN ULONG_PTR ResourceName,
    IN PIMAGE_RESOURCE_DIRECTORY ResourceDirectory,
    IN PIMAGE_RESOURCE_DIRECTORY_ENTRY ResourceDirectoryEntry
    );

NTSTATUS
LdrpSearchResourceSection_U(
    IN PVOID DllHandle,
    IN PULONG_PTR ResourceIdPath,
    IN ULONG ResourceIdPathLength,
    IN BOOLEAN FindDirectoryEntry,
    IN BOOLEAN ExactMatchOnly,
    OUT PVOID *ResourceDirectoryOrData
    );

NTSTATUS
LdrpAccessResourceData(
    IN PVOID DllHandle,
    IN PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry,
    OUT PVOID *Address OPTIONAL,
    OUT PULONG Size OPTIONAL
    );

extern CONST CCHAR RtlpBitsClearAnywhere[256];
extern CONST CCHAR RtlpBitsClearLow[256];
extern CONST CCHAR RtlpBitsClearHigh[256];
extern CONST CCHAR RtlpBitsClearTotal[256];

//
//  Macro that tells how many contiguous bits are set (i.e., 1) in
//  a byte
//

#define RtlpBitSetAnywhere( Byte ) RtlpBitsClearAnywhere[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many contiguous LOW order bits are set
//  (i.e., 1) in a byte
//

#define RtlpBitsSetLow( Byte ) RtlpBitsClearLow[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many contiguous HIGH order bits are set
//  (i.e., 1) in a byte
//

#define RtlpBitsSetHigh( Byte ) RtlpBitsClearHigh[ (~(Byte) & 0xFF) ]


//
//  Macro that tells how many set bits (i.e., 1) there are in a byte
//

#define RtlpBitsSetTotal( Byte ) RtlpBitsClearTotal[ (~(Byte) & 0xFF) ]



//
// Upcase data table
//

extern const UCHAR Nls844UnicodeCaseTableLevel1[];
extern const UCHAR Nls844UnicodeUpcaseTableLevel2[];
extern const UCHAR Nls844UnicodeLowercaseTableLevel2[];
extern const USHORT Nls844UnicodeCaseTableLevel3[];


//
// Macros for Upper Casing a Unicode Code Point.
//

#define LOBYTE(w)           ((UCHAR)((w)))
#define HIBYTE(w)           ((UCHAR)(((USHORT)((w)) >> 8) & 0xFF))
#define GET8(w)             ((ULONG)(((w) >> 8) & 0xff))
#define GETHI4(w)           ((ULONG)(((w) >> 4) & 0xf))
#define GETLO4(w)           ((ULONG)((w) & 0xf))

/***************************************************************************\
* TRAVERSE844W
*
* Traverses the 8:4:4 translation table for the given wide character.  It
* returns the final value of the 8:4:4 table, which is a WORD in length.
*
*   Broken Down Version:
*   --------------------
*       Incr = pTable[GET8(wch)];
*       Incr = pTable[Incr + GETHI4(wch)];
*       Value = pTable[Incr + GETLO4(wch)];
*
* DEFINED AS A MACRO.
*
* 05-31-91    JulieB    Created.
\***************************************************************************/

#define TRAVERSE844W(pTable, wch)                                           \
    Nls844UnicodeCaseTableLevel3[(4*((pTable)[Nls844UnicodeCaseTableLevel1[GET8(wch)] + GETHI4(wch)])) + GETLO4(wch)]

//
// NLS_UPCASE - Based on julieb's macros in nls.h
//
// We will have this upcase macro quickly shortcircuit out if the value
// is within the normal ANSI range (i.e., < 127).  We actually won't bother
// with the 5 values above 'z' because they won't happen very often and
// coding it this way lets us get out after 1 compare for value less than
// 'a' and 2 compares for lowercase a-z.
//

#define NLS_UPCASE(wch) (                                                   \
    ((wch) < 'a' ?                                                          \
        (wch)                                                               \
    :                                                                       \
        ((wch) <= 'z' ?                                                     \
            (wch) - ('a'-'A')                                               \
        :                                                                   \
            ((WCHAR)((wch) - TRAVERSE844W(Nls844UnicodeUpcaseTableLevel2,(wch)))) \
        )                                                                   \
    )                                                                       \
)

#define NLS_DOWNCASE(wch) (                                                 \
    ((wch) < 'A' ?                                                          \
        (wch)                                                               \
    :                                                                       \
        ((wch) <= 'Z' ?                                                     \
            (wch) + ('a'-'A')                                               \
        :                                                                   \
            ((WCHAR)((wch) + TRAVERSE844W(Nls844UnicodeLowercaseTableLevel2,(wch)))) \
        )                                                                   \
    )                                                                       \
)

#if DBG && defined(NTOS_KERNEL_RUNTIME)
#define RTL_PAGED_CODE() PAGED_CODE()
#else
#define RTL_PAGED_CODE()
#endif


//
// The follow definition is used to support the Rtl compression engine
// Every compression format that NT supports will need to supply
// these set of routines in order to be called by NtRtl.
//

typedef NTSTATUS (*PRTL_COMPRESS_WORKSPACE_SIZE) (
    IN USHORT CompressionEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );

typedef NTSTATUS (*PRTL_COMPRESS_BUFFER) (
    IN USHORT CompressionEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );

typedef NTSTATUS (*PRTL_DECOMPRESS_BUFFER) (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

typedef NTSTATUS (*PRTL_DECOMPRESS_FRAGMENT) (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

typedef NTSTATUS (*PRTL_DESCRIBE_CHUNK) (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

typedef NTSTATUS (*PRTL_RESERVE_CHUNK) (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

//
// Here is the declarations of the LZNT1 routines
//

NTSTATUS
RtlCompressWorkSpaceSizeLZNT1 (
    IN USHORT CompressionEngine,
    OUT PULONG CompressBufferWorkSpaceSize,
    OUT PULONG CompressFragmentWorkSpaceSize
    );

NTSTATUS
RtlCompressBufferLZNT1 (
    IN USHORT CompressionEngine,
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG UncompressedChunkSize,
    OUT PULONG FinalCompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlDecompressBufferLZNT1 (
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

NTSTATUS
RtlDecompressFragmentLZNT1 (
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

NTSTATUS
RtlDescribeChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

NTSTATUS
RtlReserveChunkLZNT1 (
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

//
// Define procedure prototypes for architecture specific debug support routines.
//

NTSTATUS
DebugPrint(
    IN PSTRING Output
    );

ULONG
DebugPrompt(
    IN PSTRING Output,
    IN PSTRING Input
    );


//
// Define procedure prototypes for slist manipulation and general lookaside lists
//

/*++

VOID
RtlpInitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

#define RtlpInitializeSListHead(_listhead_) (_listhead_)->Alignment = 0

/*++

USHORT
RtlpQueryDepthSListHead (
    IN PSLIST_HEADERT SListHead
    )

Routine Description:

    This function queries the current number of entries contained in a
    sequenced single linked list.

Arguments:

    SListHead - Supplies a pointer to the sequenced listhead which is
        be queried.

Return Value:

    The current number of entries in the sequenced singly linked list is
    returned as the function value.

--*/

#define RtlpQueryDepthSList(_listhead_) (_listhead_)->Depth

PVOID
FASTCALL
RtlpInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

PVOID
FASTCALL
RtlpInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PVOID ListEntry
    );


#if defined(NTOS_KERNEL_RUNTIME) || defined(BLDR_KERNEL_RUNTIME)

VOID
DebugLoadImageSymbols(
    IN PSTRING FileName,
    IN PKD_SYMBOLS_INFO SymbolInfo
    );

VOID
DebugUnLoadImageSymbols(
    IN PSTRING FileName,
    IN PKD_SYMBOLS_INFO SymbolInfo
    );

#endif // defined(NTOS_KERNEL_RUNTIME)

#endif  // _NTRTLP_

//
// Procedure prototype for exception logging routines.

ULONG
RtlpLogExceptionHandler(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN ULONG_PTR ControlPc,
    IN PVOID HandlerData,
    IN ULONG Size
    );

VOID
RtlpLogLastExceptionDisposition(
    IN ULONG LogIndex,
    IN EXCEPTION_DISPOSITION Disposition
    );

#ifndef NTOS_KERNEL_RUNTIME

#define NO_ALTERNATE_RESOURCE_MODULE    (PVOID)(-1)

typedef struct _ALT_RESOURCE_MODULE {
    //
    // Module handle for module known to application,
    // whose resource accesses we want to redirect.
    //
    PVOID ModuleBase;
    //
    // Module handle for module we loaded under the covers,
    // to which resource access will be redirected; will be
    // NO_ALTERNATE_RESOURCE_MODULE if we tried and failed to load
    // the alternate resource module for the module represented by
    // ModuleBase.
    //
    PVOID AlternateModule;
} ALT_RESOURCE_MODULE, *PALT_RESOURCE_MODULE;

BOOLEAN
LdrpVerifyAlternateResourceModule(
    IN PVOID Module,
    IN PVOID AlternateModule
    );

BOOLEAN
LdrpSetAlternateResourceModuleHandle(
    IN PVOID Module,
    IN PVOID AlternateModule
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\nls.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    nls.c

Abstract:

    This module implements NLS support functions for NT.

Author:

    Mark Lucovsky (markl) 16-Apr-1991

Environment:

    Kernel or user-mode

Revision History:

    16-Feb-1993    JulieB    Added Upcase Rtl Routines.
    08-Mar-1993    JulieB    Moved Upcase Macro to ntrtlp.h.
    02-Apr-1993    JulieB    Fixed RtlAnsiCharToUnicodeChar to use transl. tbls.
    02-Apr-1993    JulieB    Fixed BUFFER_TOO_SMALL check.
    28-May-1993    JulieB    Fixed code to properly handle DBCS.

--*/

#include "ntrtlp.h"

NTSTATUS
RtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the ansi source string. The maximum length field is only
        set if AllocateDestinationString is TRUE.

    SourceString - Supplies the ansi source string that is to be
        converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index;
    NTSTATUS st;

    RTL_PAGED_CODE();

    UnicodeLength = RtlAnsiStringToUnicodeSize(SourceString);
    if ( UnicodeLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)UnicodeLength;
        DestinationString->Buffer = RtlAllocateStringRoutine(UnicodeLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    st = RtlMultiByteToUnicodeN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            RtlFreeStringRoutine(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index / sizeof(WCHAR)] = UNICODE_NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
RtlUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to ansi.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG AnsiLength;
    ULONG Index;
    NTSTATUS st;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;

    RTL_PAGED_CODE();

    AnsiLength = RtlUnicodeStringToAnsiSize(SourceString);
    if ( AnsiLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(AnsiLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)AnsiLength;
        DestinationString->Buffer = RtlAllocateStringRoutine(AnsiLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            /*
             * Return STATUS_BUFFER_OVERFLOW, but translate as much as
             * will fit into the buffer first.  This is the expected
             * behavior for routines such as GetProfileStringA.
             * Set the length of the buffer to one less than the maximum
             * (so that the trail byte of a double byte char is not
             * overwritten by doing DestinationString->Buffer[Index] = '\0').
             * RtlUnicodeToMultiByteN is careful not to truncate a
             * multibyte character.
             */
            if (!DestinationString->MaximumLength) {
                return STATUS_BUFFER_OVERFLOW;
            }
            ReturnStatus = STATUS_BUFFER_OVERFLOW;
            DestinationString->Length = DestinationString->MaximumLength - 1;
            }
        }

    st = RtlUnicodeToMultiByteN(
             DestinationString->Buffer,
             DestinationString->Length,
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
        if ( AllocateDestinationString ) {
            RtlFreeStringRoutine(DestinationString->Buffer);
            DestinationString->Buffer = NULL;
        }

        return st;
    }

    DestinationString->Buffer[Index] = '\0';

    return ReturnStatus;
}

NTSTATUS
RtlUpcaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    upcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the upcased equivalent
        to the unicode source string.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        upcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;

    RTL_PAGED_CODE();

    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = RtlAllocateStringRoutine((ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
        DestinationString->Buffer[Index] = (WCHAR)NLS_UPCASE(SourceString->Buffer[Index]);
    }

    DestinationString->Length = SourceString->Length;

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDowncaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into a
    downcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the downcased
        equivalent to the unicode source string.  The maximum length field
        is only set if AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        downcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;

    RTL_PAGED_CODE();

    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = RtlAllocateStringRoutine((ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
        DestinationString->Buffer[Index] = (WCHAR)NLS_DOWNCASE(SourceString->Buffer[Index]);
    }

    DestinationString->Length = SourceString->Length;

    return STATUS_SUCCESS;
}


WCHAR
RtlUpcaseUnicodeChar(
    IN WCHAR SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified unicode character to its
    equivalent upcased unicode chararacter.  The purpose for this routine
    is to allow for character by character upcase translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies the unicode character to be upcased.

Return Value:

    Returns the upcased unicode equivalent of the specified input character.

--*/

{
    RTL_PAGED_CODE();

    //
    // Note that this needs to reference the translation table !
    //

    return (WCHAR)NLS_UPCASE(SourceCharacter);
}



WCHAR
RtlDowncaseUnicodeChar(
    IN WCHAR SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified unicode character to its
    equivalent downcased unicode chararacter.  The purpose for this routine
    is to allow for character by character downcase translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies the unicode character to be downcased.

Return Value:

    Returns the downcased unicode equivalent of the specified input character.

--*/

{
    RTL_PAGED_CODE();

    //
    // Note that this needs to reference the translation table !
    //

    return (WCHAR)NLS_DOWNCASE(SourceCharacter);
}


VOID
RtlFreeUnicodeString(
    IN OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlAnsiStringToUnicodeString.  Note that only UnicodeString->Buffer
    is free'd by this routine.

Arguments:

    UnicodeString - Supplies the address of the unicode string whose
        buffer was previously allocated by RtlAnsiStringToUnicodeString.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    if (UnicodeString->Buffer) {
        RtlFreeStringRoutine(UnicodeString->Buffer);
        memset( UnicodeString, 0, sizeof( *UnicodeString ) );
        }
}


VOID
RtlFreeAnsiString(
    IN OUT PANSI_STRING AnsiString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToAnsiString.  Note that only AnsiString->Buffer
    is free'd by this routine.

Arguments:

    AnsiString - Supplies the address of the ansi string whose buffer
        was previously allocated by RtlUnicodeStringToAnsiString.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    if (AnsiString->Buffer) {
        RtlFreeStringRoutine(AnsiString->Buffer);
        memset( AnsiString, 0, sizeof( *AnsiString ) );
        }
}


LONG
RtlCompareUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareUnicodeString function compares two counted strings.  The
    return value indicates if the strings are equal or String1 is less than
    String2 or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    PWCHAR s1, s2, Limit;
    LONG n1, n2;
    WCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = String1->Length;
    n2 = String2->Length;

    ASSERT((n1 & 1) == 0);
    ASSERT((n2 & 1) == 0);
    ASSERT(!(((((ULONG_PTR)s1 & 1) != 0) || (((ULONG_PTR)s2 & 1) != 0)) && (n1 != 0) && (n2 != 0)));

    Limit = (PWCHAR)((PCHAR)s1 + (n1 <= n2 ? n1 : n2));
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {

                //
                // Note that this needs to reference the translation table!
                //

                c1 = NLS_UPCASE(c1);
                c2 = NLS_UPCASE(c2);
                if (c1 != c2) {
                    return (LONG)(c1) - (LONG)(c2);
                }
            }
        }

    } else {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {
                return (LONG)(c1) - (LONG)(c2);
            }
        }
    }

    return n1 - n2;
}


BOOLEAN
RtlEqualUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualUnicodeString function compares two counted unicode strings for
    equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PWCHAR s1, s2, Limit;
    LONG n1, n2;
    WCHAR c1, c2;

    n1 = String1->Length;
    n2 = String2->Length;

    ASSERT((n1 & 1) == 0);
    ASSERT((n2 & 1) == 0);

    if (n1 == n2) {
        s1 = String1->Buffer;
        s2 = String2->Buffer;

        ASSERT(!(((((ULONG_PTR)s1 & 1) != 0) || (((ULONG_PTR)s2 & 1) != 0)) && (n1 != 0) && (n2 != 0)));

        Limit = (PWCHAR)((PCHAR)s1 + n1);
        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if ((c1 != c2) && (NLS_UPCASE(c1) != NLS_UPCASE(c2))) {
                    return FALSE;
                }
            }

            return TRUE;

        } else {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    return FALSE;
                }
            }

            return TRUE;
        }

    } else {
        return FALSE;
    }
}


BOOLEAN
RtlPrefixUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlPrefixUnicodeString function determines if the String1
    counted string parameter is a prefix of the String2 counted string
    parameter.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first unicode string.

    String2 - Pointer to the second unicode string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals a prefix of String2 and
    FALSE otherwise.

--*/

{
    PWSTR s1, s2;
    ULONG n;
    WCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n = String1->Length;
    if (String2->Length < n) {
        return( FALSE );
        }

    n = n / sizeof(c1);
    if (CaseInSensitive) {
        while (n) {
            c1 = *s1++;
            c2 = *s2++;

            if ((c1 != c2) && (NLS_UPCASE(c1) != NLS_UPCASE(c2))) {
                return( FALSE );
                }

            n--;
            }
        }
    else {
        while (n) {
            if (*s1++ != *s2++) {
                return( FALSE );
                }

            n--;
            }
        }

    return TRUE;
}


VOID
RtlCopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlCopyString function copies the SourceString to the
    DestinationString.  If SourceString is not specified, then
    the Length field of DestinationString is set to zero.  The
    MaximumLength and Buffer fields of DestinationString are not
    modified by this function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Optional pointer to the source string.

Return Value:

    None.

--*/

{
    UNALIGNED WCHAR *src, *dst;
    ULONG n;

    if (ARGUMENT_PRESENT(SourceString)) {
        dst = DestinationString->Buffer;
        src = SourceString->Buffer;
        n = SourceString->Length;
        if ((USHORT)n > DestinationString->MaximumLength) {
            n = DestinationString->MaximumLength;
        }

        DestinationString->Length = (USHORT)n;
        RtlCopyMemory(dst, src, n);
        if (DestinationString->Length < DestinationString->MaximumLength) {
            dst[n / sizeof(WCHAR)] = UNICODE_NULL;
        }

    } else {
        DestinationString->Length = 0;
    }

    return;
}


NTSTATUS
RtlAppendUnicodeToString (
    IN PUNICODE_STRING Destination,
    IN PCWSTR Source OPTIONAL
    )

/*++

Routine Description:

    This routine appends the supplied UNICODE string to an existing
    PUNICODE_STRING.

    It will copy bytes from the Source PSZ to the destination PSTRING up to
    the destinations PUNICODE_STRING->MaximumLength field.

Arguments:

    IN PUNICODE_STRING Destination, - Supplies a pointer to the destination
                            string
    IN PWSTR Source - Supplies the string to append to the destination

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n;
    UNALIGNED WCHAR *dst;

    if (ARGUMENT_PRESENT( Source )) {
        UNICODE_STRING UniSource;

        RtlInitUnicodeString(&UniSource, Source);

        n = UniSource.Length;

        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source, n );

        Destination->Length += n;

        if (Destination->Length < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlAppendUnicodeStringToString (
    IN PUNICODE_STRING Destination,
    IN PUNICODE_STRING Source
    )

/*++

Routine Description:

    This routine will concatinate two PSTRINGs together.  It will copy
    bytes from the source up to the MaximumLength of the destination.

Arguments:

    IN PSTRING Destination, - Supplies the destination string
    IN PSTRING Source - Supplies the source for the string copy

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n = Source->Length;
    UNALIGNED WCHAR *dst;

    if (n) {
        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source->Buffer, n );

        Destination->Length += n;

        if (Destination->Length < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}


BOOLEAN
RtlCreateUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString
    )
{
    ULONG cb;

    RTL_PAGED_CODE();

    cb = (wcslen( SourceString ) + 1) * sizeof( WCHAR );
    DestinationString->Buffer = RtlAllocateStringRoutine( cb );
    if (DestinationString->Buffer) {
        RtlMoveMemory( DestinationString->Buffer, SourceString, cb );
        DestinationString->MaximumLength = (USHORT)cb;
        DestinationString->Length = (USHORT)(cb - sizeof( UNICODE_NULL ));
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\sertl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sertl.c

Abstract:

    This Module implements many security rtl routines defined in ntseapi.h

Author:

    Jim Kelly       (JimK)     23-Mar-1990
    Robert Reichel  (RobertRe)  1-Mar-1991

Environment:

    Pure Runtime Library Routine

Revision History:


--*/

#include "ntrtlp.h"

VOID
RtlMapGenericMask(
    IN OUT PACCESS_MASK AccessMask,
    IN PGENERIC_MAPPING GenericMapping
    )

/*++

Routine Description:

    This routine maps all generic accesses in the provided access mask
    to specific and standard accesses according to the provided
    GenericMapping.

Arguments:

        AccessMask - Points to the access mask to be mapped.

        GenericMapping - The mapping of generic to specific and standard
                         access types.

Return Value:

    None.

--*/

{
    RTL_PAGED_CODE();

    if (*AccessMask & GENERIC_READ) {

        *AccessMask |= GenericMapping->GenericRead;
    }

    if (*AccessMask & GENERIC_WRITE) {

        *AccessMask |= GenericMapping->GenericWrite;
    }

    if (*AccessMask & GENERIC_EXECUTE) {

        *AccessMask |= GenericMapping->GenericExecute;
    }

    if (*AccessMask & GENERIC_ALL) {

        *AccessMask |= GenericMapping->GenericAll;
    }

    //
    // Now clear the generic flags
    //

    *AccessMask &= ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\time.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Time.c

Abstract:

    This module implements the absolute time conversion routines for NT.

    Absolute LARGE_INTEGER in NT is represented by a 64-bit large integer accurate
    to 100ns resolution.  The smallest time resolution used by this package
    is One millisecond.  The basis for NT time is the start of 1601 which
    was chosen because it is the start of a new quadricentury.  Some facts
    to note are:

    o At 100ns resolution 32 bits is good for about 429 seconds (or 7 minutes)

    o At 100ns resolution a large integer (i.e., 63 bits) is good for
      about 29,247 years, or around 10,682,247 days.

    o At 1 second resolution 31 bits is good for about 68 years

    o At 1 second resolution 32 bits is good for about 136 years

    o 100ns Time (ignoring time less than a millisecond) can be expressed
      as two values, Days and Milliseconds.  Where Days is the number of
      whole days and Milliseconds is the number of milliseconds for the
      partial day.  Both of these values are ULONG.

    Given these facts most of the conversions are done by first splitting
    LARGE_INTEGER into Days and Milliseconds.

Author:

    Gary Kimura     [GaryKi]    26-Aug-1989

Environment:

    Pure utility routine

Revision History:

--*/

#include "ntrtlp.h"


//
//  The following two tables map a month index to the number of days preceding
//  the month in the year.  Both tables are zero based.  For example, 1 (Feb)
//  has 31 days preceding it.  To help calculate the maximum number of days
//  in a month each table has 13 entries, so the number of days in a month
//  of index i is the table entry of i+1 minus the table entry of i.
//

CONST CSHORT LeapYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+29,                             // March
    31+29+31,                          // April
    31+29+31+30,                       // May
    31+29+31+30+31,                    // June
    31+29+31+30+31+30,                 // July
    31+29+31+30+31+30+31,              // August
    31+29+31+30+31+30+31+31,           // September
    31+29+31+30+31+30+31+31+30,        // October
    31+29+31+30+31+30+31+31+30+31,     // November
    31+29+31+30+31+30+31+31+30+31+30,  // December
    31+29+31+30+31+30+31+31+30+31+30+31};

CONST CSHORT NormalYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+28,                             // March
    31+28+31,                          // April
    31+28+31+30,                       // May
    31+28+31+30+31,                    // June
    31+28+31+30+31+30,                 // July
    31+28+31+30+31+30+31,              // August
    31+28+31+30+31+30+31+31,           // September
    31+28+31+30+31+30+31+31+30,        // October
    31+28+31+30+31+30+31+31+30+31,     // November
    31+28+31+30+31+30+31+31+30+31+30,  // December
    31+28+31+30+31+30+31+31+30+31+30+31};


//
//  The following definitions and declarations are some important constants
//  used in the time conversion routines
//

//
//  This is the week day that January 1st, 1601 fell on (a Monday)
//

#define WEEKDAY_OF_1601                  1

//
//  These are the magic numbers needed to do our extended division.  The
//  only numbers we ever need to divide by are
//
//      10,000 = convert 100ns tics to millisecond tics
//
//      10,000,000 = convert 100ns tics to one second tics
//
//      86,400,000 = convert Millisecond tics to one day tics
//

const LARGE_INTEGER Magic10000    = {0xe219652c, 0xd1b71758};
#define SHIFT10000                       13

const LARGE_INTEGER Magic10000000 = {0xe57a42bd, 0xd6bf94d5};
#define SHIFT10000000                    23

const LARGE_INTEGER Magic86400000 = {0xfa67b90e, 0xc6d750eb};
#define SHIFT86400000                    26

//
//  To make the code more readable we'll also define some macros to
//  do the actual division for use
//

#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

#define ConvertMillisecondsTo100ns(MILLISECONDS) (                 \
    RtlExtendedIntegerMultiply( (MILLISECONDS), 10000 )            \
    )

#define Convert100nsToSeconds(LARGE_INTEGER) (                              \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000000, SHIFT10000000 ) \
    )

#define ConvertSecondsTo100ns(SECONDS) (                           \
    RtlExtendedIntegerMultiply( (SECONDS), 10000000 )              \
    )

#define ConvertMillisecondsToDays(LARGE_INTEGER) (                          \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic86400000, SHIFT86400000 ) \
    )

#define ConvertDaysToMilliseconds(DAYS) (                          \
    Int32x32To64( (DAYS), 86400000 )                               \
    )


//
//  Local support routine
//

ULONG
ElapsedDaysToYears (
    IN ULONG ElapsedDays
    )

/*++

Routine Description:

    This routine computes the number of total years contained in the indicated
    number of elapsed days.  The computation is to first compute the number of
    400 years and subtract that it, then do the 100 years and subtract that out,
    then do the number of 4 years and subtract that out.  Then what we have left
    is the number of days with in a normalized 4 year block.  Normalized being that
    the first three years are not leap years.

Arguments:

    ElapsedDays - Supplies the number of days to use

Return Value:

    ULONG - Returns the number of whole years contained within the input number
        of days.

--*/

{
    ULONG NumberOf400s;
    ULONG NumberOf100s;
    ULONG NumberOf4s;
    ULONG Years;

    //
    //  A 400 year time block is 365*400 + 400/4 - 400/100 + 400/400 = 146097 days
    //  long.  So we simply compute the number of whole 400 year block and the
    //  the number days contained in those whole blocks, and subtract if from the
    //  elapsed day total
    //

    NumberOf400s = ElapsedDays / 146097;
    ElapsedDays -= NumberOf400s * 146097;

    //
    //  A 100 year time block is 365*100 + 100/4 - 100/100 = 36524 days long.
    //  The computation for the number of 100 year blocks is biased by 3/4 days per
    //  100 years to account for the extra leap day thrown in on the last year
    //  of each 400 year block.
    //

    NumberOf100s = (ElapsedDays * 100 + 75) / 3652425;
    ElapsedDays -= NumberOf100s * 36524;

    //
    //  A 4 year time block is 365*4 + 4/4 = 1461 days long.
    //

    NumberOf4s = ElapsedDays / 1461;
    ElapsedDays -= NumberOf4s * 1461;

    //
    //  Now the number of whole years is the number of 400 year blocks times 400,
    //  100 year blocks time 100, 4 year blocks times 4, and the number of elapsed
    //  whole years, taking into account the 3/4 day per year needed to handle the
    //  leap year.
    //

    Years = (NumberOf400s * 400) +
            (NumberOf100s * 100) +
            (NumberOf4s * 4) +
            (ElapsedDays * 100 + 75) / 36525;

    return Years;
}


//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )

//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                                              \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )



//
//  Internal Support routine
//

static
VOID
TimeToDaysAndFraction (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedDays,
    OUT PULONG Milliseconds
    )

/*++

Routine Description:

    This routine converts an input 64-bit time value to the number
    of total elapsed days and the number of milliseconds in the
    partial day.

Arguments:

    Time - Supplies the input time to convert from

    ElapsedDays - Receives the number of elapsed days

    Milliseconds - Receives the number of milliseconds in the partial day

Return Value:

    None

--*/

{
    LARGE_INTEGER TotalMilliseconds;
    LARGE_INTEGER Temp;

    //
    //  Convert the input time to total milliseconds
    //

    TotalMilliseconds = Convert100nsToMilliseconds( *(PLARGE_INTEGER)Time );

    //
    //  Convert milliseconds to total days
    //

    Temp = ConvertMillisecondsToDays( TotalMilliseconds );

    //
    //  Set the elapsed days from temp, we've divided it enough so that
    //  the high part must be zero.
    //

    *ElapsedDays = Temp.LowPart;

    //
    //  Calculate the exact number of milliseconds in the elapsed days
    //  and subtract that from the total milliseconds to figure out
    //  the number of milliseconds left in the partial day
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( *ElapsedDays );

    Temp.QuadPart = TotalMilliseconds.QuadPart - Temp.QuadPart;

    //
    //  Set the fraction part from temp, the total number of milliseconds in
    //  a day guarantees that the high part must be zero.
    //

    *Milliseconds = Temp.LowPart;

    //
    //  And return to our caller
    //

    return;
}


//
//  Internal Support routine
//

//static
VOID
DaysAndFractionToTime (
    IN ULONG ElapsedDays,
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input elapsed day count and partial time
    in milliseconds to a 64-bit time value.

Arguments:

    ElapsedDays - Supplies the number of elapsed days

    Milliseconds - Supplies the number of milliseconds in the partial day

    Time - Receives the output time to value

Return Value:

    None

--*/

{
    LARGE_INTEGER Temp;
    LARGE_INTEGER Temp2;

    //
    //  Calculate the exact number of milliseconds in the elapsed days.
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( ElapsedDays );

    //
    //  Convert milliseconds to a large integer
    //

    Temp2.LowPart = Milliseconds;
    Temp2.HighPart = 0;

    //
    //  add milliseconds to the whole day milliseconds
    //

    Temp.QuadPart = Temp.QuadPart + Temp2.QuadPart;

    //
    //  Finally convert the milliseconds to 100ns resolution
    //

    *(PLARGE_INTEGER)Time = ConvertMillisecondsTo100ns( Temp );

    //
    //  and return to our caller
    //

    return;
}


VOID
RtlTimeToTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine converts an input 64-bit LARGE_INTEGER variable to its corresponding
    time field record.  It will tell the caller the year, month, day, hour,
    minute, second, millisecond, and weekday corresponding to the input time
    variable.

Arguments:

    Time - Supplies the time value to interpret

    TimeFields - Receives a value corresponding to Time

Return Value:

    None

--*/

{
    ULONG Years;
    ULONG Month;
    ULONG Days;

    ULONG Hours;
    ULONG Minutes;
    ULONG Seconds;
    ULONG Milliseconds;

    CONST CSHORT *DaysPrecedingMonthTable;

    //
    //  First divide the input time 64 bit time variable into
    //  the number of whole days and part days (in milliseconds)
    //

    TimeToDaysAndFraction( Time, &Days, &Milliseconds );

    //
    //  Compute which weekday it is and save it away now in the output
    //  variable.  We add the weekday of the base day to bias our computation
    //  which means that if one day has elapsed then we the weekday we want
    //  is the Jan 2nd, 1601.
    //

    TimeFields->Weekday = (CSHORT)((Days + WEEKDAY_OF_1601) % 7);

    //
    //  Calculate the number of whole years contained in the elapsed days
    //  For example if Days = 500 then Years = 1
    //

    Years = ElapsedDaysToYears( Days );

    //
    //  And subtract the number of whole years from our elapsed days
    //  For example if Days = 500, Years = 1, and the new days is equal
    //  to 500 - 365 (normal year).
    //

    Days = Days - ElapsedYearsToDays( Years );

    //
    //  Now test whether the year we are working on (i.e., The year
    //  after the total number of elapsed years) is a leap year
    //  or not.
    //

    if (IsLeapYear( Years + 1 )) {

        DaysPrecedingMonthTable = LeapYearDaysPrecedingMonth;

    } else {

        DaysPrecedingMonthTable = NormalYearDaysPrecedingMonth;
    }

    //
    //  Figure out what month it is, and then subtract the number of days
    //  preceding the month from the days to figure out whay day of the month
    //  it is.
    //

    for (Month = 1; Month <= 12; Month++) {

        if (Days < (USHORT)DaysPrecedingMonthTable[Month]) {

            Days = Days - DaysPrecedingMonthTable[Month - 1] + 1;
            break;
        }
    }

    ASSERT(Month <= 12);
    ASSERT(Days >= 1 && Days <= 31);

    //
    //  Now we need to compute the elapsed hour, minute, second, milliseconds
    //  from the millisecond variable.  This variable currently contains
    //  the number of milliseconds in our input time variable that did not
    //  fit into a whole day.  To compute the hour, minute, second part
    //  we will actually do the arithmetic backwards computing milliseconds
    //  seconds, minutes, and then hours.  We start by computing the
    //  number of whole seconds left in the day, and then computing
    //  the millisecond remainder.
    //

    Seconds = Milliseconds / 1000;
    Milliseconds = Milliseconds % 1000;

    //
    //  Now we compute the number of whole minutes left in the day
    //  and the number of remainder seconds
    //

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    //
    //  Now compute the number of whole hours left in the day
    //  and the number of remainder minutes
    //

    Hours = Minutes / 60;
    Minutes = Minutes % 60;

    //
    //  As our final step we put everything into the time fields
    //  output variable
    //

    TimeFields->Year         = (CSHORT)(Years + 1601);
    TimeFields->Month        = (CSHORT)Month;
    TimeFields->Day          = (CSHORT)Days;
    TimeFields->Hour         = (CSHORT)Hours;
    TimeFields->Minute       = (CSHORT)Minutes;
    TimeFields->Second       = (CSHORT)Seconds;
    TimeFields->Milliseconds = (CSHORT)Milliseconds;

    //
    //  and return to our caller
    //

    return;
}



BOOLEAN
RtlTimeFieldsToTime (
    IN PTIME_FIELDS TimeFields,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input Time Field variable to a 64-bit NT time
    value.  It ignores the WeekDay of the time field.

Arguments:

    TimeFields - Supplies the time field record to use

    Time - Receives the NT Time corresponding to TimeFields

Return Value:

    BOOLEAN - TRUE if the Time Fields is well formed and within the
        range of time expressible by LARGE_INTEGER and FALSE otherwise.

--*/

{
    ULONG Year;
    ULONG Month;
    ULONG Day;
    ULONG Hour;
    ULONG Minute;
    ULONG Second;
    ULONG Milliseconds;

    ULONG ElapsedDays;
    ULONG ElapsedMilliseconds;

    //
    //  Load the time field elements into local variables.  This should
    //  ensure that the compiler will only load the input elements
    //  once, even if there are alias problems.  It will also make
    //  everything (except the year) zero based.  We cannot zero base the
    //  year because then we can't recognize cases where we're given a year
    //  before 1601.
    //

    Year         = TimeFields->Year;
    Month        = TimeFields->Month - 1;
    Day          = TimeFields->Day - 1;
    Hour         = TimeFields->Hour;
    Minute       = TimeFields->Minute;
    Second       = TimeFields->Second;
    Milliseconds = TimeFields->Milliseconds;

    //
    //  Check that the time field input variable contains
    //  proper values.
    //

    if ((TimeFields->Month < 1)                      ||
        (TimeFields->Day < 1)                        ||
        (Year < 1601)                                ||
        (Month > 11)                                 ||
        ((CSHORT)Day >= MaxDaysInMonth(Year, Month)) ||
        (Hour > 23)                                  ||
        (Minute > 59)                                ||
        (Second > 59)                                ||
        (Milliseconds > 999)) {

        return FALSE;

    }

    //
    //  Compute the total number of elapsed days represented by the
    //  input time field variable
    //

    ElapsedDays = ElapsedYearsToDays( Year - 1601 );

    if (IsLeapYear( Year - 1600 )) {

        ElapsedDays += LeapYearDaysPrecedingMonth[ Month ];

    } else {

        ElapsedDays += NormalYearDaysPrecedingMonth[ Month ];

    }

    ElapsedDays += Day;

    //
    //  Now compute the total number of milliseconds in the fractional
    //  part of the day
    //

    ElapsedMilliseconds = (((Hour*60) + Minute)*60 + Second)*1000 + Milliseconds;

    //
    //  Given the elapsed days and milliseconds we can now build
    //  the output time variable
    //

    DaysAndFractionToTime( ElapsedDays, ElapsedMilliseconds, Time );

    //
    //  And return to our caller
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\stdtimep.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stdtimep.h

Abstract:

    This module contains definitions and function prototypes which are local to
    stdime.c and fmttime.c.

Author:

    Rob McKaughan (t-robmc) 17-Jul-1991

Revision History:

--*/

#ifndef _STD_TIME_P_
#define _STD_TIME_P_

//
//  These are the magic numbers needed to do our extended division.  The
//  only numbers we ever need to divide by are
//
//      10,000 = convert 100ns tics to millisecond tics
//
//      10,000,000 = convert 100ns tics to one second tics
//
//      86,400,000 = convert Millisecond tics to one day tics
//

extern LARGE_INTEGER Magic10000;
#define SHIFT10000                       13

extern LARGE_INTEGER Magic10000000;
#define SHIFT10000000                    23

extern LARGE_INTEGER Magic86400000;
#define SHIFT86400000                    26

//
//  To make the code more readable we'll also define some macros to
//  do the actual division for use
//

#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

#define ConvertMillisecondsTo100ns(MILLISECONDS) (                 \
    RtlExtendedIntegerMultiply( (MILLISECONDS), 10000 )            \
    )

#define Convert100nsToSeconds(LARGE_INTEGER) (                              \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000000, SHIFT10000000 ) \
    )

#define ConvertSecondsTo100ns(SECONDS) (                           \
    RtlExtendedIntegerMultiply( (SECONDS), 10000000L )             \
    )

#define ConvertMillisecondsToDays(LARGE_INTEGER) (                          \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic86400000, SHIFT86400000 ) \
    )

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros for Time Differentials and Time Revisions                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// The following define the minimum and maximum possible values for the Time
// Differential Factor as defined by ISO 4031-1978.
//

#define MAX_STDTIME_TDF (780)
#define MIN_STDTIME_TDF (-720)

//
// The revision of this design (will be inserted in the revision field of any
// STANDARD_TIMEs created by this revision).
//

#define STDTIME_REVISION (4)


//
// The number of bits we need to shift to get to and from a revision in a
// StdTime.TdfAndRevision field.
//

#define STDTIME_REVISION_SHIFT 12


//
// USHORT
// ShiftStandardTimeRevision(
//    IN USHORT Rev
//    )
// Description:
//    This routine shifts the given revision number to its proper place for
//    storing in a STANDARD_TIME.TdfAndRevision field.
//

#define ShiftStandardTimeRevision(Rev)                                        \
   ((USHORT) ((Rev) << STDTIME_REVISION_SHIFT))


//
// The pre-shifted value of the current revision
//

#define SHIFTED_STDTIME_REVISION (ShiftStandardTimeRevision(STDTIME_REVISION))


//
// The bit mask used to mask a STANDARD_TIME.TdfAndRevision field to retrieve
// the Tdf value.
//

#define TDF_MASK ((USHORT) 0x0fff)


//
// USHORT
// MaskStandardTimeTdf(
//    IN USHORT Tdf
//    )
// Description:
//    This routine masks the given tdf field with TDF_MASK and returns the
//    result.
//
// BUG: Byte order dependant
//

#define MaskStandardTimeTdf(Tdf) ((USHORT) ((Tdf) & TDF_MASK))


//
// SHORT
// GetStandardTimeTdf(
//    IN STANDARD_TIME
//    )
// Description:
//    This routine gets the Time Differential Factor from a tdf field and
//    makes any adjustments necessary to preserve the sign of the TDF.
//    The resulting TDF is returned.
//
//    Since the TDF is stored as a signed 12 bit int, it's sign bit is the
//    bit 0x0800.  To make it a 16 bit negative, we subtract 0x1000 from the
//    bottome 12 bits of the TdfAndRevision field.
//
// BUG: Byte order dependant
//

#define GetStandardTimeTdf(StdTime)                                           \
   ((SHORT)                                                                   \
     (((StdTime)->TdfAndRevision) & 0x0800)                                   \
        ? (MaskStandardTimeTdf((StdTime)->TdfAndRevision) - 0x1000)           \
        : MaskStandardTimeTdf((StdTime)->TdfAndRevision)                      \
   )


//
// USHORT
// GetStandardTimeRev(
//    IN USHORT Tdf
//    )
// Description:
//    This routine gets the revision number from a tdf field and returns it
//    shifted back down to its place as a SHORT.
//

#define GetStandardTimeRev(StdTime)                                           \
   ((USHORT) (((StdTime)->TdfAndRevision) >> STDTIME_REVISION_SHIFT))



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Tests for absolute and delta times                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// BOOLEAN
// IsPositive(
//    IN LARGE_INTEGER Time
//    )
// Returns:
//    TRUE - if the time in Time is positive.
//    FALSE - if Time is negative.
//

#define IsPositive(Time)                                                      \
   ( ((Time).HighPart > 0) || (((Time).HighPart = 0) & ((Time).LowPart > 0)) )

//
// BOOLEAN
// IsAbsoluteTime(
//    IN PSTANDARDTIME Time
//    )
// Returns:
//    TRUE - if the given time is an absolute time
//    FALSE - If the given time is not an absolute time
//

#define IsAbsoluteTime(Time)                                                  \
   ( IsPositive(Time->SimpleTime) )


//
// BOOLEAN
// IsDeltaTime(
//    IN PSTANDARDTIME Time
//    )
// Returns:
//    TRUE - if the given time is a delta time
//    FALSE - If the given time is not a delta time
//

#define IsDeltaTime(Time)                                                     \
   ( !IsAbsoluteTime(Time) )


//
// BOOLEAN
// GreaterThanTime(
//    IN PLARGE_INTEGER Time1,
//    IN PLARGE_INTEGER Time2
//    )
// Returns:
//    TRUE - If Time1 is greater (older) than Time2
//    FALSE - If not
//
// BUG: Byte order dependant
// BUG: Only works on absolute times
//

#define GreaterThanTime(Time1, Time2)                                         \
   (                                                                          \
     ((Time1).HighPart > (Time2).HighPart)                                    \
     ||                                                                       \
     (                                                                        \
      ((Time1).HighPart == (Time2).HighPart)                                  \
      &&                                                                      \
      ((Time1).LowPart > (Time2).LowPart)                                     \
     )                                                                        \
   )


//
// BOOLEAN
// GreaterThanStandardTime(
//    IN PSTANDARD_TIME Time1,
//    IN PSTANDARD_TIME Time2
//    )
// Returns:
//    TRUE - If Time1 is greater (older) than Time2
//    FALSE - If not
//

#define GreaterThanStdTime(Time1, Time2) \
   GreaterThanTime((Time1).SimpleTime, (Time2).SimpleTime)



//////////////////////////////////////////////////////////////////////////////
//                                                                           /
//  The following definitions and declarations are some important constants  /
//  used in the time conversion routines                                     /
//                                                                           /
//////////////////////////////////////////////////////////////////////////////

//
//  This is the week day that January 1st, 1601 fell on (a Monday)
//

#define WEEKDAY_OF_1601                  1

//
//  These are known constants used to convert 1970 and 1980 times to 1601
//  times.  They are the number of seconds from the 1601 base to the start
//  of 1970 and the start of 1980.  The number of seconds from 1601 to
//  1970 is 369 years worth, or (369 * 365) + 89 leap days = 134774 days, or
//  134774 * 864000 seconds, which is equal to the large integer defined
//  below.  The number of seconds from 1601 to 1980 is 379 years worth, or etc.
//
//  These are declared in time.c
//

extern LARGE_INTEGER SecondsToStartOf1970;
extern LARGE_INTEGER SecondsToStartOf1980;


//
//  ULONG
//  ElapsedDaysToYears (
//      IN ULONG ElapsedDays
//      );
//
//  To be completely true to the Gregorian calendar the equation to
//  go from days to years is really
//
//      ElapsedDays / 365.2425
//
//  But because we are doing the computation in ulong integer arithmetic
//  and the LARGE_INTEGER variable limits the number of expressible days to around
//  11,000,000 we use the following computation
//
//      (ElapsedDays * 128 + 127) / (365.2425 * 128)
//
//  which will be off from the Gregorian calendar in about 150,000 years
//  but that doesn't really matter because LARGE_INTEGER can only express around
//  30,000 years
//

#define ElapsedDaysToYears(DAYS) ( \
    ((DAYS) * 128 + 127) / 46751   \
    )

//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )

//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                                              \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )


//
// Local utlity function prototypes
//

VOID
RtlpConvert48To64(
   IN PSTDTIME_ERROR num48,
   OUT LARGE_INTEGER *num64
   );

NTSTATUS
RtlpConvert64To48(
   IN LARGE_INTEGER num64,
   OUT PSTDTIME_ERROR num48
   );

LARGE_INTEGER
RtlpTimeToLargeInt(
   IN LARGE_INTEGER Time
   );

LARGE_INTEGER
RtlpLargeIntToTime(
   IN LARGE_INTEGER Int
   );

NTSTATUS
RtlpAdd48Int(
   IN PSTDTIME_ERROR First48,
   IN PSTDTIME_ERROR Second48,
   IN PSTDTIME_ERROR Result48
   );

NTSTATUS
RtlpAddTime(
   IN LARGE_INTEGER Time1,
   IN LARGE_INTEGER Time2,
   OUT PLARGE_INTEGER Result
   );

NTSTATUS
RtlpSubtractTime(
   IN LARGE_INTEGER Time1,
   IN LARGE_INTEGER Time2,
   OUT PLARGE_INTEGER Result
   );

LARGE_INTEGER
RtlpAbsTime(
   IN LARGE_INTEGER Time
   );

#endif //_STD_TIME_P_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\stktrace.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stktrace.c

Abstract:

    This module implements routines to snapshot a set of stack back traces
    in a data base.  Useful for heap allocators to track allocation requests
    cheaply.

Author:

    Steve Wood (stevewo) 29-Jan-1992

Revision History:

    17-May-1999 (silviuc) : added RtlWalkFrameChain that replaces the
    unsafe RtlCaptureStackBackTrace.

--*/

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>

USHORT
RtlCaptureStackBackTrace(
    IN ULONG FramesToSkip,
    IN ULONG FramesToCapture,
    OUT PVOID *BackTrace,
    OUT PULONG BackTraceHash
    )
/*++

Routine Description:

    This routine walks up the stack frames, capturing the return address from
    each frame requested. This used to be implemented in assembly language and
    used to be unsafe in special contexts (DPC level). Right now it uses
    RtlWalkFrameChain that validates the chain of pointers and it guarantees
    not to take exceptions.

Arguments:

    FramesToSkip - frames detected but not included in the stack trace

    FramesToCapture - frames to be captured in the stack trace buffer. 
        One of the frames will be for RtlCaptureStackBackTrace.

    BackTrace - stack trace buffer

    BackTraceHash - very simple hash value that can be used to organize
      hash tables. It is just an arithmetic sum of the pointers in the
      stack trace buffer.

Return Value:

     Number of return addresses returned in the stack trace buffer.

--*/
{
    PVOID Trace [2 * MAX_STACK_DEPTH];
    ULONG FramesFound;
    ULONG HashValue;
    ULONG Index;

    //
    // One more frame to skip for the "capture" function (WalkFrameChain).
    //

    FramesToSkip++;

    //
    // Sanity checks.
    //

    if (FramesToCapture + FramesToSkip >= 2 * MAX_STACK_DEPTH) {
        return 0;
    }

    FramesFound = RtlWalkFrameChain (
        Trace,
        FramesToCapture + FramesToSkip,
        0);

    if (FramesFound <= FramesToSkip) {
        return 0;
    }

    for (HashValue = 0, Index = 0; Index < FramesToCapture; Index++) {

        if (FramesToSkip + Index >= FramesFound) {
            break;
        }

        BackTrace[Index] = Trace[FramesToSkip + Index];
        HashValue += PtrToUlong(BackTrace[Index]);
    }

    *BackTraceHash = HashValue;
    return (USHORT)Index;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// RtlWalkFrameChain
/////////////////////////////////////////////////////////////////////

//
// This section contains an algorithm for getting stack traces.
// It works only on x86. It is an improvement of
// RtlCaptureStackBackTrace which for reasons that escape me is written
// in assembly and it is unsafe (can raise exceptions). The new function
// RtlWalkFrameChain is guaranteed to not take exceptions whatever the
// call context.
//
// Note. It might be a good idea to not BBT this code. Especially I am concerned
// about the only assembly instruction used in the whole code that saves
// the value of the EBP register.
//

#ifdef NTOS_KERNEL_RUNTIME
#define _KERNEL_MODE_STACK_TRACES_       1
#define _COLLECT_FRAME_WALK_STATISTICS_  0
#else
#define _KERNEL_MODE_STACK_TRACES_       0
#define _COLLECT_FRAME_WALK_STATISTICS_  0
#endif

#define SIZE_1_KB  ((ULONG_PTR) 0x400)
#define SIZE_1_GB  ((ULONG_PTR) 0x40000000)

#define PAGE_START(address) (((ULONG_PTR)address) & ~((ULONG_PTR)PAGE_SIZE - 1))

VOID CollectFrameWalkStatistics (ULONG Index);

#if (( i386 ) && ( FPO ))
#pragma optimize( "y", off )    // disable FPO for consistent stack traces
#endif

ULONG
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags)

/*++

Routine Description:

    RtlWalkFrameChain

Description:

    This function tries to walk the EBP chain and fill out a vector of
    return addresses. The function works only on x86. It is possible that
    the function cannot fill the requested number of callers because somewhere
    on the stack we have a function compiled FPO (the frame register (EBP) is
    used as a normal register. In this case the function will just return with
    a less then requested count. In kernel mode the function should not take
    any exceptions (page faults) because it can be called at all sorts of
    irql levels.

    The `Flags' parameter is used for future extensions. A zero value will be
    compatible with new stack walking algorithms.

    Note. The algorithm can be somewhat improved by unassembling the return
    addresses identified. However this is impractical in kernel mode because
    the function might get called at high irql levels where page faults are
    not allowed.

Return value:

    The number of identified return addresses on the stack. This can be less
    then the Count requested if the stack ends or we encounter a FPO compiled
    function.

--*/

{
#if defined(_X86_)

    ULONG_PTR Fp, NewFp, ReturnAddress;
    ULONG Index;
    ULONG_PTR StackEnd, StackStart;
    BOOLEAN Result;

    //
    // Get the current EBP pointer which is supposed to
    // be the start of the EBP chain.
    //

    _asm mov Fp, EBP;

    StackStart = Fp;

#if _KERNEL_MODE_STACK_TRACES_

    StackEnd = (ULONG_PTR)(KeGetCurrentThread()->StackBase);

    //
    // bugbug: find a reliable way to get the stack limit in kernel mode.
    // `StackBase' is not a reliable way to get the stack end in kernel
    // mode because we might execute a DPC routine on thread's behalf.
    // There are a few other reasons why we cannot trust this completely.
    //
    // Note. The condition `PAGE_START(StackEnd) - PAGE_START(StackStart) > PAGE_SIZE'
    // is not totally safe. We can encounter a situation where in this case we
    // do not have the same stack. Can we?
    //
    // The DPC stack is actually the stack of the idle thread corresponding to
    // the current processor. Based on that we probably can figure out in almost
    // all contexts what are the real limits of the stack.
    //

    if ((StackStart > StackEnd)
        || (PAGE_START(StackEnd) - PAGE_START(StackStart) > PAGE_SIZE)) {

        StackEnd = (StackStart + PAGE_SIZE) & ~((ULONG_PTR)PAGE_SIZE - 1);
    
        //
        // Try to get one more page if possible. Note that this is not
        // 100% reliable because a non faulting address can fault if
        // appropriate locks are not held.
        //

        if (MmIsAddressValid ((PVOID)StackEnd)) {
            StackEnd += PAGE_SIZE;
        }
    }

#else

    StackEnd = (ULONG_PTR)(NtCurrentTeb()->NtTib.StackBase);

#endif // #if _KERNEL_MODE_STACK_TRACES_

    try {

        for (Index = 0; Index < Count; Index++) {

            if (Fp + sizeof(ULONG_PTR) >= StackEnd) {
                break;
            }

            NewFp = *((PULONG_PTR)(Fp + 0));
            ReturnAddress = *((PULONG_PTR)(Fp + sizeof(ULONG_PTR)));

            //
            // Figure out if the new frame pointer is ok. This validation
            // should avoid all exceptions in kernel mode because we always
            // read within the current thread's stack and the stack is
            // guaranteed to be in memory (no page faults). It is also guaranteed
            // that we do not take random exceptions in user mode because we always
            // keep the frame pointer within stack limits.
            //

            if (! (Fp < NewFp && NewFp < StackEnd)) {
                break;
            }

            //
            // Figure out if the return address is ok. If return address
            // is a stack address or <64k then something is wrong. There is
            // no reason to return garbage to the caller therefore we stop.
            //

            if (StackStart < ReturnAddress && ReturnAddress < StackEnd) {
                break;
            }

            if (ReturnAddress < 64 * SIZE_1_KB) {
                break;
            }

            //
            // Store new fp and return address and move on.
            //

            Fp = NewFp;
            Callers[Index] = (PVOID)ReturnAddress;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // The frame traversal algorithm is written so that we should
        // not get any exception. Therefore if we get some exception
        // we better debug it.
        //

#if DBG
        DbgPrint ("Unexpected exception in RtlWalkFrameChain ...\n");
        DbgBreakPoint ();
#endif
    }

    //
    // Return the number of return addresses identified on the stack.
    //

#if _COLLECT_FRAME_WALK_STATISTICS_
    CollectFrameWalkStatistics (Index);
#endif // #if _COLLECT_FRAME_WALK_STATISTICS_

    return Index;

#else

    return 0;

#endif // #if defined(_X86_)
}


#if _COLLECT_FRAME_WALK_STATISTICS_

KSPIN_LOCK FrameWalkStatisticsLock;
ULONG FrameWalkStatisticsCounters [32];
ULONG FrameWalkCollectStatisticsCalls;
BOOLEAN FrameWalkStatisticsInitialized;

VOID
CollectFrameWalkStatistics (

    ULONG Index)

/*++

Routine description:

    CollectFrameWalkStatistics

Description:

    This function computes the distribution of detectable chain
    lengths. This is used only for debugging the frame traversal
    algorithm. It proves that it is worth trying to get stack
    traces on optimized images because only about 8% of the calls
    cannot be resolved to more than two callers. A sample distribution
    computed by calling RtlWalkFrameChain for every call to
    ExAllocatePoolWithTag gave the results below:

         Length       Percentage
         0-2          5%
         3-5          20%
         6-10         40%
         10-16        35%

    With a failure rate of 5% it is worth using it.

--*/

{
    KIRQL PreviousIrql;
    ULONG I;
    ULONG Percentage;
    ULONG TotalPercentage;

    //
    // Spin lock initialization is not safe in the code below
    // but this code is used only during frame walk algorithm
    // development so there is no reason to make it bulletproof.
    //

    if (! FrameWalkStatisticsInitialized) {
        KeInitializeSpinLock (&FrameWalkStatisticsLock);
        FrameWalkStatisticsInitialized = TRUE;
    }

    KeAcquireSpinLock (
        &FrameWalkStatisticsLock,
        &PreviousIrql);

    FrameWalkCollectStatisticsCalls++;

    if (Index < 32) {
        FrameWalkStatisticsCounters[Index]++;
    }

    if (FrameWalkCollectStatisticsCalls != 0
        && (FrameWalkCollectStatisticsCalls % 60000 == 0)) {

        DbgPrint ("FrameWalk: %u calls \n", FrameWalkCollectStatisticsCalls);

        TotalPercentage = 0;

        for (I = 0; I < 32; I++) {

            Percentage = FrameWalkStatisticsCounters[I] * 100
                / FrameWalkCollectStatisticsCalls;

            DbgPrint ("FrameWalk: [%02u] %02u \n", I, Percentage);

            TotalPercentage += Percentage;
        }

        DbgPrint ("FrameWalk: total %u \n", TotalPercentage);
        DbgBreakPoint ();
    }

    KeReleaseSpinLock (
        &FrameWalkStatisticsLock,
        PreviousIrql);
}

#endif // #if _COLLECT_FRAME_WALK_STATISTICS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\byteswap.asm ===
title  "Byte Swap Functions"
;++
;
; Copyright (c) 1997  Microsoft Corporation
;
; Module Name:
;
;    movemem.asm
;
; Abstract:
;
;    This module implements functions to perform byte swapping operations.
;
;
; Author:
;
;    Forrest Foltz (forrestf) 12-Dec-1997
;
; Environment:
;
;    User or Kernel mode.
;
; Revision History:
;
;--
.486p
	.xlist
include ks386.inc
include callconv.inc            ; calling convention macros
	.list 

;
; Alignment for functions in this module
;

CODE_ALIGNMENT macro
    align   16
endm


_TEXT   SEGMENT PARA PUBLIC 'CODE'
	ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

	PAGE 
	SUBTTL "RtlUshortByteSwap"
;++
;
; USHORT
; RtlUshortByteSwap(
;    IN USHORT Source
;    )
;
; /*++
; 
; Routine Description:
; 
;    The RtlfUshortByteSwap function exchanges bytes 0 and 1 of Source
;    and returns the resulting USHORT.
; 
; Arguments:
; 
;    (cx) Source - 16-bit value to byteswap.
; 
; Return Value:
; 
;    Swapped 16-bit value.
;
;--

CODE_ALIGNMENT
				
cPublicFastCall RtlUshortByteSwap  ,1
cPublicFpo 0, 0

	mov     ah, cl
	mov     al, ch
	fstRET  RtlUshortByteSwap

fstENDP RtlUshortByteSwap


	PAGE 
	SUBTTL "RtlUlongByteSwap"
;++
;
; ULONG
; RtlUlongByteSwap(
;    IN ULONG Source
;    )
;
; /*++
;
; Routine Description:
;
;    The RtlUlongByteSwap function exchanges byte pairs 0:3 and 1:2 of
;    Source and returns the the resulting ULONG.
;
; Arguments:
;
;    (ecx) Source - 32-bit value to byteswap.
;
; Return Value:
;
;    Swapped 32-bit value.
;
;--

CODE_ALIGNMENT

cPublicFastCall RtlUlongByteSwap  ,1
cPublicFpo 0, 0

	mov     eax, ecx
	bswap   eax
	fstRET  RtlUlongByteSwap

fstENDP RtlUlongByteSwap

_TEXT   ends
	    end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\bitmapa.asm ===
title  "Bitmap Functions"
;++
;
; Copyright (c) 1999  Microsoft Corporation
;
; Module Name:
;
;    bitmapa.asm
;
; Abstract:
;
;    This module implements functions to perform bitmap operations.
;
; Author:
;
;    Tracy Sharpe (tracysh) 16-Dec-1999
;
; Environment:
;
;    User or Kernel mode.
;
; Revision History:
;
;--
.486p
	.xlist
include ks386.inc
include callconv.inc            ; calling convention macros
	.list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
	ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

	PAGE
	SUBTTL "RtlFindFirstSetRightMember"
;++
;
; USHORT
; RtlFindFirstSetRightMember(
;    IN ULONG Set
;    )
;
; /*++
;
; Routine Description:
;
;    Searches the Set for the lest signficant set bit.
;
; Arguments:
;
;    (ecx) Set - 32-bit value to operate on.
;
; Return Value:
;
;    Bit position of the first set right member.
;
;--

cPublicFastCall RtlFindFirstSetRightMember  ,1
cPublicFpo 0, 0

    bsf     eax, ecx
	fstRET  RtlFindFirstSetRightMember

fstENDP RtlFindFirstSetRightMember

_TEXT   ends
	    end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\string.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    string.c

Abstract:

    This module defines functions for manipulating counted strings (STRING).
    A counted string is a data structure containing three fields.  The Buffer
    field is a pointer to the string itself.  The MaximumLength field contains
    the maximum number of bytes that can be stored in the memory pointed to
    by the Buffer field.  The Length field contains the current length, in
    bytes, of the string pointed to by the Buffer field.  Users of counted
    strings should not make any assumptions about the existence of a null
    byte at the end of the string, unless the null byte is explicitly
    included in the Length of the string.

Author:

    Steve Wood (stevewo) 31-Mar-1989

Revision History:

    22-Sep-1993    JulieB    Fixed TO_UPPER macro for chars above 0x7f.


--*/

#include "ntrtlp.h"

VOID
RtlCopyString(
    OUT PSTRING DestinationString,
    IN PSTRING SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlCopyString function copies the SourceString to the
    DestinationString.  If SourceString is not specified, then
    the Length field of DestinationString is set to zero.  The
    MaximumLength and Buffer fields of DestinationString are not
    modified by this function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Optional pointer to the source string.

Return Value:

    None.

--*/

{
    PSZ src, dst;
    ULONG n;

    if (ARGUMENT_PRESENT( SourceString )) {
        dst = DestinationString->Buffer;
        src = SourceString->Buffer;
        n = SourceString->Length;
        if ((USHORT)n > DestinationString->MaximumLength) {
            n = DestinationString->MaximumLength;
            }
        DestinationString->Length = (USHORT)n;
        while (n) {
            *dst++ = *src++;
            n--;
            }
        }
    else {
        DestinationString->Length = 0;
        }
}

CHAR
RtlUpperChar (
    register IN CHAR Character
    )

/*++

Routine Description:

    This routine returns a character uppercased
.
Arguments:

    IN CHAR Character - Supplies the character to upper case

Return Value:

    CHAR - Uppercased version of the character
--*/

{
    WCHAR wCh;

    wCh = NLS_UPCASE((WCHAR)((UCHAR)Character));
    return (wCh < 256) ? wCh : '?';
}

CHAR
RtlLowerChar (
    register IN CHAR Character
    )

/*++

Routine Description:

    This routine returns a character lowercased
.
Arguments:

    IN CHAR Character - Supplies the character to lower case

Return Value:

    CHAR - Lowercased version of the character
--*/

{
    WCHAR wCh;

    wCh = NLS_DOWNCASE((WCHAR)((UCHAR)Character));
    return (wCh < 256) ? wCh : '?';
}

LONG
RtlCompareString(
    IN PSTRING String1,
    IN PSTRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareString function compares two counted strings.  The return
    value indicates if the strings are equal or String1 is less than String2
    or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    PUCHAR s1, s2, Limit;
    LONG n1, n2;
    UCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = String1->Length;
    n2 = String2->Length;
    Limit = s1 + (n1 <= n2 ? n1 : n2);
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 !=c2) {
                c1 = RtlUpperChar(c1);
                c2 = RtlUpperChar(c2);
                if (c1 != c2) {
                    return (LONG)c1 - (LONG)c2;
                }
            }
        }

    } else {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {
                return (LONG)c1 - (LONG)c2;
            }
        }
    }

    return n1 - n2;
}

BOOLEAN
RtlEqualString(
    IN PSTRING String1,
    IN PSTRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualString function compares two counted strings for equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PUCHAR s1, s2, Limit;
    LONG n1, n2;
    UCHAR c1, c2;

    n1 = String1->Length;
    n2 = String2->Length;
    if (n1 == n2) {
        s1 = String1->Buffer;
        s2 = String2->Buffer;
        Limit = s1 + n1;
        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    c1 = RtlUpperChar(c1);
                    c2 = RtlUpperChar(c2);
                    if (c1 != c2) {
                        return FALSE;
                    }
                }
            }

            return TRUE;

        } else {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    return FALSE;
                }
            }

            return TRUE;
        }

    } else {
        return FALSE;
    }
}

BOOLEAN
RtlPrefixString(
    IN PSTRING String1,
    IN PSTRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlPrefixString function determines if the String1 counted string
    parameter is a prefix of the String2 counted string parameter.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals a prefix of String2 and
    FALSE otherwise.

--*/

{
    PSZ s1, s2;
    USHORT n;
    UCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n = String1->Length;
    if (String2->Length < n) {
        return( FALSE );
        }

    if (CaseInSensitive) {
        while (n) {
            c1 = *s1++;
            c2 = *s2++;

            if (c1 != c2 && RtlUpperChar(c1) != RtlUpperChar(c2)) {
                return( FALSE );
                }

            n--;
            }
        }
    else {
        while (n) {
            if (*s1++ != *s2++) {
                return( FALSE );
                }

            n--;
            }
        }

    return TRUE;
}

VOID
RtlUpperString(
    IN PSTRING DestinationString,
    IN PSTRING SourceString
    )

/*++

Routine Description:

    The RtlUpperString function copies the SourceString to the
    DestinationString, converting it to upper case.  The MaximumLength
    and Buffer fields of DestinationString are not modified by this
    function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Pointer to the source string.

Return Value:

    None.

--*/

{
    PSZ src, dst;
    ULONG n;

    dst = DestinationString->Buffer;
    src = SourceString->Buffer;
    n = SourceString->Length;
    if ((USHORT)n > DestinationString->MaximumLength) {
        n = DestinationString->MaximumLength;
        }
    DestinationString->Length = (USHORT)n;
    while (n) {
        *dst++ = RtlUpperChar(*src++);
        n--;
        }
}

NTSTATUS
RtlAppendStringToString (
    IN PSTRING Destination,
    IN PSTRING Source
    )

/*++

Routine Description:

    This routine will concatinate two PSTRINGs together.  It will copy
    bytes from the source up to the MaximumLength of the destination.

Arguments:

    IN PSTRING Destination, - Supplies the destination string
    IN PSTRING Source - Supplies the source for the string copy

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n = Source->Length;

    if (n) {
        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        RtlMoveMemory( &Destination->Buffer[ Destination->Length ],
                       Source->Buffer,
                       n
                     );
        Destination->Length += n;
        }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\context.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module implements user-mode callable context manipulation routines.
    The interfaces exported from this module are portable, but they must
    be re-implemented for each architecture.

Author:

    Mark Lucovsky (markl) 20-Jun-1989

Revision History:

    Bryan Willman (bryanwi) 8-Mar-90

	Ported to the 80386

--*/

#include "ntrtlp.h"

#if defined(ALLOC_PRAGMA) && defined(NTOS_KERNEL_RUNTIME)
#pragma alloc_text(PAGE,RtlInitializeContext)
#pragma alloc_text(PAGE,RtlRemoteCall)
#endif


VOID
RtlInitializeContext(
    IN HANDLE Process,
    OUT PCONTEXT Context,
    IN PVOID Parameter OPTIONAL,
    IN PVOID InitialPc OPTIONAL,
    IN PVOID InitialSp OPTIONAL
    )

/*++

Routine Description:

    This function initializes a context structure so that it can
    be used in a subsequent call to NtCreateThread.

Arguments:

    Context - Supplies a context buffer to be initialized by this routine.

    InitialPc - Supplies an initial program counter value.

    InitialSp - Supplies an initial stack pointer value.

Return Value:

    Raises STATUS_BAD_INITIAL_STACK if the value of InitialSp is not properly
           aligned.

    Raises STATUS_BAD_INITIAL_PC if the value of InitialPc is not properly
           aligned.

--*/

{
    RTL_PAGED_CODE();

    Context->Eax = 0L;
    Context->Ebx = 1L;
    Context->Ecx = 2L;
    Context->Edx = 3L;
    Context->Esi = 4L;
    Context->Edi = 5L;
    Context->Ebp = 0L;

    Context->SegGs = 0;
    Context->SegFs = KGDT_R3_TEB;
    Context->SegEs = KGDT_R3_DATA;
    Context->SegDs = KGDT_R3_DATA;
    Context->SegSs = KGDT_R3_DATA;
    Context->SegCs = KGDT_R3_CODE;

    Context->EFlags = 0x200L;	    // force interrupts on, clear all else.

    //
    // Even though these are optional, they are used as is, since NULL
    // is what these would have been initialized to anyway
    //

    Context->Esp = (ULONG) InitialSp;
    Context->Eip = (ULONG) InitialPc;

    //
    // add code to check alignment and raise exception...
    //

    Context->ContextFlags = CONTEXT_CONTROL|CONTEXT_INTEGER|CONTEXT_SEGMENTS;

    //
    // Set the initial context of the thread in a machine specific way.
    // ie, pass the initial parameter to the start address
    //

    Context->Esp -= sizeof(Parameter);
    ZwWriteVirtualMemory(Process,
			 (PVOID)Context->Esp,
			 (PVOID)&Parameter,
			 sizeof(Parameter),
			 NULL);
    Context->Esp -= sizeof(Parameter); // Reserve room for ret address


}



NTSTATUS
RtlRemoteCall(
    HANDLE Process,
    HANDLE Thread,
    PVOID CallSite,
    ULONG ArgumentCount,
    PULONG Arguments,
    BOOLEAN PassContext,
    BOOLEAN AlreadySuspended
    )

/*++

Routine Description:

    This function calls a procedure in another thread/process, using
    NtGetContext and NtSetContext.  Parameters are passed to the
    target procedure via its stack.

Arguments:

    Process - Handle of the target process

    Thread - Handle of the target thread within that process

    CallSite - Address of the procedure to call in the target process.

    ArgumentCount - Number of 32 bit parameters to pass to the target
                    procedure.

    Arguments - Pointer to the array of 32 bit parameters to pass.

    PassContext - TRUE if an additional parameter is to be passed that
        points to a context record.

    AlreadySuspended - TRUE if the target thread is already in a suspended
                       or waiting state.

Return Value:

    Status - Status value

--*/

{
    NTSTATUS Status;
    CONTEXT Context;
    ULONG NewSp;
    ULONG ArgumentsCopy[5];

    RTL_PAGED_CODE();

    if (ArgumentCount > 4)
        return STATUS_INVALID_PARAMETER;

    //
    // If necessary, suspend the guy before with we mess with his stack.
    //
    if (!AlreadySuspended) {
        Status = NtSuspendThread( Thread, NULL );
        if (!NT_SUCCESS( Status )) {
            return( Status );
            }
        }


    //
    // Get the context record for the target thread.
    //

    Context.ContextFlags = CONTEXT_FULL;
    Status = NtGetContextThread( Thread, &Context );
    if (!NT_SUCCESS( Status )) {
        if (!AlreadySuspended) {
            NtResumeThread( Thread, NULL );
            }
        return( Status );
        }


    //
    //	Pass all parameters on the stack, regardless of whether a
    //	a context record is passed.
    //

    //
    //	Put Context Record on stack first, so it is above other args.
    //
    NewSp = Context.Esp;
    if (PassContext) {
	NewSp -= sizeof( CONTEXT );
	Status = NtWriteVirtualMemory( Process,
				       (PVOID)NewSp,
				       &Context,
				       sizeof( CONTEXT ),
				       NULL
				    );
	if (!NT_SUCCESS( Status )) {
            if (!AlreadySuspended) {
                NtResumeThread( Thread, NULL );
                }
	    return( Status );
	    }
        ArgumentsCopy[0] = NewSp;   // pass pointer to context
        RtlMoveMemory(&(ArgumentsCopy[1]),Arguments,ArgumentCount*sizeof( ULONG ));
        ArgumentCount++;
	}
    else {
        RtlMoveMemory(ArgumentsCopy,Arguments,ArgumentCount*sizeof( ULONG ));
        }

    //
    //	Copy the arguments onto the target stack
    //
    if (ArgumentCount) {
        NewSp -= ArgumentCount * sizeof( ULONG );
        Status = NtWriteVirtualMemory( Process,
                                       (PVOID)NewSp,
                                       ArgumentsCopy,
                                       ArgumentCount * sizeof( ULONG ),
                                       NULL
                                     );
        if (!NT_SUCCESS( Status )) {
            if (!AlreadySuspended) {
                NtResumeThread( Thread, NULL );
                }
            return( Status );
            }
        }

    //
    // Set the address of the target code into Eip, the new target stack
    // into Esp, and reload context to make it happen.
    //
    Context.Esp = NewSp;
    Context.Eip = (ULONG)CallSite;
    Status = NtSetContextThread( Thread, &Context );
    if (!AlreadySuspended) {
        NtResumeThread( Thread, NULL );
        }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\debug2.asm ===
title  "Debug Support Functions"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    debug.s
;
; Abstract:
;
;    This module implements functions to support debugging NT.
;
; Author:
;
;    Steven R. Wood (stevewo) 3-Aug-1989
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   11 April 90 (and before)    bryanwi
;       Ported to 386, 386 specific support added.
;
;   2  Aug.  90    (tomp)
;       Added _DbgUnLoadImageSymbols routine.
;
;--
.386p


        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

_TEXT	SEGMENT PUBLIC DWORD 'CODE'
ASSUME  DS:FLAT, ES:FLAT, FS:NOTHING, GS:NOTHING, SS:NOTHING

cPublicProc _DbgBreakPoint        ,0
cPublicFpo 0,0
        int 3
        stdRET    _DbgBreakPoint
stdENDP _DbgBreakPoint

cPublicProc _DbgBreakPointWithStatus,1
cPublicFpo 1,0
        mov eax,[esp+4]
        public _RtlpBreakWithStatusInstruction@0
_RtlpBreakWithStatusInstruction@0:
        int 3
        stdRET  _DbgBreakPointWithStatus
stdENDP _DbgBreakPointWithStatus

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\divlarge.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    largediv.c

Abstract:

    This module implements the NT runtime library large integer divide
    routines.

    N.B. These routines use a one bit at a time algorithm and is slow.
         They should be used only when absolutely necessary.

Author:

    David N. Cutler 10-Aug-1992

Revision History:

--*/

#include "ntrtlp.h"

LARGE_INTEGER
RtlLargeIntegerDivide (
    IN LARGE_INTEGER Dividend,
    IN LARGE_INTEGER Divisor,
    OUT PLARGE_INTEGER Remainder OPTIONAL
    )

/*++

Routine Description:

    This routine divides an unsigned 64-bit dividend by an unsigned 64-bit
    divisor and returns a 64-bit quotient, and optionally a 64-bit remainder.

Arguments:

    Dividend - Supplies the 64-bit dividend for the divide operation.

    Divisor - Supplies the 64-bit divisor for the divide operation.

    Remainder - Supplies an optional pointer to a variable which receives
        the remainder

Return Value:

    The 64-bit quotient is returned as the function value.

--*/

{

    ULONG Index = 64;
    LARGE_INTEGER Partial = {0, 0};
    LARGE_INTEGER Quotient;

#ifndef BLDR_KERNEL_RUNTIME
    //
    // Check for divide by zero
    //

    if (!(Divisor.LowPart | Divisor.HighPart)) {
        RtlRaiseStatus (STATUS_INTEGER_DIVIDE_BY_ZERO);
    }
#endif

    //
    // Loop through the dividend bits and compute the quotient and remainder.
    //

    Quotient = Dividend;
    do {

        //
        // Shift the next dividend bit into the parital remainder and shift
        // the partial quotient (dividend) left one bit.
        //

        Partial.HighPart = (Partial.HighPart << 1) | (Partial.LowPart >> 31);
        Partial.LowPart = (Partial.LowPart << 1) | ((ULONG)Quotient.HighPart >> 31);
        Quotient.HighPart = (Quotient.HighPart << 1) | (Quotient.LowPart >> 31);
        Quotient.LowPart <<= 1;

        //
        // If the partial remainder is greater than or equal to the divisor,
        // then subtract the divisor from the partial remainder and insert a
        // one bit into the quotient.
        //

        if (((ULONG)Partial.HighPart > (ULONG)Divisor.HighPart) ||
            ((Partial.HighPart == Divisor.HighPart) &&
            (Partial.LowPart >= Divisor.LowPart))) {

            Quotient.LowPart |= 1;
            Partial.HighPart -= Divisor.HighPart;
            if (Partial.LowPart < Divisor.LowPart) {
                Partial.HighPart -= 1;
            }

            Partial.LowPart -= Divisor.LowPart;
        }

        Index -= 1;
    } while (Index > 0);

    //
    // If the remainder is requested, then return the 64-bit remainder.
    //

    if (ARGUMENT_PRESENT(Remainder)) {
        *Remainder = Partial;
    }

    //
    // Return the 64-bit quotient.
    //

    return Quotient;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\largeint.asm ===
TITLE   "Large Integer Arithmetic"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    largeint.s
;
; Abstract:
;
;    This module implements routines for performing extended integer
;    arithmtic.
;
; Author:
;
;    David N. Cutler (davec) 24-Aug-1989
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

IFNDEF BLDR_KERNEL_RUNTIME
        EXTRNP  _RtlRaiseStatus, 1
ENDIF


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
        subttl  "Extended Large Integer Divide"

;++
;
; LARGE_INTEGER
; RtlExtendedLargeIntegerDivide (
;     IN LARGE_INTEGER Dividend,
;     IN ULONG Divisor,
;     OUT PULONG Remainder OPTIONAL
;     )
;
; Routine Description:
;
;     This routine divides an unsigned 64 bit dividend by a 32 bit divisor
;     and returns a 64-bit quotient, and optionally the 32-bit remainder.
;
;
; Arguments:
;
;     Dividend - Supplies the 64 bit dividend for the divide operation.
;
;     Divisor - Supplies the 32 bit divisor for the divide operation.
;
;     Remainder - Supplies an optional pointer to a variable which receives
;         the remainder
;
; Return Value:
;
;     The 64-bit quotient is returned as the function value.
;
;--

cPublicProc _RtlExtendedLargeIntegerDivide, 4
cPublicFpo 4,3

        push    esi
        push    edi
        push    ebx

        mov     eax, [esp+16]       ; (eax) = Dividend.LowPart
        mov     edx, [esp+20]       ; (edx) = Dividend.HighPart

lid00:  mov     ebx, [esp+24]       ; (ebx) = Divisor
        or      ebx, ebx
        jz      short lid_zero      ; Attempted a divide by zero

        push    ebp

        mov     ecx, 64             ; Loop count
        xor     esi, esi            ; Clear partial remainder

; (edx:eax) = Dividend
; (ebx) = Divisor
; (ecx) = Loop count
; (esi) = partial remainder

align 4
lid10:  shl     eax, 1              ; (LowPart << 1)  | 0
        rcl     edx, 1              ; (HighPart << 1) | CF
        rcl     esi, 1              ; (Partial << 1)  | CF

        sbb     edi, edi            ; clone CF into edi (0 or -1)

        cmp     esi, ebx            ; check if partial remainder less then divisor
        cmc
        sbb     ebp, ebp            ; clone CF intp ebp
        or      edi, ebp            ; merge with remainder of high bit

        sub     eax, edi            ; merge quotient bit
        and     edi, ebx            ; Select divisor or 0
        sub     esi, edi

        dec     ecx                 ; dec interration count
        jnz     short lid10         ; go around again

        pop     ebp
        pop     ebx
        pop     edi

        mov     ecx, [esp+20]       ; (ecx) = Remainder
        or      ecx, ecx
        jnz     short lid20

        pop     esi
        stdRET  _RtlExtendedLargeIntegerDivide

align 4
lid20:
        mov     [ecx], esi          ; store remainder
        pop     esi
        stdRET  _RtlExtendedLargeIntegerDivide

lid_zero:
IFNDEF BLDR_KERNEL_RUNTIME
        stdCall _RtlRaiseStatus, <STATUS_INTEGER_DIVIDE_BY_ZERO>
ENDIF
        pop     ebx
        pop     edi
        pop     esi
        stdRET  _RtlExtendedLargeIntegerDivide

stdENDP     _RtlExtendedLargeIntegerDivide

        page
        subttl  "Extended Magic Divide"
;++
;
; LARGE_INTEGER
; RtlExtendedMagicDivide (
;    IN LARGE_INTEGER Dividend,
;    IN LARGE_INTEGER MagicDivisor,
;    IN CCHAR ShiftCount
;    )
;
; Routine Description:
;
;    This function divides a signed large integer by an unsigned large integer
;    and returns the signed large integer result. The division is performed
;    using reciprocal multiplication of a signed large integer value by an
;    unsigned large integer fraction which represents the most significant
;    64-bits of the reciprocal divisor rounded up in its least significant bit
;    and normalized with respect to bit 63. A shift count is also provided
;    which is used to truncate the fractional bits from the result value.
;
; Arguments:
;
;   (ebp+8) = Dividend
;   (ebp+16) = MagicDivisor value is a 64-bit multiplicative reciprocal
;   (ebp+24) = ShiftCount - Right shift adjustment value.
;
; Return Value:
;
;    The large integer result is stored  in (edx:eax)
;
;--

RemdDiv     equ [ebp+8]             ; Dividend
RemdRec     equ [ebp+16]            ; Reciprocal (magic divisor)
RemdShift   equ [ebp+24]
RemdTmp1    equ [ebp-4]
RemdTmp2    equ [ebp-8]
RemdTmp3    equ [ebp-12]

cPublicProc _RtlExtendedMagicDivide ,5

        push    ebp
        mov     ebp,esp
        sub     esp,12
        push    esi

        mov     esi, RemdDiv+4
        test    esi,80000000h
        jz      remd10                  ; no sign, no need to negate

        neg     dword ptr RemdDiv+4
        neg     dword ptr RemdDiv
        sbb     dword ptr RemdDiv+4,0   ; negate

remd10: mov     eax,RemdRec
        mul     dword ptr RemdDiv       ; (edx:eax) = Div.lo * Rec.lo
        mov     RemdTmp1,edx

        mov     eax,RemdRec
        mul     dword ptr RemdDiv+4     ; (edx:eax) = Div.hi * Rec.lo
        mov     RemdTmp2,eax
        mov     RemdTmp3,edx

        mov     eax,RemdRec+4
        mul     dword ptr RemdDiv       ; (edx:eax) = Div.lo * Rec.hi

;
;   Col 0 doesn't matter
;   Col 1 = Hi(Div.lo * Rec.lo) + Low(Div.Hi * Rec.lo) + Low(Div.lo * Rec.hi)
;         = RemdTmp1 + RemdTmp2 + eax
;         -> Only want carry from Col 1
;

        xor     ecx,ecx                 ; (ecx) = 0
        add     eax,RemdTmp1
        adc     ecx, 0                  ; save carry in ecx
        add     eax,RemdTmp2
        adc     ecx, 0                  ; Save Carry, all we want from Col2

        mov     RemdTmp1,edx

        mov     eax,RemdRec+4
        mul     dword ptr RemdDiv+4     ; (edx:eax) = Div.Hi * Rec.Hi

;
;   TOS = carry flag from Col 1
;
;   Col 2 = Col1 CF +
;           Hi(Div.Hi * Rec.Lo) + Hi(Div.Lo * Rec.Hi) + Low(Div.Hi * Rec.Hi)
;         = CF + RemdTmp3 + RemdTmp1 + eax
;
;   Col 3 = Col2 CF + Hi(Div.Hi * Rec.Hi)
;         = CF + edx
;

        add     eax,RemdTmp1
        adc     edx, 0                  ; add carry to edx
        add     eax,RemdTmp3            ; (eax) = col 2
        adc     edx, 0                  ; add carry to edx
        add     eax, ecx
        adc     edx, 0                  ; (edx) = col 3

;
;   (edx:eax) = the high 64 bits of the multiply, shift it right by
;               shift count to discard bits to right of virtual decimal pt.
;
;   RemdShift could be as large as 63 and still not 0 the result, 386
;   will only shift 31 bits at a time, so must do the sift multiple
;   times to get correct effect.
;

        mov     cl,RemdShift
remd20: cmp     cl,31
        jbe     remd30
        sub     cl,31
        shrd    eax,edx,31
        shr     edx,31
        jmp     remd20

remd30: shrd    eax,edx,cl
        shr     edx,cl

;
;   Negate the result if need be
;

        test    esi,80000000h
        jz      remd40                  ; no sign, go return without negate

        neg     edx
        neg     eax
        sbb     edx,0

;
;   Store the result
;

remd40:
        ; results in (edx:eax)

        pop     esi
        mov     esp,ebp
        pop     ebp
        stdRET    _RtlExtendedMagicDivide

stdENDP _RtlExtendedMagicDivide


        page
        subttl  "Extended Integer Multiply"
;++
;
; LARGE_INTEGER
; RtlExtendedIntegerMultiply (
;    IN LARGE_INTEGER Multiplicand,
;    IN ULONG Multiplier
;    )
;
; Routine Description:
;
;    This function multiplies a signed large integer by a signed integer and
;    returns the signed large integer result.
;
; Arguments:
;
;   (ebp+8,12)=multiplican (MCAN)
;   (ebp+16)=multiplier (MPER)
;
; Return Value:
;
;    The large integer result is stored in (edx:eax)
;
;--

ReimMCAN    equ <dword ptr [ebp+8]>
ReimMPER    equ <dword ptr [ebp+16]>

cPublicProc _RtlExtendedIntegerMultiply ,3

        push    ebp
        mov     ebp,esp
        push    esi

        mov     esi,ReimMPER
        xor     esi,ReimMCAN+4              ; (esi) = result sign

        test    ReimMCAN+4,80000000h
        jz      short reim10                ; MCAN pos, go look at MPER

        neg     dword ptr ReimMCAN+4
        neg     dword ptr ReimMCAN
        sbb     dword ptr ReimMCAN+4,0      ; negate multiplican

reim10: test    ReimMPER,80000000h
        jz      short reim20                ; MPER pos, go do multiply

        neg     dword ptr ReimMPER          ; negate multiplier

reim20: mov     eax,ReimMPER
        mul     dword ptr ReimMCAN          ; (edx:eax) = MPER * MCAN.low
        push    edx
        mov     ecx, eax
        mov     eax,ReimMPER
        mul     dword ptr ReimMCAN+4        ; (edx:eax) = MPER * MCAN.high
        add     eax,[esp]                   ; (eax) = hi part of MPER*MCAN.low
                                            ;   plus low part of MPER*MCAN.hi

        test    esi,80000000h
        jz      short reim30                ; result sign is OK, go return

        neg     eax
        neg     ecx
        sbb     eax,0                       ; negate result

reim30: add     esp,4                       ; clean eax off stack
        pop     esi                         ; restore nonvolatile reg
        mov     edx,eax                     ; (edx:ecx) = result
        mov     eax,ecx                     ; (edx:eax) = result

        pop     ebp
        stdRET    _RtlExtendedIntegerMultiply

stdENDP _RtlExtendedIntegerMultiply

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\debug3.c ===
//++
//
// Copyright (c) 1990  Microsoft Corporation
//
// Module Name:
//
//    debug3.c
//
// Abstract:
//
//    This module implements architecture specific functions to support debugging NT.
//
// Author:
//
//    Steven R. Wood (stevewo) 3-Aug-1989
//
// Environment:
//
//    Any mode.
//
// Revision History:
//
//--

#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntrtlp.h"

//
// Prototype for local procedure
//

NTSTATUS
DebugService(
    ULONG   ServiceClass,
    PVOID   Arg1,
    PVOID   Arg2
    );

VOID _fptrap() {};

NTSTATUS
DebugPrint(
    IN PSTRING Output
    )
{
    return DebugService( BREAKPOINT_PRINT, Output, 0 );
}


ULONG
DebugPrompt(
    IN PSTRING Output,
    IN PSTRING Input
    )
{
    return DebugService( BREAKPOINT_PROMPT, Output, Input );
}

VOID
DebugLoadImageSymbols(
    IN PSTRING FileName,
    IN PKD_SYMBOLS_INFO SymbolInfo
    )
{
    DebugService( BREAKPOINT_LOAD_SYMBOLS, FileName, SymbolInfo );
}

NTSTATUS
DebugService(
    ULONG   ServiceClass,
    PVOID   Arg1,
    PVOID   Arg2
    )

//++
//
//  Routine Description:
//
//      Allocate an ExceptionRecord, fill in data to allow exception
//      dispatch code to do the right thing with the service, and
//      call RtlRaiseException (NOT ExRaiseException!!!).
//
//  Arguments:
//      ServiceClass - which call is to be performed
//      Arg1 - generic first argument
//      Arg2 - generic second argument
//
//  Returns:
//      Whatever the exception returns in eax
//
//--

{
    NTSTATUS    RetValue;

    _asm {
        mov     eax, ServiceClass
        mov     ecx, Arg1
        mov     edx, Arg2

        int     2dh                 ; Raise exception
        int     3                   ; DO NOT REMOVE (See KiDebugService)

        mov     RetValue, eax

    }

    return RetValue;
}


// DebugUnloadImageSymbols must appear after DebugSerive.  Moved
// it down below DebugService, so BBT would have a label after DebugService.
// A label after the above _asm  is necessary so BBT can treat DebugService
// as  "KnownDataRange".   Otherwise, the two  'int' instructions could get broken up
// by BBT's optimizer.
VOID
DebugUnLoadImageSymbols(
    IN PSTRING FileName,
    IN PKD_SYMBOLS_INFO SymbolInfo
    )
{
    DebugService( BREAKPOINT_UNLOAD_SYMBOLS, FileName, SymbolInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\critsect.asm ===
title   "Critical Section Support"
;++
;
;  Copyright (c) 1991  Microsoft Corporation
;
;  Module Name:
;
;     critsect.asm
;
;  Abstract:
;
;     This module implements functions to support user mode critical sections.
;
;  Author:
;
;     Bryan M. Willman (bryanwi) 2-Oct-91
;
;  Environment:
;
;     Any mode.
;
;  Revision History:
;
;--

.486p
        .xlist
KERNELONLY  equ     1

include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        extrn   _KiPCR:DWORD
        EXTRNP  _KeWaitForSingleObject,5
        EXTRNP  _KeSetEvent,3
        EXTRNP  HalRequestSoftwareInterrupt,1,,FASTCALL

CriticalSection equ     [esp + 4]

        page , 132
        subttl  "RtlEnterCriticalSectionAndRegion"

;++
;
; VOID
; RtlEnterCriticalSectionAndRegion(
;    IN PRTL_CRITICAL_SECTION CriticalSection
;    )
;
; Routine Description:
;
;    This function enters a critical section and disables kernel APC's.
;
; Arguments:
;
;    CriticalSection - supplies a pointer to a critical section.
;
; Return Value:
;
;    None.
;
;--

        align   16
cPublicProc _RtlEnterCriticalSectionAndRegion,1
cPublicFpo 1,0

        mov     ecx, PCR[PcPrcbData+PbCurrentThread]
        mov     edx, CriticalSection    ; get address of critical section

;
; Disable kernel APC's.
;

        dec     dword ptr ThKernelApcDisable[ecx]

;
; Attempt to acquire critical section.
;

        inc     dword ptr CsLockCount[edx] ; increment lock count
        jnz     short Ent20             ; if nz, already owned

;
; Set critical section owner and initialize recursion count.
;

        mov     CsOwningThread[edx], ecx ; set critical section owner
        mov     dword ptr CsRecursionCount[edx], 1 ; set recursion count

        stdRET  _RtlEnterCriticalSectionAndRegion

;
; For out of straight-line paths, we fall into RtlEnterCriticalSection
;

stdENDP _RtlEnterCriticalSectionAndRegion


        page , 132
        subttl  "RtlEnterCriticalSection"

;++
;
; VOID
; RtlEnterCriticalSection(
;    IN PRTL_CRITICAL_SECTION CriticalSection
;    )
;
; Routine Description:
;
;    This function enters a critical section.
;
; Arguments:
;
;    CriticalSection - supplies a pointer to a critical section.
;
; Return Value:
;
;    None.
;
;--

        align   16
cPublicProc _RtlEnterCriticalSection,1
cPublicFpo 1,0

        mov     ecx, PCR[PcPrcbData+PbCurrentThread]
        mov     edx, CriticalSection    ; get address of critical section

;
; Attempt to acquire critical section.
;

        inc     dword ptr CsLockCount[edx] ; increment lock count
        jnz     short Ent20             ; if nz, already owned

;
; Set critical section owner and initialize recursion count.
;

Ent10:
        mov     CsOwningThread[edx], ecx ; set critical section owner
        mov     dword ptr CsRecursionCount[edx], 1 ; set recursion count

        stdRET  _RtlEnterCriticalSection

;
; The critical section is already owned, but may be owned by the current thread.
;

        align   16
Ent20:  cmp     CsOwningThread[edx],ecx ; check if current thread is owner
        jne     short Ent30             ; if ne, current thread not owner
        inc     dword ptr CsRecursionCount[edx] ; increment recursion count

        stdRET  _RtlEnterCriticalSection

;
; The critcal section is owned by another thread and the current thread must
; wait for ownership.
;

Ent30:  stdCall _KeWaitForSingleObject,<edx,WrExecutive,0,0,0>
        mov     ecx, PCR[PcPrcbData+PbCurrentThread]
        mov     edx,CriticalSection     ; get address of critical section
        jmp     Ent10                   ; set owner and recursion count

stdENDP _RtlEnterCriticalSection


        page , 132
        subttl  "RtlLeaveCriticalSectionAndRegion"
;++
;
; VOID
; RtlLeaveCriticalSectionAndAndRegion(
;    IN PRTL_CRITICAL_SECTION CriticalSection
;    )
;
; Routine Description:
;
;    This function leaves a critical section and enables kernel APC's.
;
; Arguments:
;
;    CriticalSection - supplies a pointer to a critical section.
;
; Return Value:
;
;    None.
;
;--

        align   16
cPublicProc _RtlLeaveCriticalSectionAndRegion,1
cPublicFpo 1,0

        mov     edx,CriticalSection
        xor     eax,eax                     ; Assume STATUS_SUCCESS
        dec     dword ptr CsRecursionCount[edx]
        jnz     Lveea20                     ; skip if only leaving recursion

        mov     CsOwningThread[edx],eax     ; clear owning thread id

        dec     dword ptr CsLockCount[edx]  ; interlocked dec of
                                            ; ... CriticalSection->LockCount
        jl      Lveea10
        stdCall _KeSetEvent,<edx,EVENT_INCREMENT,0>

;
; Enable kernel APC's and check if we need to raise an APC interrupt.
;

Lveea10:
        mov     ecx, PCR[PcPrcbData+PbCurrentThread]
        mov     eax, dword ptr [ecx+ThKernelApcDisable]
                                            ; Grab the current APC disable count
        inc     eax
        test    eax, eax                    ; Kernel APC disable count == 0?
        mov     dword ptr [ecx+ThKernelApcDisable], eax
                                            ; Write the count back to the thread
        jnz     Lveea15
        lea     eax, [ecx+ThApcState+AsApcListHead]
        cmp     dword ptr [ecx+ThApcState+AsApcListHead], eax
                                            ; Check if APC list is empty
        je      Lveea15

        mov     byte ptr [ecx+ThApcState+AsKernelApcPending], 1
        mov     cl, APC_LEVEL               ; Service the pending kernel APC
        fstCall HalRequestSoftwareInterrupt

Lveea15:
        stdRET  _RtlLeaveCriticalSectionAndRegion

        align   16
Lveea20:
        dec     dword ptr CsLockCount[edx]  ; interlocked dec of
                                            ; ... CriticalSection->LockCount
        stdRET  _RtlLeaveCriticalSectionAndRegion

_RtlLeaveCriticalSectionAndRegion    endp


        page , 132
        subttl  "RtlLeaveCriticalSection"
;++
;
; VOID
; RtlLeaveCriticalSection(
;    IN PRTL_CRITICAL_SECTION CriticalSection
;    )
;
; Routine Description:
;
;    This function leaves a critical section.
;
; Arguments:
;
;    CriticalSection - supplies a pointer to a critical section.
;
; Return Value:
;
;    None.
;
;--

        align   16
cPublicProc _RtlLeaveCriticalSection,1
cPublicFpo 1,0

        mov     edx,CriticalSection
        xor     eax,eax                     ; Assume STATUS_SUCCESS
        dec     dword ptr CsRecursionCount[edx]
        jnz     leave_recurs                ; skip if only leaving recursion

        mov     CsOwningThread[edx],eax     ; clear owning thread id

        dec     dword ptr CsLockCount[edx]  ; interlocked dec of
                                            ; ... CriticalSection->LockCount
        jge     @F
        stdRET  _RtlLeaveCriticalSection
@@:
        stdCall _KeSetEvent,<edx,EVENT_INCREMENT,0>
        stdRET  _RtlLeaveCriticalSection

        align   16
leave_recurs:
        dec     dword ptr CsLockCount[edx]  ; interlocked dec of
                                            ; ... CriticalSection->LockCount
        stdRET  _RtlLeaveCriticalSection

_RtlLeaveCriticalSection    endp


        page    ,132
        subttl  "RtlTryEnterCriticalSection"
;++
;
; ULONG
; RtlTryEnterCriticalSection(
;    IN PRTL_CRITICAL_SECTION CriticalSection
;    )
;
; Routine Description:
;
;    This function attempts to enter a critical section without blocking.
;
; Arguments:
;
;    CriticalSection (a0) - Supplies a pointer to a critical section.
;
; Return Value:
;
;    If the critical section was successfully entered, then a value of TRUE
;    is returned as the function value. Otherwise, a value of FALSE is returned.
;
;--

CriticalSection equ     [esp + 4]

cPublicProc _RtlTryEnterCriticalSection,1
cPublicFpo 1,0

        mov     ecx, CriticalSection        ; interlocked inc of
        mov     eax, -1                     ; set value to compare against
        mov     edx, 0                      ; set value to set
        cmpxchg dword ptr CsLockCount[ecx], edx  ; Attempt to acquire critsect
        jnz     short tec10                 ; if nz, critsect already owned

        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     CsOwningThread[ecx], eax
        mov     dword ptr CsRecursionCount[ecx], 1

        mov     eax, 1                      ; set successful status

        stdRET  _RtlTryEnterCriticalSection

tec10:
;
; The critical section is already owned. If it is owned by another thread,
; return FALSE immediately. If it is owned by this thread, we must increment
; the lock count here.
;
        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        cmp     CsOwningThread[ecx], eax
        jz      tec20                       ; if eq, this thread is already the owner
        xor     eax, eax                    ; set failure status
        stdRET  _RtlTryEnterCriticalSection

tec20:
;
; This thread is already the owner of the critical section. Perform an atomic
; increment of the LockCount and a normal increment of the RecursionCount and
; return success.
;
        inc     dword ptr CsLockCount[ecx]
        inc     dword ptr CsRecursionCount[ecx]
        mov     eax, 1
        stdRET  _RtlTryEnterCriticalSection

stdENDP _RtlTryEnterCriticalSection

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\exdsptch.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exdsptch.c

Abstract:

    This module implements the dispatching of exception and the unwinding of
    procedure call frames.

Author:

    David N. Cutler (davec) 13-Aug-1989

Environment:

    Any mode.

Revision History:

    10 april 90 bryanwi

            Port to the 386.

--*/

#include "ntrtlp.h"


//
// Dispatcher context structure definition.
//

typedef struct _DISPATCHER_CONTEXT {
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    } DISPATCHER_CONTEXT;

//
// Execute handler for exception function prototype.
//

EXCEPTION_DISPOSITION
RtlpExecuteHandlerForException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PVOID DispatcherContext,
    IN PEXCEPTION_ROUTINE ExceptionRoutine
    );

//
// Execute handler for unwind function prototype.
//

EXCEPTION_DISPOSITION
RtlpExecuteHandlerForUnwind (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT PCONTEXT ContextRecord,
    IN OUT PVOID DispatcherContext,
    IN PEXCEPTION_ROUTINE ExceptionRoutine
    );



BOOLEAN
RtlDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This function attempts to dispatch an exception to a call frame based
    handler by searching backwards through the stack based call frames. The
    search begins with the frame specified in the context record and continues
    backward until either a handler is found that handles the exception, the
    stack is found to be invalid (i.e., out of limits or unaligned), or the end
    of the call hierarchy is reached.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    If the exception is handled by one of the frame based handlers, then
    a value of TRUE is returned. Otherwise a value of FALSE is returned.

--*/

{

    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    PEXCEPTION_REGISTRATION_RECORD NestedRegistration;
    ULONG HighAddress;
    ULONG HighLimit;
    ULONG LowLimit;
    EXCEPTION_RECORD ExceptionRecord1;

#if !defined(WX86_i386)

    ULONG Index;

#endif

    //
    // Get current stack limits.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);

    //
    // Start with the frame specified by the context record and search
    // backwards through the call frame hierarchy attempting to find an
    // exception handler that will handler the exception.
    //

    RegistrationPointer = RtlpGetRegistrationHead();
    NestedRegistration = 0;

    while (RegistrationPointer != EXCEPTION_CHAIN_END) {

        //
        // If the call frame is not within the specified stack limits or the
        // call frame is unaligned, then set the stack invalid flag in the
        // exception record and return FALSE. Else check to determine if the
        // frame has an exception handler.
        //

        HighAddress = (ULONG)RegistrationPointer +
            sizeof(EXCEPTION_REGISTRATION_RECORD);

        if ( ((ULONG)RegistrationPointer < LowLimit) ||
             (HighAddress > HighLimit) ||
             (((ULONG)RegistrationPointer & 0x3) != 0) ) {

#if defined(NTOS_KERNEL_RUNTIME)

            //
            // Allow for the possibility that the problem occured on the
            // DPC stack.
            //

            ULONG TestAddress = (ULONG)RegistrationPointer;

            if (((TestAddress & 0x3) == 0) &&
                KeGetCurrentIrql() >= DISPATCH_LEVEL) {

                PKPRCB Prcb = KeGetCurrentPrcb();
                ULONG DpcStack = (ULONG)Prcb->DpcStack;

                if ((Prcb->DpcRoutineActive) &&
                    (HighAddress <= DpcStack) &&
                    (TestAddress >= DpcStack - KERNEL_STACK_SIZE)) {

                    //
                    // This error occured on the DPC stack, switch
                    // stack limits to the DPC stack and restart 
                    // the loop.
                    // 

                    HighLimit = DpcStack;
                    LowLimit = DpcStack - KERNEL_STACK_SIZE;
                    continue;
                }
            }

#endif

            ExceptionRecord->ExceptionFlags |= EXCEPTION_STACK_INVALID;
            return FALSE;
        }

        Disposition = RtlpExecuteHandlerForException(
            ExceptionRecord,
            (PVOID)RegistrationPointer,
            ContextRecord,
            (PVOID)&DispatcherContext,
            (PEXCEPTION_ROUTINE)RegistrationPointer->Handler);

        //
        // If the current scan is within a nested context and the frame
        // just examined is the end of the context region, then clear
        // the nested context frame and the nested exception in the
        // exception flags.
        //

        if (NestedRegistration == RegistrationPointer) {
            ExceptionRecord->ExceptionFlags &= (~EXCEPTION_NESTED_CALL);
            NestedRegistration = 0;
        }

        //
        // Case on the handler disposition.
        //

        switch (Disposition) {

            //
            // The disposition is to continue execution. If the
            // exception is not continuable, then raise the exception
            // STATUS_NONCONTINUABLE_EXCEPTION. Otherwise return
            // TRUE.
            //

        case ExceptionContinueExecution :
            if ((ExceptionRecord->ExceptionFlags &
               EXCEPTION_NONCONTINUABLE) != 0) {
                ExceptionRecord1.ExceptionCode =
                                        STATUS_NONCONTINUABLE_EXCEPTION;
                ExceptionRecord1.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                ExceptionRecord1.ExceptionRecord = ExceptionRecord;
                ExceptionRecord1.NumberParameters = 0;
                RtlRaiseException(&ExceptionRecord1);
            } else {
                return TRUE;
            }

            //
            // The disposition is to continue the search. Get next
            // frame address and continue the search.
            //

        case ExceptionContinueSearch :
            break;

            //
            // The disposition is nested exception. Set the nested
            // context frame to the establisher frame address and set
            // nested exception in the exception flags.
            //

        case ExceptionNestedException :
            ExceptionRecord->ExceptionFlags |= EXCEPTION_NESTED_CALL;
            if (DispatcherContext.RegistrationPointer > NestedRegistration) {
                NestedRegistration = DispatcherContext.RegistrationPointer;
            }
            break;

            //
            // All other disposition values are invalid. Raise
            // invalid disposition exception.
            //

        default :
            ExceptionRecord1.ExceptionCode = STATUS_INVALID_DISPOSITION;
            ExceptionRecord1.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            ExceptionRecord1.ExceptionRecord = ExceptionRecord;
            ExceptionRecord1.NumberParameters = 0;
            RtlRaiseException(&ExceptionRecord1);
            break;
        }

        //
        // If chain goes in wrong direction or loops, report an
        // invalid exception stack, otherwise go on to the next one.
        //

        RegistrationPointer = RegistrationPointer->Next;
    }
    return FALSE;
}

#ifdef _X86_
#pragma optimize("y", off)      // RtlCaptureContext needs EBP to be correct
#endif

VOID
RtlUnwind (
    IN PVOID TargetFrame OPTIONAL,
    IN PVOID TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN PVOID ReturnValue
    )

/*++

Routine Description:

    This function initiates an unwind of procedure call frames. The machine
    state at the time of the call to unwind is captured in a context record
    and the unwinding flag is set in the exception flags of the exception
    record. If the TargetFrame parameter is not specified, then the exit unwind
    flag is also set in the exception flags of the exception record. A backward
    walk through the procedure call frames is then performed to find the target
    of the unwind operation.

    N.B.    The captured context passed to unwinding handlers will not be
            a  completely accurate context set for the 386.  This is because
            there isn't a standard stack frame in which registers are stored.

            Only the integer registers are affected.  The segement and
            control registers (ebp, esp) will have correct values for
            the flat 32 bit environment.

    N.B.    If you change the number of arguments, make sure you change the
            adjustment of ESP after the call to RtlpCaptureContext (for
            STDCALL calling convention)

Arguments:

    TargetFrame - Supplies an optional pointer to the call frame that is the
        target of the unwind. If this parameter is not specified, then an exit
        unwind is performed.

    TargetIp - Supplies an optional instruction address that specifies the
        continuation address of the unwind. This address is ignored if the
        target frame parameter is not specified.

    ExceptionRecord - Supplies an optional pointer to an exception record.

    ReturnValue - Supplies a value that is to be placed in the integer
        function return register just before continuing execution.

Return Value:

    None.

--*/

{
    PCONTEXT ContextRecord;
    CONTEXT ContextRecord1;
    DISPATCHER_CONTEXT DispatcherContext;
    EXCEPTION_DISPOSITION Disposition;
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;
    PEXCEPTION_REGISTRATION_RECORD PriorPointer;
    ULONG HighAddress;
    ULONG HighLimit;
    ULONG LowLimit;
    EXCEPTION_RECORD ExceptionRecord1;
    EXCEPTION_RECORD ExceptionRecord2;

    //
    // Get current stack limits.
    //

    RtlpGetStackLimits(&LowLimit, &HighLimit);

    //
    // If an exception record is not specified, then build a local exception
    // record for use in calling exception handlers during the unwind operation.
    //

    if (ARGUMENT_PRESENT(ExceptionRecord) == FALSE) {
        ExceptionRecord = &ExceptionRecord1;
        ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
        ExceptionRecord1.ExceptionFlags = 0;
        ExceptionRecord1.ExceptionRecord = NULL;
        ExceptionRecord1.ExceptionAddress = RtlpGetReturnAddress();
        ExceptionRecord1.NumberParameters = 0;
    }

    //
    // If the target frame of the unwind is specified, then set EXCEPTION_UNWINDING
    // flag in the exception flags. Otherwise set both EXCEPTION_EXIT_UNWIND and
    // EXCEPTION_UNWINDING flags in the exception flags.
    //

    if (ARGUMENT_PRESENT(TargetFrame) == TRUE) {
        ExceptionRecord->ExceptionFlags |= EXCEPTION_UNWINDING;
    } else {
        ExceptionRecord->ExceptionFlags |= (EXCEPTION_UNWINDING |
                                                        EXCEPTION_EXIT_UNWIND);
    }

    //
    // Capture the context.
    //

    ContextRecord = &ContextRecord1;
    ContextRecord1.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL | CONTEXT_SEGMENTS;
    RtlpCaptureContext(ContextRecord);

#ifdef STD_CALL
    //
    // Adjust captured context to pop our arguments off the stack
    //
    ContextRecord->Esp += sizeof(TargetFrame) +
                          sizeof(TargetIp)    +
                          sizeof(ExceptionRecord) +
                          sizeof(ReturnValue);
#endif
    ContextRecord->Eax = (ULONG)ReturnValue;

    //
    // Scan backward through the call frame hierarchy, calling exception
    // handlers as they are encountered, until the target frame of the unwind
    // is reached.
    //

    RegistrationPointer = RtlpGetRegistrationHead();
    while (RegistrationPointer != EXCEPTION_CHAIN_END) {

        //
        // If this is the target of the unwind, then continue execution
        // by calling the continue system service.
        //

        if ((ULONG)RegistrationPointer == (ULONG)TargetFrame) {
            ZwContinue(ContextRecord, FALSE);

        //
        // If the target frame is lower in the stack than the current frame,
        // then raise STATUS_INVALID_UNWIND exception.
        //

        } else if ( (ARGUMENT_PRESENT(TargetFrame) == TRUE) &&
                    ((ULONG)TargetFrame < (ULONG)RegistrationPointer) ) {
            ExceptionRecord2.ExceptionCode = STATUS_INVALID_UNWIND_TARGET;
            ExceptionRecord2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            ExceptionRecord2.ExceptionRecord = ExceptionRecord;
            ExceptionRecord2.NumberParameters = 0;
            RtlRaiseException(&ExceptionRecord2);
        }

        //
        // If the call frame is not within the specified stack limits or the
        // call frame is unaligned, then raise the exception STATUS_BAD_STACK.
        // Else restore the state from the specified frame to the context
        // record.
        //

        HighAddress = (ULONG)RegistrationPointer +
            sizeof(EXCEPTION_REGISTRATION_RECORD);

        if ( ((ULONG)RegistrationPointer < LowLimit) ||
             (HighAddress > HighLimit) ||
             (((ULONG)RegistrationPointer & 0x3) != 0) ) {

#if defined(NTOS_KERNEL_RUNTIME)

            //
            // Allow for the possibility that the problem occured on the
            // DPC stack.
            //

            ULONG TestAddress = (ULONG)RegistrationPointer;

            if (((TestAddress & 0x3) == 0) &&
                KeGetCurrentIrql() >= DISPATCH_LEVEL) {

                PKPRCB Prcb = KeGetCurrentPrcb();
                ULONG DpcStack = (ULONG)Prcb->DpcStack;

                if ((Prcb->DpcRoutineActive) &&
                    (HighAddress <= DpcStack) &&
                    (TestAddress >= DpcStack - KERNEL_STACK_SIZE)) {

                    //
                    // This error occured on the DPC stack, switch
                    // stack limits to the DPC stack and restart 
                    // the loop.
                    // 

                    HighLimit = DpcStack;
                    LowLimit = DpcStack - KERNEL_STACK_SIZE;
                    continue;
                }
            }

#endif

            ExceptionRecord2.ExceptionCode = STATUS_BAD_STACK;
            ExceptionRecord2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
            ExceptionRecord2.ExceptionRecord = ExceptionRecord;
            ExceptionRecord2.NumberParameters = 0;
            RtlRaiseException(&ExceptionRecord2);
        } else {

            //
            // The handler must be executed by calling another routine
            // that is written in assembler. This is required because
            // up level addressing of the handler information is required
            // when a collided unwind is encountered.
            //

            Disposition = RtlpExecuteHandlerForUnwind(
                ExceptionRecord,
                (PVOID)RegistrationPointer,
                ContextRecord,
                (PVOID)&DispatcherContext,
                RegistrationPointer->Handler);

            //
            // Case on the handler disposition.
            //

            switch (Disposition) {

                //
                // The disposition is to continue the search. Get next
                // frame address and continue the search.
                //

            case ExceptionContinueSearch :
                break;

                //
                // The disposition is colided unwind. Maximize the target
                // of the unwind and change the context record pointer.
                //

            case ExceptionCollidedUnwind :

                //
                // Pick up the registration pointer that was active at
                // the time of the unwind, and simply continue.
                //

                RegistrationPointer = DispatcherContext.RegistrationPointer;
                break;


                //
                // All other disposition values are invalid. Raise
                // invalid disposition exception.
                //

            default :
                ExceptionRecord2.ExceptionCode = STATUS_INVALID_DISPOSITION;
                ExceptionRecord2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
                ExceptionRecord2.ExceptionRecord = ExceptionRecord;
                ExceptionRecord2.NumberParameters = 0;
                RtlRaiseException(&ExceptionRecord2);
                break;
            }

            //
            // Step to next registration record
            //

            PriorPointer = RegistrationPointer;
            RegistrationPointer = RegistrationPointer->Next;

            //
            // Unlink the unwind handler, since it's been called.
            //

            RtlpUnlinkHandler(PriorPointer);

            //
            // If chain goes in wrong direction or loops, raise an
            // exception.
            //

        }
    }

    if (TargetFrame == EXCEPTION_CHAIN_END) {

        //
        //  Caller simply wants to unwind all exception records.
        //  This differs from an exit_unwind in that no "exit" is desired.
        //  Do a normal continue, since we've effectively found the
        //  "target" the caller wanted.
        //

        ZwContinue(ContextRecord, FALSE);

    } else {

        //
        //  Either (1) a real exit unwind was performed, or (2) the
        //  specified TargetFrame is not present in the exception handler
        //  list.  In either case, give debugger and subsystem a chance
        //  to see the unwind.
        //

        ZwRaiseException(ExceptionRecord, ContextRecord, FALSE);

    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\ntcurteb.asm ===
title  "NtCurTeb.asm"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    NtCurTeb.asm
;
; Abstract:
;
;    Efficient NtCurrentTeb code.
;
; Author:
;
;    Bryan Willman (bryanwi) 28 feb 90
;
; Environment:
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        page ,132
        subttl  "NtCurrentTeb"

IFDEF NTOS_KERNEL_RUNTIME
.PAGE   SEGMENT DWORD PUBLIC 'CODE'
ELSE
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
ENDIF
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; PTEB
; NtCurrentTeb();
;
; Routine Description:
;
;    This routine returns the address of the current TEB.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    Address of TEB.
;
;--
cPublicProc _NtCurrentTeb   ,0
cPublicFpo 0,0

;
;   How this works in both user and kernel mode.
;
;   In user mode, TEB.TIB.Self is flat address of containing structure.
;   In kernel mode, PCR.TIB.Self is flat address of the TEB.
;   Same offset both places, so fs:PcTeb is always the flat address
;   of the TEB.
;

        mov     eax,fs:[PcTeb]
        stdRET    _NtCurrentTeb

stdENDP _NtCurrentTeb
IFDEF NTOS_KERNEL_RUNTIME
.PAGE           ENDS
ELSE
_TEXT           ENDS
ENDIF
                end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\lzntx86.asm ===
title	"Compression and Decompression Engines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    lzntx86.asm
;
; Abstract:
;
;    This module implements the compression and decompression engines needed
;    to support file system compression.  Functions are provided to
;    compress a buffer and decompress a buffer.
;
; Author:
;
;    Mark Zbikowski (markz) 15-Mar-1994
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   15-Mar-1994 markz
;
;           386 version created
;
;--
.386p

        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
	subttl	"Decompress a buffer"
;++
;
; NTSTATUS
; LZNT1DecompressChunk (
;     OUT PUCHAR UncompressedBuffer,
;     IN PUCHAR EndOfUncompressedBufferPlus1,
;     IN PUCHAR CompressedBuffer,
;     IN PUCHAR EndOfCompressedBufferPlus1,
;     OUT PULONG FinalUncompressedChunkSize
;     )
;
; Routine Description:
;
;    This function decodes a stream of compression tokens and places the
;    resultant output into the destination buffer.  The format of the input
;    is described ..\lznt1.c.  As the input is decoded, checks are made to
;    ensure that no data is read past the end of the compressed input buffer
;    and that no data is stored past the end of the output buffer.  Violations
;    indicate corrupt input and are indicated by a status return.
;
;    The following code takes advantage of two distinct observations.
;    First, literal tokens occur at least twice as often as copy tokens.
;    This argues for having a "fall-through" being the case where a literal
;    token is found.  We structure the main decomposition loop in eight
;    pieces where the first piece is a sequence of literal-test fall-throughs
;    and the remainder are a copy token followed by 7,6,...,0 literal-test
;    fall-throughs.  Each test examines a particular bit in the tag byte
;    and jumps to the relevant code piece.
;
;    The second observation involves performing bounds checking only
;    when needed.  Bounds checking the compressed buffer need only be done
;    when fetching the tag byte.  If there is not enough room left in the
;    input for a tag byte and 8 (worst case) copy tokens, a branch is made
;    to a second loop that handles a byte-by-byte "safe" copy to finish
;    up the decompression.  Similarly, at the head of the loop a check is
;    made to ensure that there is enough room in the output buffer for 8
;    literal bytes.  If not enough room is left, then the second loop is
;    used.  Finally, after performing each copy, the output-buffer check
;    is made as well since a copy may take the destination pointer
;    arbitrarily close to the end of the destination.
;
;    The register conventions used in the loops below are:
;
;	    (al)    contains the current tag byte
;	    (ebx)   contains the current width in bits of the length given
;		    the maximum offset
;		    that can be utilized in a copy token.  We update this
;		    value only prior to performing a copy.  This width is used
;		    both to index a mask table (for extracting the length) as
;		    well as shifting (for extracting the copy offset)
;	    (ecx)   is used to contain counts during copies
;	    (edx)   is used as a temp variable during copies
;	    (esi)   is used mainly as the source of the next compressed token.
;		    It is also used for copies.
;	    (edi)   is used as the destination of literals and copies
;	    (ebp)   is used as a frame pointer
;
; Arguments:
;
;    UncompressedBuffer (ebp+8) - pointer to destination of uncompression.
;
;    EndOfUncompressedBufferPlus1  (ebp+12) - pointer just beyond the
;	output buffer.	This is used for consistency checking of the stored
;	compressed data.
;
;    CompressedBuffer (ebp+16) - pointer to compressed source.	This pointer
;       has been adjusted by the caller to point past the header word, so
;       the pointer points to the first tag byte describing which of the
;	following tokens are literals and which are copy groups.
;
;    EndOfCompressedBufferPlus1 (ebp+20) - pointer just beyond end of input
;	buffer.  This is used to terminate the decompression.
;
;    FinalUncompressedChunkSize (ebp+24) - pointer to a returned decompressed
;	size.  This has meaningful data ONLY when LZNT1DecompressChunk returns
;	STATUS_SUCCESS
;
; Return Value:
;
;    STATUS_SUCCESS is returned only if the decompression consumes thee entire
;	input buffer and does not exceed the output buffer.
;    STATUS_BAD_COMPRESSION_BUFFER is returned when the output buffer would be
;	overflowed.
;
;--

;    Decompression macros

;**	TestLiteralAt - tests to see if there's a literal at a specific
;	    bit position.  If so, it branches to the appropriate copy code
;	    (decorated by the bit being used).
;
;       This code does no bounds checking

TestLiteralAt	macro	CopyLabel,bit,IsMain
	test	al,1 SHL bit		; is there a copy token at this position?
	jnz	CopyLabel&bit		; yes, go copy it

	mov	dl,[esi+bit+1]		; (dl) = literal byte from compressed stream
ifidn <IsMain>,<Y>
	mov	[edi+bit],dl		; store literal byte
else
	mov	[edi],dl		; store literal byte
	inc	edi			; point to next literal
endif

endm


;	Jump - allow specific jumps with computed labels.

Jump	macro	lab,tag
        jmp     lab&tag
endm



;**	DoCopy - perform a copy.  If a bit position is specified
;	    then branch to the appropriate point in the "safe" tail when
;	    the copy takes us too close to the end of the output buffer
;
;       This code checks the bounds of the copy token:  copying before the
;       beginning of the buffer and copying beyond the end of the buffer.

DoCopy	macro	AdjustLabel,bit,IsMain

ifidn	<IsMain>,<Y>
if bit ne 0
	add	edi,bit
endif
endif

Test&AdjustLabel&bit:
	cmp	edi,WidthBoundary
	ja	Adjust&AdjustLabel&bit

	xor	ecx,ecx
	mov	cx,word ptr [esi+bit+1] ; (ecx) = encoded length:offset
	lea	edx,[esi+1]		; (edx) = next token location
	mov	Temp,edx

	mov	esi,ecx 		; (esi) = encoded length:offset
	and	ecx,MaskTab[ebx*4]	; (ecx) = length
	xchg	ebx,ecx 		; (ebx) = length/(ecx) = width
	shr	esi,cl			; (esi) = offset
	xchg	ebx,ecx 		; (ebx) = width, (ecx) = length

	neg	esi			; (esi) = negative real offset
	lea	esi,[esi+edi-1] 	; (esi) = pointer to previous string

        cmp     esi,UncompressedBuffer  ; off front of buffer?
        jb      DOA                     ; yes, error

	add	ecx,3			; (ecx) = real length

	lea	edx,[edi+ecx]		; (edx) = end of copy
ifidn	<IsMain>,<Y>
	cmp	edx,EndOfSpecialDest	; do we exceed buffer?
	jae	TailAdd&bit		; yes, handle in safe tail
else
	cmp	edx,EndOfUncompressedBufferPlus1
					; do we exceed buffer?
	ja	DOA			; yes, error
endif

	rep	movsb			; Copy the bytes

	mov	esi,Temp		; (esi) = next token location

ifidn	<IsMain>,<Y>
	sub	edi,bit+1
endif

endm





;**	AdjustWidth - adjust width of length based upon current position of
;	    input buffer (max offset)


AdjustWidth macro   l,i
Adjust&l&i:
	dec	ebx			; (ebx) = new width pointer
	mov	edx,UncompressedBuffer	; (edx) = pointer to dest buffer
	add	edx,WidthTab[ebx*4]	; (edx) = new width boundary
	mov	WidthBoundary,edx	; save boundary for comparison
	jmp	Test&l&i

endm


;**	GenerateBlock - generates the unsafe block of copy/literal pieces.
;
;       This code does no checking for simple input/output checking.  Only
;       the data referred to by the copy tokens is checked.

GenerateBlock	macro	bit
Copy&bit:

	DoCopy	Body,bit,Y

	j = bit + 1
	while j lt 8
	    TestLiteralAt   Copy,%(j),Y
	    j = j + 1
	endm

	add	esi,9
	add	edi,8

	jmp	Top

	AdjustWidth Body,bit
endm



;**	GenerateTailBlock - generates safe tail block for compression.	This
;	    code checks everything before each byte stored so it is expected
;	    to be executed only at the end of the buffer.


GenerateTailBlock   macro   bit
TailAdd&bit:
	add	EndOfCompressedBufferPlus1,1+2*8
                                        ; restore buffer length to true length
	mov     esi,Temp                ; (esi) = source of copy token block
	dec	esi

Tail&bit:
	lea	ecx,[esi+bit+1]         ; (ecx) = source of next token
	cmp	ecx,EndOfCompressedBufferPlus1	; are we done?
	jz	Done                    ; yes - we exactly match end of buffer
;       ja      DOA                     ; INTERNAL ERROR only

	cmp	edi,EndOfUncompressedBufferPlus1
	jz	Done			; go quit, destination is full
;       ja      DOA                     ; INTERNAL ERROR only

	TestLiteralAt	TailCopy,bit,N

        Jump	Tail,%(bit+1)


;       We expect a copy token to be at [esi+bit+1].  This means that
;       esi+bit+1+tokensize must be <= EndOfCompressedBufferPlus1
TailCopy&bit:
        lea     ecx,[esi+bit+3]         ; (ecx) = next input position
        cmp     ecx,EndOfCompressedBufferPlus1  ; do we go too far
        ja      DOA                     ; yes, we are beyond the end of buffer

	DoCopy	Tail,bit,N		; perform copy

        Jump	Tail,%(bit+1)

	AdjustWidth Tail,bit

endm



cPublicProc _LZNT1DecompressChunk ,5
	push	ebp			; (tos) = saved frame pointer
	mov	ebp,esp 		; (ebp) = frame pointer to arguments
	sub	esp,12			; Open up room for locals

Temp			      equ dword ptr [ebp-12]
WidthBoundary		      equ dword ptr [ebp-8]
EndOfSpecialDest	      equ dword ptr [ebp-4]

;SavedEBP		      equ dword ptr [ebp]
;ReturnAddress		      equ dword ptr [ebp+4]

UncompressedBuffer	      equ dword ptr [ebp+8]
EndOfUncompressedBufferPlus1  equ dword ptr [ebp+12]
CompressedBuffer	      equ dword ptr [ebp+16]
EndOfCompressedBufferPlus1    equ dword ptr [ebp+20]
FinalUncompressedChunkSize    equ dword ptr [ebp+24]


	push	ebx
	push	esi
	push	edi

	mov	edi,UncompressedBuffer	; (edi) = destination of decompress
	mov	esi,CompressedBuffer	; (esi) = header
	sub	EndOfCompressedBufferPlus1,1+2*8    ; make room for special source

	mov	eax,EndOfUncompressedBufferPlus1    ; (eax) = end of destination
	sub	eax,8			; (eax) = beginning of special tail
	mov	EndOfSpecialDest,eax	; store special tail

	mov	WidthBoundary,edi	; force initial width mismatch
	mov	ebx,13			; initial width of output


Top:	cmp	esi,EndOfCompressedBufferPlus1	; Will this be the last tag group in source?
	jae	DoTail			; yes, go handle specially
	cmp	edi,EndOfSpecialDest	; are we too close to end of buffer?
	jae	DoTail			; yes, go skip to end

	mov	al,byte ptr [esi]	; (al) = tag byte, (esi) points to token

	irpc	i,<01234567>
	    TestLiteralAt   Copy,%(i),Y
	endm

	add	esi,9
	add	edi,8

	jmp	Top
;		       ; Width of offset    Width of length
WidthTab    dd	0FFFFh ;	16		   0
	    dd	0FFFFh ;	15		   1
	    dd	0FFFFh ;	14		   2
	    dd	0FFFFh ;	13		   3
	    dd	0FFFFh ;	12		   4
	    dd	2048   ;	11		   5
	    dd	1024   ;	10		   6
	    dd	512    ;	9		   7
	    dd	256    ;	8		   8
	    dd	128    ;	7		   9
	    dd	64     ;	6		   10
	    dd	32     ;	5		   11
	    dd	16     ;	4		   12
	    dd	0      ;	3		   13
	    dd	0      ;	2		   14
	    dd	0      ;	1		   15
	    dd	0      ;	0		   16


;				    ;
MaskTab     dd	0000000000000000b   ;	     0
	    dd	0000000000000001b   ;	     1
	    dd	0000000000000011b   ;	     2
	    dd	0000000000000111b   ;	     3
	    dd	0000000000001111b   ;	     4
	    dd	0000000000011111b   ;	     5
	    dd	0000000000111111b   ;	     6
	    dd	0000000001111111b   ;	     7
	    dd	0000000011111111b   ;	     8
	    dd	0000000111111111b   ;	     9
	    dd	0000001111111111b   ;	     10
	    dd	0000011111111111b   ;	     11
	    dd	0000111111111111b   ;	     12
	    dd	0001111111111111b   ;	     13
	    dd	0011111111111111b   ;	     14
	    dd	0111111111111111b   ;	     15
	    dd	1111111111111111b   ;	     16


	irpc	i,<01234567>
	    GenerateBlock   %(i)
	endm

;	We're handling a tail specially for this.  We must check at all
;	spots for running out of input as well as overflowing output.
;
;	(esi) = pointer to possible next tag

DoTail: add	EndOfCompressedBufferPlus1,1+2*8    ; point to end of compressed input

TailLoop:
	cmp	esi,EndOfCompressedBufferPlus1	; are we totally done?
	jz	Done			; yes, go return
	mov	al,byte ptr [esi]	; (al) = tag byte

	jmp	Tail0

	irpc	i,<01234567>
	    GenerateTailBlock	i
	endm

Tail8:	add	esi,9
	jmp	TailLoop



DOA:	mov	eax,STATUS_BAD_COMPRESSION_BUFFER
	jmp	Final

Done:	mov	eax,edi 		; (eax) = pointer to next byte to store
	sub	eax,UncompressedBuffer	; (eax) = length of uncompressed
	mov	edi,FinalUncompressedChunkSize	; (edi) = user return value location
	mov	[edi],eax		; return total transfer size to user
	xor	eax,eax 		; (eax) = STATUS_SUCCESS

Final:	pop	edi
	pop	esi
	pop	ebx
	mov	esp,ebp
	pop	ebp


	stdRET _LZNT1DecompressChunk

stdENDP _LZNT1DecompressChunk

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\movemem.asm ===
title  "User Mode Zero and Move Memory functions"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    movemem.asm
;
; Abstract:
;
;    This module implements functions to zero and copy blocks of memory
;
;
; Author:
;
;    Steven R. Wood (stevewo) 25-May-1990
;
; Environment:
;
;    User mode only.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

if DBG

ifndef BLDR_KERNEL_RUNTIME
_TEXT   SEGMENT PARA PUBLIC 'CODE'
_MsgUnalignedPtr    db  'RTL: RtlCompare/FillMemoryUlong called with unaligned pointer (%x)\n',0
_MsgUnalignedCount  db  'RTL: RtlCompare/FillMemoryUlong called with unaligned count (%x)\n',0
_TEXT   ENDS
endif

ifndef BLDR_KERNEL_RUNTIME
ifdef NTOS_KERNEL_RUNTIME
        extrn   _KdDebuggerEnabled:BYTE
endif
        EXTRNP  _DbgBreakPoint,0
        extrn   _DbgPrint:near
endif
endif

;
; Alignment parameters for zeroing and moving memory.
;

ZERO_MEMORY_ALIGNMENT = 4
ZERO_MEMORY_ALIGNMENT_LOG2 = 2
ZERO_MEMORY_ALIGNMENT_MASK = ZERO_MEMORY_ALIGNMENT - 1

MEMORY_ALIGNMENT = 4
MEMORY_ALIGNMENT_LOG2 = 2
MEMORY_ALIGNMENT_MASK = MEMORY_ALIGNMENT - 1


;
; Alignment for functions in this module
;

CODE_ALIGNMENT macro
    align   16
endm


_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl "RtlCompareMemory"
;++
;
; ULONG
; RtlCompareMemory (
;    IN PVOID Source1,
;    IN PVOID Source2,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function compares two blocks of memory and returns the number
;    of bytes that compared equal.
;
; Arguments:
;
;    Source1 (esp+4) - Supplies a pointer to the first block of memory to
;       compare.
;
;    Source2 (esp+8) - Supplies a pointer to the second block of memory to
;       compare.
;
;    Length (esp+12) - Supplies the Length, in bytes, of the memory to be
;       compared.
;
; Return Value:
;
;    The number of bytes that compared equal is returned as the function
;    value. If all bytes compared equal, then the length of the orginal
;    block of memory is returned.
;
;--

RcmSource1      equ     [esp+12]
RcmSource2      equ     [esp+16]
RcmLength       equ     [esp+20]

CODE_ALIGNMENT
cPublicProc _RtlCompareMemory,3
cPublicFpo 3,0

        push    esi                     ; save registers
        push    edi                     ;
        cld                             ; clear direction
        mov     esi,RcmSource1          ; (esi) -> first block to compare
        mov     edi,RcmSource2          ; (edi) -> second block to compare

;
;   Compare dwords, if any.
;

rcm10:  mov     ecx,RcmLength           ; (ecx) = length in bytes
        shr     ecx,2                   ; (ecx) = length in dwords
        jz      rcm20                   ; no dwords, try bytes
        repe    cmpsd                   ; compare dwords
        jnz     rcm40                   ; mismatch, go find byte

;
;   Compare residual bytes, if any.
;

rcm20:  mov     ecx,RcmLength           ; (ecx) = length in bytes
        and     ecx,3                   ; (ecx) = length mod 4
        jz      rcm30                   ; 0 odd bytes, go do dwords
        repe    cmpsb                   ; compare odd bytes
        jnz     rcm50                   ; mismatch, go report how far we got

;
;   All bytes in the block match.
;

rcm30:  mov     eax,RcmLength           ; set number of matching bytes
        pop     edi                     ; restore registers
        pop     esi                     ;
        stdRET  _RtlCompareMemory

;
;   When we come to rcm40, esi (and edi) points to the dword after the
;   one which caused the mismatch.  Back up 1 dword and find the byte.
;   Since we know the dword didn't match, we can assume one byte won't.
;

rcm40:  sub     esi,4                   ; back up
        sub     edi,4                   ; back up
        mov     ecx,5                   ; ensure that ecx doesn't count out
        repe    cmpsb                   ; find mismatch byte

;
;   When we come to rcm50, esi points to the byte after the one that
;   did not match, which is TWO after the last byte that did match.
;

rcm50:  dec     esi                     ; back up
        sub     esi,RcmSource1          ; compute bytes that matched
        mov     eax,esi                 ;
        pop     edi                     ; restore registers
        pop     esi                     ;
        stdRET  _RtlCompareMemory

stdENDP _RtlCompareMemory


       subttl  "RtlCompareMemory"
EcmlSource       equ     [esp + 4 + 4]
EcmlLength       equ     [esp + 4 + 8]
EcmlPattern      equ     [esp + 4 + 12]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlCompareMemoryUlong  ,3

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     edi,EcmlSource
if DBG
ifndef BLDR_KERNEL_RUNTIME
        test    edi,3
        jz      @F
        push    edi
        push    offset FLAT:_MsgUnalignedPtr
        call    _DbgPrint
        add     esp, 2 * 4
ifdef NTOS_KERNEL_RUNTIME
        cmp     _KdDebuggerEnabled,0
else
        mov     eax,fs:[PcTeb]
        mov    eax,[eax].TebPeb
        cmp     byte ptr [eax].PebBeingDebugged,0
endif
        je      @F
        call    _DbgBreakPoint@0
@@:
endif
endif
        mov     ecx,EcmlLength
        mov     eax,EcmlPattern
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to compare is non-zero, then do it.
;

        repe    scasd
        je      @F
        sub     edi,4
@@:
        sub     edi,EcmlSource
        mov     eax,edi
        pop     edi
        stdRET    _RtlCompareMemoryUlong

stdENDP _RtlCompareMemoryUlong


       subttl  "RtlFillMemory"
;++
;
; VOID
; RtlFillMemory (
;    IN PVOID Destination,
;    IN ULONG Length,
;    IN UCHAR Fill
;    )
;
; Routine Description:
;
;    This function fills memory with a byte value.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
;    Fill - Supplies the byte value to fill memory with.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EfmDestination  equ     [esp + 4 + 4]
EfmLength       equ     [esp + 4 + 8]
EfmFill         equ     byte ptr [esp + 4 + 12]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlFillMemory  ,3
cPublicFpo 3,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     edi,EfmDestination
        mov     ecx,EfmLength
        mov     al,EfmFill
        mov     ah,al
        shl     eax,16
        mov     al,EfmFill
        mov     ah,al
        cld

        mov     edx,ecx
        and     edx,ZERO_MEMORY_ALIGNMENT_MASK
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to zero is non-zero, then do it.
;

        rep     stosd

;
; If number of extra 8-bit bytes to zero is non-zero, then do it.  In either
; case restore non-volatile registers and return.
;

        or      ecx,edx
        jnz     @F
        pop     edi
        stdRET    _RtlFillMemory
@@:
        rep     stosb
        pop     edi
        stdRET    _RtlFillMemory

stdENDP _RtlFillMemory

       subttl  "RtlZeroMemory"
;++
;
; VOID
; RtlFillMemoryUlong (
;    IN PVOID Destination,
;    IN ULONG Length,
;    IN ULONG Fill
;    )
;
; Routine Description:
;
;    This function fills memory with a 32-bit value.  The Destination pointer
;    must be aligned on a 4 byte boundary and the low order two bits of the
;    Length parameter are ignored.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
;    Fill - Supplies the 32-bit value to fill memory with.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EfmlDestination  equ     [esp + 4 + 4]
EfmlLength       equ     [esp + 4 + 8]
EfmlFill         equ     [esp + 4 + 12]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlFillMemoryUlong  ,3
cPublicFpo 3,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = value to store in destination
;   direction flag is clear for auto-increment
;

        mov     edi,EfmlDestination
if DBG
ifndef BLDR_KERNEL_RUNTIME
        test    edi,3
        jz      @F
        push    edi
        push    offset FLAT:_MsgUnalignedPtr
        call    _DbgPrint
        add     esp, 2 * 4
ifdef NTOS_KERNEL_RUNTIME
        cmp     _KdDebuggerEnabled,0
else
        mov     eax,fs:[PcTeb]
        mov    eax,[eax].TebPeb
        cmp     byte ptr [eax].PebBeingDebugged,0
endif
        je      @F
        call    _DbgBreakPoint@0
@@:
endif
endif
        mov     ecx,EfmlLength
        mov     eax,EfmlFill
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to zero is non-zero, then do it.
;

        rep     stosd

        pop     edi
        stdRET    _RtlFillMemoryUlong

stdENDP _RtlFillMemoryUlong

       subttl  "RtlZeroMemory"
;++
;
; VOID
; RtlZeroMemory (
;    IN PVOID Destination,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function zeros memory.
;
; Arguments:
;
;    Destination - Supplies a pointer to the memory to zero.
;
;    Length - Supplies the Length, in bytes, of the memory to be zeroed.
;
; Return Value:
;
;    None.
;
;--

; definitions for arguments
; (TOS) = Return address

EzmDestination  equ     [esp + 4 + 4]
EzmLength       equ     [esp + 4 + 8]

; end of arguments

CODE_ALIGNMENT
cPublicProc _RtlZeroMemory  ,2
cPublicFpo 2,1

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    edi

;
; Setup the registers for using REP STOS instruction to zero memory.
;
;   edi -> memory to zero
;   ecx = number of 32-bit words to zero
;   edx = number of extra 8-bit bytes to zero at the end (0 - 3)
;   eax = zero (value to store in destination)
;   direction flag is clear for auto-increment
;

        mov     edi,EzmDestination
        mov     ecx,EzmLength
        xor     eax,eax
        cld

        mov     edx,ecx
        and     edx,ZERO_MEMORY_ALIGNMENT_MASK
        shr     ecx,ZERO_MEMORY_ALIGNMENT_LOG2


;
; If number of 32-bit words to zero is non-zero, then do it.
;

        rep     stosd

;
; If number of extra 8-bit bytes to zero is non-zero, then do it.  In either
; case restore non-volatile registers and return.
;

        or      ecx,edx
        jnz     @F
        pop     edi
        stdRET    _RtlZeroMemory
@@:
        rep     stosb
        pop     edi
        stdRET    _RtlZeroMemory

stdENDP _RtlZeroMemory

        page , 132
        subttl  "RtlMoveMemory"
;++
;
; VOID
; RtlMoveMemory (
;    IN PVOID Destination,
;    IN PVOID Source OPTIONAL,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function moves memory either forward or backward, aligned or
;    unaligned, in 4-byte blocks, followed by any remaining bytes.
;
; Arguments:
;
;    Destination - Supplies a pointer to the destination of the move.
;
;    Source - Supplies a pointer to the memory to move.
;
;    Length - Supplies the Length, in bytes, of the memory to be moved.
;
; Return Value:
;
;    None.
;
;--

; Definitions of arguments
; (TOS) = Return address

EmmDestination  equ     [esp + 8 + 4]
EmmSource       equ     [esp + 8 + 8]
EmmLength       equ     [esp + 8 + 12]

; End of arguments

CODE_ALIGNMENT
cPublicProc _RtlMoveMemory  ,3
cPublicFpo 3,2

;
; Save the non-volatile registers that we will use, without the benefit of
; a frame pointer.  No exception handling in this routine.
;

        push    esi
        push    edi

;
; Setup the registers for using REP MOVS instruction to move memory.
;
;   esi -> memory to move (NULL implies the destination will be zeroed)
;   edi -> destination of move
;   ecx = number of 32-bit words to move
;   edx = number of extra 8-bit bytes to move at the end (0 - 3)
;   direction flag is clear for auto-increment
;

        mov     esi,EmmSource
        mov     edi,EmmDestination
        mov     ecx,EmmLength
        cld

        cmp     esi,edi                 ; Special case if Source > Destination
        jbe     overlap

nooverlap:
        mov     edx,ecx
        and     edx,MEMORY_ALIGNMENT_MASK
        shr     ecx,MEMORY_ALIGNMENT_LOG2

;
; If number of 32-bit words to move is non-zero, then do it.
;

        rep     movsd

;
; If number of extra 8-bit bytes to move is non-zero, then do it.  In either
; case restore non-volatile registers and return.
;

        or      ecx,edx
        jnz     @F
        pop     edi
        pop     esi
        stdRET    _RtlMoveMemory
@@:
        rep     movsb

movedone:
        pop     edi
        pop     esi
        stdRET    _RtlMoveMemory

;
; Here to handle special case when Source > Destination and therefore is a
; potential overlapping move.  If Source == Destination, then nothing to do.
; Otherwise, increment the Source and Destination pointers by Length and do
; the move backwards, a byte at a time.
;

overlap:
        je      movedone
        mov     eax,edi
        sub     eax,esi
        cmp     ecx,eax
        jbe     nooverlap

        std
        add     esi,ecx
        add     edi,ecx
        dec     esi
        dec     edi
        rep     movsb
        cld
        jmp     short movedone

stdENDP _RtlMoveMemory

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\slist.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 1996  Microsoft Corporation
;
; Module Name:
;
;    slist.asm
;
; Abstract:
;
;    This module implements functions to support interlocked S-List
;    operations.
;
; Author:
;
;    David N. Cutler (davec) 13-Mar-1996
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl  "Interlocked Pop Entry Sequenced List"
;++
;
; PVOID
; FASTCALL
; RtlpInterlockedPopEntrySList (
;    IN PSLIST_HEADER ListHead
;    )
;
; Routine Description:
;
;    This function removes an entry from the front of a sequenced singly
;    linked list so that access to the list is synchronized in an MP system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry that is removed is returned as the
;    function value.
;
; Arguments:
;
;    (ecx) = ListHead - Supplies a pointer to the sequenced listhead from
;         which an entry is to be removed.
;
; Return Value:
;
;    The address of the entry removed from the list, or NULL if the list is
;    empty.
;
;--

cPublicFastCall RtlpInterlockedPopEntrySList, 1

cPublicFpo 0,2

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
        mov     edx,[ebp] + 4           ; get current sequence number
        mov     eax,[ebp] + 0           ; get current next link

;
; If the list is empty, then there is nothing that can be removed.
;

Epop10: or      eax, eax                ; check if list is empty
        jz      short Epop20            ; if z set, list is empty
        mov     ecx, edx                ; copy sequence number and depth
        add     ecx, 0FFFFH             ; adjust sequence number and depth

;
; N.B. It is possible for the following instruction to fault in the rare
;      case where the first entry in the list is allocated on another
;      processor and free between the time the free pointer is read above
;      and the following instruction. When this happens, the access fault
;      code continues execution by skipping the following instruction.
;      This results in the compare failing and the entire operation is
;      retried.
;

        mov     ebx, [eax]              ; get address of successor entry

.586

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

.386

        jnz     short Epop10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

Epop20: pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET    RtlpInterlockedPopEntrySList

fstENDP RtlpInterlockedPopEntrySList

        page , 132
        subttl  "Interlocked Push Entry Sequenced List"
;++
;
; PVOID
; FASTCALL
; RtlpInterlockedPushEntrySList (
;    IN PSLIST_HEADER ListHead,
;    IN PVOID ListEntry
;    )
;
; Routine Description:
;
;    This function inserts an entry at the head of a sequenced singly linked
;    list so that access to the list is synchronized in an MP system.
;
; Arguments:
;
;    (ecx) ListHead - Supplies a pointer to the sequenced listhead into which
;          an entry is to be inserted.
;
;    (edx) ListEntry - Supplies a pointer to the entry to be inserted at the
;          head of the list.
;
; Return Value:
;
;    Previous contents of ListHead.  NULL implies list went from empty
;       to not empty.
;
;--

cPublicFastCall RtlpInterlockedPushEntrySList, 2

cPublicFpo 0,2

;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ebp, ecx                ; save listhead address
        mov     ebx, edx                ; save list entry address
        mov     edx,[ebp] + 4           ; get current sequence number
        mov     eax,[ebp] + 0           ; get current next link
Epsh10: mov     [ebx], eax              ; set next link in new first entry
        mov     ecx, edx                ; copy sequence number
        add     ecx, 010001H            ; increment sequence number and depth

.586

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

.386

        jnz     short Epsh10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;

cPublicFpo 0,0

        pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;

        fstRET  RtlpInterlockedPushEntrySList

fstENDP RtlpInterlockedPushEntrySList

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\rtldump.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rtldump.c

Abstract:

    This module implements dump procedures for:

	ContextRecords,
	ExceptionReportRecords,
	ExceptionRegistrationRecords

Author:

    Bryan Willman (bryanwi)  12 April 90

Environment:

    Callable in any mode in which DbgPrint works.

Revision History:

--*/

#include    "ntrtlp.h"

VOID
RtlpContextDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    )
/*++

Routine Description:

    This function dumps the contents of a context record.

    Currently, it does not dump floating point context.

Arguments:

    Object - Address of the record to dump.

    Control - Ignored, here so we look like a standard dump procedure.

Return Value:

    none

--*/

{
    PCONTEXT	Context;

    Context = (PCONTEXT)Object;

    DbgPrint("      Record @ %lx\n", (ULONG)Context);
    DbgPrint(" ContextFlags: %lx\n", Context->ContextFlags);
    DbgPrint("\n");

    DbgPrint("          Edi: %lx\n", Context->Edi);
    DbgPrint("          Esi: %lx\n", Context->Esi);
    DbgPrint("          Ebx: %lx\n", Context->Ebx);
    DbgPrint("          Edx: %lx\n", Context->Edx);
    DbgPrint("          Ecx: %lx\n", Context->Ecx);
    DbgPrint("          Eax: %lx\n", Context->Eax);
    DbgPrint("\n");

    DbgPrint("          Ebp: %lx\n", Context->Ebp);
    DbgPrint("          Eip: %lx\n", Context->Eip);
    DbgPrint("        SegCs: %lx\n", Context->SegCs);
    DbgPrint("       EFlags: %lx\n", Context->EFlags);
    DbgPrint("          Esp: %lx\n", Context->Esp);
    DbgPrint("        SegSs: %lx\n", Context->SegSs);
    DbgPrint("\n");

    return;
}



VOID
RtlpExceptionReportDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    )
/*++

Routine Description:

    This function dumps the contents of an Exception report record.

Arguments:

    Object - Address of the record to dump.

    Control - Ignored, here so we look like a standard dump procedure.

Return Value:

    none

--*/

{
    ULONG i;

    PEXCEPTION_RECORD	Exception;

    Exception = (PEXCEPTION_RECORD)Object;

    DbgPrint("                Record @ %lx\n", (ULONG)Exception);
    DbgPrint("          ExceptionCode: %lx\n", Exception->ExceptionCode);
    DbgPrint("         ExceptionFlags: %lx\n", Exception->ExceptionFlags);
    DbgPrint("        ExceptionRecord: %lx\n", Exception->ExceptionRecord);
    DbgPrint("       ExceptionAddress: %lx\n", Exception->ExceptionAddress);
    DbgPrint("       NumberParameters: %lx\n", Exception->NumberParameters);
    for (i = 0; i < Exception->NumberParameters; i++)
	DbgPrint("ExceptionInformation[%d]: %lx\n",
		 i, Exception->ExceptionInformation[i]);
    DbgPrint("\n");
    return;
}



VOID
RtlpExceptionRegistrationDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    )
/*++

Routine Description:

    This function dumps the contents of an exception registration record,
    unless Object == NULL, in which case it dumps the entire registration
    chain.

    Currently, it does not dump floating point context.

Arguments:

    Object - Address of the record to dump.

    Control - Ignored, here so we look like a standard dump procedure.

Return Value:

    none

--*/

{
    PEXCEPTION_REGISTRATION_RECORD RegistrationPointer;

    RegistrationPointer = (PEXCEPTION_REGISTRATION_RECORD)Object;

    if (RegistrationPointer != EXCEPTION_CHAIN_END) {
	DbgPrint("Record @ %lx\n", (ULONG)RegistrationPointer);
	DbgPrint("   Next: %lx\n", RegistrationPointer->Next);
	DbgPrint("Handler: %lx\n", RegistrationPointer->Handler);
	DbgPrint("\n");
    } else {
	RegistrationPointer = RtlpGetRegistrationHead();

	while (RegistrationPointer != EXCEPTION_CHAIN_END) {
	    DbgPrint("Record @ %lx\n", (ULONG)RegistrationPointer);
	    DbgPrint("   Next: %lx\n", RegistrationPointer->Next);
	    DbgPrint("Handler: %lx\n", RegistrationPointer->Handler);
	    DbgPrint("\n");
	}
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\raisests.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    raisests.c

Abstract:

    This module implements the routine that raises an exception given a
    specific status value.

Author:

    David N. Cutler (davec) 8-Aug-1990

Environment:

    Any mode.

Revision History:

--*/

#include "ntrtlp.h"

VOID
RtlRaiseStatus (
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This function raises an exception with the specified status value. The
    exception is marked as continuable with no parameters.

Arguments:

    Status - Supplies the status value to be used as the exception code
        for the exception that is to be raised.

Return Value:

    None.

--*/

{

    EXCEPTION_RECORD ExceptionRecord;

    //
    // Construct an exception record.
    //

    ExceptionRecord.ExceptionCode = Status;
    ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
    ExceptionRecord.NumberParameters = 0;
    ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
    RtlRaiseException(&ExceptionRecord);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\ntrtl386.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntrtl386.h

Abstract:

    i386 specific parts of ntrtlp.h

Author:

    Bryan Willman   10 April 90

Environment:

    These routines are statically linked in the caller's executable and
    are callable in either kernel mode or user mode.

Revision History:

--*/

//
// Exception handling procedure prototypes.
//
VOID
RtlpCaptureContext (
    OUT PCONTEXT ContextRecord
    );

VOID
RtlpUnlinkHandler (
    PEXCEPTION_REGISTRATION_RECORD UnlinkPointer
    );

PEXCEPTION_REGISTRATION_RECORD
RtlpGetRegistrationHead (
    VOID
    );

PVOID
RtlpGetReturnAddress (
    VOID
    );


//
//  Record dump procedures.
//

VOID
RtlpContextDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    );

VOID
RtlpExceptionReportDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    );

VOID
RtlpExceptionRegistrationDump(
    IN PVOID Object,
    IN ULONG Control OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\raise.asm ===
title  "Raise Exception"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    raise.asm
;
; Abstract:
;
;    This module implements the function to raise a software exception.
;
; Author:
;
;    Bryan Willman  11 april 90
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        EXTRNP  _ZwRaiseException,3

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
; Context flags definition.
;

CONTEXT_SETTING EQU CONTEXT_INTEGER OR CONTEXT_CONTROL OR CONTEXT_SEGMENTS


;
; Exception record length definition.
;

EXCEPTION_RECORD_LENGTH EQU (ErExceptionInformation + 16) AND 0fffffff0H

        page
        subttl  "Raise Software Exception"
;++
;
; VOID
; RtlRaiseException (
;    IN PEXCEPTION_RECORD ExceptionRecord
;    )
;
; Routine Description:
;
;    This function raises a software exception by building a context record,
;    establishing the stack limits of the current processor mode, and calling
;    the exception dispatcher. If the exception dispatcher finds a handler
;    to process the exception, then control is returned to the caller using
;    the NtContinue system service. Otherwise the NtLastChance system service
;    is called to provide default handing.
;
;   N.B.    On the 386, floating point state is not defined for non-fp
;           exceptions.  Therefore, this routine does not attempt to
;           capture it.
;
;           This means this routine cannot be used to report fp exceptions.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _RtlRaiseException  ,1

        push    ebp
        mov     ebp,esp
        pushfd                          ; save flags before sub
        sub     esp,ContextFrameLength  ; Allocate a context record

;
;   Save regs we use in context record
;

        mov     [(ebp-ContextFrameLength-4)+CsEax],eax
        mov     [(ebp-ContextFrameLength-4)+CsEcx],ecx

;
;   Get pointer to exception report record, and set the exceptionaddress
;   field to be our return address
;

        mov     eax,[ebp+8]             ; (eax) -> ExceptionReportRecord

        mov     ecx,[ebp+4]
        mov     [eax.ErExceptionAddress],ecx

;
;   Copy machine context into the context record
;


        lea     eax,[ebp-ContextFrameLength-4]  ; (eax) -> Context record

        mov     [eax.CsEip],ecx

        mov     [eax.CsEbx],ebx
        mov     [eax.CsEdx],edx

        mov     [eax.CsEsi],esi
        mov     [eax.CsEdi],edi

;
; context record's ESP must have the argument popped off the stack
;

        lea     ecx,[ebp+12]

        mov     [eax.CsEsp],ecx

        mov     ecx,[ebp]
        mov     [eax.CsEbp],ecx

        mov     ecx,[ebp-4]
        mov     [eax.CsEflags],ecx

        mov     dword ptr [eax.CsSegCs],cs
        mov     dword ptr [eax.CsSegSs],ss

;
;   Set Context flags, note that FLOATING_POINT is NOT set.
;

        mov     dword ptr [eax.CsContextFlags],CONTEXT_SETTING

;
;   _ZwRaiseException(ExceptionRecord, ContextRecord, FirstChance=TRUE)
;

; 1 - TRUE
; eax - Context Record
; [ebp+8] - Exception Report Record

        stdCall   _ZwRaiseException,<[ebp+8],eax,1>

;
;   We came back, suggesting some sort of error in the call.  Raise
;   a status exception to report this, return from ZwRaiseException is type.
;

        sub     esp,EXCEPTION_RECORD_LENGTH ; allocate record on stack, esp is base
        mov     [esp.ErExceptionCode],eax   ; set exception type
        mov     dword ptr [esp.ErExceptionFlags],EXCEPTION_NONCONTINUABLE
        mov     dword ptr [esp.ErNumberParameters],0  ; no parms
        mov     eax,[ebp+8]
        mov     [esp.ErExceptionRecord],eax ; point back to first exception
        mov     eax,esp
        stdCall   _RtlRaiseException,<eax>

;
;   We will never come here, because RtlRaiseException will not allow
;   return if exception is non-continuable.
;

stdENDP _RtlRaiseException

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\stringsp.asm ===
TITLE   "String support routines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    stringsup.asm
;
; Abstract:
;
;    This module implements suplimentary routines for performing string
;    operations.
;
; Author:
;
;    Larry Osterman (larryo) 18-Sep-1991
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--

.386p

include callconv.inc            ; calling convention macros


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "RtlInitAnsiString"
;++
;
; VOID
; RtlInitAnsiString(
;     OUT PANSI_STRING DestinationString,
;     IN PSZ SourceString OPTIONAL
;     )
;
;
; Routine Description:
;
;    The RtlInitAnsiString function initializes an NT counted string.
;    The DestinationString is initialized to point to the SourceString
;    and the Length and MaximumLength fields of DestinationString are
;    initialized to the length of the SourceString, which is zero if
;    SourceString is not specified.
;
; Arguments:
;
;    (TOS+4) = DestinationString - Pointer to the counted string to initialize
;
;    (TOS+8) = SourceString - Optional pointer to a null terminated string that
;        the counted string is to point to.
;
;
; Return Value:
;
;    None.
;
; NOTE:
;       This routine assumes that the string is less than 64K in size.
;
;--

cPublicProc _RtlInitAnsiString ,2
cPublicFpo 2,2
        push    edi
        mov     edi,[esp]+8+4           ; (edi)= SourceString
        mov     edx,[esp]+4+4           ; (esi)= DestinationString
        mov     DWORD PTR [edx], 0      ; (Destination).Length = (Destination).MaximumLength = 0
        mov     DWORD PTR [edx]+4, edi  ; (Destination).Buffer = 0
        test    edi, edi
        jz      @f
        or      ecx, -1
        xor     eax, eax
        repne   scasb
        not     ecx
        mov     [edx]+2, cx             ; Save maximum length
        dec     ecx
        mov     [edx], cx               ; Save length
@@:     pop     edi
        stdRET    _RtlInitAnsiString

stdENDP _RtlInitAnsiString


        page
        subttl  "RtlInitAnsiString"
;++
;
; VOID
; RtlInitUnicodeString(
;     OUT PUNICODE_STRING DestinationString,
;     IN PWSZ SourceString OPTIONAL
;     )
;
;
; Routine Description:
;
;    The RtlInitUnicodeString function initializes an NT counted string.
;    The DestinationString is initialized to point to the SourceString
;    and the Length and MaximumLength fields of DestinationString are
;    initialized to the length of the SourceString, which is zero if
;    SourceString is not specified.
;
; Arguments:
;
;    (TOS+4) = DestinationString - Pointer to the counted string to initialize
;
;    (TOS+8) = SourceString - Optional pointer to a null terminated string that
;        the counted string is to point to.
;
;
; Return Value:
;
;    None.
;
; NOTE:
;       This routine assumes that the string is less than 64K in size.
;
;--

cPublicProc _RtlInitUnicodeString ,2
cPublicFpo 2,2
        push    edi
        mov     edi,[esp]+8+4           ; (edi)= SourceString
        mov     edx,[esp]+4+4           ; (esi)= DestinationString
        mov     DWORD PTR [edx], 0      ; (Destination).Length = (Destination).MaximumLength = 0
        mov     DWORD PTR [edx]+4, edi  ; (Destination).Buffer = 0
        test    edi, edi
        jz      @f
        or      ecx, -1
        xor     eax, eax
        repne   scasw
        not     ecx
        shl     ecx,1
        mov     [edx]+2, cx             ; Save maximum length
        dec     ecx
        dec     ecx
        mov     [edx], cx               ; Save length
@@:     pop     edi
        stdRET    _RtlInitUnicodeString

stdENDP _RtlInitUnicodeString

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\xcptmisc.asm ===
title   "Miscellaneous Exception Handling"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    xcptmisc.asm
;
; Abstract:
;
;    This module implements miscellaneous routines that are required to
;    support exception handling. Functions are provided to call an exception
;    handler for an exception, call an exception handler for unwinding, get
;    the caller's stack pointer, get the caller's frame pointer, get the
;    caller's floating status, get the caller's processor state, get the
;    caller's extended processor status, and get the current stack limits.
;
; Author:
;
;    David N. Cutler (davec) 14-Aug-1989
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;   6 April 90  bryanwi
;
;           386 version created
;
;--
.386p

        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

;
; Unwind flags.
;

Unwind  equ EXCEPTION_UNWINDING OR EXCEPTION_EXIT_UNWIND

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
        subttl  "Execute Handler for Exception"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExecuteHandlerForException (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext,
;    IN PEXCEPTION_ROUTINE ExceptionRoutine
;    )
;
; Routine Description:
;
;    This function allocates a call frame, stores the handler address and
;    establisher frame pointer in the frame, establishes an exception
;    handler, and then calls the specified exception handler as an exception
;    handler. If a nested exception occurs, then the exception handler of
;    of this function is called and the handler address and establisher
;    frame pointer are returned to the exception dispatcher via the dispatcher
;    context parameter. If control is returned to this routine, then the
;    frame is deallocated and the disposition status is returned to the
;    exception dispatcher.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (ebp+12) - Supplies the frame pointer of the establisher
;       of the exception handler that is to be called.
;
;    ContextRecord (ebp+16) - Supplies a pointer to a context record.
;
;    DispatcherContext (ebp+20) - Supplies a pointer to the dispatcher context
;       record.
;
;    ExceptionRoutine (ebp+24) - supplies a pointer to the exception handler
;       that is to be called.
;
; Return Value:
;
;    The disposition value returned by the specified exception handler is
;    returned as the function value.
;
;--

cPublicProc _RtlpExecuteHandlerForException,5

        mov     edx,offset FLAT:ExceptionHandler    ; Set who to register
        jmp     ExecuteHandler                      ; jump to common code

stdENDP _RtlpExecuteHandlerForException


        page
        subttl  "Execute Handler for Unwind"
;++
;
; EXCEPTION_DISPOSITION
; RtlpExecuteHandlerForUnwind (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext,
;    IN PEXCEPTION_ROUTINE ExceptionRoutine
;    )
;
; Routine Description:
;
;    This function allocates a call frame, stores the handler address and
;    establisher frame pointer in the frame, establishes an exception
;    handler, and then calls the specified exception handler as an unwind
;    handler. If a collided unwind occurs, then the exception handler of
;    of this function is called and the handler address and establisher
;    frame pointer are returned to the unwind dispatcher via the dispatcher
;    context parameter. If control is returned to this routine, then the
;    frame is deallocated and the disposition status is returned to the
;    unwind dispatcher.
;
; Arguments:
;
;    ExceptionRecord (ebp+8) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (ebp+12) - Supplies the frame pointer of the establisher
;       of the exception handler that is to be called.
;
;    ContextRecord (ebp+16) - Supplies a pointer to a context record.
;
;    DispatcherContext (ebp+20) - Supplies a pointer to the dispatcher context
;       record.
;
;    ExceptionRoutine (ebp+24) - supplies a pointer to the exception handler
;       that is to be called.
;
; Return Value:
;
;    The disposition value returned by the specified exception handler is
;    returned as the function value.
;
;--

cPublicProc _RtlpExecuteHandlerForUnwind    ,5

        mov     edx,offset FLAT:UnwindHandler

;;  N.B. - FALL into ExecuteHandler

stdENDP _RtlpExecuteHandlerForUnwind



;
;   ExecuteHandler is the common tail for RtlpExecuteHandlerForException
;   and RtlpExecuteHandlerForUnwind.
;
;   (edx) = handler (Exception or Unwind) address
;


ExceptionRecord     equ [ebp+8]
EstablisherFrame    equ [ebp+12]
ContextRecord       equ [ebp+16]
DispatcherContext   equ [ebp+20]
ExceptionRoutine    equ [ebp+24]


cPublicProc   ExecuteHandler,5

        push    ebp
        mov     ebp,esp

        push    EstablisherFrame        ; Save context of exception handler
                                        ; that we're about to call.

    .errnz   ErrHandler-4
        push    edx                     ; Set Handler address

    .errnz   ErrNext-0
        push    fs:PcExceptionList                      ; Set next pointer


        mov     fs:PcExceptionList,esp                  ; Link us on

; Call the specified exception handler.

        push    DispatcherContext
        push    ContextRecord
        push    EstablisherFrame
        push    ExceptionRecord

        mov     ecx,ExceptionRoutine
        call    ecx
        mov     esp,fs:PcExceptionList

; Don't clean stack here, code in front of ret will blow it off anyway

; Disposition is in eax, so all we do is deregister handler and return

    .errnz  ErrNext-0
        pop     fs:PcExceptionList

        mov     esp,ebp
        pop     ebp
        stdRET  ExecuteHandler

stdENDP ExecuteHandler

        page
        subttl  "Local Exception Handler"
;++
;
; EXCEPTION_DISPOSITION
; ExceptionHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext
;    )
;
; Routine Description:
;
;    This function is called when a nested exception occurs. Its function
;    is to retrieve the establisher frame pointer and handler address from
;    its establisher's call frame, store this information in the dispatcher
;    context record, and return a disposition value of nested exception.
;
; Arguments:
;
;    ExceptionRecord (exp+4) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (esp+8) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;    ContextRecord (esp+12) - Supplies a pointer to a context record.
;
;    DispatcherContext (esp+16) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;    A disposition value ExceptionNestedException is returned if an unwind
;    is not in progress. Otherwise a value of ExceptionContinueSearch is
;    returned.
;
;--

stdPROC   ExceptionHandler,4

        mov     ecx,dword ptr [esp+4]           ; (ecx) -> ExceptionRecord
        test    dword ptr [ecx.ErExceptionFlags],Unwind
        mov     eax,ExceptionContinueSearch     ; Assume unwind
        jnz     eh10                            ; unwind, go return

;
; Unwind is not in progress - return nested exception disposition.
;

        mov     ecx,[esp+8]             ; (ecx) -> EstablisherFrame
        mov     edx,[esp+16]            ; (edx) -> DispatcherContext
        mov     eax,[ecx+8]             ; (eax) -> EstablisherFrame for the
                                        ;          handler active when we
                                        ;          nested.
        mov     [edx],eax               ; Set DispatcherContext field.
        mov     eax,ExceptionNestedException

eh10:   stdRET    ExceptionHandler

stdENDP ExceptionHandler

        page
        subttl  "Local Unwind Handler"
;++
;
; EXCEPTION_DISPOSITION
; UnwindHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PVOID DispatcherContext
;    )
;
; Routine Description:
;
;    This function is called when a collided unwind occurs. Its function
;    is to retrieve the establisher frame pointer and handler address from
;    its establisher's call frame, store this information in the dispatcher
;    context record, and return a disposition value of nested unwind.
;
; Arguments:
;
;    ExceptionRecord (esp+4) - Supplies a pointer to an exception record.
;
;    EstablisherFrame (esp+8) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;    ContextRecord (esp+12) - Supplies a pointer to a context record.
;
;    DispatcherContext (esp+16) - Supplies a pointer to the dispatcher context
;       record.
;
; Return Value:
;
;    A disposition value ExceptionCollidedUnwind is returned if an unwind is
;    in progress. Otherwise a value of ExceptionContinueSearch is returned.
;
;--

stdPROC   UnwindHandler,4

        mov     ecx,dword ptr [esp+4]           ; (ecx) -> ExceptionRecord
        test    dword ptr [ecx.ErExceptionFlags],Unwind
        mov     eax,ExceptionContinueSearch     ; Assume NOT unwind
        jz      uh10                            ; not unwind, go return


;
; Unwind is in progress - return collided unwind disposition.
;

        mov     ecx,[esp+8]             ; (ecx) -> EstablisherFrame
        mov     edx,[esp+16]            ; (edx) -> DispatcherContext
        mov     eax,[ecx+8]             ; (eax) -> EstablisherFrame for the
                                        ;          handler active when we
                                        ;          nested.
        mov     [edx],eax               ; Set DispatcherContext field.
        mov     eax,ExceptionCollidedUnwind

uh10:   stdRET    UnwindHandler

stdENDP UnwindHandler

        page
        subttl  "Unlink Exception Registration Record & Handler"
;++
;
; VOID
; RtlpUnlinkHandler(PEXCEPTION_REGISTRATION_RECORD UnlinkPointer)
;
; Routine Description:
;
;   This function removes the specified exception registration record
;   (and thus the relevent handler) from the exception traversal
;   chain.
;
; Arguments:
;
;    UnlinkPointer (esp+4) - Address of registration record to unlink.
;
; Return Value:
;
;    The caller's return address.
;
;--

cPublicProc _RtlpUnlinkHandler ,1

        mov     ecx,dword ptr [esp+4]
        mov     ecx,[ecx.ErrNext]
        mov     fs:PcExceptionList,ecx
        stdRET    _RtlpUnlinkHandler

stdENDP _RtlpUnlinkHandler

        page
        subttl  "Capture Context"
;++
;
; VOID
; RtlCaptureContext (PCONTEXT ContextRecord)
; RtlpCaptureContext (PCONTEXT ContextRecord)
;
; Routine Description:
;
;   This fucntion fills in the specified context record with the
;   current state of the machine, except that the values of EBP
;   and ESP are computed to be those of the caller's caller.
;
;   N.B.  This function assumes it is called from a 'C' procedure with
;         the old ebp at [ebp], the return address at [ebp+4], and
;         old esp = ebp + 8.
;
;         Certain 'C' optimizations may cause this to not be true.
;
;   N.B.  This function does NOT adjust ESP to pop the arguments off
;         the caller's stack.  In other words, it provides a __cdecl ESP,
;         NOT a __stdcall ESP.  This is mainly because we can't figure
;         out how many arguments the caller takes.
;
;   N.B.  Floating point state is NOT captured.
;
;   RtlpCaptureContext does not capture volitales.
;   RtlCaptureContext captures volitales.
;
; Arguments:
;
;    ContextRecord  (esp+4) - Address of context record to fill in.
;
; Return Value:
;
;    The caller's return address.
;
;--

cPublicProc _RtlCaptureContext ,1

        push    ebx
        mov     ebx,[esp+8]         ; (ebx) -> ContextRecord

        mov     dword ptr [ebx.CsEax],eax
        mov     dword ptr [ebx.CsEcx],ecx
        mov     dword ptr [ebx.CsEdx],edx
        mov     eax, [esp]
        mov     dword ptr [ebx.CsEbx],eax

        mov     dword ptr [ebx.CsEsi],esi
        mov     dword ptr [ebx.CsEdi],edi
        jmp     RtlpCaptureCommon
stdENDP _RtlCaptureContext

cPublicProc _RtlpCaptureContext ,1

        push    ebx
        mov     ebx,[esp+8]         ; (ebx) -> ContextRecord

        mov     dword ptr [ebx.CsEax],0
        mov     dword ptr [ebx.CsEcx],0
        mov     dword ptr [ebx.CsEdx],0
        mov     dword ptr [ebx.CsEbx],0

        mov     dword ptr [ebx.CsEsi],0
        mov     dword ptr [ebx.CsEdi],0

RtlpCaptureCommon:
        mov     [ebx.CsSegCs],cs
        mov     [ebx.CsSegSs],ss

        pushfd
        pop     [ebx.CsEflags]

        mov     eax,[ebp+4]
        mov     [ebx.CsEip],eax

        mov     eax,[ebp]
        mov     [ebx.CsEbp],eax

        lea     eax,[ebp+8]
        mov     [ebx.CsEsp],eax

        pop     ebx
        stdRET    _RtlpCaptureContext

stdENDP _RtlpCaptureContext

        page
        subttl  "Capture Context (private)"
;++
;
; VOID
; RtlCaptureContext (PCONTEXT ContextRecord)
;
; Routine Description:
;
;   This function is similiar too RtlpCaptureContext expect that
;   volitales are captured as well.
;
;   This fucntion fills in the specified context record with the
;   current state of the machine, except that the values of EBP
;   and ESP are computed to be those of the caller's caller.
;
;   N.B.  This function does NOT adjust ESP to pop the arguments off
;         the caller's stack.  In other words, it provides a __cdecl ESP,
;         NOT a __stdcall ESP.  This is mainly because we can't figure
;         out how many arguments the caller takes.
;
;   N.B.  Floating point state is NOT captured.
;
; Arguments:
;
;    ContextRecord  (esp+4) - Address of context record to fill in.
;
; Return Value:
;
;    The caller's return address.
;
;--


ifndef WX86_i386
        page
        subttl  "Get Stack Limits"
;++
;
; VOID
; RtlpGetStackLimits (
;    OUT PULONG LowLimit,
;    OUT PULONG HighLimit
;    )
;
; Routine Description:
;
;    This function returns the current stack limits based on the current
;    processor mode.
;
;    On the 386 we always store the stack limits in the PCR, and address
;    both PCR and TEB the same way, so this code is mode independent.
;
; Arguments:
;
;    LowLimit (esp+4) - Supplies a pointer to a variable that is to receive
;       the low limit of the stack.
;
;    HighLimit (esp+8) - Supplies a pointer to a variable that is to receive
;       the high limit of the stack.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _RtlpGetStackLimits ,2
;cPublicFpo 2,0

        mov     eax,fs:PcStackLimit
        mov     ecx,[esp+4]
        mov     [ecx],eax               ; Save low limit

        mov     eax,fs:PcStackBase
        mov     ecx,[esp+8]
        mov     [ecx],eax               ; Save high limit

        stdRET    _RtlpGetStackLimits

stdENDP _RtlpGetStackLimits

endif
        page
        subttl  "Get Exception Registration List Head"
;++
;
;   PVOID
;   RtlpGetRegistrationHead()
;
;   Routine Description:
;
;       This function returns the address of the first Exception
;       registration record for the current context.
;
;   Arguments:
;
;       None.
;
;   Return Value:
;
;       The address of the first registration record.
;
;--

cPublicProc _RtlpGetRegistrationHead    ,0
;cPublicFpo 0,0

        mov     eax,fs:PcExceptionList
        stdRET    _RtlpGetRegistrationHead

stdENDP _RtlpGetRegistrationHead

        page
        subttl  "Get Return Address"
;++
;
;   PVOID
;   RtlpGetReturnAddress()
;
;   Routine Description:
;
;       This function returns the caller's return address.  It assumes
;       that a standard 'C' entry sequence has been used, be warned
;       that certain optimizations might invalidate that assumption.
;
;   Arguments:
;
;       None.
;
;   Return Value:
;
;       The address of the first registration record.
;
;--

cPublicProc _RtlpGetReturnAddress ,0
;cPublicFpo 0,0

        mov     eax,[ebp+4]
        stdRET    _RtlpGetReturnAddress

stdENDP _RtlpGetReturnAddress
_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\stkwalk.asm ===
TITLE   "Capture Stack Back Trace"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    stkwalk.asm
;
; Abstract:
;
;    This module implements the routine RtlCaptureStackBackTrace.  It will
;    walker the stack back trace and capture a portion of it.
;
; Author:
;
;    Steve Wood (stevewo) 29-Jan-1992
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

IFDEF NTOS_KERNEL_RUNTIME
        EXTRNP  _MmIsAddressValid,1
        EXTRNP  _KeGetCurrentIrql,0
        EXTRN   _KiPCR:DWORD
ENDIF

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

IFDEF NTOS_KERNEL_RUNTIME
        page ,132
        subttl  "RtlGetCallersAddress"
;++
;
; VOID
; RtlGetCallersAddress(
;    OUT PVOID *CallersAddress,
;    OUT PVOID *CallersCaller
;    )
;
; Routine Description:
;
;    This routine walks up the stack frames, capturing the first two return
;    addresses
;
;
; Arguments:
;
;    OUT PVOID CallersAddress - returns callers return address
;    OUT PVOID CallersCaller - returns callers caller return address
;
; Return Value:
;
;     None.
;
;
;--
RgcaCallersAddress      EQU [ebp+08h]
RgcaCallersCaller       EQU [ebp+0Ch]
cPublicProc _RtlGetCallersAddress ,2
        push    ebp
        mov     ebp, esp
        push    ebx                     ; Save EBX
        push    esi                     ; Save ESI
        push    edi                     ; Save EDI
        mov     eax, PCR[PcPrcbData+PbCurrentThread] ; (eax)->current thread
        push    ThStackBase[eax]        ;  RcbtStackBase = base of kernel stack
        push    esp                     ; Save current esp for handler
        push    offset RgcaFault        ; Address of handler
        push    PCR[PcExceptionList]    ; Save current list head
        mov     PCR[PcExceptionList],esp; Put us on list
        xor     esi,esi                 ; (ESI) will contain callers return address
        xor     edi,edi                 ; (EDI) will contain callers caller return address

        mov     edx,ebp                 ; (EDX) = current frame pointer
        mov     edx,[edx]               ; (EDX) = callers frame pointer
        cmp     edx,ebp                 ; If outside stack limits,
        jbe     short RgcaExit          ; ...then exit
        cmp     edx,RcbtStackBase
        jae     short RgcaCheckForDpcStack
        cmp     edx,ThStackLimit[eax]
        jb      short RgcaCheckForDpcStack

Rgca20:
        mov     esi,[edx].4             ; Get callers return address

        mov     edx,[edx]               ; (EDX) = callers caller frame pointer
        cmp     edx,ebp                 ; If outside stack limits,
        jbe     short RgcaExit          ; ...then exit
        cmp     edx,RcbtStackBase
        jae     short RgcaExit

        mov     edi,[edx].4             ; Get callers caller return address
RgcaExit:
        mov     ecx,RgcaCallersAddress
        jecxz   @F
        mov     [ecx],esi
@@:
        mov     ecx,RgcaCallersCaller
        jecxz   @F
        mov     [ecx],edi
@@:
        pop     PCR[PcExceptionList]    ; Restore Exception list
        pop     edi                     ; discard handler address
        pop     edi                     ; discard saved esp
        pop     edi                     ; discard RcbtStackBase
        pop     edi                     ; Restore EDI
        pop     esi                     ; Restore ESI
        pop     ebx                     ; Restore EBX
        pop     ebp
        stdRET  _RtlGetCallersAddress

;
; We may be executing on the DPC stack for this processor which is ok.
;

RgcaCheckForDpcStack:

        ; Check if DPC active.

        cmp     dword ptr PCR[PcPrcbData+PbDpcRoutineActive], 0
        mov     eax, PCR[PcPrcbData+PbDpcStack]
        je      short RgcaExit          ; if no DPC active, must be bad stack.

        ; Check if address if below DPC stack upper bound
        ;
        ; Note: If we ARE on the DPC stack, we need to adjust this funtion's
        ; idea of the initial stack pointer so it will succeed the check at
        ; the next level.   We do not support transitioning across stacks in
        ; this function.

        cmp     edx, eax
        mov     RcbtStackBase, eax
        jae     short RgcaExit          ; exit if above upper bound

        ; Check if below DPC stack lower bound.

        sub     eax, KERNEL_STACK_SIZE
        cmp     edx, eax
        ja      short Rgca20            ; jif on DPC stack
        jmp     short RgcaExit          ; not on DPC stack.


RgcaFault:
;
; Cheap and sleazy exception handler.  This will not unwind properly, which
; is ok because this function is a leaf except for calling KeGetCurrentIrql,
; which has no exception handler.
;
        mov     eax,[esp+0Ch]           ; (esp)->Context
        mov     edi,CsEdi[eax]          ; restore buffer pointer
        mov     esp,[esp+8]             ; (esp)->ExceptionList
        jmp     RgcaExit                ;
stdENDP _RtlGetCallersAddress
ENDIF

IFDEF NTOS_KERNEL_RUNTIME
RcbtStackBase        EQU [ebp-10h]
ENDIF

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\close.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This module implements routines related to handling IRP_MJ_CLOSE.

--*/

#include "udfx.h"

NTSTATUS
UdfxFsdClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_CLOSE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;
    PUDF_FCB Fcb;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    FileObject = IrpSp->FileObject;

    //
    // Synchronize access to the file control block lists by acquiring the
    // global mutex.
    //

    UdfxAcquireGlobalMutexExclusive();

    //
    // Delete the directory enumeration context if one exists.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)FileObject->FsContext2;

    if (DirectoryEnumContext != NULL) {
        FileObject->FsContext2 = NULL;
        ExFreePool(DirectoryEnumContext);
    }

    //
    // Dereference the file control block associated with the file object.
    //

    Fcb = (PUDF_FCB)FileObject->FsContext;
    FileObject->FsContext = NULL;
    UdfxDereferenceFcb(Fcb);

    //
    // Decrement the file object count for the volume and check if we're ready
    // to delete this device object.
    //

    VolumeExtension->FileObjectCount--;

    if ((VolumeExtension->FileObjectCount == 0) && VolumeExtension->Dismounted) {
        UdfxDeleteVolumeDevice(DeviceObject);
    }

    UdfxReleaseGlobalMutex();

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\up\makefile.inc ===
!ifdef PASS0ONLY
.SUFFIXES: .c
!endif

obj\$(TARGET_DIRECTORY)\generr.obj: ..\generr.c

..\error.h: obj\$(TARGET_DIRECTORY)\generr.obj
    generr $? $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\devctrl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    devctrl.c

Abstract:

    This module implements routines related to handling IRP_MJ_DEVICE_CONTROL.

--*/

#include "udfx.h"

NTSTATUS
UdfxFsdDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_DEVICE_CONTROL
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;

    VolumeExtension = (PUDF_VOLUME_EXTENSION)DeviceObject->DeviceExtension;

    //
    // Check if the volume has been dismounted.
    //

    if (VolumeExtension->Dismounted) {
        status = STATUS_VOLUME_DISMOUNTED;
        goto CleanupAndExit;
    }

    //
    // Pass the IRP down to the target device.  We don't need to touch any of
    // the arguments.
    //

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(VolumeExtension->TargetDeviceObject, Irp);

CleanupAndExit:
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\rtl\i386\xsum.asm ===
title  "Compute Checksum"

;/*++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    cksy.asm
;
; Abstract:
;
;    This module implements a function to compute the checksum of a buffer.
;
; Author:
;
;    David N. Cutler (davec) 27-Jan-1992
;
; Revision History:
;
;     Who         When        What
;     --------    --------    ----------------------------------------------
;     mikeab      01-22-94    Pentium optimization
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--*/

LOOP_UNROLLING_BITS     equ     5
LOOP_UNROLLING          equ     (1 SHL LOOP_UNROLLING_BITS)

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        .list

        .code

;++
;
; ULONG
; tcpxsum(
;   IN ULONG cksum,
;   IN PUCHAR buf,
;   IN ULONG len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;
; Arguments:
;
;    cksum - Suppiles the initial checksum value, in 16-bit form,
;            with the high word set to 0.
;
;    buf - Supplies a pointer to the buffer to the checksum buffer.
;
;    len - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum in 32-bit two-partial-accumulators form, added to
;    the initial checksum, is returned as the function value.
;
;--

cksum   equ     12                      ; stack offset to initial checksum
buf     equ     16                      ; stack offset to source address
len     equ     20                      ; stack offset to length in words

to_checksum_last_word:
        jmp     checksum_last_word

to_checksum_done:
        jmp     checksum_done

to_checksum_dword_loop_done:
        jmp     checksum_dword_loop_done

cPublicProc tcpxsum,3

        push    ebx                     ; save nonvolatile register
        push    esi                     ; save nonvolatile register

        mov     ecx,[esp + len]         ; get length in bytes
        sub     eax,eax                 ; clear computed checksum
        test    ecx,ecx                 ; any bytes to checksum at all?
        jz      short to_checksum_done  ; no bytes to checksum

;
; if the checksum buffer is not word aligned, then add the first byte of
; the buffer to the input checksum.
;

        mov     esi,[esp + buf]         ; get source address
        sub     edx,edx                 ; set up to load word into EDX below
        test    esi,1                   ; check if buffer word aligned
        jz      short checksum_word_aligned ; if zf, buffer word aligned
        mov     ah,[esi]                ; get first byte (we know we'll have
                                        ;  to swap at the end)
        inc     esi                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; If the buffer is not an even number of of bytes, then initialize
; the computed checksum with the last byte of the buffer.
;

checksum_word_aligned:                  ;
        shr     ecx,1                   ; convert to word count
        jnc     short checksum_start    ; if nc, even number of bytes
        mov     al,[esi+ecx*2]          ; initialize the computed checksum
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; Compute checksum in large blocks of dwords, with one partial word up front if
; necessary to get dword alignment, and another partial word at the end if
; needed.
;

;
; Compute checksum on the leading word, if that's necessary to get dword
; alignment.
;

checksum_start:                         ;
        test    esi,02h                 ; check if source dword aligned
        jz      short checksum_dword_aligned ; source is already dword aligned
        mov     dx,[esi]                ; get first word to checksum
        add     esi,2                   ; update source address
        add     eax,edx                 ; update partial checksum
                                        ;  (no carry is possible, because EAX
                                        ;  and EDX are both 16-bit values)
        dec     ecx                     ; count off this word (zero case gets
                                        ;  picked up below)

;
; Checksum as many words as possible by processing a dword at a time.
;

checksum_dword_aligned:
        push    ecx                     ; so we can tell if there's a trailing
                                        ;  word later
        shr     ecx,1                   ; # of dwords to checksum
        jz      short to_checksum_last_word ; no dwords to checksum

        mov     edx,[esi]               ; preload the first dword
        add     esi,4                   ; point to the next dword
        dec     ecx                     ; count off the dword we just loaded
        jz      short to_checksum_dword_loop_done
                                        ; skip the loop if that was the only
                                        ;  dword
        mov     ebx,ecx                 ; EBX = # of dwords left to checksum
        add     ecx,LOOP_UNROLLING-1    ; round up loop count
        shr     ecx,LOOP_UNROLLING_BITS ; convert from word count to unrolled
                                        ;  loop count
        and     ebx,LOOP_UNROLLING-1    ; # of partial dwords to do in first
                                        ;  loop
        jz      short checksum_dword_loop ; special-case when no partial loop,
                                          ;  because fixup below doesn't work
                                          ;  in that case (carry flag is
                                          ;  cleared at this point, as required
                                          ;  at loop entry)
        lea     esi,[esi+ebx*4-(LOOP_UNROLLING*4)]
                                        ; adjust buffer pointer back to
                                        ;  compensate for hardwired displacement
                                        ;  at loop entry point
                                        ; ***doesn't change carry flag***
        jmp     loop_entry[ebx*4]       ; enter the loop to do the first,
                                        ; partial iteration, after which we can
                                        ; just do 64-word blocks
                                        ; ***doesn't change carry flag***

checksum_dword_loop:

DEFLAB  macro   pre,suf
pre&suf:
        endm

TEMP=0
        REPT    LOOP_UNROLLING
        deflab  loop_entry_,%TEMP
        adc     eax,edx
        mov     edx,[esi + TEMP]
TEMP=TEMP+4
        ENDM

checksum_dword_loop_end:

        lea     esi,[esi + LOOP_UNROLLING * 4]  ; update source address
                                        ; ***doesn't change carry flag***
        dec     ecx                     ; count off unrolled loop iteration
                                        ; ***doesn't change carry flag***
        jnz     checksum_dword_loop     ; do more blocks

checksum_dword_loop_done label proc
        adc     eax,edx                 ; finish dword checksum
        mov     edx,0                   ; prepare to load trailing word
        adc     eax,edx

;
; Compute checksum on the trailing word, if there is one.
; High word of EDX = 0 at this point
; Carry flag set iff there's a trailing word to do at this point
;

checksum_last_word label proc           ; "proc" so not scoped to function
        pop     ecx                     ; get back word count
        test    ecx,1                   ; is there a trailing word?
        jz      short checksum_done     ; no trailing word
        add     ax,[esi]                ; add in the trailing word
        adc     eax,0                   ;

checksum_done label proc                ; "proc" so not scoped to function
        mov     ecx,eax                 ; fold the checksum to 16 bits
        ror     ecx,16
        add     eax,ecx
        mov     ebx,[esp + buf]
        shr     eax,16
        test    ebx,1                   ; check if buffer word aligned
        jz      short checksum_combine  ; if zf set, buffer word aligned
        ror     ax,8                    ; byte aligned--swap bytes back
checksum_combine label proc             ; "proc" so not scoped to function
        add     ax,word ptr [esp + cksum] ; combine checksums
        pop     esi                     ; restore nonvolatile register
        adc     eax,0                   ;
        pop     ebx                     ; restore nonvolatile register
        stdRET  tcpxsum


REFLAB  macro   pre,suf
        dd      pre&suf
        endm

        align   4
loop_entry      label   dword
        dd      0
TEMP=LOOP_UNROLLING*4
        REPT    LOOP_UNROLLING-1
TEMP=TEMP-4
        reflab  loop_entry_,%TEMP
        ENDM






stdENDP tcpxsum



LOOP_UNROLLING_BITS_XMMI     equ     4
LOOP_UNROLLING_XMMI          equ     (1 SHL LOOP_UNROLLING_BITS_XMMI)

;VRSTEST EQU     0
ifdef VRSTEST
;
; Test tcpxsum_xmmi for correctness.
tcksum   equ     8[ebp]                   ; stack offset to initial checksum
tbuf     equ     12[ebp]                   ; stack offset to source address
tlen     equ     16[ebp]                  ; stack offset to length in words
        align
cPublicProc tcpxsum_xmmi,3
        ;int     3
        push    ebp
        mov     ebp, esp
        push    ebx
        push    esi
        mov     ebx, offset tcpxsum
        mov     esi, offset tcpxsum_xmmi1
        ; Get a "random" number
        .586p
        rdtsc
        .386p
        and     eax, 10H
        jz      old_then_new
        ; Swap which routine is called first
        push    ebx
        mov     ebx, esi
        pop     esi
old_then_new:
        ; Call the first routine
        push    tlen
        push    tbuf
        push    tcksum
        call    ebx
        ; Save the answer
        push    eax
        ; Call the second routine
        push    tlen
        push    tbuf
        push    tcksum
        call    esi
        ; Check the answer
        cmp     eax, [esp]
        jnz     different_xsum
        ; Same answer, we are done
        pop     eax
        pop     esi
        pop     ebx
        pop     ebp
        stdRET  tcpxsum_xmmi
        align
        ; Different answers, need to debug the problem
different_xsum:
        ; Get both checksums onto the stack
        push    eax
        ; ... and bugcheck
        ;EXTRNP  _KeBugCheck,1,IMPORT
        ;stdCall   _KeBugCheck, <0>
again:
        int     3
        jmp     again
stdENDP tcpxsum_xmmi
endif


;++
;
; ULONG
; tcpxsum_xmmi(
;   IN ULONG cksum,
;   IN PUCHAR buf,
;   IN ULONG len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;    It uses Processor's prefetch instruction.
;
; Arguments:
;
;    cksum - Suppiles the initial checksum value, in 16-bit form,
;            with the high word set to 0.
;
;    buf - Supplies a pointer to the buffer to the checksum buffer.
;
;    len - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum in 32-bit two-partial-accumulators form, added to
;    the initial checksum, is returned as the function value.
;
;--

cksum   equ     12                      ; stack offset to initial checksum
buf     equ     16                      ; stack offset to source address
len     equ     20                      ; stack offset to length in words

to_checksum_last_word_xmmi:
        jmp     checksum_last_word_xmmi

to_checksum_done_xmmi:
        jmp     checksum_done_xmmi

to_checksum_dword_loop_done_xmmi:
        jmp     checksum_dword_loop_done_xmmi

ifdef VRSTEST
cPublicProc tcpxsum_xmmi1,3
else
cPublicProc tcpxsum_xmmi,3
endif

        push    ebx                     ; save nonvolatile register
        push    esi                     ; save nonvolatile register

        mov     ecx,[esp + len]         ; get length in bytes
        sub     eax,eax                 ; clear computed checksum
        test    ecx,ecx                 ; any bytes to checksum at all?
        jz      short to_checksum_done_xmmi  ; no bytes to checksum

;
; if the checksum buffer is not word aligned, then add the first byte of
; the buffer to the input checksum.
;

        mov     esi,[esp + buf]         ; get source address
        sub     edx,edx                 ; set up to load word into EDX below
        test    esi,1                   ; check if buffer word aligned
        jz      short checksum_word_aligned ; if zf, buffer word aligned
        mov     ah,[esi]                ; get first byte (we know we'll have
                                        ;  to swap at the end)
        inc     esi                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      short to_checksum_done_xmmi  ; if zf set, no more bytes

;
; If the buffer is not an even number of of bytes, then initialize
; the computed checksum with the last byte of the buffer.
;

checksum_word_aligned:                  ;
        shr     ecx,1                   ; convert to word count
        jnc     short checksum_start    ; if nc, even number of bytes
        mov     al,[esi+ecx*2]          ; initialize the computed checksum
        jz      short to_checksum_done_xmmi  ; if zf set, no more bytes

;
; Compute checksum in large blocks of dwords, with one partial word up front if
; necessary to get dword alignment, and another partial word at the end if
; needed.
;

;
; Compute checksum on the leading word, if that's necessary to get dword
; alignment.
;

checksum_start:                         ;
        test    esi,02h                 ; check if source dword aligned
        jz      short checksum_dword_aligned ; source is already dword aligned
        mov     dx,[esi]                ; get first word to checksum
        add     esi,2                   ; update source address
        add     eax,edx                 ; update partial checksum
                                        ;  (no carry is possible, because EAX
                                        ;  and EDX are both 16-bit values)
        dec     ecx                     ; count off this word (zero case gets
                                        ;  picked up below)

;
; Checksum as many words as possible by processing a dword at a time.
;

checksum_dword_aligned:
        push    ecx                     ; so we can tell if there's a trailing
                                        ;  word later
        shr     ecx,1                   ; # of dwords to checksum
        jz      short to_checksum_last_word_xmmi ; no dwords to checksum

        mov     edx,[esi]               ; preload the first dword
        add     esi,4                   ; point to the next dword
        dec     ecx                     ; count off the dword we just loaded
        jz      short to_checksum_dword_loop_done_xmmi
                                        ; skip the loop if that was the only
                                        ;  dword
        mov     ebx,ecx                 ; EBX = # of dwords left to checksum
        add     ecx,LOOP_UNROLLING_XMMI-1    ; round up loop count
        shr     ecx,LOOP_UNROLLING_BITS_XMMI ; convert from word count to unrolled
                                        ;  loop count
        and     ebx,LOOP_UNROLLING_XMMI-1    ; # of partial dwords to do in first
                                        ;  loop
        jz      short checksum_dword_loop ; special-case when no partial loop,
                                          ;  because fixup below doesn't work
                                          ;  in that case (carry flag is
                                          ;  cleared at this point, as required
                                          ;  at loop entry)
        lea     esi,[esi+ebx*4-(LOOP_UNROLLING_XMMI*4)]
                                        ; adjust buffer pointer back to
                                        ;  compensate for hardwired displacement
                                        ;  at loop entry point
                                        ; ***doesn't change carry flag***
        jmp     xmmi_loop_entry[ebx*4]  ; enter the loop to do the first,
                                        ; partial iteration, after which we can
                                        ; just do 64-word blocks
                                        ; ***doesn't change carry flag***

checksum_dword_loop:
        ; prefetch the 32-byte cache line from [esi+0]
        db 0fH
        db 18H
        db 46H
        db 00H

        ; prefetch the 32-byte cache line from [esi+20h]
        db 0fH
        db 18H
        db 46H
        db 20H

        ; prefetch the 32-byte cache line from [esi+40h]
        db 0fH
        db 18H
        db 46H
        db 40H

        ; prefetch the 32-byte cache line from [esi+60h]
        db 0fH
        db 18H
        db 46H
        db 60H

DEFLAB  macro   pre,suf
pre&suf:
        endm

TEMP=0
        REPT    LOOP_UNROLLING_XMMI
        deflab  xmmi_loop_entry_,%TEMP
        adc     eax,edx
        mov     edx,[esi + TEMP]
TEMP=TEMP+4
        ENDM

checksum_dword_loop_end:

        lea     esi,[esi + LOOP_UNROLLING_XMMI * 4]  ; update source address
                                        ; ***doesn't change carry flag***
        dec     ecx                     ; count off unrolled loop iteration
                                        ; ***doesn't change carry flag***
        jnz     checksum_dword_loop     ; do more blocks

checksum_dword_loop_done_xmmi label proc
        adc     eax,edx                 ; finish dword checksum
        mov     edx,0                   ; prepare to load trailing word
        adc     eax,edx

;
; Compute checksum on the trailing word, if there is one.
; High word of EDX = 0 at this point
; Carry flag set iff there's a trailing word to do at this point
;

checksum_last_word_xmmi label proc      ; "proc" so not scoped to function
        pop     ecx                     ; get back word count
        test    ecx,1                   ; is there a trailing word?
        jz      short checksum_done_xmmi; no trailing word
        add     ax,[esi]                ; add in the trailing word
        adc     eax,0                   ;

checksum_done_xmmi label proc           ; "proc" so not scoped to function
        mov     ecx,eax                 ; fold the checksum to 16 bits
        ror     ecx,16
        add     eax,ecx
        mov     ebx,[esp + buf]
        shr     eax,16
        test    ebx,1                   ; check if buffer word aligned
        jz      short checksum_combine_xmmi  ; if zf set, buffer word aligned
        ror     ax,8                    ; byte aligned--swap bytes back
checksum_combine_xmmi label proc        ; "proc" so not scoped to function
        add     ax,word ptr [esp + cksum] ; combine checksums
        pop     esi                     ; restore nonvolatile register
        adc     eax,0                   ;
        pop     ebx                     ; restore nonvolatile register
        stdRET  tcpxsum


REFLAB  macro   pre,suf
        dd      pre&suf
        endm

        align   4
xmmi_loop_entry      label   dword
        dd      0
TEMP=LOOP_UNROLLING_XMMI*4
        REPT    LOOP_UNROLLING_XMMI-1
TEMP=TEMP-4
        reflab  xmmi_loop_entry_,%TEMP
        ENDM

ifdef VRSTEST
stdENDP tcpxsum_xmmi1
else
stdENDP tcpxsum_xmmi
endif

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\udfx\create.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    create.c

Abstract:

    This module implements routines related to handling IRP_MJ_CREATE.

--*/

#include "udfx.h"

//
// Structure that wraps up all of the variables related to walk through a
// directory stream.
//

typedef struct _UDF_DIRECTORY_MAPPING {
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PIRP Irp;
    PUDF_FCB DirectoryFcb;
    ULONG LogicalSectorNumber;
    ULONG FileBytesRemaining;
    ULONG CacheBytesRemaining;
    PVOID CacheBuffer;
    PUCHAR CurrentBuffer;
} UDF_DIRECTORY_MAPPING, *PUDF_DIRECTORY_MAPPING;

NTSTATUS
UdfxMapNextDirectorySector(
    IN OUT PUDF_DIRECTORY_MAPPING DirectoryMapping
    )
/*++

Routine Description:

    This routine maps the next directory sector into the cache using the state
    in the supplied mapping structure.

Arguments:

    DirectoryMapping - Specifies a structure that describes the current sector
        mapping and how to map the next sector.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PUDF_VOLUME_EXTENSION VolumeExtension;
    PUCHAR LocalCurrentBuffer;
    ULONG LocalCacheBytesRemaining;

    //
    // If another sector has already been mapped, then unmap it now.
    //

    if (DirectoryMapping->CacheBuffer != NULL) {
        FscUnmapBuffer(DirectoryMapping->CacheBuffer);
        DirectoryMapping->CacheBuffer = NULL;
    }

    //
    // If there aren't any more bytes remaining in the directory stream, then
    // bail out now.
    //

    if (DirectoryMapping->FileBytesRemaining == 0) {
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    // Map the directory sector into the cache.
    //

    VolumeExtension = DirectoryMapping->VolumeExtension;

    status = UdfxMapLogicalSector(VolumeExtension, DirectoryMapping->Irp,
        DirectoryMapping->LogicalSectorNumber, &DirectoryMapping->CacheBuffer);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    DirectoryMapping->LogicalSectorNumber++;

    LocalCurrentBuffer = (PUCHAR)DirectoryMapping->CacheBuffer;

    //
    // If the data is part of the file descriptor, then adjust the current
    // buffer to point to the real start of the data.  The number of remaining
    // bytes will be adjusted below.
    //

    if (UdfxIsFlagSet(DirectoryMapping->DirectoryFcb->Flags, UDF_FCB_EMBEDDED_DATA)) {
        LocalCurrentBuffer += DirectoryMapping->DirectoryFcb->EmbeddedDataOffset;
        ASSERT(DirectoryMapping->FileBytesRemaining < UDF_CD_SECTOR_SIZE);
    }

    //
    // Compute the number of bytes remaining in the file and in this cache
    // buffer taking into account whether or not this is the last sector of the
    // directory stream.
    //

    if (DirectoryMapping->FileBytesRemaining > UDF_CD_SECTOR_SIZE) {
        LocalCacheBytesRemaining = UDF_CD_SECTOR_SIZE;
        DirectoryMapping->FileBytesRemaining -= UDF_CD_SECTOR_SIZE;
    } else {
        LocalCacheBytesRemaining = DirectoryMapping->FileBytesRemaining;
        DirectoryMapping->FileBytesRe