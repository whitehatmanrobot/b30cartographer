rry, charlie...
			ASSERT(FALSE); // this shouldn't ever happen!!!
            ReleaseMutex (m_hWriteMutex);
            return FALSE;
        }*/

        if (m_iWriters == 0)
        {
            // We don't already have write access, so we need to clear all the
            // readers out.
            if (WaitForSingleObject (m_hNoReaders, TIMEOUT_VAL) == WAIT_TIMEOUT)
            {
                ASSERT (FALSE);
                ReleaseMutex (m_hWriteMutex);
                return FALSE;
            }
        }

        if (InterlockedIncrement (&m_iReaders) == 1)
            ResetEvent (m_hNoReaders);
        m_iWriters++;
        return TRUE;
    }

    ////////////////////////////////////////////////////////////////////////////
    // SuspendWrite
    //
    // This function puts the lock in a state where no further write permissions
    // we be granted (even to the calling thread), but reads from ANY thread
    // will be.  Use ResumeWrite() to get back to original state.

    BOOL    SuspendWrite ()
    {
        if (WaitForSingleObject (m_hWriteMutex, TIMEOUT_VAL) == WAIT_TIMEOUT)
        {
            ASSERT (FALSE);
            return FALSE; // If we can't get it, we don't HAVE it!
        }

		if (m_cSuspendDepth++)
			goto l_done;

/*        ASSERT (!m_fWritesDenied);
        m_fWritesDenied = TRUE;*/

        // For each writer, release the write mutex
		unsigned i;
        for (i=0; i<m_iWriters; i++)
            ReleaseMutex (m_hWriteMutex);

l_done:
        // Release it one more time, which should render it signalled
        ReleaseMutex (m_hWriteMutex);
        return TRUE;
    }

    ////////////////////////////////////////////////////////////////////////////
    // ResumeWrite
    //
    // This function puts the lock back in the state at which SuspendWrite was
    // called by obtaining the write mutex for each writer.  This
    // allows threads to nest calls to BeginWrite, call SuspendWrite to allow
    // read access, and then ResumeWrite to get back to the nested state.

    BOOL    ResumeWrite ()
    {
        if (WaitForSingleObject (m_hWriteMutex, TIMEOUT_VAL) == WAIT_TIMEOUT)
        {
            ASSERT (FALSE);     // This is bad news...
            return FALSE;
        }

		ASSERT(m_cSuspendDepth > 0);
		if (--m_cSuspendDepth)
			goto l_done;

        // Make sure we're actually resuming a suspended write state
//        ASSERT (m_fWritesDenied);

        // For each writer we had previously, grab the write mutex
		unsigned i;
        for (i=0; i<m_iWriters; i++)
        {
            DWORD   dw = WaitForSingleObject (m_hWriteMutex, 0);
            ASSERT (dw == WAIT_OBJECT_0);       // We already own it!
        }

//        m_fWritesDenied = FALSE;

l_done:
        // Release the mutex that we grabbed for this function
        ReleaseMutex (m_hWriteMutex);
        return TRUE;
    }

    ////////////////////////////////////////////////////////////////////////////
    // EndWrite

    void    EndWrite ()
    {
		if (m_iWriters < 1)
		{
			ASSERT(FALSE); // mismatched BeginWrite/EndWrite calls!
			return;
		}

        m_iWriters--;
        ReleaseMutex (m_hWriteMutex);
		ReleaseMutex (m_hWriteSerializerMutex);
        EndRead ();
    }
};


struct POOLEDMUTEX
{
    HANDLE  hMutex;
    union
    {
        long    iLockCount;
        long    iNextFree;
    };
};

////////////////////////////////////////////////////////////////////////////////
// CPooledMutex
//
// A 'pooled mutex' is a locking mechanism that does not require the existence
// of an actual mutex until the object is actually locked.  Mutex objects are
// stored in a global pool, and dished out only to locked objects.  When the
// object is finally unlocked, the mutex object is returned to the pool.
//
// Benefits of Pooled Mutex over normal mutex or critical sections:
//  1) Size (this object's instance data is 2 bytes; critsec's are 24, mutex handles are 4)
//  2) Reduced system resource depletion (if numerous objects need their own
//     locks, but few are locked at once) -- comparison doesn't apply to critsec's
//
// Costs:
//  1) Speed (there's more grunt work to do, especially in the non-nested, single
//     use lock/unlock case, where we must get/release handles from/to the pool, etc.)

class CPooledMutex
{
    class CHouseKeeper
    {
    public:
        CHouseKeeper ();
        ~CHouseKeeper ();
    };
    friend class CHouseKeeper;

private:
    static  POOLEDMUTEX     *m_rghPool;         // The mutex handle pool
    static  long            m_iAllocSize;       // Allocated size of the pool
    static  long            m_iNextFree;        // Index of first available mutex
    static  CThreadLock     m_lock;             // Critsec for locking/unlocking
    static  CHouseKeeper    m_hk;               // Handles construction/destruction of pool

    static  void            Initialize ();
    static  void            Shutdown ();
    static  long            GetNextMutex ();
    static  void            RepoolMutex (long iIndex);
    static  void            Lock (short *piCookie);
    static  void            Unlock (short *piCookie);

    short                   m_iIndex;           // This instance's mutex index (-1 means not locked)

public:
    CPooledMutex () : m_iIndex(-1) {}
    ~CPooledMutex () { ASSERT (m_iIndex == -1);  } // If you hit this assert, you're destroying a locked mutex!

    void    Lock () { Lock (&m_iIndex); }
    void    Unlock () { Unlock (&m_iIndex); }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\fontsandcolors.h ===
//------------------------------------------------------------------------------
// fontsandcolors.h
// Author: Josh Stevens [joshs]
//
// Fonts & Colors helper macros.  See common\idl\vs\vsshell.idl for related
// interfaces and enums.
//------------------------------------------------------------------------------


#pragma once


// Sometimes includers of this file define INIT_GUID and sometimes they don't,
// so rather than using the DEFINE_GUID macro and hoping it works, we'll just
// define the GUIDs by hand.

// {1F987C00-E7C4-4869-8A17-23FD602268B0}
EXTERN_C const GUID DECLSPEC_SELECTANY GUID_DialogsAndToolWindowsFC = { 0x1f987c00, 0xe7c4, 0x4869, { 0x8a, 0x17, 0x23, 0xfd, 0x60, 0x22, 0x68, 0xb0 } };

// {A27B4E24-A735-4d1d-B8E7-9716E1E3D8E0}
EXTERN_C const GUID DECLSPEC_SELECTANY GUID_TextEditorFC = { 0xa27b4e24, 0xa735, 0x4d1d, { 0xb8, 0xe7,  0x97,  0x16,  0xe1,  0xe3,  0xd8,  0xe0 } };

// {C34C709B-C855-459e-B38C-3021F162D3B1}
EXTERN_C const GUID DECLSPEC_SELECTANY GUID_TextOutputToolWindowsFC = { 0xc34c709b, 0xc855, 0x459e, { 0xb3, 0x8c, 0x30, 0x21, 0xf1, 0x62, 0xd3, 0xb1 } };

// {47724E70-AF55-48fb-A928-BB161C1D0C05}
EXTERN_C const GUID DECLSPEC_SELECTANY GUID_PrinterFC = { 0x47724e70, 0xaf55, 0x48fb, { 0xa9, 0x28, 0xbb, 0x16, 0x1c, 0x1d, 0xc, 0x5 } };


// Only font size between these two values (inclusive) are listed in the
// Fonts & Colors page.
#define FONT_SIZE_MIN 6
#define FONT_SIZE_MAX 24

#define INITFONTINFO(f) { ZeroMemory(&(f), sizeof(FontInfo)); (f).bFaceNameValid = (f).bPointSizeValid = (f).bCharSetValid = FALSE; }

#define DESTROYFONTINFO(f) \
    { \
        if ((f).bstrFaceName != NULL) ::SysFreeString((f).bstrFaceName); \
        INITFONTINFO(f); \
    }

#define COPYFONTINFO(a, b) \
    { \
        DESTROYFONTINFO(a); \
        memcpy(&(a), &(b), sizeof(FontInfo)); \
        if ((b).bstrFaceName != NULL) \
        { \
            (a).bstrFaceName = ::SysAllocString((b).bstrFaceName); \
        } \
        else \
        { \
            (a).bstrFaceName = NULL; \
        } \
    }


#define INITCOLORABLEITEMINFO(c) { ZeroMemory(&(c), sizeof(ColorableItemInfo)); (c).bForegroundValid = (c).bBackgroundValid = (c).bFontFlagsValid = FALSE; }
#define COPYCOLORABLEITEMINFO(a, b) { memcpy(&(a), &(b), sizeof(ColorableItemInfo)); }


#define INITALLCOLORABLEITEMINFO(a) \
    { \
        ZeroMemory(&(a), sizeof(AllColorableItemInfo)); \
        INITCOLORABLEITEMINFO((a).Info); \
        (a).bNameValid = \
        (a).bLocalizedNameValid = \
        (a).bAutoForegroundValid = \
        (a).bAutoBackgroundValid = \
        (a).bMarkerVisualStyleValid = \
        (a).bLineStyleValid = \
        (a).bFlagsValid = \
        (a).bDescriptionValid = FALSE; \
    }

#define DESTROYALLCOLORABLEITEMINFO(a) \
    { \
        if ((a).bstrName != NULL) ::SysFreeString((a).bstrName); \
        if ((a).bstrLocalizedName != NULL) ::SysFreeString((a).bstrLocalizedName); \
        if ((a).bstrDescription != NULL) ::SysFreeString((a).bstrDescription); \
        INITALLCOLORABLEITEMINFO(a); \
    }

#define COPYALLCOLORABLEITEMINFO(a, b) \
    {  \
        DESTROYALLCOLORABLEITEMINFO(a); \
        memcpy(&(a), &(b), sizeof(AllColorableItemInfo)); \
        COPYCOLORABLEITEMINFO((a).Info, (b).Info); \
        if ((b).bstrName != NULL) \
        { \
            (a).bstrName = ::SysAllocString((b).bstrName); \
        } \
        else \
        { \
            (a).bstrName = NULL; \
        } \
        if ((b).bstrLocalizedName != NULL) \
        { \
            (a).bstrLocalizedName = ::SysAllocString((b).bstrLocalizedName); \
        } \
        else \
        { \
            (a).bstrLocalizedName = NULL; \
        } \
        if ((b).bstrDescription != NULL) \
        { \
            (a).bstrDescription = ::SysAllocString((b).bstrDescription); \
        } \
        else \
        { \
            (a).bstrDescription = NULL; \
        } \
    }


// This constant means that bits 0-23 are an index into the following color table:
// 0  - generic text (foreground)
// 1  - generic text (background)
// 2  - black
// 3  - white
// 4  - maroon
// 5  - dark green
// 6  - brown
// 7  - dark blue
// 8  - purple
// 9  - aquamarine
// 10 - light gray
// 11 - dark gray
// 12 - red
// 13 - green
// 14 - yellow
// 15 - blue
// 16 - magenta
// 17 - cyan
// 18 - selected text (foreground) == ::GetSysColor(COLOR_HIGHLIGHTTEXT)
// 19 - selected text (background) == ::GetSysColor(COLOR_HIGHLIGHT)
// 20 - inactive selection (foreground) == ::GetSysColor(COLOR_INACTIVECAPTIONTEXT)
// 21 - inactive selection (background) == ::GetSysColor(COLOR_INACTIVECAPTION)
// 22 - indicator margin (background) == ::GetSysColor(COLOR_3DFACE)
// 23 - plain text (foreground) == ::GetSysColor(COLOR_WINDOWTEXT)
// 24 - plain text (background) == ::GetSysColor(COLOR_WINDOW)
// Entries 0-1 and 18-24 are tracking (i.e., dynamic)
#define _COLORREF_INDEXED (0x01000000)

// This indicates that bits 0-23 are a COLOR_* value, the raw RGB equivalent of which
// is returned from the GetSysColor() function.
#define _COLORREF_SYS (0x10000000)

// This indicates that bits 0-23 are a VSCOLOR_* value, the raw RGB equivalent of which
// is returned from IVsUIShell::GetVSSysColor().
#define _COLORREF_VS (0x20000000)

// These three constants define the range of "real" colors in our palette--that is,
// colors that correspond to raw RGB constants and don't "track" system color
// settings.
#define FIRST_REAL_COLOR (2)
#define LAST_REAL_COLOR  (17)
#define REAL_COLOR_COUNT (LAST_REAL_COLOR - FIRST_REAL_COLOR + 1)

// Call these to create COLORREF that represents the color specified by the given
// index.  The value returned is NOT a raw RGB value.
#define INDEXED_COLORREF(c)     (_COLORREF_INDEXED | (c))
#define INDEXED_SYS_COLORREF(c) (_COLORREF_SYS     | (c))
#define INDEXED_VS_COLORREF(c)  (_COLORREF_VS      | (c))

// Call this to extract the index from an indexed COLORREF (e.g., a value returned
// by INDEXED_COLORREF().  The value returned is NOT a raw RGB value, nor is it
// an index-coded COLORREF; it is simply an index.
#define GET_COLORREF_INDEX(c) ((c) & 0x00ffffff)

// Returns whether the specified value is an index-coded COLORREF.
#define IS_INDEXED_COLORREF(c) ((c) & (_COLORREF_INDEXED | _COLORREF_SYS | _COLORREF_VS))

// Returns whether the given COLORREF is an index-coded value that corresponds to
// one of the system color values (i.e., not a "real" color value).
#define IS_AUTO_COLORREF(c) (IS_INDEXED_COLORREF(c) && (GET_COLORREF_INDEX(c) < FIRST_REAL_COLOR || GET_COLORREF_INDEX(c) > LAST_REAL_COLOR))

// This constant means that the color tracks the 'automatic' color specified
// in the crAutoForeground or crAutoBackground member.
#define COLORREF_AUTO (0x02000000)

// This constant means that the color is invalid, or not set.
#define COLORREF_INVALID (0xff000000)

// This constant means that the color tracks the foreground color of another
// item in the list, specified by an index in bits 0-23.
#define COLORREF_TRACK_FG_BY_INDEX (0x04000000)

#define COLORREF_TRACK_BG_BY_INDEX (0x08000000)

#define PALETTE_SIZE (16 + 2 + 7)
#define ACTUAL_COLOR(Color, Auto) GetRGBValue(Color, Auto)

extern int ShellAutoToWin32Constant(int index);
extern COLORREF GetRGBValue(COLORREF crColor, COLORREF crAuto = COLORREF_INVALID, IServiceProvider *pSP = NULL, const GUID *pguidCategory = NULL);
extern void SetPaletteColor(int index, COLORREF color);
extern void SetUserTextColors(REFGUID rguidCategory, COLORREF crForeground, COLORREF crBackground);
extern COLORREF GetPaletteColor(int index);
extern BOOL GetUserTextColors(REFGUID rguidCategory, COLORREF *pcrForeground, COLORREF *pcrBackground);
extern COLORREF* GetColorPalette();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\javaguid.h ===
// JAVAGUID.H

// {1D0762F0-8439-11d0-A8AA-00A0C921A4D2}
DEFINE_GUID(CLSID_JavaLangService,
0x1d0762f0, 0x8439, 0x11d0, 0xa8, 0xaa, 0x0, 0xa0, 0xc9, 0x21, 0xa4, 0xd2);

DEFINE_GUID(SID_SJavaLangService,
0x1d0762f0, 0x8439, 0x11d0, 0xa8, 0xaa, 0x0, 0xa0, 0xc9, 0x21, 0xa4, 0xd2);

// {AECC23E0-8AA3-11d0-B606-00A0C922E851}
DEFINE_GUID(CLSID_JavaPackage, 
0x42aa6510, 0x5245, 0x11d2, 0x8c, 0xfc, 0x0, 0xc0, 0x4f, 0xc2, 0xc6, 0xcc);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\mnuhelpids.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Visual Studio
//
//  Microsoft Confidential
//  Copyright 1997-1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:	menucmds.h
//	Area:	Help Package Commands
//
//  Contents:
//		Helps System Package Menu, Group, Command IDs
//
//----------------------------------------------------------------------------
#ifndef __HELPIDS_H_
#define __HELPIDS_H_


#ifndef NOGUIDS

#ifdef DEFINE_GUID
  // WB package object CLSID
  DEFINE_GUID (guidHelpCmdId,
    0x4a79114a, 0x19e4, 0x11d3, 0xb8, 0x6b, 0x0, 0xc0, 0x4f, 0x79, 0xf8, 0x2);

  DEFINE_GUID (guidHelpGrpId,
    0x4a79114b, 0x19e4, 0x11d3, 0xb8, 0x6b, 0x0, 0xc0, 0x4f, 0x79, 0xf8, 0x2);

  DEFINE_GUID (guidHelpPkg,
    0x4a791146, 0x19e4, 0x11d3, 0xb8, 0x6b, 0x0, 0xc0, 0x4f, 0x79, 0xf8, 0x2);

#else
// {4A79114A-19E4-11d3-B86B-00C04F79F802}
#define guidHelpCmdId    {0x4a79114a, 0x19e4, 0x11d3, {0xb8, 0x6b, 0x0, 0xc0, 0x4f, 0x79, 0xf8, 0x2 }}

// {4A79114B-19E4-11d3-B86B-00C04F79F802}
#define guidHelpGrpId    {0x4a79114b, 0x19e4, 0x11d3, {0xb8, 0x6b, 0x0, 0xc0, 0x4f, 0x79, 0xf8, 0x2 }}


// The following is the same as CLSID_HelpPackage but for consumption by CTC.
// {4A791146-19E4-11d3-B86B-00C04F79F802}
#define guidHelpPkg			{0x4a791146, 0x19e4, 0x11d3, {0xb8, 0x6b, 0x0, 0xc0, 0x4f, 0x79, 0xf8, 0x2}}

#endif //DEFINE_GUID

#endif //NOGUIDS

	
// Menus
#define IDM_HELP_CONTENTS	    0x0001
#define IDM_HELP_KEYWORDS	    0x0002
#define IDM_HELP_SEARCH		    0x0003

#define IDM_HELP_MENU_MSONTHWEB     0x0100

#define IDM_HLPTOC_CTX		    0x0200
#define IDM_HELP_RESLIST_CTX        0x0300
#define IDM_HELP_RESLIST_CTX_SORTBY 0x0400

// Groups
#define IDG_HELP_GRP		    0x0010
#define IDG_HELPVIEW_GRP            0x0020
#define IDG_HELP_FILTERS            0x0030

#define IDG_HLPTOC_CTX_PRINT        0x0050

#define IDG_HELP_RESLIST_CTX_SORTBY 0x0060
#define IDG_HELP_RESLIST_CTX_COLUMNS 0x0070

#define IDG_HELP_MSONTHEWEB_NEWS    0x0100
#define IDG_HELP_MSONTHEWEB_INFO    0x0200
#define IDG_HELP_MSONTHEWEB_HOME    0x0300


//Command IDs
#define icmdHelpContents	    0x0100
#define icmdHelpKeywords            0x0101
#define icmdHelpSearch		    0x0102
#define icmdModifyFilter            0x0103
#define icmdHelpOnHelp              0x0104

#define icmdSearchResults           0x0110
#define icmdIndexResults            0x0111

// TOC contex menu                  
#define icmdPrintTopic              0x0120
#define icmdPrintChildren           0x0121

#define icmdSortByCol1              0x0130
#define icmdSortByCol2              0x0131
#define icmdSortByCol3              0x0132
#define icmdSortByCol4              0x0133
#define icmdSortByCol5              0x0134
#define icmdSortByCol6              0x0135
#define icmdSortByCol7              0x0136
#define icmdSortByCol8              0x0137
#define icmdSortByCol9              0x0138
#define icmdSortByCol10             0x0139

#define icmdSortByColMin            icmdSortByCol1
#define icmdSortByColMax            icmdSortByCol10


#define icmdHelpOnTheWeb_FIRST      0x1000
#define icmdHelpOnTheWebFree        0x1000 // Must be consecutive.
#define icmdHelpOnTheWebNews        0x1001
#define icmdHelpOnTheWebFAQ         0x1002
#define icmdHelpOnTheWebSupport     0x1003
#define icmdHelpOnTheWebMSDN        0x1004
#define icmdHelpOnTheWebFeedback    0x1005
#define icmdHelpOnTheWebBest        0x1006
#define icmdHelpOnTheWebSearch      0x1007
#define icmdHelpOnTheWebTutorial    0x1008
#define icmdHelpOnTheWebHome        0x1009
#define icmdHelpOnTheWeb_LAST       0x1009

///////////////////////////////////////////////////////////////////////////////
// Button Bitmap IDs

#define bmpidVsHelpContents           1
#define bmpidVsHelpIndex              2
#define bmpidVsHelpSearch             3
#define bmpidVsHelpIndexResults       4
#define bmpidVsHelpSearchResults      5



#endif //__HELPIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\lock.h ===
////////////////////////////////////////////////////////////////////////////////
// LOCK.H
//
// Helper classes for adding thread synchronization to objects.  To make any
// object 'thread safe', make it derive from CThreadLockable, which contains the
// overhead of the lock and exposes two functions, ThreadLock and ThreadUnlock.
//
// For convenience, use a local CLock object to provide scope-locking on an
// object that is CThreadLockable, such as:
//
//      CLock       lock(&MyObject);
//
// This will lock MyObject (by calling ThreadLock()) on construction, and unlock
// on destruction.
//
// If your object has its own locking mechanism, you can use the template form
// of CLock (CObjLock<T>) which makes the same calls to ThreadLock/Unlock, but
// does not require the object to derive CThreadLockable.

#pragma once
#include "dbgout.h" // ASSERT
////////////////////////////////////////////////////////////////////////////////
// CSmallLock
//
// This object is a very small version of a critical section.  It grants 'access'
// to a single thread, using an efficient wait state when the lock is contended.
// This object is 4 bytes in size, as opposed to the 24 bytes required by a
// Win32 critical section.  However, you lose two important things by using
// CSmallLock instead of a critical section:
//
//  1) A lock count is NOT maintained, so the same thread cannot request access
//     to the same lock a second time (if it does it will hang forever).
//  2) Critical sections use a semaphore (when the lock is contended) so that
//     threads requesting access to a locked critical section are queued.  This
//     object does not do this, so access to a newly unlocked object is granted
//     to the next thread awaiting access that the scheduler happens to start.
//     Plus, waiting on a semaphore is a kernel wait, which is slightly more
//     efficient.
//
// CSmallLock enters an efficient spin loop when the lock is contended.  On a
// single processor machine, this loop simply gives up its time slice; on a
// multi-processor machine, the loop 'spins' re-checking the lock state for 'a
// while' before relinquishing the processor in hopes that the thread owning
// the lock will release it, thus avoiding the expensive context switch.

class CSmallLock
{
private:
    volatile    long        m_iLock;

    // UNDONE:  Implement spin count stuff...
    long        SpinStart () { return 0; }
    void        Spin (long *piSpinCount) { if ((*piSpinCount)-- < 0) { Sleep(1); *piSpinCount = SpinStart(); } }

public:
    CSmallLock() : m_iLock(0) {}

    void    Lock ()
    {
        long    iSpin = SpinStart ();
        while (InterlockedExchange ((long *)&m_iLock, 1) != 0)
            Spin (&iSpin);
    }

    void    Unlock ()
    {
        ASSERT (m_iLock == 1);
        m_iLock = 0;
    }
};

////////////////////////////////////////////////////////////////////////////////
// CCountLock
//
// This is a lock-count-maintaining version of CSmallLock.  It allows a thread
// to nest calls to Lock/Unlock without deadlocking.  Takes 8 bytes instead of
// 4.

class CCountLock
{
private:
    volatile    DWORD       m_dwOwner;          // Owning thread (non-zero means locked)
                long        m_iLockCount;       // Lock count

    // UNDONE:  Implement spin count stuff...
    long        SpinStart () { return 0; }
    void        Spin (long *piSpinCount) { if ((*piSpinCount)-- < 0) { Sleep(1); *piSpinCount = SpinStart(); } }

public:
    CCountLock () : m_dwOwner(0), m_iLockCount(0) {}

    long    Lock ()
    {
        long    iSpin = SpinStart ();
        DWORD   dwOld, dwTid = GetCurrentThreadId();

        while (TRUE)
        {
/*
#if defined(_WIN64) || defined(_NEW_SDK)
            dwOld = (DWORD)InterlockedCompareExchange ((long *)&m_dwOwner, (long)dwTid, 0);
#else
            dwOld = (DWORD)InterlockedCompareExchange ((void **)&m_dwOwner, (void *)dwTid, 0);
#endif
*/

        //TIMSULL try this instead so we can run on Win95   V7-43140
        dwOld = (DWORD)_InterlockedCompareExchange ((long*)&m_dwOwner, (long)dwTid, 0);

        if (dwOld == 0 || dwOld == dwTid)
                break;
            Spin (&iSpin);
        }

        return ++m_iLockCount;
    }

    long    Unlock ()
    {
        ASSERT (m_dwOwner == GetCurrentThreadId());
        ASSERT (m_iLockCount > 0);
        if (--m_iLockCount == 0)
        {
            m_dwOwner = 0;
            return 0;
        }
        return m_iLockCount;
    }

    BOOL    LockedByMe () { return m_dwOwner == GetCurrentThreadId(); }


// Win64Fix (MikhailA)
#ifndef _WIN64
//TIMSULL source for InterlockedCompareExchange   V7-43140
__forceinline
LONG
__fastcall
_InterlockedCompareExchange(
  IN OUT PLONG Destination,
  IN LONG Exchange,
  IN LONG Comperand
  )
{
  LONG lRet;
  __asm {
    mov  eax, Comperand
    mov  ecx, Destination
    mov  edx, Exchange
    lock cmpxchg [ecx], edx
    mov  lRet, eax
  }
  return lRet;
};

#endif // !_WIN64

};

////////////////////////////////////////////////////////////////////////////////
// CReadWriteLock
//
// This is a multiple-reader, single-writer lock mechanism.  Up to 4 threads can
// simultaneously acquire read permission (when no writer exists), and a single
// thread can acquire write permission (when no other readers exist).  It's also
// permitted for the same thread to obtain a read lock after obtaining a write
// lock, and vice versa (provided no other readers exist).  All locks can be
// recursively acquired.
//
// Additionally, the writer thread can mark the lock as 'write-suspended', which
// allows other threads to acquire read locks but disallows other threads to
// acquire write locks.  This is handy for protecting an object that fires
// events when changes are made to it -- the writer thread will write lock, make
// its changes, write-suspend the lock, fire the events (opening other threads to
// read the object to examine changed data but disallowing further modifications)
// and finally unlocking when all events are fired.  Suspending writes allows
// reads regardless of the number of locks the writer thread has acquired, and
// the calling thread must still unlock once for each time it acquired write
// access.  Once suspended, the writer thread must 'resume' its write lock, which
// will block until any other reader threads have 'left the building'.

class CReadWriteLock
{
private:
    enum
    {
        LF_WRITEPENDING = 0x01,     // Thread is waiting for write access
        LF_WRITESUSPENDED = 0x02,   // Writer thread has allowed reads without revoking its write privilege

        READERS = 4,                // Number of readers (keep small)
    };

    CSmallLock      m_lock;                     // Lock for access to below data
    DWORD           m_dwWriter;                 // Writer thread ID
    DWORD           m_rgdwReaders[READERS];     // Reader thread IDs
    BYTE            m_rgiReadLocks[READERS];    // Reader lock counts
    BYTE            m_iWriteLocks;              // Writer lock count
    BYTE            m_wFlags;                   // Flags

public:
    CReadWriteLock () : m_dwWriter(0), m_iWriteLocks(0), m_wFlags(0)
    {
        ZeroMemory (m_rgdwReaders, sizeof (m_rgdwReaders));
        ZeroMemory (m_rgiReadLocks, sizeof (m_rgiReadLocks));
    }

#ifdef _DEBUG
    ~CReadWriteLock () { ASSERT (m_wFlags == 0); ASSERT (m_dwWriter == 0); for (long i=0; i<READERS; i++) ASSERT (m_rgdwReaders[i] == 0); }
#endif

    void        ReadLock ();
    void        ReadUnlock ();
    void        WriteLock ();
    void        WriteUnlock ();
    BOOL        WriteSuspend ();        // NOTE:  Returns FALSE if writes were already suspended -- these are NOT cumulative!
    void        WriteResume ();
};

////////////////////////////////////////////////////////////////////////////////
// CThreadLockable

class CThreadLockable
{
    CCountLock      m_lock;

public:
    void        ThreadLock () { m_lock.Lock (); }
    void        ThreadUnlock () { m_lock.Unlock (); }
};

////////////////////////////////////////////////////////////////////////////////
// CObjLock

template <class T>
class CObjLock
{
private:
    T   *m_pObject;

public:
    CObjLock (T *p) : m_pObject(p) { m_pObject->ThreadLock (); }
    ~CObjLock () { Unlock (); }
    void    Unlock () { if (m_pObject != NULL) { m_pObject->ThreadUnlock (); m_pObject = NULL; } }
    void    Lock (T *p) { ASSERT (m_pObject == NULL || p == m_pObject); m_pObject = p; p->ThreadLock (); }
};

////////////////////////////////////////////////////////////////////////////////
// CLock

typedef CObjLock<CThreadLockable>   CLock;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\leakdiag.h ===
/* LeakDiag.h

	Copyright (c) 2001 Microsoft Corporation.	All Rights Reserved.

	Abstract:
        LeakDiag detects leaks of GDI and USER object handles.

***************************************************
Author: MikhailA
First revision: 05-14-2001
***************************************************

The following objects are handled

GDI
	HDC
    HPEN
    HBRUSH
    HBITMAP
    HFONT
    HRGN
    HPALETTE
    HCOLORSPACE

USER
    HMENU
    HACCEL
    HICON
    HCURSOR

COMCTL
    HIMAGELIST


How does it work?

LeakDiag redefines GDI and USER functions (such as CreateBitmap or DeleteObject) so the call 
first goes to the leakdiag.dll along with the location (file name and the line #) where the allocation
took place. The DLL maintains a list of allocated handles along with file names and line numbers.
When the correspondent destructor (DeleeObject, ReleaseDC, etc) get called, the call again goes
to the leakdiag.dll and the handle gets removed from the list.

LeakDiag will assert if the destructor fails (for example, when you use DeleteObject instead 
of DestroyCursor on a cursor handle).


How to use

1. Include leakdiag.h after system and CRT headers, but before your local header files

2. Add a reference to the leakdiag.lib in your sources file	BEFORE system libraries. 
In VS7 packages the best place is next to the vsassert.lib

!IF ("$(BUILD_RETAIL)" == "no")
        $(VSBUILT)\$(BUILT_FLAVOR)\lib\*\vsassert.lib \
        $(VSBUILT)\$(BUILT_FLAVOR)\lib\*\leakdiag.lib \
!ENDIF

3. Run suites or just play with the application, executing code that allocates and destroys
GDI and USER object.

4. Close the application. If there are leaks, you'll see them in the debugger output window,
like

LeakDiag: handle leak at c:\foo\bar.cpp (123)

OR

LeakDiag: no leaks detected

5. If you have code that creates an object and then hands it over to another module
that is not under the leakdiag control, you will see a leak since the leakdiag.dll
nevers sees a call that deletes the object. To fix this you may call
LeakDiag_RemoveHandle() before you hand the object over to another module. This
will remove the handle from the leakdiag list of handles so it won't report 
a bogus leak.


Current (5/14/01) version does not assert on leaks since it is not fully tested so there
may be some noise in the reports and I don't want suites to break without a reason.
For the same reason leakdiag is not yet permanently active. 

IMPORTANT NOTICE:

One may see that in the header some GDI/USER functions are redeclared using macros
while some redeclared as functions. All functions started as macros. but some VS7 modules
required them to be declared as functions. For instance, if module declares its own
LoadBitmap as a member of a class, the macro won't work since the code won't compile.
This is done on a case by case basis, as needed.

*/

#pragma once

#define LEAKDIAG_ACTIVE                         0x01
#define LEAKDIAG_ASSERT_LEAKS                   0x02
#define LEAKDIAG_OUTPUT_DEBUG_STRING            0x04
#define LEAKDIAG_ASSERT_REDUNDANT_DELETEOBJECT  0x08

#ifdef DEBUG

#define _LEAKDIAG_ACTIVE_

#ifdef __cplusplus
extern "C"
{
#endif

#ifdef _LEAKDIAG_IMPL
#define LD_DLLEXPORT __declspec(dllexport) __stdcall
#else
#define LD_DLLEXPORT __declspec(dllimport) __stdcall
#endif

HANDLE   LD_DLLEXPORT   LeakDiag_AddHandle(HANDLE hObjToAdd, LPCSTR pszFile, int nLine);
HANDLE   LD_DLLEXPORT   LeakDiag_RemoveHandle(HANDLE hObj);
void     LD_DLLEXPORT   LeakDiag_DumpLeaks(void);
DWORD    LD_DLLEXPORT   LeakDiag_SetMode(DWORD dwMode);
BOOL     LD_DLLEXPORT   LeakDiag_DeleteObject(HGDIOBJ h);
BOOL     LD_DLLEXPORT   LeakDiag_EndPaint(HWND hwnd, CONST PAINTSTRUCT* pps);
HMENU    LD_DLLEXPORT   LeakDiag_CreateMenu(LPCSTR pszFile, int nLine);
HMENU    LD_DLLEXPORT   LeakDiag_CreatePopupMenu(LPCSTR pszFile, int nLine);
HICON    LD_DLLEXPORT   LeakDiag_LoadIconA(HINSTANCE hInst, LPCSTR lpszIcon, LPCSTR pszFile, int nLine);
HICON    LD_DLLEXPORT   LeakDiag_LoadIconW(HINSTANCE hInst, LPCWSTR lpszIcon, LPCSTR pszFile, int nLine);
HANDLE   LD_DLLEXPORT   LeakDiag_LoadImageA(HINSTANCE hInst, LPCSTR lpszName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad, LPCSTR pszFile, int nLine);
HANDLE   LD_DLLEXPORT   LeakDiag_LoadImageW(HINSTANCE hInst, LPCWSTR lpszName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad, LPCSTR pszFile, int nLine);
UINT     LD_DLLEXPORT   LeakDiag_ExtractIconExA(LPCSTR pszIconFile, int index, HICON* phLarge, HICON* hSmall, UINT uiIcon, LPCSTR pszFile, int nLine);
UINT     LD_DLLEXPORT   LeakDiag_ExtractIconExW(LPCWSTR pszIconFile, int index, HICON* phLarge, HICON* hSmall, UINT uiIcon, LPCSTR pszFile, int nLine);

#ifdef __cplusplus
}
#endif

#ifndef LEAKDIAG_NO_REDEFINITION

#ifndef _LEAKDIAG_IMPL

#ifdef __cplusplus

template <class T>
T LeakDiag_Convert(HANDLE h)
{ return static_cast<T>(h); }

// General
#define DeleteObject(h)         LeakDiag_DeleteObject(h)

#ifdef LEAKDIAG_VBDC
// DC
#define VBDeleteDC(hdc)           VBDeleteDC(LeakDiag_Convert<HDC>(LeakDiag_RemoveHandle(hdc)))
#define VBReleaseDC(hwnd, hdc)    VBReleaseDC(hwnd, LeakDiag_Convert<HDC>(LeakDiag_RemoveHandle(hdc)))
#define VBEndPaint(hwnd, ps)      LeakDiag_EndPaint(hwnd, ps)

#define VBBeginPaint(hwnd, ps)        LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::VBBeginPaint(hwnd, ps), __FILE__, __LINE__))
#define VBGetDC(hwnd)                 LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::VBGetDC(hwnd), __FILE__, __LINE__))
#define VBGetDCEx(hwnd, hrgn, dw)     LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::VBGetDCEx(hwnd, hrgn, dw), __FILE__, __LINE__))
#define VBGetWindowDC(hwnd)           LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::VBGetWindowDC(hwnd), __FILE__, __LINE__))
#define VBCreateDCA(s1, s2, s3, dm)   LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::VBCreateDCA(s1, s2, s3, dm), __FILE__, __LINE__))
#define VBCreateDCW(s1, s2, s3, dm)   LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::VBCreateDCW(s1, s2, s3, dm), __FILE__, __LINE__))
#define VBCreateCompatibleDC(a)       LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::VBCreateCompatibleDC(a), __FILE__, __LINE__))

#else
// DC
#define DeleteDC(hdc)           DeleteDC(LeakDiag_Convert<HDC>(LeakDiag_RemoveHandle(hdc)))
#define ReleaseDC(hwnd, hdc)    ReleaseDC(hwnd, LeakDiag_Convert<HDC>(LeakDiag_RemoveHandle(hdc)))
#define EndPaint(hwnd, ps)      LeakDiag_EndPaint(hwnd, ps)

#define BeginPaint(hwnd, ps)        LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::BeginPaint(hwnd, ps), __FILE__, __LINE__))
#define GetDC(hwnd)                 LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::GetDC(hwnd), __FILE__, __LINE__))
#define GetDCEx(hwnd, hrgn, dw)     LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::GetDCEx(hwnd, hrgn, dw), __FILE__, __LINE__))
#define GetWindowDC(hwnd)           LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::GetWindowDC(hwnd), __FILE__, __LINE__))
#define CreateDCA(s1, s2, s3, dm)   LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::CreateDCA(s1, s2, s3, dm), __FILE__, __LINE__))
#define CreateDCW(s1, s2, s3, dm)   LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::CreateDCW(s1, s2, s3, dm), __FILE__, __LINE__))
#define CreateCompatibleDC(a)       LeakDiag_Convert<HDC>(LeakDiag_AddHandle(::CreateCompatibleDC(a), __FILE__, __LINE__))

#endif // LEAKDIAG_VBDC

// Pens
#define CreatePen(a, b, c)                      LeakDiag_Convert<HPEN>(LeakDiag_AddHandle(::CreatePen(a, b, c), __FILE__, __LINE__))
#define CreatePenIndirect(a)                    LeakDiag_Convert<HPEN>(LeakDiag_AddHandle(::CreatePenIndirect(a), __FILE__, __LINE__))
#define ExtCreatePen(dw1, dw2, lb, dw3, pdw)    LeakDiag_Convert<HPEN>(LeakDiag_AddHandle(::ExtCreatePen(dw1, dw2, lb, dw3, pdw), __FILE__, __LINE__))

// Brushes
#define CreateBrush(a, b, c)            LeakDiag_Convert<HBRUSH>(LeakDiag_AddHandle(::CreateBrush(a, b, c), __FILE__, __LINE__))
#define CreateBrushIndirect(a)          LeakDiag_Convert<HBRUSH>(LeakDiag_AddHandle(::CreateBrushIndirect(a), __FILE__, __LINE__))
#define CreateDIBPatternBrushPt(a, b)   LeakDiag_Convert<HBRUSH>(LeakDiag_AddHandle(::CreateDIBPatternBrushPt(a, b), __FILE__, __LINE__))
#define CreateDIBPatternBrush(a, b)     LeakDiag_Convert<HBRUSH>(LeakDiag_AddHandle(::CreateDIBPatternBrush(a, b), __FILE__, __LINE__))
#define CreateHatchBrush(a, b)          LeakDiag_Convert<HBRUSH>(LeakDiag_AddHandle(::CreateHatchBrush(a, b), __FILE__, __LINE__))
#define CreatePatternBrush(a)           LeakDiag_Convert<HBRUSH>(LeakDiag_AddHandle(::CreatePatternBrush(a), __FILE__, __LINE__))
#define CreateSolidBrush(a)             LeakDiag_Convert<HBRUSH>(LeakDiag_AddHandle(::CreateSolidBrush(a), __FILE__, __LINE__))

// Bitmaps
#define CreateBitmap(a1, a2, a3, a4, a5)            LeakDiag_Convert<HBITMAP>(LeakDiag_AddHandle(::CreateBitmap(a1, a2, a3, a4, a5), __FILE__, __LINE__))
#define CreateBitmapIndirect(a)                     LeakDiag_Convert<HBITMAP>(LeakDiag_AddHandle(::CreateBitmapIndirect(a), __FILE__, __LINE__))
#define CreateCompatibleBitmap(a1, a2, a3)          LeakDiag_Convert<HBITMAP>(LeakDiag_AddHandle(::CreateCompatibleBitmap(a1, a2, a3), __FILE__, __LINE__))
#define CreateDIBitmap(a1, a2, a3, a4, a5, a6)      LeakDiag_Convert<HBITMAP>(LeakDiag_AddHandle(::CreateDIBitmap(a1, a2, a3, a4, a5, a6), __FILE__, __LINE__))
#define CreateDIBSection(a1, a2, a3, a4, a5, a6)    LeakDiag_Convert<HBITMAP>(LeakDiag_AddHandle(::CreateDIBSection(a1, a2, a3, a4, a5, a6), __FILE__, __LINE__))
#define LoadBitmapA(a1, a2)                         LeakDiag_Convert<HBITMAP>(LeakDiag_AddHandle(::LoadBitmapA(a1, a2), __FILE__, __LINE__))
#define LoadBitmapW(a1, a2)                         LeakDiag_Convert<HBITMAP>(LeakDiag_AddHandle(::LoadBitmapW(a1, a2), __FILE__, __LINE__))

// Icons
#define LoadIconA(a1, a2)                                       LeakDiag_LoadIconA(a1, a2, __FILE__, __LINE__)
#define LoadIconW(a1, a2)                                       LeakDiag_LoadIconW(a1, a2, __FILE__, __LINE__)
#define DuplicateIcon(a1, a2)                                   LeakDiag_Convert<HICON>(LeakDiag_AddHandle(::DuplicateIcon(a1, a2), __FILE__, __LINE__))
#define CopyIcon(a1)                                            LeakDiag_Convert<HICON>(LeakDiag_AddHandle(::CopyIcon(a1), __FILE__, __LINE__))
#define ExtractIconA(a1, a2, a3)                                LeakDiag_Convert<HICON>(LeakDiag_AddHandle(::ExtractIconA(a1, a2, a3), __FILE__, __LINE__))
#define ExtractIconW(a1, a2, a3)                                LeakDiag_Convert<HICON>(LeakDiag_AddHandle(::ExtractIconW(a1, a2, a3), __FILE__, __LINE__))
#define ExtractIconExA(a1, a2, a3, a4, a5)                      LeakDiag_ExtractIconExA(a1, a2, a3, a4, a5, __FILE__, __LINE__)
#define ExtractIconExW(a1, a2, a3, a4, a5)                      LeakDiag_ExtractIconExW(a1, a2, a3, a4, a5, __FILE__, __LINE__)
#define ExtractAssociatedIconA(a1, a2, a3)                      LeakDiag_Convert<HICON>(LeakDiag_AddHandle(::ExtractAssociatedIconA(a1, a2, a3), __FILE__, __LINE__))
#define ExtractAssociatedIconW(a1, a2, a3)                      LeakDiag_Convert<HICON>(LeakDiag_AddHandle(::ExtractAssociatedIconW(a1, a2, a3), __FILE__, __LINE__))
#define CreateIcon(a1, a2, a3, a4, a5, a6, a7)                  LeakDiag_Convert<HICON>(LeakDiag_AddHandle(::CreateIcon(a1, a2, a3, a4, a5, a6, a7), __FILE__, __LINE__))
#define CreateIconFromResource(a1, a2, a3, a4)                  LeakDiag_Convert<HICON>(LeakDiag_AddHandle(::CreateIconFromResource(a1, a2, a3, a4), __FILE__, __LINE__))
#define CreateIconFromResourceEx(a1, a2, a3, a4, a5, a6, a7)    LeakDiag_Convert<HICON>(LeakDiag_AddHandle(::CreateIconFromResourceEx(a1, a2, a3, a4, a5, a6, a7), __FILE__, __LINE__))
#define CreateIconIndirect(a1)                                  LeakDiag_Convert<HICON>(LeakDiag_AddHandle(::CreateIconIndirect(a1), __FILE__, __LINE__))
#define DestroyIcon(h)                                          DestroyIcon(LeakDiag_Convert<HICON>(LeakDiag_RemoveHandle(h)))

// Fonts
#define CreateFontA(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)  LeakDiag_Convert<HFONT>(LeakDiag_AddHandle(::CreateFontA(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14), __FILE__, __LINE__))
#define CreateFontW(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)  LeakDiag_Convert<HFONT>(LeakDiag_AddHandle(::CreateFontW(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14), __FILE__, __LINE__))
#define CreateFontIndirectA(a)                                                    LeakDiag_Convert<HFONT>(LeakDiag_AddHandle(::CreateFontIndirectA(a), __FILE__, __LINE__))
#define CreateFontIndirectW(a)                                                    LeakDiag_Convert<HFONT>(LeakDiag_AddHandle(::CreateFontIndirectW(a), __FILE__, __LINE__))
#define CreateFontIndirectExA(a)                                                  LeakDiag_Convert<HFONT>(LeakDiag_AddHandle(::CreateFontIndirectExA(a), __FILE__, __LINE__))
#define CreateFontIndirectExW(a)                                                  LeakDiag_Convert<HFONT>(LeakDiag_AddHandle(::CreateFontIndirectExW(a), __FILE__, __LINE__))

// Cursors

//#define CopyCursor(a1)                              LeakDiag_Convert<HCURSOR>(LeakDiag_AddHandle(::CopyCursor(a1), __FILE__, __LINE__))
#define CreateCursor(a1, a2, a3, a4, a5, a6, a7)    LeakDiag_Convert<HCURSOR>(LeakDiag_AddHandle(::CreateCursor(a1, a2, a3, a4, a5, a6, a7), __FILE__, __LINE__))
#define LoadCursorFromFileA(a1)                     LeakDiag_Convert<HCURSOR>(LeakDiag_AddHandle(::LoadCursorFromFileA(a1), __FILE__, __LINE__))
#define LoadCursorFromFileW(a1)                     LeakDiag_Convert<HCURSOR>(LeakDiag_AddHandle(::LoadCursorFromFileW(a1), __FILE__, __LINE__))
#define DestroyCursor(h)                            DestroyCursor(LeakDiag_Convert<HCURSOR>(LeakDiag_RemoveHandle(h)))

// Images
#ifdef VSD_VSCOMMODULE_H_INCLUDED_ 
// HACK(MikhailA): hack for VS7 deployment package. Remove when deploy starts using common Unicode wrapper
#define LoadImageW(a1, a2, a3, a4, a5)   LeakDiag_LoadImageW(a1, a2, a3, a4, a5, __FILE__, __LINE__)
#else
#define LoadImageW(a1, a2, a3, a4, a5, a6)   LeakDiag_LoadImageW(a1, a2, a3, a4, a5, a6, __FILE__, __LINE__)
#endif

#define LoadImageA(a1, a2, a3, a4, a5, a6)   LeakDiag_LoadImageA(a1, a2, a3, a4, a5, a6, __FILE__, __LINE__)
#define CopyImage(a1, a2, a3, a4, a5)        LeakDiag_AddHandle(::CopyImage(a1, a2, a3, a4, a5), __FILE__, __LINE__)

// Palette
#define CreatePalette(a1)           LeakDiag_Convert<HPALETTE>(LeakDiag_AddHandle(::CreatePalette(a1), __FILE__, __LINE__))
#define CreateHalftonePalette(a1)   LeakDiag_Convert<HPALETTE>(LeakDiag_AddHandle(::CreateHalftonePalette(a1), __FILE__, __LINE__))

// Accelerators
#define LoadAcceleratorsA(a1, a2)   LeakDiag_Convert<HACCEL>(LeakDiag_AddHandle(::LoadAcceleratorsA(a1, a2), __FILE__, __LINE__))
#define LoadAcceleratorsW(a1, a2)   LeakDiag_Convert<HACCEL>(LeakDiag_AddHandle(::LoadAcceleratorsW(a1, a2), __FILE__, __LINE__))
#define DestroyAcceleratorTable(h)  DestroyAcceleratorTable(LeakDiag_Convert<HACCEL>(LeakDiag_RemoveHandle(h)))

// Menu
#define LoadMenuA(a1, a2)     LeakDiag_Convert<HMENU>(LeakDiag_AddHandle(::LoadMenuA(a1, a2), __FILE__, __LINE__))
#define LoadMenuW(a1, a2)     LeakDiag_Convert<HMENU>(LeakDiag_AddHandle(::LoadMenuW(a1, a2), __FILE__, __LINE__))
#define LoadMenuIndirectA(a1) LeakDiag_Convert<HMENU>(LeakDiag_AddHandle(::LoadMenuIndirectA(a1), __FILE__, __LINE__))
#define LoadMenuIndirectW(a1) LeakDiag_Convert<HMENU>(LeakDiag_AddHandle(::LoadMenuIndirectW(a1), __FILE__, __LINE__))
//#define CreateMenu           LeakDiag_CreateMenu
//#define CreatePopupMenu      LeakDiag_CreatePopupMenu
#define DestroyMenu(h)        DestroyMenu((HMENU)LeakDiag_RemoveHandle(h))

// Colorspace
#define CreateColorSpaceA(a1)    LeakDiag_Convert<HCOLORSPACE>(LeakDiag_AddHandle(::CreateColorSpaceA(a1), __FILE__, __LINE__))
#define CreateColorSpaceW(a1)    LeakDiag_Convert<HCOLORSPACE>(LeakDiag_AddHandle(::CreateColorSpaceW(a1), __FILE__, __LINE__))
#define DeleteColorSpace(h)     DeleteColorSpace(LeakDiag_Convert<HCOLORSPACE>(LeakDiag_RemoveHandle(h)))

// Regions
#define CreateEllipticRgn(a1, a2, a3, a4)           LeakDiag_Convert<HRGN>(LeakDiag_AddHandle(::CreateEllipticRgn(a1, a2, a3, a4), __FILE__, __LINE__))
#define CreateEllipticRgnIndirect(a1)               LeakDiag_Convert<HRGN>(LeakDiag_AddHandle(::CreateEllipticRgnIndirect(a1), __FILE__, __LINE__))
#define CreatePolygonRgn(a1, a2, a3)                LeakDiag_Convert<HRGN>(LeakDiag_AddHandle(::CreatePolygonRgn(a1, a2, a3), __FILE__, __LINE__))
#define CreatePolyPolygonRgn(a1, a2, a3, a4)        LeakDiag_Convert<HRGN>(LeakDiag_AddHandle(::CreatePolyPolygonRgn(a1, a2, a3, a4), __FILE__, __LINE__))
#define CreateRectRgn(a1, a2, a3, a4)               LeakDiag_Convert<HRGN>(LeakDiag_AddHandle(::CreateRectRgn(a1, a2, a3, a4), __FILE__, __LINE__))
#define CreateRectRgnIndirect(a1)                   LeakDiag_Convert<HRGN>(LeakDiag_AddHandle(::CreateRectRgnIndirect(a1), __FILE__, __LINE__))
#define CreateRoundRectRgn(a1, a2, a3, a4, a5, a6)  LeakDiag_Convert<HRGN>(LeakDiag_AddHandle(::CreateRoundRectRgn(a1, a2, a3, a4, a5, a6), __FILE__, __LINE__))
#define ExtCreateRegion(a1, a2, a3)                 LeakDiag_Convert<HRGN>(LeakDiag_AddHandle(::ExtCreateRegion(a1, a2, a3), __FILE__, __LINE__))
#define SetWindowRgn(hWnd, hRgn, bRedraw)           SetWindowRgn(hWnd, LeakDiag_Convert<HRGN>(LeakDiag_RemoveHandle(hRgn)), bRedraw)

// ImageList
#define ImageList_LoadImageA(a1, a2, a3, a4, a5, a6, a7)    LeakDiag_Convert<HIMAGELIST>(LeakDiag_AddHandle(::ImageList_LoadImageA(a1, a2, a3, a4, a5, a6, a7), __FILE__, __LINE__))
#define ImageList_LoadImageW(a1, a2, a3, a4, a5, a6, a7)    LeakDiag_Convert<HIMAGELIST>(LeakDiag_AddHandle(::ImageList_LoadImageW(a1, a2, a3, a4, a5, a6, a7), __FILE__, __LINE__))
#define ImageList_LoadBitmapA(a1, a2, a3, a4, a5)           LeakDiag_Convert<HIMAGELIST>(LeakDiag_AddHandle(::ImageList_LoadBitmapA(a1, a2, a3, a4, a5), __FILE__, __LINE__))
#define ImageList_LoadBitmapW(a1, a2, a3, a4, a5)           LeakDiag_Convert<HIMAGELIST>(LeakDiag_AddHandle(::ImageList_LoadBitmapW(a1, a2, a3, a4, a5), __FILE__, __LINE__))
#define ImageList_Merge(a1, a2, a3, a4, a5, a6)             LeakDiag_Convert<HIMAGELIST>(LeakDiag_AddHandle(::ImageList_Merge(a1, a2, a3, a4, a5, a6), __FILE__, __LINE__))
#define ImageList_Read(a1)                                  LeakDiag_Convert<HIMAGELIST>(LeakDiag_AddHandle(::ImageList_Read(a1), __FILE__, __LINE__))
#define ImageList_Duplicate(a1)                             LeakDiag_Convert<HIMAGELIST>(LeakDiag_AddHandle(::ImageList_Duplicate(a1), __FILE__, __LINE__))
#define ImageList_Create(a1, a2, a3, a4, a5)                LeakDiag_Convert<HIMAGELIST>(LeakDiag_AddHandle(::ImageList_Create(a1, a2, a3, a4, a5), __FILE__, __LINE__))
#define ImageList_Destroy(h)                                ImageList_Destroy(LeakDiag_Convert<HIMAGELIST>(LeakDiag_RemoveHandle(h)))

#else

// plain C

// General
#define DeleteObject(h)         LeakDiag_DeleteObject(h)

#ifdef LEAKDIAG_VBDC

// DC
#define VBDeleteDC(hdc)           VBDeleteDC((HDC)LeakDiag_RemoveHandle(hdc))
#define VBReleaseDC(hwnd, hdc)    VBReleaseDC(hwnd, (HDC)LeakDiag_RemoveHandle(hdc))
#define VBEndPaint(hwnd, ps)      LeakDiag_EndPaint(hwnd, ps)

#define VBBeginPaint(hwnd, ps)        (HDC)LeakDiag_AddHandle(VBBeginPaint(hwnd, ps), __FILE__, __LINE__))
#define VBGetDC(hwnd)                 ((HDC)LeakDiag_AddHandle(VBGetDC(hwnd), __FILE__, __LINE__))
#define VBGetDCEx(hwnd, hrgn, dw)     ((HDC)LeakDiag_AddHandle(VBGetDCEx(hwnd, hrgn, dw), __FILE__, __LINE__))
#define VBGetWindowDC(hwnd)           ((HDC)LeakDiag_AddHandle(VBGetWindowDC(hwnd), __FILE__, __LINE__))
#define VBCreateDCA(s1, s2, s3, dm)   ((HDC)LeakDiag_AddHandle(VBCreateDCA(s1, s2, s3, dm), __FILE__, __LINE__))
#define VBCreateDCW(s1, s2, s3, dm)   ((HDC)LeakDiag_AddHandle(VBCreateDCW(s1, s2, s3, dm), __FILE__, __LINE__))
#define VBCreateCompatibleDC(a)       ((HDC)LeakDiag_AddHandle(VBCreateCompatibleDC(a), __FILE__, __LINE__))

#else
// DC
#define DeleteDC(hdc)           DeleteDC((HDC)LeakDiag_RemoveHandle(hdc))
#define ReleaseDC(hwnd, hdc)    ReleaseDC(hwnd, (HDC)LeakDiag_RemoveHandle(hdc))
#define EndPaint(hwnd, ps)      LeakDiag_EndPaint(hwnd, ps)

#define BeginPaint(hwnd, ps)        (HDC)LeakDiag_AddHandle(BeginPaint(hwnd, ps), __FILE__, __LINE__))
#define GetDC(hwnd)                 ((HDC)LeakDiag_AddHandle(GetDC(hwnd), __FILE__, __LINE__))
#define GetDCEx(hwnd, hrgn, dw)     ((HDC)LeakDiag_AddHandle(GetDCEx(hwnd, hrgn, dw), __FILE__, __LINE__))
#define GetWindowDC(hwnd)           ((HDC)LeakDiag_AddHandle(GetWindowDC(hwnd), __FILE__, __LINE__))
#define CreateDCA(s1, s2, s3, dm)   ((HDC)LeakDiag_AddHandle(CreateDCA(s1, s2, s3, dm), __FILE__, __LINE__))
#define CreateDCW(s1, s2, s3, dm)   ((HDC)LeakDiag_AddHandle(CreateDCW(s1, s2, s3, dm), __FILE__, __LINE__))
#define CreateCompatibleDC(a)       ((HDC)LeakDiag_AddHandle(CreateCompatibleDC(a), __FILE__, __LINE__))

#endif // LEAKDIAG_VBDC

// Pens
#define CreatePen(a, b, c)                      ((HPEN)LeakDiag_AddHandle(CreatePen(a, b, c), __FILE__, __LINE__))
#define CreatePenIndirect(a)                    ((HPEN)LeakDiag_AddHandle(CreatePenIndirect(a), __FILE__, __LINE__))
#define ExtCreatePen(dw1, dw2, lb, dw3, pdw)    ((HPEN)LeakDiag_AddHandle(ExtCreatePen(dw1, dw2, lb, dw3, pdw), __FILE__, __LINE__))

// Brushes
#define CreateBrush(a, b, c)            ((HBRUSH)LeakDiag_AddHandle(::CreateBrush(a, b, c), __FILE__, __LINE__))
#define CreateBrushIndirect(a)          ((HBRUSH)LeakDiag_AddHandle(CreateBrushIndirect(a), __FILE__, __LINE__))
#define CreateDIBPatternBrushPt(a, b)   ((HBRUSH)LeakDiag_AddHandle(CreateDIBPatternBrushPt(a, b), __FILE__, __LINE__))
#define CreateDIBPatternBrush(a, b)     ((HBRUSH)LeakDiag_AddHandle(CreateDIBPatternBrush(a, b), __FILE__, __LINE__))
#define CreateHatchBrush(a, b)          ((HBRUSH)LeakDiag_AddHandle(CreateHatchBrush(a, b), __FILE__, __LINE__))
#define CreatePatternBrush(a)           ((HBRUSH)LeakDiag_AddHandle(CreatePatternBrush(a), __FILE__, __LINE__))
#define CreateSolidBrush(a)             ((HBRUSH)LeakDiag_AddHandle(CreateSolidBrush(a), __FILE__, __LINE__))

// Bitmaps
#define CreateBitmap(a1, a2, a3, a4, a5)            ((HBITMAP)LeakDiag_AddHandle(CreateBitmap(a1, a2, a3, a4, a5), __FILE__, __LINE__))
#define CreateBitmapIndirect(a)                     ((HBITMAP)LeakDiag_AddHandle(CreateBitmapIndirect(a), __FILE__, __LINE__))
#define CreateCompatibleBitmap(a1, a2, a3)          ((HBITMAP)LeakDiag_AddHandle(CreateCompatibleBitmap(a1, a2, a3), __FILE__, __LINE__))
#define CreateDIBitmap(a1, a2, a3, a4, a5, a6)      ((HBITMAP)LeakDiag_AddHandle(CreateDIBitmap(a1, a2, a3, a4, a5, a6), __FILE__, __LINE__))
#define CreateDIBSection(a1, a2, a3, a4, a5, a6)    ((HBITMAP)LeakDiag_AddHandle(CreateDIBSection(a1, a2, a3, a4, a5, a6), __FILE__, __LINE__))
#define LoadBitmapA(a1, a2)                         ((HBITMAP)LeakDiag_AddHandle(LoadBitmapA(a1, a2), __FILE__, __LINE__))
#define LoadBitmapW(a1, a2)                         ((HBITMAP)LeakDiag_AddHandle(LoadBitmapW(a1, a2), __FILE__, __LINE__))

// Icons
#define LoadIconA(a1, a2)                                       LeakDiag_LoadIconA(a1, a2, __FILE__, __LINE__)
#define LoadIconW(a1, a2)                                       LeakDiag_LoadIconW(a1, a2, __FILE__, __LINE__)
#define DuplicateIcon(a1, a2)                                   ((HICON)LeakDiag_AddHandle(DuplicateIcon(a1, a2), __FILE__, __LINE__))
#define CopyIcon(a1)                                            ((HICON)LeakDiag_AddHandle(CopyIcon(a1), __FILE__, __LINE__))
#define ExtractIconA(a1, a2, a3)                                ((HICON)LeakDiag_AddHandle(ExtractIconA(a1, a2, a3), __FILE__, __LINE__))
#define ExtractIconW(a1, a2, a3)                                ((HICON)LeakDiag_AddHandle(ExtractIconW(a1, a2, a3), __FILE__, __LINE__))
#define ExtractIconExA(a1, a2, a3, a4, a5)                      LeakDiag_ExtractIconExA(a1, a2, a3, a4, a5, __FILE__, __LINE__)
#define ExtractIconExW(a1, a2, a3, a4, a5)                      LeakDiag_ExtractIconExW(a1, a2, a3, a4, a5, __FILE__, __LINE__)
#define ExtractAssociatedIconA(a1, a2, a3)                      ((HICON)LeakDiag_AddHandle(ExtractAssociatedIconA(a1, a2, a3), __FILE__, __LINE__))
#define ExtractAssociatedIconW(a1, a2, a3)                      ((HICON)LeakDiag_AddHandle(ExtractAssociatedIconW(a1, a2, a3), __FILE__, __LINE__))
#define CreateIcon(a1, a2, a3, a4, a5, a6, a7)                  ((HICON)LeakDiag_AddHandle(CreateIcon(a1, a2, a3, a4, a5, a6, a7), __FILE__, __LINE__))
#define CreateIconFromResource(a1, a2, a3, a4)                  ((HICON)LeakDiag_AddHandle(CreateIconFromResource(a1, a2, a3, a4), __FILE__, __LINE__))
#define CreateIconFromResourceEx(a1, a2, a3, a4, a5, a6, a7)    ((HICON)LeakDiag_AddHandle(CreateIconFromResourceEx(a1, a2, a3, a4, a5, a6, a7), __FILE__, __LINE__))
#define CreateIconIndirect(a1)                                  ((HICON)LeakDiag_AddHandle(CreateIconIndirect(a1), __FILE__, __LINE__))
#define DestroyIcon(h)                                          DestroyIcon((HICON)LeakDiag_RemoveHandle(h))

// Fonts
#define CreateFontA(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)  ((HFONT)LeakDiag_AddHandle(CreateFontA(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14), __FILE__, __LINE__))
#define CreateFontW(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)  ((HFONT)LeakDiag_AddHandle(CreateFontW(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14), __FILE__, __LINE__))
#define CreateFontIndirectA(a)                                                    ((HFONT)LeakDiag_AddHandle(CreateFontIndirectA(a), __FILE__, __LINE__))
#define CreateFontIndirectW(a)                                                    ((HFONT)LeakDiag_AddHandle(CreateFontIndirectW(a), __FILE__, __LINE__))
#define CreateFontIndirectExA(a)                                                  ((HFONT)LeakDiag_AddHandle(CreateFontIndirectExA(a), __FILE__, __LINE__))
#define CreateFontIndirectExW(a)                                                  ((HFONT)LeakDiag_AddHandle(CreateFontIndirectExW(a), __FILE__, __LINE__))

// Cursors

//#define CopyCursor(a1)                              ((HCURSOR)LeakDiag_AddHandle(CopyCursor(a1), __FILE__, __LINE__))
#define CreateCursor(a1, a2, a3, a4, a5, a6, a7)    ((HCURSOR)LeakDiag_AddHandle(CreateCursor(a1, a2, a3, a4, a5, a6, a7), __FILE__, __LINE__))
#define LoadCursorFromFileA(a1)                     ((HCURSOR)LeakDiag_AddHandle(LoadCursorFromFileA(a1), __FILE__, __LINE__))
#define LoadCursorFromFileW(a1)                     ((HCURSOR)LeakDiag_AddHandle(LoadCursorFromFileW(a1), __FILE__, __LINE__))
#define DestroyCursor(h)                            DestroyCursor((HCURSOR)LeakDiag_RemoveHandle(h))

// Images
#define LoadImageA(a1, a2, a3, a4, a5, a6)   LeakDiag_LoadImageA(a1, a2, a3, a4, a5, a6, __FILE__, __LINE__)
#define LoadImageW(a1, a2, a3, a4, a5, a6)   LeakDiag_LoadImageW(a1, a2, a3, a4, a5, a6, __FILE__, __LINE__)
#define CopyImage(a1, a2, a3, a4, a5)        LeakDiag_AddHandle(::CopyImage(a1, a2, a3, a4, a5), __FILE__, __LINE__)

// Palette
#define CreatePalette(a1)           ((HPALETTE)LeakDiag_AddHandle(CreatePalette(a1), __FILE__, __LINE__))
#define CreateHalftonePalette(a1)   ((HPALETTE)LeakDiag_AddHandle(CreateHalftonePalette(a1), __FILE__, __LINE__))

// Accelerators
#define LoadAcceleratorsA(a1, a2)   ((HACCEL)LeakDiag_AddHandle(LoadAcceleratorsA(a1, a2), __FILE__, __LINE__))
#define LoadAcceleratorsW(a1, a2)   ((HACCEL)LeakDiag_AddHandle(LoadAcceleratorsW(a1, a2), __FILE__, __LINE__))
#define DestroyAcceleratorTable(h)  DestroyAcceleratorTable((HACCEL)LeakDiag_RemoveHandle(h))

// Menu
#define LoadMenuA(a1, a2)     ((HMENU)LeakDiag_AddHandle(LoadMenuA(a1, a2), __FILE__, __LINE__))
#define LoadMenuW(a1, a2)     ((HMENU)LeakDiag_AddHandle(LoadMenuW(a1, a2), __FILE__, __LINE__))
#define LoadMenuIndirectA(a1) ((HMENU)LeakDiag_AddHandle(LoadMenuIndirectA(a1), __FILE__, __LINE__))
#define LoadMenuIndirectW(a1) ((HMENU)LeakDiag_AddHandle(LoadMenuIndirectW(a1), __FILE__, __LINE__))
//#define CreateMenu           LeakDiag_CreateMenu
//#define CreatePopupMenu      LeakDiag_CreatePopupMenu
#define DestroyMenu(h)        DestroyMenu((HMENU)LeakDiag_RemoveHandle(h))

// Colorspace
#define CreateColorSpaceA(a1)   ((HCOLORSPACE)LeakDiag_AddHandle(CreateColorSpaceA(a1), __FILE__, __LINE__))
#define CreateColorSpaceW(a1)   ((HCOLORSPACE)LeakDiag_AddHandle(CreateColorSpaceW(a1), __FILE__, __LINE__))
#define DeleteColorSpace(h)     DeleteColorSpace((HCOLORSPACE)LeakDiag_RemoveHandle(h))

// Regions
#define CreateEllipticRgn(a1, a2, a3, a4)           ((HRGN)LeakDiag_AddHandle(CreateEllipticRgn(a1, a2, a3, a4), __FILE__, __LINE__))
#define CreateEllipticRgnIndirect(a1)               ((HRGN)LeakDiag_AddHandle(CreateEllipticRgnIndirect(a1), __FILE__, __LINE__))
#define CreatePolygonRgn(a1, a2, a3)                ((HRGN)LeakDiag_AddHandle(CreatePolygonRgn(a1, a2, a3), __FILE__, __LINE__))
#define CreatePolyPolygonRgn(a1, a2, a3, a4)        ((HRGN)LeakDiag_AddHandle(CreatePolyPolygonRgn(a1, a2, a3, a4), __FILE__, __LINE__))
#define CreateRectRgn(a1, a2, a3, a4)               ((HRGN)LeakDiag_AddHandle(CreateRectRgn(a1, a2, a3, a4), __FILE__, __LINE__))
#define CreateRectRgnIndirect(a1)                   ((HRGN)LeakDiag_AddHandle(CreateRectRgnIndirect(a1), __FILE__, __LINE__))
#define CreateRoundRectRgn(a1, a2, a3, a4, a5, a6)  ((HRGN)LeakDiag_AddHandle(CreateRoundRectRgn(a1, a2, a3, a4, a5, a6), __FILE__, __LINE__))
#define ExtCreateRegion(a1, a2, a3)                 ((HRGN)LeakDiag_AddHandle(ExtCreateRegion(a1, a2, a3), __FILE__, __LINE__))
#define SetWindowRgn(hWnd, hRgn, bRedraw)           SetWindowRgn(hWnd, (HRGN)LeakDiag_RemoveHandle(hRgn), bRedraw)

// ImageList
#define ImageList_LoadImageA(a1, a2, a3, a4, a5, a6, a7)    ((HIMAGELIST)LeakDiag_AddHandle(ImageList_LoadImageA(a1, a2, a3, a4, a5, a6, a7), __FILE__, __LINE__))
#define ImageList_LoadImageW(a1, a2, a3, a4, a5, a6, a7)    ((HIMAGELIST)LeakDiag_AddHandle(ImageList_LoadImageW(a1, a2, a3, a4, a5, a6, a7), __FILE__, __LINE__))
#define ImageList_LoadBitmapA(a1, a2, a3, a4, a5)           ((HIMAGELIST)LeakDiag_AddHandle(ImageList_LoadBitmapA(a1, a2, a3, a4, a5), __FILE__, __LINE__))
#define ImageList_LoadBitmapW(a1, a2, a3, a4, a5)           ((HIMAGELIST)LeakDiag_AddHandle(ImageList_LoadBitmapW(a1, a2, a3, a4, a5), __FILE__, __LINE__))
#define ImageList_Merge(a1, a2, a3, a4, a5, a6)             ((HIMAGELIST)LeakDiag_AddHandle(ImageList_Merge(a1, a2, a3, a4, a5, a6), __FILE__, __LINE__))
#define ImageList_Read(a1)                                  ((HIMAGELIST)LeakDiag_AddHandle(ImageList_Read(a1), __FILE__, __LINE__))
#define ImageList_Duplicate(a1)                             ((HIMAGELIST)LeakDiag_AddHandle(ImageList_Duplicate(a1), __FILE__, __LINE__))
#define ImageList_Create(a1, a2, a3, a4, a5)                ((HIMAGELIST)LeakDiag_AddHandle(ImageList_Create(a1, a2, a3, a4, a5), __FILE__, __LINE__))
#define ImageList_Destroy(h)                                ImageList_Destroy((HIMAGELIST)LeakDiag_RemoveHandle(h))

#endif // __cplusplus

#endif // _LEAKDIAG_IMPL

#endif // LEAKDIAG_NO_REDEFINITION
#else

// release

inline HANDLE LeakDiag_RemoveHandle(HANDLE hObj) { return hObj; }
inline void LeakDiag_SetMode(DWORD) {}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\ocundoid.h ===
//----------------------------------------------------------------------------
//
//  Microsoft IStudio
//
//  Microsoft Confidential
//  Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
//  File:	ocundoid.h
//
//  Contents:
//		OleUndoManager GUIDs
//----------------------------------------------------------------------------
#ifndef _OCUNDOID_H
#define _OCUNDOID_H

// {C964830F-91A0-11D0-B14C-0000F8041356}
DEFINE_GUID(CLSID_OleUndoManager,
	0xC964830F,0x91A0,0x11D0,0xB1,0x4C,0x00,0x00,0xF8,0x04,0x13,0x56);

#endif //_OCUNDOID_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\multi.h ===
#include <multimon.h>

// A few more API to simply getting Montiro info when the HMONITOR is not needed by the caller
extern BOOL WINAPI MonitorInfoFromWindow(HWND,    LPMONITORINFO, UINT);
extern BOOL WINAPI MonitorInfoFromRect  (LPCRECT, LPMONITORINFO, UINT);
extern BOOL WINAPI MonitorInfoFromPoint (POINT,   LPMONITORINFO, UINT);

// The following functions are from MSDN and are helpers for centering 
// rects and windows.
#define MONITOR_CENTER   0x0001        // center rect to monitor
#define MONITOR_CLIP     0x0000        // clip rect to monitor
#define MONITOR_WORKAREA 0x0002        // use monitor work area
#define MONITOR_AREA     0x0000        // use monitor entire area

extern void WINAPI ClipOrCenterRectToMonitor(LPRECT prc, UINT flags);
extern void WINAPI ClipOrCenterWindowToMonitor(HWND hwnd, UINT flags);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\OMGlyphs.h ===
////////////////////////////////////////////////////////////////////////////////
// OMGlyphs.H
//
// This file defines indexes into the imagelist OMStdBmps.bmp

#pragma once

#define OM_GLYPH_NONE                 -1
#define OM_GLYPH_UNKNOWN              -1

// Images are determined by an OM_GLYPH_* + OM_GLYPH_ACC_* value.  There are OM_GLYPH_ACC_TYPE_COUNT versions of each image.
#define OM_GLYPH_ACC_TYPE_COUNT      6

#define OM_GLYPH_CLASS               (OM_GLYPH_ACC_TYPE_COUNT * 0)
#define OM_GLYPH_CONSTANT            (OM_GLYPH_ACC_TYPE_COUNT * 1)
#define OM_GLYPH_DELEGATE            (OM_GLYPH_ACC_TYPE_COUNT * 2)
#define OM_GLYPH_ENUM                (OM_GLYPH_ACC_TYPE_COUNT * 3)
#define OM_GLYPH_ENUMMEMBER          (OM_GLYPH_ACC_TYPE_COUNT * 4)
#define OM_GLYPH_EVENT               (OM_GLYPH_ACC_TYPE_COUNT * 5)
#define OM_GLYPH_EXCEPTION           (OM_GLYPH_ACC_TYPE_COUNT * 6)
#define OM_GLYPH_FIELD               (OM_GLYPH_ACC_TYPE_COUNT * 7)
#define OM_GLYPH_INTERFACE           (OM_GLYPH_ACC_TYPE_COUNT * 8)
#define OM_GLYPH_MACRO               (OM_GLYPH_ACC_TYPE_COUNT * 9)
#define OM_GLYPH_MAP                 (OM_GLYPH_ACC_TYPE_COUNT * 10)
#define OM_GLYPH_MAPITEM             (OM_GLYPH_ACC_TYPE_COUNT * 11)
#define OM_GLYPH_METHOD              (OM_GLYPH_ACC_TYPE_COUNT * 12)
#define OM_GLYPH_OVERLOAD            (OM_GLYPH_ACC_TYPE_COUNT * 13)
#define OM_GLYPH_MODULE              (OM_GLYPH_ACC_TYPE_COUNT * 14)
#define OM_GLYPH_NAMESPACE           (OM_GLYPH_ACC_TYPE_COUNT * 15)
#define OM_GLYPH_OPERATOR            (OM_GLYPH_ACC_TYPE_COUNT * 16)
#define OM_GLYPH_PROPERTY            (OM_GLYPH_ACC_TYPE_COUNT * 17)
#define OM_GLYPH_STRUCT              (OM_GLYPH_ACC_TYPE_COUNT * 18)
#define OM_GLYPH_TEMPLATE            (OM_GLYPH_ACC_TYPE_COUNT * 19)
#define OM_GLYPH_TYPEDEF             (OM_GLYPH_ACC_TYPE_COUNT * 20)
#define OM_GLYPH_TYPE                (OM_GLYPH_ACC_TYPE_COUNT * 21)
#define OM_GLYPH_UNION               (OM_GLYPH_ACC_TYPE_COUNT * 22)
#define OM_GLYPH_VARIABLE            (OM_GLYPH_ACC_TYPE_COUNT * 23)
#define OM_GLYPH_VALUETYPE           (OM_GLYPH_ACC_TYPE_COUNT * 24)
#define OM_GLYPH_INTRINSIC           (OM_GLYPH_ACC_TYPE_COUNT * 25)

#define OM_GLYPH_ERROR               (OM_GLYPH_ACC_TYPE_COUNT * 26)       // Error glyph (NOTE:  Do not add OM_GLYPH_ACC_ to this!!!)
#define OM_GLYPH_ASSEMBLY	     (OM_GLYPH_ERROR + 6)
#define OM_GLYPH_LIBRARY             (OM_GLYPH_ERROR + 7)
#define OM_GLYPH_VBPROJECT           (OM_GLYPH_ERROR + 8)
#define OM_GLYPH_COOLPROJECT         (OM_GLYPH_ERROR + 10)
#define OM_GLYPH_OPEN_FOLDER         (OM_GLYPH_ERROR + 15)
#define OM_GLYPH_CLOSED_FOLDER       (OM_GLYPH_ERROR + 16)
#define OM_GLYPH_ARROW               (OM_GLYPH_ERROR + 17)

#define OM_GLYPH_ACC_PUBLIC          0
#define OM_GLYPH_ACC_INTERNAL        1
#define OM_GLYPH_ACC_FRIEND          2
#define OM_GLYPH_ACC_PROTECTED       3
#define OM_GLYPH_ACC_PRIVATE         4
#define OM_GLYPH_ACC_SHORTCUT        5

#define OM_GLYPH_IMGLIST_WIDTH           16
#define OM_GLYPH_IMGLIST_BACKGROUND      0x0000ff00

// Given a current glyph, returns its base glyph type. If given a glyph outside
// the range of those with different access classes, it return OM_GLYPH_UNKNOWN.
#define OM_GLYPH_GET_BASE_GLYPH(x) (((x)<OM_GLYPH_ERROR)?(x) - ((x)%OM_GLYPH_ACC_TYPE_COUNT):OM_GLYPH_UNKNOWN)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\mempool.h ===
////////////////////////////////////////////////////////////////////////////////
// MEMPOOL.H
//
// Copyright (c) 1996-1997, Microsoft Corporation.   All Rights Reserved.
// Information Contained Herein Is Proprietary and Confidential.
////////////////////////////////////////////////////////////////////////////////

#pragma once

////////////////////////////////////////////////////////////////////////////////
// CMemPool

class CMemPool
{
private:

    enum
    {
        DEF_BLOCKS_IN_POOL  = 256
    };

    ////////////////////////////////////////////////////////////////////////////
    // CPool

    class CPool
    {
    public:
        CPool       *m_pPrev;       // Previous pool
        long        m_iBlocksLeft;  // Number of blocks this pool has left to allocate (first time)
        BYTE        *m_pNextBlock;  // Next available block in the pool (first time)
    };

    ////////////////////////////////////////////////////////////////////////////
    // CFree

    class CFree
    {
    public:
        CFree       *m_pPrev;       // Previous free block
    };

    CRITICAL_SECTION    m_cs;

    long    m_iBlockSize;       // Size of blocks
    long    m_iBlocksInPool;    // Number of blocks a pool will hold
    CPool   *m_pCurPool;        // Topmost pool
    CFree   *m_pFreeList;       // Free block chain

public:
    CMemPool (long iBlockSize, long iBlocksInPool = DEF_BLOCKS_IN_POOL) :
        m_iBlockSize(iBlockSize),
        m_pCurPool(NULL),
        m_iBlocksInPool(iBlocksInPool),
        m_pFreeList(NULL)
    {
        ASSERT (iBlockSize >= sizeof (CFree *));
        InitializeCriticalSection (&m_cs);
    }
    ~CMemPool ();

    void    *Allocate ();
    void    Free (void *p);
    long    BlockSize () { return m_iBlockSize; }
};

////////////////////////////////////////////////////////////////////////////////
// HELPFUL MACROS:  If you have a class type that you want allocated from a
// memory pool, use these macros:
//
//  DECLARE_MEMORY_POOL()       Put this in your class definition to declare an
//                              overloaded new/delete pair and a pool for your
//                              class.  You MUST UNDEFINE 'new' before this line,
//                              and #define it back to 'vs_new' afterward!
//
//  DEFINE_MEMORY_POOL(class)   Put this in a module to define and construct the
//                              memory pool for the class
////////////////////////////////////////////////////////////////////////////////

#define DECLARE_MEMORY_POOL()\
    static  CMemPool    _m_alloc; \
    DECLARE_CLASS_NEW(dwSize) { ASSERT (dwSize == (UINT)_m_alloc.BlockSize()); return _m_alloc.Allocate (); } \
    void    operator delete (PVOID pv) { _m_alloc.Free (pv); }
	
#define DEFINE_MEMORY_POOL(c) CMemPool  c::_m_alloc(sizeof(c));
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\OutputGroupNames.h ===
//-----------------------------------------------------------------------------
// Microsoft Visual Basic Deployment Editors
//
// Microsoft Confidential
// Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.
//
// @doc
// @module OutputGroupNames.h
//
//	These are the canonical names for output groups which we will be using
//  in Visual Studio.  Canonical names must not be localized!  Using these
//  canonical names allows projects to ask for specific types of outputs.
//
//  Users do not see these canonical names -- they see the display names
//  and description fields instead -- so you can still "localize" your output
//  groups visually as required.
//
// @owner MattGe
//-----------------------------------------------------------------------------

#pragma once

// This info has been moved to vssolutn.idl.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\regex.h ===
// regex.h - Regular expression parser/engine
//--------------------------------------------------------------------------
// Copyright (c) 1988 - 1999, Microsoft Corp. All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//--------------------------------------------------------------------------
#pragma once

//#define SUPPORT_WILDCARD    // implement wildcard operator ?
//#define SUPPORT_CARET       // implement caret operator \c
//#define SUPPORT_WORDBREAK   // implement wordbreak operator %
#define SUPPORT_PROPS       // implement Unicode properties

enum __RE_COMPILEFLAGS {
    REC_REGEX           = 0x00000001,       // Full VS regex syntax
    REC_WILDCARD        = 0x00000002,       // VB Wildcard matching
    REC_MATCHCASE       = 0x00000010,       // Match exact case (case-sensitive)
    REC_WHOLEWORD       = 0x00000020        // Match whole words
};
typedef DWORD RE_COMPILEFLAGS;

enum __RE_FINDFLAGS {
    REF_LINESTART       = 0x00000001,       // Buffer starts at line boundary
    REF_LINEEND         = 0x00000002,       // Buffer ends at line boundary
    REF_TRYMATCH        = 0x00010000,       // Match only at the start position (otherwise seeks)
    REF_REVERSE         = 0x00020000        // Scan buffer in reverse
};
typedef DWORD RE_FINDFLAGS;

enum __RE_MATCHINFO {
    REMI_FOUND          = 0x00000001,       // Found!
    REMI_LINESTART      = 0x00000002,       // Matched start of line (^)
    REMI_LINEEND        = 0x00000004,       // Matched end of line ($)
    REMI_TAGS           = 0x00000008,       // Tagged results available
    REMI_ENDOFBUFFER    = 0x00000010        // Scanned to end of buffer
};
typedef DWORD RE_MATCHINFO;

typedef struct __RE_TEXTRANGE
{
    LONG    iStart;
    LONG    iLength;
} RE_TEXTRANGE, * PRE_TEXTRANGE;

//----------------------------------------------------------------
// Regex HRESULTS
//
// This must be kept in sync with VS textfind.idl.
//
#ifndef __RE_E_DEFINED__ // Don't collide with textfind.h if it's being used
#define __RE_E_DEFINED__
//                     Failure  |  Facility            | Code
#define RE_ERROR(x) (0x80000000 | (FACILITY_ITF << 16) | (x))

enum RE_ERRORS {
  RE_E_INTERNALERROR          = RE_ERROR(0x0001), // internal error (e.g. undefined opcode)
  RE_E_SYNTAXERROR            = RE_ERROR(0x0002), // syntax error in expression    
  RE_E_STACKOVERFLOW          = RE_ERROR(0x0003), // evaluation stack overflow
  RE_E_MISSINGARG             = RE_ERROR(0x0004), // missing argument in syntax
  RE_E_POWERARGOUTOFRANGE     = RE_ERROR(0x0005), // ^n power closure argument out of range
  RE_E_ESCAPEMISSINGARG       = RE_ERROR(0x0006), // \ or \x or \u missing valid argument
  RE_E_SPECIALUNKNOWN         = RE_ERROR(0x0007), // :x unknown x
  RE_E_TAGOUTOFRANGE          = RE_ERROR(0x0008), // \n n out of range
  RE_E_SETMISSINGCLOSE        = RE_ERROR(0x0009), // [] missing ]
  RE_E_TAGMISSINGCLOSE        = RE_ERROR(0x000a), // {} missing }
  RE_E_TOOMANYTAGS            = RE_ERROR(0x000b), // {} too many tagged expressions
  RE_E_EMPTYSET               = RE_ERROR(0x000c), // [] Empty set 
  RE_E_GROUPMISSINGCLOSE      = RE_ERROR(0x000d), // () missing ) 
  RE_E_REPLACETEXT            = RE_ERROR(0x000e), // Unable to create replacement text
};

#undef RE_ERROR
#endif // __RE_E_DEFINED__

// limits for ^n power closure
// Although 1 is redundant, we allow it to avoid generating overly pedantic errors.
// (exp)^1 matches the same thing as (exp).
#define MIN_POWER   1
#define MAX_POWER   256

//----------------------------------------------------------------
// RE_ScanChar - Scan a char, possibly expressed in the RE literal char syntax
//
PCWSTR WINAPI RE_ScanChar (PCWSTR pSrc, PWSTR * ppDst);

//----------------------------------------------------------------
// RE_Free - Free storage (ctx, stack)
//
void WINAPI RE_Free (void * pv);

//----------------------------------------------------------------
// RE_Compile - compile a pattern
//
HRESULT WINAPI RE_Compile (
    /*[in]*/    RE_COMPILEFLAGS flags,        // RE_COMPILEFLAGS options
    /*[in]*/    PCWSTR          pszPattern,   // Text Pattern
    /*[out]*/   void **         ppvCtx        // Context for RE_Search - Must be RE_Free()'d.
    );

//----------------------------------------------------------------
// RE_Find - Search text using compiled pattern
//
// You must free the compiled pattern and stack using RE_Free.
// ppvStack should initially point at NULL.
//
HRESULT WINAPI RE_Find (
    /*[in]*/        RE_FINDFLAGS    flags,         // Search options
    /*[in]*/        PCWSTR          pchText,       // Text to search
    /*[in]*/        LONG            cchText,       // Length (-1 == NULL-terminated)
    /*[in]*/        PCWSTR          pchStart,      // Point within Text to start matching.
                                                   // if NULL, starts at the edge of the buffer
    /*[in,out]*/    void *          pvCtx,         // Previously compiled pattern
    /*[in,out]*/    void **         ppvStack,      // Evaluation stack (initially NULL, must be RE_Free()'d.)

    /*[out]*/       LONG *          pcchMatch,     // Length of match
    /*[out]*/       PCWSTR *        ppchMatch,     // Matched text in pchText
    /*[out,retval]*/RE_MATCHINFO *  pMatchInfo     // RE_MATCHINFO - Info about match
    );

//----------------------------------------------------------------
// RE_TagCount - Get count of tagged items in match
//
HRESULT WINAPI RE_TagCount (
    /*[in] */ void * pvCtx, 
    /*[out]*/ LONG * pcTags
    );

//----------------------------------------------------------------
// RE_GetTags - Get array of text ranges for tagged items in match
//
// The first element is always the same as the match returned by RE_Find.
//
HRESULT WINAPI RE_GetTags (
    /*[in]*/        void            * pvCtx,    // Previously matched pattern
    /*[in]*/        LONG              cTags,    // Count of elements in prgTags
    /*[in,out]*/    PRE_TEXTRANGE     prgTags   // Array of ranges
    );

//----------------------------------------------------------------
// RE_*Translate - evaluate RE replace syntax
//----------------------------------------------------------------

enum __RE_TRANSLATEFLAGS
{
    // Use empty replacements for unmatched or out-of-range tag refs.
    // If not set, then unmatched or out-of-range tag refs generate an error.
    RETF_EMPTYTAGS          = 0x00000001    
};
typedef DWORD RE_TRANSLATEFLAGS;

//----------------------------------------------------------------
// This base class and Translate functions are used when the ranges 
// of a tagged match are translated to another coordinate space and
// text image. The VS environment uses these.
//
class __declspec(novtable) RE_TranslateHelper
{
public:

  // Return length of tagged item iSegment, from 0-9
  // Return -1 if iSegment is out of range.
  virtual LONG  SegmentLength (LONG iSegment); 

  // Copy the text of the tagged item iSegment into pDst.
  // Return a pointer to the next character after the end of the copied text.
  virtual PWSTR CopySegment   (LONG iSegment, PWSTR pDst);
};

HRESULT WINAPI RE_THTranslateSize   (RE_TranslateHelper *pth, RE_TRANSLATEFLAGS flags, PCWSTR pszPattern, LONG *pcch);
HRESULT WINAPI RE_THTranslateBuffer (RE_TranslateHelper *pth, RE_TRANSLATEFLAGS flags, PCWSTR pszPattern, PWSTR pszResult);
HRESULT WINAPI RE_THTranslate       (RE_TranslateHelper *pth, RE_TRANSLATEFLAGS flags, PCWSTR pszPattern, BSTR * pbstrResult);

//----------------------------------------------------------------
// RE_Translate - calculate the size required to evaluate the pattern.
//
// RETURNS: length of replacement pattern, or -1 if error
//
HRESULT WINAPI RE_TranslateSize (void *pvCtx, RE_TRANSLATEFLAGS flags, PCWSTR pszPattern, LONG *pcch);

//----------------------------------------------------------------
// RE_Translate - Generate translated text for replacement syntax.
//
HRESULT WINAPI RE_TranslateBuffer (void *pvCtx, RE_TRANSLATEFLAGS flags, PCWSTR pszPattern, PWSTR pszResult);
HRESULT WINAPI RE_Translate       (void *pvCtx, RE_TRANSLATEFLAGS flags, PCWSTR pszPattern, BSTR * pbstrResult);

#ifdef SUPPORT_CARET
//----------------------------------------------------------------
// RE_CaretPos - Get caret position (\c) from matched RE (if any) 
//
HRESULT WINAPI RE_GetCaretPos (void *pvCtx, PCWSTR * ppchCaret);
#endif

//----------------------------------------------------------------
// RE_Status - Get HRESULT of previous compilation
//
HRESULT WINAPI RE_Status (void *pvCtx, HRESULT * phr);

enum __RE_FEATURES 
{
    REF_Any                 = 0x00000001,   // .
    REF_Closure             = 0x00000002,   // *
    REF_Closure1            = 0x00000004,   // +
    REF_MinClosure          = 0x00000008,   // @
    REF_MinClosure1         = 0x00000010,   // #
    REF_AnchorStartOfLine   = 0x00000020,   // ^
    REF_AnchorEndOfLine     = 0x00000040,   // $
    REF_OR                  = 0x00000080,   // |
    REF_Group               = 0x00000100,   // (expr)
    REF_Tag                 = 0x00000200,   // {expr}
    REF_PreviousTag         = 0x00000400,   // \#
    REF_Power               = 0x00000800,   // (expr)^n
    REF_Set                 = 0x00001000,   // [...]
    REF_NotSet              = 0x00002000,   // [^...]
    REF_Fail                = 0x00004000,   // ~(expr)
    REF_LineBreak           = 0x00008000,   // \n
    REF_Escape              = 0x00010000,   // \\, \t, etc.
    REF_Hex                 = 0x00020000,   // \u####, \x####
    REF_WordStart           = 0x00040000,   // <
    REF_WordEnd             = 0x00080000,   // >
    REF_WordBreak           = 0x00100000,   // % NOT IMPLEMENTED
    REF_Shorthand           = 0x00200000,   // :x
    REF_Property            = 0x00400000,   // :Xx
    REF_Wildcard            = 0x00800000,   // ? NOT IMPLEMENTED
    REF_Caret               = 0x01000000    // \c NOT IMPLEMENTED
};
typedef DWORD RE_FEATURES;

HRESULT WINAPI RE_AnalyseFeatures (PCWSTR pszPattern, RE_FEATURES * pREF);

// Replace features are only REF_Escape REF_Hex REF_Tag
HRESULT WINAPI RE_AnalyseReplaceFeatures (PCWSTR pszPattern, RE_FEATURES * pREF);

#if 0
enum __WC_FEATURES
{
    WCF_Any      = 0x00000001,   // ?
    WCF_Some     = 0x00000002,   // *
    WCF_Digit    = 0x00000004,   // #
    WCF_Set      = 0x00000008,   // [...]
    WCF_NotSet   = 0x00000010    // [!...]
};
typedef DWORD WC_FEATURES;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\RegistryLocations.h ===
// String values representing registry key locations. Most are relative strings, and are expected to 
// be appended to root key strings from other locations, if not here. - mweddle

#define SZ_REGISTRATION       "Registration"
#define LSZ_REGISTRATION      L"Registration"
#define SZ_PRODUCTID          "ProductID"
#define LSZ_PRODUCTID         L"ProductID"
#define SZ_USERNAME           "UserName"
#define SZ_ORGANIZATION       "RegisteredOrganization"
#define SZ_REGLOC_LVCERT      "LVCertificate"
#define SZ_REGLOC_INSTALLDIR  "InstallDir"
#define LSZ_REGLOC_INSTALLDIR L"InstallDir"

// Although this is not distinctly a registry location, it probably should be, or else a better
// method of acquiring the application name should be used. This is intended to be a temporary measure.
#define SZ_VS_APPNAME         "Visual Studio"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\regutil.h ===
////////////////////////////////////////////////////////////////////////////////
// regutil.h

extern long RegDeleteSubKeys(HKEY, LPCSTR);

//---------------------------------------------------------------------------
// contruct strings to be used in _ATL_REGMAP_ENTRY for the app reg root
//---------------------------------------------------------------------------
HRESULT util_GetRegRootStrings(LPCOLESTR pszRegistrationRoot, BSTR * pbstrRootBegin, BSTR * pbstrRootEnd);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\ResLibInst.h ===
#pragma once

#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))
#endif // !defined(NUMBER_OF)

typedef BOOL (* PFN_GUILFN_LCID_CHECK)(LPARAM lParam, LCID lcid);

HRESULT W_GetUILibraryFileName
(
  LCID                  lcidDefault,    // can be 0
  LPCOLESTR             pszPath,
  LPCOLESTR             pszDllName,
  PFN_GUILFN_LCID_CHECK pfnCheckLCID,   // can be null
  LPARAM                lParam,
  BSTR                * pbstrFullPath,  // can be null
  LCID	              * plcidOut        // can be null
);

/*
HRESULT W_LoadPackageUILibrary(
  LPCOLESTR             pszRegRoot, 
  REFGUID               guidPackage, 
  DWORD                 dwExFlags, 
  PFN_GUILFN_LCID_CHECK pfnCheckLCID,   // can be null
  LPARAM                lParam,
  HINSTANCE           * phinstOut, 
  BSTR                * pbstrFullPath = NULL, 
  LCID                * plcidOut = NULL, 
  BOOL                  fUnloadCurrentLib = FALSE);
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\regexp.h ===
// regexp.h
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// June 1, 1998 [paulde] revised for Unicode lib
//

#pragma once
#ifndef __REGEXP_H__
#define __REGEXP_H__

#define MAXPATARG   10          // 0 is entire 1-9 are valid

typedef unsigned char RE_OPCODE;

// compiled pattern
typedef struct {
    BOOL        fCase;              // TRUE => case is significant
    int         RESize;             // Estimated size
    RE_OPCODE * REip;               // Instruction pointer
    UINT        cArg;               // Total groups matched
    int         REArg;              // Current group
    WCHAR     * pArgBeg[MAXPATARG]; // Beginning of tagged strings
    WCHAR     * pArgEnd[MAXPATARG]; // End of tagged strings
    RE_OPCODE   code[1];            // Pseudo-code instructions
} REPattern;

// *ppat should be null when called
// free after use with REFree
HRESULT WINAPI RECompile     (WCHAR * p, BOOL fCase, REPattern ** ppat);
HRESULT WINAPI SimpleCompile (WCHAR * p, BOOL fCase, REPattern ** ppat);

BOOL WINAPI RESearch(
    PCWSTR        buf,
    ULONG_PTR     * ichStart,         // WCHAR index into buf where to start
    BOOL          fForward,         // TRUE if forward search, FALSE if backward
    BOOL          fLineStart,       // TRUE if buf starts at the start of a line
    BOOL          fLineEnd,         // TRUE if buf ends at the end of a line
    REPattern   * pat,              // compiled pattern
    PCWSTR        szString,         // pointer to regular expression
    RE_OPCODE *** pREStack,         // stack  -- should point to NULL first call, REFree when done with all calls
    ULONG       * pcREStackEntries, // stack size
    ULONG_PTR   * xEnd,             // out
    BOOL        * pfMatchLineStart, // out
    BOOL        * pfMatchLineEnd    // out
    );

HRESULT WINAPI RETranslate(REPattern *, WCHAR *, BSTR *);

// get length required to hold resulting translation
int WINAPI RETranslateLength (REPattern * pat, PWSTR src);

void WINAPI REFree (void * pv);

#endif  // __REGEXP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\sccmnid.h ===
/*-------------------------------------------------------------------------------
Microsoft Visual Studio Enterprise Edition

Namespace: None
Subsystem: Visual Studio Source Code Control
Copyright: (c) 1997-2000, Microsoft Corporation
           All Rights Reserved

@doc	internal

@module sccmnid.h - SCC Package Menu IDs |

@owner	MartynL

Information Contained Herein Is Proprietary and Confidential.
-------------------------------------------------------------------------------*/

// Can't use pragma once here, as this passes through ctc
#ifndef SccMnID_H_Included
#define SccMnID_H_Included

// Note that we have code that depends on the adjacency of the context and non-context
// versions of the commands, and also upon the odd/even dichotomy

#define icmdFlagContext							1

#define icmdSccAdd								21000
#define icmdSccContextAdd						21001	// (icmdSccAdd+icmdFlagContext)
#define icmdSccCheckout							21002
#define icmdSccContextCheckout					21003	// (icmdSccCheckout+icmdFlagContext)
#define icmdSccCheckoutShared					21004
#define icmdSccContextCheckoutShared			21005	// (icmdSccCheckoutShared+icmdFlagContext)
#define icmdSccCheckoutExclusive				21006
#define icmdSccContextCheckoutExclusive			21007	// (icmdSccCheckoutExclusive+icmdFlagContext)
#define icmdSccUndoCheckout						21008
#define icmdSccContextUndoCheckout				21009	// (icmdSccUndoCheckout+icmdFlagContext)
#define icmdSccGetLatestVersion					21010	
#define icmdSccContextGetLatestVersion			21011	// (icmdSccGetLatestVersion+icmdFlagContext)	
#define icmdSccShowNonEmptyCheckinWindow		21012
#define icmdSccContextShowNonEmptyCheckinWindow	21013	// (icmdSccShowNonEmptyCheckinWindow+icmdFlagContext)
#define icmdSccCheckin							21014
#define icmdSccContextCheckin					21015	// (icmdSccCheckin+icmdFlagContext)

// The order for the "Add" commands are important because they are used as a range
#define icmdSccAddSolution						21016	
#define icmdSccContextAddSolution				21017	// (icmdSccAddSolution + icmdFlagContext)
#define icmdSccAddSelection						21018	
#define icmdSccContextAddSelection				21019	// (icmdSccAddSelection + icmdFlagContext)

#define icmdSccGetVersion						21500
#define icmdSccShowCheckinWindow				21502
#define icmdSccProperties						21504
#define icmdSccDiff								21506
#define icmdSccHistory							21508
#define icmdSccShare							21510
#define icmdSccRemove							21512
#define icmdSccAdmin							21514
#define icmdSccRefreshStatus					21516
#define icmdSccRename							21518
#define icmdSccSetLocation						21520

#define icmdSccOpenFromSourceControlSingleProvider			21522	// Open with a single versioning provider
#define icmdSccAddSelectionWithSolution						21524	// "Virtual provider" - the same provider as the current solution has
#define icmdSccShowConnectionManager						21526

#define icmdSccOpenFromSourceControlMSSCCIProvider			21528	// Open using MSSCCI ptovider (if available)
#define icmdSccAddSolutionToSourceControlMSSCCIProvider		21530	// Always adds to SC using MSSCCI ptovider (if available)
#define icmdSccAddSelectionToSourceControlMSSCCIProvider	21532	// Always adds to SC using MSSCCI ptovider (if available)
#define icmdSccAddFromSourceControlMSSCCIProvider			21534	// AddFromSC using MSSCCI provider (if available)
#define icmdSccAddFromSourceControlSingleProvider			21536	// AddFromSC with a single versioning provider

#define igrpSccMainAdd										22000	// IDG_SCC_ADD 28
#define	igrpSccMainCommands									22001	
#define	igrpSccMainAction									22002	// IDG_SCC_MAIN 26
#define	igrpSccMainSecondary								22003	// IDG_SCC_MAIN2 30
#define	igrpSccMainAdmin									22004	// IDG_SCC_MAIN3 31
#define	igrpSccCommands										22005	// IDG_SCC_SUBMENU 29
#define	igrpSccEditorContext								22006	// IDG_SCC_CTXT_EDIT 32
#define igrpSccOpenFromSourceControl						22007
#define igrpSccOpenFromSourceControlProviders				22008
#define igrpSccAddSolutionToSourceControlProviders			22009
#define igrpSccAddSelectionToSourceControlProviders			22010

#define igrpSccSccAddSelectionWithSolution					22011
#define igrpSccOpenFromSourceControlMSSCCIProvider			22012
#define igrpSccAddSolutionToSourceControlMSSCCIProvider		22013
#define igrpSccAddSelectionToSourceControlMSSCCIProvider	22014
#define igrpSccAddFromSourceControl							22015
#define igrpSccAddFromSourceControlMSSCCIProvider			22016
#define igrpSccAddFromSourceControlProviders				22017
												
#define imnuSccMenu											23000	// IDM_VS_MENU_SCC 18 
#define imnuSccOpenFromSourceControl						23001
#define imnuSccAddSolutionToSourceControl					23002
#define imnuSccAddSelectionToSourceControl					23003
#define imnuSccAddFromSourceControl							23004
												
#define itbrSccToolbar										24000	// IDM_VS_TOOL_SCC 17 

// Open from source control providers command ID's. The ID's have their own GUID space in order not to overlap with others
#define icmdSccOpenFromSourceControlFirstProvider			0x1000		// First provider's ID
#define icmdSccOpenFromSourceControlLastProvider			0xFFFFFFFF	// Last provider's ID

// Add a solution to source control providers command ID's. The ID's have their own GUID space in order not to overlap with others
#define icmdSccAddSolutionToSourceControlFirstProvider		0x1000		// First provider's ID
#define icmdSccAddSolutionToSourceControlLastProvider		0xFFFFFFFF	// Last provider's ID

// Add a selection to source control providers command ID's. The ID's have their own GUID space in order not to overlap with others
#define icmdSccAddSelectionToSourceControlFirstProvider		0x1000		// First provider's ID
#define icmdSccAddSelectionToSourceControlLastProvider		0xFFFFFFFF	// Last provider's ID

// Add from source control operation providers command ID's. The ID's have their own GUID space in order not to overlap with others
#define icmdSccAddFromSourceControlFirstProvider			0x1000		// First provider's ID
#define icmdSccAddFromSourceControlLastProvider				0xFFFFFFFF	// Last provider's ID

// TeamExplorer menu items IDs. The ID's have their own GUID space in order not to overlap with others
#define icmdSccTeamExplorerViewFirst						0x1000		// First opened TeamExplorer's ID
#define icmdSccTeamExplorerViewLast							0xFFFFFFFF	// Last opened TeamExplorer's ID

// VisualComponentManager menu items IDs. The ID's have their own GUID space in order not to overlap with others
#define icmdSccVisualComponentManagerViewFirst				0x1000		// First opened TeamExplorer's ID
#define icmdSccVisualComponentManagerViewLast				0xFFFFFFFF	// Last opened TeamExplorer's ID

#ifdef DEFINE_GUID // presumably compiling code, not ctc.

DEFINE_GUID(guidSccPkg,
0xAA8EB8CD, 0x7A51, 0x11D0, 0x92, 0xC3, 0x00, 0xA0, 0xC9, 0x13, 0x8C, 0x45);

// {53544C4D-C4AD-4998-9808-00935EA47729}
DEFINE_GUID(guidSccOpenFromSourceControl, 
0x53544C4D, 0xc4ad, 0x4998, 0x98, 0x8, 0x0, 0x93, 0x5e, 0xa4, 0x77, 0x29);

// {53544C4D-0E51-4941-83F6-29423FED03EF}
DEFINE_GUID(guidSccAddSolutionToSourceControl, 
0x53544C4D, 0xe51, 0x4941, 0x83, 0xf6, 0x29, 0x42, 0x3f, 0xed, 0x3, 0xef);

// {53544C4D-5DAE-4c96-A292-5057FD62BCC2}
DEFINE_GUID(guidSccAddSelectionToSourceControl, 
0x53544C4D, 0x5dae, 0x4c96, 0xa2, 0x92, 0x50, 0x57, 0xfd, 0x62, 0xbc, 0xc2);

// {53544C4D-7D04-46b0-87D4-35A81DC2FEFC}
DEFINE_GUID(guidSccAddFromSourceControl, 
0x53544C4D, 0x7d04, 0x46b0, 0x87, 0xd4, 0x35, 0xa8, 0x1d, 0xc2, 0xfe, 0xfc);

// {53544C4D-3BF2-4b83-A468-295691EB8609}
DEFINE_GUID(guidSccViewTeamExplorer, 
0x53544C4D, 0x3bf2, 0x4b83, 0xa4, 0x68, 0x29, 0x56, 0x91, 0xeb, 0x86, 0x9);

// {53544C4D-3BF3-4b83-A468-295691EB8609}
DEFINE_GUID(guidSccViewVisualComponentManager, 
0x53544C4D, 0x3bf3, 0x4b83, 0xa4, 0x68, 0x29, 0x56, 0x91, 0xeb, 0x86, 0x9);

#else // ctc

#define guidSccPkg { \
0xAA8EB8CD, 0x7A51, 0x11D0, { 0x92, 0xC3, 0x00, 0xA0, 0xC9, 0x13, 0x8C, 0x45 }}

// {53544C4D-C4AD-4998-9808-00935EA47729}
#define guidSccOpenFromSourceControl { \
0x53544C4D, 0xC4Ad, 0x4998, { 0x98, 0x08, 0x00, 0x93, 0x5E, 0xA4, 0x77, 0x29 }}

// {53544C4D-0E51-4941-83F6-29423FED03EF}
#define guidSccAddSolutionToSourceControl { \
0x53544C4D, 0x0E51, 0x4941, { 0x83, 0xF6, 0x29, 0x42, 0x3F, 0xED, 0x03, 0xEF }}

// {53544C4D-5DAE-4c96-A292-5057FD62BCC2}
#define guidSccAddSelectionToSourceControl { \
0x53544C4D, 0x5DAE, 0x4C96, { 0xA2, 0x92, 0x50, 0x57, 0xFD, 0x62, 0xBC, 0xC2 }}

// {53544C4D-7D04-46b0-87D4-35A81DC2FEFC}
#define guidSccAddFromSourceControl { \
0x53544C4D, 0x7d04, 0x46b0, { 0x87, 0xd4, 0x35, 0xa8, 0x1d, 0xc2, 0xfe, 0xfc }}

// {53544C4D-3BF2-4b83-A468-295691EB8609}
#define guidSccViewTeamExplorer { \
0x53544C4D, 0x3bf2, 0x4b83, { 0xa4, 0x68, 0x29, 0x56, 0x91, 0xeb, 0x86, 0x9	}}

// {53544C4D-3BF3-4b83-A468-295691EB8609}
#define guidSccViewVisualComponentManager { \
0x53544C4D, 0x3bf3, 0x4b83, { 0xa4, 0x68, 0x29, 0x56, 0x91, 0xeb, 0x86, 0x9	}}

#endif // DEFINE_GUID

#endif // #pragma once
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\scc.h ===
//***************************************************************************
// scc.h
//
// This module contains the prototypes and definitions for Microsoft's
// Source Code Control API.  This file and the SCC API are covered by
// Non-Disclosure Agreements (NDA) and are not to be redistributed in any
// for without permission by Microsoft.
//
// This module has been updated to include the following:
//	May '96:	
//	 * The SCC version number has been bumped to 1.1.
//	 * 16-bit is no longer supported.
//	 * A new capability bit, SCC_CAP_REENTRANT, has been added.  A provider
//		which returns this bit can handle multiple SCC context values (eg:
//		multiple simultaneous open projects), and reentrant calls for thos
//		contexts (ie: thread safe).
//   * A new option, SCC_OPT_SCCCHECKOUTONLY has been added. This is used
//      to disallow scc operations from outside of integration.  Integration
//      hosts like MS Access use this to prevent files from being checked out
//      without also being imported into scc.
//
// Copyright (c) Microsoft Corporation 1995-1996, All rights reserved.
//***************************************************************************
#ifndef _SCC_DEFS
#define _SCC_DEFS

#include <stdlib.h>


/****************************************************************************
    Make it easy to export functions
****************************************************************************/
#if !defined( EXTFUN )
#if defined( WIN32 )
#define EXTFUN __declspec(dllexport)
#else
#define EXTFUN __export
#endif
#endif

#if defined( __cplusplus )
#define SCCEXTERNC extern "C"
#else
#define SCCEXTERNC
#endif



/****************************************************************************
    Linkage for external functions will be C naming mode.
****************************************************************************/
#if defined( __cplusplus )
extern "C" {
#endif



/****************************************************************************
    Take care of type information based on platform and settings.
****************************************************************************/
//#if defined( UNICODE )
#include <winnls.h>
//#else
//typedef LPSTR LPTSTR;
//typedef LPCSTR LPCTSTR;
//typedef char TCHAR;
//#endif

#if defined( WIN16 )
typedef BOOL far * LPBOOL;
#endif


/****************************************************************************
    Version Flag.  Major is HIWORD, Minor is LOWORD
****************************************************************************/
#define SCC_MAJOR_VER_VAL   1
#define SCC_MINOR_VER_VAL   1
#define SCC_VER_NUM         MAKELONG(SCC_MINOR_VER_VAL, SCC_MAJOR_VER_VAL)
#define SCC_GET_MAJOR_VER(ver)  HIWORD(ver)
#define SCC_GET_MINOR_VER(ver)  LOWORD(ver)



/****************************************************************************
    Following strings are the keys for accessing the registry to find
    the SCC provider.
****************************************************************************/
#if !defined( _SCC_REG_KEYS )
#define _SCC_REG_KEYS
#define STR_SCC_PROVIDER_REG_LOCATION   "Software\\SourceCodeControlProvider"
#define STR_PROVIDERREGKEY              "ProviderRegKey"
#define STR_SCCPROVIDERPATH             "SCCServerPath"
#define STR_SCCPROVIDERNAME             "SCCServerName"
#define STR_SCC_INI_SECTION             "Source Code Control"
#define STR_SCC_INI_KEY                 "SourceCodeControlProvider"
#define SCC_PROJECTNAME_KEY             "SCC_Project_Name"
#define SCC_PROJECTAUX_KEY              "SCC_Aux_Path"
#define SCC_STATUS_FILE                 "MSSCCPRJ.SCC"
#define SCC_KEY                         "SCC"
#define SCC_FILE_SIGNATURE              "This is a source code control file"
#endif /* _SCC_REG_KEYS */



/****************************************************************************
    String lengths (each length does *not* include the terminating '\0')
****************************************************************************/
#define SCC_NAME_LEN            31      // lpSccName, SCCInitialize
#define SCC_AUXLABEL_LEN        31      // lpAuxPathLabel, SCCInitialize
#define SCC_USER_LEN            31      // lpUser, SCCOpenProject
#define SCC_PRJPATH_LEN         300     // lpAuxProjPath, SCCGetProjPath



/****************************************************************************
    These are the error codes that may be returned from a function.
    All errors are < 0, warnings are > 0, and success is 0.  Use the
    macros provided for quick checking.  
****************************************************************************/
typedef long SCCRTN;
typedef SCCRTN FAR * LPSCCRTN;

#define IS_SCC_ERROR(rtn) (((rtn) < 0) ? TRUE : FALSE)
#define IS_SCC_SUCCESS(rtn) (((rtn) == SCC_OK) ? TRUE : FALSE)
#define IS_SCC_WARNING(rtn) (((rtn) > 0) ? TRUE : FALSE)


#define SCC_I_SHARESUBPROJOK				7
#define SCC_I_FILEDIFFERS						6
#define SCC_I_RELOADFILE						5
#define SCC_I_FILENOTAFFECTED                   4
#define SCC_I_PROJECTCREATED                    3
#define SCC_I_OPERATIONCANCELED                 2
#define SCC_I_ADV_SUPPORT                       1

#define SCC_OK                                  0

#define SCC_E_INITIALIZEFAILED                  -1
#define SCC_E_UNKNOWNPROJECT                    -2
#define SCC_E_COULDNOTCREATEPROJECT             -3
#define SCC_E_NOTCHECKEDOUT                     -4
#define SCC_E_ALREADYCHECKEDOUT                 -5
#define SCC_E_FILEISLOCKED                      -6
#define SCC_E_FILEOUTEXCLUSIVE                  -7
#define SCC_E_ACCESSFAILURE                     -8
#define SCC_E_CHECKINCONFLICT                   -9
#define SCC_E_FILEALREADYEXISTS                 -10
#define SCC_E_FILENOTCONTROLLED                 -11
#define SCC_E_FILEISCHECKEDOUT                  -12
#define SCC_E_NOSPECIFIEDVERSION                -13
#define SCC_E_OPNOTSUPPORTED                    -14
#define SCC_E_NONSPECIFICERROR                  -15
#define SCC_E_OPNOTPERFORMED                    -16
#define SCC_E_TYPENOTSUPPORTED                  -17
#define SCC_E_VERIFYMERGE                       -18
#define SCC_E_FIXMERGE                          -19
#define SCC_E_SHELLFAILURE                      -20
#define SCC_E_INVALIDUSER                       -21
#define SCC_E_PROJECTALREADYOPEN                -22
#define SCC_E_PROJSYNTAXERR                     -23
#define SCC_E_INVALIDFILEPATH                   -24
#define SCC_E_PROJNOTOPEN                       -25
#define SCC_E_NOTAUTHORIZED                     -26
#define SCC_E_FILESYNTAXERR                     -27
#define SCC_E_FILENOTEXIST                      -28
#define SCC_E_CONNECTIONFAILURE					-29



#ifndef _SCC_STATUS_DEFINED
#define _SCC_STATUS_DEFINED
/****************************************************************************
    The SCC_STATUS_xxx macros define the state of a file
****************************************************************************/
enum  SccStatus 
{
    SCC_STATUS_INVALID          = -1L,		// Status could not be obtained, don't rely on it
    SCC_STATUS_NOTCONTROLLED    = 0x0000L,	// File is not under source control
    SCC_STATUS_CONTROLLED       = 0x0001L,	// File is under source code control
    SCC_STATUS_CHECKEDOUT       = 0x0002L,	// Checked out to current user at local path
    SCC_STATUS_OUTOTHER         = 0x0004L,	// File is checked out to another user
    SCC_STATUS_OUTEXCLUSIVE     = 0x0008L,	// File is exclusively check out
    SCC_STATUS_OUTMULTIPLE      = 0x0010L,	// File is checked out to multiple people
    SCC_STATUS_OUTOFDATE        = 0x0020L,	// The file is not the most recent
    SCC_STATUS_DELETED          = 0x0040L,	// File has been deleted from the project
    SCC_STATUS_LOCKED           = 0x0080L,	// No more versions allowed
    SCC_STATUS_MERGED           = 0x0100L,	// File has been merged but not yet fixed/verified
    SCC_STATUS_SHARED           = 0x0200L,	// File is shared between projects
    SCC_STATUS_PINNED           = 0x0400L,	// File is shared to an explicit version
    SCC_STATUS_MODIFIED         = 0x0800L,	// File has been modified/broken/violated
    SCC_STATUS_OUTBYUSER        = 0x1000L,	// File is checked out by current user someplace
    SCC_STATUS_NOMERGE          = 0x2000L,	// File is never mergeable and need not be saved before a GET
    SCC_STATUS_RESERVED_1       = 0x4000L,	// Status bit reserved for internal use
    SCC_STATUS_RESERVED_2       = 0x8000L	// Status bit reserved for internal use
};
#endif /* _SCC_STATUS_DEFINED */




/****************************************************************************
    SccOpenProject flags
****************************************************************************/
#define SCC_OP_CREATEIFNEW      0x00000001L
#define SCC_OP_SILENTOPEN       0x00000002L


/****************************************************************************
    Keep checked out
****************************************************************************/
#define SCC_KEEP_CHECKEDOUT     0x1000


/****************************************************************************
    Add flags
****************************************************************************/
#define SCC_FILETYPE_AUTO       0x00
#define SCC_FILETYPE_TEXT       0x01
#define SCC_FILETYPE_BINARY     0x02
#define SCC_ADD_STORELATEST     0x04


/****************************************************************************
    Diff flags.  The SCC_DIFF_QD_xxx flags are mutually exclusive.  If any
	one of the three are specified, then no visual feed back is to be given.
	If one is specified but not supported, then the next best one is chosen.
****************************************************************************/
#define SCC_DIFF_IGNORECASE     0x0002
#define SCC_DIFF_IGNORESPACE    0x0004
#define SCC_DIFF_QD_CONTENTS	0x0010
#define SCC_DIFF_QD_CHECKSUM	0x0020
#define SCC_DIFF_QD_TIME		0x0040
#define SCC_DIFF_QUICK_DIFF		0x0070		/* Any QD means no display     */


/****************************************************************************
    Get flags
****************************************************************************/
#define SCC_GET_ALL             0x00000001L
#define SCC_GET_RECURSIVE       0x00000002L


/****************************************************************************
    PopulateList flags
****************************************************************************/
#define SCC_PL_DIR				0x00000001L


/****************************************************************************
    Options for SccGetCommandOptions and SccPopulateList
****************************************************************************/
typedef LPVOID LPCMDOPTS;
#ifndef SCCCOMMAND_DEFINED
#define SCCCOMMAND_DEFINED
enum  SCCCOMMAND 
{
	SCC_COMMAND_GET,
	SCC_COMMAND_CHECKOUT,
	SCC_COMMAND_CHECKIN,
	SCC_COMMAND_UNCHECKOUT,
  	SCC_COMMAND_ADD,
	SCC_COMMAND_REMOVE,
	SCC_COMMAND_DIFF,
	SCC_COMMAND_HISTORY,
	SCC_COMMAND_RENAME,
	SCC_COMMAND_PROPERTIES,
	SCC_COMMAND_OPTIONS
};
#endif /* SCCCOMMAND_DEFINED */

typedef BOOL (*POPLISTFUNC)  (LPVOID pvCallerData, BOOL bAddKeep, LONG nStatus, LPCSTR lpFile);
typedef BOOL (*POPLISTFUNCA) (LPVOID pvCallerData, BOOL bAddKeep, LONG nStatus, LPCSTR lpFile);
typedef BOOL (*POPLISTFUNCW) (LPVOID pvCallerData, BOOL bAddKeep, LONG nStatus, LPCWSTR lpFile);
#ifdef UNICODE
typedef POPLISTFUNCW POPLISTFUNCT;
#else
typedef POPLISTFUNCA POPLISTFUNCT;
#endif

/****************************************************************************
    The SCC_CAP_xxx flags are used to determine what capabilites a provider
    has.
****************************************************************************/
#define SCC_CAP_REMOVE            0x00000001L   // Supports the SCC_Remove command
#define SCC_CAP_RENAME            0x00000002L   // Supports the SCC_Rename command
#define SCC_CAP_DIFF              0x00000004L   // Supports the SCC_Diff command
#define SCC_CAP_HISTORY           0x00000008L   // Supports the SCC_History command
#define SCC_CAP_PROPERTIES        0x00000010L   // Supports the SCC_Properties command
#define SCC_CAP_RUNSCC            0x00000020L   // Supports the SCC_RunScc command
#define SCC_CAP_GETCOMMANDOPTIONS 0x00000040L   // Supports the SCC_GetCommandOptions command
#define SCC_CAP_QUERYINFO         0x00000080L   // Supports the SCC_QueryInfo command
#define SCC_CAP_GETEVENTS         0x00000100L   // Supports the SCC_GetEvents command
#define SCC_CAP_GETPROJPATH       0x00000200L   // Supports the SCC_GetProjPath command
#define SCC_CAP_ADDFROMSCC        0x00000400L   // Supports the SCC_AddFromScc command
#define SCC_CAP_COMMENTCHECKOUT   0x00000800L   // Supports a comment on Checkout
#define SCC_CAP_COMMENTCHECKIN    0x00001000L   // Supports a comment on Checkin
#define SCC_CAP_COMMENTADD        0x00002000L   // Supports a comment on Add
#define SCC_CAP_COMMENTREMOVE     0x00004000L   // Supports a comment on Remove
#define SCC_CAP_TEXTOUT           0x00008000L   // Writes text to an IDE-provided output function
#define SCC_CAP_ADD_STORELATEST   0x00200000L   // Supports storing files without deltas
#define SCC_CAP_HISTORY_MULTFILE  0x00400000L   // Multiple file history is supported
#define SCC_CAP_IGNORECASE        0x00800000L   // Supports case insensitive file comparison
#define SCC_CAP_IGNORESPACE       0x01000000L   // Supports file comparison that ignores white space
#define SCC_CAP_POPULATELIST      0x02000000L   // Supports finding extra files
#define SCC_CAP_COMMENTPROJECT    0x04000000L   // Supports comments on create project
#define SCC_CAP_DIFFALWAYS        0x10000000L   // Supports diff in all states if under control
#define SCC_CAP_GET_NOUI          0x20000000L	// Provider doesn't support a UI for SccGet,
												//   but IDE may still call SccGet function.
#define SCC_CAP_REENTRANT		  0x40000000L	// Provider is reentrant and thread safe.

/****************************************************************************
	The following flags are used for the print call-back that the IDE
	provides on SccInitialize.  
	
	If the IDE supports cancel, it may get one of the Cancel messages.
	In this case, the provider will inform the IDE to show the Cancel
	button with SCC_MSG_STARTCANCEL.  After this, any set of normal
	messages may be sent.  If any of these return SCC_MSG_RTN_CANCEL,
	then the provider will quit the operation and return.  The Provider
	will also poll periodically with SCC_MSG_DOCANCEL to see if the
	user has canceled the operation.  When all operations are done, or
	the user has canceled, SCC_MSG_STOPCANCEL will be sent through.

	The SCC_MSG_INFO, WARNING, and ERROR types are used for messages that
	get displayed in the scrolling list of messages.  SCC_MSG_STATUS is
	a special type that indicates that the text should show up in a 
	status bar or temporary display area.  This message type should not
	remain permanently in the list.
****************************************************************************/
enum
{
	// Return codes
	SCC_MSG_RTN_CANCEL=-1,				// Returned from call-back to indicate cancel
	SCC_MSG_RTN_OK=0,					// Returned from call-back to continue
	// Message types
	SCC_MSG_INFO=1,						// Message is informational
	SCC_MSG_WARNING,					// Message is a warning
	SCC_MSG_ERROR,						// Message is an error
	SCC_MSG_STATUS,						// Message is meant for status bar
	// IDE supports Cancel operation
	SCC_MSG_DOCANCEL,					// No text, IDE returns 0 or SCC_MSG_RTN_CANCEL
	SCC_MSG_STARTCANCEL,				// Start a cancel loop
	SCC_MSG_STOPCANCEL					// Stop the cancel loop
};

#ifndef _LPTEXTOUTPROC_DEFINED
#define _LPTEXTOUTPROC_DEFINED
typedef long (*LPTEXTOUTPROC) (LPCSTR, DWORD);
#endif /* _LPTEXTOUTPROC_DEFINED */


/****************************************************************************
    nOption values for SccSetOption.
****************************************************************************/
#define SCC_OPT_EVENTQUEUE      0x00000001L     // Set status of the event queue
#define SCC_OPT_USERDATA        0x00000002L     // Specify user data for 
												//	SCC_OPT_NAMECHANGEPFN
#define SCC_OPT_HASCANCELMODE	0x00000003L		// The IDE can handle Cancel 
												//	of long running operations
#define SCC_OPT_NAMECHANGEPFN   0x00000004L     // Set a callback for name changes
#define SCC_OPT_SCCCHECKOUTONLY 0x00000005L		// Disable SS explorer checkout, 
												//  and don't set working dir
#define SCC_OPT_SHARESUBPROJ 0x00000006L		// Allow destination dir for share


/* SCC_OPT_EVENTQUEUE values */
#define SCC_OPT_EQ_DISABLE      0x00L           // Suspend event queue activity
#define SCC_OPT_EQ_ENABLE       0x01L           // Enable event queue logging

/* SCC_OPT_NAMECHANGEPFN callback typedef */
typedef void (*OPTNAMECHANGEPFN)(LONG pvCallerData, 
                    LPCSTR pszOldName, LPCSTR pszNewName);

/****************************************************************************
	Values for SCC_OPT_HASCANCELMODE.  By default, it is assumed that the IDE
	will not allow for canceling a long running operation.  The provider must
	handle this on their own in this case.  If the IDE, however, sets this
	option to SCC_OPT_HCM_YES, it means that it will handle canceling the
	operation.  In this case, use the SCC_MSG_xxx flags with the output
	call-back to tell the IDE what messages to display while the operation
	is running.
****************************************************************************/
#define SCC_OPT_HCM_NO			0L				// (Default) Has no cancel mode,
												//	Provider must supply if desired
#define SCC_OPT_HCM_YES			1L				// IDE handles cancel

/****************************************************************************
	Values for SCC_OPT_SCCCHECKOUTONLY.  By default, it is assumed that 
	the user may use the gui to get and checkout files from this project,
	and that a working dir should be set,  If this option is explicitly turned on,
	then no working dir is set for the project, and the files may only be gotten
	or checked in or out from scc integration, never from the gui.
****************************************************************************/
#define SCC_OPT_SCO_NO			0L				// (Default) OK to checkout from GUI
												//	Working dir is set.
#define SCC_OPT_SCO_YES			1L				// no GUI checkout, no working dir



/****************************************************************************
	The SCC_PROC_NAMES macro will expand for each function in the API.
	You must define SCC_PROC to do what you want.  For this file, it
	creates an enum (see code just after the table), by concatenating
	SCC_CMD_ with the function name.  This enum is used in the sccuser.cpp
	module as an index for function pointers of the provider.  sccuser.cpp
	also redefines SCC_PROC to expand a table of character string function
	names.  This table, when used with the enum, allows for adding and
	removing of function names from the API will only a recompile required
	to fix up addresses and offsets.  You can #undef SCC_PROC and redefine
	it to do other tables of your own if required.
****************************************************************************/
#define SCC_PROC(nam)   SCC_CMD_ ## nam

#define SCC_PROC_NAMES \
    SCC_PROC(SccInitialize), \
    SCC_PROC(SccUninitialize), \
    SCC_PROC(SccOpenProject), \
    SCC_PROC(SccCloseProject), \
    SCC_PROC(SccGet), \
    SCC_PROC(SccCheckout), \
    SCC_PROC(SccUncheckout), \
    SCC_PROC(SccCheckin), \
    SCC_PROC(SccAdd), \
    SCC_PROC(SccRemove), \
    SCC_PROC(SccRename), \
    SCC_PROC(SccDiff), \
    SCC_PROC(SccHistory), \
    SCC_PROC(SccProperties), \
    SCC_PROC(SccRunScc), \
    SCC_PROC(SccGetCommandOptions), \
    SCC_PROC(SccQueryInfo), \
    SCC_PROC(SccGetEvents), \
    SCC_PROC(SccGetProjPath), \
    SCC_PROC(SccPopulateList), \
    SCC_PROC(SccAddFromScc), \
    SCC_PROC(SccSetOption), \
    SCC_PROC(SccGetVersion)

enum 
{
    SCC_PROC_NAMES
};
#define SCC_CMD_COUNT           (SCC_CMD_SccGetVersion + 1)




/****************************************************************************
    Following are the ASCII definitions of the functions.
****************************************************************************/



/*******************************************************************************
	Returns a 4 byte version of the provider.  This can be used to check for 
	SCC spec conformance.
*******************************************************************************/
SCCEXTERNC LONG EXTFUN SccGetVersion(void);

/*******************************************************************************
	Call this function once per instance of a provider.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccInitialize(
                        LPVOID * ppContext, 
                        HWND hWnd, 
                        LPCSTR lpCallerName,
                        LPSTR lpSccName, 
                        LPLONG lpSccCaps, 
                        LPSTR lpAuxPathLabel, 
                        LPLONG pnCheckoutCommentLen, 
                        LPLONG pnCommentLen
                        );

/*******************************************************************************
	Call this function once for every instance of a provider, when it is going
	away.  You must call SccInitialize before calling this function, and should
	not call it with any open projects.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccUninitialize(
                        LPVOID pContext
                        );

/*******************************************************************************
	Opens a project.  This function should never be called with an already open
	project on pContext.  The lpUser, lpProjName, and lpAuxProjPath values
	may be modified by the provider.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccOpenProject(
                        LPVOID pContext,
                        HWND hWnd, 
                        LPSTR lpUser,
                        LPSTR lpProjName,
                        LPCSTR lpLocalProjPath,
                        LPSTR lpAuxProjPath,
                        LPCSTR lpComment,
                        LPTEXTOUTPROC lpTextOutProc,
                        LONG dwFlags
                        );

/*******************************************************************************
	Called to close a project opened by SccOpenProject.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccCloseProject(
                        LPVOID pContext
                        );

/*******************************************************************************
	Prompts the user for provider project information.  This may include the
	path to a certain project.  The caller must be prepared to accept changes
	to lpUser, lpProjName, lpLocalPath, and lpAuxProjPath.  lpProjName and
	lpAuxProjPath are then used in a call to SccOpenProject.  They should not
	be modified by the caller upon return.  The caller should avoid displaying
	these two parameters upon return, as the provider might use a formatted
	string that is not ready for view.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccGetProjPath(
                        LPVOID pContext, 
                        HWND hWnd, 
                        LPSTR lpUser,
                        LPSTR lpProjName, 
                        LPSTR lpLocalPath,
                        LPSTR lpAuxProjPath,
                        BOOL bAllowChangePath,
                        LPBOOL pbNew
                        );

/*******************************************************************************
	Retrieves a read only copy of a set of files.  The array is a set of files
	on the local disk.  The paths must be fully qualified.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccGet(
                        LPVOID pContext, 
                        HWND hWnd, 
                        LONG nFiles, 
                        LPCSTR* lpFileNames, 
                        LONG dwFlags,
                        LPCMDOPTS pvOptions
                        );

/*******************************************************************************
	Checks out the array of files.  The array is a set of fully qualified local
	path names.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccCheckout(
                        LPVOID pContext, 
                        HWND hWnd, 
                        LONG nFiles, 
                        LPCSTR* lpFileNames, 
                        LPCSTR lpComment, 
                        LONG dwFlags,
                        LPCMDOPTS pvOptions
                        );

/*******************************************************************************
	Undo a checkout of an array of files.  The array is a set of fully qualified
	local path names.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccUncheckout(
                        LPVOID pContext, 
                        HWND hWnd, 
                        LONG nFiles, 
                        LPCSTR* lpFileNames, 
                        LONG dwFlags,
                        LPCMDOPTS pvOptions
                        );

/*******************************************************************************
	Make the modifications the user has made to an array of files permanent. The
	file names must be fully qualified local paths.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccCheckin(
                        LPVOID pContext, 
                        HWND hWnd, 
                        LONG nFiles, 
                        LPCSTR* lpFileNames, 
                        LPCSTR lpComment, 
                        LONG dwFlags,
                        LPCMDOPTS pvOptions
                        );

/*******************************************************************************
	Add an array of fully qualified files to the source control system.  The 
	array of flags describe the type of file.  See the SCC_FILETYPE_xxxx flags.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccAdd(
                        LPVOID pContext, 
                        HWND hWnd, 
                        LONG nFiles, 
                        LPCSTR* lpFileNames, 
                        LPCSTR lpComment, 
                        LONG * pdwFlags,
                        LPCMDOPTS pvOptions
                        );

/*******************************************************************************
	Removes the array of fully qualified files from the source control system.
	The files are not removed from the user's disk, unless advanced options
	are set by the user.  Advaned options are defined by the provider.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccRemove(
                        LPVOID pContext, 
                        HWND hWnd, 
                        LONG nFiles, 
                        LPCSTR* lpFileNames,
                        LPCSTR lpComment,
                        LONG dwFlags,
                        LPCMDOPTS pvOptions
                        );

/*******************************************************************************
	Renames the given file to a new name in the source control system.  The
	provider should not attempt to access the file on disk.  It is the
	caller's responsibility to rename the file on disk.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccRename(
                        LPVOID pContext, 
                        HWND hWnd, 
                        LPCSTR lpFileName,
                        LPCSTR lpNewName
                        );

/*******************************************************************************
	Show the differences between the local users fully qualified file and the
	version under source control.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccDiff(
                        LPVOID pContext, 
                        HWND hWnd, 
                        LPCSTR lpFileName, 
                        LONG dwFlags,
                        LPCMDOPTS pvOptions
                        );

/*******************************************************************************
	Show the history for an array of fully qualified local file names.  The
	provider may not always support an array of files, in which case only the
	first files history will be shown.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccHistory(
                        LPVOID pContext, 
                        HWND hWnd, 
                        LONG nFiles, 
                        LPCSTR* lpFileNames, 
                        LONG dwFlags,
                        LPCMDOPTS pvOptions
                        );

/*******************************************************************************
	Show the properties of a fully qualified file.  The properties are defined
	by the provider and may be different for each one.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccProperties(
                        LPVOID pContext, 
                        HWND hWnd, 
                        LPCSTR lpFileName
                        );

/*******************************************************************************
	Examine a list of fully qualified files for their current status.  The
	return array will be a bitmask of SCC_STATUS_xxxx bits.  A provider may
	not support all of the bit types.  For example, SCC_STATUS_OUTOFDATE may
	be expensive for some provider to provide.  In this case the bit is simply
	not set.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccQueryInfo(
                        LPVOID pContext, 
                        LONG nFiles, 
                        LPCSTR* lpFileNames, 
                        LPLONG lpStatus
                        );

/*******************************************************************************
	Like SccQueryInfo, this function will examine the list of files for their
	current status.  In addition, it will use the pfnPopulate function to 
	notify the caller when a file does not match the critera for the nCommand.
	For example, if the command is SCC_COMMAND_CHECKIN, and a file in the list
	is not checked out, then the callback is used to tell the caller this.  
	Finally, the provider may find other files that could be part of the command
	and add them.  This allows a VB user to check out a .bmp file that is used
	by their VB project, but does not appear in the VB makefile.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccPopulateList(
                        LPVOID pContext, 
                        enum SCCCOMMAND nCommand, 
                        LONG nFiles, 
                        LPCSTR* lpFileNames, 
                        POPLISTFUNC pfnPopulate, 
                        LPVOID pvCallerData,
						LPLONG lpStatus, 
						LONG dwFlags
                        );

/*******************************************************************************
	SccGetEvents runs in the background checking the status of files that the
	caller has asked about (via SccQueryInfo).  When the status changes, it 
	builds a list of those changes that the caller may exhaust on idle.  This
	function must take virtually no time to run, or the performance of the 
	caller will start to degrade.  For this reason, some providers may choose
	not to implement this function.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccGetEvents(
                        LPVOID pContext, 
                        LPSTR lpFileName,
                        LPLONG lpStatus,
                        LPLONG pnEventsRemaining
                        );

/*******************************************************************************
	This function allows a user to access the full range of features of the
	source control system.  This might involve launching the native front end
	to the product.  Optionally, a list of files are given for the call.  This
	allows the provider to immediately select or subset their list.  If the
	provider does not support this feature, it simply ignores the values.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccRunScc(
                        LPVOID pContext, 
                        HWND hWnd, 
                        LONG nFiles, 
                        LPCSTR* lpFileNames
                        );

/*******************************************************************************
	This function will prompt the user for advaned options for the given
	command.  Call it once with ppvOptions==NULL to see if the provider
	actually supports the feature.  Call it again when the user wants to see
	the advaned options (usually implemented as an Advaned button on a dialog).
	If a valid *ppvOptions is returned from the second call, then this value
	becomes the pvOptions value for the SccGet, SccCheckout, SccCheckin, etc...
	functions.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccGetCommandOptions(
                        LPVOID pContext, 
                        HWND hWnd, 
                        enum SCCCOMMAND nCommand,
                        LPCMDOPTS * ppvOptions
                        );


/*******************************************************************************
	This function allows the user to browse for files that are already in the
	source control system and then make those files part of the current project.
	This is handy, for example, to get a common header file into the current
	project without having to copy the file.  The return array of files
	(lplpFileNames) contains the list of files that the user wants added to
	the current makefile/project.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccAddFromScc(
                        LPVOID pContext, 
                        HWND hWnd, 
                        LPLONG pnFiles,
                        LPCSTR** lplpFileNames
                        );

/*******************************************************************************
	SccSetOption is a generic function used to set a wide variety of options.
	Each option starts with SCC_OPT_xxx and has its own defined set of values.
*******************************************************************************/
SCCEXTERNC SCCRTN EXTFUN SccSetOption(
                        LPVOID pContext,
                        LONG nOption,
                        LONG dwVal
                        );




#if defined( __cplusplus )
}
#endif





#endif // _SCC_DEFS

//******* EOF ********
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\SCGuids.h ===
/*-----------------------------------------------------------------------------
Microsoft VSEE

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc
@module VseeGuids.h - Guids for VSEE services/interfaces |
This is included by .idl files to define guids for VSEE services/interfaces.
These are the interfaces related to the shell SDK, i.e. in idl/vs

@owner Source Control Integration Team
-----------------------------------------------------------------------------*/
#pragma once

#ifdef _WIN64

#define uuid_IVsSccManager2							53474C4D-B927-4320-B9DA-13D2CB3EA93B
#define uuid_IVsSccManager3							53474C4D-A152-4757-868A-2A7D0F2E5580
#define uuid_IVsSccProject2							53474C4D-AC92-49AC-9172-603E01FA483A
#define uuid_IVsQueryEditQuerySave2					53474C4D-5984-11d3-a606-005004775ab1
#define uuid_IVsTrackProjectDocuments2				53474C4D-6639-11d3-a60d-005004775ab1
#define uuid_IVsTrackProjectDocumentsEvents2		53474C4D-663d-11d3-a60d-005004775ab1
#define uuid_IVsSccProviderFactory					53474C4D-03f8-11d0-8e5e-00a0c911005a
#define uuid_IVsSccProjectProviderBinding			53474C4D-02f8-11d0-8e5e-00a0c911005a
#define uuid_IVsSccProjectEnlistmentFactory			53474C4D-00f8-11d0-8e5e-00a0c911005a
#define uuid_IVsSccProjectEnlistmentChoice			53474C4D-06f8-11d0-8e5e-00a0c911005a
#define uuid_IVsSccEnlistmentPathTranslation		53474C4D-01f8-11d0-8e5e-00a0c911005a

#else

#define uuid_IVsSccManager2							53544C4D-B927-4320-B9DA-13D2CB3EA93B
#define uuid_IVsSccManager3							53544C4D-A152-4757-868A-2A7D0F2E5580
#define uuid_IVsSccProject2							53544C4D-AC92-49AC-9172-603E01FA483A
#define uuid_IVsQueryEditQuerySave2					53544C4D-5984-11d3-a606-005004775ab1
#define uuid_IVsTrackProjectDocuments2				53544C4D-6639-11d3-a60d-005004775ab1
#define uuid_IVsTrackProjectDocumentsEvents2		53544c4d-663d-11d3-a60d-005004775ab1
#define uuid_IVsSccProviderFactory					53544c4d-03f8-11d0-8e5e-00a0c911005a
#define uuid_IVsSccProjectProviderBinding			53544c4d-02f8-11d0-8e5e-00a0c911005a
#define uuid_IVsSccProjectEnlistmentFactory			53544c4d-00f8-11d0-8e5e-00a0c911005a
#define uuid_IVsSccProjectEnlistmentChoice			53544c4d-06f8-11d0-8e5e-00a0c911005a
#define uuid_IVsSccEnlistmentPathTranslation		53544c4d-01f8-11d0-8e5e-00a0c911005a

#endif

#define uuid_SVsSccManager							53544C4D-1927-4320-B9DA-13D2CB3EA93B
#define uuid_SVsQueryEditQuerySave					53544C4D-1984-11d3-a606-005004775ab1
#define uuid_SVsTrackProjectDocuments				53544C4D-1639-11d3-a60d-005004775ab1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\scpmnuid.h ===
//////////////////////////////////////////////////////////////////////////////
//
//Microsoft Confidential
//Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
//
//File: ScpMnuID.H
//
//Contents:
//
//////////////////////////////////////////////////////////////////////////////
#ifndef _SCPMNUID_H_
#define _SCPMNUID_H_

#include "scpedtid.h"  // This lives in %DEVBIN%

//////////////////////////////////////////////////////////////////////////////
//
// Guids defined and used by script editor
//
//////////////////////////////////////////////////////////////////////////////
#define NOICON	guidOfficeIcon:msotcidNoIcon

#ifndef __ScpEdit_h

#ifdef DEFINE_GUID
  DEFINE_GUID(CLSID_ScrptEdtPkg, 
  0xfa14be31, 0xab8c, 0x11d0, 0xb1, 0x2e, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x32);
#else
  #define CLSID_ScrptEdtPkg {0xfa14be31, 0xab8c, 0x11d0, { 0xb1, 0x2e, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x32} }
#endif

#endif



//////////////////////////////////////////////////////////////////////////////
//
// Command Identifiers, created by Script Editor
//
//////////////////////////////////////////////////////////////////////////////
#define cmdSCPClassView		0x0100

#define cmdSCPSortAlphabetically   0x0500
#define cmdSCPSortByDeclaration    0x0600


//////////////////////////////////////////////////////////////////////////////
//
// Toolbar Identifiers, created by Script Editor
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// Menu Identifiers, created by Script Editor
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// Group Identifiers, created by Script Editor
//
//////////////////////////////////////////////////////////////////////////////

// Run Menu Groups
#define IDG_SCP_TEXTVIEW	0x0200

#define IDG_SCP_TREEOUTLINE    	0x0400
#define IDG_SCP_SORT            0x0500
#define IDG_SCP_SORTCASCADE     0x0600
#define IDG_SCP_GOTODEFN        0x0700
#define IDG_SCP_BREAKPOINTS     0x0800


//////////////////////////////////////////////////////////////////////////////
//
// Cascading Menu Identifiers, created by Script Editor
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// Context Menu Identifiers, created by Script Editor
//
//////////////////////////////////////////////////////////////////////////////

#define IDM_SCP_CTXT_TEXTVIEW	0x1200
#define IDM_SCP_CTXT_SCRIPTTREE	0x1300
#define IDM_SCP_CTXT_CSCD_SORT  0x1400

//////////////////////////////////////////////////////////////////////////////
//
// Menu Controller dentifiers, created by Script Editor
//
//////////////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\shell32wp.h ===
//---------------------------------------------------------------------------
//  Microsoft Confidential
//  Copyright (C) Microsoft Corporation, 2000 - 2001.  All Rights Reserved.
//
//  File:       shell32wp.h
//
//  Owner: Microsoft Visual Studio
//----------------------------------------------------------------------------

#ifndef _INC_SHELL32WP_H
#define _INC_SHELL32WP_H

#include "shlobj.h"

#define SHGetSettings OSHGetSettings

extern "C" {
void WINAPI OSHGetSettings(LPSHELLFLAGSTATE, DWORD);
}

#endif _INC_SHELL32WP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\shellver.h ===
//If you change the IDE version, the word-vbe test in the suites may fail if
// you don't do it right because it has a reference to the version 5 of the
// typelib.
#define VBIDE_LIB_VERSION_MAJ 5
#define VBIDE_LIB_VERSION_MIN 0
#define VBIDE_LIB_VERSION     5.0

#define RBY_TYPELIBMAJVER 7
#define RBY_TYPELIBMINVER 0
#define RBY_TYPELIBVERSION 7.0

#define DTE_LIB_VERSION_MAJ 7
#define DTE_LIB_VERSION_MIN 0

#ifndef _PREFIX_
#define DTE_LIB_VERSION     7.0
#else
#if !defined(DTE_LIB_VERSION)
#define DTE_LIB_VERSION     0x0070 
// To get edg to parse some 
// template instantiations where a WORD argument is being passed
// 7.0 as high as I can tell. 
#endif /* !defined(DTE_LIB_VERSION)  */
#endif /* _PREFIX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\scpedtid.h ===
//////////////////////////////////////////////////////////////////////////////
//
//Microsoft Confidential
//Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
//
//File: scpedtid.h
//
//Contents:
//
//////////////////////////////////////////////////////////////////////////////


#ifndef _SCPEDTID_H_
#define _SCPEDTID_H_

#ifndef NOGUIDS

#ifdef DEFINE_GUID

  // Guids for the script editor package.
  DEFINE_GUID(guidSCPGrpId, 
  0xd842f011, 0xdd01, 0x11d0, 0xa7, 0x68, 0x0, 0xa0, 0xc9, 0x11, 0x10, 0xc3);

  DEFINE_GUID(guidSCPCmdId, 
  0xd842f010, 0xdd01, 0x11d0, 0xa7, 0x68, 0x0, 0xa0, 0xc9, 0x11, 0x10, 0xc3);

#else

  // Guids for the script editor
  #define guidSCPCmdId { 0xd842f010, 0xdd01, 0x11d0, { 0xa7, 0x68, 0x0, 0xa0, 0xc9, 0x11, 0x10, 0xc3 } }
  #define guidSCPGrpId { 0xd842f011, 0xdd01, 0x11d0, { 0xa7, 0x68, 0x0, 0xa0, 0xc9, 0x11, 0x10, 0xc3 } }
#endif

#endif  // NOGUIDS



// Script Editor Group
#define IDG_SCP_MainMenu        0x0900

// Script Editor Commands.
#define cmdSCPSynchTree            0x0300
#define cmdSCPGotoDefinition       0x0400
#define cmdSCPSortCascade          0x0700
#define cmdSCPToggleUnimplEvents   0x0800


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\sharedids.h ===
#ifndef _SHAREDIDS_H_
#define _SHAREDIDS_H_

//////////////////////////////////////////////////////////////////////////////
//
// GUID Identifiers, created by WebBrowse package
//
//////////////////////////////////////////////////////////////////////////////
#ifndef NOGUIDS

#ifdef DEFINE_GUID
  // {83285929-227C-11d3-B870-00C04F79F802}
  DEFINE_GUID(Group_Undefined, 
    0x83285929, 0x227c, 0x11d3, 0xb8, 0x70, 0x0, 0xc0, 0x4f, 0x79, 0xf8, 0x2);

  // {8328592A-227C-11d3-B870-00C04F79F802}
  DEFINE_GUID(Pkg_Undefined, 
    0x8328592a, 0x227c, 0x11d3, 0xb8, 0x70, 0x0, 0xc0, 0x4f, 0x79, 0xf8, 0x2);

  // {8328592B-227C-11d3-B870-00C04F79F802}
  DEFINE_GUID(guidSharedCmd, 
    0x8328592b, 0x227c, 0x11d3, 0xb8, 0x70, 0x0, 0xc0, 0x4f, 0x79, 0xf8, 0x2);

  // {8328592C-227C-11d3-B870-00C04F79F802}
  DEFINE_GUID(guidSharedBmps, 
    0x8328592c, 0x227c, 0x11d3, 0xb8, 0x70, 0x0, 0xc0, 0x4f, 0x79, 0xf8, 0x2);

	// {52FD9855-984F-48af-99F2-B718F913FF02}
  DEFINE_GUID(guidSharedBmps2, 
    0x52fd9855, 0x984f, 0x48af, 0x99, 0xf2, 0xb7, 0x18, 0xf9, 0x13, 0xff, 0x2);

  // {DF81EA62-BAAB-4d89-B550-073BA96AD0A2}
  DEFINE_GUID(guidSharedBmps3, 
  0xdf81ea62, 0xbaab, 0x4d89, 0xb5, 0x50, 0x7, 0x3b, 0xa9, 0x6a, 0xd0, 0xa2);

  // {B155A99C-CBFC-4de4-B99A-ED6B1FB03217}
  DEFINE_GUID(guidSharedBmps4, 
  0xb155a99c, 0xcbfc, 0x4de4, 0xb9, 0x9a, 0xed, 0x6b, 0x1f, 0xb0, 0x32, 0x17);

  // {2BBED035-8A0C-4c19-8CD2-298937BEB38C}
  DEFINE_GUID(guidSharedBmps5, 
  0x2bbed035, 0x8a0c, 0x4c19, 0x8c, 0xd2, 0x29, 0x89, 0x37, 0xbe, 0xb3, 0x8c);

  // {EB28B762-7E54-492b-9336-4853994FE349}
  DEFINE_GUID(guidSharedBmps6, 
  0xeb28b762, 0x7e54, 0x492b, 0x93, 0x36, 0x48, 0x53, 0x99, 0x4f, 0xe3, 0x49);

  // {634F8946-FFF0-491f-AF41-B599FC20D561}
  DEFINE_GUID(guidSharedBmps7, 
  0x634f8946, 0xfff0, 0x491f, 0xaf, 0x41, 0xb5, 0x99, 0xfc, 0x20, 0xd5, 0x61);

  // {2B671D3D-AB51-434a-8D38-CBF1728530BB}
  DEFINE_GUID(guidSharedBmps8, 
  0x2b671d3d, 0xab51, 0x434a, 0x8d, 0x38, 0xcb, 0xf1, 0x72, 0x85, 0x30, 0xbb);

  // {222989A7-37A5-429f-AE43-8E9E960E7025}
  DEFINE_GUID(guidSharedBmps9, 
  0x222989a7, 0x37a5, 0x429f, 0xae, 0x43, 0x8e, 0x9e, 0x96, 0xe, 0x70, 0x25);

  // {3EA44CF4-2BBE-4d17-AA21-63B6A24BE9F6}
  DEFINE_GUID(guidSharedBmps10, 
  0x3ea44cf4, 0x2bbe, 0x4d17, 0xaa, 0x21, 0x63, 0xb6, 0xa2, 0x4b, 0xe9, 0xf6);

  // {7C9FA578-7C66-4495-98E6-1F5457E6C7AA}
  DEFINE_GUID(guidSharedBmps11, 
  0x7c9fa578, 0x7c66, 0x4495, 0x98, 0xe6, 0x1f, 0x54, 0x57, 0xe6, 0xc7, 0xaa);
#else

// {83285929-227C-11d3-B870-00C04F79F802}
#define Group_Undefined  { 0x83285929, 0x227c, 0x11d3, { 0xb8, 0x70, 0x00, 0xc0, 0x4f, 0x79, 0xf8, 0x02 } }

// {8328592A-227C-11d3-B870-00C04F79F802}
#define Pkg_Undefined    { 0x8328592a, 0x227c, 0x11d3, { 0xb8, 0x70, 0x0, 0xc0, 0x4f, 0x79, 0xf8, 0x2 } }

// {8328592B-227C-11d3-B870-00C04F79F802}
#define guidSharedCmd    { 0x8328592b, 0x227c, 0x11d3, { 0xb8, 0x70, 0x0, 0xc0, 0x4f, 0x79, 0xf8, 0x2 } }

// {8328592C-227C-11d3-B870-00C04F79F802}
#define guidSharedBmps   { 0x8328592c, 0x227c, 0x11d3, { 0xb8, 0x70, 0x0, 0xc0, 0x4f, 0x79, 0xf8, 0x2 } }

// {52FD9855-984F-48af-99F2-B718F913FF02}
#define guidSharedBmps2  { 0x52fd9855, 0x984f, 0x48af, { 0x99, 0xf2, 0xb7, 0x18, 0xf9, 0x13, 0xff, 0x2 } }

// {DF81EA62-BAAB-4d89-B550-073BA96AD0A2}
#define guidSharedBmps3 { 0xdf81ea62, 0xbaab, 0x4d89, { 0xb5, 0x50, 0x7, 0x3b, 0xa9, 0x6a, 0xd0, 0xa2 } }

// {B155A99C-CBFC-4de4-B99A-ED6B1FB03217}
#define guidSharedBmps4 { 0xb155a99c, 0xcbfc, 0x4de4, { 0xb9, 0x9a, 0xed, 0x6b, 0x1f, 0xb0, 0x32, 0x17 } }

// {2BBED035-8A0C-4c19-8CD2-298937BEB38C}
#define guidSharedBmps5 { 0x2bbed035, 0x8a0c, 0x4c19, { 0x8c, 0xd2, 0x29, 0x89, 0x37, 0xbe, 0xb3, 0x8c } }

// {EB28B762-7E54-492b-9336-4853994FE349}
#define guidSharedBmps6 { 0xeb28b762, 0x7e54, 0x492b, { 0x93, 0x36, 0x48, 0x53, 0x99, 0x4f, 0xe3, 0x49 } }

// {634F8946-FFF0-491f-AF41-B599FC20D561}
#define guidSharedBmps7 { 0x634f8946, 0xfff0, 0x491f, { 0xaf, 0x41, 0xb5, 0x99, 0xfc, 0x20, 0xd5, 0x61 } }

// {2B671D3D-AB51-434a-8D38-CBF1728530BB}
#define guidSharedBmps8 { 0x2b671d3d, 0xab51, 0x434a, { 0x8d, 0x38, 0xcb, 0xf1, 0x72, 0x85, 0x30, 0xbb } }

// {222989A7-37A5-429f-AE43-8E9E960E7025}
#define guidSharedBmps9 { 0x222989a7, 0x37a5, 0x429f, { 0xae, 0x43, 0x8e, 0x9e, 0x96, 0xe, 0x70, 0x25 } }

// {3EA44CF4-2BBE-4d17-AA21-63B6A24BE9F6}
#define guidSharedBmps10 { 0x3ea44cf4, 0x2bbe, 0x4d17, { 0xaa, 0x21, 0x63, 0xb6, 0xa2, 0x4b, 0xe9, 0xf6 } }

// {7C9FA578-7C66-4495-98E6-1F5457E6C7AA}
#define guidSharedBmps11 { 0x7c9fa578, 0x7c66, 0x4495, { 0x98, 0xe6, 0x1f, 0x54, 0x57, 0xe6, 0xc7, 0xaa } }

#endif //DEFINE_GUID

#endif //NOGUIDS


///////////////////////////////////////////////////////////////////////////////
// Command IDs


////////////////////////////////////////////////////////////////
// BITMAPS
////////////////////////////////////////////////////////////////
// guidSharedBmps
////////////////////////////////////////////////////////////////
#define bmpidVisibleBorders				1
#define bmpidShowDetails				2
#define bmpidMake2d						3
#define bmpidLockElement				4
#define bmpid2dDropMode					5
#define bmpidSnapToGrid					6
#define bmpidForeColor					7
#define bmpidBackColor					8
#define bmpidScriptOutline				9
#define bmpidDisplay1D					10
#define bmpidDisplay2D					11
#define bmpidInsertLink					12
#define bmpidInsertBookmark				13
#define bmpidInsertImage				14
#define bmpidInsertForm					15
#define bmpidInsertDiv					16
#define bmpidInsertSpan					17
#define bmpidInsertMarquee				18
#define bmpidOutlineHTML				19
#define bmpidOutlineScript				20
#define	bmpidShowGrid					21
//
#define bmpidCopyWeb                    22
#define bmpidSynchronize                23
#define bmpidIsolatedMode               24
#define bmpidDirectMode                 25
#define bmpidDiscardChanges             26
#define bmpidGetWorkingCopy             27
#define bmpidReleaseWorkingCopy         28
#define bmpidGet                        29
#define	bmpidShowAllFiles				30
#define bmpidStopNow                    31
#define bmpidBrokenLinkReport           32
#define bmpidAddDataCommand             33
#define bmpidRemoveWebFromScc           34
//
#define	bmpidAddPageFromFile			35
#define	bmpidOpenTopic					36
#define	bmpidAddBlankPage				37
#define	bmpidEditTitleString			38
#define	bmpidChangeNodeURL				39
//
#define bmpidDeleteTable                40
#define bmpidSelectTable                41
#define bmpidSelectColumn               42
#define bmpidSelectRow                  43
#define bmpidSelectCell                 44

#define bmpidAddNewWebForm              45
#define bmpidAddNewHTMLPage             46
#define bmpidAddNewWebService           47
#define bmpidAddNewComponent            48
#define bmpidaddNewModule               49
#define bmpidAddNewForm                 50
#define bmpidAddNewInheritedForm        51
#define bmpidAddNewUserControl          52
#define bmpidAddNewInheritedUserControl 53
#define bmpidAddNewXSDSchema            54
#define bmpidAddNewXMLPage              55
#define bmpidNewLeftFrame               56
#define bmpidNewRightFrame              57
#define bmpidNewTopFrame                58
#define bmpidNewBottomFrame             59
#define bmpidNewWebUserControl          60
//
#define bmpidCompile                    61

////////////////////////////////////////////////////////////////
// guidSharedBmps2
////////////////////////////////////////////////////////////////
#define bmpid2Filter                     1
#define bmpid2EventLog                   2
#define bmpid2View                       3
#define bmpid2TimelineViewer             4
#define bmpid2BlockDiagramViewer         5
#define bmpid2MultipleEventViewer        6
#define bmpid2SingleEventViewer          7
#define bmpid2SummaryViewer              8
#define bmpid2ChartViewer                9
#define bmpid2AddMachine                10
#define bmpid2AddFilter                 11
#define bmpid2EditFilter                12
#define bmpid2ApplyFilter               13
#define bmpid2StartCollecting           14
#define bmpid2StopCollecting            15
#define bmpid2IncreaseSpeed             16
#define bmpid2DecreaseSpeed             17
#define bmpid2Unknown1                  18
#define bmpid2FirstRecord               19
#define bmpid2PrevRecord                20
#define bmpid2NextRecord                21
#define bmpid2LastRecord                22
#define bmpid2Play                      23
#define bmpid2Stop                      24
#define bmpid2Duplicate                 25
#define bmpid2Export                    26
#define bmpid2Import                    27
#define bmpid2PlayFrom                  28
#define bmpid2PlayTo                    29
#define bmpid2Goto                      30
#define bmpid2ZoomToFit                 31
#define bmpid2AutoFilter                32
#define bmpid2AutoSelect                33
#define bmpid2AutoPlayTrack             34
#define bmpid2ExpandSelection           35
#define bmpid2ContractSelection         36
#define bmpid2PauseRecording            37
#define bmpid2AddLog                    38
#define bmpid2Connect                   39
#define bmpid2Disconnect                40
#define bmpid2MachineDiagram            41
#define bmpid2ProcessDiagram            42
#define bmpid2ComponentDiagram          43
#define bmpid2StructureDiagram          44
////////////////////////////////////////////////////////////////
// guidSharedBmps3
////////////////////////////////////////////////////////////////
#define bmpid3FileSystemEditor           1
#define bmpid3RegistryEditor             2
#define bmpid3FileTypesEditor            3
#define bmpid3UserInterfaceEditor        4
#define bmpid3CustomActionsEditor        5
#define bmpid3LaunchConditionsEditor     6
////////////////////////////////////////////////////////////////
// guidSharedBmps4
////////////////////////////////////////////////////////////////
#define bmpid4FldView                    1
#define bmpid4SelExpert                  2
#define bmpid4TopNExpert                 3
#define bmpid4SortOrder                  4
#define bmpid4PropPage                   5
#define bmpid4Help                       6
#define	bmpid4SaveRpt                    7
#define bmpid4InsSummary                 8
#define bmpid4InsGroup                   9
#define bmpid4InsSubreport              10
#define bmpid4InsChart                  11
#define bmpid4InsPicture                12
#define bmpid4SortCategory              13
////////////////////////////////////////////////////////////////
// guidSharedBmps5
////////////////////////////////////////////////////////////////
#define bmpid5AddDataConn                1
////////////////////////////////////////////////////////////////
// guidSharedBmps6
////////////////////////////////////////////////////////////////
#define bmpid6ViewFieldList              1
#define bmpid6ViewGrid                   2
#define bmpid6ViewKeys                   3
#define bmpid6ViewCollapsed              4
#define bmpid6Remove                     5
#define bmpid6Refresh                    6
#define bmpid6ViewUserDefined            7
#define bmpid6ViewPageBreaks             8
#define bmpid6RecalcPageBreaks           9
#define bmpid6ZoomToFit                 10
#define bmpid6DeleteFromDB              11
////////////////////////////////////////////////////////////////
// guidSharedBmps7
////////////////////////////////////////////////////////////////
#define bmpid7SelectQuery                1
#define bmpid7InsertQuery                2
#define bmpid7UpdateQuery                3
#define bmpid7DeleteQuery                4
#define bmpid7SortAsc                    5
#define bmpid7SortDesc                   6
#define bmpid7RemoveFilter               7
#define bmpid7VerifySQL                  8
#define bmpid7RunQuery                   9
#define bmpid7DiagramPane               10
#define bmpid7GridPane                  11
#define bmpid7ResultsPane               12
#define bmpid7SQLPane                   13
#define bmpid7Totals                    14
#define bmpid7MakeTableQuery            15
#define bmpid7InsertValuesQuery         16
#define bmpid7RowFirst                  17
#define bmpid7RowLast                   18
#define bmpid7RowNext                   19
#define bmpid7RowPrevious               20
#define bmpid7RowNew                    21
#define bmpid7RowDelete                 22
#define bmpid7GenerateSQL               23	
#define bmpid7JoinLeftAll               24
#define bmpid7JoinRightAll              25
#define bmpid7RowGoto                   26
#define bmpid7ClearQuery                27
#define bmpid7QryManageIndexes          28
////////////////////////////////////////////////////////////////
// guidSharedBmps8
////////////////////////////////////////////////////////////////
#define bmpid8NewTable                   1
#define bmpid8SaveChangeScript           2
#define bmpid8PrimaryKey                 3
#define bmpid8LayoutDiagram              4
#define bmpid8LayoutSelection            5
#define bmpid8AddRelatedTables           6
#define bmpid8NewTextAnnotation          7
#define bmpid8InsertCol                  8
#define bmpid8DeleteCol                  9
#define bmpid8ShowRelLabels             10
#define bmpid8AutosizeSelTables         11
#define	bmpid8SaveSelection             12
#define bmpid8EditUDV                   13
#define bmpid8AddTableView              14
#define bmpid8ManangeIndexes            15
#define bmpid8ManangeConstraints        16
#define bmpid8ManangeRelationships      17
////////////////////////////////////////////////////////////////
// guidSharedBmps9
////////////////////////////////////////////////////////////////
#define bmpid9NewElement                 1
#define bmpid9NewSimpleType              2
#define bmpid9NewComplexType             3
#define bmpid9NewAttribute               4
#define bmpid9NewGroup                   5
#define bmpid9NewAttributeGroup          6
#define bmpid9Diamond                    7
#define bmpid9NewAnyAttribute            8
#define bmpid9NewKey                     9
#define bmpid9NewRelation               10
#define bmpid9EditKey                   11
#define bmpid9EditRelation              12
#define bmpid9MakeTypeGlobal            13
#define bmpid9CreateSchema              14
#define bmpid9PreviewDataSet            15
#define bmpid9NewFacet                  16
#define bmpid9ValidateHtmlData          17

////////////////////////////////////////////////////////////////
// guidSharedBmps10
////////////////////////////////////////////////////////////////
#define bmpid10NewDialog                 1
#define bmpid10NewMenu                   2
#define bmpid10NewCursor                 3
#define bmpid10NewIcon                   4
#define bmpid10NewBitmap                 5
#define bmpid10NewToolbar                6
#define bmpid10NewAccel                  7
#define bmpid10NewString                 8
#define bmpid10NewVersion                9
#define bmpid10ResourceInc              10
//
#define bmpid10DlgTest                  12
//
#define bmpid10CenterVert               17
#define bmpid10CenterHorz               18
#define bmpid10SpaceAcross              19
#define bmpid10SpaceDown                20
//
#define bmpid10ToggleGrid               24
#define bmpid10ToggleGuides             25
//
#define bmpid10CheckMnemonics           27
#define bmpid10AutoLayoutGrow           28
#define bmpid10AutoLayoutOptimize       29
#define bmpid10AutoLayoutNoResize       30
////////////////////////////////////////////////////////////////
// guidSharedBmps11
////////////////////////////////////////////////////////////////
#define bmpid11Pick                      1
#define bmpid11PickRegion                2
#define bmpid11PickColor                 3
#define bmpid11Eraser                    4
#define bmpid11Fill                      5
#define bmpid11Zoom                      6
#define bmpid11Pencil                    7
#define bmpid11Brush                     8
#define bmpid11AirBrush                  9
#define bmpid11Line                     10
#define bmpid11Curve                    11
#define bmpid11Text                     12
#define bmpid11Rect                     13
#define bmpid11OutlineRect              14
#define bmpid11FilledRect               15
#define bmpid11RoundedRect              16
#define bmpid11OutlineRoundedRect       17
#define bmpid11FilledRoundedRect        18
#define bmpid11Ellipse                  19
#define bmpid11OutlineEllipse           20
#define bmpid11FilledEllipse            21
#define bmpid11HotSpot                  22
#define bmpid11EraserSize1              23
#define bmpid11EraserSize2              24
#define bmpid11EraserSize3              25
#define bmpid11EraserSize4              26
#define bmpid11LineWidth1               27
#define bmpid11LineWidth2               28
#define bmpid11LineWidth3               29
#define bmpid11LineWidth4               30
#define bmpid11LineWidth5               31
#define bmpid11LargeCircle              32
#define bmpid11MediumCircle             33
#define bmpid11SmallCircle              34
#define bmpid11SmallSquare              35
#define bmpid11LeftDiagLarge            36
#define bmpid11LeftDiagMedium           37
#define bmpid11LeftDiagSmall            38
#define bmpid11RightDiagLarge           39
#define bmpid11RightDiagMedium          40
#define bmpid11RightDiagSmall           41
#define bmpid11SplashSmall              42
#define bmpid11SplashMedium             43
#define bmpid11SplashLarge              44
#define bmpid11Transparent              45
#define bmpid11Opaque                   46
#define bmpid11Zoom1x                   47
#define bmpid11Zoom2x                   48
#define bmpid11Zoom6x                   49
#define bmpid11Zoom8x                   50
#define bmpid11ColorWindow              51
#define bmpid11ResView                  52
#define bmpid11Flip                     53
#define bmpid11Stretch                  54
//
#define bmpid11NewImageType             53
#define bmpid11ImageOptions		54

#endif //_SHAREDIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\smartptr.h ===
#ifndef SMARTPTR_H_INCLUDED
#define SMARTPTR_H_INCLUDED

///////////////////////////////////////////////////////////////////////////////
//
// "Smart Pointer" classes
//
// Revision History:
//   06/13/1997 AdamK - created.
//

#include <windows.h>
#include "vsmem.h"

// ignore error C4284, since we can instantiate the template 
// even when T is not a UDT, i.e. CPointer<char> pChar.  
#pragma warning(disable: 4284) // C4284 return type for 'identifier::operator >' is not a UDT or reference to a UDT. 


////////////////////////////////////////////////////////////////////////////////
// CVoidPointer
//
// Provides core implementation of CPointer.
// Do not use this class directly -- use CPointer instead.
// 
class CVoidPointer
{
protected:
    LPVOID Address;
    CVoidPointer()
    {
        Address = 0;
    }
    ~CVoidPointer()
    {
        Free();
    }
public:
    bool Allocate(DWORD NumBytes)
    {
        LPVOID NewAddress;

        // if memory was already allocated, then reallocate, else just allocate
        if (Address)
        {
            NewAddress = VSRealloc(Address, NumBytes);

            if (NewAddress)
            {
                // if successful, release old address, since it should not
                // be freed when reallocating memory
                Release();
            }
        }
        else
        {
            NewAddress = VSAlloc(NumBytes);
        }

        if (NewAddress)
        {
            Assign(NewAddress);
            return true;
        }
        else
        {
            return false;
        }
    }
    bool Copy(LPVOID pBuffer, DWORD BufferSize)
    {
        if (Allocate(BufferSize))
        {
            CopyMemory(Address, pBuffer, BufferSize);
            return true;
        }
        else
        {
            return false;
        }
    }
    void Free()
    {
        Assign(0);
    }
    // this function releases the pointer so it may passed to another block
    // which assumes responsibility for freeing the allocated memory.
    LPVOID Release()
    {
        LPVOID ReturnValue = Address;
        Address = 0;
        return ReturnValue;
    }
    bool IsNull() const
    {
        return (Address == 0);
    }
    operator bool() const
    {
        return !IsNull();
    }
    operator !() const
    {
        return IsNull();
    }
protected:
    void Assign(LPVOID const NewAddress = 0) 
    {
        if (Address)
        {
            VSFree(Address);
        }
        Address = NewAddress;
    }
};

 
////////////////////////////////////////////////////////////////////////////////
// CPointer
//
// Implements a "smart pointer" class for a pointer to any type, which handles
// allocating and freeing memory.  
//
template<typename T>
class CPointer : public CVoidPointer
{
public:
    operator T*() const
    {
        return GetAddress();
    }
    T& operator*() const
    {
        return *GetAddress();
    }
    T* operator->() const
    {
        return GetAddress();
    }
    T* Release()
    {
        return reinterpret_cast<T*>(CVoidPointer::Release());
    }
protected:
    T* GetAddress() const
    {
        return reinterpret_cast<T*>(Address);
    }
    void Assign(T* const NewAddress = 0) 
    {
        CVoidPointer::Assign(reinterpret_cast<LPVOID>(NewAddress));
    }
};

//#ifndef CP_THREAD_ACP
//#define CP_THREAD_ACP CP_ACP
//#endif 

inline DWORD GetStringLength(LPCSTR pAnsiString)
{
    return (DWORD)(pAnsiString ? strlen(pAnsiString) : 0);
}

inline DWORD GetStringLength(LPCWSTR pUnicodeString)
{
    return (DWORD)(pUnicodeString ? wcslen(pUnicodeString) : 0);
}

inline DWORD GetStringListLength(LPCSTR pAnsiStringList)
{
    if (!pAnsiStringList)
    {
        return 0;
    }

    DWORD CurrStringLength;
    DWORD AnsiStringListLength = 0;

    for (LPCSTR pCurrString = pAnsiStringList; *pCurrString; pCurrString += CurrStringLength)
    {
        CurrStringLength = (DWORD)strlen(pCurrString) + 1;
        AnsiStringListLength += CurrStringLength;
    }
    ++AnsiStringListLength; // final NULL terminator

    return AnsiStringListLength;
}

inline DWORD GetStringListLength(LPCWSTR pUnicodeStringList)
{
    if (!pUnicodeStringList)
    {
        return 0;
    }

    DWORD CurrStringLength;
    DWORD UnicodeStringListLength = 0;

    for (LPCWSTR pCurrString = pUnicodeStringList; *pCurrString; pCurrString += CurrStringLength)
    {
        CurrStringLength = (DWORD)wcslen(pCurrString) + 1;
        UnicodeStringListLength += CurrStringLength;
    }
    ++UnicodeStringListLength; // final NULL terminator

    return UnicodeStringListLength;
}

class CAnsiString : public CPointer<CHAR>
{
public:
    // copy from null-terminated ansi string to ansi string
    bool CopyString(LPCSTR pAnsiString) 
    {
        if (!pAnsiString)
        {
            Free();
            return true;
        }

        DWORD AnsiStringSize = ((DWORD)strlen(pAnsiString) + 1) * sizeof(CHAR); // size in bytes

        if (Allocate(AnsiStringSize))
        {
            CopyMemory(Address, pAnsiString, AnsiStringSize);
            return true;
        }
        else
        {
            return false;
        }
    }
    // copy from unicode string to an ansi string
    bool CopyString(LPCWSTR pUnicodeString, DWORD CodePage = CP_ACP, DWORD Flags = 0,
        LPCSTR pDefaultChar = NULL, LPBOOL pUsedDefaultChar = NULL)
    {
        if (!pUnicodeString)
        {
            Free();
            return true;
        }

        CAnsiString pTempAnsiString;

        // determine number of characters needed to hold ansi string
        DWORD CharsNeeded = WideCharToMultiByte(CodePage, Flags, pUnicodeString, -1, NULL, 0, 0, 0);

        // allocate memory for ansi string
        if (!pTempAnsiString.Allocate(CharsNeeded * sizeof(CHAR)))
        {
            return false;
        }

        // get ansi string
        if (!WideCharToMultiByte(CodePage, Flags, pUnicodeString, -1, 
            pTempAnsiString, CharsNeeded, pDefaultChar, pUsedDefaultChar))
        {
            return false;
        }

        // assign temp string
        Assign(pTempAnsiString);    
        pTempAnsiString.Release();  

        return true;
    }
    DWORD GetLength() const
    {
        return GetStringLength(GetAddress());
    }
};


class CUnicodeString : public CPointer<WCHAR>
{
public:
    // copy from null-terminated unicode string to unicode string
    bool CopyString(LPCWSTR pUnicodeString) // copy a null-terminated string
    {
        DWORD UnicodeStringSize = ((DWORD)wcslen(pUnicodeString) + 1) * sizeof(WCHAR); // size in bytes

        if (Allocate(UnicodeStringSize))
        {
            CopyMemory(Address, pUnicodeString, UnicodeStringSize);
            return true;
        }
        else
        {
            return false;
        }
    }
    // copy from ansi string to a unicode string
    bool CopyString(LPCSTR pAnsiString, DWORD CodePage = CP_ACP, DWORD Flags = 0)
    {
        CUnicodeString pTempUnicodeString;

        // determine number of characters needed to hold unicode string
        DWORD CharsNeeded = MultiByteToWideChar(CodePage, Flags, pAnsiString, -1, NULL, 0);

        // allocate memory for unicode string
        if (!pTempUnicodeString.Allocate(CharsNeeded * sizeof(WCHAR)))
        {
            return false;
        }

        // get unicode string
        if (!MultiByteToWideChar(CodePage, Flags, pAnsiString, -1, pTempUnicodeString, CharsNeeded))
        {
            return false;
        }

        // assign temp string
        Assign(pTempUnicodeString);
        pTempUnicodeString.Release();

        return true;
    }    
    DWORD GetLength() const
    {
        return GetStringLength(GetAddress());
    }
};

class CAnsiStringList : public CPointer<CHAR>
{
public:
    // copy from a null-terminated list of ansi strings
    bool CopyStringList(LPCSTR pAnsiStringList) 
    {
        if (!pAnsiStringList)
        {
            Free();
            return true;
        }

        DWORD AnsiStringListSize = GetStringListLength(pAnsiStringList) * sizeof(CHAR);

        if (Allocate(AnsiStringListSize))
        {
            CopyMemory(Address, pAnsiStringList, AnsiStringListSize);
            return true;
        }
        else
        {
            return false;
        }
    }
    // copy from a null-terminated list of unicode strings
    bool CopyStringList(LPCWSTR pUnicodeStringList, DWORD CodePage = CP_ACP, DWORD Flags = 0,
        LPCSTR pDefaultChar = NULL, LPBOOL pUsedDefaultChar = NULL)
    {
        if (!pUnicodeStringList)
        {
            Free();
            return true;
        }

        DWORD UnicodeStringListLength = GetStringListLength(pUnicodeStringList);

        CAnsiStringList pTempAnsiStringList;

        // determine number of bytes needed to hold ansi string list
        DWORD BytesNeeded = WideCharToMultiByte(CodePage, Flags, pUnicodeStringList, UnicodeStringListLength, NULL, 0, 0, 0);

        // allocate memory for ansi string list
        if (!pTempAnsiStringList.Allocate(BytesNeeded))
        {
            return false;
        }

        // get ansi string list
        if (!WideCharToMultiByte(CodePage, Flags, pUnicodeStringList, UnicodeStringListLength, 
            pTempAnsiStringList, BytesNeeded / sizeof(CHAR), pDefaultChar, pUsedDefaultChar))
        {
            return false;
        }

        // assign temp string
        Assign(pTempAnsiStringList);    
        pTempAnsiStringList.Release();  

        return true;
    }
    DWORD GetLength() const
    {
        return GetStringListLength(GetAddress());
    }
    bool AddString(LPCSTR pAnsiString)
    {
        // if NULL or empty, nothing to add
        if (!pAnsiString || !*pAnsiString)
        {
            return true;
        }

        // get list length
        DWORD ListLength = GetLength();

        // if list length is zero (i.e. list is NULL), then add one for final NULL terminator
        if (ListLength == 0)
        {
            ++ListLength; 
        }

        // determine bytes needed
        DWORD StringLength = (DWORD)strlen(pAnsiString) + 1;
        DWORD BytesNeeded = (ListLength + StringLength) * sizeof(CHAR);

        // reallocate
        if (!Allocate(BytesNeeded))
        {
            return false;
        }

        // copy new string onto the end of the list
        CopyMemory(GetAddress() + ListLength - 1, 
            pAnsiString, StringLength * sizeof(CHAR));

        // terminate list
        GetAddress()[StringLength + ListLength - 1] = 0;

        return true;
    }
    bool AddString(LPCWSTR pUnicodeString)
    {
        CAnsiString pAnsiString;

        // translate unicode string to ansi
        if (!pAnsiString.CopyString(pUnicodeString))
        {
            return false;
        }

        return AddString(pAnsiString);
    }
};


class CUnicodeStringList : public CPointer<WCHAR>
{
public:
    // copy from a null-terminated list of unicode strings
    bool CopyStringList(LPCWSTR pUnicodeStringList) 
    {
        if (!pUnicodeStringList)
        {
            Free();
            return true;
        }

        DWORD UnicodeStringListSize = GetStringListLength(pUnicodeStringList) * sizeof(WCHAR);

        if (Allocate(UnicodeStringListSize))
        {
            CopyMemory(Address, pUnicodeStringList, UnicodeStringListSize);
            return true;
        }
        else
        {
            return false;
        }
    }
    // copy from a null-terminated list of ansi strings
    bool CopyStringList(LPCSTR pAnsiStringList, DWORD CodePage = CP_ACP, DWORD Flags = 0)
    {
        if (!pAnsiStringList)
        {
            Free();
            return true;
        }

        DWORD CurrStringLength;
        DWORD AnsiStringListLength = 0;

        // calculate length (in characters) of ansi string list
        for (LPCSTR pCurrString = pAnsiStringList; *pCurrString; pCurrString += CurrStringLength)
        {
            CurrStringLength = (DWORD)strlen(pCurrString) + 1;
            AnsiStringListLength += CurrStringLength;
        }
        ++AnsiStringListLength; // include NULL terminator

        CUnicodeStringList pTempUnicodeStringList;

        // determine number of bytes needed to hold unicode string list
        DWORD BytesNeeded = MultiByteToWideChar(CodePage, Flags, pAnsiStringList, AnsiStringListLength, NULL, 0);

        // allocate memory for unicode string list
        if (!pTempUnicodeStringList.Allocate(BytesNeeded))
        {
            return false;
        }

        // get unicode string list
        if (!MultiByteToWideChar(CodePage, Flags, pAnsiStringList, AnsiStringListLength, 
            pTempUnicodeStringList, BytesNeeded / sizeof(CHAR)))
        {
            return false;
        }

        // assign temp string
        Assign(pTempUnicodeStringList);    
        pTempUnicodeStringList.Release();  

        return true;
    }
    DWORD GetLength() const
    {
        return GetStringListLength(GetAddress());
    }
    bool AddString(LPCWSTR pUnicodeString)
    {
        // if NULL or empty, nothing to add
        if (!pUnicodeString || !*pUnicodeString)
        {
            return true;
        }

        // determine list length
        DWORD ListLength = GetLength();

        // if list length is zero (i.e. list is NULL), then add one for final NULL terminator
        if (ListLength == 0)
        {
            ++ListLength; 
        }

        // determine bytes needed
        DWORD StringLength = (DWORD)wcslen(pUnicodeString) + 1;
        DWORD BytesNeeded = (ListLength + StringLength) * sizeof(WCHAR);

        // reallocate
        if (!Allocate(BytesNeeded))
        {
            return false;
        }

        // copy new string onto the end of the list
        CopyMemory(GetAddress() + ListLength - 1, pUnicodeString, StringLength * sizeof(WCHAR));

        // terminate list
        GetAddress()[StringLength + ListLength - 1] = 0;

        return true;
    }
    bool AddString(LPCSTR pAnsiString)
    {
        CUnicodeString pUnicodeString;

        // translate ansi string to unicode
        if (!pUnicodeString.CopyString(pAnsiString))
        {
            return false;
        }

        return AddString(pUnicodeString);
    }
};

#ifdef UNICODE
#define CVSString CUnicodeString
#define CVSStringList CUnicodeStringList
#else
#define CVSString CAnsiString
#define CVSStringList CAnsiStringList
#endif


#endif // SMARTPTR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\stdiduie.h ===
//-----------------------------------------------------------------------------
// Microsoft Visual Studio
//
// Microsoft Confidential
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// File: stdiduie.h
// Area: IOleComponentUIManager
//
// Contents:
//   Contains ids used for UIEvents used in StandardUIEventSet98.
//   StandardUIEventSet98 is defined by the following guid:
//
//   {54038220-FA22-11d0-8798-00A0C91E2A46}
//   DEFINE_GUID(StandardUIEventSet98, 
//   0x54038220, 0xfa22, 0x11d0, 0x87, 0x98, 0x0, 0xa0, 0xc9, 0x1e, 0x2a, 0x46);
//-----------------------------------------------------------------------------

#ifndef _STDIDUIE_H_                  
#define _STDIDUIE_H_                  

#ifndef __NOENUM__

// for specialized contracts
enum
  {
  UIE_TEXTSELMODE_STREAM   = 0,
  UIE_TEXTSELMODE_BOX      = 1
  };

enum
  {
  UIE_TEXTINSMODE_INSERT     = 0,
  UIE_TEXTINSMODE_OVERSTRIKE = 1
  };

#endif //__NOENUM__

// Events for GUID StandardUIEventSet98
// The following UIEvents all use:
//    dwUIEventStatus = OLEUIEVENTSTATUS_OCCURRED
//    dwEventFreq     = OLEUIEVENTFREQ_NULL
#define uieventidSetTextLinePos     1	// ARG: NULL, VT_I2, VT_I4, VT_BSTR, or VT_EMPTY
					//	If VT_I2 or VT_I4, number is formatted into "Ln ##"
					//	if VT_BSTR, text is displayed as is with no formatting
					//	if VT_EMPTY, value is NOT displayed at all
					//	if NULL pointer, value is left unchanged

#define uieventidSetTextColPos	    10	// ARG: NULL, VT_I2, VT_I4, VT_BSTR, or VT_EMPTY
					//	If VT_I2 or VT_I4, number is formatted into "Ln ##"
					//	if VT_BSTR, text is displayed as is with no formatting
					//	if VT_EMPTY, value is NOT displayed at all
					//	if NULL pointer, value is left unchanged

#define uieventidSetTextCharPos     2	// ARG: NULL, VT_I2, VT_I4, VT_BSTR, or VT_EMPTY
					//	If VT_I2 or VT_I4, number is formatted into "Ln ##"
					//	if VT_BSTR, text is displayed as is with no formatting
					//	if VT_EMPTY, value is NOT displayed at all
					//	if NULL pointer, value is left unchanged

#define uieventidSetTextSelMode     3	// ARG: VT_I4 UIE_TEXTSELMODE enum or VT_BSTR
#define uieventidSetTextInsMode     4	// ARG: VT_I4 UIE_TEXTINSMODE enum

#define uieventidSetGraphicXPos     5	// ARG: VT_I2, VT_I4, VT_R4, or VT_R8
#define uieventidSetGraphicYPos     6	// ARG: VT_I2, VT_I4, VT_R4, or VT_R8
#define uieventidSetGraphicXSize    7	// ARG: VT_I2, VT_I4, VT_R4, or VT_R8
#define uieventidSetGraphicYSize    8	// ARG: VT_I2, VT_I4, VT_R4, or VT_R8

// The following UIEvents all use:
//    dwUIEventStatus = OLEUIEVENTSTATUS_START / OLEUIEVENTSTATUS_STOP
//    dwEventFreq     = OLEUIEVENTFREQ_NULL
#define uieventidAnimateIcon	    9	// OLEUIEVENTSTATUS_START:  Starts animated icon
					// OLEUIEVENTSTATUS_STOP:   Stops animated icon
					// NYI: ARG: VT_I4, Index of predefined icons, or custom icon
#endif //_STDIDUIE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\spanset.h ===
// SpanSet.h - Implementation of IVsTextSpanSet
//
// Microsoft Confidential
// Copyright 1999 Microsoft Corporation.  All Rights Reserved.
//
//================================================================
// Created March 9 1999, Paul Chase Dempsey [paulde]
//
#pragma once
#include "textfind.h"
#include "textspan.h"

class CVsTextSpanSet :   
    public IVsTextSpanSet,
    public IVsTextImageEvents,
    public IVsTextLinesEvents
{
public:
    CVsTextSpanSet();
    ~CVsTextSpanSet();

    // IUnknown
    DECLARE_STD_UNKNOWN

    STDMETHOD (AttachTextImage)(IUnknown * pText);
    STDMETHOD (Detach         )(void);

    STDMETHOD (SuspendTracking)(void); // stop tracking without unadvising change events
    STDMETHOD (ResumeTracking )(void); // resume tracking

    STDMETHOD (Add          )(LONG celt, const TextSpan * pSpan);
    STDMETHOD (GetCount     )(LONG * pcelt);
    STDMETHOD (GetAt        )(LONG iEl, TextSpan * pSpan);
    STDMETHOD (RemoveAll    )(void); 
    STDMETHOD (Sort         )(DWORD SortOptions);
    STDMETHOD (AddFromEnum  )(IVsEnumTextSpans *pEnum);

    // IVsTextImageEvents
    STDMETHOD_(void, OnTextChange) (TextAddress taStart, TextAddress taEnd, TextAddress taNewEnd);

    // IVsTextLinesEvents
    STDMETHOD_(void, OnChangeLineText)(const TextLineChange *pTextLineChange, BOOL fLast);
    STDMETHOD_(void, OnChangeLineAttributes)(long iFirstLine, long iLastLine);

    HRESULT     AttachSpans (LONG celt, TextSpan * pSpans);

private:
    ULONG                       m_cRef;
    CTextSpan *                 m_pSpans;
    int                         m_cel;
    BOOL                        m_cTracking;
    DWORD                       m_dwCookie;
    IVsTextImage *              m_pTextImage;
    IConnectionPoint *          m_pTextLinesCP;

    HRESULT SinkTextImageEvents (void);
    HRESULT SinkTextLinesEvents (IUnknown * pText);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\stdhlpvb.h ===
//---------------------------------------------------------------------------
// StdHlpVb.h
//---------------------------------------------------------------------------
// Help IDs for prop/meth/evt structures
//---------------------------------------------------------------------------
// Copyright (c) 1994, Microsoft Corporation
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------

#ifndef STDHLPVB_H
#define STDHLPVB_H  // Indicates this file has been included.

#include "ids.h" // HELP_TOC_CONTEXT

// This is the VB.HLP table of contents context id
//#define HELP_TOC_CONTEXT        2008002
// help id for all (Custom) properties on the prop browser
//#define HELP_CUSTOM_PROPERTY    2020930


#define vbNoHelp        65535


// This is the base help context number offset for all intrinsic controls.
// Resource ID# = helpstringcontext - HELPSTRINGCTX_RESID_OFFSET
// helpstringcontext = Resource ID# + HELPSTRINGCTX_RESID_OFFSET
#define HELPSTRINGCTX_RESID_OFFSET 900000

// Note: Constants that used to be defined here (help resources) no longer 
// Note: need to be added here.  All you need to do now to add help to
// Note: intrinsic controls/methods/etc is to add the appropriate constant
// Note: to either RbyObj.ID (objects), RbyMth.ID (methods), RbyEvt.ID
// Note: (events), or RbyPro.ID (properties).  The rest is now automatic.


#endif  // STDHLPVB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\SystemFolders.h ===
////////////////////////////////////////////////////////////////////////////////
// SystemFolders.h

HRESULT util_GetSystemFolder(WCHAR *pwszFullPath, int CSIDL_Requested);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\stdidcmd.h ===
//-----------------------------------------------------------------------------
// Microsoft Visual Studio
//
// Microsoft Confidential
// Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// File: stdidcmd.h
// Area: IOleCommandTarget and IOleComponentUIManager
//
// Contents:
//   Contains ids used for commands used in StandardCommandSet97.
//   StandardCommandSet97 is defined by the following guid:
//
//   {5efc7975-14bc-11cf-9b2b-00aa00573819}
//   DEFINE_GUID(CLSID_StandardCommandSet97,
//               0x5efc7975, 0x14bc, 0x11cf, 0x9b, 0x2b, 0x00, 0xaa, 0x00, 
//               0x57, 0x38, 0x19);
//
//   Contains ids used for commands used in StandardCommandSet2K.
//   StandardCommandSet2K is defined by the following guid:
//
//   {1496A755-94DE-11D0-8C3F-00C04FC2AAE2}
//  DEFINE_GUID(CMDSETID_StandardCommandSet2K,
//    0x1496A755, 0x94DE, 0x11D0, 0x8C, 0x3F, 0x00, 0xC0, 0x4F, 0xC2, 0xAA, 0xE2);
//
//  NOTE that new commands should be added to the end of StandardCommandSet2K
//  and that CLSID_StandardCommandSet97 should not be further added to.
//  NOTE also that in StandardCommandSet2K all commands up to ECMD_FINAL are
//  standard editor commands and have been moved here from editcmd.h.
//-----------------------------------------------------------------------------

#ifndef _STDIDCMD_H_                  
#define _STDIDCMD_H_                  

#ifndef __CTC__
#ifdef __cplusplus

// for specialized contracts
enum
  {
  CMD_ZOOM_PAGEWIDTH	   = -1,
  CMD_ZOOM_ONEPAGE	   = -2,
  CMD_ZOOM_TWOPAGES	   = -3,
  CMD_ZOOM_SELECTION	   = -4,
  CMD_ZOOM_FIT		   = -5
  };

#endif //__cplusplus
#endif //__CTC__

#define cmdidAlignBottom		1                                                                   
#define cmdidAlignHorizontalCenters     2                                                        
#define cmdidAlignLeft			3                                                                     
#define cmdidAlignRight			4                                                                    
#define cmdidAlignToGrid		5                                                                   
#define cmdidAlignTop			6                                                                      
#define cmdidAlignVerticalCenters       7                                                          
#define cmdidArrangeBottom		8                                                                 
#define cmdidArrangeRight		9                                                                  
#define cmdidBringForward		10                                                                 
#define cmdidBringToFront		11                                                                 
#define cmdidCenterHorizontally         12                                                           
#define cmdidCenterVertically           13                                                             
#define cmdidCode			14                                                                         
#define cmdidCopy			15                                                                         
#define cmdidCut			16                                                                          
#define cmdidDelete			17                                                                       
#define cmdidFontName			18                                                                     
#define cmdidFontNameGetList			500                                                                     
#define cmdidFontSize			19                                                                     
#define cmdidFontSizeGetList			501                                                                     
#define cmdidGroup			20                                                                        
#define cmdidHorizSpaceConcatenate      21                                                        
#define cmdidHorizSpaceDecrease         22                                                           
#define cmdidHorizSpaceIncrease         23                                                           
#define cmdidHorizSpaceMakeEqual        24                                                          
#define cmdidLockControls               369
#define cmdidInsertObject		25                                                                 
#define cmdidPaste			26                                                                        
#define cmdidPrint			27                                                                        
#define cmdidProperties			28                                                                   
#define cmdidRedo			29                                                                         
#define cmdidMultiLevelRedo		30                                                               
#define cmdidSelectAll			31                                                                    
#define cmdidSendBackward		32                                                                 
#define cmdidSendToBack			33                                                                   
#define cmdidShowTable			34                                                                    
#define cmdidSizeToControl		35                                                                
#define cmdidSizeToControlHeight        36                                                          
#define cmdidSizeToControlWidth         37                                                           
#define cmdidSizeToFit			38                                                                    
#define cmdidSizeToGrid			39                                                                   
#define cmdidSnapToGrid			40                                                                   
#define cmdidTabOrder			41                                                                     
#define cmdidToolbox			42                                                                      
#define cmdidUndo			43                                                                         
#define cmdidMultiLevelUndo		44                                                               
#define cmdidUngroup			45                                                                      
#define cmdidVertSpaceConcatenate       46                                                         
#define cmdidVertSpaceDecrease          47                                                            
#define cmdidVertSpaceIncrease          48                                                            
#define cmdidVertSpaceMakeEqual         49                                                           
#define cmdidZoomPercent		50                                                                  
#define cmdidBackColor			51                                                                    
#define cmdidBold			52                                                                         
#define cmdidBorderColor		53                                                                  
#define cmdidBorderDashDot		54                                                                
#define cmdidBorderDashDotDot           55                                                             
#define cmdidBorderDashes		56                                                                 
#define cmdidBorderDots			57                                                                   
#define cmdidBorderShortDashes          58                                                            
#define cmdidBorderSolid		59                                                                  
#define cmdidBorderSparseDots           60                                                             
#define cmdidBorderWidth1		61                                                                 
#define cmdidBorderWidth2		62                                                                 
#define cmdidBorderWidth3		63                                                                 
#define cmdidBorderWidth4		64                                                                 
#define cmdidBorderWidth5		65                                                                 
#define cmdidBorderWidth6		66                                                                 
#define cmdidBorderWidthHairline        67                                                          
#define cmdidFlat			68                                                                         
#define cmdidForeColor			69                                                                    
#define cmdidItalic			70                                                                       
#define cmdidJustifyCenter		71                                                                
#define cmdidJustifyGeneral		72                                                               
#define cmdidJustifyLeft		73                                                                  
#define cmdidJustifyRight		74                                                                 
#define cmdidRaised			75                                                                       
#define cmdidSunken			76                                                                       
#define cmdidUnderline			77                                                                    
#define cmdidChiseled			78                                                                     
#define cmdidEtched			79                                                                       
#define cmdidShadowed			80                                                                     
#define cmdidCompDebug1			81                                                                   
#define cmdidCompDebug2			82                                                                   
#define cmdidCompDebug3			83                                                                   
#define cmdidCompDebug4			84                                                                   
#define cmdidCompDebug5			85                                                                   
#define cmdidCompDebug6			86                                                                   
#define cmdidCompDebug7			87                                                                   
#define cmdidCompDebug8			88                                                                   
#define cmdidCompDebug9			89                                                                   
#define cmdidCompDebug10		90                                                                  
#define cmdidCompDebug11		91                                                                  
#define cmdidCompDebug12		92                                                                  
#define cmdidCompDebug13		93                                                                  
#define cmdidCompDebug14		94                                                                  
#define cmdidCompDebug15		95                                                                  
#define cmdidExistingSchemaEdit         96                                                           
#define cmdidFind			97                                                                         
#define cmdidGetZoom			98                                                                      
#define cmdidQueryOpenDesign		99                                                              
#define cmdidQueryOpenNew		100                                                                
#define cmdidSingleTableDesign          101                                                           
#define cmdidSingleTableNew		102                                                              
#define cmdidShowGrid			103
#define cmdidNewTable			104
#define cmdidCollapsedView		105
#define cmdidFieldView			106
#define cmdidVerifySQL			107
#define cmdidHideTable			108

#define cmdidPrimaryKey			109
#define cmdidSave			110
#define cmdidSaveAs			111
#define cmdidSortAscending		112

#define cmdidSortDescending		113
#define cmdidAppendQuery		114
#define cmdidCrosstabQuery		115
#define cmdidDeleteQuery		116
#define cmdidMakeTableQuery		117

#define cmdidSelectQuery		118
#define cmdidUpdateQuery		119
#define cmdidParameters			120
#define cmdidTotals			121
#define cmdidViewCollapsed		122

#define cmdidViewFieldList		123


#define cmdidViewKeys			124
#define cmdidViewGrid			125
#define cmdidInnerJoin			126

#define cmdidRightOuterJoin		127
#define cmdidLeftOuterJoin		128
#define cmdidFullOuterJoin		129
#define cmdidUnionJoin			130
#define cmdidShowSQLPane		131

#define cmdidShowGraphicalPane          132
#define cmdidShowDataPane		133
#define cmdidShowQBEPane		134
#define cmdidSelectAllFields		135

#define cmdidOLEObjectMenuButton        136

// ids on the ole verbs menu - these must be sequential ie verblist0-verblist9
#define cmdidObjectVerbList0		137
#define cmdidObjectVerbList1		138
#define cmdidObjectVerbList2		139
#define cmdidObjectVerbList3		140
#define cmdidObjectVerbList4		141
#define cmdidObjectVerbList5		142
#define cmdidObjectVerbList6		143
#define cmdidObjectVerbList7		144
#define cmdidObjectVerbList8		145
#define cmdidObjectVerbList9		146 // Unused on purpose!

#define cmdidConvertObject		147
#define cmdidCustomControl		148
#define cmdidCustomizeItem		149
#define cmdidRename			150

#define cmdidImport			151
#define cmdidNewPage			152
#define cmdidMove			153
#define cmdidCancel			154

#define cmdidFont			155

#define cmdidExpandLinks		156
#define cmdidExpandImages		157
#define cmdidExpandPages		158
#define cmdidRefocusDiagram 		159
#define cmdidTransitiveClosure		160
#define cmdidCenterDiagram		161
#define cmdidZoomIn 			162
#define cmdidZoomOut			163
#define cmdidRemoveFilter		164
#define cmdidHidePane			165
#define cmdidDeleteTable		166
#define cmdidDeleteRelationship		167
#define cmdidRemove 			168
#define cmdidJoinLeftAll		169
#define cmdidJoinRightAll		170
#define cmdidAddToOutput		171 	// Add selected fields to query output
#define cmdidOtherQuery 		172 	// change query type to 'other'
#define cmdidGenerateChangeScript	173
#define cmdidSaveSelection		174	// Save current selection
#define cmdidAutojoinCurrent		175	// Autojoin current tables
#define cmdidAutojoinAlways 		176	// Toggle Autojoin state
#define cmdidEditPage			177	// Launch editor for url
#define cmdidViewLinks			178	// Launch new webscope for url
#define cmdidStop			179	// Stope webscope rendering
#define cmdidPause			180	// Pause webscope rendering
#define cmdidResume			181	// Resume webscope rendering
#define cmdidFilterDiagram		182	// Filter webscope diagram
#define cmdidShowAllObjects		183	// Show All objects in webscope diagram
#define cmdidShowApplications		184	// Show Application objects in webscope diagram
#define cmdidShowOtherObjects		185	// Show other objects in webscope diagram
#define cmdidShowPrimRelationships	186	// Show primary relationships
#define cmdidExpand			187	// Expand links
#define cmdidCollapse			188	// Collapse links
#define cmdidRefresh			189	// Refresh Webscope diagram
#define cmdidLayout			190	// Layout websope diagram
#define cmdidShowResources		191	// Show resouce objects in webscope diagram
#define cmdidInsertHTMLWizard		192	// Insert HTML using a Wizard
#define cmdidShowDownloads		193	// Show download objects in webscope diagram
#define cmdidShowExternals		194	// Show external objects in webscope diagram
#define cmdidShowInBoundLinks		195	// Show inbound links in webscope diagram
#define cmdidShowOutBoundLinks		196	// Show out bound links in webscope diagram
#define cmdidShowInAndOutBoundLinks	197	// Show in and out bound links in webscope diagram
#define cmdidPreview			198	// Preview page
#define cmdidOpen			261	// Open
#define cmdidOpenWith			199	// Open with
#define cmdidShowPages			200	// Show HTML pages
#define cmdidRunQuery			201 	// Runs a query
#define cmdidClearQuery 		202 	// Clears the query's associated cursor
#define cmdidRecordFirst		203 	// Go to first record in set
#define cmdidRecordLast 		204 	// Go to last record in set
#define cmdidRecordNext 		205 	// Go to next record in set
#define cmdidRecordPrevious 		206 	// Go to previous record in set
#define cmdidRecordGoto 		207 	// Go to record via dialog
#define cmdidRecordNew			208 	// Add a record to set

#define cmdidInsertNewMenu		209	// menu designer
#define cmdidInsertSeparator		210	// menu designer
#define cmdidEditMenuNames		211	// menu designer

#define cmdidDebugExplorer		212 
#define cmdidDebugProcesses		213
#define cmdidViewThreadsWindow		214
#define cmdidWindowUIList		215

// ids on the file menu
#define cmdidNewProject			216
#define cmdidOpenProject		217
#define cmdidOpenProjectFromWeb		450
#define cmdidOpenSolution		218
#define cmdidCloseSolution		219
#define cmdidFileNew			221
#define cmdidFileOpen			222
#define cmdidFileOpenFromWeb		451
#define cmdidFileClose			223
#define cmdidSaveSolution		224
#define cmdidSaveSolutionAs		225
#define cmdidSaveProjectItemAs		226
#define cmdidPageSetup			227
#define cmdidPrintPreview		228
#define cmdidExit			229

// ids on the edit menu
#define cmdidReplace			230
#define cmdidGoto			231

// ids on the view menu
#define cmdidPropertyPages		232
#define cmdidFullScreen			233
#define cmdidProjectExplorer		234
#define cmdidPropertiesWindow		235
#define cmdidTaskListWindow		236
#define cmdidOutputWindow		237
#define cmdidObjectBrowser		238
#define cmdidDocOutlineWindow	239
#define cmdidImmediateWindow	240
#define cmdidWatchWindow		241
#define cmdidLocalsWindow		242
#define cmdidCallStack			243
#define cmdidAutosWindow		cmdidDebugReserved1
#define cmdidThisWindow			cmdidDebugReserved2

// ids on project menu
#define cmdidAddNewItem			220
#define cmdidAddExistingItem		244
#define cmdidNewFolder			245
#define cmdidSetStartupProject		246
#define cmdidProjectSettings		247
#define cmdidProjectReferences          367

// ids on the debug menu
#define cmdidStepInto			248
#define cmdidStepOver			249
#define cmdidStepOut			250
#define cmdidRunToCursor		251
#define cmdidAddWatch			252
#define cmdidEditWatch			253
#define cmdidQuickWatch                 254

#define cmdidToggleBreakpoint		255
#define cmdidClearBreakpoints		256
#define cmdidShowBreakpoints		257
#define cmdidSetNextStatement		258
#define cmdidShowNextStatement		259
#define cmdidEditBreakpoint             260
#define cmdidDetachDebugger             262

// ids on the tools menu
#define cmdidCustomizeKeyboard		263
#define cmdidToolsOptions		264

// ids on the windows menu
#define cmdidNewWindow			265
#define cmdidSplit			266
#define cmdidCascade			267
#define cmdidTileHorz			268
#define cmdidTileVert			269

// ids on the help menu
#define cmdidTechSupport		270

// NOTE cmdidAbout and cmdidDebugOptions must be consecutive
//      cmd after cmdidDebugOptions (ie 273) must not be used
#define cmdidAbout			271
#define cmdidDebugOptions		272

// ids on the watch context menu
// CollapseWatch appears as 'Collapse Parent', on any
// non-top-level item
#define cmdidDeleteWatch		274
#define cmdidCollapseWatch		275
// ids 276, 277, 278, 279, 280 are in use
// below 
// ids on the property browser context menu
#define cmdidPbrsToggleStatus		282
#define cmdidPropbrsHide		283

// ids on the docking context menu
#define cmdidDockingView		284
#define cmdidHideActivePane		285
// ids for window selection via keyboard
//#define cmdidPaneNextPane		316 (listed below in order)
//#define cmdidPanePrevPane		317 (listed below in order)
#define cmdidPaneNextTab		286
#define cmdidPanePrevTab		287
#define cmdidPaneCloseToolWindow	288
#define cmdidPaneActivateDocWindow	289
#define cmdidDockingViewMDI		290
#define cmdidDockingViewFloater		291
#define cmdidAutoHideWindow		292
#define cmdidMoveToDropdownBar          293
#define cmdidFindCmd                    294 // internal Find commands
#define cmdidStart			295
#define cmdidRestart			296

#define cmdidAddinManager		297

#define cmdidMultiLevelUndoList		298
#define cmdidMultiLevelRedoList		299

#define cmdidToolboxAddTab		300
#define cmdidToolboxDeleteTab		301
#define cmdidToolboxRenameTab		302  
#define cmdidToolboxTabMoveUp		303
#define cmdidToolboxTabMoveDown		304
#define cmdidToolboxRenameItem		305
#define cmdidToolboxListView		306
//(below) cmdidSearchSetCombo		307

#define cmdidWindowUIGetList		308
#define cmdidInsertValuesQuery		309

#define cmdidShowProperties		310

#define cmdidThreadSuspend		311
#define cmdidThreadResume		312
#define cmdidThreadSetFocus		313
#define cmdidDisplayRadix		314

#define cmdidOpenProjectItem		315

#define cmdidPaneNextPane		316
#define cmdidPanePrevPane		317

#define cmdidClearPane			318
#define cmdidGotoErrorTag		319

#define cmdidTaskListSortByCategory	320
#define cmdidTaskListSortByFileLine	321
#define cmdidTaskListSortByPriority	322
#define cmdidTaskListSortByDefaultSort  323
#define cmdidTaskListShowTooltip        324
#define cmdidTaskListFilterByNothing	325
#define cmdidCancelEZDrag               326
#define cmdidTaskListFilterByCategoryCompiler	327
#define cmdidTaskListFilterByCategoryComment	328

#define cmdidToolboxAddItem		329
#define cmdidToolboxReset		330

#define cmdidSaveProjectItem		331
#define cmdidSaveOptions                959
#define cmdidViewForm			332
#define cmdidViewCode			333
#define cmdidPreviewInBrowser		334
#define cmdidBrowseWith			336
#define cmdidSearchSetCombo		307
#define cmdidSearchCombo		337
#define cmdidEditLabel	  		338
#define cmdidExceptions         339
#define cmdidDefineViews		340

#define cmdidToggleSelMode		341
#define cmdidToggleInsMode		342

#define cmdidLoadUnloadedProject	343
#define cmdidUnloadLoadedProject	344

// ids on the treegrids (watch/local/threads/stack)
#define cmdidElasticColumn	345
#define cmdidHideColumn			346

#define cmdidTaskListPreviousView	347
#define cmdidZoomDialog			348

// find/replace options
#define cmdidFindHiddenText             349
#define cmdidFindMatchCase              350
#define cmdidFindWholeWord              351
#define cmdidFindSimplePattern          276
#define cmdidFindRegularExpression      352
#define cmdidFindBackwards              353
#define cmdidFindInSelection            354
#define cmdidFindStop                   355
// UNUSED                               356
#define cmdidFindInFiles                277
#define cmdidReplaceInFiles             278
#define cmdidNextLocation               279 // next item in task list, find in files results, etc.
#define cmdidPreviousLocation           280 // prev item "

#define cmdidTaskListNextError				357
#define cmdidTaskListPrevError				358
#define cmdidTaskListFilterByCategoryUser		359
#define cmdidTaskListFilterByCategoryShortcut		360
#define cmdidTaskListFilterByCategoryHTML		361
#define cmdidTaskListFilterByCurrentFile		362
#define cmdidTaskListFilterByChecked			363
#define cmdidTaskListFilterByUnchecked			364
#define cmdidTaskListSortByDescription			365
#define cmdidTaskListSortByChecked			366

// 367 is used above in cmdidProjectReferences
#define cmdidStartNoDebug		368
// 369 is used above in cmdidLockControls

#define cmdidFindNext                   370
#define cmdidFindPrev                   371
#define cmdidFindSelectedNext           372
#define cmdidFindSelectedPrev           373
#define cmdidSearchGetList              374
#define cmdidInsertBreakpoint		375
#define cmdidEnableBreakpoint		376
#define cmdidF1Help			377

//UNUSED 378-396

#define cmdidMoveToNextEZCntr           384
#define cmdidMoveToPreviousEZCntr       393

#define cmdidProjectProperties          396
#define cmdidPropSheetOrProperties	397

// NOTE - the next items are debug only !!
#define cmdidTshellStep                 398
#define cmdidTshellRun                  399

// marker commands on the codewin menu
#define cmdidMarkerCmd0                 400
#define cmdidMarkerCmd1                 401
#define cmdidMarkerCmd2                 402
#define cmdidMarkerCmd3                 403
#define cmdidMarkerCmd4                 404
#define cmdidMarkerCmd5                 405
#define cmdidMarkerCmd6                 406
#define cmdidMarkerCmd7                 407
#define cmdidMarkerCmd8                 408
#define cmdidMarkerCmd9                 409
#define cmdidMarkerLast                 409
#define cmdidMarkerEnd                  410 // list terminator reserved

// user-invoked project reload and unload
#define cmdidReloadProject              412
#define cmdidUnloadProject              413

#define cmdidNewBlankSolution           414
#define cmdidSelectProjectTemplate      415

// document outline commands
#define cmdidDetachAttachOutline		420
#define cmdidShowHideOutline			421
#define cmdidSyncOutline				422

#define cmdidRunToCallstCursor          423
#define cmdidNoCmdsAvailable		424

#define cmdidContextWindow              427
#define cmdidAlias			428
#define cmdidGotoCommandLine		429
#define cmdidEvaluateExpression		430
#define cmdidImmediateMode		431
#define cmdidEvaluateStatement		432

#define cmdidFindResultWindow1  433
#define cmdidFindResultWindow2  434

// 500 is used above in cmdidFontNameGetList
// 501 is used above in cmdidFontSizeGetList

// ids on the window menu - these must be sequential ie window1-morewind
#define cmdidWindow1			570
#define cmdidWindow2			571
#define cmdidWindow3			572
#define cmdidWindow4			573
#define cmdidWindow5			574
#define cmdidWindow6			575
#define cmdidWindow7			576
#define cmdidWindow8			577
#define cmdidWindow9			578
#define cmdidWindow10			579
#define cmdidWindow11			580
#define cmdidWindow12			581
#define cmdidWindow13			582
#define cmdidWindow14			583
#define cmdidWindow15			584
#define cmdidWindow16			585
#define cmdidWindow17			586
#define cmdidWindow18			587
#define cmdidWindow19			588
#define cmdidWindow20			589
#define cmdidWindow21			590
#define cmdidWindow22			591
#define cmdidWindow23			592
#define cmdidWindow24			593
#define cmdidWindow25			594   // note cmdidWindow25 is unused on purpose!
#define cmdidMoreWindows		595

#define cmdidAutoHideAllWindows		597  
#define cmdidTaskListTaskHelp		598

#define cmdidClassView			599

#define cmdidMRUProj1			600
#define cmdidMRUProj2			601
#define cmdidMRUProj3			602
#define cmdidMRUProj4			603
#define cmdidMRUProj5			604
#define cmdidMRUProj6			605
#define cmdidMRUProj7			606
#define cmdidMRUProj8			607
#define cmdidMRUProj9			608
#define cmdidMRUProj10			609
#define cmdidMRUProj11			610
#define cmdidMRUProj12			611
#define cmdidMRUProj13			612
#define cmdidMRUProj14			613
#define cmdidMRUProj15			614
#define cmdidMRUProj16			615
#define cmdidMRUProj17			616
#define cmdidMRUProj18			617
#define cmdidMRUProj19			618
#define cmdidMRUProj20			619
#define cmdidMRUProj21			620
#define cmdidMRUProj22			621
#define cmdidMRUProj23			622
#define cmdidMRUProj24			623
#define cmdidMRUProj25			624  // note cmdidMRUProj25 is unused on purpose!

#define cmdidSplitNext			625
#define cmdidSplitPrev			626

#define cmdidCloseAllDocuments		627
#define cmdidNextDocument		628
#define cmdidPrevDocument		629

#define cmdidTool1			630  // note cmdidTool1 - cmdidTool24 must be
#define cmdidTool2			631  // consecutive
#define cmdidTool3			632
#define cmdidTool4			633
#define cmdidTool5			634
#define cmdidTool6			635
#define cmdidTool7			636
#define cmdidTool8			637
#define cmdidTool9			638
#define cmdidTool10			639
#define cmdidTool11			640
#define cmdidTool12			641
#define cmdidTool13			642
#define cmdidTool14			643
#define cmdidTool15			644
#define cmdidTool16			645
#define cmdidTool17			646
#define cmdidTool18			647
#define cmdidTool19			648
#define cmdidTool20			649
#define cmdidTool21			650
#define cmdidTool22			651
#define cmdidTool23			652
#define cmdidTool24			653
#define cmdidExternalCommands		654

#define cmdidPasteNextTBXCBItem		655
#define cmdidToolboxShowAllTabs		656
#define cmdidProjectDependencies	657
#define cmdidCloseDocument		658
#define cmdidToolboxSortItems		659

#define cmdidViewBarView1		660   //UNUSED
#define cmdidViewBarView2		661   //UNUSED
#define cmdidViewBarView3		662   //UNUSED
#define cmdidViewBarView4		663   //UNUSED
#define cmdidViewBarView5		664   //UNUSED
#define cmdidViewBarView6		665   //UNUSED
#define cmdidViewBarView7		666   //UNUSED
#define cmdidViewBarView8		667   //UNUSED
#define cmdidViewBarView9		668   //UNUSED
#define cmdidViewBarView10		669   //UNUSED
#define cmdidViewBarView11		670   //UNUSED
#define cmdidViewBarView12		671   //UNUSED
#define cmdidViewBarView13		672   //UNUSED
#define cmdidViewBarView14		673   //UNUSED
#define cmdidViewBarView15		674   //UNUSED
#define cmdidViewBarView16		675   //UNUSED
#define cmdidViewBarView17		676   //UNUSED
#define cmdidViewBarView18		677   //UNUSED
#define cmdidViewBarView19		678   //UNUSED
#define cmdidViewBarView20		679   //UNUSED
#define cmdidViewBarView21		680   //UNUSED
#define cmdidViewBarView22		681   //UNUSED
#define cmdidViewBarView23		682   //UNUSED
#define cmdidViewBarView24		683   //UNUSED

#define cmdidSolutionCfg		684
#define cmdidSolutionCfgGetList		685

//
// Schema table commands:
// All invoke table property dialog and select appropriate page.
//
#define cmdidManageIndexes			675
#define cmdidManageRelationships	676
#define cmdidManageConstraints		677

#define cmdidTaskListCustomView1        678
#define cmdidTaskListCustomView2        679
#define cmdidTaskListCustomView3        680
#define cmdidTaskListCustomView4        681
#define cmdidTaskListCustomView5        682
#define cmdidTaskListCustomView6        683
#define cmdidTaskListCustomView7        684
#define cmdidTaskListCustomView8        685
#define cmdidTaskListCustomView9        686
#define cmdidTaskListCustomView10       687
#define cmdidTaskListCustomView11       688
#define cmdidTaskListCustomView12       689
#define cmdidTaskListCustomView13       690
#define cmdidTaskListCustomView14       691
#define cmdidTaskListCustomView15       692
#define cmdidTaskListCustomView16       693  
#define cmdidTaskListCustomView17       694
#define cmdidTaskListCustomView18       695
#define cmdidTaskListCustomView19       696
#define cmdidTaskListCustomView20       697
#define cmdidTaskListCustomView21       698
#define cmdidTaskListCustomView22       699
#define cmdidTaskListCustomView23       700
#define cmdidTaskListCustomView24       701
#define cmdidTaskListCustomView25       702
#define cmdidTaskListCustomView26       703 
#define cmdidTaskListCustomView27       704
#define cmdidTaskListCustomView28       705
#define cmdidTaskListCustomView29       706
#define cmdidTaskListCustomView30       707
#define cmdidTaskListCustomView31       708
#define cmdidTaskListCustomView32       709
#define cmdidTaskListCustomView33       710
#define cmdidTaskListCustomView34       711
#define cmdidTaskListCustomView35       712
#define cmdidTaskListCustomView36       713
#define cmdidTaskListCustomView37       714
#define cmdidTaskListCustomView38       715
#define cmdidTaskListCustomView39       716
#define cmdidTaskListCustomView40       717
#define cmdidTaskListCustomView41       718
#define cmdidTaskListCustomView42       719
#define cmdidTaskListCustomView43       720
#define cmdidTaskListCustomView44       721
#define cmdidTaskListCustomView45       722
#define cmdidTaskListCustomView46       723
#define cmdidTaskListCustomView47       724
#define cmdidTaskListCustomView48       725
#define cmdidTaskListCustomView49       726
#define cmdidTaskListCustomView50       727 //not used on purpose, ends the list

#define cmdidWhiteSpace                 728

#define cmdidCommandWindow		729
#define cmdidCommandWindowMarkMode	730
#define cmdidLogCommandWindow		731

#define cmdidShell			732

#define cmdidSingleChar           733
#define cmdidZeroOrMore           734
#define cmdidOneOrMore            735
#define cmdidBeginLine            736
#define cmdidEndLine              737
#define cmdidBeginWord            738
#define cmdidEndWord              739
#define cmdidCharInSet            740
#define cmdidCharNotInSet         741
#define cmdidOr                   742
#define cmdidEscape               743
#define cmdidTagExp               744

// Regex builder context help menu commands
#define cmdidPatternMatchHelp       745
#define cmdidRegExList              746

#define cmdidDebugReserved1         747
#define cmdidDebugReserved2         748
#define cmdidDebugReserved3         749
//USED ABOVE                        750
//USED ABOVE                        751
//USED ABOVE                        752
//USED ABOVE                        753

//Regex builder wildcard menu commands
#define cmdidWildZeroOrMore         754
#define cmdidWildSingleChar         755
#define cmdidWildSingleDigit        756
#define cmdidWildCharInSet          757
#define cmdidWildCharNotInSet       758

#define cmdidFindWhatText           759
#define cmdidTaggedExp1             760
#define cmdidTaggedExp2             761
#define cmdidTaggedExp3             762
#define cmdidTaggedExp4             763
#define cmdidTaggedExp5             764
#define cmdidTaggedExp6             765
#define cmdidTaggedExp7             766
#define cmdidTaggedExp8             767
#define cmdidTaggedExp9             768		                    

#define cmdidEditorWidgetClick      769 // param 0 is the moniker as VT_BSTR, param 1 is the buffer line as VT_I4, and param 2 is the buffer index as VT_I4
#define cmdidCmdWinUpdateAC         770

#define cmdidSlnCfgMgr                  771

#define cmdidAddNewProject		772
#define cmdidAddExistingProject		773
#define cmdidAddExistingProjFromWeb	774

#define cmdidAutoHideContext1		776
#define cmdidAutoHideContext2		777
#define cmdidAutoHideContext3		778
#define cmdidAutoHideContext4		779
#define cmdidAutoHideContext5		780
#define cmdidAutoHideContext6		781
#define cmdidAutoHideContext7		782
#define cmdidAutoHideContext8		783
#define cmdidAutoHideContext9		784
#define cmdidAutoHideContext10		785
#define cmdidAutoHideContext11		786
#define cmdidAutoHideContext12		787
#define cmdidAutoHideContext13		788
#define cmdidAutoHideContext14		789
#define cmdidAutoHideContext15		790
#define cmdidAutoHideContext16		791
#define cmdidAutoHideContext17		792
#define cmdidAutoHideContext18		793
#define cmdidAutoHideContext19		794
#define cmdidAutoHideContext20		795
#define cmdidAutoHideContext21		796
#define cmdidAutoHideContext22		797
#define cmdidAutoHideContext23		798
#define cmdidAutoHideContext24		799
#define cmdidAutoHideContext25		800
#define cmdidAutoHideContext26		801
#define cmdidAutoHideContext27		802
#define cmdidAutoHideContext28		803
#define cmdidAutoHideContext29		804
#define cmdidAutoHideContext30		805
#define cmdidAutoHideContext31		806
#define cmdidAutoHideContext32		807
#define cmdidAutoHideContext33		808  // must remain unused

#define cmdidShellNavBackward           809
#define cmdidShellNavForward            810

#define cmdidShellNavigate1		811
#define cmdidShellNavigate2		812
#define cmdidShellNavigate3		813
#define cmdidShellNavigate4		814
#define cmdidShellNavigate5		815
#define cmdidShellNavigate6		816
#define cmdidShellNavigate7		817
#define cmdidShellNavigate8		818
#define cmdidShellNavigate9		819
#define cmdidShellNavigate10		820
#define cmdidShellNavigate11		821
#define cmdidShellNavigate12		822
#define cmdidShellNavigate13		823
#define cmdidShellNavigate14		824
#define cmdidShellNavigate15		825
#define cmdidShellNavigate16		826
#define cmdidShellNavigate17		827
#define cmdidShellNavigate18		828
#define cmdidShellNavigate19		829
#define cmdidShellNavigate20		830
#define cmdidShellNavigate21		831
#define cmdidShellNavigate22		832
#define cmdidShellNavigate23		833
#define cmdidShellNavigate24		834
#define cmdidShellNavigate25		835
#define cmdidShellNavigate26		836
#define cmdidShellNavigate27		837
#define cmdidShellNavigate28		838
#define cmdidShellNavigate29		839
#define cmdidShellNavigate30		840
#define cmdidShellNavigate31		841
#define cmdidShellNavigate32		842
#define cmdidShellNavigate33		843  // must remain unused

#define cmdidShellWindowNavigate1	844
#define cmdidShellWindowNavigate2	845
#define cmdidShellWindowNavigate3	846
#define cmdidShellWindowNavigate4	847
#define cmdidShellWindowNavigate5	848
#define cmdidShellWindowNavigate6	849
#define cmdidShellWindowNavigate7	850
#define cmdidShellWindowNavigate8	851
#define cmdidShellWindowNavigate9	852
#define cmdidShellWindowNavigate10	853
#define cmdidShellWindowNavigate11	854
#define cmdidShellWindowNavigate12	855
#define cmdidShellWindowNavigate13	856
#define cmdidShellWindowNavigate14	857
#define cmdidShellWindowNavigate15	858
#define cmdidShellWindowNavigate16	859
#define cmdidShellWindowNavigate17	860
#define cmdidShellWindowNavigate18	861
#define cmdidShellWindowNavigate19	862
#define cmdidShellWindowNavigate20	863
#define cmdidShellWindowNavigate21	864
#define cmdidShellWindowNavigate22	865
#define cmdidShellWindowNavigate23	866
#define cmdidShellWindowNavigate24	867
#define cmdidShellWindowNavigate25	868
#define cmdidShellWindowNavigate26	869
#define cmdidShellWindowNavigate27	870
#define cmdidShellWindowNavigate28	871
#define cmdidShellWindowNavigate29	872
#define cmdidShellWindowNavigate30	873
#define cmdidShellWindowNavigate31	874
#define cmdidShellWindowNavigate32	875
#define cmdidShellWindowNavigate33	876  // must remain unused

// ObjectSearch cmds
#define cmdidOBSDoFind                  877
#define cmdidOBSMatchCase               878
#define cmdidOBSMatchSubString          879
#define cmdidOBSMatchWholeWord          880
#define cmdidOBSMatchPrefix             881

// build cmds
#define cmdidBuildSln                   882
#define cmdidRebuildSln                 883
#define cmdidDeploySln                  884
#define cmdidCleanSln                   885

#define cmdidBuildSel                   886
#define cmdidRebuildSel                 887
#define cmdidDeploySel                  888
#define cmdidCleanSel                   889

#define cmdidCancelBuild                890
#define cmdidBatchBuildDlg              891

#define cmdidBuildCtx                   892
#define cmdidRebuildCtx                 893
#define cmdidDeployCtx                  894
#define cmdidCleanCtx                   895

#define cmdidQryManageIndexes		896
#define cmdidPrintDefault               897		// quick print
#define cmdidBrowseDoc                  898
#define cmdidShowStartPage	        899

#define cmdidMRUFile1			900
#define cmdidMRUFile2			901
#define cmdidMRUFile3			902
#define cmdidMRUFile4			903
#define cmdidMRUFile5			904
#define cmdidMRUFile6			905
#define cmdidMRUFile7			906
#define cmdidMRUFile8			907
#define cmdidMRUFile9			908
#define cmdidMRUFile10			909
#define cmdidMRUFile11			910
#define cmdidMRUFile12			911
#define cmdidMRUFile13			912
#define cmdidMRUFile14			913
#define cmdidMRUFile15			914
#define cmdidMRUFile16			915
#define cmdidMRUFile17			916
#define cmdidMRUFile18			917
#define cmdidMRUFile19			918
#define cmdidMRUFile20			919
#define cmdidMRUFile21			920
#define cmdidMRUFile22			921
#define cmdidMRUFile23			922
#define cmdidMRUFile24			923
#define cmdidMRUFile25			924  // note cmdidMRUFile25 is unused on purpose!

//External Tools Context Menu Commands
// continued at 1109
#define cmdidExtToolsCurPath            925
#define cmdidExtToolsCurDir             926
#define cmdidExtToolsCurFileName        927
#define cmdidExtToolsCurExtension       928
#define cmdidExtToolsProjDir            929
#define cmdidExtToolsProjFileName       930
#define cmdidExtToolsSlnDir             931
#define cmdidExtToolsSlnFileName        932


// Object Browsing & ClassView cmds
// Shared shell cmds (for accessing Object Browsing functionality)
#define cmdidGotoDefn			935
#define cmdidGotoDecl			936
#define cmdidBrowseDefn			937
#define cmdidSyncClassView              938
#define cmdidShowMembers		939
#define cmdidShowBases			940
#define cmdidShowDerived		941
#define cmdidShowDefns			942
#define cmdidShowRefs			943
#define cmdidShowCallers		944
#define cmdidShowCallees		945

#define cmdidAddClass                   946
#define cmdidAddNestedClass             947
#define cmdidAddInterface               948
#define cmdidAddMethod                  949
#define cmdidAddProperty                950
#define cmdidAddEvent                   951
#define cmdidAddVariable                952
#define cmdidImplementInterface         953
#define cmdidOverride                   954
#define cmdidAddFunction                955
#define cmdidAddConnectionPoint         956
#define cmdidAddIndexer                 957

#define cmdidBuildOrder                 958
//959 used above for cmdidSaveOptions

// Object Browser Tool Specific cmds
#define cmdidOBShowHidden               960
#define cmdidOBEnableGrouping           961
#define cmdidOBSetGroupingCriteria      962
#define cmdidOBBack                     963
#define cmdidOBForward                  964
#define cmdidOBShowPackages             965
#define cmdidOBSearchCombo              966
#define cmdidOBSearchOptWholeWord       967 
#define cmdidOBSearchOptSubstring       968 
#define cmdidOBSearchOptPrefix          969 
#define cmdidOBSearchOptCaseSensitive   970

// ClassView Tool Specific cmds
#define cmdidCVGroupingNone             971
#define cmdidCVGroupingSortOnly		972
#define cmdidCVGroupingGrouped		973
#define cmdidCVShowPackages		974
#define cmdidCVNewFolder                975
#define cmdidCVGroupingSortAccess       976

#define cmdidObjectSearch               977
#define cmdidObjectSearchResults        978

// Further Obj Browsing cmds at 1095

// build cascade menus
#define cmdidBuild1                     979
#define cmdidBuild2                     980
#define cmdidBuild3                     981
#define cmdidBuild4                     982
#define cmdidBuild5                     983
#define cmdidBuild6                     984
#define cmdidBuild7                     985
#define cmdidBuild8                     986
#define cmdidBuild9                     987
#define cmdidBuildLast                  988

#define cmdidRebuild1                   989
#define cmdidRebuild2                   990
#define cmdidRebuild3                   991
#define cmdidRebuild4                   992
#define cmdidRebuild5                   993
#define cmdidRebuild6                   994
#define cmdidRebuild7                   995
#define cmdidRebuild8                   996
#define cmdidRebuild9                   997
#define cmdidRebuildLast                998

#define cmdidClean1                     999
#define cmdidClean2                     1000
#define cmdidClean3                     1001
#define cmdidClean4                     1002
#define cmdidClean5                     1003
#define cmdidClean6                     1004
#define cmdidClean7                     1005
#define cmdidClean8                     1006
#define cmdidClean9                     1007
#define cmdidCleanLast                  1008

#define cmdidDeploy1                    1009
#define cmdidDeploy2                    1010
#define cmdidDeploy3                    1011
#define cmdidDeploy4                    1012
#define cmdidDeploy5                    1013
#define cmdidDeploy6                    1014
#define cmdidDeploy7                    1015
#define cmdidDeploy8                    1016
#define cmdidDeploy9                    1017
#define cmdidDeployLast                 1018

#define cmdidBuildProjPicker            1019
#define cmdidRebuildProjPicker          1020
#define cmdidCleanProjPicker            1021
#define cmdidDeployProjPicker           1022
#define cmdidResourceView               1023

#define cmdidShowHomePage               1024
#define cmdidEditMenuIDs                1025

#define cmdidLineBreak                  1026
#define cmdidCPPIdentifier              1027
#define cmdidQuotedString               1028
#define cmdidSpaceOrTab                 1029
#define cmdidInteger                    1030
//unused 1031-1035

#define cmdidCustomizeToolbars          1036
#define cmdidMoveToTop                  1037
#define cmdidWindowHelp	                1038

#define cmdidViewPopup                  1039
#define cmdidCheckMnemonics             1040

#define cmdidPRSortAlphabeticaly        1041
#define cmdidPRSortByCategory           1042

#define cmdidViewNextTab                1043

#define cmdidCheckForUpdates            1044

#define cmdidBrowser1			1045
#define cmdidBrowser2			1046
#define cmdidBrowser3			1047
#define cmdidBrowser4			1048
#define cmdidBrowser5			1049
#define cmdidBrowser6			1050
#define cmdidBrowser7			1051
#define cmdidBrowser8			1052
#define cmdidBrowser9			1053
#define cmdidBrowser10			1054
#define cmdidBrowser11			1055 //note unused on purpose to end list

#define cmdidOpenDropDownOpen           1058
#define cmdidOpenDropDownOpenWith       1059

#define cmdidToolsDebugProcesses        1060

#define cmdidPaneNextSubPane            1062
#define cmdidPanePrevSubPane            1063

#define cmdidMoveFileToProject1         1070
#define cmdidMoveFileToProject2         1071
#define cmdidMoveFileToProject3         1072
#define cmdidMoveFileToProject4         1073
#define cmdidMoveFileToProject5         1074
#define cmdidMoveFileToProject6         1075
#define cmdidMoveFileToProject7         1076
#define cmdidMoveFileToProject8         1077
#define cmdidMoveFileToProject9         1078
#define cmdidMoveFileToProjectLast      1079 // unused in order to end list
#define cmdidMoveFileToProjectPick      1081

#define cmdidDefineSubset               1095
#define cmdidSubsetCombo                1096
#define cmdidSubsetGetList              1097
#define cmdidOBSortObjectsAlpha         1098
#define cmdidOBSortObjectsType          1099
#define cmdidOBSortObjectsAccess        1100
#define cmdidOBGroupObjectsType         1101
#define cmdidOBGroupObjectsAccess       1102
#define cmdidOBSortMembersAlpha         1103
#define cmdidOBSortMembersType          1104
#define cmdidOBSortMembersAccess        1105

#define cmdidPopBrowseContext           1106
#define cmdidGotoRef			1107
#define cmdidOBSLookInReferences        1108

#define cmdidExtToolsTargetPath         1109
#define cmdidExtToolsTargetDir          1110
#define cmdidExtToolsTargetFileName     1111
#define cmdidExtToolsTargetExtension    1112
#define cmdidExtToolsCurLine            1113
#define cmdidExtToolsCurCol             1114
#define cmdidExtToolsCurText            1115

#define cmdidBrowseNext                 1116
#define cmdidBrowsePrev                 1117
#define cmdidBrowseUnload		1118
#define cmdidQuickObjectSearch          1119
#define cmdidExpandAll                  1120

#define cmdidStandardMax                1500

///////////////////////////////////////////
//
// cmdidStandardMax is now thought to be
// obsolete. Any new shell commands should
// be added to the end of StandardCommandSet2K
// which appears below.
//
// If you are not adding shell commands,
// you shouldn't be doing it in this file! 
//
///////////////////////////////////////////


#define cmdidFormsFirst           0x00006000

#define cmdidFormsLast           0x00006FFF

#define cmdidVBEFirst           0x00008000   


#define cmdidZoom200		    0x00008002
#define cmdidZoom150		    0x00008003
#define cmdidZoom100		    0x00008004
#define cmdidZoom75		    0x00008005
#define cmdidZoom50		    0x00008006
#define cmdidZoom25		    0x00008007
#define cmdidZoom10		    0x00008010


#define cmdidVBELast           0x00009FFF 
                                         
#define cmdidSterlingFirst           0x0000A000                                    
#define cmdidSterlingLast           0x0000BFFF                                     

#define uieventidFirst                   0xC000
#define uieventidSelectRegion      0xC001
#define uieventidDrop                  0xC002
#define uieventidLast                   0xDFFF




//////////////////////////////////////////////////////////////////
//
// The following commands form CMDSETID_StandardCommandSet2k.
// Note that commands up to ECMD_FINAL are standard editor
// commands and have been moved from editcmd.h.
// NOTE that all these commands are shareable and may be used
// in any appropriate menu.
//
//////////////////////////////////////////////////////////////////
//
// Shareable standard editor commands
//
#define ECMD_TYPECHAR                1
#define ECMD_BACKSPACE               2
#define ECMD_RETURN                  3
#define ECMD_TAB                     4
#define ECMD_BACKTAB                 5
#define ECMD_DELETE                  6
#define ECMD_LEFT                    7
#define ECMD_LEFT_EXT                8
#define ECMD_RIGHT                   9
#define ECMD_RIGHT_EXT              10
#define ECMD_UP                     11
#define ECMD_UP_EXT                 12
#define ECMD_DOWN                   13
#define ECMD_DOWN_EXT               14
#define ECMD_HOME                   15
#define ECMD_HOME_EXT               16
#define ECMD_END                    17
#define ECMD_END_EXT                18
#define ECMD_BOL                    19
#define ECMD_BOL_EXT                20
#define ECMD_FIRSTCHAR              21
#define ECMD_FIRSTCHAR_EXT          22
#define ECMD_EOL                    23
#define ECMD_EOL_EXT                24
#define ECMD_LASTCHAR               25
#define ECMD_LASTCHAR_EXT           26
#define ECMD_PAGEUP                 27
#define ECMD_PAGEUP_EXT             28
#define ECMD_PAGEDN                 29
#define ECMD_PAGEDN_EXT             30
#define ECMD_TOPLINE                31
#define ECMD_TOPLINE_EXT            32
#define ECMD_BOTTOMLINE             33
#define ECMD_BOTTOMLINE_EXT         34
#define ECMD_SCROLLUP               35
#define ECMD_SCROLLDN               36
#define ECMD_SCROLLPAGEUP           37
#define ECMD_SCROLLPAGEDN           38
#define ECMD_SCROLLLEFT             39
#define ECMD_SCROLLRIGHT            40
#define ECMD_SCROLLBOTTOM           41
#define ECMD_SCROLLCENTER           42
#define ECMD_SCROLLTOP              43
#define ECMD_SELECTALL              44
#define ECMD_SELTABIFY              45
#define ECMD_SELUNTABIFY            46
#define ECMD_SELLOWCASE             47
#define ECMD_SELUPCASE              48
#define ECMD_SELTOGGLECASE          49
#define ECMD_SELTITLECASE           50
#define ECMD_SELSWAPANCHOR          51
#define ECMD_GOTOLINE               52
#define ECMD_GOTOBRACE              53
#define ECMD_GOTOBRACE_EXT          54
#define ECMD_GOBACK                 55
#define ECMD_SELECTMODE             56
#define ECMD_TOGGLE_OVERTYPE_MODE   57
#define ECMD_CUT                    58
#define ECMD_COPY                   59
#define ECMD_PASTE                  60
#define ECMD_CUTLINE                61
#define ECMD_DELETELINE             62
#define ECMD_DELETEBLANKLINES       63
#define ECMD_DELETEWHITESPACE       64
#define ECMD_DELETETOEOL            65
#define ECMD_DELETETOBOL            66
#define ECMD_OPENLINEABOVE          67
#define ECMD_OPENLINEBELOW          68
#define ECMD_INDENT                 69
#define ECMD_UNINDENT               70
#define ECMD_UNDO                   71
#define ECMD_UNDONOMOVE             72
#define ECMD_REDO                   73
#define ECMD_REDONOMOVE             74
#define ECMD_DELETEALLTEMPBOOKMARKS 75
#define ECMD_TOGGLETEMPBOOKMARK     76
#define ECMD_GOTONEXTBOOKMARK       77
#define ECMD_GOTOPREVBOOKMARK       78
#define ECMD_FIND                   79
#define ECMD_REPLACE                80
#define ECMD_REPLACE_ALL            81
#define ECMD_FINDNEXT               82
#define ECMD_FINDNEXTWORD           83
#define ECMD_FINDPREV               84
#define ECMD_FINDPREVWORD           85
#define ECMD_FINDAGAIN              86
#define ECMD_TRANSPOSECHAR          87
#define ECMD_TRANSPOSEWORD          88
#define ECMD_TRANSPOSELINE          89
#define ECMD_SELECTCURRENTWORD      90
#define ECMD_DELETEWORDRIGHT        91
#define ECMD_DELETEWORDLEFT         92
#define ECMD_WORDPREV               93
#define ECMD_WORDPREV_EXT           94
#define ECMD_WORDNEXT               96
#define ECMD_WORDNEXT_EXT           97
#define ECMD_COMMENTBLOCK           98
#define ECMD_UNCOMMENTBLOCK         99
#define ECMD_SETREPEATCOUNT         100
#define ECMD_WIDGETMARGIN_LBTNDOWN  101
#define ECMD_SHOWCONTEXTMENU        102
#define ECMD_CANCEL                 103
#define ECMD_PARAMINFO              104
#define ECMD_TOGGLEVISSPACE         105
#define ECMD_TOGGLECARETPASTEPOS    106
#define ECMD_COMPLETEWORD           107
#define ECMD_SHOWMEMBERLIST         108
#define ECMD_FIRSTNONWHITEPREV      109
#define ECMD_FIRSTNONWHITENEXT      110
#define ECMD_HELPKEYWORD            111
#define ECMD_FORMATSELECTION	    112
#define ECMD_OPENURL    	    113     
#define ECMD_INSERTFILE 	    114
#define ECMD_TOGGLESHORTCUT	    115
#define ECMD_QUICKINFO              116
#define ECMD_LEFT_EXT_COL           117
#define ECMD_RIGHT_EXT_COL          118
#define ECMD_UP_EXT_COL             119
#define ECMD_DOWN_EXT_COL           120
#define ECMD_TOGGLEWORDWRAP         121
#define ECMD_ISEARCH                122
#define ECMD_ISEARCHBACK            123
#define ECMD_BOL_EXT_COL            124
#define ECMD_EOL_EXT_COL            125
#define ECMD_WORDPREV_EXT_COL       126
#define ECMD_WORDNEXT_EXT_COL       127
#define ECMD_OUTLN_HIDE_SELECTION   128
#define ECMD_OUTLN_TOGGLE_CURRENT   129
#define ECMD_OUTLN_TOGGLE_ALL       130
#define ECMD_OUTLN_STOP_HIDING_ALL  131
#define ECMD_OUTLN_STOP_HIDING_CURRENT 132
#define ECMD_OUTLN_COLLAPSE_TO_DEF  133
#define ECMD_DOUBLECLICK            134
#define ECMD_EXTERNALLY_HANDLED_WIDGET_CLICK 135
#define ECMD_COMMENT_BLOCK          136
#define ECMD_UNCOMMENT_BLOCK        137
#define ECMD_OPENFILE               138
#define ECMD_NAVIGATETOURL          139

// For editor internal use only
#define ECMD_HANDLEIMEMESSAGE       140

#define ECMD_SELTOGOBACK            141
#define ECMD_COMPLETION_HIDE_ADVANCED 142

#define ECMD_FORMATDOCUMENT         143
#define ECMD_OUTLN_START_AUTOHIDING 144

// Last Standard Editor Command (+1)
#define ECMD_FINAL                  145

///////////////////////////////////////////////////////////////
// Some new commands created during CTC file rationalisation
///////////////////////////////////////////////////////////////
#define ECMD_STOP                   220
#define ECMD_REVERSECANCEL          221
#define ECMD_SLNREFRESH             222
#define ECMD_SAVECOPYOFITEMAS       223
//
// Shareable commands originating in the HTML editor
//
#define ECMD_NEWELEMENT             224
#define ECMD_NEWATTRIBUTE           225
#define ECMD_NEWCOMPLEXTYPE         226
#define ECMD_NEWSIMPLETYPE          227
#define ECMD_NEWGROUP               228
#define ECMD_NEWATTRIBUTEGROUP      229
#define ECMD_NEWKEY                 230
#define ECMD_NEWRELATION            231
#define ECMD_EDITKEY                232
#define ECMD_EDITRELATION           233
#define ECMD_MAKETYPEGLOBAL         234
#define ECMD_PREVIEWDATASET         235
#define ECMD_GENERATEDATASET        236
#define ECMD_CREATESCHEMA           237
#define ECMD_LAYOUTINDENT           238
#define ECMD_LAYOUTUNINDENT         239
#define ECMD_REMOVEHANDLER			240
#define ECMD_EDITHANDLER			241
#define ECMD_ADDHANDLER				242
#define ECMD_STYLE                  243
#define ECMD_STYLEGETLIST           244
#define ECMD_FONTSTYLE              245
#define ECMD_FONTSTYLEGETLIST       246
#define ECMD_PASTEASHTML			247
#define ECMD_VIEWBORDERS			248
#define ECMD_VIEWDETAILS			249
#define ECMD_EXPANDCONTROLS			250
#define ECMD_COLLAPSECONTROLS		251
#define ECMD_SHOWSCRIPTONLY			252
#define ECMD_INSERTTABLE			253
#define ECMD_INSERTCOLLEFT			254
#define ECMD_INSERTCOLRIGHT			255
#define ECMD_INSERTROWABOVE			256
#define ECMD_INSERTROWBELOW			257
#define ECMD_DELETETABLE			258
#define ECMD_DELETECOLS				259
#define ECMD_DELETEROWS				260
#define ECMD_SELECTTABLE			261
#define ECMD_SELECTTABLECOL			262
#define ECMD_SELECTTABLEROW			263
#define ECMD_SELECTTABLECELL		264
#define ECMD_MERGECELLS				265
#define ECMD_SPLITCELL				266
#define ECMD_INSERTCELL				267
#define ECMD_DELETECELLS			268
#define ECMD_SEAMLESSFRAME			269
#define ECMD_VIEWFRAME				270
#define ECMD_DELETEFRAME			271
#define ECMD_SETFRAMESOURCE			272
#define ECMD_NEWLEFTFRAME			273
#define ECMD_NEWRIGHTFRAME			274
#define ECMD_NEWTOPFRAME			275
#define ECMD_NEWBOTTOMFRAME			276
#define ECMD_SHOWGRID				277
#define ECMD_SNAPTOGRID				278
#define ECMD_BOOKMARK				279
#define ECMD_HYPERLINK				280
#define ECMD_IMAGE					281
#define ECMD_INSERTFORM				282
#define ECMD_INSERTSPAN				283
#define ECMD_DIV					284
#define ECMD_HTMLCLIENTSCRIPTBLOCK	285
#define ECMD_HTMLSERVERSCRIPTBLOCK	286
#define ECMD_BULLETEDLIST			287
#define ECMD_NUMBEREDLIST			288
#define ECMD_EDITSCRIPT				289
#define ECMD_EDITCODEBEHIND			290
#define ECMD_DOCOUTLINEHTML			291
#define ECMD_DOCOUTLINESCRIPT		292
#define ECMD_RUNATSERVER			293
#define ECMD_WEBFORMSVERBS			294
#define ECMD_WEBFORMSTEMPLATES		295
#define ECMD_ENDTEMPLATE			296
#define ECMD_EDITDEFAULTEVENT		297
#define ECMD_SUPERSCRIPT            298
#define ECMD_SUBSCRIPT              299
#define ECMD_EDITSTYLE              300
#define ECMD_ADDIMAGEHEIGHTWIDTH    301
#define ECMD_REMOVEIMAGEHEIGHTWIDTH 302
#define ECMD_LOCKELEMENT            303
#define ECMD_VIEWSTYLEORGANIZER     304
#define	ECMD_AUTOCLOSEOVERRIDE		305
#define ECMD_NEWANY                 306
#define ECMD_NEWANYATTRIBUTE        307
#define ECMD_DELETEKEY              308
#define ECMD_AUTOARRANGE            309
#define ECMD_VALIDATESCHEMA         310
#define ECMD_NEWFACET               311
#define ECMD_VALIDATEXMLDATA        312
#define ECMD_DOCOUTLINETOGGLE       313
#define ECMD_VALIDATEHTMLDATA       314
#define ECMD_VIEWXMLSCHEMAOVERVIEW  315
//
// Shareable commands originating in the VC project
//
#define ECMD_COMPILE                350
//
#define ECMD_PROJSETTINGS           352
#define ECMD_LINKONLY               353
//
#define ECMD_REMOVE					355
#define ECMD_PROJSTARTDEBUG         356
#define ECMD_PROJSTEPINTO           357
//
//
#define ECMD_UPDATEWEBREF			360
//
#define ECMD_ADDRESOURCE			362
#define ECMD_WEBDEPLOY			    363

#define ECMD_XBOXIMAGE				370
#define ECMD_XBOXDEPLOY				371
//
// Shareable commands originating in the VB and VBA projects
// Note that there are two versions of each command. One
// version is originally from the main (project) menu and the
// other version from a cascading "Add" context menu. The main
// difference between the two commands is that the main menu
// version starts with the text "Add" whereas this is not
// present on the context menu version.
//
#define ECMD_ADDHTMLPAGE            400
#define ECMD_ADDHTMLPAGECTX         401
#define ECMD_ADDMODULE              402
#define ECMD_ADDMODULECTX           403
// unused 404
// unused 405
#define ECMD_ADDWFCFORM             406
// unused 407
// unused 408
// unused 409
#define ECMD_ADDWEBFORM             410
// unused 411
#define ECMD_ADDUSERCONTROL         412
// unused 413 to 425
#define ECMD_ADDDHTMLPAGE           426
// unused 427 to 431
#define ECMD_ADDIMAGEGENERATOR      432
// unused 433
#define ECMD_ADDINHERWFCFORM        434
// unused 435
#define ECMD_ADDINHERCONTROL        436
// unused 437
#define ECMD_ADDWEBUSERCONTROL      438
#define ECMD_BUILDANDBROWSE         439
// unused 440
// unused 441
#define ECMD_ADDTBXCOMPONENT        442
// unused 443
#define ECMD_ADDWEBSERVICE          444
// unused 445
//
// Shareable commands originating in the VFP project
//
#define ECMD_ADDVFPPAGE             500
#define ECMD_SETBREAKPOINT          501
//
// Shareable commands originating in the HELP WORKSHOP project
//
#define ECMD_SHOWALLFILES           600
#define ECMD_ADDTOPROJECT           601
#define ECMD_ADDBLANKNODE           602
#define ECMD_ADDNODEFROMFILE        603
#define ECMD_CHANGEURLFROMFILE      604
#define ECMD_EDITTOPIC              605
#define ECMD_EDITTITLE              606
#define ECMD_MOVENODEUP             607
#define ECMD_MOVENODEDOWN           608
#define ECMD_MOVENODELEFT           609
#define ECMD_MOVENODERIGHT          610
//
// Shareable commands originating in the Deploy project
//
// Note there are two groups of deploy project commands.
// The first group of deploy commands.
#define ECMD_ADDOUTPUT              700
#define ECMD_ADDFILE                701
#define ECMD_MERGEMODULE            702
#define ECMD_ADDCOMPONENTS          703
#define ECMD_LAUNCHINSTALLER        704
#define ECMD_LAUNCHUNINSTALL        705
#define ECMD_LAUNCHORCA             706
#define ECMD_FILESYSTEMEDITOR       707
#define ECMD_REGISTRYEDITOR         708
#define ECMD_FILETYPESEDITOR        709
#define ECMD_USERINTERFACEEDITOR    710
#define ECMD_CUSTOMACTIONSEDITOR    711
#define ECMD_LAUNCHCONDITIONSEDITOR 712
#define ECMD_EDITOR                 713
#define ECMD_EXCLUDE                714
#define ECMD_REFRESHDEPENDENCIES    715
#define ECMD_VIEWOUTPUTS            716
#define ECMD_VIEWDEPENDENCIES       717
#define ECMD_VIEWFILTER             718

//
// The Second group of deploy commands.
// Note that there is a special sub-group in which the relative 
// positions are important (see below)
//
#define ECMD_KEY                    750
#define ECMD_STRING                 751
#define ECMD_BINARY                 752
#define ECMD_DWORD                  753
#define ECMD_KEYSOLO                754
#define ECMD_IMPORT                 755
#define ECMD_FOLDER                 756
#define ECMD_PROJECTOUTPUT          757
#define ECMD_FILE                   758
#define ECMD_ADDMERGEMODULES        759
#define ECMD_CREATESHORTCUT         760
#define ECMD_LARGEICONS             761
#define ECMD_SMALLICONS             762
#define ECMD_LIST                   763
#define ECMD_DETAILS                764
#define ECMD_ADDFILETYPE            765
#define ECMD_ADDACTION              766
#define ECMD_SETASDEFAULT           767
#define ECMD_MOVEUP                 768
#define ECMD_MOVEDOWN               769
#define ECMD_ADDDIALOG              770
#define ECMD_IMPORTDIALOG           771
#define ECMD_ADDFILESEARCH          772
#define ECMD_ADDREGISTRYSEARCH      773
#define ECMD_ADDCOMPONENTSEARCH     774
#define ECMD_ADDLAUNCHCONDITION     775
#define ECMD_ADDCUSTOMACTION        776
#define ECMD_OUTPUTS                777
#define ECMD_DEPENDENCIES           778
#define ECMD_FILTER                 779
#define ECMD_COMPONENTS             780
#define ECMD_ENVSTRING		        781
#define ECMD_CREATEEMPTYSHORTCUT    782
#define ECMD_ADDFILECONDITION       783
#define ECMD_ADDREGISTRYCONDITION   784
#define ECMD_ADDCOMPONENTCONDITION  785
#define ECMD_ADDURTCONDITION        786
#define ECMD_ADDIISCONDITION        787

//
// The relative positions of the commands within the following deploy
// subgroup must remain unaltered, although the group as a whole may
// be repositioned. Note that the first and last elements are special
// boundary elements.
#define ECMD_SPECIALFOLDERBASE      800
#define ECMD_USERSAPPLICATIONDATAFOLDER 800
#define ECMD_COMMONFILESFOLDER      801
#define ECMD_CUSTOMFOLDER           802
#define ECMD_USERSDESKTOP           803
#define ECMD_USERSFAVORITESFOLDER   804
#define ECMD_FONTSFOLDER            805
#define ECMD_GLOBALASSEMBLYCACHEFOLDER  806
#define ECMD_MODULERETARGETABLEFOLDER   807
#define ECMD_USERSPERSONALDATAFOLDER    808
#define ECMD_PROGRAMFILESFOLDER     809
#define ECMD_USERSPROGRAMSMENU      810
#define ECMD_USERSSENDTOMENU        811
#define ECMD_SHAREDCOMPONENTSFOLDER 812
#define ECMD_USERSSTARTMENU         813
#define ECMD_USERSSTARTUPFOLDER     814
#define ECMD_SYSTEMFOLDER           815
#define ECMD_APPLICATIONFOLDER      816
#define ECMD_USERSTEMPLATEFOLDER    817
#define ECMD_WEBCUSTOMFOLDER        818
#define ECMD_WINDOWSFOLDER          819
#define ECMD_SPECIALFOLDERLAST      819
// End of deploy sub-group
//
// Shareable commands originating in the Visual Studio Analyzer project
//
#define ECMD_EXPORTEVENTS           900
#define ECMD_IMPORTEVENTS           901
#define ECMD_VIEWEVENT              902
#define ECMD_VIEWEVENTLIST          903
#define ECMD_VIEWCHART              904
#define ECMD_VIEWMACHINEDIAGRAM     905
#define ECMD_VIEWPROCESSDIAGRAM     906
#define ECMD_VIEWSOURCEDIAGRAM      907
#define ECMD_VIEWSTRUCTUREDIAGRAM   908
#define ECMD_VIEWTIMELINE           909
#define ECMD_VIEWSUMMARY            910
#define ECMD_APPLYFILTER            911
#define ECMD_CLEARFILTER            912
#define ECMD_STARTRECORDING         913
#define ECMD_STOPRECORDING          914
#define ECMD_PAUSERECORDING         915
#define ECMD_ACTIVATEFILTER         916
#define ECMD_SHOWFIRSTEVENT         917
#define ECMD_SHOWPREVIOUSEVENT      918
#define ECMD_SHOWNEXTEVENT          919
#define ECMD_SHOWLASTEVENT          920
#define ECMD_REPLAYEVENTS           921
#define ECMD_STOPREPLAY             922
#define ECMD_INCREASEPLAYBACKSPEED  923
#define ECMD_DECREASEPLAYBACKSPEED  924
#define ECMD_ADDMACHINE             925
#define ECMD_ADDREMOVECOLUMNS       926
#define ECMD_SORTCOLUMNS            927
#define ECMD_SAVECOLUMNSETTINGS     928
#define ECMD_RESETCOLUMNSETTINGS    929
#define ECMD_SIZECOLUMNSTOFIT       930
#define ECMD_AUTOSELECT             931
#define ECMD_AUTOFILTER             932
#define ECMD_AUTOPLAYTRACK          933
#define ECMD_GOTOEVENT              934
#define ECMD_ZOOMTOFIT              935
#define ECMD_ADDGRAPH               936
#define ECMD_REMOVEGRAPH            937
#define ECMD_CONNECTMACHINE         938
#define ECMD_DISCONNECTMACHINE      939
#define ECMD_EXPANDSELECTION        940
#define ECMD_COLLAPSESELECTION      941
#define ECMD_ADDFILTER              942
#define ECMD_ADDPREDEFINED0         943
#define ECMD_ADDPREDEFINED1         944
#define ECMD_ADDPREDEFINED2         945
#define ECMD_ADDPREDEFINED3         946
#define ECMD_ADDPREDEFINED4         947
#define ECMD_ADDPREDEFINED5         948
#define ECMD_ADDPREDEFINED6         949
#define ECMD_ADDPREDEFINED7         950
#define ECMD_ADDPREDEFINED8         951
#define ECMD_TIMELINESIZETOFIT      952

//
// Shareable commands originating with Crystal Reports
//
#define ECMD_FIELDVIEW             1000
#define ECMD_SELECTEXPERT          1001
#define ECMD_TOPNEXPERT            1002
#define ECMD_SORTORDER             1003
#define ECMD_PROPPAGE              1004
#define ECMD_HELP                  1005
#define ECMD_SAVEREPORT            1006
#define ECMD_INSERTSUMMARY         1007
#define ECMD_INSERTGROUP           1008
#define ECMD_INSERTSUBREPORT       1009
#define ECMD_INSERTCHART           1010
#define ECMD_INSERTPICTURE         1011
//
// Shareable commands from the common project area (DirPrj)
//
#define ECMD_SETASSTARTPAGE        1100
#define ECMD_RECALCULATELINKS      1101
#define ECMD_WEBPERMISSIONS        1102
#define ECMD_COMPARETOMASTER       1103
#define ECMD_WORKOFFLINE           1104
#define ECMD_SYNCHRONIZEFOLDER     1105
#define ECMD_SYNCHRONIZEALLFOLDERS 1106
#define ECMD_COPYPROJECT           1107
#define ECMD_IMPORTFILEFROMWEB     1108
#define ECMD_INCLUDEINPROJECT      1109
#define ECMD_EXCLUDEFROMPROJECT    1110
#define ECMD_BROKENLINKSREPORT     1111
#define ECMD_ADDPROJECTOUTPUTS     1112
#define ECMD_ADDREFERENCE          1113
#define ECMD_ADDWEBREFERENCE       1114
#define ECMD_ADDWEBREFERENCECTX    1115
#define ECMD_UPDATEWEBREFERENCE    1116
#define ECMD_RUNCUSTOMTOOL         1117 
//
// Shareable commands for right drag operations
//
#define ECMD_DRAG_MOVE             1140
#define ECMD_DRAG_COPY             1141
#define ECMD_DRAG_CANCEL           1142

//
// Shareable commands from the VC resource editor
//
#define ECMD_TESTDIALOG            1200
#define ECMD_SPACEACROSS           1201
#define ECMD_SPACEDOWN             1202
#define ECMD_TOGGLEGRID            1203
#define ECMD_TOGGLEGUIDES          1204
#define ECMD_SIZETOTEXT            1205
#define ECMD_CENTERVERT            1206
#define ECMD_CENTERHORZ            1207
#define ECMD_FLIPDIALOG            1208
#define ECMD_SETTABORDER           1209
#define ECMD_BUTTONRIGHT           1210
#define ECMD_BUTTONBOTTOM          1211
#define ECMD_AUTOLAYOUTGROW        1212
#define ECMD_AUTOLAYOUTNORESIZE    1213
#define ECMD_AUTOLAYOUTOPTIMIZE    1214
#define ECMD_GUIDESETTINGS         1215
#define ECMD_RESOURCEINCLUDES      1216
#define ECMD_RESOURCESYMBOLS       1217
#define ECMD_OPENBINARY            1218
#define ECMD_RESOURCEOPEN          1219
#define ECMD_RESOURCENEW           1220
#define ECMD_RESOURCENEWCOPY       1221
#define ECMD_INSERT                1222
#define ECMD_EXPORT                1223
#define ECMD_CTLMOVELEFT           1224
#define ECMD_CTLMOVEDOWN           1225
#define ECMD_CTLMOVERIGHT          1226
#define ECMD_CTLMOVEUP             1227
#define ECMD_CTLSIZEDOWN           1228
#define ECMD_CTLSIZEUP             1229
#define ECMD_CTLSIZELEFT           1230
#define ECMD_CTLSIZERIGHT          1231
#define ECMD_NEWACCELERATOR        1232
#define ECMD_CAPTUREKEYSTROKE      1233
#define ECMD_INSERTACTIVEXCTL      1234
#define ECMD_INVERTCOLORS          1235
#define ECMD_FLIPHORIZONTAL        1236
#define ECMD_FLIPVERTICAL          1237
#define ECMD_ROTATE90              1238
#define ECMD_SHOWCOLORSWINDOW      1239
#define ECMD_NEWSTRING             1240
#define ECMD_NEWINFOBLOCK          1241
#define ECMD_DELETEINFOBLOCK       1242
#define ECMD_ADJUSTCOLORS          1243
#define ECMD_LOADPALETTE           1244
#define ECMD_SAVEPALETTE           1245
#define ECMD_CHECKMNEMONICS        1246
#define ECMD_DRAWOPAQUE            1247
#define ECMD_TOOLBAREDITOR         1248
#define ECMD_GRIDSETTINGS          1249
#define ECMD_NEWDEVICEIMAGE        1250
#define ECMD_OPENDEVICEIMAGE       1251
#define ECMD_DELETEDEVICEIMAGE     1252
#define ECMD_VIEWASPOPUP           1253
#define ECMD_CHECKMENUMNEMONICS    1254
#define ECMD_SHOWIMAGEGRID         1255
#define ECMD_SHOWTILEGRID          1256
#define ECMD_MAGNIFY               1257
#define cmdidResProps              1258
//
// Shareable commands from the VC resource editor (Image editor toolbar)
//
#define ECMD_PICKRECTANGLE         1300
#define ECMD_PICKREGION            1301
#define ECMD_PICKCOLOR             1302
#define ECMD_ERASERTOOL            1303
#define ECMD_FILLTOOL              1304
#define ECMD_PENCILTOOL            1305
#define ECMD_BRUSHTOOL             1306
#define ECMD_AIRBRUSHTOOL          1307
#define ECMD_LINETOOL              1308
#define ECMD_CURVETOOL             1309
#define ECMD_TEXTTOOL              1310
#define ECMD_RECTTOOL              1311
#define ECMD_OUTLINERECTTOOL       1312
#define ECMD_FILLEDRECTTOOL        1313
#define ECMD_ROUNDRECTTOOL         1314
#define ECMD_OUTLINEROUNDRECTTOOL  1315
#define ECMD_FILLEDROUNDRECTTOOL   1316
#define ECMD_ELLIPSETOOL           1317
#define ECMD_OUTLINEELLIPSETOOL    1318
#define ECMD_FILLEDELLIPSETOOL     1319
#define ECMD_SETHOTSPOT            1320
#define ECMD_ZOOMTOOL              1321
#define ECMD_ZOOM1X                1322
#define ECMD_ZOOM2X                1323
#define ECMD_ZOOM6X                1324
#define ECMD_ZOOM8X                1325
#define ECMD_TRANSPARENTBCKGRND    1326
#define ECMD_OPAQUEBCKGRND         1327
//---------------------------------------------------
// The commands ECMD_ERASERSMALL thru ECMD_LINELARGER
// must be left in the same order for the use of the
// Resource Editor - They may however be relocated as
// a complete block
//---------------------------------------------------
#define ECMD_ERASERSMALL           1328
#define ECMD_ERASERMEDIUM          1329
#define ECMD_ERASERLARGE           1330
#define ECMD_ERASERLARGER          1331
#define ECMD_CIRCLELARGE           1332
#define ECMD_CIRCLEMEDIUM          1333
#define ECMD_CIRCLESMALL           1334
#define ECMD_SQUARELARGE           1335
#define ECMD_SQUAREMEDIUM          1336
#define ECMD_SQUARESMALL           1337
#define ECMD_LEFTDIAGLARGE         1338
#define ECMD_LEFTDIAGMEDIUM        1339
#define ECMD_LEFTDIAGSMALL         1340
#define ECMD_RIGHTDIAGLARGE        1341
#define ECMD_RIGHTDIAGMEDIUM       1342
#define ECMD_RIGHTDIAGSMALL        1343
#define ECMD_SPLASHSMALL           1344
#define ECMD_SPLASHMEDIUM          1345
#define ECMD_SPLASHLARGE           1346
#define ECMD_LINESMALLER           1347
#define ECMD_LINESMALL             1348
#define ECMD_LINEMEDIUM            1349
#define ECMD_LINELARGE             1350
#define ECMD_LINELARGER            1351
#define ECMD_LARGERBRUSH           1352
#define ECMD_LARGEBRUSH            1353
#define ECMD_STDBRUSH              1354
#define ECMD_SMALLBRUSH            1355
#define ECMD_SMALLERBRUSH          1356
#define ECMD_ZOOMIN                1357
#define ECMD_ZOOMOUT               1358
#define ECMD_PREVCOLOR             1359
#define ECMD_PREVECOLOR            1360
#define ECMD_NEXTCOLOR             1361
#define ECMD_NEXTECOLOR            1362
#define ECMD_IMG_OPTIONS           1363

//---------------------------------------------------

//
// Shareable commands from WINFORMS
//
#define ECMD_CANCELDRAG            1500
#define ECMD_DEFAULTACTION         1501
#define ECMD_CTLMOVEUPGRID         1502
#define ECMD_CTLMOVEDOWNGRID       1503
#define ECMD_CTLMOVELEFTGRID       1504
#define ECMD_CTLMOVERIGHTGRID      1505
#define ECMD_CTLSIZERIGHTGRID      1506
#define ECMD_CTLSIZEUPGRID         1507
#define ECMD_CTLSIZELEFTGRID       1508
#define ECMD_CTLSIZEDOWNGRID       1509
#define ECMD_NEXTCTL               1510
#define ECMD_PREVCTL               1511

//////////////////////////////////////////////////////////////////
//
// The following commands form guidDataCmdId.
// NOTE that all these commands are shareable and may be used
// in any appropriate menu.
//
//////////////////////////////////////////////////////////////////
#define icmdDesign					0x3000		// design command for project items
#define icmdDesignOn				0x3001		// design on... command for project items

#define icmdSEDesign				0x3003		// design command for the SE side
#define icmdNewDiagram				0x3004
#define icmdNewTable				0x3006

#define icmdNewDBItem				0x300E
#define icmdNewTrigger				0x3010

#define icmdDebug					0x3012
#define icmdNewProcedure			0x3013
#define icmdNewQuery				0x3014
#define icmdRefreshLocal			0x3015

#define icmdDbAddDataConnection			0x3017
#define icmdDBDefDBRef				0x3018
#define icmdRunCmd					0x3019
#define icmdRunOn					0x301A
#define icmdidNewDBRef				0x301B
#define icmdidSetAsDef				0x301C
#define icmdidCreateCmdFile			0x301D

#define icmdNewDatabase				0x3020
#define icmdNewUser					0x3021
#define icmdNewRole					0x3022
#define icmdChangeLogin				0x3023
#define icmdNewView					0x3024
#define icmdModifyConnection		0x3025
#define icmdDisconnect				0x3026
#define icmdCopyScript				0x3027
#define icmdAddSCC					0x3028
#define icmdRemoveSCC				0x3029
#define icmdGetLatest				0x3030
#define icmdCheckOut				0x3031
#define icmdCheckIn					0x3032
#define icmdUndoCheckOut			0x3033
#define icmdAddItemSCC				0x3034
#define icmdNewPackageSpec			0x3035
#define icmdNewPackageBody			0x3036
#define icmdInsertSQL				0x3037
#define icmdRunSelection			0x3038
#define icmdUpdateScript			0x3039
#define icmdCreateScript			0x303A	// to be used by db project side
#define icmdSECreateScript			0x303B	// to be used by SE side as opposed to db project side
#define icmdNewScript				0x303C
#define icmdNewFunction				0x303D
#define icmdNewTableFunction		0x303E
#define icmdNewInlineFunction		0x303F

#define icmdAddDiagram				0x3040
#define icmdAddTable				0x3041			
#define icmdAddSynonym				0x3042			
#define icmdAddView					0x3043
#define icmdAddProcedure			0x3044
#define icmdAddFunction				0x3045
#define icmdAddTableFunction		0x3046
#define icmdAddInlineFunction		0x3047
#define icmdAddPkgSpec				0x3048
#define icmdAddPkgBody				0x3049
#define icmdAddTrigger				0x304A
#define icmdExportData				0x304B

#define icmdDbnsVcsAdd				0x304C
#define icmdDbnsVcsRemove			0x304D
#define icmdDbnsVcsCheckout			0x304E
#define icmdDbnsVcsUndoCheckout		0x304F
#define icmdDbnsVcsCheckin			0x3050

#define icmdSERetrieveData			0x3060
#define icmdSEEditTextObject		0x3061
#define icmdSERun					0x3062	// to be used by SE side as opposed to db project side
#define icmdSERunSelection			0x3063	// to be used by SE side as opposed to db project side
#define icmdDesignSQLBlock			0x3064	

#define icmdRegisterSQLInstance		0x3065
#define icmdUnregisterSQLInstance	0x3066


//////////////////////////////////////////////////////////////////
//
// The following commands form guidDavDataCmdId.
// NOTE that all these commands are shareable and may be used
// in any appropriate menu.
//
//////////////////////////////////////////////////////////////////
#define	cmdidAddRelatedTables			0x0001
#define cmdidLayoutDiagram				0x0002
#define cmdidLayoutSelection			0x0003
#define cmdidInsertColumn				0x0004
#define cmdidDeleteColumn				0x0005
#define cmdidNewTextAnnotation			0x0006
#define cmdidShowRelLabels				0x0007
#define cmdidViewPageBreaks				0x0008
#define cmdidRecalcPageBreaks			0x0009
#define cmdidViewUserDefined			0x000a
#define cmdidGenerateQuery				0x000b
#define cmdidDeleteFromDB				0x000c
#define cmdidAutoSize					0x000d
#define cmdidEditViewUserDefined		0x000e
#define cmdidSetAnnotationFont			0x000f
#define cmdidZoomPercent200				0x0010
#define cmdidZoomPercent150				0x0011
#define cmdidZoomPercent100				0x0012
#define cmdidZoomPercent75				0x0013
#define cmdidZoomPercent50				0x0014
#define cmdidZoomPercent25				0x0015
#define cmdidZoomPercent10				0x0016
#define cmdidZoomPercentSelection		0x0017
#define cmdidZoomPercentFit				0x0018
#define cmdidInsertQBERow				0x0019
#define cmdidInsertCriteria				0x0020
#define cmdidAddTableView				0x0021
#define cmdidManageTriggers				0x0022
#define cmdidManagePermissions			0x0023
#define cmdidViewDependencies			0x0024
#define cmdidGenerateSQLScript			0x0025		
#define cmdidVerifySQLSilent			0x0026
#define cmdidAddTableViewForQRY			0x0027
#define cmdidManageIndexesForQRY		0x0028
#define cmdidViewFieldListQry			0x0029
#define cmdidViewCollapsedQry			0x002a
#define cmdidCopyDiagram				0x002b


#endif //_STDIDCMD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\tempmem.h ===
//---------------------------------------------------------------------------
// Copyright (C) 1991-1998, Microsoft Corporation
//                 All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//---------------------------------------------------------------------------
/*** 
*tempmem.h - Prototypes for simple stack based memory allocatiocation
*
*Revision History:
*
* [00]	19-Aug-98 marioch: Created.
*
*Implementation Notes:
*
*****************************************************************************/

#ifndef TEMPMEM_H_INCLUDED
#define TEMPMEM_H_INCLUDED

#include <malloc.h>
#include <windows.h>

#ifdef	__cplusplus

extern "C" {

inline UINT StackAvailable()
{
    INT iLocal;
    static void *pvStackBottom = 0;

    //CONSIDER: for SIZE and SPEED - initialize pvStackBottom at startup
    if (!pvStackBottom) {
	MEMORY_BASIC_INFORMATION mbi;
	VirtualQuery(&iLocal, &mbi, sizeof(mbi));
	pvStackBottom = mbi.AllocationBase;
    }
    return (UINT) (((INT_PTR) &iLocal) - (INT_PTR)pvStackBottom);
}


/* this is an internal class that shouldn't be used directly. 
  Use the TEMPBUFF macros instead
*/
class TempBufferEx {
public:
    TempBufferEx (size_t stacksize, size_t allocasize, size_t size, 
                  char* stackbuffer, size_t* allocasize_out);

    ~TempBufferEx();
	void* GetBuffer() {
          return (void*)m_pcBuffer;
	}
private:
    enum alloc_kind {ALLOCA, LOCAL, HEAP};
    alloc_kind m_where_allocated;
    char* m_pcBuffer;
    void *m_pvRegCookie;
};

/* Macro to declare and efficiently manage a temporary buffer. 
 * Var is the variable name
 * Type is its type
 * size is the actual (known at runtime) size of the buffer
 * Example: 
 * TEMPBUF(tempchars, char*, 2*len(initchars));
 *
 * NOTE: you must check the pointer to the buffer for NULL in case
 *       the allocator wasn't able to allocate the memory.
*/
#define TEMPBUF(var,type,size) char __TempBuf##var[120];\
TempBufferEx __TempBuffer##var(120,0,(size),(char*)&__TempBuf##var,0);\
type var = (type)__TempBuffer##var.GetBuffer();

/* Macro to declare and efficiently manage a temporary buffer. 
 * Var is the variable name
 * Type is its type
 * sizestack (constant) is the maximum stack size that can be reserved on the stack 
 * (40-100 is a good number)
 * size is the actual (known at runtime) size of the buffer
 * Example: 
 * TEMPBUFEX(tempchars, char*, 50,2*len(initchars));
 *
 * NOTE: you must check the pointer to the buffer for NULL in case
 *       the allocator wasn't able to allocate the memory.
*/
#define TEMPBUFEX(var,type,sizestack,size) char __TempBuf##var[sizestack];\
TempBufferEx __TempBuffer##var(sizestack,0,(size),(char*)&__TempBuf##var,0);\
type var = (type)__TempBuffer##var.GetBuffer();

/* Macro to declare and efficiently manage a temporary buffer, using alloca if possible.
 * Use this macro only in "leaf functions", functions that don't call more non OS functions,
 * because you could run out of stack space 
 * Var is the variable name
 * Type is its type
 * sizestack (constant) is the maximum stack size that can be reserved on the stack 
 * (40-100 is a good number)
 * Sizealloca is the size that can be alloca'ed from the stack. 
 * size is the actual (known at runtime) size of the buffer
 * Example: 
 * TEMPALLOCABUF(tempchars, char*, 50,1000, 2*len(initchars));
 *
 * NOTE: you must check the pointer to the buffer for NULL in case
 *       the allocator wasn't able to allocate the memory.
*/

#define TEMPALLOCABUF(var,type,sizestack,sizealloca,size) char __TempBuf##var[sizestack];\
size_t __Alloca##var =0;\
TempBufferEx __TempBuffer##var(sizestack,(sizealloca),(size),(char*)&__TempBuf##var,&__Alloca##var);\
type var = (type)(__Alloca##var ? _alloca(__Alloca##var) : __TempBuffer##var.GetBuffer());

}
#endif // cplusplus
#endif // TEMPMEM_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\textmgruuids.h ===
#pragma once

//                                                   new                                  old
#define uuid_lib_TextManagerInternal                70E2C621-E71B-4232-92B0-2738B9F24D0C //55426A36-808E-11d0-A8AA-00A0C921A4D2
#define uuid_IVsCompoundAction                      B414D071-87BA-411A-9780-33FC7D87D882 //7EA84F9F-CBE3-11d0-AE60-00C04FB68006
#define uuid_IVsCompoundActionEvents                29B88B8E-BC39-45AE-ACAB-0C670E49BCC2 //2AE670EA-CBE6-11d0-AE60-00C04FB68006
#define uuid_IVsAction                              15D2C32A-0770-4872-BB5F-EC21B0FA2436 //D8C8AB11-7D4A-11d0-A8AA-00A0C921A4D2
#define uuid_IVsTextEditorPropertyCategoryContainer A6078038-D578-4F32-B9B2-C83E1726454D //AE996CFE-AD53-4c1f-A84C-257808563397
#define uuid_IVsTextEditorPropertyContainer         7669CC95-4640-461C-8158-16F65265D77C //EF2F6382-FFCF-4289-BDB1-787DF98ABFD9
#define uuid_IVsCompletionSet                       0EF79249-B0BF-4CD0-A966-C4713546C3A5 //14309FF0-BBEC-11d0-A8D7-00A0C921A4D2
#define uuid_IVsTipWindow                           64C7FFC4-B9EE-4599-B130-FF9D890ECFD4 //14309FF1-BBEC-11d0-A8D7-00A0C921A4D2
#define uuid_IVsMethodTipWindow                     794767F6-538A-4CD3-B29E-6C76C79A7C9C //261A5570-C649-11d0-A8DF-00A0C921A4D2
#define uuid_IVsTextTipWindow                       A6ACCB2F-1E0D-458B-A878-D40EB89C1DF4 //05DD7651-130A-11d3-AFCB-00105A9991EF
#define uuid_IVsMethodData                          69D2811C-682C-4290-B92E-5DFB823DF24C //261A5571-C649-11d0-A8DF-00A0C921A4D2
#define uuid_IVsTextTipData                         90609097-17C8-40E8-8128-67194C7384B1 //05DD7653-130A-11d3-AFCB-00105A9991EF
#define uuid_IVsTextView                            BB23A14B-7C61-469A-9890-A95648CED5E6 //B5E23370-C309-11d0-A8DB-00A0C921A4D2
#define uuid_IVsThreadSafeTextView                  FEC3BF2A-7833-4777-AE74-5FFF86D6794E //51911664-911B-11d1-888C-0000F87579D2
#define uuid_IVsLayeredTextView                     60BD661B-133C-4B5C-A335-4B174C5A352F //86C20AA0-E309-11d2-AFBF-00105A9991EF
#define uuid_IVsTextViewFilter                      6B6F0B32-B88B-40F8-A8FE-97438C5BDBEF //DEE4DD21-9031-11d0-A8AC-00A0C921A4D2
#define uuid_IVsLanguageContextProvider             19404D57-F8E4-42F4-9255-B8F889B0C50C //E2BB6B9D-D149-422a-83B1-6454936B32D3
#define uuid_IVsTextMarkerContextProvider           F1671B6B-1090-4DFF-BBFD-133EB428BB6C //166C1772-16C2-447f-AF86-40BB94598276
#define uuid_IVsViewRangeClient                     30491A5B-A47E-4C9C-8204-18586648A277 //B6DC84F3-ED32-11d0-B185-00A0C90F2732
#define uuid_IVsTextViewEvents                      E1965DA9-E791-49E2-9F9D-ED766D885967 //55426A34-808E-11d0-A8AA-00A0C921A4D2
#define uuid_IVsTextManager                         909F83E3-B3FC-4BBF-8820-64378744B39B //55426A30-808E-11d0-A8AA-00A0C921A4D2
#define uuid_IVsShortcutManager                     78201465-554E-4A7B-998F-443156FD71D3 //50D292F0-6F5E-11d1-8FBD-00A0C91BBFA2
#define uuid_IVsEnumTextBuffers                     74BBEE88-AB6E-4276-9BD2-27F566B8BBAF //C2713292-1E53-11d1-A934-00A0C921A4D2
#define uuid_IVsTextManagerEvents                   B3175059-C6AA-4519-86C3-1FE594D26C35 //55426A39-808E-11d0-A8AA-00A0C921A4D2
#define uuid_IVsTextSelectionAction                 CB49CF53-CCE9-4493-AD7A-3595F4C1CAF3 //0621B428-9C32-11d1-8892-0000F87579D2
#define uuid_IVsEnumTextViews                       DB685578-E6D4-4D5E-B714-FA344A509ABF //55426A32-808E-11d0-A8AA-00A0C921A4D2
#define uuid_IVsColorableItem                       56694A40-78D0-45DD-AB15-681BC207579C //21F7F163-7FBE-11d0-A8AA-00A0C921A4D2
#define uuid_IVsMergeableUIItem                     0AE3E015-2900-4DDF-87AF-CC522AE02284 //6F3E3146-B6B8-418f-B17C-FFC237C5E8E3
#define uuid_IVsProvideColorableItems               100B9A33-905C-4312-B2A2-452189F19AB9 //21F7F162-7FBE-11d0-A8AA-00A0C921A4D2
#define uuid_IVsColorizer                           6698EF11-FF17-441C-8C5D-BC24A339B37D //8E7B969E-E33D-11d0-A6D5-00C04FB67F6A
#define uuid_IVsEnumGUID                            C7A919CC-79C5-43D7-9B1E-B22E459F6557 //F87BB463-1C42-11d3-AFCD-00105A9991EF
#define uuid_IVsLanguageInfo                        11DDB920-52C7-4237-8610-9FE8BB11656D //8E7B969F-E33D-11d0-A6D5-00C04FB67F6A
#define uuid_IVsLanguageBlock                       BA303DF5-6283-4961-A4CE-76D4F0662D11 //E9BDA1A2-C207-11d2-9372-0080C747D9A0
#define uuid_IVsEnumBSTR                            A0A9C2B0-95A3-4819-ADA3-5BD9756BBD36 //C2713291-1E53-11d1-A934-00A0C921A4D2
#define uuid_IVsDebugName                           0BCE4F72-5889-4733-8605-413C28F5899F //E8452D00-3538-11d1-A943-00A0C921A4D2
#define uuid_IVsEnumDebugName                       9AD7EC03-4157-45B4-A999-403D6DB94578 //E8452D01-3538-11d1-A943-00A0C921A4D2
#define uuid_IVsLanguageDebugInfo                   F30A6A07-5340-4C0E-B312-5772558B0E63 //C2713290-1E53-11d1-A934-00A0C921A4D2
#define uuid_IVsTextBufferTempInit                  F229A34E-5880-4C20-94C3-717CF4BE1FDA //5FF7F238-41BD-11d2-88E9-0000F87579D2
#define uuid_IVsTextBuffer                          C08E5275-0D26-4DE9-8892-994024C23750 //8E7B96A0-E33D-11d0-A6D5-00C04FB67F6A
#define uuid_IVsTextLines                           ECF3E19D-149C-43AA-80C2-D0A46946DAA3 //8E7B96A1-E33D-11d0-A6D5-00C04FB67F6A
#define uuid_IVsTextColorState                      A7A64DE3-9B5C-47F0-ABAD-0AEDBD6CC057 //E2FE4BDC-18D3-11d1-8CB6-00C04FC2AB22
#define uuid_IVsTextLinesEvents                     598D7074-DC17-4162-9A2F-97DD4540C2DD //8E7B96A7-E33D-11d0-A6D5-00C04FB67F6A
#define uuid_IVsTextStream                          D3AF020B-A862-4D22-B373-20F1B30B7D9E //8E7B96A9-E33D-11d0-A6D5-00C04FB67F6A
#define uuid_IVsEnumStreamMarkers                   06E27359-6FEE-4CCC-9E8B-AFC20C0F662A //43B965F2-E430-11d0-A6D5-00C04FB67F6A
#define uuid_IVsEnumLineMarkers                     35E981F1-77EF-4343-AAA1-8741F38627A2 //43B965F3-E430-11d0-A6D5-00C04FB67F6A
#define uuid_IVsEnumLayerMarkers                    8F591607-2A26-4A9D-A6C5-147C2E51E895 //D6F09128-A5BE-11d2-8918-0000F87579D2
#define uuid_IVsTextMarker                          950122D9-1A51-43CA-8CED-B5D9E42DE1B5 //8E7B96A2-E33D-11d0-A6D5-00C04FB67F6A
#define uuid_IVsTextStreamMarker                    10D17872-91BA-4D65-80CC-E5FC3222AC82 //8E7B96A3-E33D-11d0-A6D5-00C04FB67F6A
#define uuid_IVsTextLineMarker                      31E2DCA7-CCFF-4E09-B433-17C739CF69AD //8E7B96A4-E33D-11d0-A6D5-00C04FB67F6A
#define uuid_IVsTextLayerMarker                     28C149D2-8FCB-4AB3-8584-9A2747F3F8FC //08A9A5EA-9608-11d2-8915-0000F87579D2
#define uuid_IVsTextMarkerType                      8C4A2B6E-6377-4C71-9940-FBA1BE6EDD6F //6E3A1620-9B54-11d0-B608-00A0C922E851
#define uuid_IVsTextMarkerColorSet                  93373F76-DF07-46DB-9415-1772069F60A4 //1C9693C0-619D-11d3-AFEB-00105A9991EF
#define uuid_IVsPackageDefinedTextMarkerType        C70F1528-1A66-403F-AD42-F60F9D413E05 //0E371220-5BF9-11d3-AFE8-00105A9991EF
#define uuid_IVsTextMarkerTypeProvider              7EF86CFD-D561-4BA5-9F38-C1BFF588E3AC //08CB82B1-5CBF-11d3-AFE8-00105A9991EF
#define uuid_IVsTextMarkerClient                    B1938F1B-D7A9-42F8-9960-D009027B3D2E //37E8F1C0-D6BF-11d0-B623-00A0C922E851
#define uuid_IVsMouseCursorProvider                 E32F08DB-6364-4276-8EA8-BAA6752F7807 //1244E494-78D0-4e7a-A2AF-E2CE72689CDD
#define uuid_IVsTextMarkerGlyphDropHandler          1E220776-3C20-46E9-A691-DE549C295E26 //F463910B-8173-4a1d-9F40-90D7D37DFD86
#define uuid_IVsTextTrackingPoint                   D6BF0A8A-3798-49C5-8806-648A635EACC8 //E8C15E90-0985-11d3-AFC6-00105A9991EF
#define uuid_IVsFullTextScanner                     BE93F7B1-F2FD-45B4-938D-1C66441CD421 //1CDE1D3E-9DBB-11d1-8892-0000F87579D2
#define uuid_IVsTextScanner                         EBD73923-C190-45C1-91C5-0BC61A8AAB14 //92DFFFA3-69CE-11d0-A8A9-00A0C921A4D2
#define uuid_IVsTextFind                            0BF16544-9CEC-40E1-80B1-E467E21B97FE //71E853C7-83AE-11d0-8C3C-00C04FC2AAE2
#define uuid_IVsTextBufferEvents                    44B0CAB3-6DF8-4931-9064-8FD18AFBC88E //8E7B96A5-E33D-11d0-A6D5-00C04FB67F6A
#define uuid_IVsTextBufferDataEvents                B7515E7A-70F0-44ED-96B7-FB7EB6450C10 //9F14D3CD-8EB3-11d1-87F9-00C04FB17663
#define uuid_IVsTextStreamEvents                    96FC7D44-BCDD-4F00-AE4D-07E26B2C0E52 //8E7B96A6-E33D-11d0-A6D5-00C04FB67F6A
#define uuid_IVsSplitPane                           721D4D8E-E987-4712-B878-88A0E7DBA117 //3315DFB1-940C-11d0-A8AE-00A0C921A4D2
#define uuid_IVsSplitter                            66280096-A495-48E9-8AF4-E758FDE1FCDC //3315DFB2-940C-11d0-A8AE-00A0C921A4D2
#define uuid_IVsSplitRoot                           5486C948-AF82-4DA5-A968-97F3ADA66670 //88E7CDA0-9685-11d0-A8AF-00A0C921A4D2
#define uuid_IVsCodeWindow                          8560CECD-DFAC-4F7B-9D2A-E6D9810F3443 //DAF27AC3-90DE-11d0-A8AD-00A0C921A4D2
#define uuid_IVsCodeWindowManager                   4758CB90-6110-4440-B577-2E3FC91E4B84 //91244BB0-9B25-11d0-A8B4-00A0C921A4D2
#define uuid_IVsDropdownBarClient                   AEE77BDD-05C8-4DE1-B48E-1B003F49ACB7 //452807CD-9BFA-11d0-8C3F-00C04FC2AAE2
#define uuid_IVsDropdownBar                         D7820968-4CF8-4760-B633-570282E5F66D //452807CB-9BFA-11d0-8C3F-00C04FC2AAE2
#define uuid_IVsDropdownBarManager                  5CCB1170-6527-4D88-BE3E-198F0EF5538D //66BA4472-7F57-11d2-8903-0000F87579D2
#define uuid_IVsButtonBarClient                     B59AF843-E075-496E-A00D-E8EEB3C748EB //6B05ABE1-CA89-11d2-AFAE-00105A9991EF
#define uuid_IVsButtonBar                           4C4095EC-0AF1-48B2-A900-DB496765EE9E //6B05ABE2-CA89-11d2-AFAE-00105A9991EF
#define uuid_IVsButtonBarManager                    B4D5B0A3-1945-4F5F-B5E1-4ADD352E78C1 //6B05ABE0-CA89-11d2-AFAE-00105A9991EF
#define uuid_IVsDefaultButtonBarImages              73B7DC00-F498-4ABD-AB79-D07AFD52F395 //B2715970-D02C-11d2-AFB4-00105A9991EF
#define uuid_IVsTextMacroHelper                     CAF8109F-B74B-429F-A11A-4944AADE9AB2 //AD6D4B78-AB26-11d2-BA99-00C04F79F802
#define uuid_IVsUserData                            978A8E17-4DF8-432A-9623-D530A26452BC //7194CA21-B4D8-11d0-A8CF-00A0C921A4D2
#define uuid_IVsUserDataEvents                      5E120D5E-9637-47D9-861C-92FA03683C6C //87F506A0-442B-11d1-B667-00A0C922E851
#define uuid_IVsUndoUnit                            A8C3D107-7EDF-4B1B-8A81-080AC91590E9 //D8F778D8-C636-11d0-8C63-00C04FC2AB22
#define uuid_IVsUndoTrackingEvents                  31024DD7-30E5-4C91-821D-218BDEADA18B //C476C5B7-C0F5-11d1-88AB-0000F87579D2
#define uuid_IVsChangeTrackingUndoManager           E33C4DCF-F50C-4356-8CD8-87A7F213337B //C476C5B6-C0F5-11d1-88AB-0000F87579D2
#define uuid_IVsLinkedUndoClient                    33452684-FAB0-4F76-B4E9-19EE0B96B4AD //121426B1-F455-11d2-AFC3-00105A9991EF
#define uuid_IVsLinkCapableUndoManager              F747D466-83CA-41D6-A0E8-3F78283D01E7 //121426B0-F455-11d2-AFC3-00105A9991EF
#define uuid_IVsLifetimeControlledObject            B3B2E5D4-F03E-4BB9-85F9-61B5F45AC498 //F37B06A0-6AD3-11d3-AFEF-00105A9991EF
#define uuid_IVsLinkedUndoTransactionManager        F65478CC-96F1-4BA9-9EF9-A575ACB96031 //16C3D9E0-F101-11d2-AFC3-00105A9991EF
#define uuid_IVsChangeClusterEvents                 E55C4E80-A01C-47E8-9E94-D664B94DF6CF //25613CC0-713A-11d3-AFF1-00105A9991EF
#define uuid_coclass_VsLocalUserData              /*74CAEA79-4323-4BED-92AA-2616F34D9E1E*/ 5130C7AB-85BB-11d3-B363-00C04F611E41
#define uuid_coclass_VsUserData                   /*FEF688A3-806D-4C9C-95ED-61C1978AA7DC*/ F5E7E718-1401-11d1-883B-0000F87579D2
#define uuid_coclass_VsCodeWindow                 /*DBA88C29-53DC-44EB-9473-BF40443CA6E8*/ F5E7E719-1401-11d1-883B-0000F87579D2
#define uuid_coclass_VsSplitRoot                  /*37D05D51-4BAF-4131-9CA9-BAFB7665D605*/ F5E7E71A-1401-11d1-883B-0000F87579D2
#define uuid_coclass_VsDropdownBar                /*D5DFBFF9-20A0-4DCD-9E6D-011674B6AA9B*/ 452807CC-9BFA-11d0-8C3F-00C04FC2AAE2
#define uuid_coclass_VsTextBuffer                 /*71EA6CE1-8CCC-4EAA-9410-AC8F31D6CA09*/ 8E7B96A8-E33D-11d0-A6D5-00C04FB67F6A
#define uuid_coclass_VsTextLineStorage            /*DE623C18-23F2-43D1-AEE9-201586866D16*/ D6513A91-ACC8-11d2-8919-0000F87579D2
#define uuid_coclass_VsTextManager                /*7DE6BD48-FB11-40C5-B751-82FD068C588B*/ F5E7E71D-1401-11d1-883B-0000F87579D2
#define uuid_coclass_VsTextView                   /*5A5F8B69-5E98-4258-BAF1-B1B0C0ACFAC4*/ F5E7E71E-1401-11d1-883B-0000F87579D2
#define uuid_coclass_VsTextPackage                /*F206C691-5E00-43C1-8542-FAD53E9DB912*/ F5E7E720-1401-11d1-883B-0000F87579D2
#define uuid_coclass_VsUndoPackage                /*57E96CF3-5C25-47AF-A63F-FD7D4EEE6375*/ 1D76B2E0-F11B-11d2-AFC3-00105A9991EF
#define uuid_coclass_VsUndoUnit                   /*2EB00388-25E0-4F50-99CE-E6623DB8D445*/ 9ADF33D9-8AAD-11d0-B606-00A0C922E851
#define uuid_coclass_VsMethodTipWindow            /*51679893-6260-48FB-883B-1B720D9E1855*/ 261A5572-C649-11d0-A8DF-00A0C921A4D2
#define uuid_coclass_VsTextTipWindow              /*219B3E87-37F2-4FC7-81FF-5AC8DAE9E560*/ 05DD7650-130A-11d3-AFCB-00105A9991EF
#define uuid_coclass_VsHiddenTextLayer            /*F88CF7D8-16EA-4BDB-8489-F8BB8D50BC41*/ 9B6AB22E-916A-11d2-8914-0000F87579D2
#define uuid_coclass_VsDefaultButtonBarImages     /*0A7CBDE4-9AE6-4344-B9FE-C909E3E4749C*/ B2715971-D02C-11d2-AFB4-00105A9991EF
#define uuid_coclass_VsSyntheticTextLayer         /*40E4E341-12FD-47E8-93A8-69E903032CF9*/ 42469677-FCFF-11d2-AFC4-00105A9991EF
#define uuid_coclass_VsDiffLayer                  /*7BAA8929-E209-4019-80E6-A7F522435710*/ 42469676-FCFF-11d2-AFC4-00105A9991EF
#define uuid_IVsDynamicTabProvider                  E82466CA-CF0E-4653-9E76-4D4C6C548DA2 //E0F6FDB8-A6CB-4c0f-9B71-BBA7BF1DE3D0
#define uuid_IVsLastChangeTimeProvider              35E88F96-047C-443C-A336-91BB8E2B40EC //419F606C-6141-11d1-8870-0000F87579D2
#define uuid_IVsEnumTextSpans                       0F343A75-968B-439E-81D6-0D066E53D28D //344431A0-BF9D-11d2-AFAC-00105A9991EF
#define uuid_IVsTextLayer                           0E145D3F-BEFC-4FD9-8714-B01AE89F4396 //E47F5802-055E-11d2-88D5-0000F87579D2
#define uuid_IVsSyntheticRegion                     B9C97AB2-2A37-4134-93E9-C3014F364AA8 //42469670-FCFF-11d2-AFC4-00105A9991EF
#define uuid_IVsEnumSyntheticRegions                67D9795E-CEA4-45FF-A3DA-055CF78F139A //42469678-FCFF-11d2-AFC4-00105A9991EF
#define uuid_IVsSyntheticTextClient                 1A8FBF86-5949-4E08-B9B6-F528AFB2DF9C //42469671-FCFF-11d2-AFC4-00105A9991EF
#define uuid_IVsSyntheticTextSession                0C71E351-5141-4B6F-B838-E212F0764875 //42469673-FCFF-11d2-AFC4-00105A9991EF
#define uuid_IVsSyntheticTextManager                2AB20832-0942-42F9-974F-4E65B85DABF3 //F87BB461-1C42-11d3-AFCD-00105A9991EF
#define uuid_IVsTextHidingLayerModule               1A705427-815C-4DB6-9B5C-6D45CDDDD0C4 //3670467E-6943-11d2-88FC-0000F87579D2
#define uuid_IVsHiddenRegion                        41E57382-63F9-48E6-9DBD-163D2B14D41B //D6F09129-A5BE-11d2-8918-0000F87579D2
#define uuid_IVsEnumHiddenRegions                   681B0FFF-30B4-4578-A911-B67FB049DAFA //D6F0912A-A5BE-11d2-8918-0000F87579D2
#define uuid_IVsHiddenTextClient                    CA3F0E7F-CFA6-444E-A3FE-7B3DFAD6E5E4 //9B6AB22D-916A-11d2-8914-0000F87579D2
#define uuid_IVsHiddenTextManager                   0E5B1E59-53A7-4636-ADBB-0B23C561E293 //D6513A92-ACC8-11d2-8919-0000F87579D2
#define uuid_IVsHiddenTextSession                   82B21BAE-664B-43E1-95B1-0302805FF7D3 //9B6AB22C-916A-11d2-8914-0000F87579D2
#define uuid_IVsOutliningSession                    9A436975-A86A-4459-A350-B05604B53309 //108EE420-25D7-11d3-AFD6-00105A9991EF
#define uuid_IVsOutliningCapableLanguage            B97D5C98-0507-40FA-BF89-CE4F73EBA651 //108EE421-25D7-11d3-AFD6-00105A9991EF
#define uuid_IVsTextLayerEvents                     CDE3413A-AD8E-495F-A74F-760547294A6F //43665C62-6844-11d2-B20E-0080C747D9A0
#define uuid_IVsTextStorage                         1ABAC269-8FB0-438E-8217-230AC6EB5766 //3E7361FC-2B2D-11d2-88E2-0000F87579D2
#define uuid_IVsPersistentTextImage                 C47FFD1E-D84E-43A5-8CBE-E4AD06BE795B //97923ED8-3C68-11d2-88E7-0000F87579D2
#define uuid_IVsTextStorageColorState               1F027F1F-9696-4816-B345-3CD7D3122A48 //6566F8DC-3DCF-11d2-88E8-0000F87579D2
#define uuid_IVsFinalTextChangeCommitEvents         CE62717C-797D-445F-BC89-1D02C54CCF96 //25613CC1-713A-11d3-AFF1-00105A9991EF
#define uuid_IVsPreliminaryTextChangeCommitEvents   7F57B996-148B-46DE-A261-B1A02E6D9DBA //28B2F290-7691-11d3-AFF1-00105A9991EF
#define uuid_IVsUndoRedoClusterWithCommitEvents     F98298D9-53C4-43DB-90D6-D1A3CA4B1849 //E5FDB28F-B7AD-4214-A0A5-9607B591C395
#define uuid_IVsTextImageEvents                     B1ADB4FC-562F-43E6-8A91-CD2CFFA2B377 //708BB450-C068-11d2-936C-D714766E8B50
#define uuid_IVsTextReplaceEvents                   CF9928D9-65AE-4319-A446-94ED5C45ECDE //A72940F5-DEEC-11d2-B25E-00C04F68FD04
#define uuid_IVsFormatFilterProvider                181237A7-4861-4D6C-8CA1-8A004BEA2E8E //EB875D10-3E02-11d3-B33D-00C04F611E41
#define uuid_IVsNavigableLocationResolver           82D04B51-1626-43AA-B57F-9B23D4280333 //66087711-941A-4853-A003-B6052F971DA3
#define uuid_IVsLanguageTextOps                     518020A6-8D59-4C80-9AAE-015AB9DCC3DE //5230519F-3D3A-44ff-AA72-B7BD91A08EFC
#define uuid_IVsLanguageClipboardOps                2ED7B280-B372-415E-862D-D7D9AEAFCD10 //A0798412-B7F9-4548-8F38-F1CBBC4096DE
#define uuid_IVsQueryLineChangeCommit               72E67329-8765-4586-8B15-0B445E6F3B57 //25602B80-40FD-47e9-A4CD-3A1CB192A62B
#define uuid_IVsCodeWindowEvents                    26ACC7FD-C665-426B-B120-E96762C5DD1A //2F0B62F6-6A48-4dcf-A6DC-2480995B53BC
#define uuid_IVsFileBackup                          7B32BDF9-89D3-4574-B6AC-F2EEE9DEAB18 //485F2BE5-8B02-4228-9C43-DB0752063250
// new interfaces
#define uuid_IVsCommitGestureSink                   957970B0-71E1-11d3-AFF1-00105A9991EF
#define uuid_IVsCompoundViewChange                  B5C14FF1-8431-458c-BEBC-34C6925D1976
#define uuid_IVsEditorGoBackLocations               714FFF37-5CDC-424a-BCB4-CA50800524F1
#define uuid_IVsEnumIndependentViews                B9040F95-DADB-443a-A3C3-1C442F1BDA72
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\textpst.h ===
// textpst.h - Text file persistence
// Part of Unilib.
//------------------------------------------------------------------------------
// Copyright (c) 1998-1999, Microsoft Corporation, All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
// Author: Paul Chase Dempsey [paulde]
//------------------------------------------------------------------------------
#pragma once
#include "vsmem.h"
#include "textmgr.h"    // IVsPersistentTextImage
#include "fpstfmt.h"    // Additional STG_E_... and STG_I_...HRESULTs
#include "unipriv.h"    // UASSERT
#include "commacro.h"
#include "txfmt.h"

// !!!! WARNING !!!!
//
// If you load HTML or XML (anything that requires encoding/charset tag lookup),
// make sure to call FreeCharsetResources() from encoding.h during app termination.
//
// !!!! WARNING !!!!


//------------------------------------------------------------------------------
//
HRESULT WINAPI LoadTextImageFromMemory (IVsPersistentTextImage * pImage,
                                        DWORD                    cbData,
                                        PCBYTE                   pData,
                                        LTI_INFO *               pInfo 
                                        );

//------------------------------------------------------------------------------
//
HRESULT WINAPI LoadTextImageFromFile   (IVsPersistentTextImage * pImage, 
                                        PCWSTR                   pszFileName, 
                                        LTI_INFO *               pInfo
                                        );

//------------------------------------------------------------------------------
//
HRESULT WINAPI SaveTextImageToMemory   (IVsPersistentTextImage * pImage,
                                        DWORD *                  pcbData, 
                                        BYTE *                   pData, 
                                        LTI_INFO *               pInfo
                                        );

//------------------------------------------------------------------------------
//
HRESULT WINAPI SaveTextImageToFile     (IVsPersistentTextImage * pImage,
                                        PCWSTR                   pszFileName, 
                                        LTI_INFO *               pInfo
                                        );

//------------------------------------------------------------------------------
// GetTextImageSize
//
// Get persistent size of image, according to LTI_INFO and fExact.
//
// When fExact is FALSE, returns the minimum size guaranteed to hold the image.
// When fExact is TRUE, returns the exact size of the image (can be somewhat 
// expensive to calculate if not Unicode).
//
HRESULT WINAPI GetTextImageSize (IVsPersistentTextImage * pImage, 
                                 LTI_INFO *               pInfo, 
                                 DWORD *                  pdwSize, 
                                 BOOL                     fExact = FALSE
                                 );

// This goo makes VsHeapAlloc happy
#ifdef _DEBUG
#define MY_DEFAULT_HEAP (HANDLE)(-1)
#else
#define MY_DEFAULT_HEAP GetProcessHeap()
#endif

//------------------------------------------------------------------------------
// CMinPersistentTextImage - Minimal implementation of IVsPersistentTextImage
//
// If you don't have text buffer or storage available, you can use this minimal
// implementation with these functions.
//
// In the constructor, you can tell it to use a specific heap, and optionally
// own the heap and destroy it on final release.
//
class CMinPersistentTextImage : public IVsPersistentTextImage
{
public:
    CMinPersistentTextImage(HANDLE heap = 0, BOOL fOwnHeap = FALSE);
    ~CMinPersistentTextImage();

    // IUnknown
    //
    STDMETHODIMP            QueryInterface (REFIID riid, LPVOID *ppObj);
    STDMETHODIMP_(ULONG)    AddRef  ();
    STDMETHODIMP_(ULONG)    Release ();

    // IVsPersistentTextImage
    //
    STDMETHODIMP_(void *)   Image_Alloc   (int iSize);
    STDMETHODIMP_(void *)   Image_Realloc (void *p, int iSize);
    STDMETHODIMP_(void)     Image_Free    (void *p);
    STDMETHODIMP_(long)     Image_GetLength (void);
    STDMETHODIMP            Image_LoadText  (const WCHAR *pszText, INT iLength, DWORD dwFlags);
    // FullTextScan-style methods
    STDMETHODIMP            Image_OpenFullTextScan (void);
    STDMETHODIMP            Image_FullTextRead (const WCHAR **ppszText, long *piLength);
    STDMETHODIMP            Image_CloseFullTextScan (void);

private:
    ULONG   m_cRef;
    PCWSTR  m_pszText;
    INT     m_iLength;
    HANDLE  m_heap;
    BOOL    m_fOwnHeap;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\TxFactory.h ===
// TxFactory.h - Create IVsTextImage, IVsTextSpanSet

#pragma once
//#include "textfind.h" // interfaces defined in textfind.idl

//================================================================
//
// CreateTextImage - Create an instance of IVsTextImage
//
// If pIPersistImage is non-NULL, the IVsTextImage uses that implementation
// to handle persistence and memory allocation.
//
// If pIPersistImage is NULL, it uses it's own implementation based on VSMem
//
HRESULT WINAPI 
CreateTextImage
(
    IVsTextImage **          ppImage, 
    IVsPersistentTextImage * pIPersistImage = NULL  // optional IVsPersistentTextImage
);


//================================================================
//
// CreateNoEditTextImage - Create a lightweight noneditable instance of IVsTextImage
//
// Uses VSMem to implement IVsPersistentTextImage
//
HRESULT WINAPI 
CreateNoEditTextImage 
(
    IVsTextImage ** ppImage
);


//================================================================
//
// CreateTextSpanSet - Create an instance of IVsTextSpanSet
//
HRESULT WINAPI 
CreateTextSpanSet
(
    IVsTextSpanSet ** ppSpanSet
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\TxFmt.h ===
// TxFmt.h -- Plain Text Format files
//------------------------------------------------------------------------------
// Copyright (c) 1999, Microsoft Corporation, All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//
// Author: Paul Chase Dempsey [paulde]
//------------------------------------------------------------------------------
#pragma once

// these flags correspond to the VSTFF enum used by the environment text editor

enum LTI_FLAGS { // (L)oad (T)ext (I)mage flags

    // format    
    LTIF_SIGNATURE      = 0x00010000,   // use file signature
    LTIF_BYTESWAPPED    = 0x00020000,   // when codepage is CP_UNICODE, it's the byte-swapped form

    // i/o flags
    LTIF_DETECT         = 0x01000000,   // perform extra analysis to detect encoding
    LTIF_HTML           = 0x02000000,   // HTML
    LTIF_XML            = 0x04000000,   // XML
    LTIF_BINARY         = 0x08000000    // binary

};
typedef DWORD LTI_INFO;

// Masks for parts of LTI_INFO
// low word:    Windows codepage (see codepage.h for codepage #defines)
//high word:    LTI_FLAGS
#define LTI_CPMASK 0x0000FFFF
#define LTI_FLMASK 0xFFFF0000

// set the codepage part of an LTI_INFO
#define LTI_SETCP(lti, cp) (lti = ((lti & ~LTI_CPMASK)|(DWORD)cp))

// get the codepage part of an LTI_INFO
#define LTI_CP(lti)    (LTI_CPMASK & lti)

// get the flags part of an LTI_INFO
#define LTI_FLAGS(lti) (LTI_FLMASK & lti)

#ifndef CP_INVALID
#define CP_INVALID        0xFFFF // useful invalid codepage value
#endif

//NOTE: Take care to use an UNSIGNED variable for codepage!

// LTIF_HTML implies LTF_DETECT unless codepage is CP_UNICODE or CP_UTF8.

/* PERF HINT: 

  Once you've loaded a file with LTIF_DETECT, LTIF_HTML, or LTIF_XML, turn them off when 
  saving or getting size unless the image has been modified (i.e. the tag might have changed).

  Similarly, if you get the size with LTIF_DETECT, LTIF_HTML, or LTIF_XML, turn them off 
  when saving.

*/

#ifndef PCBYTE
typedef const BYTE * PCBYTE;
#endif

//------------------------------------------------------------------------------
// FreeCharsetResources - Free resources acquired by APIs in this file.
//
// You must call FreeCharsetResources once at app termination if you use any
// of CodepageFromCharsetNameA|W, ScanHTML|XML*, GetImageFormat, LoadTextImage*
// otherwise you may fail to release cached resources.
//
void WINAPI FreeCharsetResources (void);

//------------------------------------------------------------------------------
// CreateTempName - Create a temporary file name
// 
// If pszSrc is NULL, uses the system TEMP path.
//
// Otherwise, creates a temp filename based on the path of pszSrc.
//
// Returns: TRUE on success, FALSE on failure.
//
// On failure, you can call GetLastError to diagnose the cause.
//
BOOL WINAPI CreateTempName (
    PCWSTR pszSrc,
    PWSTR  pszTemp  // assumed to be at least MAX_PATH
    );

//------------------------------------------------------------------------------
// GetImageFormat - detect the type of text image
//
// Info     Detection instructions. 
// cbData   Count of data bytes.
// pData    Image data.
// pInfo    Result of detection.
//
// The flags and codepage in Info/pInfo are used as follows:
//
// <codepage>       Codepage returned if the function cannot otherwise determine the encoding.
//                  You can pass CP_INVALID to distinguish a parsed/detected codepage from the 
//                  default CP_ACP (0).
//
// LTIF_SIGNATURE   Signatures are always checked and override any other processing.
//                  A signature is the Unicode byte-order mark and UTF-8 file signature.
//                  A file beginning with a signature may still not be in that format, so
//                  prepare for errors in conversions.
//
//                  On output, indicates a signature was found.
//
// LTIF_DETECT      Run data analysis.  Required to detect UTF-8 without a signature.
//                  For reliable results, you must make the entire image available in pData.
//
// LTIF_HTML        Scan for HTML META charset tag.  pData must contain all data up to 
//                  the <BODY> tag (this can be a substantial portion of the image).
//
//                  On output, indicates that the no syntax errors were encountered while
//                  parsing HTML. Beware of relying on this bit: because of the extremely lax 
//                  HTML standard, many non-HTML files are valid HTML.
//
// LTIF_XML         Check for XML declaration at start of file.  Requires only
//                  enough data to hold the XML declaration (~150 bytes or so).
//
//                  On output, indicates file began with a valid XML declaration. This is 
//                  a reliable indicator that the file is XML.
//
// LTIF_BINARY      Check for non-ANSI text data. Caution: usually detects Unicode as binary.
//                  if cbData > 250, only the first 250 bytes are examined.
//
// LTIF_BYTESWAPPED Ignored on input. Can be set in output. Meaningful only for CP_UNICODE.
//
// Detection proceeds in the most efficient order: signature, binary, XML, HTML, data analysis.
// The first error-free positive identification wins. If an XML file has a signature,
// LTIF_XML is NOT set in the output. If you want to know if a file is XML, you can call
// ScanXMLEncoding(A|W) to see if it begins with a valid XML declaration.
//
// The XML declaration must appear at the very start of the image. An example is: 
//
//     <?xml version="1.0" encoding="UTF-8"?>
//
// The 'encoding' part of the declaration is optional.  If the encoding is not 
// specified, the XML standard default encoding CP_UTF8 is returned.  No further 
// analysis is perfomed to verify that the file is actually valid UTF-8 (or XML).  
// Be aware that XML is commonly written without a declared encoding, but actually 
// saved in the current system codepage. It appears that most Microsoft XML 
// processors tolerate this non-conforming practice.
//
// To verify that the file is actually UTF-8, you can use the code:
//
//     GetImageFormat (LTIF_DETECT, cbData, pData, &ltiResult);
//     if (CP_UTF8 == LTI_CP(ltiResult))
//         ; // file is valid UTF-8
//
// Or, you can use the UniLib UTF-8 functions directly for speed, precision, and more
// detailed diagnostic information.
//
//
HRESULT WINAPI GetImageFormat (
  LTI_INFO     Info,      // detection instructions
  DWORD        cbData,
  PCBYTE       pData,
  LTI_INFO *   pInfo      // result
  );

//------------------------------------------------------------------------------
// Simple signatures-only check (no parsing or data analysis)
HRESULT WINAPI GetImageSignature (
  DWORD        cbData,
  PCBYTE       pData,
  LTI_INFO *   pInfo
  );

//------------------------------------------------------------------------------
// TextImageUnicodeSize - get the exact Unicode size of a plain-text disk image
//
// Does not detect: ignores LTIF_DETECT, LTIF_HTML, LTIF_XML
// lti must have been created by running GetImageSignature or GetImageFormat
//
HRESULT WINAPI TextImageUnicodeSize (
  LTI_INFO    lti,      // format of image
  DWORD       cbData,   // image size (including signature)
  PCBYTE      pData,    // image data (including signature)
  DWORD *     pdwSize   // Unicode size
  );

//------------------------------------------------------------------------------
// GetTextImageSize - Get plain-text disk image size of a Unicode buffer
//
// Get the byte size guaranteed to hold the text when converted from Unicode to 
// the specified/detected file format.
//
// if fExact is true, returns the exact size required. This can be expensive to calculate.
// if fExact is false, returns the minimum size guaranteed to hold the data.
//
HRESULT WINAPI GetTextImageSize (
  LTI_INFO      lti,            // [in]   Format, detection instructions
  BOOL          fExact,         // [in]   Exact (TRUE) or minimum (FALSE) to calculate
  DWORD         cch,            // [in]   Count of characters in pwch
  PCWSTR        pwch,           // [in]   Unicode data
  LTI_INFO *    pInfo,          // [out]  Format used
  DWORD *       pcb             // [out]  Count of bytes for image
  );

//------------------------------------------------------------------------------
// TextImageToUnicode - Converts a plaint-text file image to a Unicode buffer
//
// Does not detect: ignores LTIF_DETECT, LTIF_HTML, LTIF_XML
// lti must have been created by running GetImageSignature or GetImageFormat
//
HRESULT WINAPI TextImageToUnicode (
  LTI_INFO    lti,        // [in]  File format
  BOOL        fCheckSize, // [in]  Check that cch is large enough?
  DWORD       cbData,     // [in]  Size of text data (including signature)
  PCBYTE      pData,      // [in]  Text data (including signature)
  DWORD       cch,        // [in]  Size of Unicode buffer
  PWSTR       pwch        // [out] Unicode buffer
  );

//------------------------------------------------------------------------------
// LoadTextFile - Load a plain-text file into a BSTR
// See GetImageFormat for information on how lti is set/returned.
//
HRESULT WINAPI LoadTextFile (
  LPCOLESTR     pszFilename,    // file name
  LTI_INFO      lti,            // Instructions for format, detection
  BSTR *        pbstr,          // [out] text of file
  LTI_INFO *    plti = NULL     // [out] format used
  );

HRESULT WINAPI LoadTextFileFromHandle (
  HANDLE        hFile,          // file handle
  LTI_INFO      lti,            // Instructions for format, detection
  BSTR *        pbstr,          // [out] text of file
  LTI_INFO *    plti = NULL     // [out] format used
  );


//------------------------------------------------------------------------------
// LoadBasicTextFile  - Load a basic plain-text file into a BSTR
//
// Use only for files known to be simple text files (NOT HTML/XML).
// Checks only file signatures to diagnose format, similar to Notepad.
// Does NOT recognize XML or HTML or detect UTF-8 or other codepages.
//
HRESULT WINAPI LoadBasicTextFile (
  LPCOLESTR     pszFilename, // [in ] filename
  BSTR *        pbstr        // [out] text of file's contents
  );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\TxEventSink.h ===
// TextEventSink.h - template classes for text event proxies
//  IVsTextImageEvents
//  IVsTextLinesEvents
//
// Microsoft Confidential
// Copyright 1999 Microsoft Corporation.  All Rights Reserved.
//
//================================================================
// Created March 9 1999, Paul Chase Dempsey [paulde]
//
#pragma once

//------------------------------------------------------------------------------
// class CTextLinesEventSink
//
// Declare ptr like this:
//    CComObject<CTextLinesEventSink<CMyClass> > *  pTextLinesEventSink = NULL;
//
// Create instance and initialize it like this:
//     hr = CComObject<CTextLinesEventSink<CMyClass> >::CreateInstance (&pTextLinesEventSink);
//     if (SUCCEEDED(hr))
//         SetObject (this); // CMyClass*
//
//------------------------------------------------------------------------------
template <class T> class ATL_NO_VTABLE CTextLinesEventSink :
    public CComObjectRoot,
    public IVsTextLinesEvents
{
private:
    T * m_pObj;       // Delegation target

public:
    CTextLinesEventSink  () : m_pObj(NULL) {}
    ~CTextLinesEventSink () {}

    // After creating, set the delegation target
    VOID SetObject (T * pObj) { m_pObj = pObj; }

    BEGIN_COM_MAP(CTextLinesEventSink)
        COM_INTERFACE_ENTRY(IVsTextLinesEvents)
    END_COM_MAP()

    // IVsTextLinesEvents methods
    STDMETHOD_(void, OnChangeLineText)(const TextLineChange *pTextLineChange, BOOL fLast)
        { m_pObj->OnChangeLineText (pTextLineChange, fLast); }

    STDMETHOD_(void, OnChangeLineAttributes)(long iFirstLine, long iLastLine)
        { m_pObj->OnChangeLineAttributes (iFirstLine, iLastLine); }
};

//------------------------------------------------------------------------------
// class CTextImageEventSink
//------------------------------------------------------------------------------
template <class T> class ATL_NO_VTABLE CTextImageEventSink :
    public CComObjectRoot,
    public IVsTextImageEvents
{
private:
    T * m_pObj;       // Owner

public:
    VOID SetObject (T * pObj) { m_pObj = pObj; }

    BEGIN_COM_MAP(CTextImageEventSink)
        COM_INTERFACE_ENTRY(IVsTextImageEvents)
    END_COM_MAP()

    // IVsTextImageEvents methods
    STDMETHOD_(void, OnTextChange) (TextAddress taStart, TextAddress taEnd, TextAddress taNewEnd)
    {
        m_pObj->OnTextChange (taStart, taEnd, taNewEnd);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\TxLineHlp.h ===
// TxLineHlp.h - IVsTextLines helpers
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1999 Microsoft Corporation.  All Rights Reserved.
//
// Paul Chase Dempsey [paulde]
//-----------------------------------------------------------------

#pragma once
//#include "textmgr.h"


//-----------------------------------------------------------------
// TextLines_GetSize - return a count of WCHARS in the buffer
//
LONG WINAPI TextLines_GetSize (IVsTextLines * pText);


//-----------------------------------------------------------------
// TextLines_GetLineCount - return a count of lines in the buffer
//
LONG WINAPI TextLines_GetLineCount (IVsTextLines * pText);


//-----------------------------------------------------------------
// TextLines_GetLineLength 
//
// return a count of chars in the line, not including EOL
//
LONG WINAPI TextLines_GetLineLength (IVsTextLines * pText, LONG iLine);


//-----------------------------------------------------------------
// TextLines_GetLastLineAndLength
//
// return the last valid line in the buffer and fetch it's length
//
LONG WINAPI TextLines_GetLastLineAndLength (IVsTextLines * pText, LONG *pcch);


//-----------------------------------------------------------------
// TextLines_GetSpanLength
//
// return the length of the span
//
LONG WINAPI TextLines_GetSpanLength (IVsTextLines * pText, const TextSpan * pSpan);


//-----------------------------------------------------------------
// TextLines_GetLine - get a line
//
HRESULT WINAPI TextLines_GetLine (
    IVsTextLines *  pText, 
    LONG            iLine, 
    DWORD           glde,  // GLDE_FLAGS enum in TextMgr.idl
    LINEDATAEX &    ld
    );


//-----------------------------------------------------------------
// TextLines_ReleaseLine - release a line
//
// If GetLine fails, do NOT call ReleaseLine: it is an error to release a 
// line that you didn't get.
//
void WINAPI TextLines_ReleaseLine (IVsTextLines *  pText, LINEDATAEX & ld);


//-----------------------------------------------------------------
// TextLines_Append - append text to the end of the buffer
//
// EOL is always normalized
//
HRESULT WINAPI TextLines_Append (IVsTextLines * pText, LPCOLESTR psz, TextSpan *pts = NULL);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\TxImgHlp.h ===
// TxImgHlp.h - IVsTextImage helpers

#pragma once
#include "dbgout.h"

inline LONG WINAPI TextImage_GetSize (IVsTextImage * pText)
{
    LONG cch;
    VERIFY(SUCCEEDED(pText->GetCharSize(&cch)));
    return cch;
}

inline LONG WINAPI TextImage_GetLineCount (IVsTextImage * pText)
{
    LONG cLines;
    VERIFY(SUCCEEDED(pText->GetLineSize(&cLines)));
    return cLines;
}

inline LONG WINAPI TextImage_GetLineLength (IVsTextImage * pText, LONG iLine)
{
    LONG len = 0; 
    VERIFY(SUCCEEDED(pText->GetLineLength(iLine, &len)));
    return len;
}

inline LONG WINAPI TextImage_GetSpanLength (IVsTextImage * pText, const TextSpan * pSpan)
{
    LONG len = 0;
    VERIFY(SUCCEEDED(pText->GetSpanLength(pSpan, &len)));
    return len;
}

inline HRESULT WINAPI TextImage_GetLine (IVsTextImage * pText, LONG iLine, DWORD glde, LINEDATAEX & ld)
{
    return pText->GetLine (glde, iLine, 0, 0, &ld);
}

inline void WINAPI TextImage_ReleaseLine (IVsTextImage * pText, LINEDATAEX & ld)
{
    VERIFY(SUCCEEDED(pText->ReleaseLine(&ld)));
}

// Increment/Decrement Address
//
// TRUE  = changed and new coordinate is valid
// FALSE = reached edge of document - not changed
//
// These move by single WCHARs only
BOOL WINAPI TextImage_IncrementAddress (IVsTextImage * pImage, CTextAddress & ta);
BOOL WINAPI TextImage_DecrementAddress (IVsTextImage * pImage, CTextAddress & ta);

// These honor composite character boundaries (surrogates, combining characters)
BOOL WINAPI TextImage_IncrementAddressComposite (IVsTextImage * pImage, CTextAddress & ta);
BOOL WINAPI TextImage_DecrementAddressComposite (IVsTextImage * pImage, CTextAddress & ta);

// Get the type of line ending used in the image.
// Be aware that an image can contain multiple types of line endings.
// This helper samples only one or a few lines.
EOLTYPE WINAPI TextImage_GetEolType(IVsTextImage * pImage);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\textspan.h ===
// textspan.h - TextAddress/TextSpan operators
//
// Microsoft Confidential
// Copyright 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
// Author: Paul Chase Dempsey [paulde]
//
// Consider:
//      IVsTextLines-aware methods
//
/*
  Notes:

  It would be much nicer to inherit from TextSpan, but you can't inherit
  and form a union with the base class. To take the advantages of the
  union for direct comparisons and assignments, we don't inherit.

*/
//================================================================
#pragma once
#include "unimisc.h"
#define INVALID_TA ((TEXTADDR)-1)

inline int EOLLen(unsigned eol)
{
    return (int)((eolCRLF == eol) ? 2 : ((eolNONE == eol) ? 0 : 1));
}

// init a TextAddress
#define TA_SET(ta, iLine, iIndex) { (ta).line = (iLine); (ta).index = (iIndex); }
#define PTA_SET(pta, iLine, iIndex) { (pta)->line = (iLine); (pta)->index = (iIndex); }

// init a TextSpan
#define TS_SET(ts, StartLine, StartIndex, EndLine, EndIndex)       \
{                                                                  \
    (ts).iStartLine  = (StartLine);                                \
    (ts).iStartIndex = (StartIndex);                               \
    (ts).iEndLine    = (EndLine);                                  \
    (ts).iEndIndex   = (EndIndex);                                 \
}

#define PTS_SET(pts, StartLine, StartIndex, EndLine, EndIndex)     \
{                                                                  \
    (pts)->iStartLine  = (StartLine);                              \
    (pts)->iStartIndex = (StartIndex);                             \
    (pts)->iEndLine    = (EndLine);                                \
    (pts)->iEndIndex   = (EndIndex);                               \
}

inline TextAddress & SetTextAddr (TextAddress & ta, long iLine, long iIndex)
{
    ta.index = iIndex;
    ta.line  = iLine;
    return ta;
}

inline TextSpan * SetTextSpan (TextSpan * pts, long StartLine, long StartIndex, long EndLine, long EndIndex)
{
    PTS_SET(pts, StartLine, StartIndex, EndLine, EndIndex);
    return pts;
}

inline TextSpan & SetTextSpan (TextSpan & ts,  long StartLine, long StartIndex, long EndLine, long EndIndex)
{
    TS_SET(ts, StartLine, StartIndex, EndLine, EndIndex);
    return ts;
}

#pragma warning(disable:4201) // unnnamed union/struct

//================================================================
//================================================================
class CTextAddress
{
friend class CTextSpan;
public:
    CTextAddress ()  : m_addr(0) 
    {
    }

    CTextAddress (TEXTADDR ta) : m_addr(ta) 
    {
    }

    CTextAddress (TextAddress ta) : m_ta(ta)
    {
    }

    CTextAddress (long iLine, long iIndex)
    {
        m_ta.index = iIndex;
        m_ta.line = iLine;
    }

    BOOL IsValid () const;

    operator TextAddress & (void);

    TEXTADDR & Address (void);
    long     & Line    (void);
    long     & Index   (void);

    operator == (const CTextAddress & rhs) const;
    operator != (const CTextAddress & rhs) const;
    operator <  (const CTextAddress & rhs) const;
    operator <= (const CTextAddress & rhs) const;
    operator >  (const CTextAddress & rhs) const;
    operator >= (const CTextAddress & rhs) const;

    operator == (const TEXTADDR & rhs) const;
    operator != (const TEXTADDR & rhs) const;
    operator <  (const TEXTADDR & rhs) const;
    operator <= (const TEXTADDR & rhs) const;
    operator >  (const TEXTADDR & rhs) const;
    operator >= (const TEXTADDR & rhs) const;

//private:
    union {
        TEXTADDR    m_addr;
        TextAddress m_ta;
    };
};

inline BOOL CTextAddress::IsValid () const
{ 
    return (m_ta.line >= 0) && (m_ta.index >= 0); 
}

inline CTextAddress::operator TextAddress & (void)
{ 
    return m_ta; 
}

inline TEXTADDR & CTextAddress::Address (void) 
{ 
    return m_addr; 
}

inline long & CTextAddress::Line (void) 
{ 
    return m_ta.line; 
}

inline long & CTextAddress::Index (void) 
{ 
    return m_ta.index; 
}

inline CTextAddress::operator == (const CTextAddress & rhs) const 
{ 
    return (m_addr == rhs.m_addr); 
}

inline CTextAddress::operator != (const CTextAddress & rhs) const 
{ 
    return (m_addr != rhs.m_addr); 
}

inline CTextAddress::operator <  (const CTextAddress & rhs) const 
{ 
    return (m_addr <  rhs.m_addr); 
}

inline CTextAddress::operator <= (const CTextAddress & rhs) const 
{ 
    return (m_addr <= rhs.m_addr); 
}

inline CTextAddress::operator >  (const CTextAddress & rhs) const 
{ 
    return (m_addr >  rhs.m_addr); 
}

inline CTextAddress::operator >= (const CTextAddress & rhs) const 
{ 
    return (m_addr >= rhs.m_addr); 
}

inline CTextAddress::operator == (const TEXTADDR & rhs) const 
{ 
    return (m_addr == rhs); 
}

inline CTextAddress::operator != (const TEXTADDR & rhs) const 
{ 
    return (m_addr != rhs); 
}

inline CTextAddress::operator <  (const TEXTADDR & rhs) const 
{ 
    return (m_addr <  rhs); 
}

inline CTextAddress::operator <= (const TEXTADDR & rhs) const 
{ 
    return (m_addr <= rhs); 
}

inline CTextAddress::operator >  (const TEXTADDR & rhs) const 
{ 
    return (m_addr >  rhs); 
}

inline CTextAddress::operator >= (const TEXTADDR & rhs) const 
{ 
    return (m_addr >= rhs); 
}

// global operators
inline operator == (const TEXTADDR & lhs, const CTextAddress & rhs) 
{ 
    return (lhs == rhs.m_addr); 
}

inline operator != (const TEXTADDR & lhs, const CTextAddress & rhs) 
{ 
    return (lhs != rhs.m_addr); 
}

inline operator <  (const TEXTADDR & lhs, const CTextAddress & rhs) 
{ 
    return (lhs <  rhs.m_addr); 
}

inline operator <= (const TEXTADDR & lhs, const CTextAddress & rhs) 
{ 
    return (lhs <= rhs.m_addr); 
}

inline operator >  (const TEXTADDR & lhs, const CTextAddress & rhs) 
{ 
    return (lhs >  rhs.m_addr); 
}

inline operator >= (const TEXTADDR & lhs, const CTextAddress & rhs) 
{ 
    return (lhs >= rhs.m_addr); 
}

//================================================================
//================================================================
class CTextSpan
{
friend class CTextAddress;
public:
    CTextSpan () : m_addrStart(0), m_addrEnd(0) 
    {
    }

    CTextSpan (int n) : m_addrStart(n), m_addrEnd(n) 
    {
    }

    CTextSpan (const TextSpan & ts) : m_ts(ts) 
    {
    }

    CTextSpan (TEXTADDR start, TEXTADDR end) : m_addrStart(start), m_addrEnd(end) 
    {
    }

    CTextSpan (TextAddress start, TextAddress end) 
    { 
        TS_SET(m_ts, start.line, start.index, end.line, end.index); 
    }

    CTextSpan (const CTextAddress & taStart, const CTextAddress & taEnd) 
    : m_addrStart(taStart.m_addr), m_addrEnd(taEnd.m_addr) 
    {
    }

    CTextSpan (long iLine, long iIndex)
    { 
        TS_SET(m_ts, iLine, iIndex, iLine, iIndex); 
    }

    CTextSpan (long iStartLine, long iStartIndex, long iEndLine, long iEndIndex)
    { 
        TS_SET(m_ts, iStartLine, iStartIndex, iEndLine, iEndIndex); 
    }

    CTextSpan (const CTextSpan & cts)
    : m_addrStart(cts.m_addrStart), m_addrEnd(cts.m_addrEnd) 
    {
    }

    //
    // Utils
    //
    BOOL IsValid        (void) const;
    long LineCount      (void) const;
    long Width          (void) const;
    BOOL IsEmpty        (void) const;
    BOOL IsOneLine      (void) const;
    BOOL IsForward      (void) const;
    void MakeForward    (void);
    void Expand         (const CTextSpan & cts); // Expands this span to enclose the text of both spans
    void Extend         (TEXTADDR TA);           // Extend this span to enclose the address

    //
    // Direct R/W member access
    //
    operator TextSpan & ();

    TextSpan *      Span            (void);
    long &          StartLine       (void);
    long &          StartIndex      (void);
    long &          EndLine         (void);
    long &          EndIndex        (void);
    CTextAddress &  Start           (void);
    CTextAddress &  End             (void);
    TEXTADDR &      StartAddress    (void);
    TEXTADDR &      EndAddress      (void);

    //
    // Comparisons
    //
    BOOL Encloses (long iLine, long iIndex) const;
    BOOL Encloses (CTextAddress ta) const;
    BOOL Encloses (const TextSpan & ts) const;

    operator == (TEXTADDR rhs) const;
    operator != (TEXTADDR rhs) const;
    operator <  (TEXTADDR rhs) const;
    operator <= (TEXTADDR rhs) const; // !! NOT the same as ((a < b) || (a == b))
    operator >  (TEXTADDR rhs) const; 
    operator >= (TEXTADDR rhs) const; // !! NOT the same as ((a > b) || (a == b))

    operator == (const CTextSpan & rhs);
    operator != (const CTextSpan & rhs);
    operator <  (const CTextSpan & rhs);
    operator >  (const CTextSpan & rhs);

    
    //{{ +++ Text editor compatability --------------------------------

    void Init (long iSL, long iSI, long iEL, long iEI);

    BOOL AttemptToMakeNonEmpty(long iLastLegalIndex);

    __int64 StartPseudoPos (void) { return m_addrStart.Address(); }
	__int64 EndPseudoPos   (void) { return m_addrEnd.Address(); }

    //}} --- Text editor compatability --------------------------------

//private:

/*
PREFIX31 can't handle this structure
*/
#ifndef _PREFIX_
    union {
        struct {
#endif // _PREFIX_
            CTextAddress m_addrStart;
            CTextAddress m_addrEnd;
#ifndef _PREFIX_
        };
#endif // _PREFIX_
        TextSpan     m_ts;
#ifndef _PREFIX_
    };
#endif // _PREFIX_
};

inline BOOL CTextSpan::IsValid (void) const 
{
    return ((m_ts.iStartIndex >= 0) && (m_ts.iEndIndex >= 0) &&
            (m_ts.iStartLine  >= 0) && (m_ts.iEndLine  >= 0) );
}

inline long CTextSpan::LineCount (void) const 
{
    long d = (m_ts.iEndLine - m_ts.iStartLine);
    return 1 + ((d < 0) ? -d : d);
}

inline long CTextSpan::Width (void) const 
{ 
    return (m_ts.iEndIndex - m_ts.iStartIndex); 
}

inline BOOL CTextSpan::IsEmpty (void) const 
{ 
    return (m_addrStart == m_addrEnd); 
}

inline BOOL CTextSpan::IsOneLine (void) const 
{ 
    return (m_ts.iStartLine == m_ts.iEndLine); 
}

inline BOOL CTextSpan::IsForward (void) const 
{ 
    return !(m_addrEnd < m_addrStart); 
}

inline void CTextSpan::MakeForward () 
{ 
    if (m_addrEnd < m_addrStart) 
        Swap(m_addrStart, m_addrEnd); 
}

// Expands this span to enclose the text of both spans
inline void CTextSpan::Expand (const CTextSpan & cts)
{
    m_addrStart = min(m_addrStart, cts.m_addrStart);
    m_addrEnd   = max(m_addrEnd,   cts.m_addrEnd);
}

// Extend this span to enclose the address
inline void CTextSpan::Extend (TEXTADDR TA)
{
    if (m_addrStart > TA)
        m_addrStart = TA;
    else if (m_addrEnd < TA)
        m_addrEnd = TA;
}

//
// Direct R/W member access
//
inline CTextSpan::operator TextSpan & (void) 
{ 
    return m_ts; 
}

inline TextSpan * CTextSpan::Span (void) 
{ 
    return &m_ts; 
}

inline long & CTextSpan::StartLine (void) 
{ 
    return m_ts.iStartLine; 
}

inline long & CTextSpan::StartIndex (void) 
{ 
    return m_ts.iStartIndex; 
}

inline long & CTextSpan::EndLine (void) 
{ 
    return m_ts.iEndLine; 
}

inline long & CTextSpan::EndIndex (void) 
{ 
    return m_ts.iEndIndex; 
}

inline CTextAddress & CTextSpan::Start (void) 
{ 
    return m_addrStart; 
}

inline CTextAddress & CTextSpan::End (void) 
{ 
    return m_addrEnd; 
}

inline TEXTADDR & CTextSpan::StartAddress (void) 
{ 
    return m_addrStart.Address(); 
}

inline TEXTADDR & CTextSpan::EndAddress (void) 
{ 
    return m_addrEnd.Address(); 
}

//
// Comparisons
//
inline BOOL CTextSpan::Encloses (long iLine, long iIndex) const
{
    CTextAddress cta(iLine, iIndex);
    return (cta >= m_addrStart) && (cta <= m_addrEnd);
}

inline BOOL CTextSpan::Encloses (CTextAddress ta) const
{
    return (ta >= m_addrStart) && (ta <= m_addrEnd);
}

inline BOOL CTextSpan::Encloses (const TextSpan & ts) const
{
    CTextSpan cts(ts);
    return (m_addrStart <= cts.m_addrStart) &&
           (m_addrEnd   >= cts.m_addrEnd  );
}

inline CTextSpan::operator == (TEXTADDR rhs) const 
{ 
    return ((m_addrStart == rhs) && (m_addrEnd == rhs)); 
}

inline CTextSpan::operator != (TEXTADDR rhs) const 
{ 
    return ((m_addrStart != rhs) || (m_addrEnd != rhs)); 
}

inline CTextSpan::operator < (TEXTADDR rhs) const 
{ 
    return (m_addrEnd < rhs); 
}

inline CTextSpan::operator <= (TEXTADDR rhs) const // !! NOT the same as ((a < b) || (a == b))
{ 
    return (m_addrEnd <= rhs); 
} 

inline CTextSpan::operator > (TEXTADDR rhs) const 
{ 
    return (m_addrStart > rhs); 
}

inline CTextSpan::operator >= (TEXTADDR rhs) const // !! NOT the same as ((a > b) || (a == b))
{ 
    return (m_addrStart >= rhs); 
} 

inline CTextSpan::operator == (const CTextSpan & rhs) 
{ 
    return ((m_addrStart == rhs.m_addrStart) && (m_addrEnd == rhs.m_addrEnd)); 
}

inline CTextSpan::operator != (const CTextSpan & rhs) 
{ 
    return ((m_addrStart != rhs.m_addrStart) || (m_addrEnd != rhs.m_addrEnd)); 
}

inline CTextSpan::operator < (const CTextSpan & rhs) 
{ 
    return (m_addrEnd < rhs.m_addrStart); 
}

inline CTextSpan::operator > (const CTextSpan & rhs) 
{ 
    return (m_addrStart > rhs.m_addrEnd); 
}

inline void CTextSpan::Init (long iSL, long iSI, long iEL, long iEI) 
{ 
    TS_SET(m_ts, iSL, iSI, iEL, iEI); 
}

inline BOOL CTextSpan::AttemptToMakeNonEmpty (long iLastLegalIndex)
{
    if (!IsEmpty())
        return TRUE;
    if (m_ts.iEndIndex < iLastLegalIndex)
    {
        m_ts.iEndIndex++;
        return TRUE;
    }
    if (m_ts.iStartIndex > 0)
    {
        m_ts.iStartIndex--;
        return TRUE;
    }
    return FALSE;
}

//inline long TA_Line  (TEXTADDR TA) { TextAddress ta; ta.ta = TA; return ta.line; }
//inline long TA_Index (TEXTADDR TA) { TextAddress ta; ta.ta = TA; return ta.index; }

// expand members in method calls

// 'TA' = CTextAddress
#define TA_COORDS(ta) (ta).line, (ta).index
#define PTA_COORDS(pta) (pta)->line, (pta)->index

// 'TS' = TextSpan
#define TS_START(ts)  (ts).iStartLine, (ts).iStartIndex
#define TS_END(ts)    (ts).iEndLine,   (ts).iEndIndex
#define TS_COORDS(ts) (ts).iStartLine, (ts).iStartIndex, (ts).iEndLine, (ts).iEndIndex

#define ATS_START(ts)  &(ts).iStartLine, &(ts).iStartIndex
#define ATS_END(ts)    &(ts).iEndLine,   &(ts).iEndIndex
#define ATS_COORDS(ts) &(ts).iStartLine, &(ts).iStartIndex, &(ts).iEndLine, &(ts).iEndIndex

// 'PTS' = TextSpan *
#define PTS_START(pts)  (pts)->iStartLine, (pts)->iStartIndex
#define PTS_END(pts)    (pts)->iEndLine,   (pts)->iEndIndex
#define PTS_COORDS(pts) (pts)->iStartLine, (pts)->iStartIndex, (pts)->iEndLine, (pts)->iEndIndex

// 'CTS' = CTextSpan
#define CTS_START(ts)  (ts).StartLine(), (ts).StartIndex()
#define CTS_END(ts)    (ts).EndLine(),   (ts).EndIndex()
#define CTS_COORDS(ts) (ts).StartLine(), (ts).StartIndex(), (ts).EndLine(), (ts).EndIndex()

#define ACTS_START(ts)  &(ts).m_ts.iStartLine, &(ts).m_ts.iStartIndex
#define ACTS_END(ts)    &(ts).m_ts.iEndLine,   &(ts).m_ts.iEndIndex
#define ACTS_COORDS(ts)  &(ts).m_ts.iStartLine, &(ts).m_ts.iStartIndex, &(ts).m_ts.iEndLine,  &(ts).m_ts.iEndIndex

// 'PCTS' = CTextSpan *
#define PCTS_START(pts)  (pts)->StartLine(), (pts)->StartIndex()
#define PCTS_END(pts)    (pts)->EndLine(),   (pts)->EndIndex()
#define PCTS_COORDS(pts) (pts)->StartLine(), (pts)->StartIndex(), (pts)->EndLine(), (pts)->EndIndex()

inline BOOL TextSpan_IsValid (const TextSpan & ts)
{
    return ((ts.iStartIndex >= 0) && (ts.iEndIndex >= 0) &&
            (ts.iStartLine  >= 0) && (ts.iEndLine  >= 0) );
}

inline BOOL TextSpan_IsValid (const TextSpan * pts) 
{
    return ((pts->iStartIndex >= 0) && (pts->iEndIndex >= 0) &&
            (pts->iStartLine  >= 0) && (pts->iEndLine  >= 0) );
}

inline BOOL TextSpan_IsEmpty (const TextSpan & ts ) 
{ 
    return (ts.iStartIndex == ts.iEndIndex) && 
           (ts.iStartLine  == ts.iEndLine); 
}

inline BOOL TextSpan_IsEmpty (const TextSpan * pts) 
{ 
    return (pts->iStartIndex == pts->iEndIndex) && 
           (pts->iStartLine  == pts->iEndLine); 
}

inline BOOL TextSpan_IsForward (const TextSpan & ts) 
{ 
    CTextSpan cts(ts); 
    return cts.IsForward(); 
}

inline BOOL TextSpan_IsForward (const TextSpan * pts) 
{ 
    return TextSpan_IsForward(*pts); 
}

inline long TextSpan_LineCount (const TextSpan & ts ) 
{ 
    long d = (ts.iEndLine - ts.iStartLine); 
    return (d < 0) ? (-d + 1) : (d + 1); 
}

inline long TextSpan_LineCount (const TextSpan * pts) 
{ 
    long d = (pts->iEndLine - pts->iStartLine); 
    return (d < 0) ? (-d + 1) : (d + 1); 
}

inline long TextSpan_ColumnDifference (const TextSpan & ts ) 
{ 
    return (ts.iEndIndex - ts.iStartIndex); 
}

inline long TextSpan_ColumnDifference (const TextSpan * pts) 
{ 
    return (pts->iEndIndex - pts->iStartIndex); 
}

inline void TextSpan_MakeForward (TextSpan & ts)
{
    CTextSpan cts(ts);
    if (cts.IsForward()) return;
    cts.MakeForward();
    ts = cts;
}

enum TS_RELATION {
    ALessB          = 0x00,
    AAtStartB       = 0x04,
    AOverStartB     = 0x08,
    AEqualB         = 0x49,
    AOverEndB       = 0x8a,
    AAtEndB         = 0x9a,
    AGreaterB       = 0xaa,
    AInsideB        = 0x88,
    AEncloseB       = 0x0a,
    AEncloseStartB  = 0x09,
    AEncloseEndB    = 0x4a,
    AIsStartB       = 0x44,
    AIsEndB         = 0x99,
    BIsStartA       = 0x5A,
    BIsEndA         = 0x05,
    AIsB            = 0x55
};

inline BYTE Compare (const CTextSpan & A, const CTextSpan & B)
{
    BYTE b1, b2, b3, b4;
    b1 = (BYTE)(1 + SignOf(B.m_addrStart.m_addr - A.m_addrStart.m_addr));
    b2 = (BYTE)(1 + SignOf(B.m_addrEnd.m_addr   - A.m_addrStart.m_addr));
    b3 = (BYTE)(1 + SignOf(B.m_addrStart.m_addr - A.m_addrEnd.m_addr));
    b4 = (BYTE)(1 + SignOf(B.m_addrEnd.m_addr   - A.m_addrEnd.m_addr));
    return (b1 << 6) | (b2 << 4) | (b3 << 2) | b1;
}
/*****************************************************************

(l)ess    = 00 (0)
(e)qual   = 01 (1)
(g)reater = 10 (2)

------------------------    ------------------------    ------------------------
      Description              a1b1 a1b2 a2b1 a2b2             Picture
------------------------    ------------------------    ------------------------

A less than B               llll    00000000    0x00    |aaaa|  |bbbb|

A at start of B             llel    00000100    0x04       |aaaa|
                                                                |bbbb|

A overlaps start of B       llgl    00001000    0x08         |aaaa|
                                                                |bbbb|

A == B                      elge    01001001    0x49            |aaaa|
                                                                |bbbb|

A overlaps end of B         glgg    10001010    0x8a               |aaaa|
                                                                |bbbb|

A at end of B               gegg    10011010    0x9a                 |aaaa|
                                                                |bbbb|

A > B                       gggg    10101010    0xaa                   |aaaa|
                                                                |bbbb|

A inside B (B encloses A)   glgl    10001000    0x88       |aa|
                                                         |bbbbbb|

A encloses B (B inside A)   llgg    00001010    0x0a    |aaaaaa|
                                                          |bb|

A encloses start of B       llge    00001001    0x09    |aaaaaa|
                                                           |bbb|

A encloses end of B         elgg    01001010    0x4a    |aaaaaa|
                                                        |bbb|

A is start of B             elel    01000100    0x44    Abbbb|

A is end of B               gege    10011001    0x99    |bbbbA

B is start of A             eegg    01011010    0x5A    Baaaa|

B is end of A               llee    00000101    0x05    |aaaaB

A and B are the same point  eeee    01010101    0x55

*****************************************************************/

// implemented in SpanSet.cpp
//
// Track* track an address or span with a change, as given by the
// arguments to IVsTextImageEvents
//
void WINAPI TrackAddress (
    CTextAddress & ta,          // address to track
    CTextAddress taStart,       // start of changed text
    CTextAddress taEnd,         // end of changed text
    CTextAddress taNewEnd       // new end of text
    );

void WINAPI TrackSpan (
    CTextSpan & ts,             // span to track
    CTextAddress taStart,       // start of changed text
    CTextAddress taEnd,         // end of changed text  
    CTextAddress taNewEnd       // new end of text      
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\ucdecomp.h ===
// ucDecomp.h
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// June 15, 1998 [paulde]
//
//-----------------------------------------------------------------
#pragma once
#ifndef __UCDECOMP_H__
#define __UCDECOMP_H__

PCWSTR  WINAPI  Decomposition     (WCHAR ch);
int     WINAPI  DecomposeStr      (PCWSTR src, int cchSrc, PWSTR dst, int cchDst);
BOOL    WINAPI  CanonCombiningStr (PWSTR  str, int cch);
int     WINAPI  CanonDecomposeStr (PCWSTR src, int cchSrc, PWSTR dst, int cchDst);

//---------------------------------------------------------------------
//
// PCWSTR Decomposition (WCHAR ch)
//
// Return decomposition of ch, or NULL if none.
//

//---------------------------------------------------------------------
//
// int DecomposeStr (PCWSTR src, int cchSrc, PWSTR dst, int cchDst)
//
// Decompose src into dst.
//
// cchSrc can be -1 for null-terminated mode.
// cchDst can be 0 to query for the required size to hold the decomposed string.
//
// Returns count of chars written.
//
// The decomposition is a maximal decomposition, but combining chars 
// are not in canonical order. See CanonCombiningStr and CanonDecomposeStr.
//

//---------------------------------------------------------------------
//
// BOOL CanonCombiningStr (PWSTR str, int cch)
//
// Put string with combining characters into canonical order.
//
// Returns : nonzero if successful, 0 on failure. 
// Call GetLastError() for more info.
//

//---------------------------------------------------------------------
//
// int CanonDecomposeStr (PCWSTR src, int cchSrc, PWSTR dst, int cchDst)
//
// Create a maximally decomposed string in canonical order.
//
// cchSrc can be -1 for null-terminated mode.
// cchDst can be 0 to query for the required size to hold the decomposed string.
//
// Returns count of chars written if successful, 0 on failure
// Call GetLastError() for more info.
//

#endif // __UCDECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\uniapi.h ===
// UniApi.h - Unicode API wrappers
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// November 8, 1998 [paulde]
//
//
// TODO: 64-bit: these build targets are Unicode only so
//       the wrappers can be a simple #define alias for the W API.
//
#pragma once

//$UNDONE(olgaark)  We should keep this file free of ATL. The CCOmBSTR helpers should be moved.
#ifndef UNIAPI_NOATL
#include "atlbase.h"
#endif

//---------------------------------------------------------------
// Initialization

// This function must be called once before anything else to detect system support
BOOL    WINAPI W_IsUnicodeSystem();

//---------------------------------------------------------------
// API Wrappers
//---------------------------------------------------------------
#if defined(_M_IA64) 

#define W_FindFirstFile FindFirstFileW
#define W_FindNextFile          FindNextFileW
#define W_GetFileAttributes     GetFileAttributesW
#define W_SetFileAttributes     SetFileAttributesW
#define W_GetFullPathName       GetFullPathNameW
#define W_CreateFile            CreateFileW
#define W_GetCurrentDirectory   GetCurrentDirectoryW
#define W_GetTempPath           GetTempPathW
#define W_GetTempFileName       GetTempFileNameW
#define W_DeleteFile            DeleteFileW
#define W_GetWindowTextLength   GetWindowTextLengthW
#define W_GetWindowText         GetWindowTextW
#define W_RegisterClass         RegisterClassW
#define W_CreateWindowEx        CreateWindowExW
#define W_CreateWindow(C,W,S,x,y,w,h,p,m,i,L) CreateWindowExW(0L,C,W,S,x,y,w,h,p,m,i,L)
#define W_CreateDialogParam     CreateDialogParamW
#define W_CreateDialog(i,t,p,f) CreateDialogParamW(i,t,p,f,NULL)
#define W_CreateDialogIndirect(i,t,p,f) CreateDialogIndirectParamW(i,t,p,f,NULL)
#define W_CopyFile(s,d,f)       CopyFileW(s,d,f)

#else

HANDLE  WINAPI W_FindFirstFile      (PCWSTR pFileName, WIN32_FIND_DATAW * pfd);
BOOL    WINAPI W_FindNextFile       (HANDLE h, WIN32_FIND_DATAW * pfd);
DWORD   WINAPI W_GetFileAttributes  (PCWSTR pFileName);
BOOL    WINAPI W_SetFileAttributes  (PCWSTR pFileName, DWORD dwAttr);
DWORD   WINAPI W_GetFullPathName    (PCWSTR pFileName, DWORD cch, PWSTR pBuffer, PWSTR * ppFilePart);
HANDLE  WINAPI W_CreateFile         (PCWSTR pFileName, DWORD dwAccess, DWORD dwShare, SECURITY_ATTRIBUTES * psa,
                                     DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplate );
DWORD   WINAPI W_GetCurrentDirectory(DWORD cch, PWSTR pBuffer);
DWORD   WINAPI W_GetTempPath        (DWORD cch, PWSTR pBuffer);
UINT    WINAPI W_GetTempFileName    (PCWSTR pPathName, PCWSTR pPrefix, UINT uUnique, PWSTR pTempFileName);
BOOL    WINAPI W_DeleteFile         (PCWSTR pPathName);
BOOL    WINAPI W_CopyFile           (PCWSTR pExistingPathName, PCWSTR pNewPathName, BOOL bFailIfExists);

int     WINAPI W_GetWindowTextLength (HWND hwnd); // per docs, always large enough but not always exact
int     WINAPI W_GetWindowText       (HWND hwnd, PWSTR psz, int cch);

ATOM    WINAPI W_RegisterClass  (CONST WNDCLASSW * pWndClass);

// To see if window is really Unicode after creation, use the IsWindowUnicode() Win32 API
HWND    WINAPI W_CreateWindowEx (DWORD dwExStyle, PCWSTR pClassName, PCWSTR pWindowName,
                                 DWORD dwStyle, int X, int Y, int nWidth, int nHeight,
                                 HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, PVOID lpParam);
#define W_CreateWindow(C,W,S,x,y,w,h,p,m,i,L) W_CreateWindowEx(0L,C,W,S,x,y,w,h,p,m,i,L)

HWND    WINAPI W_CreateDialogParam (HINSTANCE hInstance, PCWSTR pTemplateName, HWND hWndParent, 
                                    DLGPROC pDialogFunc, LPARAM dwInitParam);
#define W_CreateDialog(i,t,p,f) W_CreateDialogParam(i,t,p,f,NULL)

HWND    WINAPI W_CreateDialogIndirectParam (HINSTANCE hInstance, const DLGTEMPLATE * pTemplate,
                                            HWND hWndParent, DLGPROC pDialogFunc, LPARAM dwInitParam);
#define W_CreateDialogIndirect(i,t,p,f) W_CreateDialogIndirectParam(i,t,p,f,NULL)

#endif

//---------------------------------------------------------------
// Additional utility functions
//---------------------------------------------------------------

// These resource string load funcs never convert the string, even on Win9x
// -- you get resource data verbatim.
int     WINAPI W_LoadString   (HINSTANCE hinst, UINT id, PWSTR psz, int cch);
BSTR    WINAPI W_LoadBSTR     (HINSTANCE hInst, UINT id); // Free with SysFreeString
PWSTR   WINAPI W_LoadVSString (HINSTANCE hInst, UINT id); // Free with VSFree


#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))
#endif // !defined(NUMBER_OF)

// Returns length-prefixed non-null-terminated resource image for string
PCWSTR  WINAPI W_GetStringResourceImage (HINSTANCE hinst, UINT id);

// file/directory functions
int WINAPI W_Access(PCWSTR pPathName, int mode);                // _wchdir/_chdir
int WINAPI W_Rename(PCWSTR pOldPathName, PCWSTR pNewPathName);  // _wrename/_rename
int WINAPI W_Remove(PCWSTR pPathName);                          // _wremove/_remove
int WINAPI W_ChDir(PCWSTR pPathName);                           // _wchdir/_chdir
int WINAPI W_MkDir(PCWSTR pPathName);                           // _wmkdir/_mkdir
int WINAPI W_RmDir(PCWSTR pPathName);                           // _wrmdir/_rmdir

// Walk a file's path and get it's actual letter case
void    WINAPI W_GetActualFileCase      (PCWSTR pszName, PWSTR psz);

//---------------------------------------------------------
void inline W_ReplaceChar(PWSTR psz, WCHAR chOld, WCHAR chNew)
{
    if (psz)
    {
        WCHAR ch;
        while (0 != (ch = *psz))
        {
            if (ch == chOld)
                *psz = chNew;
            psz++;
        }
    }
}

//--------------

#ifndef UNIAPI_NOATL
void inline W_AddTrailingChar(ATL::CComBSTR &bstr, WCHAR wch)
{
  int len = bstr.Length();
  if(len > 0)
  {
    if(bstr[len - 1] != wch)
    {
      WCHAR wchBuf[2] = {wch, 0};
      bstr += wchBuf;
    }
  }
}

void inline W_AddTrailingSlash(ATL::CComBSTR &bstrFolder)
{
  W_AddTrailingChar(bstrFolder, L'\\');
}

void inline W_RemoveTrailingSlash(ATL::CComBSTR &bstrFolder)
{
  int len = bstrFolder.Length();
  if(len > 0)
  {
    if(bstrFolder[len - 1] == L'\\')
    {
	  ATL::CComBSTR bstrTmp(bstrFolder);
      bstrTmp[len - 1] = 0;
      bstrFolder = bstrTmp;
    }
  }
}

//---------------------------------------------------------

int inline BSTRcmp(BSTR bstr1, BSTR bstr2)
{
  if ((bstr1 == NULL) && (bstr2 == NULL))
    return 0;
  else if ((bstr1 == NULL) && (bstr2 != NULL))
    return -1;
  else if ((bstr1 != NULL) && (bstr2 == NULL))
    return 1;
  else 
    return wcscmp(bstr1, bstr2);
}

int inline BSTRicmp(BSTR bstr1, BSTR bstr2)
{
  if ((bstr1 == NULL) && (bstr2 == NULL))
    return 0;
  else if ((bstr1 == NULL) && (bstr2 != NULL))
    return -1;
  else if ((bstr1 != NULL) && (bstr2 == NULL))
    return 1;
  else 
    return _wcsicmp(bstr1, bstr2);
}

//------------------------------------------

// GetWindowText
BOOL W_GetWindowText(HWND hwnd, ATL::CComBSTR &bstrText);
BOOL WINAPI W_GetWindowTextTrimSpaces(HWND hwnd, ATL::CComBSTR &bstrText);

BOOL inline W_GetDlgItemText(HWND hwnd, UINT uiID, ATL::CComBSTR &bstrText)
{
  HWND hwndItem = GetDlgItem(hwnd, uiID);
  //_ASSERTE(hwndItem); // commented because we can't rely on _ASSERTE being defined

  return W_GetWindowText(hwndItem, bstrText);
}

BOOL inline W_GetDlgItemTextTrimSpaces(HWND hwnd, UINT uiID, ATL::CComBSTR &bstrText)
{
  HWND hwndItem = GetDlgItem(hwnd, uiID);
  //_ASSERTE(hwndItem); // commented because we can't rely on _ASSERTE being defined

  return W_GetWindowTextTrimSpaces(hwndItem, bstrText);
}

#endif // UNIAPI_NOATL

//----------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\UniEsc.h ===
// UniEsc - escape/unescape non-ASCII in W<->A strings 
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1999 Microsoft Corporation.  All Rights Reserved.
//----------------------------------------------------------------
// This is a suitable way to convert a Unicode string to ASCII (NOT ANSI) 
// and back, preserving all Unicode code points.
//
// By using ASCII (char < 128), the string is transparent to any ANSI/UNICODE/UTF-8 
// conversions it may suffer during it's lifetime, and the original Unicode text
// can be regenerated.
//
// When converting from W to A, all '\' become '\\', and all chars > 127 become
// \u#### where #### is 4 hex digits specifying the unicode code point.
//
// When converting from A to W, '\u####' #### can be 1-4 contiguous hex digits.
// scanning stops at the first non-hex digit. '\u' not followed by a hex digit
// becomes 'u'.
//
// This is a good way to save a Unicode string to the registry as REG_SZ using ANSI
// registry APIs on all platforms.
//
//----------------------------------------------------------------
#pragma once

int   WINAPI GetUnicodeEscapeStringLength   (PCWSTR pszSrc);
int   WINAPI UnicodeEscapeString            (PCWSTR pszSrc, int cch, PSTR  pszDst);
int   WINAPI GetUnicodeUnescapeStringLength (PCSTR  pszSrc);
int   WINAPI UnicodeUnescapeString          (PCSTR  pszSrc, int cch, PWSTR pszDst);

PSTR  WINAPI GetUnicodeEscapeString   (PCWSTR pszSrc); // VSFree result
PWSTR WINAPI GetUnicodeUnescapeString (PCSTR pszSrc);  // VSFree result
BSTR  WINAPI GetUnicodeUnescapeBSTR   (PCSTR pszSrc);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\unicase.h ===
// unicase.h - Unicode letter case
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
// June 1, 1998 [paulde]
//
//-----------------------------------------------------------------
#pragma once
#ifndef __UNICASE_H__
#define __UNICASE_H__

WCHAR   WINAPI  UpperCase (WCHAR c);
WCHAR   WINAPI  LowerCase (WCHAR c);
PWSTR   WINAPI  UpperCaseStr   (PWSTR pSrc); // Returns ptr to 0 terminator
PWSTR   WINAPI  LowerCaseStr   (PWSTR pSrc); // Returns ptr to 0 terminator

//
// To{Upper|Lower}Case - Convert buffer to Upper/Lower case.
// pSrc -- Source string
// pDst -- Destination buffer
// cch  -- For zero-terminated mode, pass -1. pDst assumed to be large enough.
//         Otherwise pass maximum number of characters to convert into pDst
//         including the zero terminator. Conversion always stops at a 0 char
//         in pSrc.
// Returns: pointer to END of pDst
//
PWSTR   WINAPI  ToUpperCase    (PCWSTR pSrc, PWSTR pDst, size_t cch);
PWSTR   WINAPI  ToLowerCase    (PCWSTR pSrc, PWSTR pDst, size_t cch);

//
// Compare[No]Case[N][Prepared]
//
// The szA and/or szB params may be NULL.
//
// *Prepared variations assume that szA is prepared according to 
// LowerCaseStr or ToLowerCase.
//
// Returns:
//      -1  A < B
//       0  A == B
//       1  A > B
//
int     WINAPI  CompareCase            (PCWSTR szA, PCWSTR szB);
int     WINAPI  CompareNoCase          (PCWSTR szA, PCWSTR szB);
int     WINAPI  CompareCaseN           (PCWSTR szA, PCWSTR szB, size_t cch);
int     WINAPI  CompareNoCaseN         (PCWSTR szA, PCWSTR szB, size_t cch);
int     WINAPI  CompareNoCasePrepared  (PCWSTR szA, PCWSTR szB);
int     WINAPI  CompareNoCaseNPrepared (PCWSTR szA, PCWSTR szB, size_t cch);

//
// StrStrNoCase[prepared] - Find <pattern> within <text>
//
// StrStrNoCasePrepared assumes that <pattern> is prepared 
// according to LowerCaseStr or ToLowerCase.
//
// For case-sensitive, you can use the CRT's wcsstr from wchar.h.
//
PCWSTR  WINAPI  StrStrNoCase           (PCWSTR text, PCWSTR pattern);
PCWSTR  WINAPI  StrStrNoCasePrepared   (PCWSTR text, PCWSTR pattern);

// VS7:32377  non-const variants
inline PWSTR WINAPI  StrStrNoCase           (PWSTR text, PCWSTR pattern){return const_cast<PWSTR>(StrStrNoCase (const_cast<PCWSTR>(text), pattern));}
inline PWSTR WINAPI  StrStrNoCasePrepared   (PWSTR text, PCWSTR pattern){return const_cast<PWSTR>(StrStrNoCasePrepared (const_cast<PCWSTR>(text), pattern));}

WCHAR   WINAPI  TitleCaseForUpperCase (WCHAR ch);
BOOL    WINAPI  ExcludeTitleCase      (WCHAR ch);

//----------------------------------------------------------------
// CopyCase  - Copy the letter case of one string to another.
// Changes the case of text in pDst to match the case of the text
// in pSrc. Can be used to implement "Keep Case"-type feature in 
// Find/Replace.
PWSTR WINAPI CopyCase (PCWSTR pSrc, PWSTR pDst);

//
// QCompare[No]Case - qsort WCHAR ptr array functions
//
// qsort(arr, cel, sizeof(PCWSTR), QCompareCase);
//
int __cdecl QCompareCase           (const void * pvA, const void * pvB);
int __cdecl QCompareNoCase         (const void * pvA, const void * pvB);

//
// BCompare[No]Case[Prepared] - bsearch WCHAR ptr array
//
// PCWSTR pszKey = L"Find this";
// PCWSTR psz = bsearch(pszKey, arr, cel, sizeof(PCWSTR), BCompareCase);
//
// BCompareNoCasePrepared assumes pvKey is prepared according to 
// LowerCaseStr or ToLowerCase.
//
int __cdecl BCompareCase           (const void * pvKey, const void * pvEl);
int __cdecl BCompareNoCase         (const void * pvKey, const void * pvEl);
int __cdecl BCompareNoCasePrepared (const void * pvKey, const void * pvEl);

#include "unipriv.h"

/////////////////////////////////////////////////////////////////
// Title case
//

//---------------------------------------------------------------
// TitleCaseForUpperCase
//
// When you have determined that a character is initial and have 
// the Uppercase form, this function substitutes another character 
// that is better for Titlecase than the Uppercase char, otherwise
// it passes the character through.
//
inline WCHAR WINAPI TitleCaseForUpperCase(WCHAR ch)
{
    UASSERT(ch == UpperCase(ch)); // Call this function only with uppercase form!
    
    // probably not
    if (ch < 0x01c4 || ch > 0x01f1)
        return ch;

    // 01C4;LATIN CAPITAL LETTER DZ WITH CARON -> 01C5;LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON
    // 01C7;LATIN CAPITAL LETTER LJ -> 01C8;LATIN CAPITAL LETTER L WITH SMALL LETTER J
    // 01CA;LATIN CAPITAL LETTER NJ -> 01CB;LATIN CAPITAL LETTER N WITH SMALL LETTER J
    // 01F1;LATIN CAPITAL LETTER DZ -> 01F2;LATIN CAPITAL LETTER D WITH SMALL LETTER Z
    //
    // Unicode nicely places all these adjacent with the Titlecase code point 
    // between the Upper and Lower code points.
    if ((0x01C4 == ch) || (0x01C7 == ch) || (0x01CA == ch) || (0x01F1 == ch))
        ch++; 

    return ch;
}

//---------------------------------------------------------------
// ExcludeTitleCase
//
// For a character with a mapping to Uppercase, excludes that 
// character from mapping to Titlecase.
//
// These are all Greek technical symbols that have Uppercase 
// equivalents, but not for Titlecase use.
//
// Pass this function the original, unmapped char -- not the Upppercase char
//
inline BOOL WINAPI ExcludeTitleCase(WCHAR ch)
{
    // probably not
    if ((ch < 0x3D0) || (ch > 0x03F1))
        return FALSE;

    // In the absence of frequency data to determine an optimal 
    // test ordering, use an ordering with strictly humorous value.
    return ((ch == 0x03D1) || // GREEK THETA SYMBOL   // this one I've actually used back in college...
            (ch == 0x03D5) || // GREEK PHI SYMBOL     // to the
            (ch == 0x03D0) || // GREEK BETA SYMBOL    //    head of
            (ch == 0x03F0) || // GREEK KAPPA SYMBOL   //       the class
            (ch == 0x03F1) || // GREEK RHO SYMBOL     // rho your boat downstream
            (ch == 0x03D6)    // GREEK PI SYMBOL      // dessert comes last (I'd have it first, but it's an odd flavor of pi)
        );
}

#endif // __UNICASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\unimisc.h ===
// unimisc.h
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
// June 1, 1998 [paulde]
//

#pragma once
#include "commacro.h"   // COM macros moved to their own header

//---------------------------------------------------------------
// IN_RANGE - Test if v is in the range r1 to r2, inclusive
//
//#define IN_RANGE(v, r1, r2) ((r1) <= (v) && (v) <= (r2))
//
// This impl is slightly smaller with no branches
//
#define IN_RANGE(v, r1, r2) ((unsigned)((v) - (r1)) <= (unsigned)((r2)-(r1)))

template<class T> inline BOOL InRange(const T& v, const T &r1, const T &r2)
{
  //return ((r1 <= v) && (v <= r2));
  return (unsigned)(v - r1) <= (unsigned)(r2 - r1);
}

//---------------------------------------------------------------
// SignOf - get sign of a number
//
// Returns:
//      -1 = n is negative
//       0 = n is zero
//       1 = n is positive
//
template<class T> inline int SignOf(T n)
{
    return ((int)n < 0) ? -1 : n > 0;
}

//---------------------------------------------------------------
// Swap - exchange two values
//
template<class T> inline void Swap(T &a, T &b)
{
    T x = a;
    a = b;
    b = x;
}

//---------------------------------------------------------------
// PtrSwap - exchange two values through pointers
//
template<class T> inline void PtrSwap(T * a, T * b)
{
    T x = *a;
    *a = *b;
    *b = x;
}

//---------------------------------------------------------------
// IsAnsiText - test if some data appears to be valid ANSI text
//
// NOTE: returns FALSE for most Unicode text.
//
// Anything >= 32 is valid
//
// The OK text characters < 32 are 7,8,9,10,12,13,27  (bell, backspace, 
// tab, linefeed, formfeed, carriage-return, esc).
//
// We form a bitset from the char value and see if it intersects 
// the valid set 0x08003780.
//
inline BOOL IsAnsiText (DWORD cb, const BYTE * pb)
{
    while (cb--)
    {
        BYTE b = *pb++;
        if ((b < 32) && !((1UL << b) & 0x08003780))
            return FALSE;
    }
    return TRUE;
}

//---------------------------------------------------------------
// FillXXXX - larger-than-byte fills. Returns a pointer 1 element past the end.
// v for 'value', not 'void'
//
inline WORD *       FillWord        (WORD       * pv, int cel, WORD     v) { while (cel--) *pv++ = v; return pv; }
inline DWORD *      FillDWORD       (DWORD      * pv, int cel, DWORD    v) { while (cel--) *pv++ = v; return pv; }
inline ULONG *      FillULONG       (ULONG      * pv, int cel, ULONG    v) { while (cel--) *pv++ = v; return pv; }
inline int *        FillInt         (int        * pv, int cel, int      v) { while (cel--) *pv++ = v; return pv; }
inline UINT *       FillUINT        (UINT       * pv, int cel, UINT     v) { while (cel--) *pv++ = v; return pv; }
inline UINT_PTR *   FillUINT_PTR    (UINT_PTR   * pv, int cel, UINT_PTR v) { while (cel--) *pv++ = v; return pv; }
#define FillWORD FillWord
#define FillINT  FillInt

#ifndef DELETEPTR
#define DELETEPTR(p)  \
{                     \
    if (p)            \
    {                 \
        delete p;     \
        p = NULL;     \
    }                 \
}
#endif

#ifndef DELETEARR
#define DELETEARR(p)  \
{                     \
    if (p)            \
    {                 \
        delete [] p;  \
        p = NULL;     \
    }                 \
}
#endif

#ifndef DELETEGDIOBJ
#define DELETEGDIOBJ(hobj)             \
{                                      \
    if (hobj)                          \
    {                                  \
        ::DeleteObject((HGDIOBJ)hobj); \
        hobj = NULL;                   \
    }                                  \
}
#endif

// Free BSTR and set to NULL
#ifndef SYSFREE
#define SYSFREE(bstr)         \
{                             \
    if (bstr)                 \
    {                         \
        SysFreeString(bstr);  \
        bstr = NULL;          \
    }                         \
}
#endif

#ifndef VSFREE
#define VSFREE(pv)   \
{                    \
    if (pv)          \
    {                \
        VSFree(pv);  \
        pv = NULL;   \
    }                \
}
#endif

#ifndef VSHEAPFREE
#define VSHEAPFREE(heap, pv)    \
{                               \
    if (pv)                     \
    {                           \
        VSHeapFree(heap, pv);   \
        pv = NULL;              \
    }                           \
}
#endif

#define VSALLOCTYPE(type, cel)        (type *)VSAlloc((cel)*sizeof(type))
#define VSALLOCTYPEZERO(type, cel)    (type *)VSAllocZero((cel)*sizeof(type))
#define VSREALLOCTYPE(type, ptr, cel) (type *)VSRealloc((ptr), (cel)*sizeof(type))
#define VSALLOCSTR(cch)               VSALLOCTYPE(WCHAR, (cch))

//---------------------------------------------------------------
// write optional return value
#ifndef SETRETVAL
#define SETRETVAL(pv, v) { if (pv) (*(pv)) = (v); }
#endif

//---------------------------------------------------------------
class CBufImpl
{
private:
    BYTE * m_pData;
    int    m_cb;
    
    HRESULT _SetByteSize (int cb);

public:
    CBufImpl() : m_pData(NULL), m_cb(0) {}
    ~CBufImpl()  { Clear(); }

    void    Clear             ();
    HRESULT SetByteSize       (int cb);
    HRESULT SetByteSizeShrink (int cb);
    int     GetByteSize       () { return m_cb; }
    BYTE *  ByteData          () { return m_pData; }
};

inline HRESULT CBufImpl::SetByteSize (int cb)
{
    if (cb <= m_cb)
        return S_OK;
    return _SetByteSize(cb);
}

//---------------------------------------------------------------
template <class T> class CMinimalArray : public CBufImpl
{
public:
    HRESULT SetSize       (int cel) { return SetByteSize(cel*sizeof(T)); }
    HRESULT SetSizeShrink (int cel) { return SetByteSizeShrink(cel*sizeof(T)); }
    int     Size    ()        { return GetByteSize()/sizeof(T); }
    operator T*     ()        { return (T*)ByteData(); }
    T*      GetData ()        { return (T*)ByteData(); }
};

typedef UNALIGNED PWSTR   UPWSTR;
typedef UNALIGNED PSTR    UPSTR;
typedef UNALIGNED int *   UPINT;
typedef UNALIGNED long *  UPLONG;
typedef UNALIGNED ULONG * UPULONG;
typedef UNALIGNED DWORD * UPDWORD;

//---------------------------------------------------------------
// CMinimalStream version 2
// 
// This version of CMinimalStream is more efficient in the case 
// where you can grow to a large size. It never reallocates during 
// string building. Instead, it chains blocks and coalesces to a 
// new block of memory only when you ask for a contiguous block
// (Gimme* or *Data).
// 

class CMSBlock; // CMinimalStream helper class

// Callback for CMinimalStream::Walk.
// Return S_FALSE or fail to stop the walk.
typedef HRESULT (CALLBACK * MSWALKFN) (UINT_PTR pUser, BYTE * pb, int cb); 

class CMinimalStream
{
public:
    enum { cbGrowByDefault = 512 };

    CMinimalStream() : m_pData(NULL), m_pCur(NULL), m_cb(0), m_pos(0), m_cbGrowBy(cbGrowByDefault) {}
    ~CMinimalStream();

    // Set byte size of memory blocks. Pass 0 to restore default
    void    GrowBy      (int cb) { m_cbGrowBy = ((cb > 0) ? cb : cbGrowByDefault); }
    void    Reset       (void); // releases all memory

    // Pre-size first block if none
    HRESULT EnsureInitialBlock (int cb = cbGrowByDefault);
    int     Recalc      (int * ppos = NULL); // calculate total data size and optionally, virtual position

    HRESULT Add         (const BYTE * pbData, int cb);
    HRESULT AddStringA  (PCSTR  psz, int cch = -1);
    HRESULT AddStringW  (PCWSTR psz, int cch = -1);
    HRESULT AddFillW    (WCHAR  ch,  int cch);
    HRESULT AddCharA    (char   ch) { return Add((const BYTE *)&ch, 1); }
    HRESULT AddCharW    (WCHAR  ch) { return AddStringW(&ch, 1); }

    int     Length      (void) { return m_pos; } // length in bytes
    BYTE *  End         (void);

    int     WLength     (void) { return m_pos/sizeof(WCHAR); } // length in WCHARs
    UPWSTR  WEnd        (void) { return (UPWSTR)End(); }

    // These let you treat the stream as a growable array.
    // If you need the stream 0-terminated, call Terminate() before *Data().
    //
    BYTE *   Data       (void);
    UPWSTR   WData      (void) { return (UPWSTR )Data(); }
    UPSTR    AData      (void) { return (UPSTR  )Data(); }
    UPINT    IData      (void) { return (UPINT  )Data(); }
    UPLONG   LData      (void) { return (UPLONG )Data(); }
    UPULONG  ULData     (void) { return (UPULONG)Data(); }
    UPDWORD  DWData     (void) { return (UPDWORD)Data(); }

    HRESULT Coalesce    (void); // coalesce everything into one contiguous block

    // 0-terminate the stream without incrementing the position.
    HRESULT Terminate    (int cbSize = sizeof(WCHAR)); 

    // 0-terminate the stream and increment the position.
    HRESULT AddTerminate (int cbSize = sizeof(WCHAR));

    // Walk visits the internal blocks in order until fnCallback fails, 
    // returns S_FALSE, or there are no more blocks. Returns S_OK if empty, 
    // otherwise the last value returned by fnCallback. fnCallback is passed 
    // pUser at each call.
    // You can use this to write a stream to a file without forcing a coalesce,
    // then Reset() to clear it.
    HRESULT Walk (MSWALKFN fnCallback, UINT_PTR pUser);

    // Gimme's hand out the accumulated buffer trimmed to size and, if Gimme*Str, 
    // null-terminated. The caller then owns the memory and is responsible for 
    // freeing it appropriately.
    //
    // The stream is always reset to accumulate a new buffer.
    // Get the size _before_ calling a Gimme* if you need it, because Gimme's always reset. 
    //
    PSTR    GimmeAStr   (void); // Free with VSFree
    PWSTR   GimmeWStr   (void); // Free with VSFree
    BSTR    GimmeBSTR   (void); // Free with SysFreeString
    BYTE *  GimmeData   (void); // Free with VSFree (not 0 - terminated)
    HGLOBAL GimmeHandle (UINT uFlags); // Free with GlobalFree, uFlags = GlobalAlloc flags, (not 0 - terminated)

private:
    int         m_cbGrowBy; // block size
    int         m_cb;       // total data size
    int         m_pos;      // virtual offset of current image end
    CMSBlock *  m_pData;    // start of chain
    CMSBlock *  m_pCur;     // current end
    CMSBlock *  NewBlock (int cb);
};

//---------------------------------------------------------------
// CMinimalStream formatted string functions.
//
// Wraps the CRT sprintf format functions (not Windows format functions).
// Not members so that they won't be linked (and pull in stdio) if you don't use 'em.
//
// NOTE: Total length of formatted result is limited to 1024 chars, including NUL.
//
HRESULT __cdecl MinStreamFormatA (CMinimalStream & ms, PCSTR  fmt, ...);
HRESULT __cdecl MinStreamFormatW (CMinimalStream & ms, PCWSTR fmt, ...);

//---------------------------------------------------------------
// MinStreamWalkWriteFile
//
// Use ms.Walk(MinStreamWalkWriteFile, (UINT_PTR)filehandle); to write
// a CMinimalStream to the open file handle given in pUser.
//
HRESULT CALLBACK MinStreamWalkWriteFile (UINT_PTR pUser, BYTE * pb, int cb);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\unichar.h ===
// unichar.h - Unicode character literals
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// June 1, 1998 [paulde]
//
#pragma once
#ifndef __UNICHAR_H__
#define __UNICHAR_H__

#include "unimisc.h"  // IN_RANGE

//      ---------                   ------------  ----------------------------------
//         ID                        Code point        Unicode character name
//      ---------                   ------------  ----------------------------------
#define  UCH_NULL                      0x0000     // NULL
#define  UCH_TAB                       0x0009     // HORIZONTAL TABULATION
#define  UCH_LF                        0x000A     // LINE FEED
#define  UCH_CR                        0x000D     // CARRAIGE RETURN
#define  UCH_SPACE                     0x0020     // SPACE
#define  UCH_SP                        0x0020     // SPACE
#define  UCH_NBSP                      0x00A0     // NO-BREAK SPACE
#define  UCH_IDEOSP                    0x3000     // IDEOGRAPHIC SPACE
#define  UCH_LS                        0x2028     // LINE SEPARATOR
#define  UCH_PS                        0x2029     // PARAGRAPH SEPARATOR
#define  UCH_ZWNBSP                    0xFEFF     // ZERO WIDTH NO-BREAK SPACE (byte order mark)
#define  UCH_BOM                       0xFEFF     // ZERO WIDTH NO-BREAK SPACE (byte order mark)
#define  UCH_BOMSWAP                   0xFFFE     // byte-swapped byte order mark
#define  UCH_NONCHAR                   0xFFFF     // Not a Character
#define  UCH_OBJECT                    0xFFFC     // OBJECT REPLACEMENT CHARACTER
#define  UCH_REPLACE                   0xFFFD     // REPLACEMENT CHARACTER

#define  UCH_ENQUAD                    0x2000     // EN QUAD
#define  UCH_EMQUAD                    0x2001     // EM QUAD
#define  UCH_ENSP                      0x2002     // EN SPACE
#define  UCH_EMSP                      0x2003     // EM SPACE
#define  UCH_3EMSP                     0x2004     // THREE-PER-EM SPACE
#define  UCH_4EMSP                     0x2005     // FOUR-PER-EM SPACE
#define  UCH_6EMSP                     0x2006     // SIX-PER-EM SPACE
#define  UCH_FIGSP                     0x2007     // FIGURE SPACE
#define  UCH_PUNSP                     0x2008     // PUNCTUATION SPACE
#define  UCH_THINSP                    0x2009     // THIN SPACE
#define  UCH_HAIRSP                    0x200A     // HAIR SPACE
#define  UCH_ZWSP                      0x200B     // ZERO WIDTH SPACE
#define  UCH_ZWNJ                      0x200C     // ZERO WIDTH NON-JOINER
#define  UCH_ZWJ                       0x200D     // ZERO WIDTH JOINER
#define  UCH_LTR                       0x200E     // LEFT-TO-RIGHT MARK
#define  UCH_RTL                       0x200F     // RIGHT-TO-LEFT MARK
#define  UCH_HYPHEN                    0x2010     // HYPHEN
#define  UCH_NBHYPHEN                  0x2011     // NON-BREAKING HYPHEN
#define  UCH_FIGDASH                   0x2012     // FIGURE DASH
#define  UCH_ENDASH                    0x2013     // EN DASH
#define  UCH_EMDASH                    0x2014     // EM DASH
#define  UCH_IDEOSP                    0x3000     // IDEOGRAPHIC SPACE

#define  UCH_EURO                      0x20AC     // EURO SIGN

//---------------------------------------------------------------
// Convert a FULLWIDTH LATIN character to it's Latin (ASCII) counterpart
// Returns the same character if it's not FULLWIDTH LATIN.
//
inline WCHAR FullWidthLatinToLatin (WCHAR ch)
{
    return (ch < 0xFF01 || ch > 0xFF5E) ? ch : WCHAR(L'!' + (ch - 0xFF01));
}

//---------------------------------------------------------------
// Line terminators
//
#define USZ_EOLCHARSET   L"\x000D\x000A\x2028\x2029"   // The set of Unicode line-break chars
#define USZ_CRLF         L"\x000D\x000A"
#define USZ_LF           L"\x000A"
#define USZ_CR           L"\x000D"
#define USZ_LS           L"\x2028"
#define USZ_PS           L"\x2029"

//---------------------------------------------------------------
// IsLineBreak - Is ch a Unicode line break character
// 
inline BOOL WINAPI IsLineBreak (WCHAR ch)
{
    return (ch <= UCH_PS) && (UCH_CR == ch || UCH_LF == ch || UCH_LS == ch || UCH_PS == ch);
}

#include "unipriv.h"

//---------------------------------------------------------------
// LineBreakAdvance - Advance a pointer at EOL past the line ending
// 
inline PCWSTR WINAPI LineBreakAdvance (PCWSTR pch)
{
    UASSERT(IsLineBreak(*pch));
    if (UCH_CR == *pch++)
        if (UCH_LF == *pch)
            pch++;
    return pch;
}
inline PWSTR WINAPI LineBreakAdvance (PWSTR pch) {return const_cast<PWSTR>(LineBreakAdvance (const_cast<PCWSTR>(pch)));}

//---------------------------------------------------------------
// Surrogates
// [U2] 3.7 <Surrogates>
// [U2] 5.5 <Handling Surrogate Characters>
//
// All surrogates fall in a single contiguous range.
// In well-formed text:
//   -  Surrogates come in pairs that must be treated atomically.
//   -  A high surrogate always precedes a low surrogate.
//
#define  UCH_SURROGATE_FIRST         0xD800    // First surrogate
#define  UCH_HI_SURROGATE_FIRST      0xD800    // First High Surrogate
#define  UCH_PV_HI_SURROGATE_FIRST   0xDB80    // <Private Use High Surrogate, First>
#define  UCH_PV_HI_SURROGATE_LAST    0xDBFF    // <Private Use High Surrogate, Last>
#define  UCH_HI_SURROGATE_LAST       0xDBFF    // Last High Surrogate
#define  UCH_LO_SURROGATE_FIRST      0xDC00    // <Low Surrogate, First>
#define  UCH_LO_SURROGATE_LAST       0xDFFF    // <Low Surrogate, Last>
#define  UCH_SURROGATE_LAST          0xDFFF    // Last surrogate

#define IsSurrogate(ch)     IN_RANGE(ch, UCH_SURROGATE_FIRST,    UCH_SURROGATE_LAST)
#define IsHighSurrogate(ch) IN_RANGE(ch, UCH_HI_SURROGATE_FIRST, UCH_HI_SURROGATE_LAST)
#define IsLowSurrogate(ch)  IN_RANGE(ch, UCH_LO_SURROGATE_FIRST, UCH_LO_SURROGATE_LAST)


//---------------------------------------------------------------
// Hangul Jamo
// [U2] 3.10 <Combining Jamo Behavior>
// [U2] 5.13 <Locating Text Element Boundaries>
//
// Hangul syllables are composed of
//   -  leading consonant  (Choseong)
//   -  vowel              (Jungseong)
//   -  trailing consonant (Jongseong)
//

#define UCH_HANGUL_JAMO_FIRST          0x1100
#define UCH_HANGUL_JAMO_LEAD_FIRST     0x1100
#define UCH_HANGUL_JAMO_LEAD_LAST      0x115F
#define UCH_HANGUL_JAMO_VOWEL_FIRST    0x1160
#define UCH_HANGUL_JAMO_VOWEL_LAST     0x11A2
#define UCH_HANGUL_JAMO_TRAIL_FIRST    0x11A8
#define UCH_HANGUL_JAMO_TRAIL_LAST     0x11F9
#define UCH_HANGUL_JAMO_LAST           0x11FF

#define IsHangulJamo(ch) IN_RANGE(ch, UCH_HANGUL_JAMO_FIRST, UCH_HANGUL_JAMO_LAST)

//---------------------------------------------------------------
// JamoSyllableBreak - detect syllable (char) boundary in Hangul text
//
// [U2] 3.10 <Combining Jamo Behavior> 'Syllable Boundaries' Table 3-3
//
// Given two characters, either one or both a Hangul Jamo, returns
// TRUE when there is a syllable break between them. 
//
// Key: x = non-Jamo  * = break
//      L = Leading consonant  V = Vowel  T = Trailing consonant 
//
// Rule: 
//    x*L  x*V  x*T  L*x  V*x  T*x
//    V*L
//    T*L
//    T*V
//    All other combinations are part of the same syllable.
//
inline BOOL WINAPI JamoSyllableBreak(WCHAR c1, WCHAR c2)
{
    // if this fires, you aren't using it correctly see comments above
    UASSERT((IN_RANGE(c1,0x1100,0x11FF)) || (IN_RANGE(c2,0x1100,0x11FF)));
    return 
        ((c1 <  0x1100) || (c2 >  0x11FF)) ||	                // x*L  x*V  x*T  L*x  V*x  T*x
        ((c1 >= 0x11A8) && (c2 <  0x11A8)) ||	                // T*L, T*V
        ((c1 >= 0x1160) && (c1 <= 0x11A2) && (c2 <= 0x115F))	// V*L
        ;
}

#endif // __UNICHAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\unilib.h ===
// unilib.h - UniLib Unicode library
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// June 1, 1998 Paul Chase Dempsey [paulde]
//
// Note: Portions of the library is designed to be usable
//       without vsmem/vsassert, so only a primitive DebugBreak
//       UASSERT is used in these portions of the library.
//
//-----------------------------------------------------------------

#pragma once
#ifndef __UNILIB_H__
#define __UNILIB_H__

#include "awconv.h"     // Ansi/Unicode conversions and string duplication
#include "unichar.h"    // Unicode character constants
#include "uniprop.h"    // Unicode character properties
#include "unicase.h"    // Case changing, Unicode string comparisons
#include "unistr.h"     // Unicode string copy, catenate, URL detection, string munging
#include "unimisc.h"    // SignOf, Swap, InRange, CMinimalTextStream
//#include "commacro.h"   // COM macros
#include "utf.h"        // UTF-8 detection, Unicode<->UTF-8 conversion
//#include "regexp.h"     // OBSOLETE: Old Regular Expression engine
#include "regex.h"      // Regular Expression engine
//#include "ucdecomp.h"   // Combining character decomposition
#include "codepage.h"   // Codepage constants
#include "unum.h"       // Integer conversions and fullwidth->halfwidth utils
#include "uniapi.h"     // Unicode Win API wrappers (Win9x/NT)
#include "w4char.h"     // 32-bit character (UCS-4) utilities
//#include "uniesc.h"     // Escape/Unescape Unicode strings as ASCII

// The folowing are part of Unilib, but not included here to avoid collisions 
// between vsmem and other allocators such as VB*.

// Text files, IVsTextLines, IVsTextImage implementations and helpers
//
//#include "textpst.h"      // Text file persistence
//#include "txeventsink.h"  // text event sinks
//#include "txfactory.h"    // Create IVsTextImage
//#include "tximage.h"      // IVsTextImage
//#include "tximghlp.h"     // helpers for using IVsTextImage
//#include "txlinehlp.h"    // helpers for using IvsTextLines

#endif __UNILIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\uniprop.h ===
// uniprop.h
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// June 1, 1998 [paulde]
//
//-----------------------------------------------------------------
#pragma once

BYTE    WINAPI  UProp    (WCHAR ch);
void    WINAPI  GetProps (PCWSTR pchBuffer, int cch, BYTE * pProps);

int     WINAPI  LastNonWhiteChar  (PCWSTR pch, int cch);
int     WINAPI  FirstNonWhiteChar (PCWSTR pch, int cch);
BOOL    WINAPI  IsWhitespace   (WCHAR ch);
BOOL    WINAPI  IsTab          (WCHAR ch);
BOOL    WINAPI  IsBlank        (WCHAR ch);
BOOL    WINAPI  IsBlanks       (PCWSTR pch, int cch);

WORD    WINAPI  UScript        (WCHAR ch);

BOOL    WINAPI  IsBidi         (WCHAR ch); // Arabic and Hebrew
BOOL    WINAPI  IsHangul       (WCHAR ch); // Korean
BOOL    WINAPI  IsKatakana     (WCHAR ch); // Japanese phonetic
BOOL    WINAPI  IsHiragana     (WCHAR ch); // Japanese phonetic
BOOL    WINAPI  IsIdeograph    (WCHAR ch); // Kanji, aka Han, aka Hanja
BOOL    WINAPI  IsExtender     (WCHAR ch); // 'Extender' from Unicode identifier rules

BYTE    WINAPI  CombiningClass (WCHAR ch);

BOOL    WINAPI  IsWholeWord (PCWSTR pchText, int cchText, PCWSTR pchItem, int cchItem, BOOL fHanWordBreak = TRUE);
BOOL    WINAPI  IsWordBreak (PCWSTR pchText, PCWSTR pchPoint, BOOL fHanWordBreak = FALSE);

BOOL    WINAPI  IsLineBreak      (WCHAR ch);

//----------------------------------------------------------------------------------------------
#define WL_WORDONLY               0x00000001  // simple word break only (default is kinsoku rule)
#define WL_SPILLWHITESPACE        0x00000002  // spill trailing whitespace past pPoint
#define WL_SPILLGRAPHICROW        0x00000004  // spill graphical row (like comment header above)
PCWSTR  WINAPI  WrapLine (PCWSTR pText, int cch, PCWSTR pPoint, DWORD dwFlags);
// non-const version
inline PWSTR WINAPI WrapLine (PWSTR pText, int cch, PWSTR pPoint, DWORD dwFlags) {return const_cast<PWSTR>(WrapLine (const_cast<PCWSTR>(pText), cch, const_cast<PCWSTR>(pPoint), dwFlags));}

BOOL    WINAPI  IsAlpha                     (WCHAR ch);
BOOL    WINAPI  IsDigit                     (WCHAR ch);
BOOL    WINAPI  IsAlphaNumeric              (WCHAR ch);
BOOL    WINAPI  IsUppercaseLetter           (WCHAR ch);
BOOL    WINAPI  IsLowercaseLetter           (WCHAR ch);
BOOL    WINAPI  IsTitlecaseLetter           (WCHAR ch);
BOOL    WINAPI  IsModifierLetter            (WCHAR ch);
BOOL    WINAPI  IsOtherLetter               (WCHAR ch);
BOOL    WINAPI  IsDecimalDigit              (WCHAR ch);
BOOL    WINAPI  IsLetterDigit               (WCHAR ch);
BOOL    WINAPI  IsOtherDigit                (WCHAR ch);
BOOL    WINAPI  IsPunctuation               (WCHAR ch);
BOOL    WINAPI  IsPairPunctuation           (WCHAR ch);
BOOL    WINAPI  IsOpenPunctuation           (WCHAR ch);
BOOL    WINAPI  IsClosePunctuation          (WCHAR ch);
BOOL    WINAPI  IsInitialQuotePunctuation   (WCHAR ch);
BOOL    WINAPI  IsFinalQuotePunctuation     (WCHAR ch);
BOOL    WINAPI  IsDashPunctuation           (WCHAR ch);
BOOL    WINAPI  IsConnectorPunctuation      (WCHAR ch);
BOOL    WINAPI  IsOtherPunctuation          (WCHAR ch);
BOOL    WINAPI  IsSpaceSeparator            (WCHAR ch);
BOOL    WINAPI  IsLineSeparator             (WCHAR ch); // 0x2028
BOOL    WINAPI  IsParagraphSeparator        (WCHAR ch); // 0x2029
BOOL    WINAPI  IsCombining                 (WCHAR ch);
BOOL    WINAPI  IsNonSpacingMark            (WCHAR ch);
BOOL    WINAPI  IsCombiningMark             (WCHAR ch);
BOOL    WINAPI  IsEnclosingMark             (WCHAR ch);
BOOL    WINAPI  IsMathSymbol                (WCHAR ch);
BOOL    WINAPI  IsSymbol                    (WCHAR ch);
BOOL    WINAPI  IsCurrencySymbol            (WCHAR ch);
BOOL    WINAPI  IsModifierSymbol            (WCHAR ch);
BOOL    WINAPI  IsOtherSymbol               (WCHAR ch);
BOOL    WINAPI  IsOtherControl              (WCHAR ch);
BOOL    WINAPI  IsOtherFormat               (WCHAR ch);
BOOL    WINAPI  IsOtherSurrogate            (WCHAR ch);
BOOL    WINAPI  IsOtherPrivateUse           (WCHAR ch);
BOOL    WINAPI  IsOtherNotAssigned          (WCHAR ch); // currently no entries in Uni w/ this prop
BOOL    WINAPI  IsNotAssigned               (WCHAR ch);

BOOL    WINAPI  IsPropAlpha                     (BYTE prop);
BOOL    WINAPI  IsPropDigit                     (BYTE prop);
BOOL    WINAPI  IsPropAlphaNumeric              (BYTE prop);
BOOL    WINAPI  IsPropUppercaseLetter           (BYTE prop);
BOOL    WINAPI  IsPropLowercaseLetter           (BYTE prop);
BOOL    WINAPI  IsPropTitlecaseLetter           (BYTE prop);
BOOL    WINAPI  IsPropModifierLetter            (BYTE prop);
BOOL    WINAPI  IsPropOtherLetter               (BYTE prop);
BOOL    WINAPI  IsPropDecimalDigit              (BYTE prop);
BOOL    WINAPI  IsPropLetterDigit               (BYTE prop);
BOOL    WINAPI  IsPropOtherDigit                (BYTE prop);
BOOL    WINAPI  IsPropPunctuation               (BYTE prop);
BOOL    WINAPI  IsPropPairPunctuation           (BYTE prop);
BOOL    WINAPI  IsPropOpenPunctuation           (BYTE prop);
BOOL    WINAPI  IsPropClosePunctuation          (BYTE prop);
BOOL    WINAPI  IsPropInitialQuotePunctuation   (BYTE prop);
BOOL    WINAPI  IsPropFinalQuotePunctuation     (BYTE prop);
BOOL    WINAPI  IsPropDashPunctuation           (BYTE prop);
BOOL    WINAPI  IsPropConnectorPunctuation      (BYTE prop);
BOOL    WINAPI  IsPropOtherPunctuation          (BYTE prop);
BOOL    WINAPI  IsPropSpaceSeparator            (BYTE prop);
BOOL    WINAPI  IsPropLineSeparator             (BYTE prop); // 0x2028
BOOL    WINAPI  IsPropParagraphSeparator        (BYTE prop); // 0x2029
BOOL    WINAPI  IsPropCombining                 (BYTE prop);
BOOL    WINAPI  IsPropNonSpacingMark            (BYTE prop);
BOOL    WINAPI  IsPropCombiningMark             (BYTE prop);
BOOL    WINAPI  IsPropEnclosingMark             (BYTE prop);
BOOL    WINAPI  IsPropSymbol                    (BYTE prop);
BOOL    WINAPI  IsPropMathSymbol                (BYTE prop);
BOOL    WINAPI  IsPropCurrencySymbol            (BYTE prop);
BOOL    WINAPI  IsPropModifierSymbol            (BYTE prop);
BOOL    WINAPI  IsPropOtherSymbol               (BYTE prop);
BOOL    WINAPI  IsPropOtherControl              (BYTE prop);
BOOL    WINAPI  IsPropOtherFormat               (BYTE prop);
BOOL    WINAPI  IsPropOtherSurrogate            (BYTE prop);
BOOL    WINAPI  IsPropOtherPrivateUse           (BYTE prop);
BOOL    WINAPI  IsPropOtherNotAssigned          (BYTE prop); // currently no entries in Uni w/ this prop
BOOL    WINAPI  IsPropNotAssigned               (BYTE prop);

//      Name                           Code    Property Symbol in Unicode Character Database
#define LetterUppercase                0x01 // Lu
#define LetterLowercase                0x02 // Ll
#define LetterTitlecase                0x03 // Lt
#define LetterModifier                 0x04 // Lm
#define LetterOther                    0x05 // Lo
#define DigitDecimal                   0x06 // Nd
#define DigitLetter                    0x07 // Nl
#define DigitOther                     0x08 // No
#define PunctuationOpen                0x09 // Ps
#define PunctuationClose               0x0a // Pe
#define PunctuationInitialQuote        0x0b // Pi
#define PunctuationFinalQuote          0x0c // Pf
#define PunctuationDash                0x0d // Pd
#define PunctuationConnector           0x0e // Pc
#define PunctuationOther               0x0f // Po
#define SeparatorSpace                 0x10 // Zs
#define SeparatorLine                  0x11 // Zl
#define SeparatorParagraph             0x12 // Zp
#define MarkNonSpacing                 0x13 // Mn
#define MarkCombining                  0x14 // Mc
#define MarkEnclosing                  0x15 // Me
#define SymbolMath                     0x16 // Sm
#define SymbolCurrency                 0x17 // Sc
#define SymbolModifier                 0x18 // Sk
#define SymbolOther                    0x19 // So
#define OtherControl                   0x1a // Cc  Control characters
#define OtherFormat                    0x1b // Cf  CSS (BiDi) Controls
#define OtherSurrogate                 0x1c // Cs
#define OtherPrivateUse                0x1d // Co
#define OtherNotAssigned               0x1e // Cn // currently no entries in Uni w/ this prop

#define NotAssigned                    0xff // (No entry in Uni database)

// enum - not flags
#define SCRIPT_NONE          0x0000 // punctuation, dingbat, symbol, math, ...
#define SCRIPT_LATIN         0x0001
#define SCRIPT_GREEK         0x0002
#define SCRIPT_CYRILLIC      0x0003
#define SCRIPT_ARMENIAN      0x0004
#define SCRIPT_HEBREW        0x0005
#define SCRIPT_ARABIC        0x0006
#define SCRIPT_DEVANAGARI    0x0007
#define SCRIPT_BENGALI       0x0008
#define SCRIPT_GURMUKHI      0x0009
#define SCRIPT_GUJARATI      0x000a
#define SCRIPT_ORIYA         0x000b
#define SCRIPT_TAMIL         0x000c
#define SCRIPT_TELUGU        0x000d
#define SCRIPT_KANNADA       0x000e
#define SCRIPT_MALAYALAM     0x000f
#define SCRIPT_THAI          0x0010
#define SCRIPT_LAO           0x0011
#define SCRIPT_TIBETAN       0x0012
#define SCRIPT_GEORGIAN      0x0013
#define SCRIPT_CJK           0x0014 // Chinese, Japanese, Korean (Han, Katakana, Hiragana, Hangul)

// Unicode 3.0 added scripts
#define SCRIPT_BRAILLE              0x0015
#define SCRIPT_SYRIAC               0x0016
#define SCRIPT_THAANA               0x0017
#define SCRIPT_SINHALA              0x0018
#define SCRIPT_MYANMAR              0x0019
#define SCRIPT_ETHIOPIC             0x001a
#define SCRIPT_CHEROKEE             0x001b
#define SCRIPT_CANADIAN_ABORIGINAL  0x001c
#define SCRIPT_OGHAM                0x001d
#define SCRIPT_RUNIC                0x001e
#define SCRIPT_KHMER                0x001f
#define SCRIPT_MONGOLIAN            0x0020
#define SCRIPT_YI                   0x0021


//-----------------------------------------------------------------
//
// PCWSTR WINAPI WrapLine (PCWSTR pText, int cch, PCWSTR pPoint, DWORD dwFlags);
//
// Word-wrap a line, applying Kinsoku rule.
//
// Input: 
//  pText     Line to break.
//  cch       Count of characters in the line (Does NOT take -1 for NULL-terminated mode).
//  pPoint    Candidate point in pText where we calculate the break from.
//  dwFlags   Line-break options.
//      WL_WORDONLY           simple word break only (default is kinsoku rule)
//      WL_SPILLWHITESPACE    contiguous trailing whitespace extends past pPoint
//      WL_SPILLGRAPHICROW    allow graphical row (e.g. row of dashes) to extend past Point
//
// Returns: The best place to start the next line.
//          The returned break point can be one past the candidate point.
//          pPoint is returned if no suitable break point is found.
//

//================================================================
//====  Implementation  ==========================================
//================================================================

//-----------------------------------------------------------------
// We include decimal digits and LOW LINE ('_') in the
// definition of a 'word'.
//
inline BOOL IsWordChar(WCHAR ch, BYTE prop)
{
    return IsPropAlphaNumeric(prop) || ch == L'_';
}

#if 1 // new prop table for Unicode 3.0
// defined in uGenTab.cpp
extern BYTE WINAPI LookupGen (WCHAR ch);
inline BYTE WINAPI UProp(WCHAR ch) { return LookupGen(ch); }
#else // old prop table
extern const BYTE * rgpbUGenProps[];

inline BYTE WINAPI UProp(WCHAR ch)
{
	const BYTE *p = rgpbUGenProps[ch>>8];
	if ((INT_PTR)p > 0xff)
		return p[ch & 0xff];
	return (BYTE)p;
}
#endif

#undef __IN_RANGE__
#define __IN_RANGE__(v, r1, r2) ((unsigned)((v) - (r1)) <= (unsigned)((r2)-(r1)))

////////////////////////////////////////////////////////////////////////////
//
// Implement BOOL Is...(WCHAR ch) functions
//
#define IS_FT_CHAR 1
#include "uniprop.inc"
#undef IS_FT_CHAR
//
// Implement BOOL IsProp...(BYTE prop) functions
//
#define IS_FT_PROP 1
#include "uniprop.inc"
#undef IS_FT_PROP

//--------------------------------------------------------------------------

inline BOOL WINAPI IsHangul(WCHAR ch)
{
    char f = 0;
    if      (ch <  0x1100) {}
    else if (ch <= 0x11FF) f = 1;  // (0x1100 - 0x11FF) Hangul Combining Jamo
    else if (ch <  0x3130) {}
    else if (ch <= 0x318f) f = 1;  // (0x3130 - 0x318f) Hangul Compatability Jamo
    else if (ch <  0xac00) {}
    else if (ch <= 0xd7a3) f = 1;  // (0xac00 - 0xd7a3) Hangul Syllables
    else if (ch <  0xffa0) {}
    else if (ch <= 0xffdf) f = 1;  // (0xffa0 - 0xffdf) Halfwidth Hangul Compatability Jamo
    return (BOOL)f;
}

inline BOOL WINAPI IsKatakana(WCHAR ch)
{
    return (ch >= 0x3031) &&
        (
        __IN_RANGE__(ch, 0x3099, 0x30fe) || 
        __IN_RANGE__(ch, 0xff66, 0xff9f) 
		);
}

inline BOOL WINAPI IsHiragana(WCHAR ch)
{
    return (ch >= 0x3031) &&
        (
        __IN_RANGE__(ch, 0x3041, 0x309e) ||
        (0x30fc == ch) || (0xff70 == ch) // fullwidth and halfwidth hira/kata prolonged sound mark
		);
}

inline BOOL WINAPI IsIdeograph(WCHAR ch)
{
  char f = 0;
  if      (ch <  0x4e00) { if (ch == 0x3005) f = 1; }
  else if (ch <= 0x9fa5) f = 1;
  else if (ch <  0xf900) {}
  else if (ch <= 0xfa2d) f = 1;
  return (BOOL)f;
}

// TRUE if ch is Hebrew or Arabic
inline BOOL WINAPI IsBidi(WCHAR ch)
{
  char f = 0;
  if      (ch <  0x0590) {}
  else if (ch <= 0x06FF) f = 1;
  else if (ch <  0xFB00) {}
  else if (ch <= 0xFDFF) f = 1;
  else if (ch <  0xFE70) {}
  else if (ch <= 0xFEFF) f = 1;
  return (BOOL)f;
}

inline BOOL WINAPI IsNonBreaking(WCHAR ch)
{
    return (
        (ch == 0x00a0) || // NO-BREAK SPACE
        (ch == 0x2011) || // NON-BREAKING HYPHEN
        (ch == 0x202F) || // NARROW NO-BREAK SPACE
        (ch == 0xfeff)    // ZERO WIDTH NO-BREAK SPACE (byte order mark)
        );
}

inline BOOL WINAPI IsBlank(WCHAR ch)
{
    return (
        (0x0020 == ch) || (0x0009 == ch) ||
        (0x00a0 == ch) || (0x3000 == ch) ||
        __IN_RANGE__(ch, 0x2000, 0x200b)
        );
}

//
// 0x0009  [HORIZONTAL TABULATION]
// 0x000a  [LINE FEED]
// 0x000b  [VERTICAL TABULATION]
// 0x000c  [FORM FEED]
// 0x000d  [CARRIAGE RETURN]
// 0x0020  SPACE
// 0x00a0  NO-BREAK SPACE
// 0x1361  ETHIOPIC WORDSPACE   $REVIEW: blank?
// 0x1680  OGHAM SPACE MARK     $REVIEW: blank?
// 0x2000  EN QUAD
// 0x2001  EM QUAD
// 0x2002  EN SPACE
// 0x2003  EM SPACE
// 0x2004  THREE-PER-EM SPACE
// 0x2005  FOUR-PER-EM SPACE
// 0x2006  SIX-PER-EM SPACE
// 0x2007  FIGURE SPACE
// 0x2008  PUNCTUATION SPACE
// 0x2009  THIN SPACE
// 0x200a  HAIR SPACE
// 0x200b  ZERO WIDTH SPACE
// 0x2028  LINE SEPARATOR
// 0x2029  PARAGRAPH SEPARATOR
// 0x202F  NARROW NO-BREAK SPACE
// 0x3000  IDEOGRAPHIC SPACE
// 0x303F  IDEOGRAPHIC HALF FILL SPACE  //$REVIEW: blank?

inline BOOL WINAPI IsWhitespace (WCHAR ch)
{
  char f = 0;
  if (0x0020 == ch) f = 1;
  else if (ch < 0x00a0)
  {
    if ((ch > 0x000D) || (ch < 0x0009))
    {
    }
    else
      f = 1;
  }
  else if (ch <= 0x303F)
  {
    if (ch <= 0x200b)
    {
      if      (0x00a0 == ch) f = 1;
//      else if (0x1361 == ch) f = 1;     // ETHIOPIC WORDSPACE
//      else if (0x1680 == ch) f = 1;     // 0x1680  OGHAM SPACE MARK
      else if (ch >= 0x2000) f = 1;
    }
    else
    {
      if      (0x2028 == ch) f = 1;
      else if (0x2029 == ch) f = 1;
      else if (0x202F == ch) f = 1;
      else if (0x3000 == ch) f = 1;
      else if (0x303F == ch) f = 1;
    }
  }
  return (BOOL)f;
}
inline BOOL WINAPI IsTab (WCHAR ch)
{
  switch (ch)
  {
  case 0x0009: 
  case 0x000b: 
      return true;
  }
  return false;
}

#undef __IN_RANGE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\unipriv.h ===
// unipriv.h -- UniLib private internal header

#pragma once

#undef UASSERT
#ifdef _DEBUG

#ifdef _X86_
#define __UBREAK__ _asm { int 3 }
#else
#define __UBREAK__ DebugBreak();
#endif // _X86_

#define UASSERT(exp) do { if (!(exp)) __UBREAK__; } while (FALSE)
#else
#define UASSERT(exp) do {} while (0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\uniprop.inc ===
// uniprop.inc -- Generate Is... or IsProp... functions
//---------------------------------------------------------------------
// #included by "uniprop.h"
//
// #define IS_FT_CHAR or IS_FT_PROP then #include this file to
// generate the char or prop-based character-type functions.
//
//---------------------------------------------------------------------
#if !defined(IS_FT_CHAR) && !defined(IS_FT_PROP)
#error "ERROR: uniprop.inc control macros not defined"
#endif
#if defined(IS_FT_CHAR) && defined(IS_FT_PROP)
#error ERROR: only one of IS_FT_CHAR and IS_FT_PROP can be defined
#endif

#undef Is_EQU_
#undef Is_LEQ_
#undef Is_GEQ_
#undef Is_RNG_
#undef Is_OF2_

#ifdef IS_FT_CHAR

#define Is_EQU_(name, P) \
    inline BOOL WINAPI Is##name(WCHAR ch) { return ((P) == UProp(ch)); }
#define Is_LEQ_(name, P) \
    inline BOOL WINAPI Is##name(WCHAR ch) { return (UProp(ch) <= (P)); }
#define Is_GEQ_(name, P) \
    inline BOOL WINAPI Is##name(WCHAR ch) { return (UProp(ch) >= (P)); }
#define Is_RNG_(name, P1, P2) \
    inline BOOL WINAPI Is##name(WCHAR ch) { BYTE P = UProp(ch); return __IN_RANGE__(P, (P1), (P2)); }
#define Is_OF2_(name, P1, P2) \
    inline BOOL WINAPI Is##name(WCHAR ch) { BYTE P = UProp(ch); return ((P1) == P || (P2) == P); }

#elif defined(IS_FT_PROP)

#define Is_EQU_(name, P) \
    inline BOOL WINAPI IsProp##name(BYTE prop) { return ((P) == prop); }
#define Is_LEQ_(name, P) \
    inline BOOL WINAPI IsProp##name(BYTE prop) { return (prop <= (P)); }
#define Is_GEQ_(name, P) \
    inline BOOL WINAPI IsProp##name(BYTE prop) { return (prop >= (P)); }
#define Is_RNG_(name, P1, P2) \
    inline BOOL WINAPI IsProp##name(BYTE prop) { return __IN_RANGE__(prop, (P1), (P2)); }
#define Is_OF2_(name, P1, P2) \
    inline BOOL WINAPI IsProp##name(BYTE prop) { return ((P1) == prop || (P2) == prop); }
#else
#error ERROR: uniprop.inc not properly set up.
#endif


    Is_LEQ_(  Alpha                     ,  LetterOther                             )
//  Is_RNG_(  Alpha                     ,  LetterUppercase, LetterOther            )
    Is_EQU_(  Digit                     ,  DigitDecimal                            )
    Is_LEQ_(  AlphaNumeric              ,  DigitDecimal                            )
//  Is_RNG_(  AlphaNumeric              ,  LetterUppercase, DigitDecimal           )
    Is_EQU_(  UppercaseLetter           ,  LetterUppercase                         )
    Is_EQU_(  LowercaseLetter           ,  LetterLowercase                         )
    Is_EQU_(  TitlecaseLetter           ,  LetterTitlecase                         )
    Is_EQU_(  ModifierLetter            ,  LetterModifier                          )
    Is_EQU_(  OtherLetter               ,  LetterOther                             )
    Is_EQU_(  DecimalDigit              ,  DigitDecimal                            )
    Is_EQU_(  LetterDigit               ,  DigitLetter                             )
    Is_EQU_(  OtherDigit                ,  DigitOther                              )
    Is_RNG_(  Punctuation               ,  PunctuationOpen, PunctuationOther       )
    Is_RNG_(  PairPunctuation           ,  PunctuationOpen, PunctuationFinalQuote  )
    Is_EQU_(  OpenPunctuation           ,  PunctuationOpen                         )
    Is_EQU_(  ClosePunctuation          ,  PunctuationClose                        )
    Is_EQU_(  InitialQuotePunctuation   ,  PunctuationInitialQuote                 )
    Is_EQU_(  FinalQuotePunctuation     ,  PunctuationFinalQuote                   )
    Is_EQU_(  DashPunctuation           ,  PunctuationDash                         )
    Is_EQU_(  ConnectorPunctuation      ,  PunctuationConnector                    )
    Is_EQU_(  OtherPunctuation          ,  PunctuationOther                        )
    Is_EQU_(  SpaceSeparator            ,  SeparatorSpace                          )
    Is_EQU_(  LineSeparator             ,  SeparatorLine                           )
    Is_EQU_(  ParagraphSeparator        ,  SeparatorParagraph                      )
    Is_RNG_(  Combining                 ,  MarkNonSpacing, MarkEnclosing           )
    Is_EQU_(  NonSpacingMark            ,  MarkNonSpacing                          )
    Is_EQU_(  CombiningMark             ,  MarkCombining                           )
    Is_EQU_(  EnclosingMark             ,  MarkEnclosing                           )
    Is_RNG_(  Symbol                    ,  SymbolMath, SymbolOther                 )
    Is_EQU_(  MathSymbol                ,  SymbolMath                              )
    Is_EQU_(  CurrencySymbol            ,  SymbolCurrency                          )
    Is_EQU_(  ModifierSymbol            ,  SymbolModifier                          )
    Is_EQU_(  OtherSymbol               ,  SymbolOther                             )
    Is_EQU_(  OtherControl              ,  OtherControl                            )
    Is_EQU_(  OtherFormat               ,  OtherFormat                             )
    Is_EQU_(  OtherSurrogate            ,  OtherSurrogate                          )
    Is_EQU_(  OtherPrivateUse           ,  OtherPrivateUse                         )
    Is_EQU_(  OtherNotAssigned          ,  OtherNotAssigned                        )
    Is_GEQ_(  NotAssigned               ,  OtherNotAssigned                        )

#undef Is_EQU_
#undef Is_LEQ_
#undef Is_GEQ_
#undef Is_RNG_
#undef Is_OF2_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\uNum.h ===
// uNum.h - Unicode number handling
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1999 Microsoft Corporation.  All Rights Reserved.
//
// June 1, 1999 [paulde]
//
// Written to a draft Unicode 3.0 standard
//
//-----------------------------------------------------------------
#pragma once
/*
    WStrToLong, WStrToULong - Convert a Unicode string to an integer.

    SHLWAPI defines some the names that we would prefer to use,
    so we use 'WStr' instead of 'Str'

    These are very similar to wcstol (the code is derived from them), 
    but handle full-width digits and letters and script-specific decimal 
    digits such as Arabic digits.

    Unlike the CRT routines, these do not set errno. Instead, you can pass 
    a pointer to an overflow flag.

    The parameters have been rearranged and given default arguments for common usage.

    NOT HANDLED: ETHIOPIC, TAMIL, SUPERSCRIPT, SUBSCRIPT
    ETHIOPIC and TAMIL do not use conventional positional notation.
    We don't expect users to input superscript/subscript numbers.

    RETURNS:    On error   : 0
                On overflow: LONG_MAX or LONG_MIN (WStrToLong)
                             LONG_MAX (WStrToULong)
                Else       : number

    ARGUMENTS:

    nptr        String to parse an integer from

    endptr      Optional address of pointer that will point to the character 
                where parsing stopped.
                Same as nptr when the string cannot be interpreted as a number.

    ibase       Numeric base: default 10.

                0       Interpret base according to the text:
                            Leading '0' : base 8
                            Leading '0x': base 16
                            Otherwise   : base 10
                        0 can be a national digit zero.
                        x is case and width-insensitive.

                2 - 36  For bases above 10, the letters a-z (case/width insensitive) are 
                        interpreted as digits.

    pfOverflow  Optional pointer to overflow flag.
    
*/

long WINAPI WStrToLong (
    const WCHAR *   nptr,               // text to parse a number from
    const WCHAR **  endptr = NULL,      // optional address of pointer to end of number, or start if not a number
    int             ibase = 10,         // optional number base
    bool *          pfOverflow = NULL   // optional overflow flag
    );

unsigned long WINAPI WStrToULong (
    const WCHAR *   nptr,
    const WCHAR **  endptr = NULL,
    int             ibase = 10,
    bool *          pfOverflow = NULL
    );

//-----------------------------------------------------------------
// FoldNumericsToASCII - Convert numerics in a string to their ASCII equivalents
//
// This converts a wider range of things to ASCII than are built into WStrToLong.
// This can be used to prepare a buffer for use with CRT routines to convert
// floating point numbers or perform similar processing.
//
// Script decimal digits
// Script FULL STOP converted to '.'
// Script +/- converted to '+'/'-'
// All Full-width ASCII equivalents converted to ASCII
// Miscellaneous stops converted to '.'
// Superscript digits and +/- converted to ASCII
//
// Does NOT convert script commas or other mathematical operators (e.g. '/' '\' division)
//
// RETURNS: TRUE on success, FALSE if arguments are bad (e.g. NULL ptrs)
//
// cchSrc  -1 if null-terminated, else count of chars to convert
// pchDst  Assumed to be at least the same size as input string
//
bool WINAPI FoldNumericsToASCII (int cchSrc, PCWSTR pchSrc, PWSTR pchDst);

//-----------------------------------------------------------------
// FoldFullWidthLatinToASCII
//
// Convert FULLWIDTH LATIN characters in a string to their LATIN counterparts.
//
// RETURNS: TRUE on success, FALSE if arguments are bad (e.g. NULL ptrs)
//
// cchSrc   -1 if null-terminated, else count of chars to convert
// pchDst   Assumed to be at least the same size as input string
//
bool WINAPI FoldFullWidthLatinToASCII (int cchSrc, PCWSTR pchSrc, PWSTR pchDst);

//-----------------------------------------------------------------
// IsDigitValue - Determines if a char is a decimal digit and 
//                gets it's numeric value.
//
// Returns: TRUE    char is a decimal digit
//          FALSE   char is not a decimal digit
//
// *puVal gets numeric value of the digit, or 0 if not a digit
//
bool WINAPI IsDigitValue (WCHAR ch, unsigned * puVal = NULL);

//-----------------------------------------------------------------
// IsAZDigitValue -  Determines if char is a-zA-Z or fullwidth equivalent
//                   and returns it's numeric value.
//
// Returns: TRUE    char is a-z
//          FALSE   char is not a-z
//
// *puVal gets numeric value if char in a-z (a == 10), else 0
//
bool WINAPI IsAZDigitValue (WCHAR ch, unsigned * puVal = NULL);

//-----------------------------------------------------------------
// SignChar - Get sign signifier of a char
//
// Returns:
//       1 if char is a plus sign or fullwidth equivalent
//      -1 if char is a minus sign or fullwidth equivalent
//       0 otherwise
//
// 002B;PLUS SIGN;Sm;0;ET;;;;;N;;;;;
// FF0B;FULLWIDTH PLUS SIGN;Sm;0;ET;<wide> 002B;;;;N;;;;;
// 002D;HYPHEN-MINUS;Pd;0;ET;;;;;N;;;;;
// FF0D;FULLWIDTH HYPHEN-MINUS;Pd;0;ET;<wide> 002D;;;;N;;;;;
//
// Note that there are other +/- equivalents in Unicode.
//
int  WINAPI SignChar (WCHAR ch);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\unistr.h ===
// unistr.h
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// June 1, 1998 [paulde]
//
//-----------------------------------------------------------------
#pragma once
#ifndef __UNISTR_H__
#define __UNISTR_H__

#pragma intrinsic(strlen)

int     WINAPI   StrLen          (PCWSTR psz);
int     WINAPI   StrLenA         (PCSTR  psz);

//----------------------------------------------------------------
// Copy strings for catenation.  Returns the next position for appending.
PWSTR   WINAPI   CopyCat         (PWSTR dst, PCWSTR src);
PSTR    WINAPI   CopyCatA        (PSTR  dst, PCSTR  src);
PWSTR   WINAPI   CopyNCat        (PWSTR dst, PCWSTR src, int cchz);
PSTR    WINAPI   CopyNCatA       (PSTR  dst, PCSTR  src, int cchz);
PWSTR   WINAPI   CopyCatInt      (PWSTR dst, int n, int radix);
PSTR    WINAPI   CopyCatIntA     (PSTR  dst, int n, int radix);

// Copies into dst up to but not including stop. Guarantees zero termination if stop > dst.
PWSTR   WINAPI   CopyCatStop     (PWSTR dst, PCWSTR src, PCWSTR stop); 

//----------------------------------------------------------------
// NextChar, PrevChar - Walk text by logical characters
// These routines honor 'grapheme' boundaries. They are aware of things like 
// combining characters (e.g. diacritics), surrogate pairs, Hangul syllables 
// formed by Hangul combining Jamo.
//
// They return NULL after reaching the bound of the string or buffer.
//
PCWSTR  WINAPI   NextChar (PCWSTR pchPoint);                // NUL terminated
PCWSTR  WINAPI   NextChar (PCWSTR pchPoint, PCWSTR pchEnd); // length-bounded
PCWSTR  WINAPI   PrevChar (PCWSTR pchStart, PCWSTR pchPoint);

// VS7:32377 non-const variants, like CRT
inline PWSTR WINAPI NextChar (PWSTR pchPoint                ) {return const_cast<PWSTR>(NextChar (const_cast<PCWSTR>(pchPoint)));}
inline PWSTR WINAPI NextChar (PWSTR pchPoint, PWSTR pchEnd  ) {return const_cast<PWSTR>(NextChar (const_cast<PCWSTR>(pchPoint), const_cast<PCWSTR>(pchEnd)));}
inline PWSTR WINAPI PrevChar (PWSTR pchStart, PWSTR pchPoint) {return const_cast<PWSTR>(PrevChar (const_cast<PCWSTR>(pchStart), const_cast<PCWSTR>(pchPoint)));}

// Returns true if pchPoint is at a grapheme boundary
bool    WINAPI   IsGraphemeBreak (PCWSTR pchStart, PCWSTR pchPoint);

//----------------------------------------------------------------
// See docs below
//#define wcsnpbrk FindCharInSet
PCWSTR  WINAPI   FindCharInSet         (PCWSTR pchBuffer, int cchBuffer, PCWSTR set);
PCWSTR  WINAPI   FindCharInOrderedSet  (PCWSTR pchBuffer, int cchBuffer, PCWSTR set);
PCWSTR  WINAPI   FindChar              (PCWSTR psz, WCHAR ch);
PCWSTR  WINAPI   FindCharN             (PCWSTR pchBuffer, int cch, WCHAR ch);
PCWSTR  WINAPI   FindLastChar          (PCWSTR psz, WCHAR ch);
PCSTR   WINAPI   FindLastCharA         (PCSTR  psz, CHAR  ch);
PCWSTR  WINAPI   CharInOrderedSet      (WCHAR ch, PCWSTR set);

// VS7:32377  non-const variants, like CRT
inline PWSTR WINAPI FindCharInSet         (PWSTR pchBuffer, int cchBuffer, PCWSTR set) {return const_cast<PWSTR>(FindCharInSet (const_cast<PCWSTR>(pchBuffer), cchBuffer, set));}
inline PWSTR WINAPI FindCharInOrderedSet  (PWSTR pchBuffer, int cchBuffer, PCWSTR set) {return const_cast<PWSTR>(FindCharInOrderedSet (const_cast<PCWSTR>(pchBuffer), cchBuffer, set));}
inline PWSTR WINAPI FindChar              (PWSTR psz, WCHAR ch) {return const_cast<PWSTR>(FindChar (const_cast<PCWSTR>(psz), ch));}
inline PWSTR WINAPI FindCharN             (PWSTR pchBuffer, int cch, WCHAR ch) {return const_cast<PWSTR>(FindCharN (const_cast<PCWSTR>(pchBuffer), cch, ch));}
inline PWSTR WINAPI FindLastChar          (PWSTR psz, WCHAR ch) {return const_cast<PWSTR>(FindLastChar (const_cast<PCWSTR>(psz), ch));}
inline PSTR  WINAPI FindLastCharA         (PSTR  psz, CHAR  ch) {return const_cast<PSTR>(FindLastCharA (const_cast<PCSTR>(psz), ch));}

//----------------------------------------------------------------
// PathSplit  - Split a unc/path/filename into it's elements
//
// Forward/back slashes are normalized before splitting.
//
// Argument  Description    Required Size   Comments
// --------  ------------   -------------   -----------------------------------------
// pszFN     Source path    n/a
// pszV      Drive or UNC   MAX_PATH        e.g. "C:" or "\\server\share"
// pszD      Directory      MAX_PATH        Everything between Drive|UNC and name[.ext]
// pszN      Name           MAX_PATH
// pszE      .Ext           MAX_PATH
//
// Note: a path like "d:\some\silly\thing" returns "d:", "\some\silly\", "thing", ""
//
void WINAPI PathSplit (PCWSTR pszFN, PWSTR pszV, PWSTR pszD, PWSTR pszN, PWSTR pszE);

void WINAPI PathSplitInPlace
(
	PCWSTR pszPath,
	int iPathLength,
	int *piDrive,
	int *piDriveLength,
	int *piDirectory,
	int *piDirectoryLength,
	int *piFilename,
	int *piFilenameLength,
	int *piExtension,
	int *piExtensionLength
);

//----------------------------------------------------------------
// Calculate the line and character index of an offset into a text buffer
BOOL    WINAPI   LineAndCharIndexOfPos (PCWSTR pchText, int cch, int cchPos, int * piLine, int * piIndex);

//----------------------------------------------------------------
// StrList* operate on empty string-terminated lists of NUL-terminated strings (e.g. filter strings).
//
int     WINAPI   StrListSize   (PCWSTR psz); // count of chars to hold the list (includes terminator)
int     WINAPI   StrListSizeA  (PCSTR  psz); // count of bytes to hold the list (includes terminator)
int     WINAPI   StrListCount  (PCWSTR psz); // count of strings in the list (not including terminator)
int     WINAPI   StrListCountA (PCSTR  psz);
int     WINAPI   StrListCounts (PCWSTR psz, int * pcStr = NULL); // return count of chars to hold list, *pcStr=count of strings

PCWSTR * WINAPI  StrListCreateArray (PCWSTR pList, int * pcel);
PCWSTR  WINAPI   StrListNext        (PCWSTR pList);
HRESULT WINAPI   StrListSort        (PWSTR pList, bool fCase = true);
HRESULT WINAPI   StrListSortPairs   (PWSTR pList, bool fCase = true);
PCWSTR  WINAPI   StrListFind        (PCWSTR pList, PCWSTR pPattern, bool fCase = true);
PCWSTR  WINAPI   StrListFindSorted  (PCWSTR pList, PCWSTR pPattern, bool fCase = true);

// VS7:32377  non-const variants
inline PWSTR * WINAPI StrListCreateArray (PWSTR pList, int * pcel) {return const_cast<PWSTR*>(StrListCreateArray (const_cast<PCWSTR>(pList), pcel));}
inline PWSTR   WINAPI StrListNext        (PWSTR pList) {return const_cast<PWSTR>(StrListNext(const_cast<PCWSTR>(pList)));}
inline PWSTR   WINAPI StrListFind        (PWSTR pList, PCWSTR pPattern, bool fCase = true){return const_cast<PWSTR>(StrListFind        (const_cast<PCWSTR>(pList), pPattern, fCase));}
inline PWSTR   WINAPI StrListFindSorted  (PWSTR pList, PCWSTR pPattern, bool fCase = true){return const_cast<PWSTR>(StrListFindSorted  (const_cast<PCWSTR>(pList), pPattern, fCase));}

int     WINAPI   StrSubstituteChar  (PWSTR psz, WCHAR chOld, WCHAR chNew); 
int     WINAPI   StrSubstituteCharA (PSTR  psz, CHAR  chOld, CHAR  chNew); // skips double byte chars

//----------------------------------------------------------------
// !! WARNING!! If you call FindURL or IsProtocol, you must call FreeCachedURLResources()
#define NO_HITTEST -1
BOOL    WINAPI   FindURL (
    PCWSTR sz,                // IN buffer
    int iLen,                 // IN length of buffer
    int iAt,                  // IN index of point to intersect, or NO_HITTEST
    INT_PTR * piStart,        // IN/OUT starting index to begin scan (IN), start of URL (OUT)
    INT_PTR * piEndProtocol,  // OUT index of end of protocol
    INT_PTR * piEnd           // OUT index of end of URL
    );
BOOL    WINAPI   IsProtocol (PCWSTR sz);
void    WINAPI   FreeCachedURLResources (void);

//----------------------------------------------------------------
void    WINAPI   SwapSegments    (PWSTR x, PWSTR y, PWSTR z);
void    WINAPI   PivotSegments   (PWSTR pA, PWSTR pB, PWSTR pC, PWSTR pD);

#define TRUNC_BEGIN    0 // remove text at the very beginning
#define TRUNC_LEFT     1 // remove text towards the beginning
#define TRUNC_CENTER   2 // remove text from the center
#define TRUNC_RIGHT    3 // remove text towards the end
#define TRUNC_END      4 // remove text from the very end
void    WINAPI   FitText(PCWSTR pszText, int cchText, PWSTR pszDst, int cchDst, PCWSTR pszFill, DWORD flags);

inline  BOOL WINAPI AbbreviateText  (PCWSTR szText, int cchGoal, PCWSTR szFiller, PCWSTR szDelim, PWSTR szBuf, int cchBuf)
{
    //VSASSERT(cchGoal <= cchBuf);
    (void)szDelim;
    (void)cchBuf;
    FitText(szText, -1, szBuf, cchGoal, szFiller, TRUNC_CENTER);
    return TRUE;
}
// anyone using this version?
BOOL    WINAPI   AbbreviateTextA (PCSTR  szText, int cchGoal, PCSTR  szFiller, PCSTR  szDelim, PSTR  szBuf, int cchBuf);

// NormalizeFileSlashes
// Convert forward slashes to backslashes.
// Reduce multiple slashes to a single slash (leading double slash allowed).
//
// To normalize to forward slashes use StrSubstituteChar(psz, '\\', '/'); after NormalizeFileSlashes
//
// Returns a pointer to the 0 terminator of the transformed string
//
PWSTR   WINAPI   NormalizeFileSlashes  (PWSTR szFile);
PSTR    WINAPI   NormalizeFileSlashesA (PSTR  szFile);

void    WINAPI   TrimWhitespace  (PWSTR psz); // removes leading and trailing whitespace from psz

// Remove blanks adjacent to line ends within a buffer.
#define TLB_START      1
#define TLB_END        2
int     WINAPI   TrimLineBlanks  (PWSTR pchBuf, int cch, DWORD dwFlags);

enum StripBlanksFlags{
//  --------------------    ------     -----------------------   -------------------------
//  Flag:                   Value:     On input:                 Return value:
//  --------------------    ------     -----------------------   -------------------------
    STB_NONE              = 0x0000, // Remove all blanks.        No blanks found.
    STB_SINGLE            = 0x0001, // Reduce to single blanks.  Only single blanks found.
    STB_MULTIPLE          = 0x0002, // (N/A)                     Multiple blanks found.
    STB_STRIP_LINEBREAKS  = 0x0010  // Include line breaks.      (N/A)
};
StripBlanksFlags  WINAPI  StripBlanks (WCHAR * pchBuf, INT_PTR * plen, int flags = STB_NONE);

// Determine whether a file path is local, UNC, or absolute 
//
// These examine the string only, and only the first part at that.  They don't
// attempt to decide whether the path is a valid filename or not.

BOOL WINAPI IsLocalAbsPath(PCWSTR sz);   // Path starts with <letter>:
BOOL WINAPI IsUNC(PCWSTR sz);            // Path starts with two backslashes
BOOL WINAPI IsAbsPath(PCWSTR sz);        // Either of the above

// Remove Bidi formatting characters from a string if the underlying system does not support them.
// They would be displayed as ? on Win9x systems that don't have appropriate codepage support.

void WINAPI StripUnsupportedBidiFormatChars(PWSTR sz);

//-----------------------------------------------------------------
/*
  BOOL FindURL (
    PCWSTR sz,                // IN buffer
    int iLen,                 // IN length of buffer
    int iAt,                  // IN index of point to intersect, or NO_HITTEST
    INT_PTR * piStart,        // IN/OUT starting index to begin scan (IN), start of URL (OUT)
    INT_PTR * piEndProtocol,  // OUT index of end of protocol
    INT_PTR * piEnd           // OUT index of end of URL
    );

  Find an URL in text, starting at *piStart index into wsz.
  iAt is NO_HITTEST to find the first URL in the text.
  To find an URL that intersects a point in the text, iAt is index from wsz of the point.
*/

//-----------------------------------------------------------------
//
// int StrLen (PCWSTR psz);
// Returns: count of chars in string 
//

//-----------------------------------------------------------------
//
// PSTR FindLastCharA (PCSTR psz, CHAR ch);
//
// MBCS-aware version of strrchr.
// Returns: pointer to right-most instance of ch in psz.
//

//-----------------------------------------------------------------
//
// PWSTR FindCharInSet (PCWSTR pchBuffer, int cchBuffer, PCWSTR set);
//
// Length-limited wide-char version of strpbrk.
// Returns: pointer to first char from set in buffer.
//

//-----------------------------------------------------------------
//
// PWSTR CopyCat (PWSTR dst, PCWSTR src)
//
// Wide char string copy for concatenation. Copy Src to Dst.
// Return: position of NUL in dst for further catenation.
//

//-----------------------------------------------------------------
//
// PWSTR CopyNCat (PWSTR dst, PCWSTR src, int cchz);
//
// NUL-limited char copy up to n chars for catentation
//
// Return: Position after char n in destination or position of 
//         copied NUL for further catenation.
//

//-----------------------------------------------------------------
//
// int StrListSize   (PCWSTR psz); 
//
// Return: count of chars to hold the list (includes terminator)

//-----------------------------------------------------------------
//
// int StrListSizeA  (PCSTR  psz); 
//
// Return: count of bytes to hold the list (includes terminator)

//-----------------------------------------------------------------
//
// int StrListCount  (PCWSTR psz); 
//
// Return: count of strings in the list (not including terminator)

//-----------------------------------------------------------------
//
// int StrListCountA (PCSTR  psz);
//
// Return: count of strings in the list (not including terminator)

//-----------------------------------------------------------------
//
// int StrListCounts (PCWSTR psz, int * pcStr = NULL); 
//
// pcStr    Receives count of strings in the list (not including terminator)
//
// Return: return count of chars to hold list
//

//-----------------------------------------------------------------
//
// PCWSTR * StrListCreateArray (PCWSTR pList, int * pcel);
//
// pcel     Receives a count of elements in the returned array,
//          not including the terminating NULL entry.
//
// Return: NULL-terminated array of PWSTRs pointing to the strings 
//         in pList, or NULL if out of memory.
//
// You must free the returned array using VSFree
//

//-----------------------------------------------------------------
//
// PCWSTR StrListNext (PCWSTR pList);
//
// Return: Pointer to the next non-empty string in the list, or 
//         NULL if no more strings
//

//-----------------------------------------------------------------
//
// HRESULT StrListSort (PWSTR pList, bool fCase = true);
//
// Sorts the string list
//
// fCase    true for case-sensitive, false for case-insensitive
//
// Return: success
//

//-----------------------------------------------------------------
//
// HRESULT StrListSortPairs (PWSTR pList, bool fCase = true);
//
// Sorts the paired-string (key/value) list. There must be an even 
// number of strings in the list. Keys and values must not contain L'\1'.
//
// fCase    true for case-sensitive, false for case-insensitive
//
// Return: success
//

//-----------------------------------------------------------------
//
// PCWSTR StrListFind (PCWSTR pList, PCWSTR pPattern, bool fCase = true);
//
// pList     Sorted list of strings to search
// pPattern  String to find in list
// fCase     true to match exact case, false to ignore case 
//
// Return: Matching string in list or NULL if not found
//

//-----------------------------------------------------------------
//
// PCWSTR StrListFindSorted (PCWSTR pList, PCWSTR pPattern, bool fCase = true);
//
// pList     Sorted list of strings to search
// pPattern  String to find in list
// fCase     true to match exact case, false to ignore case 
//           The list must be sorted in ascending order with the same fCase
//
// Return: Matching string in list or NULL if not found
//

//-----------------------------------------------------------------
//
// int StrSubstituteChar  (PWSTR psz, WCHAR chOld, WCHAR chNew); 
// int StrSubstituteCharA (PSTR  psz, CHAR  chOld, CHAR  chNew); // skips double byte chars
//
// Return: Count of chars replaced
//

//-----------------------------------------------------------------
//
// void TrimWhitespace (PWSTR psz);
//
// Remove whitespace from the start and end of the string
//

//-----------------------------------------------------------------
//
// int TrimLineBlanks (PWSTR pchBuf, int cch, DWORD dwFlags);
//
// Remove blanks adjacent to line ends within a buffer.
//
// cch == -1 for zero-terminated string.
// Set TLB_START in dwFlags to also remove blanks at the start of the buffer.
// Set TLB_END in dwFlags to also remove blanks at the end of the buffer.
// 
// Returns trimmed length (if cch == -1, length includes terminator)
// 

//-----------------------------------------------------------------
//
// BOOL AbbreviateText (PCWSTR szText, int cchGoal, PCWSTR szFiller, PCWSTR szDelim, PWSTR szBuf, int cchBuf);
//
//  szText      String to abbreviate
//  cchGoal     Size to reduce it too, including filler
//  szFiller    String to replace deleted text with (e.g. "...")
//  szDelim     Set of characters that delimit chunks of text
//  szBuf       Buffer for result
//  cchBuf      Size of szBuf
//
// Returns FALSE if szText couldn't be shortened to cchGoal.
//

//-----------------------------------------------------------------
//
// void WINAPI SwapSegments(PWSTR x, PWSTR y, PWSTR z);
//
// Swap two segments of a string.
//
//  IN: xxxxxYYYz
// OUT: YYYxxxxxz
//
// Z can point to the zero terminator or past the end of the buffer.
// The swap is performed in-place.
//

//-----------------------------------------------------------------
// void PivotSegments (PWSTR pA, PWSTR pB, PWSTR pC, PWSTR pD);
//
// Pivot two segments of a string around a middle segment.
//
//  IN: aaaaaaaBBcccccD
// OUT: cccccBBaaaaaaaD
//
// D can point to the zero terminator or past the end of the buffer.
// The pivot is performed in-place.
//

//=================================================================
//===== Implementation ============================================
//=================================================================

inline int WINAPI StrLen (PCWSTR psz)
{
    if (!psz) return 0;
    PCWSTR pch = psz;
    while (*pch)
        pch++;

    // ASSUME: length never > 4GB
    return (LONG32) (pch - psz);
}

inline int WINAPI StrLenA (PCSTR psz) 
{ 
    if (!psz) return 0;
	// Win64Fix (MikhailA): strlen returns size_t which is 64-bit long.
	// In this particular case I think int is sufficient and I won't need to fix ann the calls to the StrLenA
    return (int) strlen(psz);
}

inline PWSTR WINAPI CopyCat (PWSTR dst, PCWSTR src)
{
    while (*dst++ = *src++)
        ;
    return --dst; 
}

inline PWSTR WINAPI CopyCatStop (PWSTR dst, PCWSTR src, PCWSTR stop)
{
    if (dst >= stop) return dst;
    while ((dst < stop) && (*dst++ = *src++))
        ;
    --dst;
    if (!*dst)
      *dst = 0;
    return dst;
}

inline PSTR WINAPI CopyCatStopA (PSTR dst, PCSTR src, PCSTR stop)
{
    if (dst >= stop) return dst;
    while ((dst < stop) && (*dst++ = *src++))
        ;
    --dst;
    if (!*dst)
      *dst = 0;
    return dst;
}

// Ansi version
inline PSTR WINAPI CopyCatA (PSTR dst, PCSTR src)
{
    while (*dst++ = *src++)
        ;
    return --dst; 
}

// Guarantees zero termination. Can write one more than cchz
inline PWSTR WINAPI CopyNCat (PWSTR dst, PCWSTR src, int cchz)
{
    WCHAR ch = 0xFFFF; // UCH_NONCHAR
    while (cchz-- && (ch = *dst++ = *src++))
        ;
    if (ch)
    {
        *dst = 0;
        return dst;
    }
    else
        return --dst;
}

// does not guarantee zero termination, never writes more than cch
inline PWSTR WINAPI MemCopyNCat (PWSTR dst, PCWSTR src, int cch)
{
    while (cch-- && (*dst++ = *src++))
        ;
    if (cch >= 0)
        --dst;
    return dst;
}

// Ansi version
inline PSTR WINAPI CopyNCatA (PSTR dst, PCSTR src, int cchz)
{
    CHAR ch = 1;
    while (cchz-- && (ch = *dst++ = *src++))
        ;
    if (ch)
    {
        *dst = 0;
        return dst;
    }
    else
        return --dst;
}

inline PWSTR WINAPI CopyCatInt (PWSTR dst, int n, int radix)
{
	_itow(n, dst, radix);
	while (*dst)
		dst++;
	return dst;
}

inline PSTR WINAPI CopyCatIntA (PSTR dst, int n, int radix)
{
	_itoa(n, dst, radix);
	while (*dst)
		dst++;
	return dst;
}

inline PCWSTR WINAPI FindChar (PCWSTR psz, WCHAR ch)
{
    if (!psz) 
        return NULL;
    WCHAR T;
    do
	{
        T = *psz;
        if (T == ch)
            return psz;
        psz++;
    } while (T);
    return NULL;
}

inline PCWSTR WINAPI FindSlash (PCWSTR psz)
{
    if (!psz) 
        return NULL;
    WCHAR T;
    do
	{
        T = *psz;
        if ((T == L'\\') || (T == L'/'))
            return psz;
        psz++;
    } while (T);
    return NULL;
}

inline PCWSTR WINAPI FindCharN (PCWSTR pchBuffer, int cch, WCHAR ch)
{
    if (!pchBuffer) 
        return NULL;
    while (cch--)
    {
        if (ch == *pchBuffer)
            return pchBuffer;
        ++pchBuffer;
    }
    return NULL;
}

inline PCWSTR WINAPI FindLastChar (PCWSTR  psz, WCHAR ch)
{
    if (!psz) 
        return NULL;
    PCWSTR pch = NULL;
    WCHAR T;
    for (; T = *psz; psz++)
    {
        if (T == ch)
            pch = psz;
    }
    return pch;
}

inline PCWSTR WINAPI FindLastSlash (PCWSTR  psz, int iLength)
{
    if (!psz || !iLength) 
        return NULL;

    for (PCWSTR pch = psz + (iLength-1); pch >= psz; pch--)
    {
        if ((*pch == L'\\') || (*pch == L'/'))
            return pch;
    }
    return NULL;
}

inline BOOL WINAPI IsLocalAbsPath (PCWSTR sz)
{
    return ((sz[0] >= L'A' && sz[0] <= L'Z') || (sz[0] >= L'a' && sz[0] <= L'z'))
        && sz[1] == L':';
}

inline BOOL WINAPI IsUNC (PCWSTR sz)
{
    return sz[0] == L'\\' && sz[1] == L'\\';
}

inline BOOL WINAPI IsAbsPath (PCWSTR sz)
{
    return IsLocalAbsPath(sz) || IsUNC(sz);
}

#endif __UNISTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\utable.h ===
// utable.h - UniLib table access functions, 
// Private to UniLib -- do not use these directly.

#pragma once

BYTE WINAPI RLELookup$ (const BYTE * pbData, BYTE index);
BYTE WINAPI LookupPropRLE$ (BYTE **prgTable, WCHAR ch);
BYTE WINAPI LookupProp$    (BYTE **prgTable, WCHAR ch);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\utf.h ===
// utf.h
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// June 1, 1998 [paulde]  Revised for UniLib, surrogates
//
// Routines are documented in more detail below the declarations in 
// the "-- DOCUMENTATION --" section.
//
//-----------------------------------------------------------------
#pragma once
#ifndef __UTF_H__
#define __UTF_H__

// See "About the UTF-8 file signature" below for information and usage.
// EF BB BF
#define UTF8SIG     "\xEF\xBB\xBF" 
#define UTF8SIGLEN  (3)

// U8TU_* flags returned by UTF8ToUnicode[Info]
#define U8TU_NONASCII        0x00000001  // Info : found non-ASCII chars
#define U8TU_UCS4            0x00000002  // Info : found UCS-4 (4-byte) chars. The Unicode data contains surrogates.
#define U8TU_OVERLONG        0x00000004  // Info:  found UTF-8 sequence longer than required: char converted to UCH_REPLACE
#define U8TU_TRAIL_NO_COUNT  0x80000100  // Error: trail byte with 0 trail count
#define U8TU_COUNT_NO_TRAIL  0x80000200  // Error: nonzero trail count but no trail byte
#define U8TU_UCS4OUTOFRANGE  0x80000400  // Error: UCS4 char is out of range to represent in Unicode

// Test a U8TU_... value for errors
#define U8TU_IsError(dw)    (0 != ((dw) & 0x80000000))

// NOTE: UTF-8 encoders are supposed to use the shortest possible sequence to represent a character.
// Overlong sequences are either a bug in the UTF-8 encoder, or an attempt to use overlong data
// as a covert channel or to circumvent security. Overlong sequences generate UCH_REPLACE instead of 
// the character, and we flag U8TU_OVERLONG, but this is not an error.
//

// VU16_* flags returned by ValidateUTF16
#define VU16_NONASCII        0x00000001  // Info : found non-ASCII chars
#define VU16_UCS4            0x00000002  // Info : found non-BMP chars. The Unicode data contains surrogates.
#define VU16_NONCHAR         0x00000004  // Info : found noncharacters (U+xFFFE and U+xFFFF, where x is from 0 to 0x10,
                                         //        as well as the values U+FDD0..U+FDEF)
#define VU16_UNPAIRSURROGATE 0x80000100  // Error: high surrogate without a low surrogate, or vice versa

// Test a VU16_... value for errors
#define VU16_IsError(dw)    (0 != ((dw) & 0x80000000))


#define NULL_TERMINATED_MODE          (-1L)

// !!!!!!!!!!!!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!!!!!!!!!!!!
//
// DO NOT pass NULL output buffers to get the required buffer size. 
//
// To get the length of output buffers, use the explicit length functions:
// UnicodeLengthOfUTF8, UTF8LengthOfUnicode.
//

// "just convert it as fast as possible"
int  WINAPI  UTF8ToUTF16         (PCSTR pUTF8, int cbUTF, PWSTR pUTF16, int cchUTF16);

// "convert it and tell me all about it"
int  WINAPI  UTF8ToUTF16Info     (PCSTR pUTF8, int * pcbUTF8, PWSTR pUTF16, int cchUTF16, DWORD * pdwInfo);

// "tell me ALL about it"
// when fScanAll is FALSE, errors immediately terminate scanning the data 
int  WINAPI  GetUTF8Info         (PCSTR pUTF8, int * pcbUTF8, DWORD * pdwInfo, BOOL fScanAll = FALSE);

// "just tell me how many wchars I'll need, as fast as possible"
int  WINAPI  UTF16LengthOfUTF8   (PCSTR pUTF8, int cbUTF8);

int  WINAPI  UTF16ToUTF8         (PCWSTR pUTF16, int * pcchUTF16, PSTR pUTF8, int cbUTF8);

// "tell me exactly how many chars I need to convert"
int  WINAPI  UTF8LengthOfUTF16   (PCWSTR pUTF16, int cchUTF16);

// "tell me about any errors in this UTF-16 text"
DWORD WINAPI ValidateUTF16       (PCWSTR pUTF16, int cchUTF16, BOOL fScanAll = FALSE);


//================= COMPATIBILITY WRAPPERS ========================
//
// UTF-16 is the more precise term, but there is existing code that
// uses "Unicode" to refer to UTF-16.

inline int WINAPI UTF8ToUnicode(PCSTR pUTF8, int cbUTF, PWSTR pUni, int cchUni)
{
 return UTF8ToUTF16(pUTF8, cbUTF, pUni, cchUni);
}

inline int WINAPI UTF8ToUnicodeInfo(PCSTR pUTF8, int * pcbUTF8, PWSTR pUni, int cchUni, DWORD * pdwInfo)
{
  return UTF8ToUTF16Info(pUTF8, pcbUTF8, pUni, cchUni, pdwInfo);
}

inline int WINAPI UnicodeLengthOfUTF8(PCSTR pUTF8, int cbUTF)
{
  return UTF16LengthOfUTF8(pUTF8, cbUTF);
}

inline int WINAPI UnicodeToUTF8(PCWSTR pUni, int * pcchUni, PSTR pUTF8, int cbUTF)
{
  return UTF16ToUTF8(pUni, pcchUni, pUTF8, cbUTF);
}

inline int WINAPI UTF8LengthOfUnicode(PCWSTR pUni, int cchUni)
{
  return UTF8LengthOfUTF16(pUni, cchUni);
}


//===================== DOCUMENTATION =============================

//-----------------------------------------------------------------
//
// int UTF8ToUTF16Info (PCSTR pUTF8, int * pcbUTF8, PWSTR pUTF16, int cchUTF16, DWORD * pdwInfo);
//
// Convert UTF8 to UTF-16
//
// pUTF8      UTF-8 data
// pcbUTF8    IN : Count of UTF-8 bytes to convert, or NULL_TERMINATED_MODE.
//            OUT: Count of UTF-8 bytes converted.
// pUTF16     Buffer for converted UTF-16 text
// cchUTF16   Size of UTF-16 buffer in WCHARs.
// pdwInfo    NULL or address of flags for errors/information.
//            See U8TU_* flags above for more info. 
//
// Return:
//   Count of 16-bit code units written, including 0 terminator 
//   if NULL_TERMINATED_MODE.
//
// The conversion always completes, even in the presence of errors. *pdwInfo contains 
// status and error information. When there are conversion errors, the Unicode buffer 
// may contain one or more of character UCH_REPLACE (0xFFFD) "REPLACEMENT CHARACTER" 
// for un-convertible data.
//

//-----------------------------------------------------------------
// int GetUTF8Info (PCSTR pUTF8, int * pcbUTF8, DWORD * pdwInfo, BOOL fScanAll = FALSE);
//
// Get size and optional information/errors for conversion of UTF-8 to UTF-16.
//
// pUTF8      UTF-8 data
// pcbUTF8    IN : Count of UTF-8 bytes to scan, or NULL_TERMINATED_MODE.
//            OUT: Count of valid UTF-8 scanned.
// pdwInfo    Information and errors in the conversion.
//            See U8TU_* flags above for more info. 
// fScanAll   TRUE : scan entire UTF-8 data
//            FALSE: stop scanning at the first error and return
// Return:
//   Count of 16-bit code units required to represent the characters scanned, 
//   including 0 terminator if NULL_TERMINATED_MODE
//

//-----------------------------------------------------------------
// DWORD ValidateUTF16 (PCWSTR pUTF16, int cchUTF16, BOOL fScanAll = FALSE)
//
// Get size and optional information/errors for conversion of UTF-8 to UTF-16.
//
// pUTF16     UTF-16 data
// cchUTF16   Count of 16-bit code units to scan, or NULL_TERMINATED_MODE.
// fScanAll   TRUE : scan entire text
//            FALSE: stop scanning at the first error and return
// Return:
//   Information and errors in the text -- See VU16_* flags above for more info. 
//

//-----------------------------------------------------------------
//
// int UTF16ToUTF8 (PCWSTR pUTF16, int * pcchUTF16, PSTR pUTF8, int cbUTF8)
//
// Convert UTF-16 to UTF-8
//
// pUTF16    Source UTF-16 data
// pcchUTF16 in:  Count of 16-bit code units to convert, or NULL_TERMINATED_MODE.
//           out: count of 16-bit code units converted.
// pUTF8     Destination buffer.
// cbUTF8    Count of bytes in pUTF8.
//
// Returns:
//    Number of bytes written, including 0 terminator if NULL_TERMINATED_MODE.
//
//

//-----------------------------------------------------------------
// int UTF8LengthOfUTF16 (PCWSTR pUTF16, int cchUTF16)
//
// Get exact number of bytes required to convert 
//

//-----------------------------------------------------------------
// About the UTF-8 file signature
// -------------------------------
// The UTF-8 file signature is the UTF-8 encoding of the Unicode byte order mark.
// the byte order mark is generally used as a signature for Unicode files.
// 
// When writing plain-text UTF-8 files, begin the file with this signature.
// 
// When reading plain-text files:
// 
//   If you see the UTF-8 signature, you can assume that the file is UTF-8.
// 
//   If there is no UTF-8 signature, you can try converting. If the conversion
//   has no errors, you can be fairly sure that the file is UTF-8 and not
//   an MBCS plain-text file. This cannot be 100% positive, however. It is 
//   possible to construct MBCS files in various codepages that also happen to 
//   be valid UTF-8.
// 
//-----------------------------------------------------------------

#endif // __UTF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\version.h ===
#define rmj 7
#define rmm 0
#define rup 9466
#define rpt 2 // Must be greater that zero so MSI will replace the dlls.
#define szVerName ""
#define szVerUser "VSBLD208"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\userdata.h ===
//------------------------------------------------------------------------------
// USERDATA.H
//------------------------------------------------------------------------------
#pragma once
#include "textmgr.h"
#include "util.h"

class CUserData : public IVsUserData
{
private:
    struct DataNode
    {
        GUID                guidKey;
        VARIANT             vtData;
    };

    UINT                    m_dwRef;     // refcount 
    CStructArray<DataNode>  m_Data;

public:
    CUserData() : m_dwRef(0) {}
    virtual ~CUserData();

    // IUnknown
    //
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID *ppObj)
    {
        *ppObj = NULL;
        if (riid == IID_IUnknown)
            *ppObj = this;
        else if (riid == IID_IVsUserData)
            *ppObj = (IVsUserData *)this;

        if (*ppObj)
        {
            ((IUnknown *)(*ppObj))->AddRef();
            return NOERROR;
        }

        return E_NOINTERFACE;
    }

    STDMETHODIMP_(ULONG) AddRef ()
    {
        return ++m_dwRef;
    }

    STDMETHODIMP_(ULONG) Release ()
    {
        if (--m_dwRef)
            return (m_dwRef);
        delete this;
        return 0;
    }

    // IUserData methods
    STDMETHOD   (GetData)(REFGUID rguidKey, VARIANT *pvtData);
    STDMETHOD   (SetData)(REFGUID rguidKey, VARIANT vtData);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\verstamp.h ===
#ifndef _VERSION_H_INCL
#include "version.h"                   /* SLM maintained version file */
#endif

#if defined(_WIN32) || defined(WIN32)
#include <winver.h>
#else   /* !WIN32 */
#include <ver.h>
#endif  /* !WIN32 */

#ifndef rpt
#define rpt 0
#endif

#if     (rmm < 10)
#define rmmpad "0"
#else
#define rmmpad
#endif

#if     (rpt == 0)
#define VERSION_STR1(a,b,c,d)       #a "." rmmpad #b "." ruppad #c
#else
#define VERSION_STR1(a,b,c,d)       #a "." rmmpad #b "." ruppad #c "." #d
#endif

#if     (rup < 10)
#define ruppad "000"
#elif   (rup < 100)
#define ruppad "00"
#elif   (rup < 1000)
#define ruppad "0"
#else
#define ruppad
#endif

#define VERSION_STR2(a,b,c,d)       VERSION_STR1(a,b,c,d)
#define VER_PRODUCTVERSION_STR      VERSION_STR2(rmj,rmm,rup,rpt)
#define VER_PRODUCTVERSION          rmj,rmm,rup,rpt

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

// DEBUG flag is set for debug build, not set for retail build
#if defined(DEBUG) || defined(_DEBUG)
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

// PRIVATEBUILD flag is set if not built by build lab
#if defined(_SHIP)
#define VER_PRIVATEBUILD            0
#else
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#endif

// PRERELEASE flag is always set unless building SHIP version
#if defined(_SHIP)
#define VER_PRERELEASE              0
#else
#define VER_PRERELEASE              VS_FF_PRERELEASE
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#if defined(_WIN32) || defined(WIN32)
#define VER_FILEOS                  VOS__WINDOWS32
#else
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#endif
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vhsdefs.h ===
/////////////////////////////////////////////////////////
//
/*
	VB doesn't understand DWORDs, so I have to change
	all of the params to longs. Since I have to wait
	to turn this code on, I have entered this code so
	I can compile both ways. This allows me to check in
	the code now.

	If you are just now writing to this code use longs instead
	of DWORDs.

	NOTE: To avoid forcing VS to recompile, I've left vshelp.dll using
	DWORDs. However, I've compiled a VB compatible typelib version of helpsvcs.tlb
	into helptb.tlb. The ocx imports this tlb instead of helpsvcs.tlb.
	This is hopefully only a temporary solution...
*/

//#define _VB_COMPATIBLE_PARAMS
#ifdef _VB_COMPATIBLE_PARAMS
#define INT_TYPE LONG_PTR
#define LCID_TYPE long
cpp_quote("#ifndef INT_TYPE")
cpp_quote("#define INT_TYPE LONG_PTR")
cpp_quote("#define LCID_TYPE long")
cpp_quote("#endif")
#else
#define INT_TYPE DWORD_PTR
#define LCID_TYPE DWORD
cpp_quote("#ifndef INT_TYPE")
cpp_quote("#define INT_TYPE DWORD_PTR")
cpp_quote("#define LCID_TYPE DWORD")
cpp_quote("#endif")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\virtkeys.h ===
//////////////////////////////////////////////////////////////////////////////
//
//Microsoft Confidential
//Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
//
//File: VirtKeys.H
//
//Contents: Taken from winuser.h
//////////////////////////////////////////////////////////////////////////////


/*
 * Virtual Keys, Standard Set
 */
#define VK_LBUTTON        0x01
#define VK_RBUTTON        0x02
#define VK_CANCEL         0x03
#define VK_MBUTTON        0x04    /* NOT contiguous with L & RBUTTON */

#define VK_BACK           0x08
#define VK_TAB            0x09

#define VK_CLEAR          0x0C
#define VK_RETURN         0x0D

#define VK_SHIFT          0x10
#define VK_CONTROL        0x11
#define VK_MENU           0x12
#define VK_PAUSE          0x13
#define VK_CAPITAL        0x14


#define VK_ESCAPE         0x1B

#define VK_SPACE          0x20
#define VK_PRIOR          0x21
#define VK_NEXT           0x22
#define VK_END            0x23
#define VK_HOME           0x24
#define VK_LEFT           0x25
#define VK_UP             0x26
#define VK_RIGHT          0x27
#define VK_DOWN           0x28
#define VK_SELECT         0x29
#define VK_PRINT          0x2A
#define VK_EXECUTE        0x2B
#define VK_SNAPSHOT       0x2C
#define VK_INSERT         0x2D
#define VK_DELETE         0x2E
#define VK_HELP           0x2F

/* VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
/* VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */

#define VK_LWIN           0x5B
#define VK_RWIN           0x5C
#define VK_APPS           0x5D

#define VK_NUMPAD0        0x60
#define VK_NUMPAD1        0x61
#define VK_NUMPAD2        0x62
#define VK_NUMPAD3        0x63
#define VK_NUMPAD4        0x64
#define VK_NUMPAD5        0x65
#define VK_NUMPAD6        0x66
#define VK_NUMPAD7        0x67
#define VK_NUMPAD8        0x68
#define VK_NUMPAD9        0x69
#define VK_MULTIPLY       0x6A
#define VK_ADD            0x6B
#define VK_SEPARATOR      0x6C
#define VK_SUBTRACT       0x6D
#define VK_DECIMAL        0x6E
#define VK_DIVIDE         0x6F
#define VK_F1             0x70
#define VK_F2             0x71
#define VK_F3             0x72
#define VK_F4             0x73
#define VK_F5             0x74
#define VK_F6             0x75
#define VK_F7             0x76
#define VK_F8             0x77
#define VK_F9             0x78
#define VK_F10            0x79
#define VK_F11            0x7A
#define VK_F12            0x7B
#define VK_F13            0x7C
#define VK_F14            0x7D
#define VK_F15            0x7E
#define VK_F16            0x7F
#define VK_F17            0x80
#define VK_F18            0x81
#define VK_F19            0x82
#define VK_F20            0x83
#define VK_F21            0x84
#define VK_F22            0x85
#define VK_F23            0x86
#define VK_F24            0x87

#define VK_NUMLOCK        0x90
#define VK_SCROLL         0x91

/*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
#define VK_LSHIFT         0xA0
#define VK_RSHIFT         0xA1
#define VK_LCONTROL       0xA2
#define VK_RCONTROL       0xA3
#define VK_LMENU          0xA4
#define VK_RMENU          0xA5

#define VK_OEM_PLUS       0xBB   // '+' any country
#define VK_OEM_COMMA      0xBC   // ',' any country
#define VK_OEM_MINUS      0xBD   // '-' any country
#define VK_OEM_PERIOD     0xBE   // '.' any country

#define VK_PROCESSKEY     0xE5

#define VK_ATTN           0xF6
#define VK_CRSEL          0xF7
#define VK_EXSEL          0xF8
#define VK_EREOF          0xF9
#define VK_PLAY           0xFA
#define VK_ZOOM           0xFB
#define VK_NONAME         0xFC
#define VK_PA1            0xFD
#define VK_OEM_CLEAR      0xFE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\util.h ===
//---------------------------------------------------------------------------
// Microsoft Visual Studio
//
// Microsoft Confidential
// Copyright (C) 1994 - 2000 Microsoft Corporation. 
// All Rights Reserved.
//
// Util.h -- utility classes
//---------------------------------------------------------------------------
#pragma once

/////////////////////////////////////////////////////////////////////////////
// CString -- simple string class

class CString
{
public:
	CString() : m_psz(NULL)							{ Copy(L"", 0); }
	CString(const CString& str) : m_psz(NULL)		{ Copy(str); }
	CString(const WCHAR* psz) : m_psz(NULL)			{ Copy(psz); }
	CString(const WCHAR* psz, int iLen) : m_psz(NULL)	{ Copy(psz, iLen); }
	~CString();

	void Empty()									{ Copy(L"", 0); }
	CString& Append(const WCHAR* psz)				{ return Append(psz, lstrlenW(psz)); }
	CString& Append(const WCHAR* pch, int iAppend);
	CString& Prepend(const WCHAR* psz)				{ return Prepend(psz, lstrlenW(psz)); }
	CString& Prepend(const WCHAR* pch, int iPrepend);
	CString& Copy(const WCHAR* psz)					{ return Copy(psz, lstrlenW(psz)); }
	CString& Copy(const WCHAR* pch, int iLen);
	int Length() const								{ return lstrlenW(m_psz); }
	void SetLength(int iLen);
	WCHAR GetAt(int i) const						{ return m_psz[i]; }
	void SetAt(int i, WCHAR ch)						{ m_psz[i] = ch; }
	BOOL IsEqual(const WCHAR* psz) const			{ return IsEqual(psz, lstrlenW(psz)); }
	BOOL IsEqual(const WCHAR* pch, int iLen) const;
	int Compare(const WCHAR* psz) const				{ return Compare(m_psz, psz); }
	int CompareNoCase(const WCHAR* psz) const		{ return CompareNoCase(m_psz, psz); }

	static BOOL IsEqual(const WCHAR* pszW1, const WCHAR* pszW2);
	static int _stdcall Compare(const WCHAR* pszW1, const WCHAR* pszW2);
	static int _stdcall CompareNoCase(const WCHAR* pszW1, const WCHAR* pszW2);
	static int Compare(const WCHAR* pszW1, const WCHAR* pszW2, int iLen);
	static int CompareNoCase(const WCHAR* pszW1, const WCHAR* pszW2, int iLen);
	int LoadResourceString(UINT id, HINSTANCE hInst);

	CString& operator=(const CString& str)			{ return Copy(str); }
	CString& operator=(const WCHAR* psz)			{ return Copy(psz); }
	CString& operator+=(const WCHAR* psz)			{ return Append(psz); }
	BOOL operator==(const WCHAR* psz) const			{ return IsEqual(psz); }
	BOOL operator!=(const WCHAR* psz) const			{ return !IsEqual(psz); }
	BOOL IsNULL () const                            { return m_psz == NULL; }
	BOOL IsEmpty () const                           { return m_psz == NULL || *m_psz == 0; }
	operator const WCHAR*() const					{ return m_psz; }

#ifndef _UNICODE
	CString(const TCHAR* psz) : m_psz(NULL)			{ Copy(psz); }
	CString(const TCHAR* psz, int iLen) : m_psz(NULL)	{ Copy(psz, iLen); }
	CString& Append(const TCHAR* psz)				{ return Append(psz, lstrlen(psz)); }
	CString& Append(const TCHAR* pch, int iAppend);
	CString& Copy(const TCHAR* psz)					{ return Copy(psz, lstrlen(psz)); }
	CString& Copy(const TCHAR* pch, int iLen);
	CString& operator=(const TCHAR* psz)			{ return Copy(psz); }
	CString& operator+=(const TCHAR* psz)			{ return Append(psz); }
#endif

protected:
	WCHAR* m_psz;
};

/////////////////////////////////////////////////////////////////////////////
// CDictImpl -- implementation class for CDict

class CDictImpl
{
private:
	friend class CDictEnumImpl;

	struct CBucket
	{
		DWORD   dwHash;
		void	*pValue;
		CBucket	*pNext;
		WCHAR   szKey[1];
	};

	CBucket **m_ppBuckets;
	int		m_iCount;

	int		BucketIndex (DWORD dwHash) { return dwHash & (m_nBuckets-1); }

	// CDictImpl cannot be copied!
	CDictImpl(const CDictImpl&) {}
	CDictImpl& operator=(const CDictImpl&) { return *this; }

protected:
	BOOL	m_fIgnoreCase;
	int		m_nBuckets;

protected:
	void*	_Find (const WCHAR *pszName);
	BOOL	_Add (const WCHAR *pszName, void *pObj);
	BOOL	_RemoveValue (void *pObj, BOOL fRemoveAll);
	void	_Enum (CDictEnumImpl& e);
	
	virtual void _OnRemove (void *pObj) = 0;
	virtual void _OnAdd (void *pObj) = 0;

public:
	CDictImpl(BOOL fIgnoreCase = FALSE, int nBuckets = 32);
	~CDictImpl();

	DWORD	_Hash (const WCHAR *pszName);	// default hash algorithm

	BOOL	Remove (const WCHAR *pszName);
	void	RemoveAll ();
	int		Count () { return m_iCount; }

	virtual	DWORD Hash (const WCHAR *pszName) = 0;

#ifdef _DEBUG
	void	Dump ();
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDictEnumImpl -- implementation class for CDictEnum

class CDictEnumImpl
{
private:
	friend class CDictImpl;

	CDictImpl* m_pDict;
	int m_iBucketIndex;
	CDictImpl::CBucket* m_pBucket;

protected:
	void	_Init (CDictImpl* pDict);
	void	*_Next (const WCHAR** ppszKey);

public:
	CDictEnumImpl ();

	BOOL    Next (const WCHAR **ppszKey) { return _Next (ppszKey) != NULL; }
	long    Count () { return m_pDict->Count(); }
	void	Reset ();
};

/////////////////////////////////////////////////////////////////////////////
// CDictCallback -- callback interface for CDict

template <class T>
class CDictCallback
{
public:
	virtual void OnRemove (T *pObj) const {}
	virtual void OnAdd (T *pObj) const {}
};

/////////////////////////////////////////////////////////////////////////////
// CDictEnum -- enumerator for elements in a CDict

template <class T>
class CDictEnum : public CDictEnumImpl
{
public:
	T		*Next (const WCHAR** ppszKey = NULL) { return (T *)_Next(ppszKey); }
};

/////////////////////////////////////////////////////////////////////////////
// CDict -- simple string-to-object dictionary

template <class T>
class CDict : public CDictImpl
{
private:
	const CDictCallback<T>	*m_pCallback;
	
protected:
    virtual void    _OnAdd (void *pObj)     { OnAdd ((T *)pObj); }
    virtual void    _OnRemove (void *pObj)  { OnRemove ((T *)pObj); }

public:
	CDict (const CDictCallback<T> *pCallback = NULL, BOOL fIgnoreCase = FALSE, int nBuckets = 32) :
		CDictImpl(fIgnoreCase, nBuckets)
	{
		m_pCallback = pCallback;
	}

	~CDict ()									{ RemoveAll (); }

	void    SetCallback (const CDictCallback<T> *pCallback) { m_pCallback = pCallback; }
	T		*Find (const WCHAR *pszName)					{ return (T *)_Find (pszName); }
	BOOL	Add (const WCHAR *pszName, T *pObj)				{ return _Add (pszName, pObj); }
	BOOL	RemoveValue (T *pObj, BOOL fRemoveAll = FALSE)	{ return _RemoveValue (pObj, fRemoveAll); }
	void	Enum (CDictEnum<T>& e)							{ _Enum(e); }

	virtual	DWORD Hash (const WCHAR *pszName)	{ return _Hash(pszName); }
	virtual void OnAdd (T *pObj)				{ if (m_pCallback) m_pCallback->OnAdd (pObj); }
	virtual void OnRemove (T *pObj)				{ if (m_pCallback) m_pCallback->OnRemove (pObj); }
};

/////////////////////////////////////////////////////////////////////////////
// CPtrArrayImpl -- implementation class for CPtrArray

class CPtrArrayImpl
{
private:
    enum { ALLOC_INCR = 8 };

    void**  m_ppData;
    int     m_iCount;
    int     m_iAlloc;

    // CPtrArrayImpl cannot be copied!
    CPtrArrayImpl(const CPtrArrayImpl&) {}
    CPtrArrayImpl& operator=(const CPtrArrayImpl&) { return *this; }

protected:
    void *  _GetAt      (int i);
    void    _SetAt      (int i, void* pData);
    BOOL    _Add        (void* pData);
    BOOL    _Remove     (void* pData);
    BOOL    _InsertAt   (int i, void* pObj);

    BOOL    _ReallocData (int iAlloc);

    void    _Sort    (                 int (__cdecl *compare )(const void *p1, const void *p2));
    int     _BSearch (const void *key, int (__cdecl *compare )(const void *p1, const void *p2));

    void    _Attach  (int cel, void** prgObj);
    void    _Detach  (void) { m_ppData = NULL; m_iCount = m_iAlloc = 0; }

public:
    CPtrArrayImpl(int iAlloc = 0);
    ~CPtrArrayImpl();

    BOOL    RemoveAt    (int i);
    void    RemoveAll   (void)  { m_iCount = 0; }
    void    SetTop      (int i) { m_iCount = i; }
    int     Count       (void)  { return m_iCount; }
};

inline CPtrArrayImpl::CPtrArrayImpl(int iAlloc) :
	m_ppData(NULL),
	m_iCount(0),
	m_iAlloc(0)
{
	_ReallocData(iAlloc);
}

/////////////////////////////////////////////////////////////////////////////
// CPtrArray -- simple array of pointers

template <class T>
class CPtrArray : public CPtrArrayImpl
{
public:
    CPtrArray (int iAlloc = 0) : CPtrArrayImpl(iAlloc) {}
    ~CPtrArray() { RemoveAll(); }

    T *     GetAt       (int i)                 { return (T*)_GetAt(i); }
    void    SetAt       (int i, T * pObj)       { _SetAt(i, pObj); }
    BOOL    Add         (T * pObj)              { return _Add(pObj); }
    BOOL    Remove      (T * pObj)              { return _Remove(pObj); }
    BOOL    InsertAt    (int i, T * pObj)       { return _InsertAt(i, pObj); }
                        
    void    Sort        (               int (__cdecl *compare)(T** p1, T** p2)) { _Sort((int (__cdecl *)(const void *, void const *))compare); }
    int     BSearch     (const T *pkey, int (__cdecl *compare)(T** p1, T** p2)) { return _BSearch((const void *)pkey, (int (__cdecl *)(const void *, void const *))compare); }
                        
    void    Attach      (int cel, T** prgObj)   { _Attach(cel, prgObj); }
    void    Detach      (void)                  { _Detach(); }
};

#define CArray CPtrArray	// for compatibility

/////////////////////////////////////////////////////////////////////////////
// CStructArrayImpl -- implementation class for CStructArray

class CStructArrayImpl
{
private:
    enum { ALLOC_INCR = 8 };

    BYTE*   m_pData;
    int     m_iElemSize;
    int     m_iCount;
    int     m_iAlloc;

    // CStructArrayImpl cannot be copied!
    CStructArrayImpl(const CStructArrayImpl&) {}
    CStructArrayImpl& operator=(const CStructArrayImpl&) { return *this; }

protected:
    void *  _GetElem        (int i)     { return m_pData + (i * m_iElemSize); }
    void *  _GetAt          (int i);
    void    _SetAt          (int i, void * pData);
    BOOL    _Add            (void * pData);
    BOOL    _Remove         (void * pData);
    BOOL    _InsertAt       (int i, void * pData);
    BOOL    _ReallocData    (int iAlloc);
    void    _Attach         (int cel, void * pData);
    void    _Detach         (void) { m_pData = 0; m_iCount = m_iAlloc = 0; }

public:
    CStructArrayImpl(int iElemSize, int iAlloc = 0);
    ~CStructArrayImpl();

    BOOL    RemoveAt    (int i);
    void    RemoveAll   (void)      { m_iCount = 0; }
    void    SetTop      (int i)     { m_iCount = i; }
    int     Count       (void)      { return m_iCount; }
};

inline CStructArrayImpl::CStructArrayImpl(int iElemSize, int iAlloc) :
	m_pData(NULL),
	m_iElemSize(iElemSize),
	m_iCount(0),
	m_iAlloc(0)
{
	_ReallocData(iAlloc);
}

/////////////////////////////////////////////////////////////////////////////
// CStructArray -- simple array of structs

template <class T>
class CStructArray : public CStructArrayImpl
{
public:
	CStructArray(int iAlloc = 0) : CStructArrayImpl(sizeof(T), iAlloc) {}
	~CStructArray()						{ RemoveAll(); }

	T*		GetAt       (int i)				{ return (T*)_GetAt(i); }
	void	SetAt       (int i, T* pStruct) { _SetAt(i, pStruct); }
	BOOL	Add         (T* pStruct)		{ return _Add(pStruct); }
	BOOL	Remove      (T* pStruct)		{ return _Remove(pStruct); }
	BOOL	InsertAt    (int i, T* pStruct)	{ return _InsertAt(i, pStruct); }
    void    Attach      (int cel, T* pData) { _Attach(cel, pData); }  // pData must be allocated with VSAlloc!
    void    Detach      (void)              { _Detach(); } 
};


//////////////////////////////////////////////////////////////////
// C*ArrayBuilder
// 
// Use an array builder when the array usage follows a two-phase pattern
// of building the array, then using the built array with few or no additions
// or deletions. The array builder can be much more efficient that a C*Array 
// when the total number of elements is unknown or can grow large.
// 
// After building your array with the array builder, get the final contiguous 
// memory buffer with Gimme. After calling Gimme, the builder is empty and the
// caller owns the buffer.
//
// You can attach the buffer to a C*Array to subsequently use it as an array.
// 

class CABBlock; // private array builder block class

// array builder implementation class
class CByteArrayBuilder
{
public:
    CByteArrayBuilder   (int cbBlock);
    ~CByteArrayBuilder  () { Clear(); }

    HRESULT     Add     (int cb, BYTE * pb);
    HRESULT     Gimme   (int * pcb, BYTE **ppData);
    void        Clear   (void);

    void        StreamInto  (BYTE * pb);    // Copy of added data. pb assumed to be large enough
    int         Size        (void);

private:
    CABBlock *  m_pLast;
    CABBlock *  m_pFirst;
    int         m_cbBlock;

    CByteArrayBuilder (); // NOT IMPLEMENTED - DO NOT USE
    // can't copy
    CByteArrayBuilder(const CByteArrayBuilder&) {}
    CByteArrayBuilder& operator=(const CByteArrayBuilder&) { return *this; }
};

inline CByteArrayBuilder::CByteArrayBuilder (int cbBlock) :
    m_pLast     (NULL),
    m_pFirst    (NULL),
    m_cbBlock   (cbBlock)
{
}

//////////////////////////////////////////////////////////////////
// CStructArrayBuilder
//
// Construct with the number of elements per block.
//
// When finished adding elements, call Gimme to obtain a contiguous
// array of elements. After Gimme, the builder is empty and the caller 
// owns the memory.
//
template <class T> 
class CStructArrayBuilder : public CByteArrayBuilder
{
public:
    CStructArrayBuilder (int celPerBlock) :
        CByteArrayBuilder (celPerBlock*sizeof(T))
    {
    }
    HRESULT Add     (T * pT)              { return CByteArrayBuilder::Add (    sizeof(T), reinterpret_cast<BYTE*>(pT)); }
    HRESULT Add     (int cel, T * pT)     { return CByteArrayBuilder::Add (cel*sizeof(T), reinterpret_cast<BYTE*>(pT)); }
    HRESULT Gimme   (int * pcel, T ** ppT)
    {
        if (!pcel || !ppT) return E_POINTER;
        int     cel = 0;
        HRESULT hr  = CByteArrayBuilder::Gimme (&cel, reinterpret_cast<BYTE**>(ppT));
        *pcel = (int)(cel ? cel/sizeof(T) : 0);
        return hr;
    }
};

//////////////////////////////////////////////////////////////////
// CPtrArrayBuilder
//
// Construct with the number of pointers per block.
//
// When finished adding elements, call Gimme to obtain a contiguous
// array of elements. After Gimme, the builder is empty and the caller 
// owns the memory.
//

class CPABBlock; // private array builder block class

void __stdcall VSDestroyElement  (void *pv); // destroys an element with VSFree
void __stdcall SysDestroyElement (BSTR bstr);// destroys an element with SysFreeString

class CPtrArrayBuilderImpl
{
public:
    CPtrArrayBuilderImpl   (int BlockSize) :
        m_pLast     (NULL),
        m_pFirst    (NULL),
        m_BlockSize (BlockSize)
    {
    }
    ~CPtrArrayBuilderImpl  () 
    { 
        Clear(); 
    }

    HRESULT     Add             (int cel, void ** ppv);
    HRESULT     Add             (void * pv);
    void **     Gimme           (int * pcel);

    void        StreamInto      (void ** ppv);  // Copy of added data. ppv assumed to be large enough
    int         Size            (void);         // elements, NOT bytes!
    void        Clear           (void);
    void        FreeElements    (void) { DestroyElements(VSDestroyElement); }
    void        DestroyElements (void (__stdcall *pfnDestroy)(void *));

private:
    CPABBlock * m_pLast;
    CPABBlock * m_pFirst;
    int         m_BlockSize;

    CPtrArrayBuilderImpl (); // NOT IMPLEMENTED - DO NOT USE
    // can't copy
    CPtrArrayBuilderImpl(const CPtrArrayBuilderImpl&) {}
    CPtrArrayBuilderImpl& operator=(const CPtrArrayBuilderImpl&) { return *this; }
};

template <class T>
class CPtrArrayBuilder : public CPtrArrayBuilderImpl
{
public:
    CPtrArrayBuilder (int celBlock) : CPtrArrayBuilderImpl(celBlock) {}
    HRESULT     Add     (int cel, T** ppT)       { return CPtrArrayBuilderImpl::Add(cel, ppT); }
    HRESULT     Add     (T * pT)                 { return CPtrArrayBuilderImpl::Add(pT); }
    T**         Gimme   (int * pcel) { return (T**)CPtrArrayBuilderImpl::Gimme(pcel); }
    void        DestroyElements (void (__stdcall *pfnDestroy)(T *))
    {
        CPtrArrayBuilderImpl::DestroyElements((void (__stdcall *)(void *))pfnDestroy);
    }
};

//////////////////////////////////////////////////////////////////
// Set*ArrayFromBuilder - transfers data from a C*ArrayBuilder to a C*Array
//
template <class T>
inline BOOL SetStructArrayFromBuilder (CStructArray<T> & Array, CStructArrayBuilder<T> & Builder)
{
    int cel;
    T * pT;

    if (SUCCEEDED(Builder.Gimme(&cel, &pT)))
        return Array.Attach(cel, pT);
    else
        return FALSE;
}

template <class T>
inline BOOL SetPtrArrayFromBuilder (CPtrArray<T> & Array, CPtrArrayBuilder<T> & Builder)
{
    int cel;
    T ** prgT;

    if (SUCCEEDED(Builder.Gimme(&cel, &prgT)))
        return Array.Attach(cel, prgT);
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsclsid.h ===
#ifdef USE_VSCLSID_FOR_CLSIDS
// don't forget to change src\Env\misc\pkgs\solution\sources

//
// This file lists CLSIDs that change between builds
// Don't use slash-star comments anywhere in this file.
//



//
// Replacement for DEFINE_GUID that works with our generated guids
//

#if defined (INITGUID) || defined (INITGUIDS)
#undef VSDEFINE_GUID
#define VSDEFINE_GUID(name, val) EXTERN_C const GUID name  = { val }
#else
#define VSDEFINE_GUID(name, val)  EXTERN_C const GUID FAR name
#endif // INITGUID


#ifdef DEBUG 


// idl format
#define VSCLSID_SDMServer						/*idl*/81b6566a-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_MsMachineDebugManager 			/*idl*/81b6566b-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_EncMgr							/*idl*/81b6566c-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_WFCComponentManager				/*idl*/81b6566d-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_WFCValueEditor					/*idl*/81b6566e-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsUserData						/*idl*/81b6566f-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsCodeWindow					/*idl*/81b65670-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsSplitRoot						/*idl*/81b65671-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsDropdownBar					/*idl*/81b65672-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsTextBuffer					/*idl*/81b65673-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsTextLineStorage				/*idl*/81b65674-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsDebugTextBuffer				/*idl*/81b65675-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsTextManager					/*idl*/81b65676-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsTextView						/*idl*/81b65677-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsTextPackage					/*idl*/81b65678-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsUndoUnit						/*idl*/81b65679-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsMethodTipWindow				/*idl*/81b6567a-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsHiddenTextLayer				/*idl*/81b6567b-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_JavaPkgService					/*idl*/81b6567c-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsContextClass                  /*idl*/81b6567d-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_MDMCallbackServer               /*idl*/81b6567e-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_LECallbackServer                /*idl*/81b6567f-cdd8-11d2-992e-00c04f68fdaf
#define VSIID_IVsBuildStatusCallback            /*idl*/81b65680-cdd8-11d2-992e-00c04f68fdaf
#define VSIID_IPrivateSession                   /*idl*/81b65681-cdd8-11d2-992e-00c04f68fdaf
#define VSIID_IPrivateMachine                   /*idl*/81b65682-cdd8-11d2-992e-00c04f68fdaf
#define VSIID_ILECallback                       /*idl*/81b65683-cdd8-11d2-992e-00c04f68fdaf
#define VSIID_IMDMCallback                      /*idl*/81b65684-cdd8-11d2-992e-00c04f68fdaf




// DEFINE_GUID format			
#define VSCLSID_DBGProxy 						/*C*/0x81b65685, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_Debugger 						/*C*/0x81b65686, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_JavaExprEvaluator				/*C*/0x81b65687, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_JavaExpressionContext			/*C*/0x81b65688, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_JavaProperties					/*C*/0x81b65689, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_JavaExprEvaluatorVS7			/*C*/0x81b6568a, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_JavaLEDebugManager				/*C*/0x81b6568b, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSguidJavaEng							/*C*/0x81b6568c, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSguidScriptEng							/*C*/0x81b6568d, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSguidNativeEng							/*C*/0x81b6568e, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSguidSQLEng							/*C*/0x81b6568f, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSguidCOMPlusEng						/*C*/0x81b65690, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSguidNativeOnlyEng						/*C*/0x81b65691, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_NativeDebugEngine				/*C*/0x81b65692, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_SqlDebugEngine					/*C*/0x81b65693, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_COMPlusDebugEngine				/*C*/0x81b65694, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_MSDbgProxy						/*C*/0x81b65695, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_MSENV							/*c*/0x81b65696, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_VSDebugPackage					/*c*/0x81b65697, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_VsEnvironmentPackage            /*c*/0x81b65698, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_FreeThreadedNativeEngine        /*c*/0x81b65699, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_NativeMachineSupplier           /*c*/0x81b6569a, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_FreeThreadedNativeOnlyEngine    /*c*/0x81b6569b, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_VsSolutionBuilderProxy          /*c*/0x81b6569c, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_VS_SOLUTION_PACKAGE             /*c*/0x81b6569d, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}

#else // DEBUG

// idl format
#define VSCLSID_SDMServer						/*idl*/81b6569e-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_MsMachineDebugManager 			/*idl*/81b6569f-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_EncMgr							/*idl*/81b656a0-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VSDebugPackage					/*idl*/81b656a1-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_WFCComponentManager				/*idl*/81b656a2-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_WFCValueEditor					/*idl*/81b656a3-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsUserData						/*idl*/81b656a4-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsCodeWindow					/*idl*/81b656a5-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsSplitRoot						/*idl*/81b656a6-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsDropdownBar					/*idl*/81b656a7-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsTextBuffer					/*idl*/81b656a8-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsTextLineStorage				/*idl*/81b656a9-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsDebugTextBuffer				/*idl*/81b656aa-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsTextManager					/*idl*/81b656ab-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsTextView						/*idl*/81b656ac-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsTextPackage					/*idl*/81b656ad-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsUndoUnit						/*idl*/81b656ae-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsMethodTipWindow				/*idl*/81b656af-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsHiddenTextLayer				/*idl*/81b656b0-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_JavaPkgService					/*idl*/81b656b1-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_VsContextClass                  /*idl*/81b656b2-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_MDMCallbackServer               /*idl*/81b656b3-cdd8-11d2-992e-00c04f68fdaf
#define VSCLSID_LECallbackServer                /*idl*/81b656b4-cdd8-11d2-992e-00c04f68fdaf
#define VSIID_IVsBuildStatusCallback            /*idl*/81b656b5-cdd8-11d2-992e-00c04f68fdaf
#define VSIID_IPrivateSession                   /*idl*/81b656b6-cdd8-11d2-992e-00c04f68fdaf
#define VSIID_ILECallback                       /*idl*/81b656b7-cdd8-11d2-992e-00c04f68fdaf
#define VSIID_IMDMCallback                      /*idl*/81b656b8-cdd8-11d2-992e-00c04f68fdaf


// DEFINE_GUID format			
#define VSCLSID_DBGProxy 						/*C*/0x81b656b9, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_Debugger 						/*C*/0x81b656ba, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_JavaExprEvaluator				/*C*/0x81b656bb, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_JavaExpressionContext			/*C*/0x81b656bc, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_JavaProperties					/*C*/0x81b656bd, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_JavaExprEvaluatorVS7			/*C*/0x81b656be, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_JavaLEDebugManager				/*C*/0x81b656bf, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSguidJavaEng							/*C*/0x81b656c0, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSguidScriptEng							/*C*/0x81b656c1, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSguidNativeEng							/*C*/0x81b656c2, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSguidSQLEng							/*C*/0x81b656c3, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSguidCOMPlusEng						/*C*/0x81b656c4, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSguidNativeOnlyEng						/*C*/0x81b656c5, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_NativeDebugEngine				/*C*/0x81b656c6, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_SqlDebugEngine					/*C*/0x81b656c7, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_COMPlusDebugEngine				/*C*/0x81b656c8, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_MSDbgProxy						/*C*/0x81b656c9, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_MSENV							/*c*/0x81b656ca, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_VSDebugPackage					/*c*/0x81b656cb, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_VsEnvironmentPackage            /*c*/0x81b656cc, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_FreeThreadedNativeEngine        /*c*/0x81b656cd, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_NativeMachineSupplier           /*c*/0x81b656ce, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_FreeThreadedNativeOnlyEngine    /*c*/0x81b656cf, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_VsSolutionBuilderProxy          /*c*/0x81b656d0, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}
#define VSCLSID_VS_SOLUTION_PACKAGE             /*c*/0x81b656d1, 0xcdd8, 0x11d2,  {0x99, 0x2e, 0x0, 0xc0, 0x4f, 0x68, 0xfd, 0xaf}

#endif // DEBUG



#endif // USE_VSCLSID_FOR_CLSIDS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\VsCoCreate.h ===
#pragma once


#ifdef __cplusplus

template <class Interface>
HRESULT
VsLoaderCoCreateInstance(
    REFCLSID rclsid, 
    LPUNKNOWN pUnkOuter,
    DWORD dwClsContext, 
    REFIID riid, 
    Interface** ppInterface
    )
{

    HRESULT hr = NOERROR;
    IUnknown* punk = NULL;

    if (FAILED (hr = VsLoaderCoCreateInstanceUnknown(
        rclsid, 
        pUnkOuter,
        dwClsContext, 
        &punk
        )))
    {
        goto Error;
    }

    if (FAILED (hr = punk->QueryInterface (riid, (LPVOID*)ppInterface)))
    {
        goto Error;
    }

Error:

    if (punk)
    {
	    punk->Release();
    }

    return hr;
}

//
// To match ATL::CComPtr<T>::CoCreateInstance
//

template <class Interface>
HRESULT
VsLoaderCoCreateInstance(
    REFCLSID rclsid,
    Interface** ppInterface,
    LPUNKNOWN pUnkOuter = NULL, 
    DWORD dwClsContext = CLSCTX_ALL
    )
{
#ifdef DEBUG
    //
    // Make sure ppInterface is an IUnknown
    //
    static_cast <IUnknown*> (*ppInterface);
#endif

    return VsLoaderCoCreateInstance<Interface> (
        rclsid, 
        pUnkOuter, 
        dwClsContext, 
        __uuidof (Interface), 
        ppInterface
        );
}

//
// To use on an ATL::CComPtr<T>
//
template <class Interface>
HRESULT
VsLoaderCoCreateInstance(
    REFCLSID rclsid,
    CComPtr<Interface>** ppInterface,
    LPUNKNOWN pUnkOuter = NULL, 
    DWORD dwClsContext = CLSCTX_ALL
    )
{
    return VsLoaderCoCreateInstance<Interface> (
        rclsid,
        pUnkOuter,
        dwClsContext,
        __uuidof (Interface),
        &((*ppInterface)->p)
        );
}

#endif // _cplusplus

#ifdef __cplusplus
#define VSCOCO_CLINKAGE	extern "C"
#else
#define VSCOCO_CLINKAGE
#endif

//
// Always returns an IUnknown*
//
VSCOCO_CLINKAGE HRESULT
_cdecl
VsLoaderCoCreateInstanceUnknown(
    REFCLSID rclsid, 
    LPUNKNOWN pUnkOuter,
    DWORD dwClsContext, 
    IUnknown** ppunk
    );

VSCOCO_CLINKAGE void
_cdecl
VsLoaderSetRegistryRootA(
    LPCSTR sz
    );

VSCOCO_CLINKAGE void
_cdecl
VsLoaderSetRegistryRootW(
    LPCWSTR sz
    );

#ifdef _UNICODE
#define VsLoaderSetRegistryRoot VsLoaderSetRegistryRootW
#else // UNICODE
#define VsLoaderSetRegistryRoot VsLoaderSetRegistryRootA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\VsConsoleDef.h ===
#pragma once

#define VS_CONSOLE_OUTPUT_ENV_VAR "vsconsoleoutput"
#define VS_CONSOLE_STOP_PIPING     1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsmem.h ===
//---------------------------------------------------------------------------
// Microsoft Visual Studio
//
// Microsoft Confidential
// Copyright (C) 1994 - 2000 Microsoft Corporation. 
// All Rights Reserved.
//
// VsMem.H
//
// Common memory allocation routines
//---------------------------------------------------------------------------
#ifndef _INC_VSMEM_H
#define _INC_VSMEM_H

PVOID WINAPI VSRetAlloc (SIZE_T cb);
PVOID WINAPI VSRetAllocZero (SIZE_T cb);
PVOID WINAPI VSRetRealloc (PVOID pv, SIZE_T cb);
PVOID WINAPI VSRetReallocZero (PVOID pv, SIZE_T cb);
BOOL  WINAPI VSRetFree (PVOID pv);
SIZE_T WINAPI VSRetSize (PVOID pv);

#if DEBUG

//=----------------------------------------------------------------------=
// Debug allocation routines.

#include "vsassert.h"

// We don't want people to be using non-debug allocators.  So, we generate
// compile errors when they do
//
#define calloc(num, size)       0; VSCASSERT(0, Should_be_using_debug_allocators)
#define malloc(a)               0; VSCASSERT(0, Should_be_using_debug_allocators)
#define realloc(a, b)           0; VSCASSERT(0, Should_be_using_debug_allocators)
#define free(a)                    VSCASSERT(0, Should_be_using_debug_allocators)
#define HeapAlloc(h, f, b)      0; VSCASSERT(0, Should_be_using_debug_allocators)
#define HeapReAlloc(h, f, m, b) 0; VSCASSERT(0, Should_be_using_debug_allocators)
#define HeapFree(h, f, m)          VSCASSERT(0, Should_be_using_debug_allocators)

#define VSAlloc(cb)           VsDebAlloc(0, cb)
#define VSAllocZero(cb)       VsDebAlloc(HEAP_ZERO_MEMORY, cb)
#define VSRealloc(pv, cb)     VsDebRealloc(pv, 0, cb)
#define VSReallocZero(pv, cb) VsDebRealloc(pv, HEAP_ZERO_MEMORY, cb)
#define VSFree(pv)            VsDebFree(pv)
#define VSSize(pv)            VsDebSize(pv)

#define VSHeapCreate(flags, name)       VsDebHeapCreate(flags, name)
#define VSHeapDestroy(heap, fLeakCheck) VsDebHeapDestroy(heap, fLeakCheck)
#define VSHeapAlloc(heap, cb)           VsDebHeapAlloc(heap, 0, cb)
#define VSHeapAllocZero(heap, cb)       VsDebHeapAlloc(heap, HEAP_ZERO_MEMORY, cb)
#define VSHeapRealloc(heap, pv, cb)     VsDebHeapRealloc(heap, pv, 0, cb)
#define VSHeapReallocZero(heap, pv, cb) VsDebHeapRealloc(heap, pv, HEAP_ZERO_MEMORY, cb)
#define VSHeapFree(heap, pv)            VsDebHeapFree(heap, pv)
#define VSHeapSize(heap, pv)            VsDebHeapSize(heap, pv)

#define VSOleAlloc(cb)        VsDebOleAlloc(cb)
#define VSOleFree(pv)         VsDebOleFree(pv)
#define VSOleRealloc(pv, cb)  VsDebOleRealloc(pv, cb)

#define CoTaskMemAlloc(cb)        VsDebOleAlloc(cb)
#define CoTaskMemRealloc(pv, cb)  VsDebOleRealloc(pv, cb)
#define CoTaskMemFree(pv)         VsDebOleFree(pv)

#define SysAllocString(str)             VsDebSysAllocString((str))
#define SysAllocStringByteLen(str, cb)  VsDebSysAllocStringByteLen((str), (cb))
#define SysAllocStringLen(str, cch)     VsDebSysAllocStringLen((str), (cch))

// Wrappers for ComDlg functions...
#define GetOpenFileNameA	VsGetOpenFileNameA
#define GetSaveFileNameA	VsGetSaveFileNameA
#define GetFileTitleA		VsFileTitleA
#define ChooseColorA		VsChooseColorA
#define FindTextA		VsFindTextA
#define ReplaceTextA		VsReplaceTextA
#define ChooseFontA		VsChooseFontA
#define PrintDlgA		VsPrintDlgA
#define CommDlgExtendedError	VsCommDlgExtendedError
#define PageSetupDlgA		VsPageSetupDlgA

// Wrapper for CoCreateInstance (but if already defined to VBCoCreateInstance, don't.
// since VBCoCreateInstance does some useful but shell specific error checking)
#ifndef CoCreateInstance
#define CoCreateInstance	VsCoCreateInstance
#endif //ifndef CoCreateInstance

// We redefine new and delete to use the debug allocators, and make a 'new'
// macro to call the debug operator.  The standard runtime prototype for
// new is overloaded as well in vsmem.cpp just in case...
//
#undef new
void * _cdecl operator new(size_t size, LPSTR pszFile, UINT uLine);
#if _MSC_VER > 1200
void * _cdecl operator new[](size_t size, LPSTR pszFile, UINT uLine);
#endif
#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new( size_t, void *_P) {return (_P); }
#if _MSC_VER > 1200
inline void *__cdecl operator new[]( size_t, void *_P) {return (_P); }
#endif
#endif

/*
    Want to define your own new operator for your class, without losing position
    info in leak detection?  Here's how:

    In your class header file:

            #undef new

            class CMyClassWithOverloadedNew
            {
            public:
                DECLARE_CLASS_NEW(iSize) { MyOwnAllocator.Allocate (iSize); }   // OR:
                DECLARE_CLASS_NEW(iSize);                                       // If not inlined (see below)
            };

            #define new vs_new

    In your implementation file:

            #undef new
            DEFINE_CLASS_NEW (CMyClassWithOverloadedNew, iSize)
            {
                DEBUGOUT ("%s(%d) : %d bytes allocated", pszFile, uLine);   // NOTE:  pszFile and uLine are only available ifdef _DEBUG!
                MyAllocator.Allocate (iSize);
            }
            #define new vs_new

    By doing this, you can define/declare operator new and get 'new' #define'd back to
    the appropriate thing so other uses of new get tracked by vsmem appropriately.  (Your
    allocation scheme will not be tracked by vsmem, of course.)

    Note that if your new overload takes its own parameters, you must undef new and
    leave it undefined.  You can then use 'vs_new' to new objects other than your
    class to get them tracked appropriately (otherwise, if they leak, vsmem.cpp(25) will
    be the offending line).

*/

#define DECLARE_CLASS_NEW(sizevar) void * _cdecl operator new (size_t sizevar, LPSTR pszFile, UINT uLine)
#define DEFINE_CLASS_NEW(c,sizevar) void * _cdecl c::operator new (size_t sizevar, LPSTR pszFile, UINT uLine)

#define vs_new new(__FILE__, __LINE__)
#define new vs_new

#else

//=----------------------------------------------------------------------=
// Retail allocation routines
//

#define VSAlloc(cb)       VSRetAlloc(cb)
#define VSAllocZero(cb)   VSRetAllocZero(cb)
#define VSRealloc(pv, cb) VSRetRealloc(pv, cb)
#define VSReallocZero(pv, cb) VSRetReallocZero(pv, cb)
#define VSFree(pv)        VSRetFree(pv)
#define VSSize(pv)        VSRetSize(pv)

#define VSHeapCreate(flags, name)       HeapCreate(flags, 0, 0)
#define VSHeapDestroy(heap, fLeakCheck) HeapDestroy(heap)
#define VSHeapAlloc(heap, cb)           HeapAlloc(heap, 0, cb)
#define VSHeapAllocZero(heap, cb)       HeapAlloc(heap, HEAP_ZERO_MEMORY, cb)
#define VSHeapRealloc(heap, pv, cb)     HeapReAlloc(heap, 0, pv, cb)
#define VSHeapReallocZero(heap, pv, cb) HeapReAlloc(heap, HEAP_ZERO_MEMORY, pv, cb)
#define VSHeapFree(heap, pv)            HeapFree(heap, 0, pv)
#define VSHeapSize(heap, pv)            HeapSize(heap, 0, pv)

#define VSOleAlloc(cb)        CoTaskMemAlloc(cb)
#define VSOleFree(pv)         CoTaskMemFree(pv)
#define VSOleRealloc(pv, cb)  CoTaskMemRealloc(pv, cb)

#define vs_new new
#define DECLARE_CLASS_NEW(sizevar) void * _cdecl operator new (size_t sizevar)
#define DEFINE_CLASS_NEW(c,sizevar) void * _cdecl c::operator new (size_t sizevar)

#endif // DEBUG

#endif // _INC_VSMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsmematl.h ===
//---------------------------------------------------------------------------
// Microsoft Visual Studio
//
// Microsoft Confidential
// Copyright (C) 1994 - 2000 Microsoft Corporation. 
// All Rights Reserved.
//
// VsMemAtl.H
//
// Redefining SysAlloc* and   CoTaskMemAlloc* to a debug functions to trace 
// memory leask in code using ATL
//---------------------------------------------------------------------------
#pragma once

#if DEBUG

//=----------------------------------------------------------------------=
// Debug allocation routines.

#include "vsassert.h"

#define CoTaskMemAlloc(cb)        VsDebOleAlloc(cb)
#define CoTaskMemRealloc(pv, cb)  VsDebOleRealloc(pv, cb)
#define CoTaskMemFree(pv)         VsDebOleFree(pv)

#define SysAllocString(str)             VsDebSysAllocString((str))
#define SysAllocStringByteLen(str, cb)  VsDebSysAllocStringByteLen((str), (cb))
#define SysAllocStringLen(str, cch)     VsDebSysAllocStringLen((str), (cch))

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\VsAssert.h ===
//=--------------------------------------------------------------------------=
// VsAssert.H
//=--------------------------------------------------------------------------=
// Headers for common assert macros and debugging functionality
//=--------------------------------------------------------------------------=
// Copyright (c) 1997, Microsoft Corporation
//			All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//=--------------------------------------------------------------------------=

/*
Throwing assertion support added.

Traditional code often does this
	VSASSERT(p!=NULL, "p was NULL");
	if(!p)
	{
		return E_FAIL;
	}
or something similar. 

Unfortunately, developers often forget to do the checking after an assertion. 
Additionally, the calling function is often not well prepared for this error return.

Exception-safe code has a better choice here. It's already ready to receive an exception
at any time. So we can use that in retail to avoid crashes in these kind of bad-internal
state situations.

The basic pattern here is that exception-safe code can do:

	VsVerifyThrow(p!=NULL, "p was NULL"	);

In debug, this is just a regular assertion. In retail, the code will throw an 
exception, avoiding the crash when p would have been dereferenced, and simplifying
the code because there's no need for the if clause shown above.

Different code bases use different kinds of exceptions, so vsassert is agnostic about
which kind of exception is being used. Its function looks like this

CLINKAGE BOOL ENTRYPOINT 
VsAssertAndThrow
(
	LPCSTR pszMsg, 
	LPCSTR pszAssert, 
	LPCSTR pszFile, 
	UINT line, 
	BOOL *pfThrow,				// Set to true if the use pressed the 'throw' button
	BOOL *pfDisableAssert,		// True if the user asked to disable this assert for ever
	BOOL *pfAlwaysThrow			// True if the user asked to throw this assert for ever
);

pfThrow will be true if the user wants to throw; the calling macro can then throw the
right kind of exception inline.

if pfAlwaysThrow is true, pfDisableAssert must be true too.


*/

#ifndef _INC_VSASSERT_H
#define _INC_VSASSERT_H

#include "windows.h"
#include "ole2.h"
#include "commdlg.h"

#define	ENTRYPOINT  __declspec(dllexport) __stdcall
#ifdef __cplusplus
#define CLINKAGE	extern "C"
#else
#define CLINKAGE
#endif

//=--------------------------------------------------------------------------=
// Turn off compiler warnings which are exacerbated by constructs in this
// file's definitions:

// Warning C4127: conditional expression is constant.  This is caused by all
//		of the macros with "do { ... } while (false)" syntax.  The syntax is
//		a good way to ensure that a statement-like macro can be used in all
//		contexts (specifically if statements), but the compiler warns about
//		the "while (false)" part. 

#pragma warning(disable: 4127)

//=--------------------------------------------------------------------------=
// Debugging constants.  These flags are used to route debug messages to
// the appropriate places
//
#define DF_ENABLED	      0x01    // This option is enabled
#define DF_OUTPUTDEBUGSTRING  0x02    // Use OutputDebugString
#define DF_OUTPUTDEBUGWINDOW  0x04    // Send to the host's immediate window
#define DF_OUTPUTFILE	      0x08    // Output to a file
#define DF_OUTPUTDIALOG	      0x10    // Use the assert dialog

//=--------------------------------------------------------------------------=
// If you want to route debug messages to an immediate/debug window of the
// hosting app, use this function to setup a callback with the same
// signature as below.  To revoke it, just call the fn again with a NULL
// parameter.
//
#ifdef DEBUG
typedef void (WINAPI *IMMEDIATECALLBACK)(LPCSTR pszMessage);
CLINKAGE BOOL ENTRYPOINT VsSetImmediateCallback(IMMEDIATECALLBACK pImmediateCallback);

//=--------------------------------------------------------------------------=
// Initialization / termination for debugging.  Yes, you can assert before
// and after these calls.  This just enables the fancy stuff.  Only the host
// EXE should call these.
//
CLINKAGE VOID ENTRYPOINT VsDebugInitialize();
CLINKAGE VOID ENTRYPOINT VsDebugTerminate();

//=--------------------------------------------------------------------------=
// Function prototypes.  You should use the macros below to keep debug/retail
// differences transparent.
//
CLINKAGE BOOL ENTRYPOINT VsAssert(LPCSTR pszMsg, LPCSTR pszAssert, LPCSTR pszFile, UINT line, BOOL *pfDisableAssert);
         BOOL ENTRYPOINT VsAssert(LPCWSTR pszMsg, LPCSTR pszAssert, LPCSTR pszFile, UINT line, BOOL *pfDisableAssert);
CLINKAGE BOOL ENTRYPOINT VsAssertAndThrow(LPCSTR pszMsg, LPCSTR pszAssert, LPCSTR pszFile, UINT line, BOOL *pfThrow, BOOL *pfDisableAssert, BOOL *pfAlwaysThrow);
         BOOL ENTRYPOINT VsAssertAndThrow(LPCWSTR pszMsg, LPCSTR pszAssert, LPCSTR pszFile, UINT line, BOOL *pfThrow, BOOL *pfDisableAssert, BOOL *pfAlwaysThrow);
CLINKAGE BOOL ENTRYPOINT VsDisplayDebugMessage(LPCSTR pszMsg, LPCSTR pszAssert, LPCSTR pszFile, UINT line, int flags, BOOL *pfDisableAssert, ...);
CLINKAGE BOOL ENTRYPOINT VsDisplayDebugMessageThrow(LPCSTR pszMsg, LPCSTR pszAssert, LPCSTR pszFile, UINT line, int flags, BOOL *pfThrow, BOOL *pfDisableAssert, BOOL *pfAlwaysThrow, ...);
CLINKAGE BOOL ENTRYPOINT VsDisplayDebugMessageThrowVa(LPCSTR pszMsg, LPCSTR pszAssert, LPCSTR pszFile, UINT line, int flags, BOOL *pfThrow, BOOL *pfDisableAssert, BOOL *pfAlwaysThrow, va_list pArgs);
CLINKAGE VOID ENTRYPOINT VsDebugOutput(int dfOutput, LPCSTR pszOutputString, BOOL *pfDoInt3, BOOL *pfDisableAssert);
CLINKAGE VOID ENTRYPOINT VsDebugOutputThrow(int dfOutput, LPCSTR pszOutputString, BOOL *pfDoInt3, BOOL *pfThrow, BOOL *pfDisableAssert, BOOL *pfAlwaysThrow);
CLINKAGE VOID ENTRYPOINT VsDebugPrintf(LPCSTR pszMsg, ...);
CLINKAGE VOID ENTRYPOINT VsDebugPrintIf(BOOL fPrint, LPCSTR pszMsg, ...);
CLINKAGE VOID ENTRYPOINT VsEnableAsserts (BOOL fEnable);
CLINKAGE VOID ENTRYPOINT VsPrintCallstack(int nLines);
CLINKAGE BOOL ENTRYPOINT VsEnsureDebuggerPresent();

#ifdef _X86_
#define Int3 _asm { int 3 }
#else
#define Int3 DebugBreak();
#endif // _X86_
#define VsDebugBreak() do { if (VsEnsureDebuggerPresent()) {Int3; } } while(0)

//=--------------------------------------------------------------------------=
// Debugging macros
//
static bool g_fStopOnVsAssert = false;

#define VSASSERT(fTest, szMsg)                                      \
  do {                                                              \
    static BOOL fDisableThisAssert = FALSE;                         \
    if (!(fTest) && !fDisableThisAssert)                            \
      {                                                             \
      if(g_fStopOnVsAssert ||                                       \
        VsAssert(szMsg, #fTest, __FILE__, __LINE__, &fDisableThisAssert))\
        VsDebugBreak();                                             \
      }                                                             \
  } while (false)								    \

#define VSVERIFY(fTest, szMsg) VSASSERT((fTest), (szMsg))

#define VSVERIFYTHROW(fTest, szMsg, exception) VSVERIFYFUNC(fTest, szMsg, throw exception)

#define VSVERIFYFUNC(fTest, szMsg, function)                        \
  do                                                                \
    {                                                               \
    static BOOL fDisableThisAssert = FALSE;                         \
    static BOOL fThrowThisAssert = TRUE;                            \
    if (!(fTest))                                                   \
      {                                                             \
      BOOL fThrow=true;                                             \
      if(!fDisableThisAssert)                                       \
        {                                                           \
        if(g_fStopOnVsAssert ||                                     \
          VsAssertAndThrow( szMsg,                                  \
                            #fTest,                                 \
                            __FILE__,                               \
                            __LINE__,                               \
                            &fThrow,                                \
                            &fDisableThisAssert,                    \
                            &fThrowThisAssert))                     \
          {                                                         \
          VsDebugBreak();                                           \
          }                                                         \
        }                                                           \
      else                                                          \
        {                                                           \
          fThrow=fThrowThisAssert;                                  \
        }                                                           \
      if(fThrow)                                                    \
        {                                                           \
          function;                                                 \
        }                                                           \
      }                                                             \
    }                                                               \
  while (false)                                                     \

#define VSFAIL(szMsg) VSASSERT(0, szMsg)
#define VSIMPLIES(fHypothesis, fConclusion, szMsg) VSASSERT(!(fHypothesis) || (fConclusion), szMsg)
#define VSDEBUGPRINTF  VsDebugPrintf
#define VSDEBUGPRINTIF VsDebugPrintIf
#define VSPRINTCALLSTACK(nLines) VsPrintCallstack(nLines)

// "CAssert".  This is a compile time assert that will fire if fTest is
// zero.  Here, "msg" must be a non-quoted single word string that can be
// used as an identifier.
//
#define VSCASSERT(fTest, msg)  { struct foo { int Compile_Assert_##msg:((fTest)!=0); }; }

#else // DEBUG

//=--------------------------------------------------------------------------=
// Retail no-op implementations of debugging macros
//
inline void __cdecl _DebugNop(...) {}

#define VSASSERT(fTest, szMsg) do {} while (0)
#define VSVERIFY(fTest, szMsg) (void)(fTest);

#define VSVERIFYTHROW(fTest, szMsg, exception) VSVERIFYFUNC(fTest, szMsg, throw exception)

// Note: It is deliberate that this exists in retail too.
#define VSVERIFYFUNC(fTest, szMsg, function)                        \
  do                                                                \
    {                                                               \
    if (!(fTest))                                                   \
      {                                                             \
        function;                                                   \
      }                                                             \
    }                                                               \
  while (false)                                                     \

#define VSFAIL(szMsg) do {} while (0)
#define VSIMPLIES(fHypothesis, fConclusion, szMsg) do {} while (0)
#define VSDEBUGPRINTF 1 ? (void)0 : _DebugNop
#define VSDEBUGPRINTIF VSDEBUGPRINTF
#define VSPRINTCALLSTACK(nLines)
#define VSCASSERT(fTest, msg)

#define VsSetImmediateCallback(pfn)
#define VsDebugInitialize()
#define VsDebugTerminate()

#endif // DEBUG

//=--------------------------------------------------------------------------=
// Debug heap memory support routines.  These support leak tracking on a per
// DLL basis.  For us to be robust, you should ALWAYS use these routines
// in your debug code, unless there is some really well thought-out
// compelling reason not to.
//

#if DEBUG

// This will get you the process heap
//
#define DEFAULT_HEAP (HANDLE)-1

// Debug allocators have the concept of an instance, which is a unique ID that
// is usually the instance handle of the DLL making the allocation.  This takes
// special support from the DLL, but gives you the benefit of being able to
// track DLL leaks as they exit your process.  You can also identify allocations
// that may occur in static constructors by presetting the instance to UNDEFINED,
// then updating the instances when the DLL's ProcessAttach gets called.
//
#define INSTANCE_GLOBAL    ((DWORD)0)
#define INSTANCE_UNDEFINED ((DWORD)-1)

// you should avoid calling these functions; use the macros defined below
//
CLINKAGE PVOID    ENTRYPOINT VsDebugAllocInternal           (HANDLE hheap, DWORD flags, SIZE_T cb, LPCSTR pszFile,  UINT  uLine, UINT_PTR dwInst, LPCSTR pszExtra);
CLINKAGE PVOID    ENTRYPOINT VsDebugReallocInternal         (HANDLE hheap, PVOID pv, DWORD flags, SIZE_T  cb, LPCSTR pszFile, UINT uLine, UINT_PTR dwInst, LPCSTR pszExtra);
CLINKAGE PVOID    ENTRYPOINT VsDebugSafeReallocInternal     (HANDLE hheap, PVOID pv, DWORD flags, SIZE_T  cb, LPCSTR pszFile, UINT uLine, UINT_PTR dwInst, LPCSTR pszExtra);
CLINKAGE VOID     ENTRYPOINT VsDebugFreeInternal            (HANDLE hheap, PVOID pv);
CLINKAGE SIZE_T   ENTRYPOINT VsDebugSizeInternal            (HANDLE hheap, PVOID pv);
CLINKAGE HANDLE   ENTRYPOINT VsDebugHeapCreateInternal      (DWORD flags, LPCSTR pszName, LPCSTR pszFile, UINT uLine);
CLINKAGE VOID     ENTRYPOINT VsDebugHeapDestroyInternal     (HANDLE hheap, BOOL fLeakCheck);

// debug wrappers for heap allocations.  You should call these to do all of your
// debug memory allocations.
//
#define VsDebAlloc(flags, cb)                 VsDebugAllocInternal(DEFAULT_HEAP, (flags), (cb), __FILE__, __LINE__, INSTANCE_GLOBAL, NULL)
#define VsDebRealloc(pv, flags, cb)           VsDebugReallocInternal(DEFAULT_HEAP, (pv), (flags), (cb), __FILE__, __LINE__, INSTANCE_GLOBAL, NULL)
#define VsDebSafeRealloc(pv, flags, cb)       VsDebugSafeReallocInternal(DEFAULT_HEAP, (pv), (flags), (cb), __FILE__, __LINE__, INSTANCE_GLOBAL, NULL)
#define VsDebFree(pv)                         VsDebugFreeInternal(DEFAULT_HEAP, (pv))
#define VsDebSize(pv)                         VsDebugSizeInternal(DEFAULT_HEAP, (pv))

#define VsDebHeapAlloc(heap, flags, cb)       VsDebugAllocInternal(heap, (flags), (cb), __FILE__, __LINE__, INSTANCE_GLOBAL, NULL)
#define VsDebHeapRealloc(heap, pv, flags, cb) VsDebugReallocInternal(heap, (pv), (flags), (cb), __FILE__, __LINE__, INSTANCE_GLOBAL, NULL)
#define VsDebHeapFree(heap, pv)               VsDebugFreeInternal(heap, (pv))
#define VsDebHeapSize(heap, pv)               VsDebugSizeInternal(heap, (pv))

#define VsDebHeapCreate(flags, name)          VsDebugHeapCreateInternal(flags, name, __FILE__, __LINE__)
#define VsDebHeapDestroy(heap, fLeakCheck)    VsDebugHeapDestroyInternal(heap, fLeakCheck)

// Heap diagnostic functions that you can freely call
//
CLINKAGE VOID     ENTRYPOINT VsDebValidateHeaps     ();
CLINKAGE BOOL     ENTRYPOINT VsDebIsValidHeap       (HANDLE hHeap);
CLINKAGE BOOL     ENTRYPOINT VsDebIsValidHeapPtr    (HANDLE hHeap, PVOID pv);
CLINKAGE VOID     ENTRYPOINT VsDebDumpMemStats      ();
CLINKAGE VOID     ENTRYPOINT VsDebCheckLeaks        (HANDLE hHeap, UINT_PTR dwInst = INSTANCE_GLOBAL);

// This allows you go get at the allocation blocks for a given heap.  Most
// people will never have to call these -- you can use them to mimic the CRT
// debug leak detection scheme.
//
// Note:  You should avoid performing allocations on a heap that you're
//        enumerating.
//
struct ALLOCATION
  {
  PVOID         m_pv;         //address of block
  SIZE_T        m_cb;         //size of allocation in BYTES
  ULONG         m_cAlloc;     //allocation pass count.  relative to all heaps
  LPCSTR        m_pszFile;    //source file where the allocation was made
  ULONG         m_uLine;      //source line number where the allocation was made
  UINT_PTR      m_dwInst;     //instance ID of this allocation
  LPCSTR        m_pszExtra;   //additional info macros may like to add (eg. class name)
  DWORD         m_dwTid;      //thread ID that caused this allocation
  BOOL          m_fIgnorable; //can we ignore this allocation?
  };

// Work around a more strict VC6 compiler. When this file is included in components
// other than vsassert, these should be dllimport anyway. Also, the __declspec(dll*)
// should come *before* the return type.
typedef ALLOCATION* PALLOCATION;

CLINKAGE PALLOCATION ENTRYPOINT VsDebGetFirstBlock(HANDLE hHeap);
CLINKAGE PALLOCATION ENTRYPOINT VsDebGetNextBlock(HANDLE hHeap);

//=--------------------------------------------------------------------------=
// Debug IMallocSpy implementation.  Only an EXE should call these functions
// as there is only one MallocSpy per process.
//
// rgIgnoreList may specify an optional list of sizes of external allocations to
// ignore.  This is usefull if your leaks beyond your control happen that you
// would like to filter out.  rgIgnoreList must be static as it is not copied,
// and it must end in a 0 byte value.  You may pass in NULL here if you do not
// have any special case external allocations to ignore.
//
CLINKAGE HRESULT ENTRYPOINT VsStartMallocSpy(DWORD_PTR *rgIgnoreList);
CLINKAGE HRESULT ENTRYPOINT VsStopMallocSpy();

//=--------------------------------------------------------------------------=
// Displays the standard debugging options dialog.
//
CLINKAGE VOID ENTRYPOINT VsShowDebugOptions(HWND hwndParent);

// you should avoid calling these functions; use the macros defined below
//
CLINKAGE PVOID ENTRYPOINT VsDebOleAllocInternal   (LPCSTR pszFile, ULONG ulLine, SIZE_T cb);
CLINKAGE VOID  ENTRYPOINT VsDebOleFreeInternal    (LPCSTR pszFile, ULONG ulLine, PVOID pv);
CLINKAGE PVOID ENTRYPOINT VsDebOleReallocInternal (LPCSTR pszFile, ULONG ulLine, PVOID pv, SIZE_T cb);

CLINKAGE BSTR  ENTRYPOINT VsSysAllocStringInternal        (LPCSTR pszFile, ULONG ulLine, const OLECHAR *pszString);
CLINKAGE BSTR  ENTRYPOINT VsSysAllocStringByteLenInternal (LPCSTR pszFile, ULONG ulLine, LPCSTR pszString, UINT cb);
CLINKAGE BSTR  ENTRYPOINT VsSysAllocStringLenInternal     (LPCSTR pszFile, ULONG ulLine, const OLECHAR *pszString, UINT cch );

CLINKAGE VOID  ENTRYPOINT VsIgnoreAllocsInternal (BOOL fIgnore);

//utility to help you add leak checking functionality in case you have to wrap
// allocation routines (in which case you loose file/line info)
CLINKAGE VOID  ENTRYPOINT VsDebOleSetAllocInfo (LPCSTR pszFile, ULONG ulLine);

//wrapper for CoCreateInstance, which calls VsIgnoreAllocs
CLINKAGE HRESULT ENTRYPOINT VsCoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
				    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);

// debug wrappers for IMalloc allocations.  You should call these to do all of your debug
// IMalloc / SysAlloc* allocations
//
#define VsDebOleAlloc(cb)        VsDebOleAllocInternal(__FILE__, __LINE__, cb)
#define VsDebOleFree(pv)         VsDebOleFreeInternal(__FILE__, __LINE__, pv)
#define VsDebOleRealloc(pv, cb)  VsDebOleReallocInternal(__FILE__, __LINE__, pv, cb)

#define VsDebSysAllocString(str)            VsSysAllocStringInternal(__FILE__, __LINE__, str)
#define VsDebSysAllocStringByteLen(str, cb) VsSysAllocStringByteLenInternal(__FILE__, __LINE__, str, cb)
#define VsDebSysAllocStringLen(str, cch)    VsSysAllocStringLenInternal(__FILE__, __LINE__, str, cch)

// It may sometimes be necessary to ignore IMalloc allocations.  Common dialogs are
// an example, as they cleanup after our process has left the building.  Call this
// with TRUE for f to disable leak checking for EXTERNAL leaks, and FALSE to re-enable
// it.  Note that this (1) only works for external leaks and (2) is refcounted so
// you must balance it.
//
#define VsIgnoreAllocs(f)      VsIgnoreAllocsInternal(f);

// Wrappers for comdlg.dll 'A' functions which call VsIgnoreAllocsInternal...
CLINKAGE BOOL ENTRYPOINT VsGetOpenFileNameA(LPOPENFILENAMEA pofn);
CLINKAGE BOOL ENTRYPOINT VsGetSaveFileNameA(LPOPENFILENAMEA pofn);
CLINKAGE short ENTRYPOINT VsGetFileTitleA(LPCSTR lpstr1, LPSTR lpstr2, WORD w);
CLINKAGE BOOL ENTRYPOINT VsChooseColorA(LPCHOOSECOLORA pcc);
CLINKAGE HWND ENTRYPOINT VsFindTextA(LPFINDREPLACEA pfr);
CLINKAGE HWND ENTRYPOINT VsReplaceTextA(LPFINDREPLACEA pfr);
CLINKAGE BOOL ENTRYPOINT VsChooseFontA(LPCHOOSEFONTA pcf);
CLINKAGE BOOL ENTRYPOINT VsPrintDlgA(LPPRINTDLGA ppd);
CLINKAGE DWORD ENTRYPOINT VsCommDlgExtendedError(VOID);
CLINKAGE BOOL ENTRYPOINT VsPageSetupDlgA(LPPAGESETUPDLGA pps);

//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// Recommended defaults
//
// This header / dll combination is not designed to be used all by itself.
// You should add appropriate macro definitions to your own global headers
// to hide the fact that you're calling into this DLL.  This allows your team
// to code the way they know how, using team-established standards instead
// of imposing arbitrary rules on them.
//
// The macros below define some guidelines for setting up your own macros.
// If these macros suit all of your needs you may just #define
// VSASSERT_SET_DEFAULTS before including this header.
//
//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
#if VSASSERT_SET_DEFAULTS

// Assertion / tracing macro definitions
//
#define ASSERT(fTest, szMsg)  VSASSERT((fTest), (szMsg))
#define FAIL(szMsg)           VSFAIL((szMsg))
#define DEBUGPRINTF           VSDEBUGPRINTF
#define DEBUGPRINTIF          VSDEBUGPRINTIF
#define CASSERT(fTest, msg)   VSCASSERT((fTest), (msg))

// Debug switches
//
#define DEFINE_SWITCH(NAME, PACKAGE, DESC)  VSDEFINE_SWITCH(NAME, PACKAGE, DESC)
#define EXTERN_SWITCH(NAME)                 VSEXTERN_SWITCH(NAME)
#define FSWITCH(NAME)                       VSFSWITCH(NAME)

#if DEBUG

// Memory allocation
//
#if 0
// Note:  You should copy these to your own codebase as we cannot link them in here
//
PVOID operator new(size_t size)
      { return VsDebAlloc(0, size); }
PVOID operator new(size_t size, LPCSTR pszFile, UINT uLine)
      { return VsDebugAllocInternal(DEFAULT_HEAP, 0, size, pszFile, uLine, INSTANCE_GLOBAL, NULL); }
void  operator delete(PVOID pv)
      { VsDebFree(pv); }
#endif // 0

PVOID operator new(size_t size);
PVOID operator new(size_t size, LPCSTR pszFile, UINT uLine);
void  operator delete(PVOID pv);
#define new new(__FILE__, __LINE__)

#define calloc(num, size)     VsDebAlloc(0, (num) * (size))
#define malloc(size)          VsDebAlloc(0, (size))
#define realloc(pv, size)     VsDebSafeRealloc((pv), 0, (size))
#define free(pv)              VsDebFree((pv))

#define HeapAlloc(heap, flags, size)        VsDebHeapAlloc((heap), (flags), (size))
#define HeapReAlloc(heap, flags, pv, size)  VsDebHeapRealloc((heap), (flags), (pv), (size))
#define HeapFree(heap, flags, pv)           VsDebHeapFree((heap), (pv))
#define HeapSize(heap, flags, pv)           VsDebHeapSize((heap), (pv))

#define CoTaskMemAlloc(cb)        VsDebOleAlloc(cb)
#define CoTaskMemRealloc(pv, cb)  VsDebOleRealloc(pv, cb)
#define CoTaskMemFree(pv)         VsDebOleFree(pv)

#define SysAllocString(str)             VsDebSysAllocString((str))
#define SysAllocStringByteLen(str, cb)  VsDebSysAllocStringByteLen((str), (cb))
#define SysAllocStringLen(str, cch)     VsDebSysAllocStringLen((str), (cch))

#endif // DEBUG

//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
#endif // VSASSERT_SET_DEFAULTS

//=--------------------------------------------------------------------------=
// This provides users with a way to create switches that only appear in
// debug.  Users can change these switches through a debug dialog that is
// automatically updated with the latest switches as package DLL's are loaded.
//
// These switches are persisted to a vsdebug.ini file in the windows directory.
//
// ...at the top of your code somewhere...
//
// DEFINE_SWITCH(FDisplayZonkerStatus, "Java", "Display Zonker Status");
//
//      FDisplayZonkerStatus    - the name of your switch
//      Java                    - some logical package grouping of your desire
//      Display Zonker Status   - text to display in the dialog
//
// ...then, wherever you would actually write the zonker status...
//
// if(FSWITCH(FDisplayZonkerStatus))
//    OutputDebugString(szZonkerStatus);
//
// Finally, if you need the switch in another file, use this construct:
//
// EXTERN_SWITCH(FDisplayZonkerStatus);
//
// Switches can be shared anywhere within the same DLL, but cannot be
// shared across DLLs.
//
//

class DebSwitch;
CLINKAGE PVOID ENTRYPOINT VsGetDebSwitchHead(void);
CLINKAGE VOID  ENTRYPOINT VsLoadSwitchState(DebSwitch *pSwitch);

class DebSwitch
  {
  public:
    DebSwitch(LPCSTR pszName, LPCSTR pszPackage, LPCSTR pszDesc)
      {
      // set fields
      m_pszName = pszName;
      m_pszPackage = pszPackage;
      m_pszDesc = pszDesc;
      m_fSet = FALSE;

      // link into global list of switches
      DebSwitch **ppHead = (DebSwitch **)VsGetDebSwitchHead();
      this->m_pdebswNext = *ppHead;
      *ppHead = this;

      // now load the switch state.  We must do this piecemeal
      // because DLL's may come and go at random times
      //
      VsLoadSwitchState(this);
      }

    ~DebSwitch()
      {
      // find our link and remove it.
      DebSwitch **ppHead = (DebSwitch **)VsGetDebSwitchHead();
      while (*ppHead) 
        {
        if (*ppHead == this) 
          {
          *ppHead = (*ppHead)->m_pdebswNext;
          break;
          }

          ppHead = &((*ppHead)->m_pdebswNext);
        }
      }

    BOOL m_fSet;              // TRUE if switch is enabled
    LPCSTR m_pszPackage;       // the package name
    LPCSTR m_pszName;          // name of the switch
    LPCSTR m_pszDesc;          // description string
    DebSwitch* m_pdebswNext;  // next switch in global list
  };

#define VSDEFINE_SWITCH(NAME, PACKAGE, DESC)  DebSwitch g_Switch_ ## NAME(#NAME, PACKAGE, DESC)
#define VSEXTERN_SWITCH(NAME)                 extern DebSwitch g_Switch_ ## NAME
#define VSFSWITCH(NAME)                       (g_Switch_ ## NAME . m_fSet)

#else // DEBUG


//=--------------------------------------------------------------------------=
// Retail defines
//
#define VSDEFINE_SWITCH(NAME, PACKAGE, DESC)
#define VSEXTERN_SWITCH(NAME)
#define VSFSWITCH(NAME) FALSE

#define VsIgnoreAllocs(f)

#endif // DEBUG

/////
// This will show up in Debug.Threads in the VC debugger
/////
CLINKAGE VOID ENTRYPOINT VsNameThisThread (LPCSTR szThreadName);


//****************************************************************************
//	    REFERENCE TRACKING
//****************************************************************************
/*
  Tracker Macros
  ==============

    These macros can be used to record AddRef and Release on COM objects so
    reference counting errors can be pinpointed.

    How these macros work:
    =====================

    Whenever a reference is added by calling AddRef on a COM object, there is
    usually a variable somewhere that holds a pointer to the object.  This
    variable "owns" the reference.  When this variable is cleared (or goes out
    of scope) the reference should be released.  If there is a reference leak, it
    means that one of these variables didn't make its call to Release.

    What these macros do in the debug build is that whenever anybody calls
    AddRef, and entry is added to a table.  The entry stores the COM IUnkown
    pointer, the address of the variable that holds this pointer, and a pass count.
    Whenever anybody calls Release, we search the table for an entry where the COM
    IUnknown pointer matches and the address of the variable matches, and remove it.
    (If we don't find it we assert.  This means somebody is over-releasing.)

    Then, at shutdown, we make sure the table is empty.  If it is not empty, then
    we assert.  With the PassCount number, you can restart and break at the
    offending AddRef.  I.e., you can break at exactly the point where somebody
    AddRefs an object but never calls Release.


    How to use:
    ===========

    Here is some sample code which uses these macros.

    IFoo *g_pFoo;

    void PlayWithObjects()
    {
      IFoo *pFoo = NULL;
      IFoo *pFoo2 = NULL;

      GetFooFromSomewhere(&pFoo);
      TRACKER_RECEIVE(pFoo);

      pFoo2 = pFoo;
      TRACKER_ADDREF(pFoo2);

      // assign it to our global variable.  This global
      // is going to hold it for a long time, so we don't
      // release it at the end of this function.  Somebody somewhere
      // else is going to release it later.
      g_pFoo = pFoo;
      TRACKER_ADDREF(g_pFoo);

      // use pFoo and pFoo2 for a while

      TRACKER_RELEASE(pFoo);
      TRACKER_RELEASE(pFoo2);
    }

    Whenever you are given an object (because you called some function that
    returns it to you) and you now hold a reference to it, call TRACKER_RECEIVE.
    (This does nothing in the non-debug build.)  This will make sure you
    remember to call release later.

    Whenever you need to addref (because you copy the pointer into another
    variable, for example) use TRACKER_ADDREF.

    Whenever you need to release (when your variables are going out of scope),
    call TRACKER_RELEASE.

    Other notes: if you're giving out an object to your caller, you will need
    to use TRACKER_GIVE_AWAY.  If you're transferring ownership from one variable
    to another, use TRACKER_ASSIGN.

*/

//****************************************************************************

//---------------------------------------------------------------------------

#ifdef DEBUG
#define TRACKER_ASSERT_EVERYTHING_RELEASED() TrackerAssertEverythingReleased()
#else
#define TRACKER_ASSERT_EVERYTHING_RELEASED()
#define TrackerTransfer() do {} while (0)
#endif	// DEBUG

#ifdef DEBUG

#define TRACKER_ADDREF(punk1) do {	  \
    VSASSERT ((punk1), "TRACKER can't addref NULL");  \
    (punk1)->AddRef();			  	  \
    TrackerTransfer ((punk1), NULL, &(punk1));	  \
  } while (0)					  \

#define TRACKER_RELEASE(punk) do {	    	\
    VSASSERT (punk, "TRACKER can't release NULL");	\
    (punk)->Release();			    	\
    TrackerTransfer ((punk), &(punk), NULL);   	\
    (punk) = NULL;			    	\
  } while (0)					\

#define TRACKER_RECEIVE(punk) do {	       		\
    VSASSERT (punk, "TRACKER can't receive NULL");	\
    TrackerTransfer ((punk), NULL, &(punk)); 		\
  } while (0)						\


#define TRACKER_GIVE_AWAY(punk) do {			\
    VSASSERT (punk, "TRACKER can't give away NULL");	\
    TrackerTransfer ((punk), &(punk), NULL); 		\
  } while (0)						\


#define TRACKER_ASSIGN(punkDest, punkSrc) do {		  \
    VSASSERT (punkSrc, "TRACKER can't assign NULL");	  \
    VSASSERT (!punkDest, "TRACKER must assign to NULL");\
    (punkDest) = (punkSrc);				  \
    TrackerTransfer ((punkSrc), &(punkSrc), &(punkDest));  \
    punkSrc = NULL;					  \
  } while (0)


#define TRACKER_COPY(punkDest, punkSrc) do {		\
    VSASSERT ((punkSrc), "TRACKER can't assign NULL");	\
    VSASSERT ((!punkDest), "TRACKER must assign to NULL");\
    (punkDest) = (punkSrc);				\
    TRACKER_ADDREF ((punkDest));			\
  } while (0)

CLINKAGE void ENTRYPOINT  TrackerTransfer(IUnknown *punk, void *pvFrom, void *pvTo);
CLINKAGE void ENTRYPOINT  TrackerAssertEverythingReleased();

#else // DEBUG

#define TRACKER_ADDREF(punk)	    ((punk)->AddRef())
#define TRACKER_RELEASE(punk)	    ((punk) -> Release(), (punk) = NULL)
#define TRACKER_RECEIVE(punk)	    do {} while (0)
#define TRACKER_GIVE_AWAY(punk)	    do {} while (0)
#define TRACKER_ASSIGN(punkD, punkS) ((punkD) = (punkS), (punkS) = NULL)
#define TRACKER_COPY(punkD, punkS)  ((punkD) = (punkS), (punkD) -> AddRef())

#endif // DEBUG

#define TRACKER_CHECK_RELEASE(punk) do {	\
    if (punk) {					\
      TRACKER_RELEASE(punk);			\
    }						\
  } while (0)					


//******************** Dynamic casting

// The new C++ standard defines dynamic_cast<type> (expr), which appears
// to be particulary usefull for verifying that a pointer to one class
// can safely be casted to a pointer to another.  However, this safety
// requires the use of RTTI, which currently imposes a significant overhead.
// We could almost use static_cast when RTTI is not available, but it has
// slightly different semantics in some circumstances

// The defined(DEBUG) is uneccesary since VSASSERT will go away for retail

#if defined (_CPPRTTI) && defined (DEBUG)

#define ASSERT_TYPE(type, expr) do { \
  VSASSERT ((dynamic_cast <type> (expr)), "Wrong type"); \
  }  while (0)

#else

#define ASSERT_TYPE(type, expr) do { } while (0)

#endif



#endif // _INC_VSASSERT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\VseeGuids.h ===
/*-----------------------------------------------------------------------------
Microsoft VSEE

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc
@module VseeGuids.h - Guids for VSEE services/interfaces |
This is included by .idl files to define guids for VSEE services/interfaces.
These are the non-shell-SDK interfaces, in idl/vsee

@owner Source Control Integration Team
-----------------------------------------------------------------------------*/
#pragma once

#ifdef _WIN64

#define uuid_IVsSccManager							53474C4D-0F05-4735-8AAC-264109CF68AC
#define uuid_IVsSccProject							53474C4D-CD19-4928-A834-AFCD8A966C36
#define uuid_IVsQueryEditQuerySave					53474C4D-7E28-4d0c-A00F-3446801350CE
#define uuid_IVsTrackProjectDocuments				53474C4D-449A-4487-A56F-740CF8130032
#define uuid_IVsTrackProjectDocumentsEvents			53474C4D-A98B-4fd3-AA79-B182EE26185B
#define uuid_IVsSccEngine							53474C4D-F82C-11d0-8D84-00AA00A3F593
#define uuid_IVsSccPopulateList						53474C4D-F8CF-11d0-8D84-00AA00A3F593
#define uuid_IVsSccToolsOptions						53474C4D-304B-4D82-AD93-074816C1A0E5
#define uuid_IVsSccManagerTooltip					53474C4D-DF28-406D-81DA-96DEEB800B64
#define uuid_IVsExternalCommandTarget				53474C4D-AB21-4A15-BD22-28A9B35DD89E
#define uuid_IVsSccItem								53474C4D-AAF8-11D0-8E5E-00A0C911005A
#define uuid_IVsSccMergeConflictsUIFactory			53474C4D-00FA-4dcb-BBBF-F0F1CD8C62FC
#define uuid_IVsSccMergeConflictsUIEvents			53474C4D-03FA-4dcb-BBBF-F0F1CD8C62FC
#define uuid_IVsMergeUIFactory						53474C4D-18AC-4227-A60F-4A50AFD0A89B
#define uuid_IVsSccMergeConflictsUI					53474C4D-01FA-4dcb-BBBF-F0F1CD8C62FC
#define uuid_IVsDiffUIFactory						53474C4D-48DB-488E-95C9-1F0461970402
#define uuid_IVsDiffMergeUIClientCallback			53474C4D-6B1F-476A-B423-4BCD87DAAD03
#define uuid_IVsDiffMergeUIBroker					53474C4D-0BA6-49E0-B9B3-3D90E34C0BBF
#define uuid_IVsSccMergeConflictsUIFileInto			53474C4D-02FA-4dcb-BBBF-F0F1CD8C62FC


#else

#define uuid_IVsSccManager							53544C4D-0F05-4735-8AAC-264109CF68AC
#define uuid_IVsSccProject							53544C4D-CD19-4928-A834-AFCD8A966C36
#define uuid_IVsQueryEditQuerySave					53544C4D-7E28-4d0c-A00F-3446801350CE
#define uuid_IVsTrackProjectDocuments				53544C4D-449A-4487-A56F-740CF8130032
#define uuid_IVsTrackProjectDocumentsEvents			53544C4D-A98B-4fd3-AA79-B182EE26185B
#define uuid_IVsSccEngine							53544C4D-F82C-11d0-8D84-00AA00A3F593
#define uuid_IVsSccPopulateList						53544C4D-F8CF-11d0-8D84-00AA00A3F593
#define uuid_IVsSccToolsOptions						53544C4D-304B-4D82-AD93-074816C1A0E5
#define uuid_IVsSccManagerTooltip					53544C4D-DF28-406D-81DA-96DEEB800B64
#define uuid_IVsExternalCommandTarget				53544C4D-AB21-4A15-BD22-28A9B35DD89E
#define uuid_IVsSccItem								53544C4D-AAF8-11D0-8E5E-00A0C911005A
#define uuid_IVsSccMergeConflictsUIFactory			53544c4d-00FA-4dcb-BBBF-F0F1CD8C62FC
#define uuid_IVsSccMergeConflictsUIEvents			53544c4d-03FA-4dcb-BBBF-F0F1CD8C62FC
#define uuid_IVsMergeUIFactory						53544C4D-18AC-4227-A60F-4A50AFD0A89B
#define uuid_IVsSccMergeConflictsUI					53544c4d-01FA-4dcb-BBBF-F0F1CD8C62FC
#define uuid_IVsDiffUIFactory						53544C4D-48DB-488E-95C9-1F0461970402
#define uuid_IVsDiffMergeUIClientCallback			53544C4D-6B1F-476A-B423-4BCD87DAAD03
#define uuid_IVsDiffMergeUIBroker					53544C4D-0BA6-49E0-B9B3-3D90E34C0BBF
#define uuid_IVsSccMergeConflictsUIFileInto			53544c4d-02FA-4dcb-BBBF-F0F1CD8C62FC

#endif

#define uuid_SVsExternalCommandTarget				53544C4D-1B21-4A15-BD22-28A9B35DD89E
#define uuid_SVsDiffMergeUIBroker					53544C4D-1BA6-49E0-B9B3-3D90E34C0BBF
#define uuid_SVsSccMergeConflicts					53544c4D-10FA-4dcb-BBBF-F0F1CD8C62FC
#define uuid_SVsSccToolsOptions						53544C4D-104B-4D82-AD93-074816C1A0E5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\VsRegKey.h ===
#pragma once

/////////////////////////////////////////////////////////////////////////////
// CVsRegKeyW

#define VsRegKey_ExpectedPtr(ptr)               \
    VSASSERT(ptr != NULL, "Invalid arg");       \
    if (ptr == NULL)                            \
        { return E_POINTER; }

class CVsRegKeyW
{
public:
  CVsRegKeyW();
  ~CVsRegKeyW();

// Attributes
public:
  operator HKEY() const;
  HKEY m_hKey;

// Operations
public:
  HRESULT  QueryValue(LPCOLESTR lpszValueName, BSTR * pbstrValue);
  HRESULT  QueryValue(LPCOLESTR lpszValueName, GUID *pGuid);
  HRESULT  QueryValue(LPCOLESTR lpszValueName, DWORD * pdwValue);

  HRESULT  SetValue(LPCOLESTR lpszValueName, LPCOLESTR lpszValue);
  HRESULT  SetValue(LPCOLESTR lpszValueName, DWORD dwValue);
  //HRESULT  SetValueW(LPCOLESTR lpszValueName, REFGUID rGuid);

  HRESULT SetKeyValue(LPCOLESTR lpszKeyName, LPCOLESTR lpszValueName, LPCOLESTR lpszValue);
  static HRESULT WINAPI SetValue(HKEY hKeyParent, LPCOLESTR lpszKeyName,
	  LPCOLESTR lpszValueName, LPCOLESTR lpszValue);

  HRESULT Create(HKEY hKeyParent, LPCOLESTR lpszKeyName,
	  LPOLESTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE,
	  REGSAM samDesired = KEY_ALL_ACCESS,
	  LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
	  LPDWORD lpdwDisposition = NULL);
  HRESULT Open(HKEY hKeyParent, LPCOLESTR lpszKeyName,
	  REGSAM samDesired = KEY_ALL_ACCESS);
  HRESULT Close();
  HKEY    Detach();
  void    Attach(HKEY hKey);
  HRESULT DeleteSubKey(LPCOLESTR lpszSubKey);
  HRESULT RecurseDeleteKey(LPCOLESTR lpszKey);
  HRESULT DeleteValue(LPCOLESTR lpszValue);
  HRESULT EnumKeyEx(DWORD dwIndex, BSTR * pbstrName, BSTR * pbstrClass = NULL, PFILETIME lpftLastWriteTime = NULL);
  HRESULT GetSubkeyCount(DWORD * pdwCount); 
  HRESULT EnumValue(DWORD dwIndex, BSTR * pbstrName, DWORD * pType = NULL);
  HRESULT GetValueCount(DWORD * pdwCount); 
};

//-------------------------------------------------

inline CVsRegKeyW::CVsRegKeyW()
{
  m_hKey = NULL;
}

inline CVsRegKeyW::~CVsRegKeyW()
{
  Close();
}

inline CVsRegKeyW::operator HKEY() const
{ 
  return m_hKey;
}

inline HKEY CVsRegKeyW::Detach()
{
  HKEY hKey = m_hKey;
  m_hKey = NULL;
  return hKey;
}

inline void CVsRegKeyW::Attach(HKEY hKey)
{
  ATLASSERT(m_hKey == NULL);
  m_hKey = hKey;
}

//-------------------------------------------------

inline HRESULT CVsRegKeyW::DeleteSubKey(LPCOLESTR lpszSubKey)
{
  ATLASSERT(m_hKey != NULL);
  return HRESULT_FROM_WIN32(RegDeleteKeyW(m_hKey, lpszSubKey));
}

//-------------------------------------------------

inline HRESULT CVsRegKeyW::DeleteValue(LPCOLESTR lpszValue)
{
  ATLASSERT(m_hKey != NULL);
  return HRESULT_FROM_WIN32(RegDeleteValueW(m_hKey, (LPOLESTR)lpszValue));
}

//-------------------------------------------------

inline LONG CVsRegKeyW::RecurseDeleteKey(LPCOLESTR lpszKey)
{
  CVsRegKeyW key;
  LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE);
  if (lRes != ERROR_SUCCESS)
    return lRes;
  FILETIME time;
  DWORD dwSize = 256;
  WCHAR szBuffer[256];
  while (RegEnumKeyExW(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
	  &time)==ERROR_SUCCESS)
  {
    lRes = key.RecurseDeleteKey(szBuffer);
    if (lRes != ERROR_SUCCESS)
	    return lRes;
    dwSize = 256;
  }
  key.Close();
  return DeleteSubKey(lpszKey);
}

//-------------------------------------------------

inline HRESULT CVsRegKeyW::Close()
{
  LONG lRes = ERROR_SUCCESS;
  if (m_hKey != NULL)
  {
    lRes = RegCloseKey(m_hKey);
    m_hKey = NULL;
  }
  return HRESULT_FROM_WIN32(lRes);
}

//-------------------------------------------------

inline HRESULT CVsRegKeyW::Create(HKEY hKeyParent, LPCOLESTR lpszKeyName,
  LPOLESTR lpszClass, DWORD dwOptions, REGSAM samDesired,
  LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
  ATLASSERT(hKeyParent != NULL);
  DWORD dw;
  HKEY hKey = NULL;
  LONG lRes = RegCreateKeyExW(hKeyParent, lpszKeyName, 0,
	  lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
  if (lpdwDisposition != NULL)
    *lpdwDisposition = dw;
  if (lRes == ERROR_SUCCESS)
  {
    lRes = Close();
    m_hKey = hKey;
  }
  return HRESULT_FROM_WIN32(lRes);
}

//-------------------------------------------------

inline HRESULT CVsRegKeyW::Open(HKEY hKeyParent, LPCOLESTR lpszKeyName, REGSAM samDesired)
{
  ATLASSERT(hKeyParent != NULL);
  HKEY hKey = NULL;
  LONG lRes = RegOpenKeyExW(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
  if (lRes == ERROR_SUCCESS)
  {
    Close();
    m_hKey = hKey;
  }
  return HRESULT_FROM_WIN32(lRes);
}

//-------------------------------------------------
// Query DWORD
//-------------------------------------------------

inline HRESULT CVsRegKeyW::QueryValue(LPCOLESTR lpszValueName, DWORD * pdwValue)
{
  VsRegKey_ExpectedPtr(pdwValue);

  DWORD dwType = NULL;
  DWORD dwCount = sizeof(DWORD);
  LONG lRes = RegQueryValueExW(m_hKey, (LPOLESTR)lpszValueName, NULL, &dwType,
	  (LPBYTE)pdwValue, &dwCount);
  ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
  ATLASSERT((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
  return HRESULT_FROM_WIN32(lRes);
}

//-------------------------------------------------
// Query String
//-------------------------------------------------

inline HRESULT CVsRegKeyW::QueryValue(LPCOLESTR lpszValueName, BSTR * pbstrValue)
{
  VsRegKey_ExpectedPtr(pbstrValue);

  * pbstrValue = NULL;

  DWORD cbBuffer = 0;
  DWORD dwType = 0;
  LONG lRes = RegQueryValueExW(m_hKey, lpszValueName, NULL, &dwType, NULL, &cbBuffer);

  ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
		   (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));

  if (ERROR_SUCCESS == lRes && cbBuffer)
  {
    CComBSTR bstrValue(cbBuffer / sizeof(WCHAR) - 1);
    if(bstrValue != NULL)
    {
      lRes = RegQueryValueExW(m_hKey, lpszValueName, NULL,
				       NULL, (LPBYTE)(bstrValue.m_str), &cbBuffer);

      if(ERROR_SUCCESS == lRes && bstrValue.Length() != 0)
	 *pbstrValue = bstrValue.Detach();

    }
    else
      return E_OUTOFMEMORY;
  }

  return HRESULT_FROM_WIN32(lRes);
}

//-------------------------------------------------
// Query GUID
//-------------------------------------------------

inline HRESULT CVsRegKeyW::QueryValue(LPCOLESTR lpszValueName, GUID *pGuid)
{
  VsRegKey_ExpectedPtr(pGuid);

  CComBSTR bstrGuid;
  HRESULT hr = QueryValue(lpszValueName, &bstrGuid);
  if(SUCCEEDED(hr))
    hr = CLSIDFromString(bstrGuid, pGuid);

  return hr;
}

//-------------------------------------------------
// Set Value
//-------------------------------------------------

inline HRESULT WINAPI CVsRegKeyW::SetValue(HKEY hKeyParent, LPCOLESTR lpszKeyName, LPCOLESTR lpszValue, LPCOLESTR lpszValueName)
{
  ATLASSERT(lpszValue != NULL);
  CVsRegKeyW key;
  LONG lRes = key.Create(hKeyParent, lpszKeyName);
  if (lRes == ERROR_SUCCESS)
    lRes = key.SetValue(lpszValue, lpszValueName);
  return HRESULT_FROM_WIN32(lRes);
}

inline HRESULT CVsRegKeyW::SetKeyValue(LPCOLESTR lpszKeyName, LPCOLESTR lpszValue, LPCOLESTR lpszValueName)
{
  ATLASSERT(lpszValue != NULL);
  CVsRegKeyW key;
  LONG lRes = key.Create(m_hKey, lpszKeyName);
  if (lRes == ERROR_SUCCESS)
	  lRes = key.SetValue(lpszValue, lpszValueName);
  return HRESULT_FROM_WIN32(lRes);
}

//-------------------------------------------------
// Set DWORD
//-------------------------------------------------

inline LONG CVsRegKeyW::SetValue(LPCOLESTR lpszValueName, DWORD dwValue)
{
  ATLASSERT(m_hKey != NULL);
  LONG lRes = RegSetValueExW(m_hKey, lpszValueName, NULL, REG_DWORD,
	  (BYTE * const)&dwValue, sizeof(DWORD));
  return HRESULT_FROM_WIN32(lRes);
}

//-------------------------------------------------
// Set String
//-------------------------------------------------

inline LONG CVsRegKeyW::SetValue(LPCOLESTR lpszValueName, LPCOLESTR lpszValue)
{
  ATLASSERT(m_hKey != NULL);

  LONG lRes;

  if(!lpszValue)
  {
    lRes = RegSetValueExW(m_hKey, lpszValueName, NULL, REG_SZ,
	   NULL, 0);
    if(ERROR_SUCCESS != lRes) // SetValue with NULL fails on Win98
    {
      lRes = RegSetValueExW(m_hKey, lpszValueName, NULL, REG_SZ,
	  (BYTE * const)L"", sizeof(WCHAR));
    }
  }
  else
  {
    lRes = RegSetValueExW(m_hKey, lpszValueName, NULL, REG_SZ,
	  (BYTE * const)lpszValue, (DWORD)((wcslen(lpszValue)+1)*sizeof(WCHAR)));
  }
  return HRESULT_FROM_WIN32(lRes);
}

//-------------------------------------------------
// enum key
//-------------------------------------------------

inline HRESULT CVsRegKeyW::EnumKeyEx(DWORD dwIndex, BSTR * pbstrName, BSTR * pbstrClass, PFILETIME lpftLastWriteTime)
{
  WCHAR * pszName = NULL;
  WCHAR * pszClass = NULL;
  DWORD dwNameSize;
  DWORD dwClassSize;
  LONG  lRes;

  lRes = RegQueryInfoKeyW(m_hKey, NULL, NULL, NULL, NULL, &dwNameSize, &dwClassSize, NULL, NULL, NULL, NULL, NULL); 
  if(ERROR_SUCCESS == lRes)
  {
    dwNameSize++;
    dwClassSize++;
    if(pbstrName)
      pszName = (WCHAR *)_alloca(dwNameSize * sizeof(WCHAR));
    else
      dwNameSize = 0;

    if(pbstrClass)
      pszClass = (WCHAR *)_alloca(dwClassSize * sizeof(WCHAR));
    else
      dwClassSize = 0;

    lRes = RegEnumKeyExW(m_hKey, dwIndex, pszName, &dwNameSize, 
                NULL, pszClass, &dwClassSize, lpftLastWriteTime);
    if(ERROR_SUCCESS == lRes)
    {
      if(pbstrName)
        *pbstrName = ::SysAllocString(pszName);
      if(pbstrClass)
        *pbstrClass = ::SysAllocString(pszClass);
    }
  }
  return HRESULT_FROM_WIN32(lRes);
}

/*
inline HRESULT CVsRegKeyW::EnumKeyEx(DWORD dwIndex, BSTR * pbstrName, BSTR * pbstrClass, PFILETIME lpftLastWriteTime)
{
  WCHAR pszName[256];
  WCHAR szClass[256];
  DWORD dwNameSize = NUMBER_OF(szName);
  DWORD dwClassSize = NUMBER_OF(szClass);
  LONG  lRes;

  lRes = RegEnumKeyExW(m_hKey, dwIndex, szName, &dwNameSize, 
              NULL, szClass, &dwClassSize, lpftLastWriteTime);
  if(ERROR_SUCCESS == lRes)
  {
    if(pbstrName)
      *pbstrName = ::SysAllocString(szName);
    if(pbstrClass)
      *pbstrClass = ::SysAllocString(szClass);
  }

  return HRESULT_FROM_WIN32(lRes);
}
*/

inline HRESULT CVsRegKeyW::GetSubkeyCount(DWORD * pdwCount)
{
  LONG lRes = RegQueryInfoKeyW(m_hKey, NULL, NULL, NULL, pdwCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL); 
  return HRESULT_FROM_WIN32(lRes);
} 

//-------------------------------------------------
// enum value
//-------------------------------------------------

inline HRESULT CVsRegKeyW::EnumValue(DWORD dwIndex, BSTR * pbstrName, DWORD * pType)
{
  VsRegKey_ExpectedPtr(pbstrName);

  WCHAR * pszName;
  DWORD dwNameSize;
  LONG lRes;

  lRes = RegQueryInfoKeyW(m_hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &dwNameSize, NULL, NULL, NULL); 
  if(ERROR_SUCCESS == lRes)
  {
    dwNameSize++;
    pszName = (WCHAR *)_alloca(dwNameSize * sizeof(WCHAR));

    lRes = RegEnumValueW(m_hKey, dwIndex, pszName, &dwNameSize, NULL, pType, NULL, NULL);
    if(ERROR_SUCCESS == lRes)
    {
      *pbstrName = ::SysAllocString(pszName);
    }
  }
  return HRESULT_FROM_WIN32(lRes);
}

/*
inline HRESULT CVsRegKeyW::EnumValue(DWORD dwIndex, BSTR * pbstrName, DWORD * pType)
{
  WCHAR szName[256];
  DWORD dwNameSize = NUMBER_OF(szName);

  LONG lRes = RegEnumValueW(m_hKey, dwIndex, szName, &dwNameSize, NULL, pType, NULL, NULL);

  if(ERROR_SUCCESS == lRes)
  {
    if(pbstrName)
      *pbstrName = ::SysAllocString(szName);
  }

  return HRESULT_FROM_WIN32(lRes);
}
*/

inline HRESULT CVsRegKeyW::GetValueCount(DWORD * pdwCount)
{
  LONG lRes = RegQueryInfoKeyW(m_hKey, NULL, NULL, NULL, NULL, NULL, NULL, pdwCount, NULL, NULL, NULL, NULL); 
  return HRESULT_FROM_WIN32(lRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsslnids.h ===
// SolnMnId.h

#ifndef _VSSLNIDS_H_
#define _VSSLNIDS_H_

#ifndef NOGUIDS

#ifdef DEFINE_GUID
  DEFINE_GUID (guidSolnPkg,
    0x282BD676, 0x8B5B, 0x11D0, 0x8A, 0x34, 0x00, 0xA0, 0xC9, 0x1E, 0x2A, 0xCD);

  DEFINE_GUID (guidSolnBuilder,
    0xd0b027ce, 0x8c1f, 0x11d0, 0x8a, 0x34, 0x00, 0xa0, 0xc9, 0x1e, 0x2a, 0xcd);

  DEFINE_GUID (guidSolnLDM,
    0xa42b2bf0, 0x516e, 0x11d1, 0xa1, 0xfa, 0x00, 0x00, 0xf8, 0x02, 0x6f, 0x55);

#else

  #define guidSolnPkg	    {0x282BD676,0x8B5B,0x11D0,{0x8A,0x34,0x00,0xA0,0xC9,0x1E,0x2A,0xCD}}
  #define guidSolnBuilder   {0xd0b027ce,0x8c1f,0x11d0,{0x8a,0x34,0x00,0xa0,0xc9,0x1e,0x2a,0xcd}}
  #define guidSolnLDM	    {0xa42b2bf0,0x516e,0x11d1,{0xa1,0xfa,0x00,0x00,0xf8,0x02,0x6f,0x55}}

#endif //DEFINE_GUID
#endif //NOGUIDS

// Top level "Build" menu.
#define IDM_SLN_BUILDMENU	1
#define IDM_SLN_BUILDTOOLBAR 4
#define IDM_SLN_BUILD_CONFIG 5

// Simple project context menu
#define IDM_SPROJ_CTXT		2
#define IDM_LOCALDEPLOY_MAPTGTCONTEXT		3

// Build menu groups.
#define IDG_SLN_BUILD		11
#define IDG_SLN_REBUILD         12
#define IDG_SLN_BATCHBUILD	13
#define IDG_SLN_GO		14
#define IDG_SLN_CLEAN		15
#define IDG_SLN_CANCEL		16
#define IDG_SPROJ_CTXT_OPTIONS  17
#define IDG_SLN_DEPLOY          18

#define IDG_BUILD_TOOLBAR	20
#define IDG_CFG_TOOLBAR		21

#define icmdBuildSolution	110
#define icmdRebuildSolution	120
#define icmdRebuildSelection	125
#define icmdCleanSolution	130
#define icmdDeploySolution	140
#define icmdDeploySelection     145

#define icmdBuildSelection	150
#define icmdCleanSelection	160
#define icmdBuildCancel		170
#define icmdBatchBuild          175

#define icmdProjectBuildSettings	180

#define itbrCfg				190
#define cmdidSlnCfgCombo	191
#define cmdidSlnCfgGetList	192


// Build menu button icons
#define iconCompile			1
#define iconBuildSelection	2
#define iconBuildSolution	3
#define iconCancelBuild		4

#endif //_VSSLNIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsshlids.h ===
//////////////////////////////////////////////////////////////////////////////
//
//Microsoft Confidential
//Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
//
//File: VSShlIds.H
//
//Contents:
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _VSSHLIDS_H_
#define _VSSHLIDS_H_


//////////////////////////////////////////////////////////////////////////////
//
// GUID Identifiers, created by Visual Studio Shell
//
//////////////////////////////////////////////////////////////////////////////
#ifndef NOGUIDS

#ifdef DEFINE_GUID
  // Guid if using Office provided icons
  DEFINE_GUID (guidOfficeIcon,
    0xd309f794, 0x903f, 0x11d0, 0x9e, 0xfc, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f);

  // Guid for the duplicate accelerator keys
  DEFINE_GUID (guidKeyDupe,
    0xf17bdae0, 0xa16d, 0x11d0, 0x9f, 0x4,  0x0,  0xa0, 0xc9, 0x11, 0x0,  0x4f);

  // Guid for Shell's group and menu ids
  DEFINE_GUID (guidSHLMainMenu,
    0xd309f791, 0x903f, 0x11d0, 0x9e, 0xfc, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f);

  // Guid for DocOutline package commands
  DEFINE_GUID (guidDocOutlinePkg,
	0x21af45b0, 0xffa5, 0x11d0, 0xb6, 0x3f, 0x00, 0xa0, 0xc9, 0x22, 0xe8, 0x51);

  // UIContext guid specifying that we're not in View Source mode
  DEFINE_GUID(guidNotViewSourceMode, 
	    0x7174c6a0, 0xb93d, 0x11d1, 0x9f, 0xf4, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x4f);

  // Guid for shared groups
  // {234A7FC1-CFE9-4335-9E82-061F86E402C1}
  DEFINE_GUID(guidSharedMenuGroup, 
    0x234a7fc1, 0xcfe9, 0x4335, 0x9e, 0x82, 0x6, 0x1f, 0x86, 0xe4, 0x2, 0xc1);

  DEFINE_GUID(guidBuildCmdIcons,
    0x952691c5, 0x34d6, 0x462b, 0xac, 0x56, 0x9a, 0xb0, 0x97, 0x70, 0xa3, 0x0d);

  DEFINE_GUID(CMDSETID_StandardCommandSet2K,
    0x1496A755, 0x94DE, 0x11D0, 0x8C, 0x3F, 0x00, 0xC0, 0x4F, 0xC2, 0xAA, 0xE2);

  // {501822E1-B5AF-11d0-B4DC-00A0C91506EF}
  DEFINE_GUID(guidDataCmdId,
	0x501822e1, 0xB5AF, 0x11D0, 0xB4, 0xDC, 0x00, 0xA0, 0xC9, 0x15, 0x06, 0xEF);

  //{732abe75-cd80-11d0-a2db-00aa00a3efff}
  DEFINE_GUID(CMDSETID_DaVinciDataToolsCommandSet,
	0x732abe75, 0xcd80, 0x11d0, 0xa2, 0xdb, 0x00, 0xaa, 0x00, 0xa3, 0xef, 0xff);

  // WM_APPCOMMAND handling
  // The active ole command targets will receive CMDSETID_WMAppCommand:cmdID, where
  // cmdID is one of APPCOMMAND_****, defined in winuser.h for _WIN32_WINNT >= 0x0500
  // (use common\inc\wmappcmd.h to have this commands defined for all target platforms)
  // If command is not handled, we will look in the registry for the mapped command:
  // HKLM\<appid hive>\WMAppCommand 
  //    val <AppCmdID> = {<guidCmdSet>}:<cmdID>

  // {12F1A339-02B9-46e6-BDAF-1071F76056BF}
  DEFINE_GUID(CMDSETID_WMAppCommand, 
        0x12f1a339, 0x02b9, 0x46e6, 0xbd, 0xaf, 0x10, 0x71, 0xf7, 0x60, 0x56, 0xbf);


#else //!DEFINE_GUID
  // Guid if using Office provided icons
  #define guidOfficeIcon	      { 0xd309f794, 0x903f, 0x11d0, { 0x9e, 0xfc, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f } }
  // Guid for the duplicate accelerator keys
  #define guidKeyDupe		      { 0xf17bdae0, 0xa16d, 0x11d0, { 0x9f, 0x4,  0x0,  0xa0, 0xc9, 0x11, 0x0,  0x4f } }
  // Guid for Shell's group and menu ids
  #define guidSHLMainMenu	      { 0xd309f791, 0x903f, 0x11d0, { 0x9e, 0xfc, 0x00, 0xa0, 0xc9, 0x11, 0x00, 0x4f } }
  // Guid for Standard Shell Commands (97 set)
  #define CMDSETID_StandardCommandSet97  { 0x5efc7975, 0x14bc, 0x11cf, { 0x9b, 0x2b, 0x00, 0xaa, 0x00, 0x57, 0x38, 0x19 } }
  // Guid for Standard Shell Commands (2k set)
  #define CMDSETID_StandardCommandSet2K {0x1496A755, 0x94DE, 0x11D0, {0x8C, 0x3F, 0x00, 0xC0, 0x4F, 0xC2, 0xAA, 0xE2}}
  // Guid for DocOutline package commands
  #define guidDocOutlinePkg { 0x21af45b0, 0xffa5, 0x11d0, { 0xb6, 0x3f, 0x00, 0xa0, 0xc9, 0x22, 0xe8, 0x51 } }
  // Guid for TaskList package commands
  #define CLSID_VsTaskListPackage	  { 0x4A9B7E50, 0xAA16, 0x11d0, { 0xA8, 0xC5, 0x00, 0xA0, 0xC9, 0x21, 0xA4, 0xD2 } }
  // Guid for find/replace bitmaps...
  #define guidFindIcon  { 0x740EEC10, 0x1A5D, 0x11D1, { 0xA0, 0x30, 0x00, 0xA0, 0xC9, 0x11, 0xE8, 0xE9} }
  // Guid for debugger bitmaps
  #define guidDebuggerIcon { 0xb7afe65e, 0x3a96, 0x11d1, { 0xb0, 0x68, 0x0, 0xc0, 0x4f, 0xb6, 0x6f, 0xa0} }
  // Guid for object browser buttons
  #define guidObjectBrowserButtons  { 0x5f810e80, 0x33ad, 0x11d1, { 0xa7, 0x96, 0x0, 0xa0, 0xc9, 0x11, 0x10, 0xc3 } }
  // UIContext guid specifying that we're not in View Source mode
  #define guidNotViewSourceMode  {0x7174c6a0, 0xb93d, 0x11d1, {0x9f, 0xf4, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x4f} }
  // Guid for text editor bitmaps...
  #define guidTextEditorIcon  { 0xc40a5a10, 0x3eeb, 0x11d3, { 0xaf, 0xe5, 0x0, 0x10, 0x5a, 0x99, 0x91, 0xef } }
  #define guidSharedMenuGroup { 0x234a7fc1, 0xcfe9, 0x4335, { 0x9e, 0x82, 0x6, 0x1f, 0x86, 0xe4, 0x02, 0xc1 } }
  // guid for build cmd icons
  #define guidBuildCmdIcons { 0x952691c5, 0x34d6, 0x462b, {0xac, 0x56, 0x9a, 0xb0, 0x97, 0x70, 0xa3, 0x0d}}
  // {501822E1-B5AF-11d0-B4DC-00A0C91506EF} Guid for Data project commands
  #define guidDataCmdId {0x501822e1, 0xb5af, 0x11d0, {0xb4, 0xdc, 0x00, 0xa0, 0xc9, 0x15, 0x06, 0xef}}
  //{732abe75-cd80-11d0-a2db-00aa00a3efff}
  #define CMDSETID_DaVinciDataToolsCommandSet	{0x732abe75, 0xcd80, 0x11d0, {0xa2, 0xdb, 0x00, 0xaa, 0x00, 0xa3, 0xef, 0xff} }
  // {12F1A339-02B9-46e6-BDAF-1071F76056BF}
  #define CMDSETID_WMAppCommand { 0x12f1a339, 0x02b9, 0x46e6, { 0xbd, 0xaf, 0x10, 0x71, 0xf7, 0x60, 0x56, 0xbf } }
 

#endif //!DEFINE_GUID

#ifdef __CTC__
// *** UIContext Guids for use by CTC parser only...
#define UICONTEXT_SolutionBuilding		{ 0xadfc4e60, 0x397, 0x11d1, { 0x9f, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x4f } }
#define UICONTEXT_Debugging			{ 0xadfc4e61, 0x397, 0x11d1, { 0x9f, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x4f } }
#define UICONTEXT_FullScreenMode		{ 0xadfc4e62, 0x397, 0x11d1, { 0x9f, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x4f } }
#define UICONTEXT_DesignMode			{ 0xadfc4e63, 0x397, 0x11d1, { 0x9f, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x4f } }
#define UICONTEXT_NoSolution			{ 0xadfc4e64, 0x397, 0x11d1, { 0x9f, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x4f } }
#define UICONTEXT_SolutionExists                { 0xf1536ef8, 0x92ec, 0x443c, { 0x9e, 0xd7, 0xfd, 0xad, 0xf1, 0x50, 0xda, 0x82 } };
#define UICONTEXT_EmptySolution			{ 0xadfc4e65, 0x397, 0x11d1, { 0x9f, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x4f } }
#define UICONTEXT_SolutionHasSingleProject	{ 0xadfc4e66, 0x397, 0x11d1, { 0x9f, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x4f } }
#define UICONTEXT_SolutionHasMultipleProjects 	{ 0x93694fa0, 0x397, 0x11d1, { 0x9f, 0x4e, 0x0, 0xa0, 0xc9, 0x11, 0x0, 0x4f } }
#define UICONTEXT_CodeWindow		{ 0x8fe2df1d, 0xe0da, 0x4ebe, { 0x9d, 0x5c, 0x41, 0x5d, 0x40, 0xe4, 0x87, 0xb5 } }
#endif //__CTC__

#define guidVSStd97					CMDSETID_StandardCommandSet97
#define CLSID_StandardCommandSet97  CMDSETID_StandardCommandSet97

#define guidVSStd2K					CMDSETID_StandardCommandSet2K
#define CLSID_StandardCommandSet2K  CMDSETID_StandardCommandSet2K
#define CLSID_CTextViewCommandGroup CMDSETID_StandardCommandSet2K
#define CLSID_TCG					CMDSETID_StandardCommandSet2K
#define CLSID_ECG					CMDSETID_StandardCommandSet2K
#define guidDavDataCmdId			CMDSETID_DaVinciDataToolsCommandSet

// Standard editor guid.
#define guidStdEditor   {0x9ADF33D0, 0x8AAD, 0x11d0, {0xB6, 0x06, 0x00, 0xA0, 0xC9, 0x22, 0xE8, 0x51} }

// Standard editor shorthand macros for a more compact and manageable table
#define guidStdEd       guidStdEditor
#define guidStdEdCmd    guidStdEditor:IDG_VS_EDITOR_CMDS
#define guidStdEdBmk    guidStdEditor:IDG_VS_EDITOR_BOOKMARK_CMDS
#define guidStdEdAdv    guidStdEditor:IDG_VS_EDITOR_ADVANCED_CMDS
#define guidStdEdOut    guidStdEditor:IDG_VS_EDITOR_OUTLINING_CMDS
#define guidStdLang     guidStdEditor:IDG_VS_EDITOR_LANGUAGE_INFO
#define guidStdEdIntel  guidStdEditor:IDG_VS_EDITOR_INTELLISENSE_CMDS
#endif //!NOGUIDS

//////////////////////////////////////////////////////////////////////////////
//
// Toolbar Identifiers, created by Visual Studio Shell
//
//////////////////////////////////////////////////////////////////////////////
#define IDM_VS_TOOL_MAINMENU	      0x0000
#define IDM_VS_TOOL_STANDARD	      0x0001
#define IDM_VS_TOOL_WINDOWUI	      0x0002
#define IDM_VS_TOOL_PROJWIN	      0x0003
#define IDM_VS_TOOL_FINDREPLACE       0x0004
#define IDM_VS_TOOL_FULLSCREEN	      0x0005
#define IDM_VS_TOOL_DEBUGGER	      0x0006
//UNUSED 0x0007-0x000a
#define IDM_VS_TOOL_OPENWINDOWS	      0x000b
#define IDM_VS_TOOL_VIEWBAR	      0x000c
#define IDM_VS_TOOL_BUILD             0x000d
#define IDM_VS_TOOL_TEXTEDITOR	      0x000e
#define IDM_VS_TOOL_OBJBROWSER        0x000f
#define IDM_VS_TOOL_CLASSVIEW         0x0010
#define IDM_VS_TOOL_PROPERTIES        0x0011
#define IDM_VS_TOOL_DATA              0x0012
#define IDM_VS_TOOL_SCHEMA            0x0013


//////////////////////////////////////////////////////////////////////////////
// Toolbar ID for customize mode only 
//
// **** NOTE ****  DO NOT add any menu or toolbar that has an ID greater than
//                 IDM_VS_TOOL_ADDCOMMAND, otherwise you WILL break customize
//                 mode. IDM_VS_TOOL_UDEFINED is a very special toolbar.
//                 Do not use or place it anywhere - used by shell only.
//////////////////////////////////////////////////////////////////////////////
#define IDM_VS_TOOL_UNDEFINED	      0xEDFF
#define IDM_VS_TOOL_ADDCOMMAND	      0xEE00

//////////////////////////////////////////////////////////////////////////////
//
// Menu Identifiers, created by Visual Studio Shell
//
//////////////////////////////////////////////////////////////////////////////
#define IDM_VS_MENU_FILE	      0x0080
#define IDM_VS_MENU_EDIT	      0x0081
#define IDM_VS_MENU_VIEW	      0x0082
#define IDM_VS_MENU_PROJECT	      0x0083
#define IDM_VS_MENU_TOOLS	      0x0085
#define IDM_VS_MENU_WINDOW	      0x0086
#define IDM_VS_MENU_ADDINS	      0x0087
#define IDM_VS_MENU_HELP	      0x0088
#define IDM_VS_MENU_DEBUG	      0x0089
#define IDM_VS_MENU_FORMAT            0x008A
#define IDM_VS_MENU_ALLMACROS         0x008B
#define IDM_VS_MENU_BUILD             0x008C

//////////////////////////////////////////////////////////////////////////////
//
// Group Identifiers, created by Visual Studio Shell
//
//////////////////////////////////////////////////////////////////////////////

// Main Menu Bar Groups
#define IDG_VS_MM_FILEEDITVIEW	      0x0101    // File/Edit/View menus go here
#define IDG_VS_MM_PROJECT	      0x0102    // Project menu go here
#define IDG_VS_MM_BUILDDEBUGRUN	      0x0103	// Build/Debug/Run menus go here
#define IDG_VS_MM_TOOLSADDINS	      0x0104	// Tools/Addins menu goes here
#define IDG_VS_MM_WINDOWHELP	      0x0105	// Window/Help menus go here

// All Macros Groups
#define IDG_VS_MM_MACROS              0x010A

// File Menu Groups
#define IDG_VS_FILE_NEW_PROJ_CSCD     0x010E
#define IDG_VS_FILE_ITEM              0x010F
#define IDG_VS_FILE_FILE              0x0110
#define IDG_VS_FILE_ADD               0x0111
#define IDG_VS_FILE_SAVE              0x0112
#define IDG_VS_FILE_RENAME            0x0113
#define IDG_VS_FILE_PRINT             0x0114
#define IDG_VS_FILE_MRU               0x0115
#define IDG_VS_FILE_EXIT              0x0116
#define IDG_VS_FILE_DELETE            0x0117
#define IDG_VS_FILE_SOLUTION          0x0118
#define IDG_VS_FILE_NEW_CASCADE       0x0119
#define IDG_VS_FILE_OPENP_CASCADE     0x011A
#define IDG_VS_FILE_OPENF_CASCADE     0x011B
#define IDG_VS_FILE_ADD_PROJECT       0x011C
#define IDG_VS_FILE_ADD_SLNITEM       0x011D
#define IDG_VS_FILE_FMRU_CASCADE      0x011E
#define IDG_VS_FILE_PMRU_CASCADE      0x011F
#define IDG_VS_FILE_BROWSER           0x0120
#define IDG_VS_FILE_MOVE              0x0121
#define IDG_VS_FILE_MOVE_CASCADE      0x0122
#define IDG_VS_FILE_MOVE_PICKER       0x0123
#define IDG_VS_FILE_MISC              0x0124
#define IDG_VS_FILE_MISC_CASCADE      0x0125

// Edit Menu Groups
#define IDG_VS_EDIT_OBJECTS           0x0128
#define IDG_VS_EDIT_UNDOREDO	      0x0129
#define IDG_VS_EDIT_CUTCOPY	      0x012A
#define IDG_VS_EDIT_SELECT	      0x012B
#define IDG_VS_EDIT_FIND	      0x012C
#define IDG_VS_EDIT_GOTO	      0x012D

// View Menu Groups
#define IDG_VS_VIEW_BROWSER	      0x0130
#define IDG_VS_VIEW_PROPPAGES	      0x0131
#define IDG_VS_VIEW_TOOLBARS	      0x0132
#define IDG_VS_VIEW_FORMCODE	      0x0133
#define IDG_VS_VIEW_DEFINEVIEWS	      0x0134
#define IDG_VS_VIEW_WINDOWS	      0x0135
#define IDG_VS_VIEW_REFRESH           0x0136
#define IDG_VS_VIEW_NAVIGATE          0x0137
#define IDG_VS_VIEW_SYMBOLNAVIGATE    0x0138
#define IDG_VS_VIEW_SMALLNAVIGATE     0x0139
#define IDG_VS_VIEW_OBJBRWSR          0x013A
#define IDG_VS_VIEW_LINKS             0x013B

// Project Menu Groups
#define IDG_VS_PROJ_ADD               0x0140
#define IDG_VS_PROJ_OPTIONS           0x0141
#define IDG_VS_PROJ_REFERENCE         0x0142
#define IDG_VS_PROJ_FOLDER            0x0143
#define IDG_VS_PROJ_UNLOADRELOAD      0x0144
#define IDG_VS_PROJ_ADDCODE           0x0145
#define IDG_VS_PROJ_PROJECT           0x0146
#define IDG_VS_PROJ_ADDREMOVE         0x0147
#define IDG_VS_PROJ_WEB1              0x0148
#define IDG_VS_PROJ_WEB2              0x0149
#define IDG_VS_PROJ_TOOLBAR1          0x014A
#define IDG_VS_PROJ_TOOLBAR2          0x014B
#define IDG_VS_PROJ_MISCADD           0x014C
#define IDG_VS_PROJ_SETTINGS          0x014D

// Run Menu Groups
#define IDG_VS_RUN_START	      0x0150
#define IDG_VS_DBG_STEP		      0x0151
#define IDG_VS_DBG_WATCH	      0x0152
#define IDG_VS_DBG_BRKPTS	      0x0153
#define IDG_VS_DBG_STATEMENT	      0x0154
#define IDG_VS_DBG_ATTACH	      0x0155
#define IDG_VS_DBG_TBBRKPTS	      0x0156
#define IDG_VS_DBG_DBGWINDOWS	      0x0157   // this actually resides on the debugger toolbar

//Tools->External Tools Groups
#define IDG_VS_TOOLS_EXT_CUST         0x0158
#define IDG_VS_TOOLS_EXT_TOOLS        0x0159

// Tools Menu Groups
#define IDG_VS_TOOLS_OPTIONS	      0x015A
#define IDG_VS_TOOLS_OTHER2	      0x015B
#define IDG_VS_TOOLS_OBJSUBSET        0x015C

// Addins Menu Groups
#define IDG_VS_ADDIN_BUILTIN	      0x015D
#define IDG_VS_ADDIN_MANAGER	      0x015E

// Window Menu Groups
#define IDG_VS_WINDOW_NEW	      0x0160
#define IDG_VS_WINDOW_ARRANGE	      0x0161
#define IDG_VS_WINDOW_LIST	      0x0162
#define IDG_VS_WINDOW_NAVIGATION      0x0163

// Help Menu Groups
#define IDG_VS_HELP_SUPPORT	      0x016A
#define IDG_VS_HELP_ABOUT 	      0x016B

// Standard Toolbar Groups
#define IDG_VS_TOOLSB_NEWADD	      0x0170
#define IDG_VS_TOOLSB_SAVEOPEN	      0x0171
#define IDG_VS_TOOLSB_CUTCOPY	      0x0172
#define IDG_VS_TOOLSB_UNDOREDO	      0x0173
#define IDG_VS_TOOLSB_RUNBUILD	      0x0174
#define IDG_VS_TOOLSB_WINDOWS	      0x0175  // don't use
#define IDG_VS_TOOLSB_GAUGE	      0x0176
#define IDG_VS_TOOLSB_SEARCH	      0x0177
#define IDG_VS_TOOLSB_NEWWINDOWS      0x0178
#define IDG_VS_TOOLSB_NAVIGATE        0x0179

// Window UI Toolbar Groups
#define IDG_VS_WINDOWUI_LOADSAVE      0x017A

// Open Windows Toolbar Groups
#define IDG_VS_OPENWIN_WINDOWS	      0x017B

// View Bar Toolbar Groups
#define IDG_VS_VIEWBAR_VIEWS	      0x017C

// Watch context menu groups
#define IDG_VS_WATCH_EDITADDDEL	      0x0180
//#define IDG_VS_WATCH_COLLAPSE	      0x0181
#define IDG_VS_WATCH_PROCDEFN	      0x0182
#define IDG_VS_WATCH_STARTEND	      0x0183

// Thread context menu groups
#define IDG_VS_THREAD_SUSPENDRESUME   0x0184

// Hexadecimal group
#define IDG_VS_DEBUG_DISPLAYRADIX     0x0185

// Treegrid context menu
#define IDG_VS_TREEGRID		      0x0186

// Immediate context menu groups
#define IDG_VS_IMMD_OBPROCDEFN	      0x0188

// Docking / Hide Pane Group
#define IDG_VS_DOCKHIDE		      0x0190

// Thread context menu groups
#define IDG_VS_CALLST_RUNTOCURSOR     0x0191

// MenuDesigner Context Menu Groups
#define IDG_VS_MNUDES_CUTCOPY	      0x0195
#define IDG_VS_MNUDES_INSERT	      0x0196
#define IDG_VS_MNUDES_EDITNAMES	      0x0197
#define IDG_VS_MNUDES_VIEWCODE	      0x0198
#define IDG_VS_MNUDES_PROPERTIES      0x0199

#define IDG_VS_MNUDES_UNDOREDO	      0x019A

// Window Menu Cascade groups
#define IDG_VS_WNDO_OTRWNDWS0         0x019E
#define IDG_VS_WNDO_OTRWNDWS1         0x019F
#define IDG_VS_WNDO_OTRWNDWS2         0x01A0
#define IDG_VS_WNDO_OTRWNDWS3         0x01A1
#define IDG_VS_WNDO_OTRWNDWS4         0x01A2
#define IDG_VS_WNDO_OTRWNDWS5         0x01A3
#define IDG_VS_WNDO_OTRWNDWS6         0x01A4
#define IDG_VS_WNDO_WINDOWS1	      0x01A5
#define IDG_VS_WNDO_WINDOWS2	      0x01A6
#define IDG_VS_WNDO_DBGWINDOWS	      IDG_VS_WNDO_WINDOWS1

// OLE Verbs Menu Cascade groups
#define IDG_VS_EDIT_OLEVERBS          0x01A8

// PropBrs Context menu groups
#define IDG_VS_PROPBRS_MISC	      0x01AA

// Output Window Pane Context menu groups
#define IDG_VS_OUTPUTPANECOPY	      0x01AC
#define IDG_VS_OUTPUTPANECLEAR	      0x01AD
#define IDG_VS_OUTPUTPANEGOTO	      0x01AE

// New Toolbox Context Menu groups   
#define IDG_VS_TOOLBOX_TBX	      0x01B0
#define IDG_VS_TOOLBOX_ITEM	      0x01B1
#define IDG_VS_TOOLBOX_TAB	      0x01B2
#define IDG_VS_TOOLBOX_MOVE	      0x01B3
#define IDG_VS_TOOLBOX_RENAME	      0x01B4

// Miscellaneous Files project context menu groups
#define IDG_VS_MISCFILES_PROJ         0x01B8

// Miscellaneous Files project item context menu groups
#define IDG_VS_MISCFILES_PROJITEM     0x01BA

// Solution Items project item context menu groups
#define IDG_VS_SOLNITEMS_PROJ         0x01BC
#define IDG_VS_SOLNITEMS_PROJITEM     0x01BD

// Stub (unloaded/placeholder) project context menu groups
#define IDG_VS_STUB_PROJECT           0x01BE

// Code Window context menu groups
#define IDG_VS_CODEWIN_TEXTEDIT		0x01C0
#define IDG_VS_CODEWIN_DEBUG_BP		0x01C1
#define IDG_VS_CODEWIN_DEBUG_WATCH	0x01C2
#define IDG_VS_CODEWIN_DEBUG_STEP	0x01C3
#define IDG_VS_CODEWIN_MARKER		0x01C4
#define IDG_VS_CODEWIN_OPENURL		0x01C5
#define IDG_VS_CODEWIN_SHORTCUT		0x01C6
#define IDG_VS_CODEWIN_INTELLISENSE     0x02B0
#define IDG_VS_CODEWIN_NAVIGATETOLOCATION         0x02B1
#define IDG_VS_CODEWIN_NAVIGATETOFILE 0x02B2
#define IDG_VS_CODEWIN_OUTLINING    0x02B3
#define IDG_VS_CODEWIN_CTXT_OUTLINING 0x02B4
// Task List context menu groups
#define IDG_VS_TASKLIST		      0x01C7

// cascading Task list menu groups
#define IDG_VS_TASKLIST_SORT		      0x01C8
#define IDG_VS_TASKLIST_NEXTPREV_ERR	  0x01C9
#define IDG_VS_TASKLIST_FILTER		      0x01CA
#define IDG_VS_TASKLIST_FILTER_CATEGORY	  0x01CB
#define IDG_VS_TASKLIST_FILTER_FILE	      0x01CC
#define IDG_VS_TASKLIST_FILTER_CHECKSTATE 0x01CD
#define IDG_VS_VIEWMENU_SHOWTASKS	      0x01CE

// Full screen menu group
#define IDG_VS_FULLSCREEN		0x01D0

// Full Screen toolbar group
#define IDG_VS_FULLSCREENBAR		0x01D1

// Build toolbar group
#define IDG_VS_BUILDBAR                 0x01D2

// Project Window Toolbar group
#define IDG_VS_PROJWIN1			0x01D5
#define IDG_VS_PROJWINEND		0x01D6

// Find and replace toolbar group
#define IDG_VS_FIND_NEW                 0x01DA
#define IDG_VS_FIND_OPTIONS             0x01DB
#define IDG_VS_FIND_OTHER               0x01DC

// Solution Node ctxt menu groups     
#define IDG_VS_SOLNNODE_CTXT_TOP	0x01E0
#define IDG_VS_SOLNNODE_CTXT_BOTTOM	0x01E1

// Project Window Default group
#define IDG_VS_PROJWIN_NODE_CTXT_TOP	0x01E2
#define IDG_VS_PROJWIN_NODE_CTXT_BOTTOM	0x01E3
#define IDG_VS_PROJWIN_ITEM_CTXT_TOP	0x01E4
#define IDG_VS_PROJWIN_ITEM_CTXT_BOTTOM	0x01E5

// Document Window Default groups	
#define IDG_VS_DOCWINDOW_CTXT_TOP	0x01E6
#define IDG_VS_DOCWINDOW_CTXT_BOTTOM	0x01E7

// Tool Window Default groups
#define IDG_VS_TOOLWINDOW_CTXT_TOP	0x01E8
#define IDG_VS_TOOLWINDOW_CTXT_BOTTOM	0x01E9

// EZ MDI groups
#define IDG_VS_EZ_TILE                  0x01EA
#define IDG_VS_EZ_CANCEL                0x01EB
#define IDG_VS_EZ_DOCWINDOWOPS          0x01EC

// Debugger Group
#define IDG_VS_TOOL_DEBUGGER	        0x0200

// Shell defined context menu groups
#define IDG_VS_CTXT_MULTIPROJ_BUILD     0x0201
#define IDG_VS_CTXT_PROJECT_ADD         0x0202
#define IDG_VS_CTXT_PROJECT_ADD_ITEMS   0x0203
#define IDG_VS_CTXT_PROJECT_DEBUG	0x0204
#define IDG_VS_CTXT_PROJECT_START	0x0205
#define IDG_VS_CTXT_PROJECT_BUILD	0x0206
#define IDG_VS_CTXT_PROJECT_TRANSFER	0x0207
#define IDG_VS_CTXT_ITEM_VIEWOBJECT	0x0208
#define IDG_VS_CTXT_ITEM_OPEN		0x0209
#define IDG_VS_CTXT_ITEM_TRANSFER	0x020A
#define IDG_VS_CTXT_ITEM_VIEWBROWSER	0x020B
#define IDG_VS_CTXT_SAVE		0x020C
#define IDG_VS_CTXT_ITEM_PRINT		0x020D
#define IDG_VS_CTXT_ITEM_PROPERTIES	0x020E
#define IDG_VS_CTXT_SCC			0x020F 
#define IDG_VS_CTXT_ITEM_RENAME		0x0210
#define IDG_VS_CTXT_PROJECT_RENAME	0x0211
#define IDG_VS_CTXT_SOLUTION_RENAME	0x0212
#define IDG_VS_CTXT_ITEM_SAVE		IDG_VS_CTXT_SAVE
#define IDG_VS_CTXT_PROJECT_SAVE	0x0213
#define IDG_VS_CTXT_PROJECT_PROPERTIES	0x0214
#define IDG_VS_CTXT_SOLUTION_PROPERTIES	0x0215
#define IDG_VS_CTXT_ITEM_SCC		IDG_VS_CTXT_SCC
#define IDG_VS_CTXT_PROJECT_SCC		0x0216
#define IDG_VS_CTXT_SOLUTION_SCC	0x0217

#define IDG_VS_CTXT_SOLUTION_SAVE	0x0218
#define IDG_VS_CTXT_SOLUTION_BUILD	0x0219
#define IDG_VS_UNUSED			0x021A  // unused group for hidden cmds
#define IDG_VS_CTXT_SOLUTION_START      0x021B
#define IDG_VS_CTXT_SOLUTION_TRANSFER   0x021C
#define IDG_VS_CTXT_SOLUTION_ADD_PROJ   0x021D
#define IDG_VS_CTXT_SOLUTION_ADD_ITEM   0x021E
#define IDG_VS_CTXT_SOLUTION_DEBUG      0x021F

#define IDG_VS_CTXT_DOCOUTLINE		0x0220
#define IDG_VS_CTXT_NOCOMMANDS          0x0221

#define IDG_VS_TOOLS_CMDLINE		0x0222

#define IDG_VS_CTXT_CMDWIN_MARK		0x0223

#define IDG_VS_CTXT_AUTOHIDE		0x0224

//External tools context menu groups
#define IDG_VS_EXTTOOLS_CURARGS         0x0225
#define IDG_VS_EXTTOOLS_PROJARGS        0x0226
#define IDG_VS_EXTTOOLS_SLNARGS         0x0227
#define IDG_VS_EXTTOOLS_CURDIRS         0x0228
#define IDG_VS_EXTTOOLS_PROJDIRS        0x0229
#define IDG_VS_EXTTOOLS_SLNDIRS         0x022A
#define IDG_VS_EXTTOOLS_TARGETARGS      0x022B
#define IDG_VS_EXTTOOLS_EDITORARGS      0x022C
#define IDG_VS_EXTTOOLS_TARGETDIRS      0x022D

#define IDG_VS_CTXT_ITEM_VIEW           0x022E
#define IDG_VS_CTXT_DELETE              0x022F
#define IDG_VS_CTXT_FOLDER_TRANSFER     0x0230
#define IDG_VS_CTXT_MULTISELECT_TRANSFER  0x0231
#define IDG_VS_CTXT_PROJECT_DEPS        0x0232
#define IDG_VS_CTXT_SOLUTION_ADD        0x0233
#define IDG_VS_CTXT_PROJECT_CONFIG      0x0234

// New File/Add New Item Open button drop-down menu
#define IDG_VS_OPENDROPDOWN_MENU        0x0235

// Object search menu groups
//RESERVED: 0x0235 - 0x0237
#define IDG_VS_OBJSEARCH_NAVIGATE     0x0238
#define IDG_VS_OBJSEARCH_EDIT         0x0239

// Context menu group for reloading an unloaded project
#define IDG_VS_CTXT_PROJECT_RELOAD    0x023A

// Classview menu groups
#define IDG_VS_CLASSVIEW_FOLDERS      0x0240  // Used in toolbar
#define IDG_VS_CLASSVIEW_FOLDERS2     0x0241  // Used in context menu
#define IDG_VS_CLASSVIEW_DISPLAY      0x0242
#define IDG_VS_CLASSVIEW_SEARCH       0x0243
#define IDG_VS_CLASSVIEW_EDIT         0x0244
#define IDG_VS_CLASSVIEW_NAVIGATION   0x0245
#define IDG_VS_CLASSVIEW_SHOWINFO     0x0247
#define IDG_VS_CLASSVIEW_PROJADD      0x0248
#define IDG_VS_CLASSVIEW_ITEMADD      0x0249
#define IDG_VS_CLASSVIEW_GROUPING     0x024a
#define IDG_VS_CLASSVIEW_PROJWIZARDS  0x024b
#define IDG_VS_CLASSVIEW_ITEMWIZARDS  0x024c
#define IDG_VS_CLASSVIEW_PROJADDITEMS 0x024d
#define IDG_VS_CLASSVIEW_FOLDERS_EDIT 0x024e

// Regular Expression Context menu groups
#define IDG_VS_FINDREGEXNORM0	      0x024f
#define IDG_VS_FINDREGEXNORM1	      0x0250
#define IDG_VS_FINDREGEXHELP	      0x0251
#define IDG_VS_REPLACEREGEXNORM	      0x0252
#define IDG_VS_REPLACEREGEXHELP	      0x0253
#define IDG_VS_FINDWILDNORM	      0x0254
#define IDG_VS_FINDWILDHELP	      0x0255
#define IDG_VS_REPLACEWILDNORM	      0x0256
#define IDG_VS_REPLACEWILDHELP	      0x0257
#define IDG_VS_FINDREGEXNORM2	      0x0258
#define IDG_VS_FINDREGEXNORM3	      0x0259

// Back/Forward
#define IDG_VS_CSCD_NAVIGATE	      0x0260

// Object Browser menu groups
#define IDG_VS_OBJBROWSER_SUBSETS     0x0270
#define IDG_VS_OBJBROWSER_DISPLAY     0x0271
#define IDG_VS_OBJBROWSER_DISPLAY2    0x0272
#define IDG_VS_OBJBROWSER_SEARCH      0x0273
#define IDG_VS_OBJBROWSER_SEARCH2     0x0274
#define IDG_VS_OBJBROWSER_NAVIGATION  0x0275
#define IDG_VS_OBJBROWSER_EDIT        0x0276
#define IDG_VS_OBJBROWSER_OBJGRP      0x0277
#define IDG_VS_OBJBROWSER_MEMGRP      0x0278
#define IDG_VS_OBJBROWSER_GROUPINGS   0x0279

// Build Menu groups
#define IDG_VS_BUILD_SOLUTION         0x0280
#define IDG_VS_BUILD_SELECTION        0x0281
#define IDG_VS_BUILD_MISC             0x0282
#define IDG_VS_BUILD_CANCEL           0x0283
#define IDG_VS_BUILD_CASCADE          0x0284
#define IDG_VS_REBUILD_CASCADE        0x0285
#define IDG_VS_CLEAN_CASCADE          0x0286
#define IDG_VS_DEPLOY_CASCADE         0x0287
#define IDG_VS_BUILD_PROJPICKER       0x0288
#define IDG_VS_REBUILD_PROJPICKER     0x0289
#define IDG_VS_CLEAN_PROJPICKER       0x0290
#define IDG_VS_DEPLOY_PROJPICKER      0x0291

#define IDG_VS_CTXT_CMDWIN_CUTCOPY    0x0292

// Additional Shell defined context menu groups
#define IDG_VS_CTXT_PROJECT_ADD_FORMS 0x02A0
#define IDG_VS_CTXT_PROJECT_ADD_MISC  0x02A1
#define IDG_VS_CTXT_ITEM_INCLUDEEXCLUDE 0x02A2
#define IDG_VS_CTXT_FOLDER_ADD        0x02A3
#define IDG_VS_CTXT_REFROOT_ADD       0x02A4
#define IDG_VS_CTXT_REFROOT_TRANSFER  0x02A5
#define IDG_VS_CTXT_WEBREFFOLDER_ADD  0x02A6
#define IDG_VS_CTXT_COMPILELINK       0x02A7

//0x02B0 used for Codewindow context menu
//0x02B1 used for Codewindow context menu
//0x02B2 used for Codewindow context menu

// Properties panel groups
#define IDG_VS_PROPERTIES_SORT        0x02BA
#define IDG_VS_PROPERTIES_PAGES       0x02BB

//////////////////////////////////////////////////////////////////////////////
//
// Groups for Menu Controllers
//
//////////////////////////////////////////////////////////////////////////////
#define IDG_VS_MNUCTRL_NEWITM                 0x02C0
#define IDG_VS_MNUCTRL_NEWITM_BOTTOM          0x02C1
#define IDG_VS_MNUCTRL_NEWPRJ                 0x02C2
#define IDG_VS_MNUCTRL_NEWPRJ_BOTTOM          0x02C3
#define IDG_VS_MNUCTRL_NAVBACK                0x02C4
#define IDG_VS_MNUCTRL_OBSEARCHOPTIONS        0x02C5

//////////////////////////////////////////////////////////////////////////////
//
// Cascading Menu Identifiers, created by Visual Studio Shell
//
//////////////////////////////////////////////////////////////////////////////
#define IDM_VS_CSCD_WINDOWS		      0x0300
#define IDM_VS_CSCD_TASKLIST_SORT	      0x0301
#define IDM_VS_CSCD_TASKLIST_FILTER	      0x0302
#define IDM_VS_CSCD_TASKLIST_VIEWMENU_FILTER  0x0303
#define IDM_VS_CSCD_DEBUGWINDOWS	      0x0304
#define IDM_VS_EDITOR_CSCD_OUTLINING_MENU 0x0305
#define IDM_VS_CSCD_COMMANDBARS               0x0306
#define IDM_VS_CSCD_OLEVERBS                  0x0307
#define IDM_VS_CSCD_NEW                       0x0308
#define IDM_VS_CSCD_OPEN                      0x0309
#define IDM_VS_CSCD_ADD                       0x030A
#define IDM_VS_CSCD_MNUDES                    0x030B
#define IDM_VS_CSCD_FILEMRU                   0x030C
#define IDM_VS_CSCD_PROJMRU                   0x030D
#define IDM_VS_CSCD_NEW_PROJ                  0x030E
#define IDM_VS_CSCD_MOVETOPRJ                 0x030F

#define IDM_VS_CSCD_NAVIGATE1		      0x0310
#define IDM_VS_CSCD_NAVIGATE2		      0x0311
#define IDM_VS_CSCD_NAVIGATE3		      0x0312
#define IDM_VS_CSCD_NAVIGATE4		      0x0313
#define IDM_VS_CSCD_NAVIGATE5		      0x0314
#define IDM_VS_CSCD_NAVIGATE6		      0x0315
#define IDM_VS_CSCD_NAVIGATE7		      0x0316
#define IDM_VS_CSCD_NAVIGATE8		      0x0317
#define IDM_VS_CSCD_NAVIGATE9		      0x0318
#define IDM_VS_CSCD_NAVIGATE10		      0x0319
#define IDM_VS_CSCD_NAVIGATE11		      0x031A
#define IDM_VS_CSCD_NAVIGATE12		      0x031B
#define IDM_VS_CSCD_NAVIGATE13		      0x031C
#define IDM_VS_CSCD_NAVIGATE14		      0x031D
#define IDM_VS_CSCD_NAVIGATE15		      0x031E
#define IDM_VS_CSCD_NAVIGATE16		      0x031F
#define IDM_VS_CSCD_NAVIGATE17		      0x0320
#define IDM_VS_CSCD_NAVIGATE18		      0x0321
#define IDM_VS_CSCD_NAVIGATE19		      0x0322
#define IDM_VS_CSCD_NAVIGATE20		      0x0323
#define IDM_VS_CSCD_NAVIGATE21		      0x0324
#define IDM_VS_CSCD_NAVIGATE22		      0x0325
#define IDM_VS_CSCD_NAVIGATE23		      0x0326
#define IDM_VS_CSCD_NAVIGATE24		      0x0327
#define IDM_VS_CSCD_NAVIGATE25		      0x0328
#define IDM_VS_CSCD_NAVIGATE26		      0x0329
#define IDM_VS_CSCD_NAVIGATE27		      0x032A
#define IDM_VS_CSCD_NAVIGATE28		      0x032B
#define IDM_VS_CSCD_NAVIGATE29		      0x032C
#define IDM_VS_CSCD_NAVIGATE30		      0x032D
#define IDM_VS_CSCD_NAVIGATE31		      0x032E
#define IDM_VS_CSCD_NAVIGATE32		      0x032F

#define IDM_VS_CSCD_BUILD                     0x0330
#define IDM_VS_CSCD_REBUILD                   0x0331
#define IDM_VS_CSCD_CLEAN                     0x0332
#define IDM_VS_CSCD_DEPLOY                    0x0333
#define IDM_VS_CSCD_MISCFILES                 0x0334

#define IDM_VS_CSCD_EXTTOOLS                  0x0340

#define IDM_VS_CSCD_SOLUTION_ADD              0x0350
#define IDM_VS_CSCD_SOLUTION_DEBUG            0x0351
#define IDM_VS_CSCD_PROJECT_ADD               0x0352
#define IDM_VS_CSCD_PROJECT_DEBUG             0x0353
// ClassView cascades
#define IDM_VS_CSCD_CV_PROJADD                0x0354
#define IDM_VS_CSCD_CV_ITEMADD                0x0355

//////////////////////////////////////////////////////////////////////////////
//
// Context Menu Identifiers, created by Visual Studio Shell
//
//////////////////////////////////////////////////////////////////////////////
#define IDM_VS_CTXT_PROJNODE	      0x0402
#define IDM_VS_CTXT_PROJWIN	      0x0403
#define IDM_VS_CTXT_PROJWINBREAK      0x0404
// UNUSED 0x0405 
#define IDM_VS_CTXT_DOCKEDWINDOW      0x0406
#define IDM_VS_CTXT_MENUDES	      0x0407
#define IDM_VS_CTXT_PROPBRS	      0x0408
#define IDM_VS_CTXT_TOOLBOXITEM	      0x0409
#define IDM_VS_CTXT_TOOLBOXTAB	      0x040A
#define IDM_VS_CTXT_CODEWIN	      0x040D
#define IDM_VS_CTXT_TASKLIST	      0x040E
#define IDM_VS_CTXT_OUTPUTPANE	      0x0411
#define IDM_VS_CTXT_STUBPROJECT	      0x0412
#define IDM_VS_CTXT_SOLNNODE          0x0413

// Slctn of one or more ProjNodes & SolnNode (doesn't involve ProjItem nodes)
#define IDM_VS_CTXT_XPROJ_SLNPROJ     0x0415
// Slctn of one or more ProjItems & SolnNode (min 1 ProjItem & may involve ProjNodes too)
#define IDM_VS_CTXT_XPROJ_SLNITEM     0x0416
// Selection of one more Project Nodes and one or more Project Items across projects (does not involve Solution Node) 
#define IDM_VS_CTXT_XPROJ_PROJITEM    0x0417
// Selection of two or more Project Nodes (does not involve the Solution Node or Project Item Nodes)
#define IDM_VS_CTXT_XPROJ_MULTIPROJ   0x0418
// Selection of one more Project Items across projects (does not involve Project Nodes or Solution Node)
#define IDM_VS_CTXT_XPROJ_MULTIITEM   0x0419

#define IDM_VS_CTXT_NOCOMMANDS        0x041A

// Miscellaneous Files project and item context menus
#define IDM_VS_CTXT_MISCFILESPROJ     0x041B
#define IDM_VS_CTXT_MISCFILESITEM     0x041C

// Solution Items project and item context menus
#define IDM_VS_CTXT_SOLNITEMSPROJ     0x041D
#define IDM_VS_CTXT_SOLNITEMSITEM     0x041E

// Command Window context menu
#define IDM_VS_CTXT_COMMANDWINDOW     0x041F

// AutoHide context menu on channel
#define IDM_VS_CTXT_AUTOHIDE	      0x0420

//0x0421-0x0423 unused

#define IDM_VS_CTXT_FIND_REGEX	      0x0424
#define IDM_VS_CTXT_REPLACE_REGEX     0x0425
#define IDM_VS_CTXT_FIND_WILD         0x0426
#define IDM_VS_CTXT_REPLACE_WILD      0x0427
#define IDM_VS_CTXT_EXTTOOLSARGS      0x0428
#define IDM_VS_CTXT_EXTTOOLSDIRS      0x0429

// EZMdi context menus
#define IDM_VS_CTXT_EZTOOLWINTAB      0x042A
#define IDM_VS_CTXT_EZDOCWINTAB       0x042B
#define IDM_VS_CTXT_EZDRAGGING        0x042C
#define IDM_VS_CTXT_EZCHANNEL         0x042D

// New File/Add New Item Open button drop-down menu
#define IDM_VS_CTXT_OPENDROPDOWN      0x042E

// Common Item Node context menu
#define IDM_VS_CTXT_ITEMNODE          0x0430

// Folder Node context menu
#define IDM_VS_CTXT_FOLDERNODE        0x0431

//////////////////////////////////////////////////////////////////////////////
// ClassView context menus
#define IDM_VS_CTXT_CV_PROJECT        0x0432
#define IDM_VS_CTXT_CV_ITEM           0x0433
#define IDM_VS_CTXT_CV_FOLDER         0x0434
#define IDM_VS_CTXT_CV_GROUPINGFOLDER 0x0435
#define IDM_VS_CTXT_CV_MULTIPLE       0x0436

// Object Browsing tools context menus
#define IDM_VS_CTXT_OBJBROWSER_OBJECTS 0x0437
#define IDM_VS_CTXT_OBJBROWSER_MEMBERS 0x0438
#define IDM_VS_CTXT_OBJBROWSER_DESC   0x0439
#define IDM_VS_CTXT_OBJSEARCH         0x0440

//////////////////////////////////////////////////////////////////////////////
// Reference context menus
// Reference Root Node context menu
#define IDM_VS_CTXT_REFERENCEROOT     0x0450
// Reference Item context menu
#define IDM_VS_CTXT_REFERENCE         0x0451
// Web Reference Folder context menu
#define IDM_VS_CTXT_WEBREFFOLDER      0x0452

//////////////////////////////////////////////////////////////////////////////
// Right drag menu group
#define IDM_VS_CTXT_RIGHT_DRAG        0x0460
#define IDG_VS_CTXT_RIGHT_DRAG1       0x0461
#define IDG_VS_CTXT_RIGHT_DRAG2       0x0462

//////////////////////////////////////////////////////////////////////////////
//
// Menu Controller dentifiers, created by Visual Studio Shell
//
//////////////////////////////////////////////////////////////////////////////
#define IDM_VS_MNUCTRL_NEWITM	      0x0500
#define IDM_VS_MNUCTRL_NEWPRJ	      0x0501
#define IDM_VS_MNUCTRL_OTRWNDWS	      0x0502
#define IDM_VS_MNUCTRL_NAVBACK        0x0503
#define IDM_VS_MNUCTRL_OBSEARCHOPTS   0x0504
#define IDM_VS_MNUCTRL_CVGROUPING     0x0505
#define IDM_VS_MNUCTRL_OBGRPOBJS      0x0506
#define IDM_VS_MNUCTRL_OBGRPMEMS      0x0507

// Text editor toolbar groups
#define IDG_VS_EDITTOOLBAR_COMPLETION 0x0550
#define IDG_VS_EDITTOOLBAR_INDENT     0x0551
#define IDG_VS_EDITTOOLBAR_COMMENT    0x0552
#define IDG_VS_EDITTOOLBAR_TEMPBOOKMARKS    0x0553

// Format Menu groups
#define IDG_VS_FORMAT_STYLE     0x0569
#define IDG_VS_FORMAT_COLOR     0x056A
#define IDG_VS_FORMAT_PARAGRAPH 0x056B
#define IDG_VS_FORMAT_INDENT    0x056C
#define IDG_VS_FORMAT_GRID      0x0554
#define IDG_VS_FORMAT_SPACE     0x0555
#define IDG_VS_FORMAT_CENTER    0x0556
#define IDG_VS_FORMAT_ORDER     0x0557
#define IDG_VS_FORMAT_ALIGN     0x0567
#define IDG_VS_FORMAT_LOCK      0x0558
#define IDG_VS_FORMAT_ELEMENT   0x056D
#define IDG_VS_FORMAT_STYLEORG  0x056E

// Format Align menu groups
#define IDG_VS_FORMAT_ALIGN_X     0x0559
#define IDG_VS_FORMAT_ALIGN_Y     0x055A
#define IDG_VS_FORMAT_ALIGN_GRID  0x055B

// Format Size menu groups
#define IDG_VS_FORMAT_SIZE        0x055C

// Format Space menu groups
#define IDG_VS_FORMAT_SPACE_X     0x055D
#define IDG_VS_FORMAT_SPACE_Y     0x055E

// Format Center menu groups
#define IDG_VS_FORMAT_CENTER_CMDS 0x055F

// Format Order menu groups
#define IDG_VS_FORMAT_ORDER_CMDS  0x0560

// Format cascaded menus
#define IDM_VS_CSCD_FORMAT_FONT      0x056F
#define IDM_VS_CSCD_FORMAT_JUSTIFY   0x0570
#define IDM_VS_CSCD_FORMAT_ALIGN     0x0561
#define IDM_VS_CSCD_FORMAT_SIZE      0x0562
#define IDM_VS_CSCD_FORMAT_SPACE_X   0x0563
#define IDM_VS_CSCD_FORMAT_SPACE_Y   0x0564
#define IDM_VS_CSCD_FORMAT_CENTER    0x0565
#define IDM_VS_CSCD_FORMAT_ORDER     0x0566

// View menu groups
#define IDG_VS_VIEW_TABORDER         0x0568
#define IDG_VS_VIEW_OPTIONS          0x0571


// 0x0569 used in IDG_VS_FORMAT_STYLE above
// 0x056A used in IDG_VS_FORMAT_COLOR above
// 0x056B used in IDG_VS_FORMAT_PARAGRAPH above
// 0x056C used in IDG_VS_FORMAT_INDENT above
// 0x056D used in IDG_VS_FORMAT_ELEMENT above
// 0x056E used in IDG_VS_FORMAT_STYLEORG above
// 0x056F used in IDM_VS_CSCD_FORMAT_FONT above
// 0x0570 used in IDM_VS_CSCD_FORMAT_JUSTIFY above
// 0x0571 used in IDG_VS_VIEW_OPTIONS above


// Format Paragraph menu groups
#define IDG_VS_FORMAT_FONTFACE       0x0572
#define IDG_VS_FORMAT_FONTSCRIPT     0x0573
#define IDG_VS_FORMAT_JUSTIFY        0x0574

// Table Menu
#define IDM_VS_TABLE_MENU            0x0575

// Table cascaded menus
#define IDM_VS_CSCD_TABLE_INSERT     0x0576
#define IDM_VS_CSCD_TABLE_DELETE     0x0577
#define IDM_VS_CSCD_TABLE_SELECT     0x0578

// Table menu groups
#define IDG_VS_TABLE_MAIN            0x0579
#define IDG_VS_TABLE_INSERT_1        0x057A
#define IDG_VS_TABLE_INSERT_2        0x057B
#define IDG_VS_TABLE_INSERT_3        0x057C
#define IDG_VS_TABLE_INSERT_4        0x057D
#define IDG_VS_TABLE_DELETE          0x057E
#define IDG_VS_TABLE_SELECT          0x057F

// Frame Set Menu
#define IDM_VS_FRAMESET_MENU         0x0580

// Frame Set Menu groups
#define IDG_VS_FRAME_WHOLE           0x0581
#define IDG_VS_FRAME_INDV            0x0582
#define IDG_VS_FRAME_NEW             0x0583

// Tools Menu groups
#define IDG_VS_TOOLS_EDITOPT         0x0584

// Insert Menu
#define IDM_VS_INSERT_MENU           0x0585

// Insert Menu groups
#define IDG_VS_INSERT_TAGS           0x0586
#define IDG_VS_INSERT_TAGS2          0x0587

// Script Block Menu
#define IDM_VS_SCRIPTBLOCK           0x0588

// Script Block Group
#define IDG_VS_SCRIPTBLOCK           0x0589

// Project cascaded menus
#define IDM_VS_CSCD_PROJECT_WEB      0x0600


///////////////////////////////////////////////
//
// Editor menu groups
//
///////////////////////////////////////////////
#define IDG_VS_EDITOR_CMDS           0x3E8A
#define IDG_VS_EDITOR_BOOKMARK_CMDS  0x3E8B
#define IDG_VS_EDITOR_ADVANCED_CMDS  0x3E8F
#define IDG_VS_EDITOR_OUTLINING_CMDS 0x3E90
#define IDG_VS_EDITOR_LANGUAGE_INFO  0x3E93
#define IDG_VS_EDITOR_INTELLISENSE_CMDS 0x3E94

#define IDM_VS_EDITOR_BOOKMARK_MENU  0x3E9E
#define IDM_VS_EDITOR_ADVANCED_MENU  0x3EA0
#define IDM_VS_EDITOR_OUTLINING_MENU 0x3EA1
#define IDM_VS_EDITOR_INTELLISENSE_MENU 0x3EA2
#define IDM_VS_EDITOR_FIND_MENU      0x3EA3
#endif // _VSSHLIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsshelluuids.h ===
#pragma once

//                                                    new                                 old
#define uuid_IVsPackage                           D4F3F4B1-E900-4e51-ADB3-D532348F83CB  //7d960b00-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsToolWindowFactory                 A7A1C907-C3D2-4acb-9114-4EE23B6FCF7E  //94E6E7DE-F418-11d2-B6FA-00C04F9901D1
#define uuid_IVsPersistSolutionOpts               53BA0F89-24DD-46e1-A7D6-ED24C039FBC4  //45CF6805-93EB-11D0-AF4C-00A0C90F9DE6
#define uuid_IVsPersistSolutionProps              0D0E68EA-C910-45a7-8C24-7BBFA7D2D201  //45CF6806-93EB-11D0-AF4C-00A0C90F9DE6
#define uuid_IVsSolutionPersistence               67A65088-52F3-4c47-B829-1B53A112E8DC  //45CF6807-93EB-11D0-AF4C-00A0C90F9DE6
#define uuid_IVsProjectFactory                    33FCD00A-BD45-403c-9C66-07BA9A923501  //7d960b05-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsNonSolutionProjectFactory         8CBFFBBE-241E-4b9c-9926-C06F7374386C  //BC798C3A-4EB9-11d3-B2BF-00C04F688E57
#define uuid_IVsRegisterProjectTypes              F08400BB-0960-47f4-9E12-591DBF370546  //7d960b06-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsOwnedProjectFactory               E4197123-1086-4d51-B2D5-903F4D61C5AA  //70F026F7-E043-4634-9DFF-C1ED96C264D6
#define uuid_IVsHierarchy                         59B2D1D0-5DB0-4f9f-9609-13F0168516D6  //7d960b01-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsUIHierarchy                       E82609EA-5169-47f4-91D0-6957272CBE9F  //7d960b02-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsHierarchyEvents                   6DDD8DC3-32B2-4bf1-A1E1-B6DA40526D1E  //7d960b03-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsParentHierarchy                   8FE0E50A-785A-4a50-8EDB-1D054D68EF87  //92D73940-C541-11d2-8598-006097C68E81
#define uuid_IVsSolution                          7F7CD0DB-91EF-49dc-9FA9-02D128515DD4  //054AECC1-AC4D-11d0-AF54-00A0C90F9DE6
#define uuid_IVsSolution2                         95C6A090-BB9E-4bf2-B0BE-F1D04F0ECEA3  //95C6A090-BB9E-4bf2-B0BE-F1D04F0ECEA3 // new interface
#define uuid_IVsSolutionEvents                    A8516B56-7421-4dbd-AB87-57AF7A2E85DE  //054AECC2-AC4D-11d0-AF54-00A0C90F9DE6
#define uuid_IVsSolutionEvents2                   A711DF67-B00A-4e82-A990-51B2B450EA0F  //710932AF-2116-4cbd-8E48-0C5944EF0C6A
#define uuid_IVsSolutionEvents3                   F1DE2D75-3B95-4510-9B2B-565BC0E38877  //F1DE2D75-3B95-4510-9B2B-565BC0E38877 // new interface
#define uuid_IVsFireSolutionEvents                A4662D0F-FA14-48ac-8E68-D481EF200627  //054AECC2-AC4D-11d0-AF54-00A0C90F9DE6 // new interface
#define uuid_IVsProject                           CD4028ED-C4D8-44ba-890F-E7FB02A380C6  //625911f3-af99-11d0-8e69-00a0c911005a
#define uuid_IVsProject2                          4AF886C3-7796-4c81-A174-4A87080DEE58  //669B7232-890C-11d1-BC18-0000F87552E7
#define uuid_IVsProject3                          1C11116E-4FF2-4a80-82DC-69F95042E0A4  //36201871-BC59-11d2-BFC9-00C04F990235
#define uuid_IVsParentProject                     79001CD1-69C6-45b8-8F7A-DCCCE0469E8D  //79001CD1-69C6-45b8-8F7A-DCCCE0469E8D // new interface
#define uuid_IVsProjectSpecificEditorMap          4B2BEBAA-BA1E-4479-8720-8CE19D276098  //21f29401-a80b-4a7f-b5c4-a9f9ca849447
#define uuid_IVsProjectSpecificEditorMap2         F84A6D1D-F305-4055-A02C-A642B871BB20  //F84A6D1D-F305-4055-A02C-A642B871BB20 // new interface
#define uuid_IVsProjectResources                  3F819030-50CF-4b72-B3FC-B3B9BFBBEE69  //9c68abb3-d1e5-4986-a501-e1f446005a43
#define uuid_IVsSupportItemHandoff                E09C9DCF-D4B7-4d6e-A676-1FC64B4BF6EB  //3E7CBE01-C114-4291-80DE-7DCDE3AB0032
#define uuid_IVsAddProjectItemDlg                 11DFCCEB-D935-4a9f-9796-5BA433C5AF8E  //a448e7a0-b830-11d0-9ffd-00a0c911e8e9
#define uuid_IVsAddProjectItemDlg2                6B90D260-E363-4e8a-AE51-BD19C493416D  //8C73614F-7E67-11d2-BFB9-00C04F990235
#define uuid_IVsFilterAddProjectItemDlg           D93A191C-525A-43bc-ACFD-7EF494143CF4  //75437597-FE86-11d2-BECE-00C04F682A08
#define uuid_IVsFilterAddProjectItemDlg2          61116CFF-5319-440a-81CE-5D9F54A610DE  //61116CFF-5319-440a-81CE-5D9F54A610DE // new interface
#define uuid_IVsProjectTextImageProvider          82A40D77-D2D4-4c93-AB11-8D50ADF02B1E  //6EF99245-719D-4d55-8955-7F9E9A1ADFD1
#define uuid_IVsSaveOptionsDlg                    C3E2ED14-4E64-4c26-84D7-68CCD071A0C8  //9B550A73-1215-11d3-BED1-00C04F682A08
#define uuid_IEnumRunningDocuments                D5C658C5-59A1-414f-AF5E-E72E83377EAE  //6b60be84-7b47-11d2-b2c2-00c04fb17608
#define uuid_IVsRunningDocumentTable              A928AA21-EA77-47ac-8A07-355206C94BDD  //625911f2-af99-11d0-8e69-00a0c911005a
#define uuid_IVsRunningDocTableEvents             BEA6BB4F-A905-49ca-A216-202DF370E07E  //5579c9f0-d09d-11d0-8e75-00a0c911005a
#define uuid_IVsRunningDocTableEvents2            15C7826F-443C-406d-98F8-55F6260669EC  //e38a9670-8e0b-11d1-b278-00c04fb17608
#define uuid_IVsRunningDocTableEvents3            376ED667-F576-458f-B991-2CFD3EBC7B08  //e69a388a-fce0-11d2-8a60-00c04f682e21
#define uuid_IVsDocumentLockHolder                685933F2-C1AD-4540-A15A-D3F977A81AF7  //e2334ed2-43b5-11d3-8a7c-00c04f682e21
#define uuid_IVsWindowFrame                       11138F8A-38C0-4436-B5A6-2F5EF2C3E242  //7d960b0d-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsWindowFrameNotify                 FE46E1DF-E8A8-48d3-932E-B61BC092E681  //A31CAE00-0AB0-11d1-B646-00A0C922E851
#define uuid_IVsWindowFrameNotify2                F4DE74E7-078A-430E-B0E1-8B131BDEF335  //f4de74e7-078a-430e-b0e1-8b131bdef335
#define uuid_IVsBackForwardNavigation             B7EE8DBA-E930-4c5d-984D-B07F8EB60977  //349D5D4E-5811-11d3-B741-00C04F9901D1
#define uuid_IVsWindowView                        7E7C4B21-079F-4830-9ED5-E0CB0BF281F1  //C562FF5A-FE57-11d2-B709-00C04F9901D1
#define uuid_IVsToolWindowToolbarHost             CF7549A9-7A2A-4a6e-ACF4-05452C98CF7E  //34ECEDC1-06FE-11d1-AED2-549FFB000000
#define uuid_IVsToolWindowToolbar                 4544D333-8D5F-4517-9113-3550D618F2AD  //34ECEDC2-06FE-11d1-AED2-549FFB000000
#define uuid_IVsUIShell                           B61FC35B-EEBF-4dec-BFF1-28A2DD43C38F  //7d960b1d-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsUIShellDocumentWindowMgr          686C2AF1-A2E5-4f6c-B660-B63FD4F70C18  //A33B889B-18C2-4c4e-B561-4D95F0C3DD40
#define uuid_IVsPackageDynamicToolOwner           7DB81657-7722-4407-B675-9F4A6FEEEA15  //914C74A0-8F69-11d1-BC27-0000F87552E7
#define uuid_IVsExternalFilesManager              E36756DE-BB4F-4900-A7F0-E827BDBD2092  //2FC2CA21-B6AA-11d0-AE1A-00A0C90FFFC3
#define uuid_IVsExternalFilesManager2             999B1784-A1EE-42eb-B4B6-E928008FFB5D  //74C9E366-2BCD-11D2-B2B4-00C04FB17608
#define uuid_IVsFileChangeEvents                  F04C8816-7F77-450d-9527-14D0B93DA159  //b4e98631-f322-11d0-8e89-00a0c911005a
#define uuid_IVsFileChange                        250E1E9A-D2FC-410f-99E4-1ABA5B390A9A  //b4e98630-f322-11d0-8e89-00a0c911005a
#define uuid_IVsFileChangeEx                      9bc72973-194a-4ea8-b4d5-afb0b0d0dcb1  //9bc72973-194a-4ea8-b4d5-afb0b0d0dcb1
#define uuid_IVsIME                               DC7EDE19-3DD1-4e20-A7F1-110883ED996F  //632f13be-b1cc-11d0-ae4c-00c04fb68006
#define uuid_IVsRelativePathResolver              26831FB7-7C55-4ab1-B4AD-E37783F2D4A8  //702312F2-461F-45b2-8EEA-DA1D566115DF
#define uuid_IVsUIShellOpenDocument               35299EEC-11EE-4518-9F08-401638D1D3BC  //7d960b17-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsMultiViewDocumentView             0F4B629E-8C34-4b5e-A450-F9F8DCFE3009  //46ca0880-0ed7-11d1-8ebd-00a0c90f26ea
#define uuid_IVsPersistDocData                    D5D49C61-1C0B-4ea1-9ADB-A79FB1DBC7B5  //7d960b1c-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsPersistDocData2                   9D71890D-090C-4b67-80C3-4CB55C600B60  //1E3A7DC6-800A-11d2-ADD5-00C04F7971C3
#define uuid_IVsDocDataFileChangeControl          BF955013-A875-439d-A4E7-A3BBDF12AA4F  //04F29FC4-CE44-11d1-88B1-0000F87579D2
#define uuid_IVsPersistHierarchyItem              18933F6E-0937-4888-8C77-EC8A393B21EA  //a12946d0-bcf3-11d0-8e69-00a0c911005a
#define uuid_IVsPersistHierarchyItem2             5A494367-DF56-4062-8EDA-54E2C1FF42BC  //EEFEA81A-8949-4f04-A089-CFBF9BC414C5
#define uuid_IVsUIHierarchyWindow                 A2DD88C9-D878-4323-95A3-77DAF258E5D0  //7d960b0e-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsWindowPane                        B0834D0F-ACFF-4ea5-809B-97CBB5D3D26B  //7d960b08-7af8-11d0-8e5e-00a0c911005a
#define uuid_IEnumPackages                        9673A35F-C03A-438d-BD7E-27D9E28AC184  //7d960b0c-7af8-11d0-8e5e-00a0c911005a
#define uuid_IEnumHierarchies                     BEC77711-2DF9-44d7-B478-A453C2E8A134  //A2C2BCF9-AC4D-11d0-AF54-00A0C90F9DE6
#define uuid_IEnumWindowFrames                    8C453B03-8907-435b-96D7-573C40948F5C  //46052C70-DCFB-11d0-9404-00A0C90F2734
#define uuid_IVsShell                             FD9DC8E3-2FFC-446D-8C50-99CA4A3D2D1C  //7d960b09-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsBroadcastMessageEvents            FC5EF273-DCE3-4DBB-AEE3-F54F91F00286  //9A726311-D779-11d0-AE21-00A0C90FFFC3
#define uuid_IVsShellPropertyEvents               7A54FEA1-E786-4A30-8F38-45B3703E50DD  //8C506C01-D7A0-11d0-AE21-00A0C90FFFC3
#define uuid_IVsEditorFactory                     40FB079B-B62C-486F-9823-C9A2EAE8DBFD  //7d960b13-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsRegisterEditors                   78036A8D-A04C-43E4-8BC0-846E63AFA9A2  //7d960b14-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsEditorFactoryNotify               02AC210F-139B-4F8E-9159-501CF2A87D6E  //fa50ef7c-2b83-42c5-ab89-e9395e9731d8
#define uuid_IVsMultiItemSelect                   96973FC6-C2E4-4CB9-8BAF-7F7CD6DBC604  //7d960b0f-7af8-11d0-8e5e-00a0c911005a
#define uuid_IEnumHierarchyItems                  687396AE-252E-460F-8F54-EF2C521BB6D8  //1C97C7F5-8C7B-46a2-A84B-AB12A5833A45
#define uuid_IVsEnumHierarchyItemsFactory         30E5C390-C3E6-40AC-BD1D-7015B1B5F541  //65C8CA4C-0871-48c5-A2E5-FB2F4DC4DB23
#define uuid_IVsSwatchClient                      E68652D0-396C-4937-95A3-F0AE7ACD0E15  //4C8F7500-5106-11d3-8821-00C04F7971A5
#define uuid_IVsTrackSelectionEx                  18291FD1-A1DD-4264-AEAD-6AFD616BF15A  //7d960b10-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsSelectionEvents                   82871589-D680-4D86-B969-9D1102B00F6F  //7d960b11-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsMonitorSelection                  55AB9450-F9C7-4305-94E8-BEF12065338D  //7d960b12-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsTaskList                          9D21BCC5-2C63-4A61-B055-2F3DF78EB30A  //BC5955D1-AA0D-11d0-A8C5-00A0C921A4D2
#define uuid_IVsTaskProvider                      6909C6ED-2AF5-4A35-8EA7-E6095A3ECF9E  //BC5955D2-AA0D-11d0-A8C5-00A0C921A4D2
#define uuid_IVsTaskProvider2                     A7E6B1F9-DFF1-4354-870F-196BE871F329  //842BEEF8-B57A-11d2-8B97-00C04F8EC28C
#define uuid_IVsTaskItem                          0F6D7FB4-2649-4E51-BC20-3698F9F51358  //BC5955D3-AA0D-11d0-A8C5-00A0C921A4D2
#define uuid_IVsTaskItem2                         970A6925-5FFA-4A77-972F-7AB90C0130E5  //D30A201A-7837-11d2-8B81-00C04F8EC28C
#define uuid_IVsEnumTaskItems                     66638598-522B-4058-9E65-FAF237700E81  //BC5955D4-AA0D-11d0-A8C5-00A0C921A4D2
#define uuid_IVsCommentTaskToken                  327C43D7-CCB1-41D7-9A7B-CE87751201F7  //92ED80E0-144D-11d1-8F8B-00A0C91BBFA2
#define uuid_IVsEnumCommentTaskTokens             EC47207E-5A2A-45D4-9FA4-F9AB94E380B4  //92ED80E1-144D-11d1-8F8B-00A0C91BBFA2
#define uuid_IVsCommentTaskInfo                   D94C96DA-A6C4-4F52-84F6-52ECF05DEA3A  //92ED80E2-144D-11d1-8F8B-00A0C91BBFA2
#define uuid_IVsTaskListEvents                    D529FAD1-4BE0-4BEA-92A3-A58A4B89D056  //92ED80E3-144D-11d1-8F8B-00A0C91BBFA2
#define uuid_IVsOutputWindowPane                  9B878A55-296A-404D-80C4-1468BB7CDC43  //B7886422-E776-11d0-AE28-00A0C90FFFC3
#define uuid_IVsOutputWindow                      533FAD11-FE7F-41EE-A381-8B67792CD692  //B7886421-E776-11d0-AE28-00A0C90FFFC3
#define uuid_IVsAsyncEnum                         C734671A-9BB0-45C5-A08E-B9AB73CF5F47  //d0b027c6-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsAsyncEnumCallback                 EE559C3D-0189-4F81-B088-C6CC6A394CA1  //d0b027c7-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsHierarchyDropDataSource           AC7D8BE5-B7F5-400B-B02C-35207672F56B  //7d960b1b-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsHierarchyDropDataSource2          D84D04B8-8E0D-4298-AD9C-27F8C0D5484A  //C43E5BC8-14FC-4b6d-9237-1ADD628D4899
#define uuid_IVsHierarchyDropDataTarget           5AA5B118-B3D4-40C5-8739-231CE192850C  //7d960b1a-7af8-11d0-8e5e-00a0c911005a

// library VsShell
#define uuid_lib_VsShell                          D6F79714-BFA9-4F00-98CF-E2FA31802694   //455AD7A0-8C58-11d0-A8AB-00A0C921A4D2                   
#define uuid_IVsDebuggerEvents                  /*F7C88E0E-A5C6-4E32-BD42-AFFCFB94A1D1*/ 7d960b15-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsDebugLaunch                     /*E2E82904-6072-4F8E-A4F5-9AF15A98F444*/ A5412570-5FB9-11d1-A811-00A0C9110051
#define uuid_IVsDebugger                        /*2E10DD68-AD50-4D3C-94F7-D6C165C7E25D*/ 7d960b16-7af8-11d0-8e5e-00a0c911005a
#define uuid_IVsLaunchPad                       /*D53BFAC7-AE4E-4500-AFB0-3925AE60B2BC*/ EF16A8B0-41CF-11d1-84A4-00A0C9110055
#define uuid_IVsLaunchPadEvents                 /*A847B389-401A-4438-8A90-CA5BF2451E13*/ 65BC5C20-41D1-11d1-84A4-00A0C9110055
#define uuid_IVsLaunchPadFactory                /*6979C82C-21DB-4E5C-A225-C50A766AA5BA*/ c21c16a2-1612-4995-b445-f7b1c1657878
#define uuid_IVsJavaClassLocatorService         /*374FAF39-7EF3-4877-8667-7E96EC0C1771*/ 53525550-C745-11d0-A7A6-00A0C9110051
#define uuid_IVsTextBufferProvider              /*A001CA6F-F6FF-4C98-873A-845B1C917B96*/ 76A3B2C0-C743-11d0-A7A6-00A0C9110051
                                                                
#define uuid_IVsToolboxDataProvider               F925DA6B-3F43-4437-9E1E-4D4C1BBDAB3F  //E370AEAA-AA14-11d0-8C46-00C04FC2AA89
#define uuid_IVsToolboxUser                       B5E12E94-6653-4A0D-9C42-5357F2654360  //E370AEAB-AA14-11d0-8C46-00C04FC2AA89
#define uuid_IEnumToolboxItems                    5303CCDE-D37A-445B-88A1-A71742F66345  //ADB5A663-C641-11d0-8C54-00C04FC2AA89
#define uuid_IEnumToolboxTabs                     CC81495D-3C2B-4B1E-82CE-965EA5FCA2A0  //ADB5A664-C641-11d0-8C54-00C04FC2AA89
#define uuid_IVsToolbox                           70E643E2-1673-4764-8A39-63CB1AEE0DC9  //E370AEA9-AA14-11d0-8C46-00C04FC2AA89
#define uuid_IVsToolbox2                          08E728DC-9C45-4060-A243-B73443B7CA16  //0F844C7D-5EF0-11d2-B213-0000F87570EE
#define uuid_IVsToolboxClipboardCycler            6A2A1D82-C590-4AB1-8CC2-D95BACBBA9E0  //E31E5D50-D8A6-11d2-AFBD-00105A9991EF
#define uuid_IVsStatusbarUser                     D388BD3B-4D50-4356-B09A-8917E706D196  //DB5CFB59-FC95-11d0-8C7E-00C04FC2AA89
#define uuid_IVsStatusbar                         DC0AF70E-5097-4DD3-9983-5A98C3A19942  //1F9C665D-F96A-11d0-8C7E-00C04FC2AA89
#define uuid_IVsDocOutlineProvider                47B1D60A-4EB8-4723-B991-992E6393E392  //81CD5C00-FFA1-11d0-B63F-00A0C922E851
#define uuid_IVsComponentSelectorProvider         1375E029-1FDD-47FF-A22C-6709242133E2  //040F3EE3-55D8-11d3-9ECE-00C04F682A08
#define uuid_IVsComponentUser                     910035B1-D8BE-403A-975E-E4FB68CE40A1  //0E3C4039-6639-11d3-BFFC-00C04F990235
#define uuid_IVsComponentSelectorDlg              66899421-F497-4503-8C9D-ADAE290F2F27  //2F952EED-564F-11d3-9ECE-00C04F682A08
#define uuid_IVsObjectBrowser                     A4AAB3EC-A9BB-42E2-8FD4-B01FE406D3F1  //970D9860-EE83-11d0-A778-00A0C91110C3
#define uuid_IVsLiteTreeList                      1E425321-94CB-448e-8E1E-E1EA2479E5E2  //D1E5F1F2-66F8-4384-BB9E-38DA0DCCE632
#define uuid_IVsLiteTree                          C4158C7D-5052-48D9-8643-7A821BB0F50B  //CC27B016-3D1E-469e-A0B6-9CFAB0E6DBF6
#define uuid_IVsLiteTreeEvents                    87066898-76AB-45E2-B33C-C5B6B99BB03E  //E85449F3-F8BC-11d0-A77A-00A0C91110C3
#define uuid_IVsLibrary                           E86128E4-3B1B-4BE9-BEB6-D30E5BF40850  //1FF9C984-5E75-47cd-B65F-FB63445BFCD7
#define uuid_IVsLibraryMgr                        DC1B976F-4DC7-4B3D-9EC7-A0DE9D39BC13  //7E547EFB-5DBB-4049-B039-86E416220E30
#define uuid_IVsObjectBrowserList                 44CCEB38-619B-401C-9B48-B9E874FFEE21  //E85449F6-F8BC-11d0-A77A-00A0C91110C3
#define uuid_IVsObjectList                        C48F7AB9-8966-4138-B602-14C5EB8BD857  //07f5fbe1-1abb-11d3-85aa-006097c68e81
#define uuid_IVsObjectListOwner                   5801DB45-16AA-4F08-BB57-82A070B79512  //0e801c7a-479b-11d3-bdba-00c04f688e50
#define uuid_IVsObjectManager                     01E95D2E-2D20-4662-9DE7-4C1C35524260  //07f5fbe0-1abb-11d3-85aa-006097c68e81
#define uuid_IVsObjectManagerEvents               7C4C8065-FB7E-45D8-9B50-940A8FCB5876  //07f5fbe2-1abb-11d3-85aa-006097c68e81
#define uuid_IVsLibraryMgrEvents                  A66E54A0-1102-4A7A-A058-03C7109B99D1  //E85449F7-F8BC-11d0-A77A-00A0C91110C3
#define uuid_IVsObjectBrowserDescription          EA31732A-0A11-4E80-8DCC-9E6DB395BE59  //E85449F8-F8BC-11d0-A77A-00A0C91110C3
#define uuid_IVsObjectBrowserDescription2         0587FED2-8072-401F-9090-BCA98C44BBF7  //7178484A-76B0-11d3-BDC7-00C04F688E50
#define uuid_IVsClassView                         D7ECCE71-9C14-49A9-A93D-A5ED6286AC46  //C9C0AE26-AA77-11d2-B3F0-0000F87570EE  // << Same as GUID_ClassView Toolwindow GUID, why not?
#define uuid_IVsObjBrowser                        0DF98187-FD9A-4669-8A56-727910A4866C  //269A02DC-6AF8-11d3-BDC4-00C04F688E50
#define uuid_IEnumComReferences                   46B4B7C2-11EB-4753-BE4B-0E0A16E9CE53  //6114C8A0-0CE9-11d1-8BD9-00A0C90F26F7
#define uuid_IVsComReferenceDlgEvents             66A77728-86E1-4D18-88C5-EE0D4FD4BF60  //6114C8A1-0CE9-11d1-8BD9-00A0C90F26F7
#define uuid_IVsComReferenceDlg                   CC05EE57-C6C0-4742-A469-0961E50B0049  //6114C8A2-0CE9-11d1-8BD9-00A0C90F26F7
#define uuid_IVsExtensibleObject                  D2C45F92-23B5-408B-B41D-D4365FB7EDA8  //94017641-2BA3-11d1-AE65-00A0C90F26F4
#define uuid_IVsLanguageInfoPackage               8C444EF9-5863-4AB1-A1D0-55CC60AC253A  //5E0EEA6C-2EBD-11d1-8CC5-00C04FC2AB22
#define uuid_IVsSwitchToolWindow                  34DBAA55-2CA4-44EF-9F92-85435D3E4451  //3d4683e0-313b-11d1-a04a-00a0c911e8e9
#define uuid_IVsMenuItem                          DC0A8728-F58B-4444-B9F0-32D6868BF399  //F71AA513-9038-11d0-8C3C-00C04FC2AA89
#define uuid_IVsMenuEditor                        6FBCB271-B391-4F80-B560-45E650DEF0A7  //559BAFB1-8396-11d0-B668-00AA00A3EE26
#define uuid_IVsMenuEditorSite                    61B34381-6D7C-461D-949A-1AE178CBA00D  //6A213651-8396-11d0-B668-00AA00A3EE26
#define uuid_IVsMenuEditorFactory                 EAF61568-F99B-4BC2-83C4-1DAD8FFAE9E5  //6513023F-94BD-11d0-8C3E-00C04FC2AA89
#define uuid_IVsIntelliMouseHandler               35A96FFB-7ED0-4D76-93CE-49BE83A9C91E  //B9C589F8-471B-11d1-8862-0000F87579D2
#define uuid_IVsCodeShareHandler                  F4936BE4-7AE0-4C97-9D82-51D219FC5D77  //16c5b4c1-03b3-11d1-a39a-006097df2373
#define uuid_IVsWindowPaneCommit                  508ED8E9-923D-44ED-8165-5B96DA4E0829  //AEC7E124-7662-11d1-9CF5-00C04FB17665
#define uuid_IVsPropertyBrowser                   B1E402B6-D8E0-4422-9164-421FEE099F00  //AA71B5C0-CD90-11d1-B4D6-00A0C911E8B1
#define uuid_IVsUIHierWinClipboardHelper          DF29D855-D0EC-4DA1-BCC3-42FA3A09B1CB  //7EEDD561-FC1E-11d2-BECD-00C04F682A08
#define uuid_IVsUIHierWinClipboardHelperEvents    4D25F3C7-3138-4AC6-91AF-D7FF6929DB9F  //7EEDD562-FC1E-11d2-BECD-00C04F682A08
#define uuid_IVsHierarchyDeleteHandler            320E51F6-D238-4BD0-BA89-CCA91DBCF411  //8F97C0CD-2B64-11d3-BEDD-00C04F682A08
#define uuid_IVsCmdNameMapping                    6D10BA00-9465-4F93-8B1D-11E36EE1FF65  //D3EE8D38-78D7-11d2-8776-00C04F7971A5
#define uuid_IVsParseCommandLine                  366704D5-85D0-4F7D-B267-90FA4DD37D5B  //1B04D776-CAB7-11d2-A41B-00C04F72D18A
#define uuid_IVsTextOut                           2BD8D42F-5BC5-4B7F-AB50-FE9310F2FE53  //2CAA1AB2-0261-11d3-BE8A-0080C747D9A0
#define uuid_IVsCommandWindow                     0660CD86-F3AB-4008-930D-BAE8B10FF8CA  //94964F2F-FF42-11d2-A434-00C04F72D18A
#define uuid_IVsThreadSafeCommandWindow           811DEB01-C1B0-4172-9CA3-504C5095882E  //1D009554-87E2-11d3-A45A-00C04F72D18A
#define uuid_IVsTestLog                           575BC578-7562-44E7-986C-5B31398CF121  //9A90C18F-7F31-11d2-9BFC-00C04F9901D1
#define uuid_IVsTshell                          /*CA3E5036-9567-407C-B464-5ECA98B533A0*/  F6A0FA50-B78B-11d0-A79E-00A0C9110051
#define uuid_IVsPropertyPageFrame                 BC039978-213E-4CA0-81C4-10EDF2AF2D66  //41218D4C-AC2A-11d2-8B91-00C04F8EC28C
#define uuid_IVsFontAndColorDefaults              5FA2AC9A-3BEF-423A-8B5E-6645811BFB6B  //0514444A-F8DB-11d2-AE7D-00C04F7971C3
#define uuid_IVsFontAndColorGroup                 1D42A4C9-57DE-4D3E-8010-485ADFC1E95B  //A76B7F30-50CF-11d3-8E5C-00104BC90F0C
#define uuid_IVsFontAndColorEvents                F73E1D1E-3D1B-44F0-B736-D59F960B7F9E  //12F8E1DA-1EB3-11d3-AE9B-00C04F7971C3
#define uuid_IVsFontAndColorDefaultsProvider      3448FF72-B072-435E-9059-29D89C0A3CD0  //9B7C3392-145C-11d3-AE91-00C04F7971C3
#define uuid_IVsFontAndColorStorage               40BC7B1A-E625-4DA1-86B4-7660F3CCBB16  //1369CBD4-0FBD-11d3-AE8E-00C04F7971C3
#define uuid_IVsProjectStartupServices            82780F79-A3ED-4B7F-90C0-5FEE14CBB53E  //30B4F22A-0EE3-11d3-9B52-00C04F68380C
#define uuid_IEnumProjectStartupServices          9E6F916A-3E8B-4741-8AFB-5187F82B699B  //746797AC-0EE3-11d3-9B52-00C04F68380C
#define uuid_IVsPropertyPage                      237ABD5F-9537-4AEE-A893-72AB9A0EA8E8  //6DD48D3C-1BD1-11d3-8BBD-00C04F8EC28C
#define uuid_IVsPerPropertyBrowsing               0FF510A3-5FA5-49F1-8CCC-190D71083F3E  //0A55B998-D98E-11D2-91DF-00A0CC394083
#define uuid_IVsRegisterPriorityCommandTarget     ED77D5EC-B0DE-4721-BDC6-38DCBE589B4C  //C96FC5D4-DE9F-43bf-B197-03897D829800
#define uuid_IVsObjectSearch                      44A39218-81BD-4669-9DE0-F282A8BAEE34  //1AB09D1C-6A1F-410f-856D-7C35D386A068
#define uuid_IVsGeneratorProgress                 BED89B98-6EC9-43CB-B0A8-41D6E2D6669D  //bdb56d23-712a-43f0-a2d0-5cf06e71003d
#define uuid_IVsSingleFileGenerator               3634494C-492F-4F91-8009-4541234E4E99  //edea12ea-3621-4a7e-ac32-8940f17453b7
#define uuid_IVsCfg                               B8F932A5-5037-48C9-AB3A-A4ABBA79358B  //d0b027b1-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsDebuggableProjectCfg              2BC88742-618D-46B2-B65D-67AC990E3215  //d0b027dc-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsBuildStatusCallback               A17326AD-C97B-4278-86E2-72163C4C6A8C  //d0b027c3-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsBuildableProjectCfg               8588E475-BB33-4763-B4BA-0322F839AA3C  //d0b027c0-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsDeployStatusCallback              E9964F8D-5600-4623-B611-FF4007B22419  //942DCAB5-BA5D-11d0-AB23-00A0C90F2713
#define uuid_IVsDeployableProjectCfg              358F6C9F-CD65-446A-B79A-30CEE094FDC1  //2bc4e9c7-66b3-11d1-b194-00a0c91e2acd
#define uuid_IVsProjectCfg                        2DBDF061-439B-4822-9727-CA3ED918B658  //d0b027b2-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsProjectCfg2                       A7ADE7A0-F286-4C03-8137-D6D0EF3D6848  //521F66DD-F1C1-11d2-B0AD-00A0C9CFCEE6
#define uuid_IVsCfgProvider                       EEABD2BE-4F4F-4CCB-86AD-9F469C5C9686  //d0b027e0-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsCfgProviderEvents                 E6D78900-BB40-4039-9C54-593A242B65DA  //2bc4e9f0-66b3-11d1-b194-00a0c91e2acd
#define uuid_IVsCfgProviderEventsHelper           0D6D480C-894F-48E4-98D2-E0A7127750E4  //99913f1e-1ee3-11d3-8a6e-00c04f682e21
#define uuid_IVsCfgProvider2                      623E34D5-82C1-42ED-A82C-6CA0478FFDDA  //2bc4e9f1-66b3-11d1-b194-00a0c91e2acd
#define uuid_IVsProjectCfgProvider                803E46E2-6A0D-4D5D-9F84-6CE1248B068D  //e0b027b0-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsGetCfgProvider                    509D0E4F-A770-44C3-9185-D4F1E4813AD6  //BFDCD88A-30CA-11d3-9B5F-00C04F68380C
#define uuid_IVsEnumOutputs                       0A8AC2FB-87BC-4795-8C8B-47E877F48FE8  //d0b027b3-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsOutput                            0238DCC5-62D6-4DAC-A977-2C6A36C502F4  //d0b027b4-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsHierarchicalOutput                2D39742A-C729-44C3-AC5B-85785D4C1C22  //d0b027c8-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsOutputGroup                       FCC03D95-7C2E-4398-AAAE-0F4B56104FC8  //521F66DE-F1C1-11d2-B0AD-00A0C9CFCEE6
#define uuid_IVsOutput2                           653BB330-1205-4CF8-8F88-723D6E199A01  //521F66DF-F1C1-11d2-B0AD-00A0C9CFCEE6
#define uuid_IVsDeployDependency                  A086E870-AA0B-4EF9-8CF3-4A38267B9C7D  //521F66E0-F1C1-11d2-B0AD-00A0C9CFCEE6
#define uuid_IVsProjectDeployDependency           B4D28A5B-063D-4622-B0C7-C3DDEBFCDCCF  //06e2018b-568f-44e9-8af7-5d501cae6eb7
#define uuid_IVsDependency                        9DB6689F-3C5F-43ED-B0D5-54851A980B93  //d0b027b6-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsBuildDependency                   28D58EEE-EFFC-4B4D-834C-3A746FEAC7AE  //d0b027d6-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsEnumDependencies                  0ED850AF-C30A-42BA-AA20-3436ADF24937  //d0b027b5-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsDependencyProvider                819CC554-C7BF-4965-A4D4-937B2B6CD2E1  //d0b027c9-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsPropertyStreamIn                  EC9ABAFB-E744-44B5-8771-0B875EE6FC5C  //d0b027cb-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsPropertyFileIn                    805B0E0A-7122-4855-962F-887E46D2F112  //2bc4e9c0-66b3-11d1-b194-00a0c91e2acd
#define uuid_IVsPropertyStreamOut                 BF283741-E0AD-49C0-BEA4-1E267E52208F  //d0b027cc-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsPropertyFileOut                   3018E511-6282-41FC-8E1F-77AB1BDDE523  //2bc4e9c1-66b3-11d1-b194-00a0c91e2acd
#define uuid_IVsStructuredFileIOHelper            0612FCA3-B60E-410B-BCCE-43953FF0763C  //2bc4e9c2-66b3-11d1-b194-00a0c91e2acd
#define uuid_IVsStructuredFileIO                  12B43F9F-8550-4FFA-850F-FE9D4D396C20  //d0b027e1-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsHTMLConverter                     218D0424-9C53-4EA1-A679-A0AED59B0E4F  //CB89733A-B2E0-11d1-981B-0000F8058E9D
#define uuid_IVsSolutionObjectManager             B6622DC2-ACC1-463A-A50C-F9674DA9C827  //910E8284-F867-11d0-AB36-00A0C90F2713
#define uuid_IVsSolutionSecurityOptions           05A323E9-5069-474E-9BCC-14F87302B213  //96313150-6AA6-11d1-A202-0000F8026F55
#define uuid_IVsUpdateSolutionEvents              A9F86308-5EA7-485D-BAB8-E8989C3CFBDC  //d0b027da-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsUpdateSolutionEvents2             F59DBC1A-91C3-45C9-9796-1CAB558502DD  //868163bb-1da7-41df-87b8-ce64439a4093
#define uuid_IVsSolutionBuildManager              93E969D6-1AA0-455F-B208-6ED3C82B5C58  //d0b027db-8c1f-11d0-8a34-00a0c91e2acd
#define uuid_IVsSolutionBuildManager2             80353F58-F2A3-47B8-B2DF-0475E07BB1C6  //e823a2b0-88ed-44c8-98de-73fd5d54b908
#define uuid_IVsLibraryReferenceManager         /*910ACC85-ECD4-4CF8-85E0-EB105ABE8008*/  699D5E17-9B22-466b-ACFA-2E12CD64E249
#define uuid_IVsLangSpecificSyntax                0E7798AD-4000-48DF-AA1D-851425D45825  //9E9AB119-D2A1-4381-9020-6B771DC46AE9

// new interfaces
#define uuid_IVsNonLocalProject                   1A1DFC92-F6EC-4fef-A26F-6D0DA546F32A
#define uuid_IVsSimpleDocFactory                  9D0CA895-4F60-4de8-980D-06AAD61CE88C
#define uuid_IVsInvisibleEditor	                  2EC892AF-9642-417f-B452-8AA1ACBFBA99
#define uuid_IVsInvisibleEditorManager            14439CDE-B6CF-4dd6-9615-67E8B3DF380D
#define uuid_IVsResourceView                      AD3B499C-281D-46bb-B43B-071413528C04
#define uuid_IVsXMLMemberIndex                    F9C06C61-207B-41d5-9CA2-690B3AE01083
#define uuid_IVsXMLMemberIndexService             D31E676B-D416-4da7-977E-20E00AAE1118
#define uuid_IVsXMLMemberData                     05EC0018-FB7F-4492-9F91-21245C5A3D15
#define uuid_IVsObjectSearchPane                  BBA468E0-2D3D-450e-AF95-CCB9DE1162E8
#define uuid_IVsProjectSpecialFiles               7CEB5F64-3AF3-4FC4-843D-E8E61F43B13C
#define uuid_IVsBatchUpdate                       A2D3286E-B5AE-4981-8D32-E9053FCF997D
#define uuid_IVsCommandArgInfo                    AAD53083-6316-4a65-82C3-85732AC52E52
#define uuid_IVsPropertyPageNotify                48002E6A-CE3C-4c7e-9D10-3D46A3AF5881
#define uuid_IVsFilterKeys                        C00858CF-2E17-4323-9D79-0B0CFC39A92F
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsversion.h ===
#include ".\version.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsstring.h ===
//=--------------------------------------------------------------------------=
// VsString.H
//=--------------------------------------------------------------------------=
// Common string manipulation functions and classes.  This library has the
// following goals:
//
//    1.  Unicode / Ansi transparent.  You should be able to compile your code
//        as ansi or as unicode and all these calls should work transparently.
//
//    2.  Simple.  I want to provide a broad range of functionality without
//        creating ten thousand API calls.  Also, I want to name these
//        API's simply and consistently.
//
//=--------------------------------------------------------------------------=
// Copyright 1997 Microsoft Corporation.  All rights reserved.
// Information contained herein is proprietary and confidential.
// 
// BrianPe.  4/97
//

#ifndef _INC_VSSTRING_H
#define _INC_VSSTRING_H


//=--------------------------------------------------------------------------=
// StrConvert.  this is a very simple string utility class.  No, it does
// not, should not, will not ever become a full string class.  All it does
// is help facilitate conversions among the following datatypes:
//
// WCHAR
// CHAR
// Resource ID
//
// One problem with a class like this is error handling - it is always 
// assumed to succeed.  This class will return an empty string if it
// runs out of memory.  Not particularly robust, but it will prevent
// a crash.
//
class StrConvert
  {
  friend void VsStrSetDefaultHInstance(HINSTANCE hInst);

  public:
    StrConvert(LPSTR  psz);
    StrConvert(LPWSTR pwsz);
    StrConvert(UINT   uId, HINSTANCE hinstResource = NULL);

    ~StrConvert();

    operator LPSTR();
    operator LPWSTR();

    static void SetDefaultInstance(HINSTANCE hinstResource) { s_hinstResource = hinstResource; }

  private:
    UINT      m_fWszStatic:1;
    UINT      m_fSzStatic:1;
    LPSTR     m_psz;
    LPWSTR    m_pwsz;
    HINSTANCE m_hinst;
    UINT      m_uId;

    void _LoadString(BOOL fUnicodePreferred);

    static HINSTANCE    s_hinstResource;
    const  static WCHAR s_chEmpty;
  };


//=--------------------------------------------------------------------------=
// String copying functions.  These are overloaded here so you can just
// pass in what you've got and what you want, and they will always work.
// They always return the number of BYTES copied, and they always take the
// number of CHARACTERS to copy.
//
DWORD VsStrCpy(LPSTR pszDest,   LPSTR pszSrc,   int cch = -1);
DWORD VsStrCpy(LPWSTR pszDest,  LPSTR pszSrc,   int cch = -1);
DWORD VsStrCpy(LPSTR pszDest,   LPWSTR pszSrc,  int cch = -1);
DWORD VsStrCpy(LPWSTR pszDest,  LPWSTR pszSrc,  int cch = -1);


//=--------------------------------------------------------------------------=
// Same thing for comparisons.  We only have one compare function, but it
// takes a variety of flags.
//
#define SC_IGNORECASE   0x01
#define SC_IGNOREWIDTH  0x02

enum STRING_COMPARE
  {
  SC_LESSTHAN     = -1,
  SC_EQUAL        = 0,
  SC_GREATERTHAN  = 1
  };

STRING_COMPARE VsStrCmp(LPSTR pszStr1,  LPSTR pszStr2,  int nCompareFlags = 0);
STRING_COMPARE VsStrCmp(LPWSTR pszStr1, LPSTR pszStr2,  int nCompareFlags = 0);
STRING_COMPARE VsStrCmp(LPSTR  pszStr1, LPWSTR pszStr2, int nCompareFlags = 0);
STRING_COMPARE VsStrCmp(LPWSTR pszStr1, LPWSTR pszStr2, int nCompareFlags = 0);


#endif // _INC_VSSTRING_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\W4Char.h ===
// W4Char.h - UCS-4 Character definitions and string routines
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1999 Microsoft Corporation.  All Rights Reserved.
//
// July 24, 1999 [paulde] Paul Chase Dempsey
//
//-----------------------------------------------------------------
#pragma once
#include "unichar.h"

typedef DWORD W4CHAR;
typedef       W4CHAR * PW4STR;
typedef const W4CHAR * PCW4STR;

//-----------------------------------------------------------------
// W4CharRange - Returns a range code for a W4CHAR
//
// Returns:
// -1  Out of UTF-16 (Unicode) range
//  0  Basic Unicode, i.e. BMP, plane 1
//  1  Surrogate
//
int     WINAPI W4CharRange (W4CHAR ch);

//-----------------------------------------------------------------
// W4CHAR length routines
//
int WINAPI WLengthOfW4Char   (W4CHAR ch);       // Count of WCHARs to represent the W4CHAR
int WINAPI WStrLengthOfW4Str (PCW4STR pw4Str);  // Count of WCHARs in a W4STR
int WINAPI W4LengthOfWStr    (PCWSTR psz);      // Count of W4CHARs in a WSTR
int WINAPI W4StrLen          (PCW4STR pw4Str);  // Count of W4CHARS in a W4STR

#define StrLenW4 W4Strlen   // alias

//-----------------------------------------------------------------
// CopyW4CharToWChar - Copy one W4CHAR to PWSTR
//
PWSTR   WINAPI CopyW4CharToWChar (PWSTR pDst, W4CHAR ch);

//-----------------------------------------------------------------
// CopyNW4StrToW - Copy n W4Chars to PWSTR
//
PWSTR   WINAPI CopyNW4StrToW     (PWSTR pDst, PCW4STR pw4Str, int cch4);  

//-----------------------------------------------------------------
// CopyW4StrToWN - Copy W4Chars to a PWSTR, up to n WCHARs
//
int     WINAPI CopyW4StrToWN    (PWSTR      pDst, 
                                 PCW4STR    pw4Str, 
                                 int        cchDstMax, 
                                 PCW4STR *  ppw4 = NULL);

//-----------------------------------------------------------------
// W4CharFromWChar Get 1 W4CHAR from PCWSTR
//
// Returns 1 W4CHAR from pch, optionally getting a pointer to the
// next position in the source.
//
W4CHAR  WINAPI W4CharFromWChar  (PCWSTR pch, PCWSTR * ppchNext = NULL);

//-----------------------------------------------------------------
// CopyWStrToW4Str - Copy from PWSTR to PW4STR
//
PW4STR  WINAPI CopyWStrToW4Str  (PW4STR pDst, PCWSTR pSrc);

//-----------------------------------------------------------------
// MakeW4Char - Make a W4CHAR from a surrogate pair
//
// The result is garbage if the characters are not a 
// surrogate pair in the specified order.
//
W4CHAR  WINAPI MakeW4Char (WCHAR chHi, WCHAR chLo);

//-----------------------------------------------------------------
// MakeSurrogatePair - Make a surrogate pair from a W4CHAR
//
// The result is garbage if the W4CHAR is not in the UCS-4 range 
// that surrogates represent.
//
PWSTR   WINAPI MakeSurrogatePair (PWSTR pch, W4CHAR ch);

// inline implementations
#include "W4Char.inl"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vstypeinfo.h ===
//--------------------------------------------------------------------------
// Microsoft Visual Basic
//
// Copyright (c) 2000 Microsoft Corporation 
// All rights reserved
//
// VSTypeInfo.h
//
// Modified version of CComTypeInfoHolder that loads the typelib from the 
// HMODULE instead of from the registry. This allows the typelib of the interface 
// implemented by the class using this class, to not be registered.
// The index of the type library resource to load is passed
// in by the classes that use this class instead of the major ver they would 
// have otherwise passed to IDispatchImpl. ( Major ver is no longer needed 
// since the type lib is not loaded from the registry.)
//---------------------------------------------------------------------------
#ifndef __VSTYPEINFO_H__
#define __VSTYPEINFO_H__

#include "vsmodule.h"

class CVsTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wTypeLibRes;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;
	struct stringdispid
	{
		CComBSTR bstr;
		int nLen;
		DISPID id;
	};
	stringdispid* m_pMap;
	int m_nCount;

public:
	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		*ppInfo = m_pInfo;
		if (m_pInfo != NULL)
		{
			m_pInfo->AddRef();
			hr = S_OK;
		}
		return hr;
	}
	HRESULT GetTI(LCID lcid);
	HRESULT EnsureTI(LCID lcid)
	{
		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		return hr;
	}

	// This function is called by the module on exit
	// It is registered through _Module.AddTermFunc()
	static void __stdcall Cleanup(DWORD_PTR dw)
	{
		CVsTypeInfoHolder* p = (CVsTypeInfoHolder*) dw;
		if (p->m_pInfo != NULL)
			p->m_pInfo->Release();
		p->m_pInfo = NULL;
		delete [] p->m_pMap;
		p->m_pMap = NULL;
	}

	HRESULT GetTypeInfo(UINT /* itinfo */, LCID lcid, ITypeInfo** pptinfo)
	{
		HRESULT hRes = E_POINTER;
		if (pptinfo != NULL)
			hRes = GetTI(lcid, pptinfo);
		return hRes;
	}
	HRESULT GetIDsOfNames(REFIID /* riid */, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
		{
			for (int i=0; i<(int)cNames; i++)
			{
				int n = (int)ocslen(rgszNames[i]);
				for (int j=m_nCount-1; j>=0; j--)
				{
					if ((n == m_pMap[j].nLen) &&
						(memcmp(m_pMap[j].bstr, rgszNames[i], m_pMap[j].nLen * sizeof(OLECHAR)) == 0))
					{
						rgdispid[i] = m_pMap[j].id;
						break;
					}
				}
				if (j < 0)
				{
					hRes = m_pInfo->GetIDsOfNames(rgszNames + i, 1, &rgdispid[i]);
					if (FAILED(hRes))
						break;
				}
			}
		}
		return hRes;
	}

	HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID /* riid */,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
			hRes = m_pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
		return hRes;
	}
	HRESULT LoadNameCache(ITypeInfo* pTypeInfo)
	{
		TYPEATTR* pta;
		HRESULT hr = pTypeInfo->GetTypeAttr(&pta);
		if (SUCCEEDED(hr))
		{
			m_nCount = pta->cFuncs;
			m_pMap = m_nCount == 0 ? 0 : new stringdispid[m_nCount];
			for (int i=0; i<m_nCount; i++)
			{
				FUNCDESC* pfd;
				if (SUCCEEDED(pTypeInfo->GetFuncDesc(i, &pfd)))
				{
					CComBSTR bstrName;
					if (SUCCEEDED(pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL)))
					{
						m_pMap[i].bstr.Attach(bstrName.Detach());
						m_pMap[i].nLen = SysStringLen(m_pMap[i].bstr);
						m_pMap[i].id = pfd->memid;
					}
					pTypeInfo->ReleaseFuncDesc(pfd);
				}
			}
			pTypeInfo->ReleaseTypeAttr(pta);
		}
		return S_OK;
	}
};


inline HRESULT CVsTypeInfoHolder::GetTI(LCID lcid)
{
	//If this assert occurs then most likely didn't initialize properly
	ATLASSERT(m_plibid != NULL && m_pguid != NULL);
	ATLASSERT(!InlineIsEqualGUID(*m_plibid, GUID_NULL) && "Did you forget to pass the LIBID to CComModule::Init?");

	if (m_pInfo != NULL)
		return S_OK;
	HRESULT hRes = E_FAIL;
	EnterCriticalSection(&_Module.m_csTypeInfoHolder);
	if (m_pInfo == NULL)
	{
		ITypeLib* pTypeLib;

        // Changed only this block of code from the original CComTypeInfoHolder to load from HMODULE 
        // instead of the registry.
        TCHAR szTypeLibRes[21];
        TCHAR szModuleFileName[_MAX_PATH + 1];

        HINSTANCE hInst = _Module.GetModuleInstance();
        DWORD dwSize = GetModuleFileName(hInst, szModuleFileName, _MAX_PATH);
        CString strTypeLibRes = szModuleFileName;
        // don't bother appending \1, as that's the default and just causes the 
        // system to have to look for two different files unnecessarily
        if( m_wTypeLibRes != 1 )
        {
	        strTypeLibRes += _T("\\");
	        _itot(m_wTypeLibRes, szTypeLibRes, 10);
	        strTypeLibRes += szTypeLibRes;
        }
        hRes = LoadTypeLib(strTypeLibRes, &pTypeLib);

        
		if (SUCCEEDED(hRes))
		{
			CComPtr<ITypeInfo> spTypeInfo;
			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);
			if (SUCCEEDED(hRes))
			{
				CComPtr<ITypeInfo> spInfo(spTypeInfo);
				CComPtr<ITypeInfo2> spTypeInfo2;
				if (SUCCEEDED(spTypeInfo->QueryInterface(&spTypeInfo2)))
					spInfo = spTypeInfo2;

				LoadNameCache(spInfo);
				m_pInfo = spInfo.Detach();
			}
			pTypeLib->Release();
		}
        else
            ASSERT(FALSE);

	}
	LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
	_Module.AddTermFunc(Cleanup, (DWORD_PTR)this);
	return hRes;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\warning.h ===
//--------------------------------------------------------------------------
// warning.h
//--------------------------------------------------------------------------
// Warnings we want to ignore
//--------------------------------------------------------------------------
// Copyright (c) 1997, Microsoft Corporation
//		       All Rights Reserved
// Information Contained Herein Is Proprietary and Confidential.
//--------------------------------------------------------------------------

#ifndef __warning_h
#define __warning_h

// Warning that symbols are > 255 characters
#pragma warning (disable : 4786 )

// Warning that formal parameters are unused (common with OLE interfaces)
#pragma warning (disable : 4100 )

#endif // __warning_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\W4Char.inl ===
// W4Char.inl
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1999 Microsoft Corporation.  All Rights Reserved.
//
// July 24, 1999 [paulde] Paul Chase Dempsey
//
//-----------------------------------------------------------------

inline int WINAPI W4StrLen (PCW4STR pw4Str)
{
  if (!pw4Str) return 0;
  PCW4STR pch = pw4Str;
  while (*pch)
    ++pch;
  return (LONG32)(pch - pw4Str);
}

//-----------------------------------------------------------------
// W4CharRange
//
// Returns:
// -1  Out of UTF-16 (Unicode) range
//  0  Basic Unicode, i.e. BMP, plane 1
//  1  Surrogate
//
inline int WINAPI W4CharRange (W4CHAR ch)
{
  if (ch <= 0x0000FFFF) return 0;
  if (ch <= 0x0010FFFF) return 1;
  return -1;
}

//-----------------------------------------------------------------
inline int WINAPI WLengthOfW4Char (W4CHAR ch)
{
  if (ch <= 0x0000FFFF) return 1;
  if (ch <= 0x0010FFFF) return 2;
  return 1;
}

//-----------------------------------------------------------------
inline W4CHAR WINAPI MakeW4Char (WCHAR chHi, WCHAR chLo)
{
  UASSERT(IsHighSurrogate(chHi) && IsLowSurrogate(chLo));
  return ((W4CHAR)(chHi - UCH_HI_SURROGATE_FIRST) << 10) + 
         ((W4CHAR)(chLo - UCH_LO_SURROGATE_FIRST) + 0x00100000);

}

//-----------------------------------------------------------------
inline PWSTR WINAPI MakeSurrogatePair (PWSTR pch, W4CHAR ch)
{
  UASSERT(pch);
  UASSERT(ch > 0x0000FFFF && ch <= 0x0010FFFF);
  ch -= 0x0010000;
  *pch++ = (WCHAR)((ch >> 10) + UCH_HI_SURROGATE_FIRST);
  *pch++ = (WCHAR)((ch & 0x000003FF) + UCH_LO_SURROGATE_FIRST);
  return pch;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\WStrArr.h ===
// WStrArr.h - WCHAR CPtrArray type and helpers

#pragma once
#include "util.h"
#include "vsmem.h"
#include "awconv.h"

typedef CPtrArray<WCHAR> CWStrArray;
typedef int (__cdecl *WSTRARRCMP)(WCHAR **p1, WCHAR **p2);

inline void     CWStrArray_SortNoCase (CWStrArray & ar) { ar.Sort((WSTRARRCMP)QCompareNoCase); }
inline void     CWStrArray_SortCase   (CWStrArray & ar) { ar.Sort((WSTRARRCMP)QCompareCase); }
inline int      CWStrArray_FindCase   (CWStrArray & ar, PCWSTR sz) { return ar.BSearch(sz, (WSTRARRCMP)BCompareCase); }
inline int      CWStrArray_FindNoCase (CWStrArray & ar, PCWSTR sz) { return ar.BSearch(sz, (WSTRARRCMP)BCompareNoCase); }
inline HRESULT  CWStrArray_Add        (CWStrArray & ar, PCWSTR sz)
{
    PWSTR p;
    HRESULT hr = StrDupW(sz, &p);
    if (FAILED(hr)) return hr;
    if (ar.Add(p))
        return S_OK;
    else 
    {
        VSFree(p);
        return E_OUTOFMEMORY;
    }
}
inline void     CWStrArray_Empty      (CWStrArray & ar)
{
    for (int i = 0; i < ar.Count(); i++)
        VSFree(ar.GetAt(i));
    ar.RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\WComCtl.h ===
// WComCtl.h - Common controls Unicode wrapper
//
// Currently supports only Tree View, List View, and Tab Control.
//
// Adding other controls is fairly straightforward. It should be 
// added here and follow the same pattern as the wrappers here.
//
//-----------------------------------------------------------------
// Microsoft Confidential
// Copyright 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
// Paul Chase Dempsey - paulde@microsoft.com
// August 3, 1998
// December 15, 1999: Adapted from HTMLHelp version for VS
//----------------------------------------------------------------
#pragma once
#include <commctrl.h>
#include "uniapi.h"

/*================================================================
This file lets you program to the List View, Tree View, and Tab controls
solely in Unicode, independent of the platform (Win9x vs NT) and independent
of the type of build (ANSI/SBCS/MBCS/UNICODE). When the platform or installed 
common controls supports Unicode, you get full Unicode capability (even on Win9x).

When Unicode is not supported, capability degrades and items are converted to 
ANSI using CP_ACP. Extra programming may be required to support degrading to ANSI
when you cannot guarantee that the Unicode-enabled versions of the common controls
are installed on the user's system. 

This file defines all the standard common control macros with the prefix "W_".
For macros that do not require conversion, they are direct aliases of the
standard macro. For macros that might require conversion, the macro maps
to a helper that does the right thing.

If you use callbacks or notifications, you may need to supply both ANSI 
and Unicode versions of the callbacks/notifications. The wrappers cannot 
hide this difference from you.

Dependencies: UniLib$(D).lib, util$(D).lib, vsassert.lib (DEBUG only)

----------------------------------------------------------------
Using WComCtl.h:

To create a Unicode control explicitly, call W_CreateControlWindow. 

If the control is on a dialog template, call W_EnableUnicode on the 
control in your WM_INITDIALOG handler. 

Prepend all TreeView_, ListView_, and TabCtrl_ macros with "W_". 

Convert your string and data types to explicitly Unicode, for example:
LPSTR -> LPWSTR, LV_ITEM -> LV_ITEMW, TV_INSERTSTRUCT -> TV_INSERTSTRUCTW, etc.

If you implement callbacks or handle notifications, review your code to
see if you need to handle both A and W versions of the callback or 
notification. If your product may run on a Win9x system without the 
Unicode-enabled version of common controls, you must implement both.

To see if a callback or notification message comes in ANSI and UNICODE 
flavors, look in commctl.h to see if there are separate items defined.

================================================================*/

enum CCTLWINTYPE { W_ListView, W_TreeView, W_TabCtrl };

// Just like CreateWindowEx, but uses CCTLWINTYPE enumeration
HWND WINAPI W_CreateControlWindow (
    DWORD        dwStyleEx,
    DWORD        dwStyle,
    CCTLWINTYPE  wt,
    LPCWSTR      pwszTitle,
    int x, int y, int width, int height,
    HWND         parent,
    HMENU        menu,
    HINSTANCE    inst,
    LPVOID       lParam
    );

// Call this for controls created via a dialog template
BOOL     WINAPI W_EnableUnicode (HWND hwndCtl, CCTLWINTYPE wt);

int      WINAPI W_CompareString (LCID lcid, DWORD dwFlags, PCWSTR str1, int cch1, PCWSTR str2, int cch2);
int      WINAPI W_cbchMaxAcp(); // max bytes per char for CP_ACP (less ugly name would be nice :-)

UINT WINAPI CodePageFromLCID(LCID lcid);

//================================================================
// Generic A/W utils to support creating windows as Unicode when possible
#if 0 // in uniapi
HWND     WINAPI W_CreateWindowEx (
    // Standard CreateWindowEx params
    DWORD     dwExStyle,
    LPCWSTR   lpClassName,
    LPCWSTR   lpWindowName,
    DWORD     dwStyle,
    int       X,
    int       Y,
    int       nWidth,
    int       nHeight,
    HWND      hWndParent,
    HMENU     hMenu,
    HINSTANCE hInstance,
    LPVOID    lpParam,
    // Return flag whether we got a Unicode one (may be NULL).
    // You can always call IsWindowUnicode() to see if an hwnd is Unicode.
    BOOL *    pfUnicode = NULL
    );

inline HWND WINAPI W_CreateWindow(LPCWSTR lpClassName, LPCWSTR lpWindowName, 
                                  DWORD dwStyle, 
                                  int x, int y, int nWidth, int nHeight, 
                                  HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam, 
                                  BOOL * pfUni = NULL)
{
    return  W_CreateWindowEx(0L, lpClassName, lpWindowName, 
        dwStyle, 
        x, y, nWidth, nHeight, 
        hWndParent, hMenu, hInstance, lpParam, pfUni);
}
#endif

// W_SubClassWindow - subclasses hwnd as Unicode (SetWindowLongW) or Ansi (SetWindowLongA)
// according to fUnicode. Asserts if fUnicode is true, and you're on WIn95.
void     WINAPI W_SubClassWindow        (HWND hwnd, void* Proc, BOOL fUnicode);

// Like W_SubClassWindow, except GetWindowLong W/A GWL_WNDPROC
WNDPROC  WINAPI W_GetWndProc            (HWND hwnd, BOOL fUnicode);

//
// The following functions make the appropriate A/W call 
// depending on the A/W type of hwnd.
//
// W_DelegateWindowProc == CallWindowProc
LRESULT  WINAPI W_DelegateWindowProc    (WNDPROC Proc, HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT  WINAPI W_DefWindowProc         (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT  WINAPI W_DefDlgProc            (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

BOOL     WINAPI W_HasText               (HWND hwnd); // window text length > 0
int      WINAPI W_GetTextLengthExact    (HWND hwnd); // Standard GetWindowTextLength is only guaranteed to be large enough -- not always exact

#if 0 // in uniapi
int      WINAPI W_GetWindowText         (HWND hwnd, PWSTR psz, int cchMax);
BOOL     WINAPI W_SetWindowText         (HWND hwnd, PCWSTR psz);
#endif

// Passes psz (or psz converted to ANSI on Win9x) in LPARAM
LRESULT  WINAPI W_SendStringMessage     (HWND hwnd, UINT msg, WPARAM wParam, PCWSTR psz);

//================================================================
// Combo box
//================================================================
#if 0 // HH invention. Windows standard is CRLF-delimited.
// ComboBox
// '\n'-delimited list of strings, return length of returned string
int      WINAPI W_ComboBox_GetListText  (HWND hwnd, PWSTR psz, int cchMax);
// '\n'-delimited list of strings, return count of items added
int      WINAPI W_ComboBox_SetListText  (HWND hwnd, PWSTR psz, int cItemsMax);
#endif

#define W_ComboBox_AddString(hwnd, psz)              ((int)(DWORD)W_SendStringMessage((hwnd), CB_ADDSTRING, 0L, psz))
#define W_ComboBox_InsertString(hwnd, index, psz)    ((int)(DWORD)W_SendStringMessage((hwnd), CB_INSERTSTRING,    (WPARAM)(int)(index), psz))
#define W_ComboBox_FindStringExact(hwnd, index, psz) ((int)(DWORD)W_SendStringMessage((hwnd), CB_FINDSTRINGEXACT, (WPARAM)(int)(index), psz))
#define W_ComboBox_SelectString(hwnd, index, psz)    ((int)(DWORD)W_SendStringMessage((hwnd), CB_SELECTSTRING,    (WPARAM)(int)(index), psz))

//================================================================
// List View
//================================================================

BOOL WINAPI W_IsListViewUnicode(HWND hwndLV);

//
// API helpers
//

BOOL WINAPI W_ListView_GetItem_fn          (HWND hwnd, LV_ITEMW * pitem);
BOOL WINAPI W_ListView_SetItem_fn          (HWND hwnd, LV_ITEMW * pitem);
int  WINAPI W_ListView_InsertItem_fn       (HWND hwnd, LV_ITEMW * pitem);
int  WINAPI W_ListView_FindItem_fn         (HWND hwnd, int iStart, LV_FINDINFOW * plvfi);
int  WINAPI W_ListView_GetStringWidth_fn   (HWND hwnd, LPCWSTR psz);
HWND WINAPI W_ListView_EditLabel_fn        (HWND hwnd, int i);
BOOL WINAPI W_ListView_GetColumn_fn        (HWND hwnd, int iCol, LV_COLUMNW * pcol);
BOOL WINAPI W_ListView_SetColumn_fn        (HWND hwnd, int iCol, LV_COLUMNW * pcol);
int  WINAPI W_ListView_InsertColumn_fn     (HWND hwnd, int iCol, LV_COLUMNW * pcol);
void WINAPI W_ListView_GetItemText_fn      (HWND hwnd, int i, int iSubItem_, LPWSTR  pszText_, int cchTextMax_);
void WINAPI W_ListView_SetItemText_fn      (HWND hwnd, int i, int iSubItem_, LPCWSTR pszText_);
BOOL WINAPI W_ListView_GetISearchString_fn (HWND hwnd, LPWSTR lpsz);
BOOL WINAPI W_ListView_SetBkImage_fn       (HWND hwnd, LPLVBKIMAGEW plvbki);
BOOL WINAPI W_ListView_GetBkImage_fn       (HWND hwnd, LPLVBKIMAGEW plvbki);

//
// Complete Unicode ListView_ API
//

#define W_ListView_GetBkColor(hwnd)                         ListView_GetBkColor(hwnd)
#define W_ListView_SetBkColor(hwnd, clrBk)                  ListView_SetBkColor(hwnd, clrBk)
#define W_ListView_GetImageList(hwnd, iImageList)           ListView_GetImageList(hwnd, iImageList)
#define W_ListView_SetImageList(hwnd, himl, iImageList)     ListView_SetImageList(hwnd, himl, iImageList)
#define W_ListView_GetItemCount(hwnd)                       ListView_GetItemCount(hwnd)
#define W_ListView_GetItem(hwnd, pitem)                   W_ListView_GetItem_fn(hwnd, pitem)
#define W_ListView_SetItem(hwnd, pitem)                   W_ListView_SetItem_fn(hwnd, pitem)
#define W_ListView_InsertItem(hwnd, pitem)                W_ListView_InsertItem_fn(hwnd, pitem)
#define W_ListView_DeleteItem(hwnd, i)                      ListView_DeleteItem(hwnd, i)
#define W_ListView_DeleteAllItems(hwnd)                     ListView_DeleteAllItems(hwnd)
#define W_ListView_GetCallbackMask(hwnd)                    ListView_GetCallbackMask(hwnd)
#define W_ListView_SetCallbackMask(hwnd, mask)              ListView_SetCallbackMask(hwnd, mask)
#define W_ListView_GetNextItem(hwnd, i, flags)              ListView_GetNextItem(hwnd, i, flags)
#define W_ListView_FindItem(hwnd, iStart, plvfi)          W_ListView_FindItem_fn(hwnd, iStart, plvfi)
#define W_ListView_GetItemRect(hwnd, i, prc, code)          ListView_GetItemRect(hwnd, i, prc, code)
#define W_ListView_SetItemPosition(hwndLV, i, x, y)         ListView_SetItemPosition(hwndLV, i, x, y)
#define W_ListView_GetItemPosition(hwndLV, i, ppt)          ListView_GetItemPosition(hwndLV, i, ppt)
#define W_ListView_GetStringWidth(hwndLV, psz)            W_ListView_GetStringWidth_fn(hwndLV, psz)
#define W_ListView_HitTest(hwndLV, pinfo)                   ListView_HitTest(hwndLV, pinfo)
#define W_ListView_EnsureVisible(hwndLV, i, fPartialOK)     ListView_EnsureVisible(hwndLV, i, fPartialOK)
#define W_ListView_Scroll(hwndLV, dx, dy)                   ListView_Scroll(hwndLV, dx, dy)
#define W_ListView_RedrawItems(hwndLV, iFirst, iLast)       ListView_RedrawItems(hwndLV, iFirst, iLast)
#define W_ListView_Arrange(hwndLV, code)                    ListView_Arrange(hwndLV, code)
#define W_ListView_EditLabel(hwndLV, i)                   W_ListView_EditLabel_fn(hwndLV, i)
#define W_ListView_GetEditControl(hwndLV)                   ListView_GetEditControl(hwndLV)
#define W_ListView_GetColumn(hwnd, iCol, pcol)            W_ListView_GetColumn_fn(hwnd, iCol, pcol)
#define W_ListView_SetColumn(hwnd, iCol, pcol)            W_ListView_SetColumn_fn(hwnd, iCol, pcol)
#define W_ListView_InsertColumn(hwnd, iCol, pcol)         W_ListView_InsertColumn_fn(hwnd, iCol, pcol)
#define W_ListView_DeleteColumn(hwnd, iCol)                 ListView_DeleteColumn(hwnd, iCol)
#define W_ListView_GetColumnWidth(hwnd, iCol)               ListView_GetColumnWidth(hwnd, iCol)
#define W_ListView_SetColumnWidth(hwnd, iCol, cx)           ListView_SetColumnWidth(hwnd, iCol, cx)
#define W_ListView_GetHeader(hwnd)                          ListView_GetHeader(hwnd)
#define W_ListView_CreateDragImage(hwnd, i, lpptUpLeft)     ListView_CreateDragImage(hwnd, i, lpptUpLeft)
#define W_ListView_GetViewRect(hwnd, prc)                   ListView_GetViewRect(hwnd, prc)
#define W_ListView_GetTextColor(hwnd)                       ListView_GetTextColor(hwnd)
#define W_ListView_SetTextColor(hwnd, clrText)              ListView_SetTextColor(hwnd, clrText)
#define W_ListView_GetTextBkColor(hwnd)                     ListView_GetTextBkColor(hwnd)
#define W_ListView_SetTextBkColor(hwnd, clrTextBk)          ListView_SetTextBkColor(hwnd, clrTextBk)
#define W_ListView_GetTopIndex(hwndLV)                      ListView_GetTopIndex(hwndLV)
#define W_ListView_GetCountPerPage(hwndLV)                  ListView_GetCountPerPage(hwndLV)
#define W_ListView_GetOrigin(hwndLV, ppt)                   ListView_GetOrigin(hwndLV, ppt)
#define W_ListView_Update(hwndLV, i)                        ListView_Update(hwndLV, i)
#define W_ListView_SetItemState(hwndLV, i, data, mask)      ListView_SetItemState(hwndLV, i, data, mask)
#define W_ListView_GetItemState(hwndLV, i, mask)            ListView_GetItemState(hwndLV, i, mask)
#define W_ListView_GetCheckState(hwndLV, i)                 ListView_GetCheckState(hwndLV, i)
#define W_ListView_GetItemText(hwndLV, i, iSubItem_, pszText_, cchTextMax_) W_ListView_GetItemText_fn(hwndLV, i, iSubItem_, pszText_, cchTextMax_)
#define W_ListView_SetItemText(hwndLV, i, iSubItem_, pszText_)              W_ListView_SetItemText_fn(hwndLV, i, iSubItem_, pszText_)
#define W_ListView_SetItemCount(hwndLV, cItems)             ListView_SetItemCount(hwndLV, cItems)
#define W_ListView_SetItemCountEx(hwndLV, cItems, dwFlags)  ListView_SetItemCountEx(hwndLV, cItems, dwFlags)
#define W_ListView_SortItems(hwndLV, _pfnCompare, _lPrm)    ListView_SortItems(hwndLV, _pfnCompare, _lPrm)
#define W_ListView_SetItemPosition32(hwndLV, i, x, y)       ListView_SetItemPosition32(hwndLV, i, x, y)
#define W_ListView_GetSelectedCount(hwndLV)                 ListView_GetSelectedCount(hwndLV)
#define W_ListView_GetItemSpacing(hwndLV, fSmall)           ListView_GetItemSpacing(hwndLV, fSmall)
#define W_ListView_GetISearchString(hwndLV, lpsz)         W_ListView_GetISearchString_fn(hwndLV, lpsz)
#define W_ListView_SetIconSpacing(hwndLV, cx, cy)           ListView_SetIconSpacing(hwndLV, cx, cy)

#define W_ListView_SetExtendedListViewStyle(hwndLV, dw)             ListView_SetExtendedListViewStyle(hwndLV, dw)
#define W_ListView_SetExtendedListViewStyleEx(hwndLV, dwMask, dw)   ListView_SetExtendedListViewStyleEx(hwndLV, dwMask, dw)
#define W_ListView_GetExtendedListViewStyle(hwndLV)                 ListView_GetExtendedListViewStyle(hwndLV)
#define W_ListView_GetExtendedListViewStyle(hwndLV)                 ListView_GetExtendedListViewStyle(hwndLV)

#define W_ListView_GetSubItemRect(hwnd, iItem, iSubItem, code, prc) ListView_GetSubItemRect(hwnd, iItem, iSubItem, code, prc)
#define W_ListView_SubItemHitTest(hwnd, plvhti)                     ListView_SubItemHitTest(hwnd, plvhti)
#define W_ListView_SetColumnOrderArray(hwnd, iCount, pi)            ListView_SetColumnOrderArray(hwnd, iCount, pi)
#define W_ListView_GetColumnOrderArray(hwnd, iCount, pi)            ListView_GetColumnOrderArray(hwnd, iCount, pi)
#define W_ListView_SetHotItem(hwnd, i)                              ListView_SetHotItem(hwnd, i)
#define W_ListView_GetHotItem(hwnd)                                 ListView_GetHotItem(hwnd)
#define W_ListView_SetHotCursor(hwnd, hcur)                         ListView_SetHotCursor(hwnd, hcur)
#define W_ListView_GetHotCursor(hwnd)                               ListView_GetHotCursor(hwnd)
#define W_ListView_ApproximateViewRect(hwnd, iWidth, iHeight, iCount)   ListView_ApproximateViewRect(hwnd, iWidth, iHeight, iCount)
#define W_ListView_SetWorkAreas(hwnd, nWorkAreas, prc)              ListView_SetWorkAreas(hwnd, nWorkAreas, prc)
#define W_ListView_GetWorkAreas(hwnd, nWorkAreas, prc)              ListView_GetWorkAreas(hwnd, nWorkAreas, prc)
#define W_ListView_GetNumberOfWorkAreas(hwnd, pnWorkAreas)          ListView_GetNumberOfWorkAreas(hwnd, pnWorkAreas)
#define W_ListView_GetSelectionMark(hwnd)                           ListView_GetSelectionMark(hwnd)
#define W_ListView_SetSelectionMark(hwnd, i)                        ListView_SetSelectionMark(hwnd, i)
#define W_ListView_SetHoverTime(hwndLV, dwHoverTimeMs)              ListView_SetHoverTime(hwndLV, dwHoverTimeMs)
#define W_ListView_GetHoverTime(hwndLV)                             ListView_GetHoverTime(hwndLV)
#define W_ListView_SetToolTipHwnd(hwndLV, hwndNewHwnd)              ListView_SetToolTipHwnd(hwndLV, hwndNewHwnd)
#define W_ListView_GetToolTipHwnd(hwndLV)                           ListView_GetToolTipHwnd(hwndLV)
#define W_ListView_SetBkImage(hwnd, plvbki)                       W_ListView_SetBkImage_fn(hwnd, plvbki)
#define W_ListView_GetBkImage(hwnd, plvbki)                       W_ListView_GetBkImage_fn(hwnd, plvbki)

//================================================================
// Tree View
//================================================================

// W_IsTreeViewUnicode
//
// WARNING: alters contents of the control to test it's capabilities.
// If you need to know this ifnormation, call this API only once at 
// init time (before you add anything to to the control) and save the flag.
//
BOOL      WINAPI W_IsTreeViewUnicode(HWND hwndTV);

//
// wrapper helpers
//

HTREEITEM WINAPI W_TreeView_InsertItem_fn(HWND hwnd, LPTV_INSERTSTRUCTW lpis);
BOOL WINAPI W_TreeView_GetItem_fn(HWND hwnd, TV_ITEMW * pitem);
BOOL WINAPI W_TreeView_SetItem_fn(HWND hwnd, TV_ITEMW * pitem);
HWND WINAPI W_TreeView_EditLabel_fn(HWND hwnd, HTREEITEM hitem);
BOOL WINAPI W_TreeView_GetISearchString_fn(HWND hwndTV, LPWSTR lpsz);

//
// Complete Unicode TreeView_ API
//

#define W_TreeView_InsertItem(hwnd, lpis)                   W_TreeView_InsertItem_fn(hwnd, lpis)
#define W_TreeView_DeleteItem(hwnd, hitem)                  TreeView_DeleteItem(hwnd, hitem)
#define W_TreeView_DeleteAllItems(hwnd)                     TreeView_DeleteAllItems(hwnd)
#define W_TreeView_Expand(hwnd, hitem, code)                TreeView_Expand(hwnd, hitem, code)
#define W_TreeView_GetItemRect(hwnd, hitem, prc, code)      TreeView_GetItemRect(hwnd, hitem, prc, code)
#define W_TreeView_GetCount(hwnd)                           TreeView_GetCount(hwnd)
#define W_TreeView_GetIndent(hwnd)                          TreeView_GetIndent(hwnd)
#define W_TreeView_SetIndent(hwnd, indent)                  TreeView_SetIndent(hwnd, indent)
#define W_TreeView_GetImageList(hwnd, iImage)               TreeView_GetImageList(hwnd, iImage)
#define W_TreeView_SetImageList(hwnd, himl, iImage)         TreeView_SetImageList(hwnd, himl, iImage)
#define W_TreeView_GetNextItem(hwnd, hitem, code)           TreeView_GetNextItem(hwnd, hitem, code)
#define W_TreeView_GetChild(hwnd, hitem)                    TreeView_GetChild(hwnd, hitem)          
#define W_TreeView_GetNextSibling(hwnd, hitem)              TreeView_GetNextSibling(hwnd, hitem)    
#define W_TreeView_GetPrevSibling(hwnd, hitem)              TreeView_GetPrevSibling(hwnd, hitem)    
#define W_TreeView_GetParent(hwnd, hitem)                   TreeView_GetParent(hwnd, hitem)         
#define W_TreeView_GetFirstVisible(hwnd)                    TreeView_GetFirstVisible(hwnd)          
#define W_TreeView_GetNextVisible(hwnd, hitem)              TreeView_GetNextVisible(hwnd, hitem)    
#define W_TreeView_GetPrevVisible(hwnd, hitem)              TreeView_GetPrevVisible(hwnd, hitem)    
#define W_TreeView_GetSelection(hwnd)                       TreeView_GetSelection(hwnd)             
#define W_TreeView_GetDropHilight(hwnd)                     TreeView_GetDropHilight(hwnd)           
#define W_TreeView_GetRoot(hwnd)                            TreeView_GetRoot(hwnd)                  
#define W_TreeView_GetLastVisible(hwnd)                     TreeView_GetLastVisible(hwnd)
#define W_TreeView_Select(hwnd, hitem, code)                TreeView_Select(hwnd, hitem, code)
#define W_TreeView_SelectItem(hwnd, hitem)                  TreeView_SelectItem(hwnd, hitem)            
#define W_TreeView_SelectDropTarget(hwnd, hitem)            TreeView_SelectDropTarget(hwnd, hitem)      
#define W_TreeView_SelectSetFirstVisible(hwnd, hitem)       TreeView_SelectSetFirstVisible(hwnd, hitem) 
#define W_TreeView_GetItem(hwnd, pitem)                   W_TreeView_GetItem_fn(hwnd, pitem)
#define W_TreeView_SetItem(hwnd, pitem)                   W_TreeView_SetItem_fn(hwnd, pitem)
#define W_TreeView_EditLabel(hwnd, hitem)                 W_TreeView_EditLabel_fn(hwnd, hitem)
#define W_TreeView_GetEditControl(hwnd)                     TreeView_GetEditControl(hwnd)
#define W_TreeView_GetVisibleCount(hwnd)                    TreeView_GetVisibleCount(hwnd)
#define W_TreeView_HitTest(hwnd, lpht)                      TreeView_HitTest(hwnd, lpht)
#define W_TreeView_CreateDragImage(hwnd, hitem)             TreeView_CreateDragImage(hwnd, hitem)
#define W_TreeView_SortChildren(hwnd, hitem, recurse)       TreeView_SortChildren(hwnd, hitem, recurse)
#define W_TreeView_EnsureVisible(hwnd, hitem)               TreeView_EnsureVisible(hwnd, hitem)
#define W_TreeView_SortChildrenCB(hwnd, psort, recurse)     TreeView_SortChildrenCB(hwnd, psort, recurse)
#define W_TreeView_EndEditLabelNow(hwnd, fCancel)           TreeView_EndEditLabelNow(hwnd, fCancel)
#define W_TreeView_SetToolTips(hwnd,  hwndTT)               TreeView_SetToolTips(hwnd,  hwndTT)
#define W_TreeView_GetToolTips(hwnd)                        TreeView_GetToolTips(hwnd)
#define W_TreeView_GetISearchString(hwndTV, lpsz)         W_TreeView_GetISearchString_fn(hwndTV, lpsz)
#define W_TreeView_SetInsertMark(hwnd, hItem, fAfter)       TreeView_SetInsertMark(hwnd, hItem, fAfter)
#define W_TreeView_SetItemHeight(hwnd,  iHeight)            TreeView_SetItemHeight(hwnd,  iHeight)
#define W_TreeView_GetItemHeight(hwnd)                      TreeView_GetItemHeight(hwnd)
#define W_TreeView_SetBkColor(hwnd, clr)                    TreeView_SetBkColor(hwnd, clr)
#define W_TreeView_SetTextColor(hwnd, clr)                  TreeView_SetTextColor(hwnd, clr)
#define W_TreeView_GetBkColor(hwnd)                         TreeView_GetBkColor(hwnd)
#define W_TreeView_GetTextColor(hwnd)                       TreeView_GetTextColor(hwnd)
#define W_TreeView_SetScrollTime(hwnd, uTime)               TreeView_SetScrollTime(hwnd, uTime)
#define W_TreeView_GetScrollTime(hwnd)                      TreeView_GetScrollTime(hwnd)


//================================================================
// TabCtrl
//================================================================

// W_IsTabCtrlUnicode
//
// WARNING: alters contents of the control to test it's capabilities.
// If you need to know this ifnormation, call this API only once at 
// init time (before you add anything to to the control) and save the flag.
//
BOOL WINAPI W_IsTabCtrlUnicode(HWND hwndTC);

//
// wrapper helpers
//

BOOL WINAPI W_TabCtrl_GetItem_fn(HWND hwnd, int iItem, TC_ITEMW * pitem);
BOOL WINAPI W_TabCtrl_SetItem_fn(HWND hwnd, int iItem, TC_ITEMW * pitem);
int  WINAPI W_TabCtrl_InsertItem_fn(HWND hwnd, int iItem, TC_ITEMW * pitem);

//
// Complete Unicode TabCtrl API
//

#define W_TabCtrl_GetImageList(hwnd)                        TabCtrl_GetImageList(hwnd)
#define W_TabCtrl_SetImageList(hwnd, himl)                  TabCtrl_SetImageList(hwnd, himl)
#define W_TabCtrl_GetItemCount(hwnd)                        TabCtrl_GetItemCount(hwnd)
#define W_TabCtrl_GetItem(hwnd, iItem, pitem)             W_TabCtrl_GetItem_fn(hwnd, iItem, pitem)
#define W_TabCtrl_SetItem(hwnd, iItem, pitem)             W_TabCtrl_SetItem_fn(hwnd, iItem, pitem)
#define W_TabCtrl_InsertItem(hwnd, iItem, pitem)          W_TabCtrl_InsertItem_fn(hwnd, iItem, pitem)
#define W_TabCtrl_DeleteItem(hwnd, i)                       TabCtrl_DeleteItem(hwnd, i)                                                        
#define W_TabCtrl_DeleteAllItems(hwnd)                      TabCtrl_DeleteAllItems(hwnd)                                                        
#define W_TabCtrl_GetItemRect(hwnd, i, prc)                 TabCtrl_GetItemRect(hwnd, i, prc)                                                        
#define W_TabCtrl_GetCurSel(hwnd)                           TabCtrl_GetCurSel(hwnd)                                                        
#define W_TabCtrl_SetCurSel(hwnd, i)                        TabCtrl_SetCurSel(hwnd, i)                                                        
#define W_TabCtrl_HitTest(hwndTC, pinfo)                    TabCtrl_HitTest(hwndTC, pinfo)                                                        
#define W_TabCtrl_SetItemExtra(hwndTC, cb)                  TabCtrl_SetItemExtra(hwndTC, cb)                                                        
#define W_TabCtrl_AdjustRect(hwnd, bLarger, prc)            TabCtrl_AdjustRect(hwnd, bLarger, prc)                                                        
#define W_TabCtrl_SetItemSize(hwnd, x, y)                   TabCtrl_SetItemSize(hwnd, x, y)                                                        
#define W_TabCtrl_RemoveImage(hwnd, i)                      TabCtrl_RemoveImage(hwnd, i)                                                        
#define W_TabCtrl_SetPadding(hwnd,  cx, cy)                 TabCtrl_SetPadding(hwnd,  cx, cy)                                                        
#define W_TabCtrl_GetRowCount(hwnd)                         TabCtrl_GetRowCount(hwnd)                                                        
#define W_TabCtrl_GetToolTips(hwnd)                         TabCtrl_GetToolTips(hwnd)                                                        
#define W_TabCtrl_SetToolTips(hwnd, hwndTT)                 TabCtrl_SetToolTips(hwnd, hwndTT)                                                        
#define W_TabCtrl_GetCurFocus(hwnd)                         TabCtrl_GetCurFocus(hwnd)                                                        
#define W_TabCtrl_SetCurFocus(hwnd, i)                      TabCtrl_SetCurFocus(hwnd, i)                                                        
#define W_TabCtrl_SetMinTabWidth(hwnd, x)                   TabCtrl_SetMinTabWidth(hwnd, x)                                                        
#define W_TabCtrl_DeselectAll(hwnd, fExcludeFocus)          TabCtrl_DeselectAll(hwnd, fExcludeFocus)                                                        
#define W_TabCtrl_HighlightItem(hwnd, i, fHighlight)        TabCtrl_HighlightItem(hwnd, i, fHighlight)                                                        
#define W_TabCtrl_SetExtendedStyle(hwnd, dw)                TabCtrl_SetExtendedStyle(hwnd, dw)                                                        
#define W_TabCtrl_GetExtendedStyle(hwnd)                    TabCtrl_GetExtendedStyle(hwnd)                                                        
#define W_TabCtrl_SetUnicodeFormat(hwnd, fUnicode)          TabCtrl_SetUnicodeFormat(hwnd, fUnicode)                                                        
#define W_TabCtrl_GetUnicodeFormat(hwnd)                    TabCtrl_GetUnicodeFormat(hwnd)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\wbids.h ===
#ifndef _WBIDS_H_
#define _WBIDS_H_

#include "MsHtmCID.h"

//////////////////////////////////////////////////////////////////////////////
//
// GUID Identifiers, created by WebBrowse package
//
//////////////////////////////////////////////////////////////////////////////
#ifndef NOGUIDS

#ifdef DEFINE_GUID
  // WB package object CLSID
  DEFINE_GUID (guidWBPkg,
    0xe8b06f41, 0x6d01, 0x11d2, 0xaa, 0x7d, 0x00, 0xc0, 0x4f, 0x99, 0x03, 0x43);

  DEFINE_GUID (guidWBPkgCmd,
    0xe8b06f44, 0x6d01, 0x11d2, 0xaa, 0x7d, 0x00, 0xc0, 0x4f, 0x99, 0x03, 0x43);

  DEFINE_GUID (guidWBGrp,
    0xe8b06f42, 0x6d01, 0x11d2, 0xaa, 0x7d, 0x00, 0xc0, 0x4f, 0x99, 0x03, 0x43);

  DEFINE_GUID (guidFavGrp,
    0xe8b06f49, 0x6d01, 0x11d2, 0xaa, 0x7d, 0x00, 0xc0, 0x4f, 0x99, 0x03, 0x43);

  DEFINE_GUID (guidFavCmd,
    0xe8b06f4a, 0x6d01, 0x11d2, 0xaa, 0x7d, 0x00, 0xc0, 0x4f, 0x99, 0x03, 0x43);

  DEFINE_GUID(guidDynHelp, 
    0x2d2e0d17, 0xc8d0, 0x4744, 0x81, 0x6, 0xed, 0xca, 0x7f, 0x21, 0xc1, 0xac);

#else

#define guidWBPkg	      { 0xe8b06f41, 0x6d01, 0x11d2, { 0xaa, 0x7d, 0x00, 0xc0, 0x4f, 0x99, 0x03, 0x43 } }
#define guidWBPkgCmd    { 0xe8b06f44, 0x6d01, 0x11d2, { 0xaa, 0x7d, 0x00, 0xc0, 0x4f, 0x99, 0x03, 0x43 } }
#define guidWBGrp 	    { 0xe8b06f42, 0x6d01, 0x11d2, { 0xaa, 0x7d, 0x00, 0xc0, 0x4f, 0x99, 0x03, 0x43 } }
#define guidFavGrp 	    { 0xe8b06f49, 0x6d01, 0x11d2, { 0xaa, 0x7d, 0x00, 0xc0, 0x4f, 0x99, 0x03, 0x43 } }
#define guidFavCmd 	    { 0xe8b06f4a, 0x6d01, 0x11d2, { 0xaa, 0x7d, 0x00, 0xc0, 0x4f, 0x99, 0x03, 0x43 } }
#define guidDynHelp	    { 0x2d2e0d17, 0xc8d0, 0x4744, { 0x81, 0x6, 0xed, 0xca, 0x7f, 0x21, 0xc1, 0xac } }

#endif //DEFINE_GUID

#endif //NOGUIDS

///////////////////////////////////////////////////////////////////////////////
// Menus

#define IDM_WBTLB_WEB             1
#define IDM_WBMNU_COMMAND_WELL    2
#define IDM_WBMNU_FONTSIZE        3
#define IDM_WB_OPENIE_CASCADE     4

#define IDM_WBCTX_DEFAULT         10
#define IDM_WBCTX_IMAGE           11
#define IDM_WBCTX_SELECTION       12
#define IDM_WBCTX_ANCHOR          13
//#define IDM_FAVCTX                20
#define IDM_VS_TOOL_FAVORITES     21

#define IDM_WB_ENCODING           25
#define IDM_WB_ENCODING_MORE      26
#define IDM_VS_DYNHELP		  27

#define IDM_WB_HELP_NAV           28

///////////////////////////////////////////////////////////////////////////////
// Menu Groups

#define IDG_WB_MAIN            100
#define IDG_WB_FAVORITES       101
#define IDG_WB_URL             102
#define IDG_WB_HELP            103
#define IDG_WB_OTHER           104
#define IDG_WB_NEW_WINDOW      105
#define IDG_WB_SHOW            106

#define IDG_WB_FONTSIZE           107
#define IDG_WB_MNUCMDS            108
#define IDG_WB_FONTSIZELIST       109
#define IDG_WB_OPENIE_CASCADE     110
#define IDG_WB_CMDWELL            111
#define IDG_WB_CMDWELL_MAINMENU   112

#define IDG_WB_BACK_FORWARD       113
#define IDG_WB_HOME_SEARCH        114

#define IDG_WB_CTX_DEF_0          119
#define IDG_WB_CTX_DEF_1          120
#define IDG_WB_CTX_DEF_2          121
#define IDG_WB_CTX_DEF_3          122
#define IDG_WB_CTX_DEF_4          123
#define IDG_WB_CTX_PROPS          124
#define IDG_WB_CTX_ANCHOR         125
#define IDG_WB_CTX_IMG_1          126
#define IDG_WB_CTX_IMG_2          127
#define IDG_WB_CTX_SEL_1          128
#define IDG_WB_CTX_ANC_1          129

// for MSDN
//#define IDG_WB_FAVWND             130

#define IDG_WB_HELP_TOC_NAV       131

#define IDG_FAV_ADDORG            144
#define IDG_VS_DYNHELP		  145
#define IDG_VS_DYNHELP_TB         146

#define IDG_WB_ENCODING           150
#define IDG_WB_ENCODING_AUTO      151
#define IDG_WB_ENCODING_MRU       152

#define IDG_WB_CP_ARABIC          155
#define IDG_WB_CP_BALTIC          156
#define IDG_WB_CP_CENTRAL_EURO    157
#define IDG_WB_CP_CHINESE_SIMPL   158
#define IDG_WB_CP_CHINESE_TRAD    159
#define IDG_WB_CP_CYRILLIC        160
#define IDG_WB_CP_GREEK           161
#define IDG_WB_CP_HEBREW          162
#define IDG_WB_CP_JAPANESE        163
#define IDG_WB_CP_KOREAN          164
#define IDG_WB_CP_THAI            165
#define IDG_WB_CP_TURKISH         166
#define IDG_WB_CP_UKRAINIAN       167
#define IDG_WB_CP_UNICODE         168
#define IDG_WB_CP_USERDEFINED     169
#define IDG_WB_CP_VIETNAMESE      170
#define IDG_WB_CP_WESTERN_EURO    171


///////////////////////////////////////////////////////////////////////////////
// Command IDs

#define icmdBack                  201 
#define icmdForward               202
#define icmdStop                  203
#define icmdRefresh               204
#define icmdHome                  205
#define icmdSearch                206
#define icmdURL                   207
#define icmdURLHandler            208
#define icmdFavWindow             210
#define icmdDocFavAdd             211
#define icmdAnchorFavAdd          212
#define icmdImgFavAdd             213
#define icmdFntSzSmallest         214
#define icmdFntSzSmaller          215
#define icmdFntSzMedium           216
#define icmdFntSzLarger           217
#define icmdFntSzLargest          218
#define icmdFontSize              219

#define icmdFavOpen               300
#define icmdFavRename             301
#define icmdOpenLinkNew           303

#define icmdFavAdd		  310
#define icmdFavOrganize		  311

#define icmdContextWindow         400

// help commands 

#define icmdSync                  401
#define icmdNext                  402
#define icmdPrev                  403

#define icmdIEFind                405

// Encoding commands

#define icmdCpFirst               410
#define icmdCpArabicASMO          410
#define icmdCpArabicDOS           411
#define icmdCpArabicISO           412
#define icmdCpArabicWIN           413
#define icmdCpBalticISO           414
#define icmdCpBalticWIN           415
#define icmdCpCentralEuroDOS      416
#define icmdCpCentralEuroISO      417
#define icmdCpCentralEuroWIN      418
#define icmdCpChineseSimplified   419
#define icmdCpChineseTraditional  420
#define icmdCpCyrillicDOS         421
#define icmdCpCyrillicISO         422
#define icmdCpCyrillicKOI8R       423
#define icmdCpCyrillicWIN         424
#define icmdCpGreekISO            425
#define icmdCpGreekWIN            426
#define icmdCpHebrewDOS           427
#define icmdCpHebrewISO           428
#define icmdCpHebrewWIN           429
#define icmdCpJapaneseAUTO        430
#define icmdCpJapaneseEUC         431
#define icmdCpJapaneseSHIFT_JIS   432
#define icmdCpKoreanAUTO          433
//#define icmdCpKorean              434
//#define icmdCpKoreanISO           435
#define icmdCpThaiWIN             436
#define icmdCpTurkishWIN          437
#define icmdCpTurkishISO          438
#define icmdCpUkrainian           439
//#define icmdCpUnicodeUTF7         440
#define icmdCpUnicodeUTF8         441
#define icmdCpVietnamese          442
#define icmdCpWesternEuroWIN      443
#define icmdCpWesternEuroISO      444
#define icmdCpUserDefined         445
#define icmdCpLast                445

#define icmdCpMRU1                460
#define icmdCpMRU2                461
#define icmdCpMRU3                462
#define icmdCpMRU4                463



// Directly mapped Trident Commands
#define icmdCpAuto                IDM_AUTODETECT

#define icmdOpenLink              IDM_FOLLOWLINKC
#define icmdOpenLinkExt           IDM_FOLLOWLINKN
#define icmdSaveTargetAs          IDM_SAVETARGET
#define icmdPrintTarget           IDM_PRINTTARGET

#define icmdSaveBgrndAs           IDM_SAVEBACKGROUND
#define icmdCopyBackground        IDM_COPYBACKGROUND

#define icmdViewSource            IDM_VIEWSOURCE

#define icmdShowPicture           IDM_SHOWPICTURE
#define icmdSavePicture           IDM_SAVEPICTURE
#define icmdCopyShortcut          IDM_COPYSHORTCUT

#define icmdProperties            IDM_PROPERTIES

#define icmdCloseWB               4998
#define icmdNavigate              4999
#define icmdOpenWB                5000
#define icmdWebBrowserFirst       5001
// don't define command > icmdWebBrowserFirst

///////////////////////////////////////////////////////////////////////////////
// Button Bitmap IDs

#define bmpidWebBrowser           1
#define bmpidBack                 2
#define bmpidForward              3
#define bmpidStop                 4
#define bmpidRefresh              5
#define bmpidHome                 6
#define bmpidSearch               7
#define bmpidFavWindow            8
#define bmpidFavAdd               9
#define bmpidFontSize             10
#define bmpidOpenLink             11
#define bmpidWebSave              12
#define bmpidPicSave              13
#define bmpidProperties           14
#define bmpidFavOrganize          15

#define bmpidSync                 16
#define bmpidPrev                 17
#define bmpidNext                 18
#define bmpidVsDynamicHelp        19

#endif //_WBIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\wmappcmd.h ===
#pragma once

// copy of WM_APPCOMMAND definition from winuser.h to be able to use it with _WIN32_WINNT = 0x0400
// WM_APPCOMMND works on NT4 and Win98 with IntelliType Pro or IntelliPoint software installed,
// but winuser defines it only for _WIN32_WINNT >= 0x0500

#ifndef WM_APPCOMMAND

#define WM_APPCOMMAND 0x0319

/* cmd for HSHELL_APPCOMMAND and WM_APPCOMMAND */
#define APPCOMMAND_BROWSER_BACKWARD       1
#define APPCOMMAND_BROWSER_FORWARD        2
#define APPCOMMAND_BROWSER_REFRESH        3
#define APPCOMMAND_BROWSER_STOP           4
#define APPCOMMAND_BROWSER_SEARCH         5
#define APPCOMMAND_BROWSER_FAVORITES      6
#define APPCOMMAND_BROWSER_HOME           7
#define APPCOMMAND_VOLUME_MUTE            8
#define APPCOMMAND_VOLUME_DOWN            9
#define APPCOMMAND_VOLUME_UP              10
#define APPCOMMAND_MEDIA_NEXTTRACK        11
#define APPCOMMAND_MEDIA_PREVIOUSTRACK    12
#define APPCOMMAND_MEDIA_STOP             13
#define APPCOMMAND_MEDIA_PLAY_PAUSE       14
#define APPCOMMAND_LAUNCH_MAIL            15
#define APPCOMMAND_LAUNCH_MEDIA_SELECT    16
#define APPCOMMAND_LAUNCH_APP1            17
#define APPCOMMAND_LAUNCH_APP2            18
#define APPCOMMAND_BASS_DOWN              19
#define APPCOMMAND_BASS_BOOST             20
#define APPCOMMAND_BASS_UP                21
#define APPCOMMAND_TREBLE_DOWN            22
#define APPCOMMAND_TREBLE_UP              23
#define APPCOMMAND_MICROPHONE_VOLUME_MUTE 24
#define APPCOMMAND_MICROPHONE_VOLUME_DOWN 25
#define APPCOMMAND_MICROPHONE_VOLUME_UP   26

#define FAPPCOMMAND_MOUSE 0x8000
#define FAPPCOMMAND_KEY   0
#define FAPPCOMMAND_OEM   0x1000
#define FAPPCOMMAND_MASK  0xF000

#define GET_APPCOMMAND_LPARAM(lParam) ((short)(HIWORD(lParam) & ~FAPPCOMMAND_MASK))
#define GET_DEVICE_LPARAM(lParam)     ((WORD)(HIWORD(lParam) & FAPPCOMMAND_MASK))
#define GET_MOUSEORKEY_LPARAM         GET_DEVICE_LPARAM
#define GET_FLAGS_LPARAM(lParam)      (LOWORD(lParam))
#define GET_KEYSTATE_LPARAM(lParam)   GET_FLAGS_LPARAM(lParam)

#endif //!WM_APPCOMMAND
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsee\vapiempguids.h ===
/*-----------------------------------------------------------------------------
Microsoft VSEE

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc external
@module VapiEmpGuids.h - GUIDs for the Versioning Enlistment Manager Proxy
Put all guids here, and only put them in here once; there should be no
guids in .idl, .rgs, .ctc, .cpp, .c, or .h files, except those generated
by Midl, indirectly from this file.

@owner JayK
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_VSEE_VAPI_EMP_GUIDS_H_INCLUDED_) // {
#define VS_COMMON_INC_VSEE_VAPI_EMP_GUIDS_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/
#include "VseeGuidDataToXxx.h"

/*-----------------------------------------------------------------------------
Guid "data" and guids that have only one needed form here
This form of guids is approximately available from uuidgen -s, then remove the braces and "0x"s.
-----------------------------------------------------------------------------*/
#define CLSID_CVapiEMPUrl_data                               (03696223, 1DD6, 11d3, 85,CF,00,A0,C9,CF,CC,16)
#define CLSID_CVapiEMPSession_data                           (03696224, 1DD6, 11d3, 85,CF,00,A0,C9,CF,CC,16)
#define LIBID_NVseeVersioningEnlistmentManagerProxy_data     (03696225, 1DD6, 11d3, 85,CF,00,A0,C9,CF,CC,16)
#define CLSID_CVapiEMPDataSource_data                        (03696226, 1DD6, 11d3, 85,CF,00,A0,C9,CF,CC,16)
#define CLSID_CVapiEMPWecFactory_data                        (03696227, 1DD6, 11d3, 85,CF,00,A0,C9,CF,CC,16)

/*-----------------------------------------------------------------------------
then various transforms of the guid "data", without ever restating the "data",
follow down below..
-----------------------------------------------------------------------------*/

// CUrl and CSession are not CoCreatable, and the rest are; that's
// why they are the worst offenders in terms of name/type choice
// FUTURE We should probably eliminate completely the generic CLSID_Foo identifiers
// and go with only Hungarian ones.
//
// also realize that instead of CLSID_CVapiEMPSession, you should use
// __uuidof(CVapiEMPSession) or similar if the __declspec(uuid()) is visible to you.

#define szCLSID_CVapiEMPUrl                                    VSEE_GUID_DATA_TO_DASHED_STRING     CLSID_CVapiEMPUrl_data
#define szCLSID_CVapiEMPSession                                VSEE_GUID_DATA_TO_DASHED_STRING     CLSID_CVapiEMPSession_data
                                                                        
// @deprecated FUTURE..                                                    
#define CLSID_CVapiEMPUrl        szCLSID_CVapiEMPUrl                        
#define CLSID_CVapiEMPSession    szCLSID_CVapiEMPSession                    
                                                                        
#define      LIBID_NVseeVersioningEnlistmentManagerProxy       VSEE_GUID_DATA_TO_DASHED             LIBID_NVseeVersioningEnlistmentManagerProxy_data
#define CHAR_LIBID_NVseeVersioningEnlistmentManagerProxy       VSEE_GUID_DATA_TO_DASHED_CHAR        LIBID_NVseeVersioningEnlistmentManagerProxy_data
                                                                        
#define      CLSID_CVapiEMPDataSource                          VSEE_GUID_DATA_TO_DASHED             CLSID_CVapiEMPDataSource_data
#define    szCLSID_CVapiEMPDataSource                          VSEE_GUID_DATA_TO_DASHED_STRING      CLSID_CVapiEMPDataSource_data
#define CHAR_CLSID_CVapiEMPDataSource                          VSEE_GUID_DATA_TO_BRACED_DASHED_CHAR CLSID_CVapiEMPDataSource_data
#define   rgsCLSID_CVapiEMPDataSource                          VSEE_GUID_DATA_TO_BRACED_DASHED      CLSID_CVapiEMPDataSource_data
#define   ctcCLSID_CVapiEMPDataSource /*currently unused*/     VSEE_GUID_DATA_TO_STRUCT_INITIALIZER CLSID_CVapiEMPDataSource_data

#define      CLSID_CVapiEMPWecFactory                          VSEE_GUID_DATA_TO_DASHED             CLSID_CVapiEMPWecFactory_data
#define    szCLSID_CVapiEMPWecFactory                          VSEE_GUID_DATA_TO_DASHED_STRING      CLSID_CVapiEMPWecFactory_data
#define CHAR_CLSID_CVapiEMPWecFactory                          VSEE_GUID_DATA_TO_BRACED_DASHED_CHAR CLSID_CVapiEMPWecFactory_data
#define   rgsCLSID_CVapiEMPWecFactory                          VSEE_GUID_DATA_TO_BRACED_DASHED      CLSID_CVapiEMPWecFactory_data
#define      ctcCLSID_CVapiEMPWecFactory /*currently unused*/  VSEE_GUID_DATA_TO_STRUCT_INITIALIZER CLSID_CVapiEMPWecFactory_data

#if defined(RGS_INVOKED) // {

// For compiling .rgs files into .rgi files.
// FUTURE make this cleaner..

#undef CLSID_CVapiEMPDataSource
#undef CLSID_CVapiEMPWecFactory

#define CLSID_CVapiEMPDataSource rgsCLSID_CVapiEMPDataSource
#define CLSID_CVapiEMPWecFactory rgsCLSID_CVapiEMPWecFactory

#endif // }

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\xpress.h ===
// This code is provided by Windows NT team
// All bug reports, as well as questions should go to AKadatch
#ifndef _XPRESS_H_
#define _XPRESS_H_

#ifdef _MSC_VER
#pragma once
#endif


/* -------------------------------------------------------------------- */
/*                                                                      */
/*               Copyright (c) 1991-1999 by Andrew Kadatch              */
/*                                                                      */
/* -------------------------------------------------------------------- */

#ifdef __cplusplus
extern "C" {
#endif

/* ---------------------- Common declarations ------------------------- */
/*                        -------------------                           */

// max. size of input block
#define XPRESS_MAX_BLOCK_LOG	16
#define XPRESS_MAX_BLOCK	(1 << XPRESS_MAX_BLOCK_LOG)


// preferred data alignment to avoid misaligned accesses
#define XPRESS_ALIGNMENT	8

// declare default calling convention used in xpress
#if !defined (UNIX) && !defined (XPRESS_CALL)
#define XPRESS_CALL __stdcall
#endif


// user-supplied callback function that allocates memory
// if there is no memory available it shall return NULL
typedef
void *
XPRESS_CALL
  XpressAllocFn
  (
    void *context,	// user-defined context (as passed to XpressEncodeCreate)
    int size		// size of memory block to allocate
  );

// user-supplied callback function that releases memory
typedef
void
XPRESS_CALL
  XpressFreeFn
  (
    void *context,	// user-defined context (as passed to XpressEncodeClose)
    void *address	// pointer to the block to be freed
  );

void * XPRESS_CALL my_alloc(void *context, int size);
void XPRESS_CALL my_free(void *context, void *memory);


/* ----------------------------- Encoder ------------------------------ */
/*                               -------                                */

// declare unique anonymous types for type safety
typedef struct {int XpressEncodeDummy;} *XpressEncodeStream;

// allocate and initialize encoder's data structures
// returns NULL if callback returned NULL (not enough memory)
XpressEncodeStream
XPRESS_CALL
  XpressEncodeCreate
  (
    int MaxOrigSize,			// max size of original data block
    void *context,				// user-defined context info (will  be passed to AllocFn)
    XpressAllocFn *AllocFn,		// memory allocation callback
    int CompressionLevel		// use 0 for speed, 9 for quality
  );


// callback function called by XpressEncode to indicate compression progress
typedef
void
XPRESS_CALL
  XpressProgressFn
  (
    void *context,			// user-defined context
    int compressed			// size of processed original data
  );
    

// returns size of compressed data
// if compression failed then compressed buffer is left as is, and
// original data should be saved instead
int
XPRESS_CALL
  XpressEncode
  (
    XpressEncodeStream stream,		// encoder's workspace
    void *CompAdr, int CompSize,	// compressed data region
    const void *OrigAdr, int OrigSize,	// input data block
    XpressProgressFn *ProgressFn,	// NULL or progress callback
    void *ProgressContext,		// user-defined context that will be passed to ProgressFn
    int ProgressSize			// call ProgressFn each time ProgressSize bytes processed
  );

// invalidate input stream and release workspace memory
void
XPRESS_CALL
  XpressEncodeClose
  (
    XpressEncodeStream stream,		// encoder's workspace
    void *context, XpressFreeFn *FreeFn	// memory releasing callback
  );


/* ----------------------------- Decoder ------------------------------ */
/*                               -------                                */

// declare unique anonymous types for type safety
typedef struct {int XpressDecodeDummy;} *XpressDecodeStream;

// allocate memory for decoder. Returns NULL if not enough memory.
XpressDecodeStream
XPRESS_CALL
  XpressDecodeCreate
  (
    void *context,			// user-defined context info (will  be passed to AllocFn)
    XpressAllocFn *AllocFn		// memory allocation callback
  );

// decode compressed block. Returns # of decoded bytes or -1 otherwise
int
XPRESS_CALL
XpressDecode
  (
    XpressDecodeStream stream,		// decoder's workspace
    void *OrigAdr, int OrigSize,	// original data region
    int DecodeSize,			// # of bytes to decode ( <= OrigSize)
    const void *CompAdr, int CompSize	// compressed data block
  );

void
XPRESS_CALL
  XpressDecodeClose
  (
    XpressDecodeStream stream,		// encoder's workspace
    void *context,			// user-defined context info (will  be passed to FreeFn)
    XpressFreeFn *FreeFn			// callback that releases the memory
  );


/* ------------------------------ CRC32 ------------------------------- */
/*                                -----                                 */

int
XPRESS_CALL
  XpressCrc32
  (
    const void *data,		// beginning of data block
    int bytes,			// number of bytes
    int crc			// initial value
  );


#ifdef __cplusplus
};
#endif

#endif /* _XPRESS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsee\VapiGuids.h ===
/*-----------------------------------------------------------------------------
Microsoft VSEE

Microsoft Confidential
Copyright 1995-1999 Microsoft Corporation. All Rights Reserved.

@doc external
@module VapiGuids - GUIDs' declarations for VAPI related components

@owner a-PavelT
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_VSEE_VAPI_GUIDS_H_INCLUDED_) // {
#define VS_COMMON_INC_VSEE_VAPI_GUIDS_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "VseeGuidDataToXxx.h"

/*-----------------------------------------------------------------------------
Guid "data" and guids that have only one needed form here
This form of guids is approximately available from uuidgen -s, then remove the braces and "0x"s.
-----------------------------------------------------------------------------*/
#define CLSID_TS_VapiEnumeratorLibrary_data     (68403BDE, 10BC, 11d3, AD,36,00,C0,4F,A3,29,BB)
#define CLSID_TS_VapiEnumerator_data            (72480079, 10BC, 11d3, AD,36,00,C0,4F,A3,29,BB)
#define CLSID_TS_MergeEngineLibrary_data        (63D0C15E, 1C7E, 11D3, A1,C4,00,50,04,0A,E0,B0)
#define CLSID_TS_MergeEngine_data               (E86ACAEA, 1C7E, 11D3, A1,C4,00,50,04,0A,E0,B0)
#define CLSID_TS_MergeBrokerLibrary_data        (EBC1D0F9, 559D, 11D3, A1,E7,00,50,04,0A,E0,B0)
#define CLSID_TS_MergeBroker_data               (F8CE0F83, 559D, 11D3, A1,E7,00,50,04,0A,E0,B0)

#define   IID_TS_IMergeEngine_S                 B0317688-1C7E-11D3-A1C4-0050040AE0B0
#define   IID_TS_IMergeBroker_S                 CA490D75-559D-11D3-A1E7-0050040AE0B0

/*-----------------------------------------------------------------------------
other forms of guids generated below, no guids below, no guid "data" below
-----------------------------------------------------------------------------*/
#define      CLSID_TS_VapiEnumeratorLibrary_S     VSEE_GUID_DATA_TO_DASHED             CLSID_TS_VapiEnumeratorLibrary_data
#define CHAR_CLSID_TS_VapiEnumeratorLibrary       VSEE_GUID_DATA_TO_BRACED_DASHED_CHAR CLSID_TS_VapiEnumeratorLibrary_data

#define      CLSID_TS_VapiEnumerator_S            VSEE_GUID_DATA_TO_DASHED             CLSID_TS_VapiEnumerator_data
#define CHAR_CLSID_TS_VapiEnumerator              VSEE_GUID_DATA_TO_BRACED_DASHED_CHAR CLSID_TS_VapiEnumerator_data
#define      CLSID_TS_VapiEnumerator_Str          VSEE_GUID_DATA_TO_STRUCT_INITIALIZER CLSID_TS_VapiEnumerator_data

#define      CLSID_TS_MergeEngineLibrary_S        VSEE_GUID_DATA_TO_DASHED             CLSID_TS_MergeEngineLibrary_data
#define CHAR_CLSID_TS_MergeEngineLibrary          VSEE_GUID_DATA_TO_BRACED_DASHED_CHAR CLSID_TS_MergeEngineLibrary_data

#define      CLSID_TS_MergeEngine_S               VSEE_GUID_DATA_TO_DASHED             CLSID_TS_MergeEngine_data
#define CHAR_CLSID_TS_MergeEngine                 VSEE_GUID_DATA_TO_BRACED_DASHED_CHAR CLSID_TS_MergeEngine_data
#define      CLSID_TS_MergeEngine_Str             VSEE_GUID_DATA_TO_STRUCT_INITIALIZER CLSID_TS_MergeEngine_data

#define      CLSID_TS_MergeBrokerLibrary_S        VSEE_GUID_DATA_TO_DASHED             CLSID_TS_MergeBrokerLibrary_data
#define CHAR_CLSID_TS_MergeBrokerLibrary          VSEE_GUID_DATA_TO_BRACED_DASHED_CHAR CLSID_TS_MergeBrokerLibrary_data

#define      CLSID_TS_MergeBroker_S               VSEE_GUID_DATA_TO_DASHED             CLSID_TS_MergeBroker_data
#define CHAR_CLSID_TS_MergeBroker                 VSEE_GUID_DATA_TO_BRACED_DASHED_CHAR CLSID_TS_MergeBroker_data
#define      CLSID_TS_MergeBroker_Str             VSEE_GUID_DATA_TO_STRUCT_INITIALIZER CLSID_TS_MergeBroker_data

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsee\VseePreprocessorPaste.h ===
/*-----------------------------------------------------------------------------
Microsoft VSEE

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc external
@module VseePreprocessorPaste.h

@owner JayK
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_VSEE_PREPROCESSORPASTE_H_INCLUDED_) // {
#define VS_COMMON_INC_VSEE_PREPROCESSORPASTE_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#define VseePrivatePreprocessorPaste(x, y) x ## y

/*-----------------------------------------------------------------------------
Name: VseePreprocessorPaste2, VseePreprocessorPaste3, etc.
@macro
These macros paste together n tokens, where n is in the name of the macro.
A level of evaluation is inserted as well.

define A 1
define B 2

VseePreprocessorPaste2(A, B) -> 12
@owner JayK
-----------------------------------------------------------------------------*/

// These are synonyms.
#define VseePreprocessorPaste(x, y)  VseePrivatePreprocessorPaste(x, y)
#define VseePreprocessorPaste2(x, y) VseePrivatePreprocessorPaste(x, y)

#define VseePreprocessorPaste3(x, y, z) VseePreprocessorPaste(VseePreprocessorPaste(x, y), z)
#define VseePreprocessorPaste4(w, x, y, z) VseePreprocessorPaste(VseePreprocessorPaste3(w, x, y), z)
#define VseePreprocessorPaste5(v, w, x, y, z) VseePreprocessorPaste(VseePreprocessorPaste4(v, w, x, y), z)
#define VseePreprocessorPaste6(u, v, w, x, y, z) VseePreprocessorPaste(VseePreprocessorPaste5(u, v, w, x, y), z)

#define VseePreprocessorPaste15(a1,a2,a3,a4,a5,a6,a7,a8,a9,a,b,c,d,e,f) \
	VseePreprocessorPaste3 \
	( \
		VseePreprocessorPaste5(a1,a2,a3,a4,a5), \
		VseePreprocessorPaste5(a6,a7,a8,a9,a), \
		VseePreprocessorPaste5(b,c,d,e,f) \
	)

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsee\VseePreprocessorStringize.h ===
/*-----------------------------------------------------------------------------
Microsoft VSEE

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc external
@module VseePreprocessorStringize.h

@owner JayK
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_VSEE_PREPROCESSORSTRINGIZE_H_INCLUDED_) // {
#define VS_COMMON_INC_VSEE_PREPROCESSORSTRINGIZE_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "VseePreprocessorPaste.h"

#define VseePrivatePreprocessorStringize(x) # x

/*-----------------------------------------------------------------------------
Name: VseePreprocessorStringize, VseePreprocessorStringizeW
@macro
These macros simply stringize their parameter, after evaluating it;
it is evaluated so that
define A B
VseePreprocessorStringize(A) -> "B" instead of "A"
VseePreprocessorStringizeW(A) -> L"B" instead of L"A"
@owner JayK
-----------------------------------------------------------------------------*/
#define VseePreprocessorStringize(x) VseePrivatePreprocessorStringize(x)
#define VseePreprocessorStringizeW(x) VseePreprocessorPaste(L, VseePrivatePreprocessorStringize(x))

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsee\VseeGuidDataToXxx.h ===
/*-----------------------------------------------------------------------------
Microsoft VSEE

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc external
@module VseeGuidDataToXxx.h

Macros to convert "guid data", of the
form (3f32766f, 2d94, 444d, bf,32,2f,32,9c,71,d4,08), to all of the various
needed forms:
  3f32766f-2d94-444d-bf32-2f329c71d408                               VSEE_GUID_DATA_TO_DASHED
 '3f32766f-2d94-444d-bf32-2f329c71d408'                              VSEE_GUID_DATA_TO_DASHED_CHAR
 "3f32766f-2d94-444d-bf32-2f329c71d408"                              VSEE_GUID_DATA_TO_DASHED_STRING
 {3f32766f-2d94-444d-bf32-2f329c71d408}                              VSEE_GUID_DATA_TO_BRACED_DASHED
'{3f32766f-2d94-444d-bf32-2f329c71d408}'                             VSEE_GUID_DATA_TO_BRACED_DASHED_CHAR
"{3f32766f-2d94-444d-bf32-2f329c71d408}"                             VSEE_GUID_DATA_TO_BRACED_DASHED_STRING
{0x3f32766f,0x2d94,0x444d,{0xbf,0x32,0x2f,0x32,0x9c,0x71,0xd4,0x08}} VSEE_GUID_DATA_TO_STRUCT_INITIALIZER

@owner JayK
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_VSEE_GUID_DATA_TO_XXX_H_INCLUDED_)
#define VS_COMMON_INC_VSEE_GUID_DATA_TO_XXX_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "VseePreprocessorPaste.h"
#include "VseePreprocessorStringize.h"
#include "VseePreprocessorCharize.h"

/*-----------------------------------------------------------------------------
I need to investigate more, but present usage is:

VSEE_GUID_DATA_TO_DASHED_STRING : __declpec(uuid())
VSEE_GUID_DATA_TO_BRACED_DASHED_STRING : also works with__declpec(uuid())
VSEE_GUID_DATA_TO_BRACED_DASHED : in .rgs files (unquoted)
VSEE_GUID_DATA_TO_STRUCT_INITIALIZER : would be used in .ctc files
VSEE_GUID_DATA_TO_BRACED_DASHED_CHAR : used in .rgs files (quoted)

-----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
Name: VSEE_GUID_DATA_TO_STRUCT_INITIALIZER
@macro
This macro does like:
VSEE_GUID_DATA_TO_STRUCT_INITIALIZER(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> { 0x80f3e6ba, 0xd9b2, 0x4c41, { 0xae, 0x90, 0x63, 0x93, 0xda, 0xce, 0xac, 0x2a } }

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayK
-----------------------------------------------------------------------------*/
#define \
VSEE_GUID_DATA_TO_STRUCT_INITIALIZER\
( \
	dwData1,  \
	 wData2,  \
	 wData3,  \
	bData4_0, \
	bData4_1, \
	bData4_2, \
	bData4_3, \
	bData4_4, \
	bData4_5, \
	bData4_6, \
	bData4_7  \
) \
{ \
	VseePreprocessorPaste2(0x, dwData1), \
	VseePreprocessorPaste2(0x,  wData2), \
	VseePreprocessorPaste2(0x,  wData3), \
	{ \
		VseePreprocessorPaste2(0x, bData4_0), \
		VseePreprocessorPaste2(0x, bData4_1), \
		VseePreprocessorPaste2(0x, bData4_2), \
		VseePreprocessorPaste2(0x, bData4_3), \
		VseePreprocessorPaste2(0x, bData4_4), \
		VseePreprocessorPaste2(0x, bData4_5), \
		VseePreprocessorPaste2(0x, bData4_6), \
		VseePreprocessorPaste2(0x, bData4_7)  \
	} \
}

/*-----------------------------------------------------------------------------
Name: VSEE_GUID_DATA_TO_DASHED
@macro
This macro does like:
VSEE_GUID_DATA_TO_DASHED(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> 80f3e6ba-d9b2-4c41-ae90-6393daceac2a

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayK
-----------------------------------------------------------------------------*/
#define \
VSEE_GUID_DATA_TO_DASHED\
( \
	dwData1,  \
	 wData2,  \
	 wData3,  \
	bData4_0, \
	bData4_1, \
	bData4_2, \
	bData4_3, \
	bData4_4, \
	bData4_5, \
	bData4_6, \
	bData4_7  \
) \
VseePreprocessorPaste15(dwData1,-,wData2,-,wData3,-,bData4_0,bData4_1,-,bData4_2,bData4_3,bData4_4,bData4_5,bData4_6,bData4_7)

// without braces

/*-----------------------------------------------------------------------------
Name: VSEE_GUID_DATA_TO_DASHED_STRING
@macro
VSEE_GUID_DATA_TO_DASHED_STRING(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> "80f3e6ba-d9b2-4c41-ae90-6393daceac2a"

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayK
-----------------------------------------------------------------------------*/
#define \
VSEE_GUID_DATA_TO_DASHED_STRING\
( \
	dw1,  \
	 w2,  \
	 w3,  \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	VseePreprocessorStringize(VSEE_GUID_DATA_TO_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

/*-----------------------------------------------------------------------------
Name: VSEE_GUID_DATA_TO_DASHED_CHAR
@macro
VSEE_GUID_DATA_TO_DASHED_CHAR(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> '80f3e6ba-d9b2-4c41-ae90-6393daceac2a'

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayK
-----------------------------------------------------------------------------*/
#define \
VSEE_GUID_DATA_TO_DASHED_CHAR\
( \
	dw1,  \
	 w2,  \
	 w3,  \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	VseePreprocessorCharize(VSEE_GUID_DATA_TO_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

// with braces

/*-----------------------------------------------------------------------------
Name: VSEE_GUID_DATA_TO_BRACED_DASHED
@macro
VSEE_GUID_DATA_TO_BRACED_DASHED(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> {80f3e6ba-d9b2-4c41-ae90-6393daceac2a}

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayK
-----------------------------------------------------------------------------*/
#define \
VSEE_GUID_DATA_TO_BRACED_DASHED\
( \
	dw1, \
	 w2, \
	 w3, \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	VseePreprocessorPaste3({,VSEE_GUID_DATA_TO_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7),})

/*-----------------------------------------------------------------------------
Name: VSEE_GUID_DATA_TO_BRACED_DASHED_STRING
@macro
VSEE_GUID_DATA_TO_BRACED_DASHED_STRING(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> "{80f3e6ba-d9b2-4c41-ae90-6393daceac2a}"

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayK
-----------------------------------------------------------------------------*/
#define \
VSEE_GUID_DATA_TO_BRACED_DASHED_STRING\
( \
	dw1, \
	 w2, \
	 w3, \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	VseePreprocessorStringize(VSEE_GUID_DATA_TO_BRACED_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

/*-----------------------------------------------------------------------------
Name: VSEE_GUID_DATA_TO_BRACED_DASHED_STRING_W
@macro
VSEE_GUID_DATA_TO_BRACED_DASHED_STRING_W(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> L"{80f3e6ba-d9b2-4c41-ae90-6393daceac2a}"

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayK
-----------------------------------------------------------------------------*/
#define VSEE_GUID_DATA_TO_BRACED_DASHED_STRING_W(dw1, w2, w3, b0, b1, b2, b3, b4, b5, b6, b7) \
	VseePreprocessorPaste(L, VSEE_GUID_DATA_TO_BRACED_DASHED_STRING(dw1, w2, w3, b0, b1, b2, b3, b4, b5, b6, b7))

/*-----------------------------------------------------------------------------
Name: VSEE_GUID_DATA_TO_BRACED_DASHED_CHAR
@macro
VSEE_GUID_DATA_TO_BRACED_DASHED_CHAR(80f3e6ba, d9b2, 4c41, ae,90,63,93,da,ce,ac,2a)
 -> '{80f3e6ba-d9b2-4c41-ae90-6393daceac2a}'

The parameters are hex constants without 0x on them.
They must be exactly 8, 4, and 2 digits wide.
They must include leading zeros.

@owner JayK
-----------------------------------------------------------------------------*/
#define \
VSEE_GUID_DATA_TO_BRACED_DASHED_CHAR\
( \
	dw1, \
	 w2, \
	 w3, \
	 b0, \
	 b1, \
	 b2, \
	 b3, \
	 b4, \
	 b5, \
	 b6, \
	 b7  \
) \
	VseePreprocessorCharize(VSEE_GUID_DATA_TO_BRACED_DASHED(dw1,w2,w3,b0,b1,b2,b3,b4,b5,b6,b7))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\inc\vsee\VseePreprocessorCharize.h ===
/*-----------------------------------------------------------------------------
Microsoft VSEE

Microsoft Confidential
Copyright 1995-2000 Microsoft Corporation. All Rights Reserved.

@doc external
@module VseePreprocessorCharize.h

@owner JayK
-----------------------------------------------------------------------------*/
#if !defined(VS_COMMON_INC_VSEE_PREPROCESSORCHARIZE_H_INCLUDED_) // {
#define VS_COMMON_INC_VSEE_PREPROCESSORCHARIZE_H_INCLUDED_
/*#pragma once ends up in .rgi, which is bad, so do not do it*/

#include "VseePreprocessorPaste.h"

#define VseePrivatePreprocessorCharize(x) #@ x

/*-----------------------------------------------------------------------------
Name: VseePreprocessorCharize, VseePreprocessorCharizeW
@macro
These macros simply charize their parameter, after evaluating it;
it is evaluated so that
define A B
VseePreprocessorCharize(A) -> 'B' instead of 'A'
VseePreprocessorCharizeW(A) -> 'B' instead of L'A'
@owner JayK
-----------------------------------------------------------------------------*/
#define VseePreprocessorCharize(x) VseePrivatePreprocessorCharize(x)
#define VseePreprocessorCharizeW(x) VseePreprocessorPaste(L, VseePrivatePreprocessorCharize(x))

#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\debugger\idl\makefile.inc ===
$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\ad1.lib : $(AD1_LIBOBJECTS)
	$(LIB_NAME) -out:$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\ad1.lib -nodefaultlib $(AD1_LIBOBJECTS)

$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\ad2ide.lib : $(AD2IDE_LIBOBJECTS)
	$(LIB_NAME) -out:$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\ad2ide.lib -nodefaultlib $(AD2IDE_LIBOBJECTS)

$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\ad2de.lib : $(AD2DE_LIBOBJECTS)
	$(LIB_NAME) -out:$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\ad2de.lib -nodefaultlib $(AD2DE_LIBOBJECTS)

$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\ad2priv.lib : $(AD2PRIV_LIBOBJECTS)
	$(LIB_NAME) -out:$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\ad2priv.lib -nodefaultlib $(AD2PRIV_LIBOBJECTS)

$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\sqlinit.lib : $(SQLINIT_LIBOBJECTS)
	$(LIB_NAME) -out:$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\sqlinit.lib -nodefaultlib $(SQLINIT_LIBOBJECTS)

$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\sleinternal.lib : $(SLEINTERNAL_LIBOBJECTS)
	$(LIB_NAME) -out:$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\sleinternal.lib -nodefaultlib $(SLEINTERNAL_LIBOBJECTS)

$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\sdminternal.lib : $(SDMINTERNAL_LIBOBJECTS)
	$(LIB_NAME) -out:$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\sdminternal.lib -nodefaultlib $(SDMINTERNAL_LIBOBJECTS)

# compile-time PDB needs to be available for those who statically link with ad*.lib
$(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\$(TARGETNAME)_comp.pdb : $(O)\$(TARGETNAME)_comp.pdb
	copy $(O)\$(TARGETNAME)_comp.pdb $(VSBUILT)\$(BUILT_FLAVOR)\lib\$(TARGET_DIRECTORY)\$(TARGETNAME)_comp.pdb

$(PASS0_HEADERDIR)\dispex.h : dispex.idl
	$(MIDL) $(PACKING) $(FULL_INCL_PATH) -char unsigned -ms_ext -c_ext -client none -server none -header $@ \
	-iid $(PASS0_UUIDDIR)\dispex.c \
	-tlb $(PASS0_TLBDIR)\dispex.tlb \
	-proxy $(PASS0_PROXYDIR)\dispex_p.c \
	-dlldata $(PASS0_DLLDATADIR)\dispex_d.c \
	-cpp_cmd $(TARGET_CPP) $(C_DEFINES) $(USER_C_DEFINES) $(MIDL_FLAGS) $(MIDL_OPTIMIZATION) dispex.idl

$(PASS0_HEADERDIR)\adnots.h : adnots.idl
	$(MIDL) $(PACKING) $(FULL_INCL_PATH) -char unsigned -ms_ext -c_ext -client none -server none -header $@ \
	-iid $(PASS0_UUIDDIR)\adnots.c \
	-tlb $(PASS0_TLBDIR)\adnots.tlb \
	-proxy $(PASS0_PROXYDIR)\adnots_p.c \
	-dlldata $(PASS0_DLLDATADIR)\adnots_d.c \
	-cpp_cmd $(TARGET_CPP) $(C_DEFINES) $(USER_C_DEFINES) $(MIDL_FLAGS) $(MIDL_OPTIMIZATION) adnots.idl

$(PASS0_HEADERDIR)\v6.h : v6.idl
	$(MIDL) $(PACKING) $(FULL_INCL_PATH) -char unsigned -ms_ext -c_ext -client none -server none -header $@ \
	-iid $(PASS0_UUIDDIR)\v6.c \
	-tlb $(PASS0_TLBDIR)\v6.tlb \
	-proxy $(PASS0_PROXYDIR)\v6_p.c \
	-dlldata $(PASS0_DLLDATADIR)\v6_d.c \
	-cpp_cmd $(TARGET_CPP) $(C_DEFINES) $(USER_C_DEFINES) $(MIDL_FLAGS) $(MIDL_OPTIMIZATION) v6.idl

$(PASS0_HEADERDIR)\enc_temp.h : enc_temp.idl
	$(MIDL) -DENC_TEMP_COMPILE $(PACKING) $(FULL_INCL_PATH) -char unsigned -ms_ext -c_ext -client none -server none -header $@ \
	-iid $(PASS0_UUIDDIR)\enc_temp.c \
	-tlb $(PASS0_TLBDIR)\enc_temp.tlb \
	-proxy $(PASS0_PROXYDIR)\enc_temp_p.c \
	-dlldata $(PASS0_DLLDATADIR)\enc_temp_d.c \
	-cpp_cmd $(TARGET_CPP) $(C_DEFINES) $(USER_C_DEFINES) $(MIDL_FLAGS) $(MIDL_OPTIMIZATION) enc_temp.idl

$(PASS0_HEADERDIR)\mdsqldbg.h : mdsqldbg.idl
	$(MIDL) $(PACKING) $(FULL_INCL_PATH) -char unsigned -ms_ext -c_ext -client none -server none -header $@ \
	-iid $(PASS0_UUIDDIR)\mdsqldbg.c \
	-tlb $(PASS0_TLBDIR)\mdsqldbg.tlb \
	-proxy $(PASS0_PROXYDIR)\mdsqldbg_p.c \
	-dlldata $(PASS0_DLLDATADIR)\mdsqldbg_d.c \
	-cpp_cmd $(TARGET_CPP) $(C_DEFINES) $(USER_C_DEFINES) $(MIDL_FLAGS) $(MIDL_OPTIMIZATION) mdsqldbg.idl

$(VSBUILT)\$(BUILT_FLAVOR)\inc\$(TARGET_DIRECTORY)\dbgmetric.h : ..\inc\dbgmetric.h
	copy ..\inc\dbgmetric.h $(VSBUILT)\$(BUILT_FLAVOR)\inc\$(TARGET_DIRECTORY)\dbgmetric.h

$(VSBUILT)\$(BUILT_FLAVOR)\inc\$(TARGET_DIRECTORY)\toolhrt.h : ..\inc\toolhrt.h
	copy ..\inc\toolhrt.h $(VSBUILT)\$(BUILT_FLAVOR)\inc\$(TARGET_DIRECTORY)\toolhrt.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\common\win95\win9x.h ===
//---------------------------------------------------------------------------
//  Microsoft Confidential
//  Copyright (C) Microsoft Corporation, 1993 - 1999.  All Rights Reserved.
//
//  File:       win9x.h
//
//  Contents:   Header file to be included by clients of the static lib UNICODE
//              wrapper win9x(d).lib
//
//  Owner: Microsoft Visual Studio
//
//  Contacts: RahulK, KSrini, larsberg
//
//  All changes and additions must be approved by one of the contacts above.
//----------------------------------------------------------------------------

#include <mbstring.h>
#include <prsht.h>
#include <commctrl.h>
#include <shlobj.h>
#include <nspapi.h>
#include <oledlg.h>
#include <ras.h>
#include <vfw.h>

// Static Win9x Wrapper Initializer
BOOL WINAPI Win9xInit (HANDLE    hDLL,DWORD     dwReason,LPVOID    lpReserved);

#ifdef MAPWAPIS

//
//  The "GOOD" APIs i.e. the ones that are wrapped
//

#define AppendMenuW OAppendMenuW
#define CallWindowProcW OCallWindowProcW
#define CharLowerBuffW OCharLowerBuffW
#define CharLowerW OCharLowerW
#define CharNextW OCharNextW
#define CharPrevW OCharPrevW
#define CharToOemW OCharToOemW
#define CharUpperBuffW OCharUpperBuffW
#define CharUpperW OCharUpperW
#define ChooseColorW OChooseColorW
#define ChooseFontW OChooseFontW
#define CompareStringW OCompareStringW
#define CopyAcceleratorTableW OCopyAcceleratorTableW
#define CopyFileW OCopyFileW
#define CopyMetaFileW OCopyMetaFileW
#define CreateMutexW OCreateMutexW
#define CreateAcceleratorTableW OCreateAcceleratorTableW
#define CreateDCW OCreateDCW
#define CreateDialogIndirectParamW OCreateDialogIndirectParamW
#define CreateDialogParamW OCreateDialogParamW
#define CreateDirectoryExW OCreateDirectoryExW
#define CreateDirectoryW OCreateDirectoryW
#define CreateEnhMetaFileW OCreateEnhMetaFileW
#define CreateEventW OCreateEventW
#define CreateFileMappingW OCreateFileMappingW
#define CreateFileW OCreateFileW
#define CreateFontIndirectW OCreateFontIndirectW
#define CreateFontW OCreateFontW
#define CreateICW OCreateICW
#define CreateMDIWindowW OCreateMDIWindowW
#define CreateMetaFileW OCreateMetaFileW
#define CreateProcessW OCreateProcessW
#define CreatePropertySheetPageW OCreatePropertySheetPageW
#define CreateSemaphoreW OCreateSemaphoreW
#define CreateWindowExW OCreateWindowExW
#define DdeCreateStringHandleW ODdeCreateStringHandleW
#define DdeInitializeW ODdeInitializeW
#define DefDlgProcW ODefDlgProcW
#define DefFrameProcW ODefFrameProcW
#define DefMDIChildProcW ODefMDIChildProcW
#define DefWindowProcW ODefWindowProcW
#define DeleteFileW ODeleteFileW
#define DialogBoxIndirectParamW ODialogBoxIndirectParamW
#define DialogBoxParamW ODialogBoxParamW
#define DispatchMessageW ODispatchMessageW
#define DocumentPropertiesW ODocumentPropertiesW
#define DragQueryFileW ODragQueryFileW
#define DrawTextExW ODrawTextExW
#define DrawTextW ODrawTextW
#define EnableWindow OEnableWindow
#define ExtractAssociatedIconW OExtractAssociatedIconW
#define ExtractIconW OExtractIconW
#define ExtractIconExW OExtractIconExW
#define ExtTextOutW OExtTextOutW
#define ExpandEnvironmentStringsW OExpandEnvironmentStringsW
#define FatalAppExitW OFatalAppExitW
#define FindFirstChangeNotificationW OFindFirstChangeNotificationW
#define FindExecutableW OFindExecutableW
#define FindFirstFileW OFindFirstFileW
#define FindNextFileW OFindNextFileW
#define FindResourceW OFindResourceW
#define FindWindowW OFindWindowW
#define FormatMessageW OFormatMessageW
#define FreeEnvironmentStringsW OFreeEnvironmentStringsW
#define GetCharABCWidthsFloatW OGetCharABCWidthsFloatW
#define GetCharABCWidthsW OGetCharABCWidthsW
#define GetCharWidthFloatW OGetCharWidthFloatW
#define GetCharWidthW OGetCharWidthW
#define GetClassInfoW OGetClassInfoW
#define GetClassInfoExW OGetClassInfoExW
#define GetClassLongW OGetClassLongW
#define GetClassNameW OGetClassNameW
#define GetClipboardFormatNameW OGetClipboardFormatNameW
#define GetComputerNameW OGetComputerNameW
#define GetCurrentDirectoryW OGetCurrentDirectoryW
#define GetCurrencyFormatW OGetCurrencyFormatW
#define GetDateFormatW OGetDateFormatW
#define GetDlgItemTextW OGetDlgItemTextW
#define GetDriveTypeW OGetDriveTypeW
#define GetEnvironmentVariableW OGetEnvironmentVariableW
#define GetEnvironmentStringsW OGetEnvironmentStringsW
#define GetFileAttributesW OGetFileAttributesW
#define GetFileAttributesExW OGetFileAttributesExW
#define GetFileTitleW OGetFileTitleW
#define GetFileVersionInfoSizeW OGetFileVersionInfoSizeW
#define GetFileVersionInfoW OGetFileVersionInfoW
#define GetFullPathNameW OGetFullPathNameW
#define GetGlyphOutlineW OGetGlyphOutlineW
#define GetKerningPairsW OGetKerningPairsW
#define GetLocaleInfoW OGetLocaleInfoW
#define GetMessageW OGetMessageW
#define GetModuleFileNameW OGetModuleFileNameW
#define GetModuleHandleW OGetModuleHandleW
#define GetNumberFormatW OGetNumberFormatW
#define GetObjectW OGetObjectW
#define GetOpenFileNameW OGetOpenFileNameW
#define GetOutlineTextMetricsW OGetOutlineTextMetricsW
#define GetPrivateProfileIntW OGetPrivateProfileIntW
#define GetPrivateProfileStringW OGetPrivateProfileStringW
#define GetProfileIntW OGetProfileIntW
#define GetPropW OGetPropW
#define GetSaveFileNameW OGetSaveFileNameW
#define GetShortPathNameW OGetShortPathNameW
#define GetStartupInfoW OGetStartupInfoW
#define GetStringTypeExW OGetStringTypeExW
#define GetSystemDirectoryW OGetSystemDirectoryW
#define GetTabbedTextExtentW OGetTabbedTextExtentW
#define GetTempFileNameW OGetTempFileNameW
#define GetTempPathW OGetTempPathW
#define GetTextExtentPoint32W OGetTextExtentPoint32W
#define GetTextExtentPointW OGetTextExtentPointW
#define GetTextExtentExPointW OGetTextExtentExPointW
#define GetTextFaceW OGetTextFaceW
#define GetTextMetricsW OGetTextMetricsW
#define GetTimeFormatW OGetTimeFormatW
#define GetUserNameW OGetUserNameW
#define GetVersionExW OGetVersionExW
#define GetVolumeInformationW OGetVolumeInformationW
#define GetWindowLongW OGetWindowLongW
#define GetWindowTextLengthW OGetWindowTextLengthW
#define GetWindowTextW OGetWindowTextW
#define GlobalAddAtomW OGlobalAddAtomW
#define GlobalFindAtomW OGlobalFindAtomW
#define GlobalGetAtomNameW OGlobalGetAtomNameW
#define GrayStringW OGrayStringW
#define ImageList_LoadImageW OImageList_LoadImageW
#define ImmGetCompositionStringW OImmGetCompositionStringW
#define InsertMenuW OInsertMenuW
#define IsBadStringPtrW OIsBadStringPtrW
#define IsCharAlphaNumericW OIsCharAlphaNumericW
#define IsCharAlphaW OIsCharAlphaW
#define IsDialogMessageW OIsDialogMessageW
#define LCMapStringW OLCMapStringW
#define LoadAcceleratorsW OLoadAcceleratorsW
#define LoadBitmapW OLoadBitmapW
#define LoadCursorW OLoadCursorW
#define LoadIconW OLoadIconW
#define LoadImageW OLoadImageW
#define LoadLibraryExW OLoadLibraryExW
#define LoadLibraryW OLoadLibraryW
#define LoadMenuIndirectW OLoadMenuIndirectW
#define LoadMenuW OLoadMenuW
#define LoadStringW OLoadStringW
#define lstrcatW OlstrcatW
#define lstrcmpiW OlstrcmpiW
#define lstrcmpW OlstrcmpW
#define lstrcpynW OlstrcpynW
#define lstrcpyW OlstrcpyW
#define lstrlenW OlstrlenW
#define MapVirtualKeyW OMapVirtualKeyW
#define MessageBoxW OMessageBoxW
#define MessageBoxIndirectW OMessageBoxIndirectW
#define ModifyMenuW OModifyMenuW
#define MoveFileExW OMoveFileExW
#define MoveFileW OMoveFileW
#define OemToCharW OOemToCharW
#define OpenEventW OOpenEventW
#define OpenMutexW OOpenMutexW
#define OpenPrinterW OOpenPrinterW
#define OutputDebugStringW OOutputDebugStringW
#define PeekMessageW OPeekMessageW
#define PostMessageW OPostMessageW
#define PostThreadMessageW OPostThreadMessageW
#define PrintDlgW OPrintDlgW
#define PropertySheetW OPropertySheetW
#define RegCreateKeyExW ORegCreateKeyExW
#define RegCreateKeyW ORegCreateKeyW
#define RegDeleteKeyW ORegDeleteKeyW
#define RegDeleteValueW ORegDeleteValueW
#define RegEnumKeyW ORegEnumKeyW
#define RegEnumValueW ORegEnumValueW
#define RegEnumKeyExW ORegEnumKeyExW
#define RegisterClassW ORegisterClassW
#define RegisterClassExW ORegisterClassExW
#define RegisterClipboardFormatW ORegisterClipboardFormatW
#define RegisterWindowMessageW ORegisterWindowMessageW
#define RegOpenKeyExW ORegOpenKeyExW
#define RegOpenKeyW ORegOpenKeyW
#define RegQueryInfoKeyW ORegQueryInfoKeyW
#define RegQueryValueExW ORegQueryValueExW
#define RegQueryValueW ORegQueryValueW
#define RegSetValueExW ORegSetValueExW
#define RegSetValueW ORegSetValueW
#define RemovePropW ORemovePropW
#define ResetDCW OResetDCW
#define SendDlgItemMessageW OSendDlgItemMessageW
#define SendMessageW OSendMessageW
#define SendMessageTimeoutW OSendMessageTimeoutW
#define SendNotifyMessageW OSendNotifyMessageW
#define SetClassLongW OSetClassLongW
#define SetCurrentDirectoryW OSetCurrentDirectoryW
#define SetDlgItemTextW OSetDlgItemTextW
#define SetEnvironmentVariableW OSetEnvironmentVariableW
#define SetFileAttributesW OSetFileAttributesW
#define SetLocaleInfoW OSetLocaleInfoW
#define SetMenuItemInfoW OSetMenuItemInfoW
#define SetPropW OSetPropW
#define SetWindowLongW OSetWindowLongW
#define SetWindowsHookExW OSetWindowsHookExW
#define SetWindowTextW OSetWindowTextW
#define SHBrowseForFolderW OSHBrowseForFolderW
#define Shell_NotifyIconW OShell_NotifyIconW
#define ShellExecuteExW OShellExecuteExW
#define SHGetFileInfoW OSHGetFileInfoW
#define SHGetPathFromIDListW OSHGetPathFromIDListW
#define StartDocW OStartDocW
#define StgCreateDocfile OStgCreateDocfile
#define SystemParametersInfoW OSystemParametersInfoW
#define TabbedTextOutW OTabbedTextOutW
#define TranslateAcceleratorW OTranslateAcceleratorW
#define UnregisterClassW OUnregisterClassW
#define VerLanguageNameW OVerLanguageNameW
#define VerQueryValueW OVerQueryValueW
#define VkKeyScanW OVkKeyScanW
#define WinHelpW OWinHelpW
#define WNetGetConnectionW OWNetGetConnectionW
#define WritePrivateProfileStringW OWritePrivateProfileStringW
#define wvsprintfW OwvsprintfW
#define wsprintfW OwsprintfW


//
//  The "BAD" APIs i.e. the ones that are NOT wrapped
//

#ifdef DEBUG

#define AbortSystemShutdownW OAbortSystemShutdownW
#define AccessCheckAndAuditAlarmW OAccessCheckAndAuditAlarmW
#define AddFontResourceW OAddFontResourceW
#define AddFormW OAddFormW
#define AddJobW OAddJobW
#define AddMonitorW OAddMonitorW
#define AddPortW OAddPortW
#define AddPrinterConnectionW OAddPrinterConnectionW
#define AddPrinterDriverW OAddPrinterDriverW
#define AddPrinterW OAddPrinterW
#define AddPrintProcessorW OAddPrintProcessorW
#define AddPrintProvidorW OAddPrintProvidorW
#define AdvancedDocumentPropertiesW OAdvancedDocumentPropertiesW
#define auxGetDevCapsW OauxGetDevCapsW
#define AVIBuildFilterW OAVIBuildFilterW
#define AVIFileCreateStreamW OAVIFileCreateStreamW
#define AVIFileInfoW OAVIFileInfoW
#define AVISaveW OAVISaveW
#define AVIStreamInfoW OAVIStreamInfoW
#define AVIStreamOpenFromFileW OAVIStreamOpenFromFileW
#define BackupEventLogW OBackupEventLogW
#define BeginUpdateResourceW OBeginUpdateResourceW
#define BuildCommDCBAndTimeoutsW OBuildCommDCBAndTimeoutsW
#define BuildCommDCBW OBuildCommDCBW
#define CallMsgFilterW OCallMsgFilterW
#define CallNamedPipeW OCallNamedPipeW
#define capCreateCaptureWindowW OcapCreateCaptureWindowW
#define ChangeDisplaySettingsW OChangeDisplaySettingsW
#define ChangeMenuW OChangeMenuW
#define CharToOemBuffW OCharToOemBuffW
#define ClearEventLogW OClearEventLogW
#define CommConfigDialogW OCommConfigDialogW
#define ConfigurePortW OConfigurePortW
#define CopyEnhMetaFileW OCopyEnhMetaFileW
#define CreateColorSpaceW OCreateColorSpaceW
#define CreateDesktopW OCreateDesktopW
#define CreateMailslotW OCreateMailslotW
#define CreateNamedPipeW OCreateNamedPipeW
#define CreateProcessAsUserW OCreateProcessAsUserW
#define CreateScalableFontResourceW OCreateScalableFontResourceW
#define CreateStatusWindowW OCreateStatusWindowW
#define CreateWindowStationW OCreateWindowStationW
#define DceErrorInqTextW ODceErrorInqTextW
#define DdeQueryStringW   ODdeQueryStringW
#define DefineDosDeviceW ODefineDosDeviceW
#define DeleteFormW ODeleteFormW
#define DeleteMonitorW ODeleteMonitorW
#define DeletePortW ODeletePortW
#define DeletePrinterConnectionW ODeletePrinterConnectionW
#define DeletePrinterDriverW ODeletePrinterDriverW
#define DeletePrintProcessorW ODeletePrintProcessorW
#define DeletePrintProvidorW ODeletePrintProvidorW
#define DeviceCapabilitiesW ODeviceCapabilitiesW
#define DlgDirListComboBoxW ODlgDirListComboBoxW
#define DlgDirListW ODlgDirListW
#define DlgDirSelectComboBoxExW ODlgDirSelectComboBoxExW
#define DlgDirSelectExW ODlgDirSelectExW
#define DoEnvironmentSubstW ODoEnvironmentSubstW
#define DrawStateW ODrawStateW
#define EditStreamSetInfoW OEditStreamSetInfoW
#define EndUpdateResourceW OEndUpdateResourceW
#define EnumCalendarInfoW OEnumCalendarInfoW
#define EnumDateFormatsW OEnumDateFormatsW
#define EnumDesktopsW OEnumDesktopsW
#define EnumDisplaySettingsW OEnumDisplaySettingsW
#define EnumFontFamiliesExW OEnumFontFamiliesExW
#define EnumFontFamiliesW OEnumFontFamiliesW
#define EnumFontsW OEnumFontsW
#define EnumFormsW OEnumFormsW
#define EnumICMProfilesW OEnumICMProfilesW
#define EnumJobsW OEnumJobsW
#define EnumMonitorsW OEnumMonitorsW
#define EnumPortsW OEnumPortsW
#define EnumPrinterDriversW OEnumPrinterDriversW
#define EnumPrintersW OEnumPrintersW
#define EnumPrintProcessorDatatypesW OEnumPrintProcessorDatatypesW
#define EnumPrintProcessorsW OEnumPrintProcessorsW
#define EnumPropsExW OEnumPropsExW
#define EnumPropsW OEnumPropsW
#define EnumProtocolsW OEnumProtocolsW
#define EnumResourceLanguagesW OEnumResourceLanguagesW
#define EnumResourceNamesW OEnumResourceNamesW
#define EnumResourceTypesW OEnumResourceTypesW
#define EnumSystemCodePagesW OEnumSystemCodePagesW
#define EnumSystemLocalesW OEnumSystemLocalesW
#define EnumTimeFormatsW OEnumTimeFormatsW
#define EnumWindowStationsW OEnumWindowStationsW
#define FillConsoleOutputCharacterW OFillConsoleOutputCharacterW
#define FindEnvironmentStringW OFindEnvironmentStringW
#define FindResourceExW OFindResourceExW
#define FindTextW OFindTextW
#define FindWindowExW OFindWindowExW
#define FoldStringW OFoldStringW
#define GetAddressByNameW OGetAddressByNameW
#define GetBinaryTypeW OGetBinaryTypeW
#define GetCharacterPlacementW OGetCharacterPlacementW
#define GetCharWidth32W OGetCharWidth32W
#define GetCommandLineW OGetCommandLineW
#define GetCompressedFileSizeW OGetCompressedFileSizeW
#define GetConsoleTitleW OGetConsoleTitleW
#define GetDefaultCommConfigW OGetDefaultCommConfigW
#define GetDiskFreeSpaceW OGetDiskFreeSpaceW
#define GetEnhMetaFileDescriptionW OGetEnhMetaFileDescriptionW
#define GetEnhMetaFileW OGetEnhMetaFileW
#define GetExpandedNameW OGetExpandedNameW
#define GetFileSecurityW OGetFileSecurityW
#define GetFormW OGetFormW
#define GetICMProfileW OGetICMProfileW
#define GetJobW OGetJobW
#define GetKeyboardLayoutNameW OGetKeyboardLayoutNameW
#define GetKeyNameTextW OGetKeyNameTextW
#define GetLogColorSpaceW OGetLogColorSpaceW
#define GetLogicalDriveStringsW OGetLogicalDriveStringsW
#define GetMenuItemInfoW OGetMenuItemInfoW
#define GetMenuStringW OGetMenuStringW
#define GetMetaFileW OGetMetaFileW
#define GetNameByTypeW OGetNameByTypeW
#define GetNamedPipeHandleStateW OGetNamedPipeHandleStateW
#define GetPrinterDataW OGetPrinterDataW
#define GetPrinterDriverDirectoryW OGetPrinterDriverDirectoryW
#define GetPrinterDriverW OGetPrinterDriverW
#define GetPrinterW OGetPrinterW
#define GetPrintProcessorDirectoryW OGetPrintProcessorDirectoryW
#define GetPrivateProfileSectionNamesW OGetPrivateProfileSectionNamesW
#define GetPrivateProfileSectionW OGetPrivateProfileSectionW
#define GetPrivateProfileStructW OGetPrivateProfileStructW
#define GetProfileSectionW OGetProfileSectionW
#define GetProfileStringW OGetProfileStringW
#define GetServiceW OGetServiceW
#define GetTypeByNameW OGetTypeByNameW
#define GetUserObjectInformationW OGetUserObjectInformationW
#define GetWindowsDirectoryW OGetWindowsDirectoryW
#define ImmConfigureIMEW OImmConfigureIMEW
#define ImmEnumRegisterWordW OImmEnumRegisterWordW
#define ImmEscapeW OImmEscapeW
#define ImmGetCandidateListCountW OImmGetCandidateListCountW
#define ImmGetCandidateListW OImmGetCandidateListW
#define ImmGetCompositionFontW OImmGetCompositionFontW
#define ImmGetConversionListW OImmGetConversionListW
#define ImmGetDescriptionW OImmGetDescriptionW
#define ImmGetGuideLineW OImmGetGuideLineW
#define ImmGetIMEFileNameW OImmGetIMEFileNameW
#define ImmGetRegisterWordStyleW OImmGetRegisterWordStyleW
#define ImmInstallIMEW OImmInstallIMEW
#define ImmIsUIMessageW OImmIsUIMessageW
#define ImmRegisterWordW OImmRegisterWordW
#define ImmSetCompositionFontW OImmSetCompositionFontW
#define ImmSetCompositionStringW OImmSetCompositionStringW
#define ImmUnregisterWordW OImmUnregisterWordW
#define InitiateSystemShutdownW OInitiateSystemShutdownW
#define InsertMenuItemW OInsertMenuItemW
#define IsCharLowerW OIsCharLowerW
#define IsCharUpperW OIsCharUpperW
#define I_RpcServerUnregisterEndpointW OI_RpcServerUnregisterEndpointW
#define joyGetDevCapsW OjoyGetDevCapsW
#define LoadCursorFromFileW OLoadCursorFromFileW
#define LoadKeyboardLayoutW OLoadKeyboardLayoutW
#define LogonUserW OLogonUserW
#define LZOpenFileW OLZOpenFileW
#define MapVirtualKeyExW OMapVirtualKeyExW
#define mciGetDeviceIDFromElementIDW OmciGetDeviceIDFromElementIDW
#define mciGetDeviceIDW OmciGetDeviceIDW
#define mciGetErrorStringW OmciGetErrorStringW
#define mciSendCommandW OmciSendCommandW
#define mciSendStringW OmciSendStringW
#define MCIWndCreateW OMCIWndCreateW
#define midiInGetDevCapsW OmidiInGetDevCapsW
#define midiInGetErrorTextW OmidiInGetErrorTextW
#define midiOutGetDevCapsW OmidiOutGetDevCapsW
#define midiOutGetErrorTextW OmidiOutGetErrorTextW
#define MIMEAssociationDialogW OMIMEAssociationDialogW
#define mixerGetControlDetailsW OmixerGetControlDetailsW
#define mixerGetDevCapsW OmixerGetDevCapsW
#define mixerGetLineControlsW OmixerGetLineControlsW
#define mixerGetLineInfoW OmixerGetLineInfoW
#define mmioInstallIOProcW OmmioInstallIOProcW
#define mmioOpenW OmmioOpenW
#define mmioRenameW OmmioRenameW
#define mmioStringToFOURCCW OmmioStringToFOURCCW
#define MultinetGetConnectionPerformanceW OMultinetGetConnectionPerformanceW
#define ObjectCloseAuditAlarmW OObjectCloseAuditAlarmW
#define ObjectOpenAuditAlarmW OObjectOpenAuditAlarmW
#define ObjectPrivilegeAuditAlarmW OObjectPrivilegeAuditAlarmW
#define OemToCharBuffW OOemToCharBuffW
#define OleUIAddVerbMenuW OOleUIAddVerbMenuW
#define OleUIEditLinksW OOleUIEditLinksW
#define OleUIPasteSpecialW OOleUIPasteSpecialW
#define OleUIPromptUserW OOleUIPromptUserW
#define OleUIUpdateLinksW OOleUIUpdateLinksW
#define OpenBackupEventLogW OOpenBackupEventLogW
#define OpenDesktopW OOpenDesktopW
#define OpenEventLogW OOpenEventLogW
#define OpenFileMappingW OOpenFileMappingW
#define OpenSemaphoreW OOpenSemaphoreW
#define OpenWindowStationW OOpenWindowStationW
#define PageSetupDlgW OPageSetupDlgW
#define PeekConsoleInputW OPeekConsoleInputW
#define PolyTextOutW OPolyTextOutW
#define PrinterMessageBoxW OPrinterMessageBoxW
#define PrivilegedServiceAuditAlarmW OPrivilegedServiceAuditAlarmW
#define QueryDosDeviceW OQueryDosDeviceW
#define RasDialW ORasDialW
#define ReadConsoleInputW OReadConsoleInputW
#define ReadConsoleOutputCharacterW OReadConsoleOutputCharacterW
#define ReadConsoleOutputW OReadConsoleOutputW
#define ReadConsoleW OReadConsoleW
#define ReadEventLogW OReadEventLogW
#define RegConnectRegistryW ORegConnectRegistryW
#define RegisterEventSourceW ORegisterEventSourceW
#define RegLoadKeyW ORegLoadKeyW
#define RegQueryMultipleValuesW ORegQueryMultipleValuesW
#define RegReplaceKeyW ORegReplaceKeyW
#define RegRestoreKeyW ORegRestoreKeyW
#define RegSaveKeyW ORegSaveKeyW
#define RegUnLoadKeyW ORegUnLoadKeyW
#define RemoveDirectoryW ORemoveDirectoryW
#define RemoveFontResourceW ORemoveFontResourceW
#define ReplaceTextW OReplaceTextW
#define ReportEventW OReportEventW
#define ResetPrinterW OResetPrinterW
#define RpcBindingFromStringBindingW ORpcBindingFromStringBindingW
#define RpcBindingInqAuthClientW ORpcBindingInqAuthClientW
#define RpcBindingToStringBindingW ORpcBindingToStringBindingW
#define RpcEpRegisterNoReplaceW ORpcEpRegisterNoReplaceW
#define RpcMgmtEpEltInqNextW ORpcMgmtEpEltInqNextW
#define RpcMgmtInqServerPrincNameW ORpcMgmtInqServerPrincNameW
#define RpcNetworkInqProtseqsW ORpcNetworkInqProtseqsW
#define RpcNetworkIsProtseqValidW ORpcNetworkIsProtseqValidW
#define RpcNsBindingInqEntryNameW ORpcNsBindingInqEntryNameW
#define RpcProtseqVectorFreeW ORpcProtseqVectorFreeW
#define RpcServerInqDefaultPrincNameW ORpcServerInqDefaultPrincNameW
#define RpcServerUseProtseqEpW ORpcServerUseProtseqEpW
#define RpcServerUseProtseqIfW ORpcServerUseProtseqIfW
#define RpcServerUseProtseqW ORpcServerUseProtseqW
#define RpcStringBindingComposeW ORpcStringBindingComposeW
#define RpcStringBindingParseW ORpcStringBindingParseW
#define RpcStringFreeW ORpcStringFreeW
#define ScrollConsoleScreenBufferW OScrollConsoleScreenBufferW
#define SearchPathW OSearchPathW
#define SendMessageCallbackW OSendMessageCallbackW
#define SetComputerNameW OSetComputerNameW
#define SetConsoleTitleW OSetConsoleTitleW
#define SetDefaultCommConfigW OSetDefaultCommConfigW
#define SetFileSecurityW OSetFileSecurityW
#define SetFormW OSetFormW
#define SetICMProfileW OSetICMProfileW
#define SetJobW OSetJobW
#define SetPrinterDataW OSetPrinterDataW
#define SetPrinterW OSetPrinterW
#define SetServiceW OSetServiceW
#define SetUserObjectInformationW OSetUserObjectInformationW
#define SetVolumeLabelW OSetVolumeLabelW
#define SetWindowsHookW OSetWindowsHookW
#define ShellAboutW OShellAboutW
#define ShellExecuteW OShellExecuteW
#define SHFileOperationW OSHFileOperationW
#define SHGetNewLinkInfoW OSHGetNewLinkInfoW
#define sndPlaySoundW OsndPlaySoundW
#define StartDocPrinterW OStartDocPrinterW
#define TranslateURLW OTranslateURLW
#define UpdateICMRegKeyW OUpdateICMRegKeyW
#define URLAssociationDialogW OURLAssociationDialogW
#define UuidFromStringW OUuidFromStringW
#define VerFindFileW OVerFindFileW
#define VerInstallFileW OVerInstallFileW
#define VkKeyScanExW OVkKeyScanExW
#define WaitNamedPipeW OWaitNamedPipeW
#define waveInGetDevCapsW OwaveInGetDevCapsW
#define waveInGetErrorTextW OwaveInGetErrorTextW
#define waveOutGetDevCapsW OwaveOutGetDevCapsW
#define waveOutGetErrorTextW OwaveOutGetErrorTextW
#define wglUseFontBitmapsW OwglUseFontBitmapsW
#define wglUseFontOutlinesW OwglUseFontOutlinesW
#define WinExecErrorW OWinExecErrorW
#define WNetAddConnection2W OWNetAddConnection2W
#define WNetAddConnection3W OWNetAddConnection3W
#define WNetAddConnectionW OWNetAddConnectionW
#define WNetCancelConnection2W OWNetCancelConnection2W
#define WNetCancelConnectionW OWNetCancelConnectionW
#define WNetConnectionDialog1W OWNetConnectionDialog1W
#define WNetDisconnectDialog1W OWNetDisconnectDialog1W
#define WNetEnumResourceW OWNetEnumResourceW
#define WNetGetLastErrorW OWNetGetLastErrorW
#define WNetGetNetworkInformationW OWNetGetNetworkInformationW
#define WNetGetProviderNameW OWNetGetProviderNameW
#define WNetGetUniversalNameW OWNetGetUniversalNameW
#define WNetGetUserW OWNetGetUserW
#define WNetOpenEnumW OWNetOpenEnumW
#define WNetSetConnectionW OWNetSetConnectionW
#define WNetUseConnectionW OWNetUseConnectionW
#define WriteConsoleInputW OWriteConsoleInputW
#define WriteConsoleOutputCharacterW OWriteConsoleOutputCharacterW
#define WriteConsoleOutputW OWriteConsoleOutputW
#define WriteConsoleW OWriteConsoleW
#define WritePrivateProfileSectionW OWritePrivateProfileSectionW
#define WritePrivateProfileStructW OWritePrivateProfileStructW
#define WriteProfileSectionW OWriteProfileSectionW
#define WriteProfileStringW OWriteProfileStringW

#endif // DEBUG

#endif // MAPWAPIS



//----------------------------------------------------------------------------
// Wrappers
//----------------------------------------------------------------------------
extern "C" {


BOOL
WINAPI
OAppendMenuW(
  HMENU hMenu,
  UINT uFlags,
  UINT uIDnewItem,
  LPCWSTR lpnewItem
  );



LRESULT
WINAPI
OCallWindowProcW(
  WNDPROC lpPrevWndFunc,
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam);



DWORD
WINAPI
OCharLowerBuffW(
  LPWSTR lpsz,
  DWORD cchLength);



LPWSTR
WINAPI
OCharLowerW (LPWSTR lpsz);



LPWSTR
WINAPI
OCharPrevW(
  LPCWSTR lpszStart,
  LPCWSTR lpszCurrent);


LPWSTR
WINAPI
OCharNextW (LPCWSTR lpsz);



BOOL
WINAPI
OCharToOemW(
  LPCWSTR lpszSrc,
  LPSTR lpszDst);


DWORD
WINAPI
OCharUpperBuffW(
  LPWSTR lpsz,
  DWORD cchLength);


LPWSTR
WINAPI
OCharUpperW(
  LPWSTR lpsz);

// From: Sridhar Chandrashekar on 7/21/98
//       Ted Smith: Returned result,
//                  Only convert lpTemplateName as nessacary
//                  Added paranioa re. CC_ENABLEHOOK

BOOL
WINAPI
OChooseColorW (LPCHOOSECOLORW lpcc);




BOOL
APIENTRY OChooseFontW(LPCHOOSEFONTW pchfw);

//  From EricKn 3/18/99
// CONSIDER: String should be converted w/ codepage that matches locale?

int
WINAPI
OCompareStringW(
  LCID     Locale,
  DWORD    dwCmpFlags,
  LPCWSTR lpString1,
  int      cchCount1,
  LPCWSTR lpString2,
  int      cchCount2);

// from johnchen 6/29/99
//UNDONE
// : Both of the CopyAcceleratorTable and CreateAcceleratorTable 
// : wrappers assume that the chars in the accelerator table are invariant 
// : between ANSI and Unicode. This is probably ok for VS tables, but it's 
// : not a complete solution if we deal with user-created tables. 

int
WINAPI
OCopyAcceleratorTableW(
  HACCEL hAccelSrc,
  LPACCEL lpAccelDst,
  int cAccelEntries);

// From: Mark Ashton on 5/8/97

BOOL
WINAPI
OCopyFileW(
  LPCWSTR lpExistingFileName,
  LPCWSTR lpNewFileName,
  BOOL bFailIfExists
  );

//  From EricKn 3/18/99

HMETAFILE 
WINAPI 
OCopyMetaFileW(
    HMETAFILE hmfSrc, 
    LPCWSTR lpszFile
    );

// from johnchen 7/19/99 
//UNDONE
// : Both of the CopyAcceleratorTable and CreateAcceleratorTable 
// : wrappers assume that the chars in the accelerator table are invariant 
// : between ANSI and Unicode. This is probably ok for VS tables, but it's 
// : not a complete solution if we deal with user-created tables. 
//

HACCEL
WINAPI
OCreateAcceleratorTableW(
  LPACCEL lpAccel, int cEntries);




HWND
WINAPI
OCreateDialogIndirectParamW(
  HINSTANCE hInstance,
  LPCDLGTEMPLATEW lpTemplate,
  HWND hWndParent,
  DLGPROC lpDialogFunc,
  LPARAM dwInitParam);



HWND
WINAPI
OCreateDialogParamW(
  HINSTANCE hInstance,
  LPCWSTR lpTemplateName,
  HWND hWndParent ,
  DLGPROC lpDialogFunc,
  LPARAM dwInitParam);


HDC
WINAPI
OCreateDCW(
  LPCWSTR lpszDriver,
  LPCWSTR lpszDevice,
  LPCWSTR lpszOutput,
  CONST DEVMODEW *lpInitData);

// From: Mark Ashton on 5/8/97

BOOL
WINAPI
OCreateDirectoryW(
  LPCWSTR lpPathName,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes
  );

// From: Mark Ashton on 5/8/97
//       Ted Smith: simpified on 6/25
// Smoke tested by Mark Ashton on 6/25

BOOL
WINAPI
OCreateDirectoryExW(
  LPCWSTR lpTemplateDirectory,
  LPCWSTR lpNewDirectory,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes
  );


HDC
WINAPI
OCreateEnhMetaFileW(
  HDC hdc,
  LPCWSTR lpFileName,
  CONST RECT *lpRect,
  LPCWSTR lpDescription);



HANDLE
WINAPI
OCreateEventW(
  LPSECURITY_ATTRIBUTES lpEventAttributes,
  BOOL bManualReset,
  BOOL bInitialState,
  LPCWSTR lpName
  );


HANDLE
WINAPI
OCreateFileW(
  LPCWSTR lpFileName,
  DWORD dwDesiredAccess,
  DWORD dwShareMode,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  DWORD dwCreationDisposition,
  DWORD dwFlagsAndAttributes,
  HANDLE hTemplateFile
  );


HFONT
WINAPI
OCreateFontIndirectW(CONST LOGFONTW * plfw);

// From: Mark Ashton on 5/29/97

HFONT
OCreateFontW(
  int nHeight, // logical height of font
  int nWidth, // logical average character width
  int nEscapement, // angle of escapement
  int nOrientation, // base-line orientation angle
  int fnWeight, // font weight
  DWORD fdwItalic, // italic attribute flag
  DWORD fdwUnderline, // underline attribute flag
  DWORD fdwStrikeOut, // strikeout attribute flag
  DWORD fdwCharSet, // character set identifier
  DWORD fdwOutputPrecision, // output precision
  DWORD fdwClipPrecision, // clipping precision
  DWORD fdwQuality, // output quality
  DWORD fdwPitchAndFamily, // pitch and family
  LPCWSTR lpszFace); // pointer to typeface name string


HDC
WINAPI
OCreateICW(
  LPCWSTR lpszDriver,
  LPCWSTR lpszDevice,
  LPCWSTR lpszOutput,
  CONST DEVMODEW *lpdvmInit);



HWND
WINAPI
OCreateMDIWindowW(
  LPWSTR lpClassName,
  LPWSTR lpWindowName,
  DWORD dwStyle,
  int X,
  int Y,
  int nWidth,
  int nHeight,
  HWND hWndParent,
  HINSTANCE hInstance,
  LPARAM lParam
  );



HDC     WINAPI
OCreateMetaFileW(LPCWSTR lpstr);



BOOL
WINAPI
OCreateProcessW(
  LPCWSTR lpApplicationName,
  LPWSTR lpCommandLine,
  LPSECURITY_ATTRIBUTES lpProcessAttributes,
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  BOOL bInheritHandles,
  DWORD dwCreationFlags,
  LPVOID lpEnvironment,
  LPCWSTR lpCurrentDirectory,
  LPSTARTUPINFOW lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
  );


HPROPSHEETPAGE
WINAPI
OCreatePropertySheetPageW(
  LPCPROPSHEETPAGEW lpcpsp
  );



HANDLE
WINAPI
OCreateSemaphoreW(
  LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
  LONG lInitialCount,
  LONG lMaximumCount,
  LPCWSTR lpName
  );


HWND  
WINAPI
OCreateWindowExW( DWORD dwExStyle,
        LPCWSTR lpClassName,
        LPCWSTR lpWindowName,
        DWORD dwStyle,
        int X,
        int Y,
        int nWidth,
        int nHeight,
        HWND hWndParent ,
        HMENU hMenu,
        HINSTANCE hInstance,
        LPVOID lpParam );


HSZ
WINAPI
ODdeCreateStringHandleW(
  DWORD idInst,
  LPCWSTR psz,
  int iCodePage);


UINT
WINAPI
ODdeInitializeW(
  LPDWORD pidInst,
  PFNCALLBACK pfnCallback,
  DWORD afCmd,
  DWORD ulRes);


LRESULT
WINAPI
ODefFrameProcW(
  HWND hWnd,
  HWND hWndMDIClient ,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam);


LRESULT
WINAPI
ODefMDIChildProcW(
  HWND hWnd,
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam);


LRESULT
WINAPI
ODefWindowProcW(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam);



BOOL
WINAPI
ODeleteFileW(
  LPCWSTR pwsz);


int
WINAPI
ODialogBoxIndirectParamW(
  HINSTANCE hInstance,
  LPCDLGTEMPLATEW hDialogTemplate,
  HWND hWndParent ,
  DLGPROC lpDialogFunc,
  LPARAM dwInitParam);


int
WINAPI
ODialogBoxParamW(
  HINSTANCE hInstance,
  LPCWSTR lpTemplateName,
  HWND hWndParent ,
  DLGPROC lpDialogFunc,
  LPARAM dwInitParam);


LONG
WINAPI
ODispatchMessageW(
  CONST MSG *lpMsg);


DWORD
WINAPI
ODocumentPropertiesW(
  HWND      hWnd,
  HANDLE    hPrinter,
  LPWSTR   pDeviceName,
  PDEVMODEW pDevModeOutput,
  PDEVMODEW pDevModeInput,
  DWORD     fMode
  );

// From: Mark Ashton on 5/29/97

UINT APIENTRY ODragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch);


int
WINAPI
ODrawTextW(
  HDC hDC,
  LPCWSTR lpString,
  int nCount,
  LPRECT lpRect,
  UINT uFormat);

// Written by Bill Hiebert on 9/4/97
// Smoke tested by Bill Hiebert 9/4/97

int
WINAPI
ODrawTextExW(HDC hdc, LPWSTR pwsz, int cb, LPRECT lprect, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams);


BOOL
WINAPI
OEnableWindow(
  HWND hWnd,
  BOOL bEnable);


// Written for Carlos Gomes on 6/26/97 by Ted Smith
// Smoke tested by Carlos Gomes on 6/26

DWORD
WINAPI
OExpandEnvironmentStringsW(
  LPCWSTR lpSrc,
  LPWSTR lpDst,
  DWORD nSize
  );

HICON 
APIENTRY 
OExtractAssociatedIconW(
    HINSTANCE hInst, 
    LPWSTR lpIconPath, 
    LPWORD lpiIcon
    );

HICON 
APIENTRY 
OExtractIconW(
    HINSTANCE hInst, 
    LPCWSTR lpszExeFileName, 
    UINT nIconIndex
    );

UINT 
WINAPI 
OExtractIconExW(
    LPCWSTR lpszFile, 
    int nIconIndex, 
    HICON FAR *phiconLarge, 
    HICON FAR *phiconSmall, 
    UINT nIcons
    );

BOOL  APIENTRY OExtTextOutW(
    HDC             hdc, 
    int             X, 
    int             Y, 
    UINT            fuOptions, 
    CONST RECT *    lprc, 
    LPCWSTR         lpString, 
    UINT            cch, 
    CONST INT *     lpDx
    );


VOID
WINAPI
OFatalAppExitW(
  UINT uAction,
  LPCWSTR lpMessageText
  );

HINSTANCE
APIENTRY
OFindExecutableW(
  LPCWSTR lpFile,
  LPCWSTR lpDirectory,
  LPWSTR lpResult
  );

// From: Mark Ashton on 5/8/97

HANDLE
WINAPI
OFindFirstChangeNotificationW(
  LPCWSTR lpPathName,
  BOOL bWatchSubtree,
  DWORD dwNotifyFilter
  );

// From: Mark Ashton on 5/8/97

HANDLE
WINAPI
OFindFirstFileW(
  LPCWSTR lpFileName,
  LPWIN32_FIND_DATAW lpFindFileData
  );

// From: Mark Ashton on 5/8/97

BOOL
WINAPI
OFindNextFileW(
  HANDLE hFindFile,
  LPWIN32_FIND_DATAW lpFindFileData
  );

// This is wrapped even though FindResourceW is implemented on Win95,
// because Win95 has a bug that corrupts the heap.

HRSRC
WINAPI
OFindResourceW(
  HINSTANCE hModule,
  LPCWSTR lpName,
  LPCWSTR lpType
  );


HWND
WINAPI
OFindWindowW(
  LPCWSTR lpClassName ,
  LPCWSTR lpWindowName);

// Bill Hiebert of IStudio on 6/13/97 added support for the
//   FORMAT_MESSAGE_ALLOCATE_BUFFER flag
// Bill donated a bugfix for 1819 on 8/1/97

DWORD
WINAPI
OFormatMessageW(
  DWORD dwFlags,
  LPCVOID lpSource,
  DWORD dwMessageId,
  DWORD dwLanguageId,
  LPWSTR lpBuffer,
  DWORD nSize,
  va_list *Arguments);

#ifdef _DEBUG
// These dumb wrapper implementations assume that the code points
// are the same in A/W
void VERIFYGETCHARWIDTHARGS (UINT uFirstChar, UINT uLastChar);
#else
#define VERIFYGETCHARWIDTHARGS(uFirstChar, uLastChar) (0);
#endif

 BOOL  APIENTRY
OGetCharABCWidthsFloatW(
  HDC     hdc,
  UINT    uFirstChar,
  UINT    uLastChar,
  LPABCFLOAT      lpABC);

 BOOL  APIENTRY
OGetCharABCWidthsW(
  HDC hdc,
  UINT uFirstChar,
  UINT uLastChar,
  LPABC lpABC);

 BOOL  APIENTRY
OGetCharWidthFloatW(
  HDC     hdc,
  UINT    uFirstChar,
  UINT    uLastChar,
  PFLOAT  pBuffer);


 BOOL  WINAPI
OGetCharWidthW(
  HDC hdc,
  UINT uFirstChar,
  UINT uLastChar,
  LPINT lpBuffer);

// Static buffers for GetClassInfo[Ex] to return the classname
// and menuname in Unicode, when running on an Ansi system.
// The contract of GetClassInfo is that it returns const ptrs
// back to the class name and menu name.  Unfortuntely, this
// prevents us from translating these back from Ansi to Unicode,
// without having some static buffers to use.  Since we strongly
// believe that the only people calling this are doing it just to
// see if it succeeds or not, so they know whether the class is
// already registered, we've willing to just have one set of
// static buffers to use.
// CAUTION: this will work as long as two threads don't call
// GetClassInfo[Ex] at the same time!
static WCHAR g_szClassName[256];
static WCHAR g_szMenuName[256];

#ifdef _DEBUG
static DWORD g_dwCallingThread = 0;    // debug global for ensuring one thread.
#endif // _DEBUG


BOOL
WINAPI
OGetClassInfoW
(
HINSTANCE hInstance,
LPCWSTR lpClassName,
LPWNDCLASSW lpWndClass
);


BOOL
WINAPI
OGetClassInfoExW
(
HINSTANCE hInstance,
LPCWSTR lpClassName,
LPWNDCLASSEXW lpWndClass
);


DWORD
WINAPI
OGetClassLongW(
  HWND hWnd,
  int nIndex);



DWORD
WINAPI
OSetClassLongW(
  HWND hWnd,
  int nIndex,
  LONG dwNewLong);


int
WINAPI
OGetClassNameW(
  HWND hWnd,
  LPWSTR lpClassName,
  int nMaxCount);


DWORD WINAPI
OGetCurrentDirectoryW(
  DWORD nBufferLength,
  LPWSTR lpBuffer);


int
WINAPI
OGetCurrencyFormatW(
  LCID     Locale,
  DWORD    dwFlags,
  LPCWSTR lpValue,
  CONST CURRENCYFMTW *lpFormat,
  LPWSTR  lpCurrencyStr,
  int      cchCurrency);


int
WINAPI
OGetDateFormatW(
  LCID     Locale,
  DWORD    dwFlags,
  CONST SYSTEMTIME *lpDate,
  LPCWSTR lpFormat,
  LPWSTR  lpDateStr,
  int      cchDate);


UINT
WINAPI
OGetDlgItemTextW(
  HWND hDlg,
  int nIDDlgItem,
  LPWSTR lpString,
  int nMaxCount);


UINT
WINAPI
OGetDriveTypeW(
  LPCWSTR lpRootPathName
  );

// Added by BillHie 4/5/99


DWORD
WINAPI
OGetEnvironmentVariableW(
  LPCWSTR lpName,
  LPWSTR lpBuffer,
  DWORD nSize
  );


LPWSTR
WINAPI
OGetEnvironmentStringsW(VOID);


int
WINAPI
OGetNumberFormatW(
  LCID     Locale,
  DWORD    dwFlags,
  LPCWSTR lpValue,
  CONST NUMBERFMTW *lpFormat,
  LPWSTR  lpNumberStr,
  int      cchNumber);


BOOL
WINAPI
OFreeEnvironmentStringsW(
    LPWSTR lpwstr
    );


BOOL
WINAPI
OSetEnvironmentVariableW(
  LPCWSTR lpName,
  LPCWSTR lpValue
  );


DWORD
WINAPI
OGetFileAttributesW(
  LPCWSTR lpFileName
  );

DWORD
WINAPI
OGetFileAttributesExW(
  LPCWSTR lpFileName,
  GET_FILEEX_INFO_LEVELS fInfoLevelId,
  LPVOID lpFileInformation	
  );

BOOL
WINAPI
OGetFileVersionInfoW(
  LPWSTR lpszFile,
  DWORD dwHandle,
  DWORD cbBuf,
  LPVOID lpvData);


short
WINAPI
OGetFileTitleW
(
LPCWSTR pwszFile,
LPWSTR pwszOut,
WORD w
);


DWORD
WINAPI
OGetFileVersionInfoSizeW(
  LPWSTR lpszFile,
  LPDWORD lpdwHandle);


DWORD
WINAPI
OGetFullPathNameW(
  LPCWSTR lpFileName,
  DWORD nBufferLength,
  LPWSTR lpBuffer,
  LPWSTR *lpFilePart
  );


//BUGBUG: wide character code points generally aren't the same for W/A,
// but this code passes the same value to both APIS

DWORD
WINAPI
OGetGlyphOutlineW(
  HDC     hdc,
  UINT    uChar,
  UINT    uFormat,
  LPGLYPHMETRICS      lpgm,
  DWORD       cbBuffer,
  LPVOID      lpvBuffer,
  CONST MAT2 *    lpmat2);


DWORD
WINAPI
OGetKerningPairsW(
  HDC         hdc,
  DWORD       nNumPairs,
  LPKERNINGPAIR       lpkrnpair);


BOOL
WINAPI
OGetMessageW(
  LPMSG lpMsg,
  HWND hWnd ,
  UINT wMsgFilterMin,
  UINT wMsgFilterMax);

 DWORD
WINAPI
OGetModuleFileNameW(
  HINSTANCE hModule,
  LPWSTR pwszFilename,
  DWORD nSize
  );


HMODULE
WINAPI
OGetModuleHandleW(
  LPCWSTR lpModuleName
  );

 UINT APIENTRY
OGetOutlineTextMetricsW(
  HDC hdc,
  UINT cbData,
  LPOUTLINETEXTMETRICW lpOTM);


UINT
WINAPI
OGetPrivateProfileIntW(
  LPCWSTR lpAppName,
  LPCWSTR lpKeyName,
  INT nDefault,
  LPCWSTR lpFileName);



DWORD
WINAPI
OGetPrivateProfileStringW(
  LPCWSTR lpAppName,
  LPCWSTR lpKeyName,
  LPCWSTR lpDefault,
  LPWSTR lpReturnedString,
  DWORD nSize,
  LPCWSTR lpFileName);


 int   WINAPI
OGetObjectW(
  HGDIOBJ hgdiobj,
  int cbBuffer,
  LPVOID lpvObject);

// From: Mark Ashton on 5/8/97
//       Ted Smith: Re-wrote fixing handling of non-trivial parameters on 6/25
// Smoke tested by Mark Ashton on 6/25

APIENTRY
OGetOpenFileNameW
(
LPOPENFILENAMEW lpofn
);


UINT
WINAPI
OGetProfileIntW(
  LPCWSTR lpAppName,
  LPCWSTR lpKeyName,
  INT nDefault
  );


HANDLE
WINAPI
OGetPropW(
  HWND hWnd,
  LPCWSTR lpString);

// From: Mark Ashton on 5/29/97
//       Ted Smith: Re-wrote fixing handling of non-trivial parameters on 6/25
// Smoke tested by Mark Ashton on 6/25

APIENTRY
OGetSaveFileNameW(LPOPENFILENAMEW lpofn);

/* We had to add this wrapper because components in daVinci that use ATL link statically. When statically
  the ATL makes call to this api and we need to provide the wrapper for that call. 
*/

// UNDONE  OGetShortPathNameW needs a thorough review for ANSI/Unicode issues


DWORD
WINAPI
OGetShortPathNameW
(
LPCTSTR lpszLongPath,  // pointer to a null-terminated path string
LPTSTR lpszShortPath,  // pointer to a buffer to receive the null-terminated short form of the path
DWORD cchBuffer        // specifies the size of the buffer pointed  to by lpszShortPath
); 


BOOL
WINAPI
OGetStringTypeExW(
  LCID     Locale,
  DWORD    dwInfoType,
  LPCWSTR  lpSrcStr,
  int      cchSrc,
  LPWORD   lpCharType);


DWORD
WINAPI
OGetTabbedTextExtentW(
  HDC hDC,
  LPCWSTR lpString,
  int nCount,
  int nTabPositions,
  LPINT lpnTabStopPositions);

// From: Mark Ashton on 5/8/97

UINT
WINAPI
OGetTempFileNameW(
  LPCWSTR lpPathName,
  LPCWSTR lpPrefixString,
  UINT uUnique,
  LPWSTR lpTempFileName
  );

// From: Mark Ashton on 5/8/97

DWORD
WINAPI
OGetTempPathW(
  DWORD nBufferLength,
  LPWSTR lpBuffer
  );

//wrapper when this is implemented on Win95 because of Win95 crashing bugs

BOOL  APIENTRY
OGetTextExtentPoint32W(
          HDC hdc,
          LPCWSTR pwsz,
          int cb,
          LPSIZE pSize
          );


BOOL APIENTRY
OGetTextExtentPointW(
          HDC hdc,
          LPCWSTR pwsz,
          int cch,
          LPSIZE pSize
          );

// helper for OGetTextExtentExPointW
static BOOL SimulateGetTextExtentExPointW (
    HDC     hdc,
    LPCWSTR lpString,
    int     cchString,
    int     nMaxExtent,
    LPINT   lpnFit,
    LPINT   alpDx,
    LPSIZE  lpSize
    );


BOOL  APIENTRY OGetTextExtentExPointW(
    HDC     hdc,
    LPCWSTR lpString,
    int     cchString,
    int     nMaxExtent,
    LPINT   lpnFit,
    LPINT   alpDx,
    LPSIZE  lpSize
    );


LONG
WINAPI
OGetWindowLongW(
  HWND hWnd,
  int nIndex);


BOOL
WINAPI
OGetTextMetricsW(
  HDC hdc,
  LPTEXTMETRICW lptm);


int
WINAPI
OGetTimeFormatW(
  LCID     Locale,
  DWORD    dwFlags,
  CONST SYSTEMTIME *lpTime,
  LPCWSTR lpFormat,
  LPWSTR  lpTimeStr,
  int      cchTime);

// From: Mark Ashton on 5/8/97

BOOL
WINAPI
OGetUserNameW (
  LPWSTR lpBuffer,
  LPDWORD pnSize
  );


BOOL
WINAPI
OGetVolumeInformationW(
  LPCWSTR lpRootPathName,
  LPWSTR lpVolumeNameBuffer,
  DWORD nVolumeNameSize,
  LPDWORD lpVolumeSerialNumber,
  LPDWORD lpMaximumComponentLength,
  LPDWORD lpFileSystemFlags,
  LPWSTR lpFileSystemNameBuffer,
  DWORD nFileSystemNameSize
  );


int
WINAPI
OGetWindowTextLengthW(
  HWND hWnd);


int
WINAPI
OGetWindowTextW(
  HWND hWnd,
  LPWSTR lpString,
  int nMaxCount);


ATOM
WINAPI
OGlobalAddAtomW(
  LPCWSTR lpString
  );

ATOM
WINAPI
OGlobalFindAtomW(
  LPCWSTR lpString
  );

// From: Josh Kaplan on 8/12/97

UINT
WINAPI
OGlobalGetAtomNameW(
  ATOM nAtom,
  LPWSTR lpBuffer,
  int nSize
  );


BOOL
WINAPI
OGrayStringW(
  HDC hDC,
  HBRUSH hBrush,
  GRAYSTRINGPROC lpOutputFunc,
  LPARAM lpData,
  int nCount,
  int X,
  int Y,
  int nWidth,
  int nHeight);

// From: Mark Ashton on 5/8/97

HIMAGELIST
WINAPI
OImageList_LoadImageW(HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);


LONG
WINAPI 
OImmGetCompositionStringW(HIMC, DWORD, LPVOID, DWORD);


BOOL
WINAPI
OInsertMenuW(
  HMENU hMenu,
  UINT uPosition,
  UINT uFlags,
  UINT uIDNewItem,
  LPCWSTR lpNewItem
  );


BOOL
WINAPI
OIsBadStringPtrW(
  LPCWSTR lpsz,
  UINT ucchMax
  );


BOOL
WINAPI
OIsCharAlphaNumericW(
  WCHAR wch);


BOOL
WINAPI
OIsCharAlphaW(
  WCHAR wch);


BOOL
WINAPI
OIsDialogMessageW(
  HWND hDlg,
  LPMSG lpMsg);

// From: Mark Ashton on 5/8/97
//     Bill Hieber - 2/5/98 fixed buffer size problem.
// CONSIDER: map only those characters that convert successfully (if not generating a sort key);$
// CONSIDER: use the codepage for locale in conversions?

int
WINAPI
OLCMapStringW(
  LCID     Locale,
  DWORD    dwMapFlags,
  LPCWSTR lpSrcStr,
  int      cchSrc,
  LPWSTR  lpDestStr,
  int      cchDest);

 HACCEL
WINAPI
OLoadAcceleratorsW(
  HINSTANCE hInst,
  LPCWSTR   lpTableName);


HBITMAP
WINAPI
OLoadBitmapW(
  HINSTANCE hInstance,
  LPCWSTR lpBitmapName);

 HCURSOR
WINAPI
OLoadCursorW(
  HINSTANCE hInstance,
  LPCWSTR lpCursorName);


HICON
WINAPI
OLoadIconW(
  HINSTANCE hInstance,
  LPCWSTR lpIconName);



HINSTANCE
WINAPI
OLoadLibraryW(
  LPCWSTR pwszFileName
  );


HMODULE
WINAPI
OLoadLibraryExW(
  LPCWSTR lpLibFileName,
  HANDLE hFile,
  DWORD dwFlags
  );


HMENU
WINAPI
OLoadMenuIndirectW(
  CONST MENUTEMPLATEW *lpMenuTemplate);


HMENU
WINAPI
OLoadMenuW(
  HINSTANCE hInstance,
  LPCWSTR lpMenuName);


int
WINAPI
OLoadStringW(
  HINSTANCE hInstance,
  UINT uID,
  LPWSTR lpBuffer,
  int nBufferMax);


LPWSTR
WINAPI
OlstrcatW(
  LPWSTR lpString1,
  LPCWSTR lpString2
  );



int
WINAPI
OlstrcmpiW(
  LPCWSTR lpString1,
  LPCWSTR lpString2
  );



int
WINAPI
OlstrcmpW(
  LPCWSTR lpString1,
  LPCWSTR lpString2
  );


LPWSTR
WINAPI
OlstrcpyW(
  LPWSTR lpString1,
  LPCWSTR lpString2
  );

// From: Mark Ashton on 5/8/97
//       Ted Smith added null string pointer handling
// [paulde] Just implement w/o using the API and save a little code

LPWSTR
WINAPI
OlstrcpynW(
  LPWSTR lpString1,
  LPCWSTR lpString2,
  int iMaxLength
  );


int
WINAPI
OlstrlenW(
  LPCWSTR lpString
  );


UINT
WINAPI
OMapVirtualKeyW(
  UINT uCode,
  UINT uMapType);


//BUGBUG: why the wrapper when it's implemented on Win95?

int
WINAPI
OMessageBoxW(
  HWND hWnd ,
  LPCWSTR lpText,
  LPCWSTR lpCaption,
  UINT uType);



int
WINAPI
OMessageBoxIndirectW(
  LPMSGBOXPARAMSW lpmbp);



BOOL
WINAPI
OModifyMenuW(
  HMENU hMnu,
  UINT uPosition,
  UINT uFlags,
  UINT uIDNewItem,
  LPCWSTR lpNewItem
  );


// From: Mark Ashton on 5/29/97

BOOL
WINAPI
OMoveFileExW(
  LPCWSTR lpExistingFileName,
  LPCWSTR lpNewFileName,
  DWORD dwFlags
  );



BOOL
WINAPI
OMoveFileW(
  LPCWSTR lpExistingFileName,
  LPCWSTR lpNewFileName);



HANDLE
WINAPI
OLoadImageW(
  HINSTANCE hinst,
  LPCWSTR lpszName,
  UINT uType,
  int cxDesired,
  int cyDesired,
  UINT fuLoad);



BOOL
WINAPI
OOemToCharW(
  LPCSTR lpszSrc,
  LPWSTR lpszDst);


// CONSIDER why is this here

BOOL
WINAPI
OOpenPrinterW(
  LPWSTR    pPrinterName,
  LPHANDLE phPrinter,
  LPPRINTER_DEFAULTSW pDefault
  );



VOID
WINAPI
OOutputDebugStringW(
  LPCWSTR lpOutputString
  );



BOOL
WINAPI
OPeekMessageW(
  LPMSG lpMsg,
  HWND hWnd ,
  UINT wMsgFilterMin,
  UINT wMsgFilterMax,
  UINT wRemoveMsg);


// Patch for converting embedded sheets from Brian Marshall 2/2/98
// TedSmith: Rewritten to survive either set of header for size of PROPSHEETPAGE

int
WINAPI
OPropertySheetW(
  LPCPROPSHEETHEADERW lpcpsh
  );




BOOL
WINAPI
OPostMessageW(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam);


BOOL
WINAPI
OPostThreadMessageW(
  DWORD idThread,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam);


// From: Mark Ashton on 5/8/97

LONG
APIENTRY
ORegCreateKeyExW(
  HKEY hKey,
  LPCWSTR lpSubKey,
  DWORD Reserved,
  LPWSTR lpClass,
  DWORD dwOptions,
  REGSAM samDesired,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  PHKEY phkResult,
  LPDWORD lpdwDisposition
  );

// From: Mark Ashton on 5/8/97

LONG
APIENTRY
ORegCreateKeyW (
  HKEY hKey,
  LPCWSTR lpSubKey,
  PHKEY phkResult
  );

// From: Mark Ashton on 5/8/97

LONG
APIENTRY
ORegEnumKeyW (
  HKEY hKey,
  DWORD dwIndex,
  LPWSTR lpName,
  DWORD cbName
  );

//  Van Kichline
//  IHammer group
//  Not supported: REG_MULTI_SZ
//

LONG
APIENTRY
ORegEnumValueW (
  HKEY hKey,
  DWORD dwIndex,
  LPWSTR lpValueName,
  LPDWORD lpcbValueName,  // Documentation indicates this is a count of characters, despite the Hungarian.
  LPDWORD lpReserved,
  LPDWORD lpType,         // May be NULL, but we need to know it on return if lpData is not NULL.
  LPBYTE lpData,          // May be NULL
  LPDWORD lpcbData        // May be NULL is lpData is NULL
  );

 LONG APIENTRY ORegOpenKeyW(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult);


LONG
APIENTRY
ORegDeleteKeyW(
  HKEY hKey,
  LPCWSTR pwszSubKey
  );


LONG
APIENTRY
ORegDeleteValueW(
  HKEY hKey,
  LPWSTR lpValueName
  );


ATOM
WINAPI
ORegisterClassW(
  CONST WNDCLASSW *lpWndClass);


ATOM
WINAPI
ORegisterClassExW (CONST WNDCLASSEXW * lpWndClass);



BOOL
WINAPI
OUnregisterClassW (
    LPCTSTR  lpClassName,   // address of class name string
    HINSTANCE  hInstance    // handle of application instance
    );


UINT
WINAPI
ORegisterClipboardFormatW (LPCWSTR lpszFormat);

 UINT WINAPI
ORegisterWindowMessageW (LPCWSTR lpString);

 LONG
APIENTRY
ORegOpenKeyExW (
  HKEY hKey,
  LPCTSTR lpSubKey,
  DWORD ulOptions,
  REGSAM samDesired,
  PHKEY phkResult
  );


LONG
APIENTRY
ORegQueryInfoKeyW (
  HKEY hKey,
  LPWSTR lpClass,
  LPDWORD lpcbClass,
  LPDWORD lpReserved,
  LPDWORD lpcSubKeys,
  LPDWORD lpcbMaxSubKeyLen,
  LPDWORD lpcbMaxClassLen,
  LPDWORD lpcValues,
  LPDWORD lpcbMaxValueNameLen,
  LPDWORD lpcbMaxValueLen,
  LPDWORD lpcbSecurityDescriptor,
  PFILETIME lpftLastWriteTime
  );

 LONG APIENTRY ORegQueryValueW (
    HKEY    hKey, 
    LPCWSTR pwszSubKey, 
    LPWSTR  pwszValue,
    PLONG   lpcbValue
    );


LONG
APIENTRY
ORegSetValueExW (
  HKEY            hKey,
  LPCWSTR         lpValueName,
  DWORD           Reserved,
  DWORD           dwType,
  CONST BYTE *    lpData,
  DWORD           cbData
  );

 LONG APIENTRY 
ORegSetValueW (
    HKEY    hKey, 
    LPCWSTR lpSubKey, 
    DWORD   dwType,
    LPCWSTR lpData, 
    DWORD   cbData
    );

 LONG
APIENTRY
ORegQueryValueExW (
  HKEY    hKey,
  LPWSTR  lpValueName,
  LPDWORD lpReserved,
  LPDWORD lpType,
  LPBYTE  lpData,
  LPDWORD lpcbData
  );



HANDLE
WINAPI
ORemovePropW(
  HWND hWnd,
  LPCWSTR lpString);

 HDC  WINAPI
OResetDCW(
  HDC hdc,
  CONST DEVMODEW *lpInitData);

// BUGBUG: OSendDlgItemMessageW converts lParam, OSendMessageW does not!!

LONG
WINAPI
OSendDlgItemMessageW(
  HWND hDlg,
  int nIDDlgItem,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam);

// BUGBUG: OSendDlgItemMessageW converts lParam, OSendMessageW does not!!

LRESULT
WINAPI
OSendMessageW(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam);


BOOL
WINAPI
OSendNotifyMessageW(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam);

//  From EricKn 3/18/99

BOOL
WINAPI
OSetCurrentDirectoryW(
  LPCWSTR lpPathName
  );


BOOL
WINAPI
OSetDlgItemTextW(
  HWND hDlg,
  int nIDDlgItem,
  LPCWSTR lpString);


BOOL
WINAPI
OSetFileAttributesW(
  LPCWSTR lpFileName,
  DWORD dwFileAttributes
  );


BOOL
WINAPI
OSetPropW(
  HWND hWnd,
  LPCWSTR lpString,
  HANDLE hData);


BOOL
WINAPI
OSetMenuItemInfoW(
  HMENU hMenu,
  UINT uItem,
  BOOL fByPosition,
  LPCMENUITEMINFOW lpcmii
  );



LONG
WINAPI
OSetWindowLongW(
  HWND hWnd,
  int nIndex,
  LONG dwNewLong);


HHOOK
WINAPI
OSetWindowsHookExW(
  int idHook,
  HOOKPROC lpfn,
  HINSTANCE hmod,
  DWORD dwThreadId);


BOOL
WINAPI
OSetWindowTextW(
  HWND hWnd,
  LPCWSTR lpString);

// From: Bill Hiebert of IStudio on 6/13/97
//       Ted Smith: somplified and returned results 6/13
//       Ted Smith: added LoadProcAddress ... on 6/16
// Smoke tested by Bill on 6/16
//       Ted Smith: Fixed handling of lpFile on 6/25
// Smoke tested by Mark Ashton on 6/25

typedef BOOL (WINAPI *PFShellExecuteExW)(LPSHELLEXECUTEINFOW);
static PFShellExecuteExW s_PFShellExecuteExW = 0;


BOOL
WINAPI
OShellExecuteExW(
  LPSHELLEXECUTEINFOW lpExecInfo);


LONG
WINAPI
OTabbedTextOutW(
  HDC hDC,
  int X,
  int Y,
  LPCWSTR lpString,
  int nCount,
  int nTabPositions,
  LPINT lpnTabStopPositions,
  int nTabOrigin);


int
WINAPI
OTranslateAcceleratorW(
  HWND hWnd,
  HACCEL hAccTable,
  LPMSG lpMsg);



DWORD
APIENTRY
OVerLanguageNameW(
    DWORD wLang,
    LPWSTR szLang,
    DWORD nSize
    );


BOOL
WINAPI
OVerQueryValueW(
  const LPVOID pBlock,
  LPWSTR lpSubBlock,
  LPVOID *lplpBuffer,
  PUINT puLerr);


SHORT
WINAPI
OVkKeyScanW(
  WCHAR ch);


BOOL
WINAPI
OWinHelpW(
  HWND hWndMain,
  LPCWSTR lpszHelp,
  UINT uCommand,
  DWORD dwData
  );


DWORD APIENTRY
OWNetGetConnectionW (
    LPCWSTR lpLocalName,
    LPWSTR  lpRemoteName,
    LPDWORD  lpnLength
    );



BOOL
WINAPI
OWritePrivateProfileStringW(
  LPCWSTR lpAppName,
  LPCWSTR lpKeyName,
  LPCWSTR lpString,
  LPCWSTR lpFileName);

 int WINAPIV
OwsprintfW (
    LPWSTR pwszOut, 
    LPCWSTR pwszFormat, 
    ...);



BOOL
WINAPI
OGetVersionExW(
  LPOSVERSIONINFOW lpVersionInformation
  );



LONG
APIENTRY
ORegEnumKeyExW (
  HKEY hKey,
  DWORD dwIndex,
  LPWSTR lpName,
  LPDWORD lpcbName,
  LPDWORD lpReserved,
  LPWSTR lpClass,
  LPDWORD lpcbClass,
  PFILETIME lpftLastWriteTime
  );



HANDLE
WINAPI
OCreateFileMappingW(
  HANDLE hFile,
  LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
  DWORD flProtect,
  DWORD dwMaximumSizeHigh,
  DWORD dwMaximumSizeLow,
  LPCWSTR lpName
  );



LRESULT
WINAPI
ODefDlgProcW(
  HWND hDlg,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam);



int
WINAPI
OGetLocaleInfoW(
  LCID     Locale,
  LCTYPE   LCType,
  LPWSTR  lpLCData,
  int      cchData);


BOOL
WINAPI
OSetLocaleInfoW(
  LCID     Locale,
  LCTYPE   LCType,
  LPCWSTR lpLCData);

//-----------------------------------------------------------------------------
// Name: OStgCreateDocfile
//
// Description:
// Wrapper for StgCreateDocfile to protect against reentrancy bug in OLE.
//
// Thread-Safety: Bullet-proof
//
// Return Values: same HRESULT as StgCreateDocfile
//-----------------------------------------------------------------------------


HRESULT
WINAPI
OStgCreateDocfile
(
const WCHAR * pwcsName, 
DWORD grfMode,
DWORD reserved,
IStorage ** ppstgOpen
);



APIENTRY
OPrintDlgW
(
LPPRINTDLGW lppd
);




int
WINAPI
OStartDocW
(
HDC hDC,
CONST DOCINFOW * pdiDocW
);


LPITEMIDLIST
WINAPI
OSHBrowseForFolderW(
  LPBROWSEINFO lpbi);


BOOL
WINAPI
OSHGetPathFromIDListW(
  LPCITEMIDLIST pidl,
  LPTSTR pszPath);


BOOL
WINAPI
OSystemParametersInfoW(
  UINT uiAction,
  UINT uiParam,
  PVOID pvParam,
  UINT fWinIni);


BOOL WINAPI OShell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData);



int
WINAPI
OGetTextFaceW(
    HDC    hdc,
    int    cwch,
    LPWSTR lpFaceName);

//  From VanK 2/23/99

DWORD 
WINAPI 
OSHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW FAR *psfi, UINT cbFileInfo, UINT uFlags);



int
WINAPI
OwvsprintfW(
  LPWSTR pwszOut,
  LPCWSTR pwszFormat,
  va_list arglist);

//================================================================
//================================================================
//=====================  Unwrapped APIs  =========================
//================================================================
//================================================================


#ifdef _DEBUG


BOOL
APIENTRY
OAbortSystemShutdownW(
  LPWSTR lpMachineName
  );


BOOL
WINAPI
OAccessCheckAndAuditAlarmW (
  LPCWSTR SubsystemName,
  LPVOID HandleId,
  LPWSTR ObjectTypeName,
  LPWSTR ObjectName,
  PSECURITY_DESCRIPTOR SecurityDescriptor,
  DWORD DesiredAccess,
  PGENERIC_MAPPING GenericMapping,
  BOOL ObjectCreation,
  LPDWORD GrantedAccess,
  LPBOOL AccessStatus,
  LPBOOL pfGenerateOnClose
  );


int WINAPI OAddFontResourceW(LPCWSTR);


BOOL
WINAPI
OAddFormW(
  HANDLE  hPrinter,
  DWORD   Level,
  LPBYTE  pForm
);


BOOL
WINAPI
OAddJobW(
  HANDLE  hPrinter,
  DWORD   Level,
  LPBYTE  pData,
  DWORD   cbBuf,
  LPDWORD pcbNeeded
);


BOOL
WINAPI
OAddMonitorW(
  LPWSTR   pName,
  DWORD   Level,
  LPBYTE  pMonitors
);


BOOL
WINAPI
OAddPortW(
  LPWSTR   pName,
  HWND    hWnd,
  LPWSTR   pMonitorName
);


HANDLE
WINAPI
OAddPrinterW(
  LPWSTR   pName,
  DWORD   Level,
  LPBYTE  pPrinter
);


BOOL
WINAPI
OAddPrinterConnectionW(
  LPWSTR   pName
);


BOOL
WINAPI
OAddPrinterDriverW(
  LPWSTR   pName,
  DWORD   Level,
  LPBYTE  pDriverInfo
);


BOOL
WINAPI
OAddPrintProcessorW(
  LPWSTR   pName,
  LPWSTR   pEnvironment,
  LPWSTR   pPathName,
  LPWSTR   pPrintProcessorName
);


BOOL
WINAPI
OAddPrintProvidorW(
  LPWSTR  pName,
  DWORD    level,
  LPBYTE   pProvidorInfo
);


LONG
WINAPI
OAdvancedDocumentPropertiesW(
  HWND    hWnd,
  HANDLE  hPrinter,
  LPWSTR   pDeviceName,
  PDEVMODEW pDevModeOutput,
  PDEVMODEW pDevModeInput
);


MMRESULT WINAPI OauxGetDevCapsW(UINT uDeviceID, LPAUXCAPSW pac, UINT cbac);


WINAPI OAVIBuildFilterW(LPWSTR lpszFilter, LONG cbFilter, BOOL fSaving);


WINAPI OAVIFileCreateStreamW (PAVIFILE pfile, PAVISTREAM FAR *ppavi, AVISTREAMINFOW FAR * psi);


WINAPI OAVIFileInfoW (PAVIFILE pfile, LPAVIFILEINFOW pfi, LONG lSize);


HRESULT CDECL OAVISaveW (LPCWSTR               szFile,
    CLSID FAR *pclsidHandler,
    AVISAVECALLBACK     lpfnCallback,
    int                 nStreams,
    PAVISTREAM      pfile,
    LPAVICOMPRESSOPTIONS lpOptions,
    ...);


WINAPI OAVIStreamInfoW (PAVISTREAM pavi, LPAVISTREAMINFOW psi, LONG lSize);


WINAPI OAVIStreamOpenFromFileW(PAVISTREAM FAR *ppavi, LPCWSTR szFile,
         DWORD fccType, LONG lParam,
         UINT mode, CLSID FAR *pclsidHandler);


BOOL
WINAPI
OBackupEventLogW (
  HANDLE hEventLog,
  LPCWSTR lpBackupFileName
  );


HANDLE
WINAPI
OBeginUpdateResourceW(
  LPCWSTR pFileName,
  BOOL bDeleteExistingResources
  );


BOOL
WINAPI
OBuildCommDCBW(
  LPCWSTR lpDef,
  LPDCB lpDCB
  );


BOOL
WINAPI
OBuildCommDCBAndTimeoutsW(
  LPCWSTR lpDef,
  LPDCB lpDCB,
  LPCOMMTIMEOUTS lpCommTimeouts
  );


BOOL
WINAPI
OCallMsgFilterW(
  LPMSG lpMsg,
  int nCode);


BOOL
WINAPI
OCallNamedPipeW(
  LPCWSTR lpNamedPipeName,
  LPVOID lpInBuffer,
  DWORD nInBufferSize,
  LPVOID lpOutBuffer,
  DWORD nOutBufferSize,
  LPDWORD lpBytesRead,
  DWORD nTimeOut
  );


VFWAPI OcapCreateCaptureWindowW (
    LPCWSTR lpszWindowName,
    DWORD dwStyle,
    int x, int y, int nWidth, int nHeight,
    HWND hwndParent, int nID);


LONG
WINAPI
OChangeDisplaySettingsW(
  LPDEVMODEW lpDevMode,
  DWORD dwFlags);


BOOL
WINAPI
OChangeMenuW(
  HMENU hMenu,
  UINT cmd,
  LPCWSTR lpszNewItem,
  UINT cmdInsert,
  UINT flags);

#if 0 //UNDONE_POST_98 - We should wrap these as being NT only...

BOOL
WINAPI
OChangeServiceConfigW(
  SC_HANDLE    hService,
  DWORD        dwServiceType,
  DWORD        dwStartType,
  DWORD        dwErrorControl,
  LPCWSTR     lpBinaryPathName,
  LPCWSTR     lpLoadOrderGroup,
  LPDWORD      lpdwTagId,
  LPCWSTR     lpDependencies,
  LPCWSTR     lpServiceStartName,
  LPCWSTR     lpPassword,
  LPCWSTR     lpDisplayName
  );
#endif


BOOL
WINAPI
OCharToOemBuffW(
  LPCWSTR lpszSrc,
  LPSTR lpszDst,
  DWORD cchDstLength);


BOOL
WINAPI
OClearEventLogW (
  HANDLE hEventLog,
  LPCWSTR lpBackupFileName
  );


BOOL
WINAPI
OCommConfigDialogW(
  LPCWSTR lpszName,
  HWND hWnd,
  LPCOMMCONFIG lpCC
  );


BOOL
WINAPI
OConfigurePortW(
  LPWSTR   pName,
  HWND    hWnd,
  LPWSTR   pPortName
);



HENHMETAFILE WINAPI OCopyEnhMetaFileW(HENHMETAFILE, LPCWSTR);


WINAPI OCreateColorSpaceW(LPLOGCOLORSPACEW);


HDESK
WINAPI
OCreateDesktopW(
  LPWSTR lpszDesktop,
  LPWSTR lpszDevice,
  LPDEVMODEW pDevmode,
  DWORD dwFlags,
  DWORD dwDesiredAccess,
  LPSECURITY_ATTRIBUTES lpsa);


HANDLE
WINAPI
OCreateMailslotW(
  LPCWSTR lpName,
  DWORD nMaxMessageSize,
  DWORD lReadTimeout,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes
  );


HANDLE
WINAPI
OCreateMutexW(
  LPSECURITY_ATTRIBUTES lpMutexAttributes,
  BOOL bInitialOwner,
  LPCWSTR lpName
  );


HANDLE
WINAPI
OCreateNamedPipeW(
  LPCWSTR lpName,
  DWORD dwOpenMode,
  DWORD dwPipeMode,
  DWORD nMaxInstances,
  DWORD nOutBufferSize,
  DWORD nInBufferSize,
  DWORD nDefaultTimeOut,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes
  );


BOOL
WINAPI
OCreateProcessAsUserW (
  HANDLE hToken,
  LPCWSTR lpApplicationName,
  LPWSTR lpCommandLine,
  LPSECURITY_ATTRIBUTES lpProcessAttributes,
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  BOOL bInheritHandles,
  DWORD dwCreationFlags,
  LPVOID lpEnvironment,
  LPCWSTR lpCurrentDirectory,
  LPSTARTUPINFOW lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
  );


BOOL    WINAPI OCreateScalableFontResourceW(DWORD, LPCWSTR, LPCWSTR, LPCWSTR);

#if 0 //UNDONE_POST_98 - We should wrap these as being NT only...

SC_HANDLE
WINAPI
OCreateServiceW(
  SC_HANDLE    hSCManager,
  LPCWSTR     lpServiceName,
  LPCWSTR     lpDisplayName,
  DWORD        dwDesiredAccess,
  DWORD        dwServiceType,
  DWORD        dwStartType,
  DWORD        dwErrorControl,
  LPCWSTR     lpBinaryPathName,
  LPCWSTR     lpLoadOrderGroup,
  LPDWORD      lpdwTagId,
  LPCWSTR     lpDependencies,
  LPCWSTR     lpServiceStartName,
  LPCWSTR     lpPassword
  );
#endif


HWND WINAPI OCreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID);


HWINSTA
WINAPI
OCreateWindowStationW(
  LPWSTR lpwinsta,
  DWORD dwReserved,
  DWORD dwDesiredAccess,
  LPSECURITY_ATTRIBUTES lpsa);


RPC_STATUS RPC_ENTRY
ODceErrorInqTextW (
  IN RPC_STATUS RpcStatus,
  OUT unsigned short __RPC_FAR * ErrorText
  );


BOOL
WINAPI
ODefineDosDeviceW(
  DWORD dwFlags,
  LPCWSTR lpDeviceName,
  LPCWSTR lpTargetPath
  );


BOOL
WINAPI
ODeleteFormW(
  HANDLE  hPrinter,
  LPWSTR   pFormName
);


BOOL
WINAPI
ODeleteMonitorW(
  LPWSTR   pName,
  LPWSTR   pEnvironment,
  LPWSTR   pMonitorName
);


BOOL
WINAPI
ODeletePortW(
  LPWSTR   pName,
  HWND    hWnd,
  LPWSTR   pPortName
);


BOOL
WINAPI
ODeletePrinterConnectionW(
  LPWSTR   pName
);


BOOL
WINAPI
ODeletePrinterDriverW(
   LPWSTR    pName,
   LPWSTR    pEnvironment,
   LPWSTR    pDriverName
);


BOOL
WINAPI
ODeletePrintProcessorW(
  LPWSTR   pName,
  LPWSTR   pEnvironment,
  LPWSTR   pPrintProcessorName
);


BOOL
WINAPI
ODeletePrintProvidorW(
  LPWSTR   pName,
  LPWSTR   pEnvironment,
  LPWSTR   pPrintProvidorName
);


int  WINAPI ODeviceCapabilitiesW(LPCWSTR, LPCWSTR, WORD,
                LPWSTR, CONST DEVMODEW *);


int
WINAPI
ODlgDirListW(
  HWND hDlg,
  LPWSTR lpPathSpec,
  int nIDListBox,
  int nIDStaticPath,
  UINT uFileType);


int
WINAPI
ODlgDirListComboBoxW(
  HWND hDlg,
  LPWSTR lpPathSpec,
  int nIDComboBox,
  int nIDStaticPath,
  UINT uFiletype);


BOOL
WINAPI
ODlgDirSelectComboBoxExW(
  HWND hDlg,
  LPWSTR lpString,
  int nCount,
  int nIDComboBox);


BOOL
WINAPI
ODlgDirSelectExW(
  HWND hDlg,
  LPWSTR lpString,
  int nCount,
  int nIDListBox);


DWORD   APIENTRY ODoEnvironmentSubstW(LPWSTR szString, UINT cbString);


BOOL WINAPI ODrawStateW(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT);


WINAPI OEditStreamSetInfoW(PAVISTREAM pavi, LPAVISTREAMINFOW lpInfo, LONG cbInfo);


BOOL
WINAPI
OEndUpdateResourceW(
  HANDLE      hUpdate,
  BOOL        fDiscard
  );


BOOL
WINAPI
OEnumCalendarInfoW(
  CALINFO_ENUMPROCW lpCalInfoEnumProc,
  LCID              Locale,
  CALID             Calendar,
  CALTYPE           CalType);


BOOL
WINAPI
OEnumDateFormatsW(
  DATEFMT_ENUMPROCW lpDateFmtEnumProc,
  LCID              Locale,
  DWORD             dwFlags);

#if 0 //UNDONE_POST_98 - We should wrap these as being NT only...

BOOL
WINAPI
OEnumDependentServicesW(
  SC_HANDLE               hService,
  DWORD                   dwServiceState,
  LPENUM_SERVICE_STATUSW  lpServices,
  DWORD                   cbBufSize,
  LPDWORD                 pcbBytesNeeded,
  LPDWORD                 lpServicesReturned
  );
#endif


BOOL
WINAPI
OEnumDesktopsW(
  HWINSTA hwinsta,
  DESKTOPENUMPROCW lpEnumFunc,
  LPARAM lParam);


BOOL
WINAPI
OEnumDisplaySettingsW(
  LPCWSTR lpszDeviceName,
  DWORD iModeNum,
  LPDEVMODEW lpDevMode);


int  WINAPI OEnumFontFamiliesW(HDC, LPCWSTR, FONTENUMPROCW, LPARAM);


int  WINAPI OEnumFontFamiliesExW(HDC, LPLOGFONTW,FONTENUMPROCW, LPARAM,DWORD);


int  WINAPI OEnumFontsW(HDC, LPCWSTR,  FONTENUMPROCW, LPARAM);


BOOL
WINAPI
OEnumFormsW(
  HANDLE  hPrinter,
  DWORD   Level,
  LPBYTE  pForm,
  DWORD   cbBuf,
  LPDWORD pcbNeeded,
  LPDWORD pcReturned
);


WINAPI OEnumICMProfilesW(HDC,ICMENUMPROCW,LPARAM);


BOOL
WINAPI
OEnumJobsW(
  HANDLE  hPrinter,
  DWORD   FirstJob,
  DWORD   NoJobs,
  DWORD   Level,
  LPBYTE  pJob,
  DWORD   cbBuf,
  LPDWORD pcbNeeded,
  LPDWORD pcReturned
);


BOOL
WINAPI
OEnumMonitorsW(
  LPWSTR   pName,
  DWORD   Level,
  LPBYTE  pMonitors,
  DWORD   cbBuf,
  LPDWORD pcbNeeded,
  LPDWORD pcReturned
);


BOOL
WINAPI
OEnumPortsW(
  LPWSTR   pName,
  DWORD   Level,
  LPBYTE  pPorts,
  DWORD   cbBuf,
  LPDWORD pcbNeeded,
  LPDWORD pcReturned
);


BOOL
WINAPI
OEnumPrinterDriversW(
  LPWSTR   pName,
  LPWSTR   pEnvironment,
  DWORD   Level,
  LPBYTE  pDriverInfo,
  DWORD   cbBuf,
  LPDWORD pcbNeeded,
  LPDWORD pcReturned
);


BOOL
WINAPI
OEnumPrintersW(
  DWORD   Flags,
  LPWSTR   Name,
  DWORD   Level,
  LPBYTE  pPrinterEnum,
  DWORD   cbBuf,
  LPDWORD pcbNeeded,
  LPDWORD pcReturned
);


BOOL
WINAPI
OEnumPrintProcessorDatatypesW(
  LPWSTR   pName,
  LPWSTR   pPrintProcessorName,
  DWORD   Level,
  LPBYTE  pDatatypes,
  DWORD   cbBuf,
  LPDWORD pcbNeeded,
  LPDWORD pcReturned
);


BOOL
WINAPI
OEnumPrintProcessorsW(
  LPWSTR   pName,
  LPWSTR   pEnvironment,
  DWORD   Level,
  LPBYTE  pPrintProcessorInfo,
  DWORD   cbBuf,
  LPDWORD pcbNeeded,
  LPDWORD pcReturned
);


int
WINAPI
OEnumPropsW(
  HWND hWnd,
  PROPENUMPROCW lpEnumFunc);


int
WINAPI
OEnumPropsExW(
  HWND hWnd,
  PROPENUMPROCEXW lpEnumFunc,
  LPARAM lParam);


INT
APIENTRY
OEnumProtocolsW (
  IN     LPINT           lpiProtocols,
  IN OUT LPVOID          lpProtocolBuffer,
  IN OUT LPDWORD         lpdwBufferLength
  );


BOOL
WINAPI
OEnumResourceLanguagesW(
  HMODULE hModule,
  LPCWSTR lpType,
  LPCWSTR lpName,
  ENUMRESLANGPROC lpEnumFunc,
  LONG lParam
  );


BOOL
WINAPI
OEnumResourceNamesW(
  HMODULE hModule,
  LPCWSTR lpType,
  ENUMRESNAMEPROC lpEnumFunc,
  LONG lParam
  );


BOOL
WINAPI
OEnumResourceTypesW(
  HMODULE hModule,
  ENUMRESTYPEPROC lpEnumFunc,
  LONG lParam
  );

#if 0 //UNDONE_POST_98 - We should wrap these as being NT only...

BOOL
WINAPI
OEnumServicesStatusW(
  SC_HANDLE               hSCManager,
  DWORD                   dwServiceType,
  DWORD                   dwServiceState,
  LPENUM_SERVICE_STATUSW  lpServices,
  DWORD                   cbBufSize,
  LPDWORD                 pcbBytesNeeded,
  LPDWORD                 lpServicesReturned,
  LPDWORD                 lpResumeHandle
  );
#endif


BOOL
WINAPI
OEnumSystemCodePagesW(
  CODEPAGE_ENUMPROCW lpCodePageEnumProc,
  DWORD              dwFlags);


BOOL
WINAPI
OEnumSystemLocalesW(
  LOCALE_ENUMPROCW lpLocaleEnumProc,
  DWORD            dwFlags);


BOOL
WINAPI
OEnumTimeFormatsW(
  TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
  LCID              Locale,
  DWORD             dwFlags);


BOOL
WINAPI
OEnumWindowStationsW(
  WINSTAENUMPROCW lpEnumFunc,
  LPARAM lParam);




BOOL
WINAPI
OFillConsoleOutputCharacterW(
  HANDLE hConsoleOutput,
  WCHAR  cCharacter,
  DWORD  nLength,
  COORD  dwWriteCoord,
  LPDWORD lpNumberOfCharsWritten
  );


LPWSTR APIENTRY OFindEnvironmentStringW(LPWSTR szEnvVar);


// FindResourceExW is implemented on Win95, but can corrupt heap on Win95

HRSRC
WINAPI
OFindResourceExW(
  HMODULE hModule,
  LPCWSTR lpType,
  LPCWSTR lpName,
  WORD    wLanguage
  );


 APIENTRY    OFindTextW(LPFINDREPLACEW);


HWND    WINAPI OFindWindowExW(HWND, HWND, LPCWSTR, LPCWSTR);


int
WINAPI
OFoldStringW(
  DWORD    dwMapFlags,
  LPCWSTR lpSrcStr,
  int      cchSrc,
  LPWSTR  lpDestStr,
  int      cchDest);


INT
APIENTRY
OGetAddressByNameW (
  IN     DWORD                dwNameSpace,
  IN     LPGUID               lpServiceType,
  IN     LPWSTR              lpServiceName OPTIONAL,
  IN     LPINT                lpiProtocols OPTIONAL,
  IN     DWORD                dwResolution,
  IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo OPTIONAL,
  IN OUT LPVOID               lpCsaddrBuffer,
  IN OUT LPDWORD              lpdwBufferLength,
  IN OUT LPWSTR              lpAliasBuffer OPTIONAL,
  IN OUT LPDWORD              lpdwAliasBufferLength OPTIONAL
  );


BOOL
WINAPI
OGetBinaryTypeW(
  LPCWSTR lpApplicationName,
  LPDWORD lpBinaryType
  );


DWORD WINAPI OGetCharacterPlacementW(HDC, LPCWSTR, int, int, LPGCP_RESULTSW, DWORD);



BOOL  WINAPI OGetCharWidth32W(HDC, UINT, UINT, LPINT);



LPWSTR
WINAPI
OGetCommandLineW(
  VOID
  );


DWORD
WINAPI
OGetCompressedFileSizeW(
  LPCWSTR lpFileName,
  LPDWORD lpFileSizeHigh
  );


BOOL
WINAPI
OGetComputerNameW (
  LPWSTR lpBuffer,
  LPDWORD lpnSize
  );


DWORD
WINAPI
OGetConsoleTitleW(
  LPWSTR lpConsoleTitle,
  DWORD nSize
  );
 


BOOL
WINAPI
OGetDefaultCommConfigW(
  LPCWSTR lpszName,
  LPCOMMCONFIG lpCC,
  LPDWORD lpdwSize
  );


BOOL
WINAPI
OGetDiskFreeSpaceW(
  LPCWSTR lpRootPathName,
  LPDWORD lpSectorsPerCluster,
  LPDWORD lpBytesPerSector,
  LPDWORD lpNumberOfFreeClusters,
  LPDWORD lpTotalNumberOfClusters
  );

BOOL
WINAPI
OGetDiskFreeSpaceExW(
  LPCTSTR lpDirectoryName,
  PULARGE_INTEGER lpFreeBytesAvailableToCaller,
  PULARGE_INTEGER lpTotalNumberOfBytes,
  PULARGE_INTEGER lpTotalNumberOfFreeBytes);


HENHMETAFILE  WINAPI OGetEnhMetaFileW(LPCWSTR);


UINT  WINAPI OGetEnhMetaFileDescriptionW(HENHMETAFILE, UINT, LPWSTR );


INT
APIENTRY
OGetExpandedNameW(
  LPWSTR,
  LPWSTR
  );


BOOL
WINAPI
OGetFileSecurityW (
  LPCWSTR lpFileName,
  SECURITY_INFORMATION RequestedInformation,
  PSECURITY_DESCRIPTOR pSecurityDescriptor,
  DWORD nLength,
  LPDWORD lpnLengthNeeded
  );


BOOL
WINAPI
OGetFormW(
  HANDLE  hPrinter,
  LPWSTR   pFormName,
  DWORD   Level,
  LPBYTE  pForm,
  DWORD   cbBuf,
  LPDWORD pcbNeeded
);


WINAPI OGetICMProfileW(HDC,LPDWORD,LPWSTR);


BOOL
WINAPI
OGetJobW(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
);


BOOL
WINAPI
OGetKeyboardLayoutNameW(
  LPWSTR pwszKLID);



WINAPI OGetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACEW,DWORD);


DWORD
WINAPI
OGetLogicalDriveStringsW(
  DWORD nBufferLength,
  LPWSTR lpBuffer
  );


BOOL
WINAPI
OGetMenuItemInfoW(
  HMENU,
  UINT,
  BOOL,
  LPMENUITEMINFOW
  );


HMETAFILE   WINAPI OGetMetaFileW(LPCWSTR);


INT
APIENTRY
OGetNameByTypeW (
  IN     LPGUID          lpServiceType,
  IN OUT LPWSTR         lpServiceName,
  IN     DWORD           dwNameLength
  );


BOOL
WINAPI
OGetNamedPipeHandleStateW(
  HANDLE hNamedPipe,
  LPDWORD lpState,
  LPDWORD lpCurInstances,
  LPDWORD lpMaxCollectionCount,
  LPDWORD lpCollectDataTimeout,
  LPWSTR lpUserName,
  DWORD nMaxUserNameSize
  );


BOOL
WINAPI
OGetPrinterW(
  HANDLE  hPrinter,
  DWORD   Level,
  LPBYTE  pPrinter,
  DWORD   cbBuf,
  LPDWORD pcbNeeded
);


DWORD
WINAPI
OGetPrinterDataW(
  HANDLE   hPrinter,
  LPWSTR    pValueName,
  LPDWORD  pType,
  LPBYTE   pData,
  DWORD    nSize,
  LPDWORD  pcbNeeded
);


BOOL
WINAPI
OGetPrinterDriverW(
  HANDLE  hPrinter,
  LPWSTR   pEnvironment,
  DWORD   Level,
  LPBYTE  pDriverInfo,
  DWORD   cbBuf,
  LPDWORD pcbNeeded
);


BOOL
WINAPI
OGetPrinterDriverDirectoryW(
  LPWSTR   pName,
  LPWSTR   pEnvironment,
  DWORD   Level,
  LPBYTE  pDriverDirectory,
  DWORD   cbBuf,
  LPDWORD pcbNeeded
);


BOOL
WINAPI
OGetPrintProcessorDirectoryW(
  LPWSTR   pName,
  LPWSTR   pEnvironment,
  DWORD   Level,
  LPBYTE  pPrintProcessorInfo,
  DWORD   cbBuf,
  LPDWORD pcbNeeded
);


DWORD
WINAPI
OGetPrivateProfileSectionW(
  LPCWSTR lpAppName,
  LPWSTR lpReturnedString,
  DWORD nSize,
  LPCWSTR lpFileName
  );


DWORD
WINAPI
OGetPrivateProfileSectionNamesW(
  LPWSTR lpszReturnBuffer,
  DWORD nSize,
  LPCWSTR lpFileName
  );


BOOL
WINAPI
OGetPrivateProfileStructW(
  LPCWSTR lpszSection,
  LPCWSTR lpszKey,
  LPVOID   lpStruct,
  UINT     uSizeStruct,
  LPCWSTR szFile
  );


DWORD
WINAPI
OGetProfileSectionW(
  LPCWSTR lpAppName,
  LPWSTR lpReturnedString,
  DWORD nSize
  );


DWORD
WINAPI
OGetProfileStringW(
  LPCWSTR lpAppName,
  LPCWSTR lpKeyName,
  LPCWSTR lpDefault,
  LPWSTR lpReturnedString,
  DWORD nSize
  );


INT
APIENTRY
OGetServiceW (
  IN     DWORD                dwNameSpace,
  IN     LPGUID               lpGuid,
  IN     LPWSTR              lpServiceName,
  IN     DWORD                dwProperties,
  IN OUT LPVOID               lpBuffer,
  IN OUT LPDWORD              lpdwBufferSize,
  IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo
  );

#if 0 //UNDONE_POST_98 - We should wrap these as being NT only...

BOOL
WINAPI
OGetServiceDisplayNameW(
  SC_HANDLE               hSCManager,
  LPCWSTR                lpServiceName,
  LPWSTR                 lpDisplayName,
  LPDWORD                 lpcchBuffer
  );


BOOL
WINAPI
OGetServiceKeyNameW(
  SC_HANDLE               hSCManager,
  LPCWSTR                lpDisplayName,
  LPWSTR                 lpServiceName,
  LPDWORD                 lpcchBuffer
  );
#endif


VOID
WINAPI
OGetStartupInfoW(
  LPSTARTUPINFOW lpStartupInfo
  );



UINT
WINAPI
OGetSystemDirectoryW(
  LPWSTR lpBuffer,
  UINT uSize
  );




INT
APIENTRY
OGetTypeByNameW (
  IN     LPWSTR         lpServiceName,
  IN OUT LPGUID          lpServiceType
  );



BOOL
WINAPI
OGetUserObjectInformationW(
  HANDLE hObj,
  int nIndex,
  PVOID pvInfo,
  DWORD nLength,
  LPDWORD lpnLengthNeeded);



UINT
WINAPI
OGetWindowsDirectoryW(
  LPWSTR lpBuffer,
  UINT uSize
  );




RPC_STATUS RPC_ENTRY
OI_RpcServerUnregisterEndpointW (
  IN unsigned short * Protseq,
  IN unsigned short * Endpoint
  );



   WINAPI OImmConfigureIMEW(HKL, HWND, DWORD, LPVOID);



WINAPI OImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID);



WINAPI OImmEscapeW(HKL, HIMC, UINT, LPVOID);



WINAPI OImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen);



WINAPI OImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount);



WINAPI OImmGetCompositionFontW(HIMC, LPLOGFONTW);



WINAPI OImmGetConversionListW(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag);



WINAPI OImmGetDescriptionW(HKL, LPWSTR, UINT uBufLen);



WINAPI OImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR, DWORD dwBufLen);



WINAPI OImmGetIMEFileNameW(HKL, LPWSTR, UINT uBufLen);



WINAPI OImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW);



 WINAPI OImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText);



WINAPI OImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM);



WINAPI OImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister);



WINAPI OImmSetCompositionFontW(HIMC, LPLOGFONTW);



 WINAPI OImmSetCompositionStringW(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD);



WINAPI OImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister);



BOOL
APIENTRY
OInitiateSystemShutdownW(
  LPWSTR lpMachineName,
  LPWSTR lpMessage,
  DWORD dwTimeout,
  BOOL bForceAppsClosed,
  BOOL bRebootAfterShutdown
  );



BOOL
WINAPI
OInsertMenuItemW(
  HMENU,
  UINT,
  BOOL,
  LPCMENUITEMINFOW
  );



BOOL
WINAPI
OIsCharLowerW(
  WCHAR ch);



BOOL
WINAPI
OIsCharUpperW(
  WCHAR ch);



MMRESULT WINAPI OjoyGetDevCapsW(UINT uJoyID, LPJOYCAPSW pjc, UINT cbjc);



HCURSOR
WINAPI
OLoadCursorFromFileW(
  LPCWSTR    lpFileName);



HKL
WINAPI
OLoadKeyboardLayoutW(
  LPCWSTR pwszKLID,
  UINT Flags);



BOOL
WINAPI
OLogonUserW (
  LPWSTR lpszUsername,
  LPWSTR lpszDomain,
  LPWSTR lpszPassword,
  DWORD dwLogonType,
  DWORD dwLogonProvider,
  PHANDLE phToken
  );



INT
APIENTRY
OLZOpenFileW(
  LPWSTR,
  LPOFSTRUCT,
  WORD
  );



UINT
WINAPI
OMapVirtualKeyExW(
  UINT uCode,
  UINT uMapType,
  HKL dwhkl);



MCIDEVICEID WINAPI OmciGetDeviceIDW(LPCWSTR pszDevice);



MCIDEVICEID WINAPI OmciGetDeviceIDFromElementIDW(DWORD dwElementID, LPCWSTR lpstrType );



BOOL WINAPI OmciGetErrorStringW(MCIERROR mcierr, LPWSTR pszText, UINT cchText);



MCIERROR WINAPI OmciSendCommandW(MCIDEVICEID mciId, UINT uMsg, DWORD dwParam1, DWORD dwParam2);



MCIERROR  WINAPI OmciSendStringW(LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);



VFWAPIV OMCIWndCreateW(HWND hwndParent, HINSTANCE hInstance,
        DWORD dwStyle,LPCWSTR szFile);



MMRESULT WINAPI OmidiInGetDevCapsW(UINT uDeviceID, LPMIDIINCAPSW pmic, UINT cbmic);



MMRESULT WINAPI OmidiInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);



MMRESULT WINAPI OmidiOutGetDevCapsW(UINT uDeviceID, LPMIDIOUTCAPSW pmoc, UINT cbmoc);



MMRESULT WINAPI OmidiOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);



HRESULT WINAPI OMIMEAssociationDialogW(HWND hwndParent,
                     DWORD dwInFlags,
                     PCWSTR pcszFile,
                     PCWSTR pcszMIMEContentType,
                     PWSTR pszAppBuf,
                     UINT ucAppBufLen);



MMRESULT WINAPI OmixerGetControlDetailsW(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);



MMRESULT WINAPI OmixerGetDevCapsW(UINT uMxId, LPMIXERCAPSW pmxcaps, UINT cbmxcaps);



MMRESULT WINAPI OmixerGetLineControlsW(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSW pmxlc, DWORD fdwControls);



MMRESULT WINAPI OmixerGetLineInfoW(HMIXEROBJ hmxobj, LPMIXERLINEW pmxl, DWORD fdwInfo);



LPMMIOPROC WINAPI OmmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);



HMMIO WINAPI OmmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);



MMRESULT WINAPI OmmioRenameW(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);



FOURCC WINAPI OmmioStringToFOURCCW(LPCWSTR sz, UINT uFlags);



DWORD APIENTRY
OMultinetGetConnectionPerformanceW(
    LPNETRESOURCEW lpNetResource,
    LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );



BOOL
WINAPI
OObjectCloseAuditAlarmW (
  LPCWSTR SubsystemName,
  LPVOID HandleId,
  BOOL GenerateOnClose
  );



BOOL
WINAPI
OObjectOpenAuditAlarmW (
  LPCWSTR SubsystemName,
  LPVOID HandleId,
  LPWSTR ObjectTypeName,
  LPWSTR ObjectName,
  PSECURITY_DESCRIPTOR pSecurityDescriptor,
  HANDLE ClientToken,
  DWORD DesiredAccess,
  DWORD GrantedAccess,
  PPRIVILEGE_SET Privileges,
  BOOL ObjectCreation,
  BOOL AccessGranted,
  LPBOOL GenerateOnClose
  );



BOOL
WINAPI
OObjectPrivilegeAuditAlarmW (
  LPCWSTR SubsystemName,
  LPVOID HandleId,
  HANDLE ClientToken,
  DWORD DesiredAccess,
  PPRIVILEGE_SET Privileges,
  BOOL AccessGranted
  );



BOOL
WINAPI
OOemToCharBuffW(
  LPCSTR lpszSrc,
  LPWSTR lpszDst,
  DWORD cchDstLength);



BOOL
WINAPI OOleUIAddVerbMenuW(LPOLEOBJECT lpOleObj, LPCWSTR lpszShortType,
    HMENU hMenu, UINT uPos, UINT uIDVerbMin, UINT uIDVerbMax,
    BOOL bAddConvert, UINT idConvert, HMENU FAR *lphMenu);



UINT
WINAPI OOleUIEditLinksW(LPOLEUIEDITLINKSW);



UINT
WINAPI OOleUIPasteSpecialW(LPOLEUIPASTESPECIALW);



FAR CDECL OOleUIPromptUserW(int nTemplate, HWND hwndParent, ...);



BOOL
WINAPI OOleUIUpdateLinksW(LPOLEUILINKCONTAINERW lpOleUILinkCntr,
    HWND hwndParent, LPWSTR lpszTitle, int cLinks);



HANDLE
WINAPI
OOpenBackupEventLogW (
  LPCWSTR lpUNCServerName,
  LPCWSTR lpFileName
  );



HDESK
WINAPI
OOpenDesktopW(
  LPWSTR lpszDesktop,
  DWORD dwFlags,
  BOOL fInherit,
  DWORD dwDesiredAccess);



HANDLE
WINAPI
OOpenEventW(
  DWORD dwDesiredAccess,
  BOOL bInheritHandle,
  LPCWSTR lpName
  );



HANDLE
WINAPI
OOpenEventLogW (
  LPCWSTR lpUNCServerName,
  LPCWSTR lpSourceName
  );



HANDLE
WINAPI
OOpenFileMappingW(
  DWORD dwDesiredAccess,
  BOOL bInheritHandle,
  LPCWSTR lpName
  );



HANDLE
WINAPI
OOpenMutexW(
  DWORD dwDesiredAccess,
  BOOL bInheritHandle,
  LPCWSTR lpName
  );


#if 0 //UNDONE_POST_98 - We should wrap these as being NT only...

SC_HANDLE
WINAPI
OOpenSCManagerW(
  LPCWSTR lpMachineName,
  LPCWSTR lpDatabaseName,
  DWORD   dwDesiredAccess
  );
#endif



HANDLE
WINAPI
OOpenSemaphoreW(
  DWORD dwDesiredAccess,
  BOOL bInheritHandle,
  LPCWSTR lpName
  );


#if 0 //UNDONE_POST_98 - We should wrap these as being NT only...

SC_HANDLE
WINAPI
OOpenServiceW(
  SC_HANDLE   hSCManager,
  LPCWSTR    lpServiceName,
  DWORD       dwDesiredAccess
  );
#endif



HWINSTA
WINAPI
OOpenWindowStationW(
  LPWSTR lpszWinSta,
  BOOL fInherit,
  DWORD dwDesiredAccess);



APIENTRY OPageSetupDlgW( LPPAGESETUPDLGW );



BOOL
WINAPI
OPeekConsoleInputW(
  HANDLE hConsoleInput,
  PINPUT_RECORD lpBuffer,
  DWORD nLength,
  LPDWORD lpNumberOfEventsRead
  );



BOOL  WINAPI OPolyTextOutW(HDC, CONST POLYTEXTW *, int);



DWORD
WINAPI
OPrinterMessageBoxW(
  HANDLE  hPrinter,
  DWORD   Error,
  HWND    hWnd,
  LPWSTR   pText,
  LPWSTR   pCaption,
  DWORD   dwType
);



BOOL
WINAPI
OPrivilegedServiceAuditAlarmW (
  LPCWSTR SubsystemName,
  LPCWSTR ServiceName,
  HANDLE ClientToken,
  PPRIVILEGE_SET Privileges,
  BOOL AccessGranted
  );



DWORD
WINAPI
OQueryDosDeviceW(
  LPCWSTR lpDeviceName,
  LPWSTR lpTargetPath,
  DWORD ucchMax
  );


#if 0 //UNDONE_POST_98 - We should wrap these as being NT only...

BOOL
WINAPI
OQueryServiceConfigW(
  SC_HANDLE               hService,
  LPQUERY_SERVICE_CONFIGW lpServiceConfig,
  DWORD                   cbBufSize,
  LPDWORD                 pcbBytesNeeded
  );



BOOL
WINAPI
OQueryServiceLockStatusW(
  SC_HANDLE                       hSCManager,
  LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
  DWORD                           cbBufSize,
  LPDWORD                         pcbBytesNeeded
  );
#endif



APIENTRY ORasDialW( LPRASDIALEXTENSIONS, LPWSTR, LPRASDIALPARAMSW, DWORD,
           LPVOID, LPHRASCONN );



BOOL
WINAPI
OReadConsoleW(
  HANDLE hConsoleInput,
  LPVOID lpBuffer,
  DWORD nNumberOfCharsToRead,
  LPDWORD lpNumberOfCharsRead,
  LPVOID lpReserved
  );



BOOL
WINAPI
OReadConsoleInputW(
  HANDLE hConsoleInput,
  PINPUT_RECORD lpBuffer,
  DWORD nLength,
  LPDWORD lpNumberOfEventsRead
  );



BOOL
WINAPI
OReadConsoleOutputW(
  HANDLE hConsoleOutput,
  PCHAR_INFO lpBuffer,
  COORD dwBufferSize,
  COORD dwBufferCoord,
  PSMALL_RECT lpReadRegion
  );



BOOL
WINAPI
OReadConsoleOutputCharacterW(
  HANDLE hConsoleOutput,
  LPWSTR lpCharacter,
  DWORD nLength,
  COORD dwReadCoord,
  LPDWORD lpNumberOfCharsRead
  );



BOOL
WINAPI
OReadEventLogW (
   HANDLE     hEventLog,
   DWORD      dwReadFlags,
   DWORD      dwRecordOffset,
   LPVOID     lpBuffer,
   DWORD      nNumberOfBytesToRead,
   DWORD      *pnBytesRead,
   DWORD      *pnMinNumberOfBytesNeeded
  );



LONG
APIENTRY
ORegConnectRegistryW (
  LPWSTR lpMachineName,
  HKEY hKey,
  PHKEY phkResult
  );



HANDLE
WINAPI
ORegisterEventSourceW (
  LPCWSTR lpUNCServerName,
  LPCWSTR lpSourceName
  );


#if 0 //UNDONE_POST_98 - We should wrap these as being NT only...

SERVICE_STATUS_HANDLE
WINAPI
ORegisterServiceCtrlHandlerW(
  LPCWSTR             lpServiceName,
  LPHANDLER_FUNCTION   lpHandlerProc
  );
#endif



LONG
APIENTRY
ORegLoadKeyW (
  HKEY    hKey,
  LPCWSTR  lpSubKey,
  LPCWSTR  lpFile
  );



LONG
APIENTRY
ORegQueryMultipleValuesW (
  HKEY hKey,
  PVALENTW val_list,
  DWORD num_vals,
  LPWSTR lpValueBuf,
  LPDWORD ldwTotsize
  );



LONG
APIENTRY
ORegReplaceKeyW (
  HKEY     hKey,
  LPCWSTR  lpSubKey,
  LPCWSTR  lpNewFile,
  LPCWSTR  lpOldFile
  );



LONG
APIENTRY
ORegRestoreKeyW (
  HKEY hKey,
  LPCWSTR lpFile,
  DWORD   dwFlags
  );



LONG
APIENTRY
ORegSaveKeyW (
  HKEY hKey,
  LPCWSTR lpFile,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes
  );



LONG
APIENTRY
ORegUnLoadKeyW (
  HKEY    hKey,
  LPCWSTR lpSubKey
  );



BOOL
WINAPI
ORemoveDirectoryW(
  LPCWSTR lpPathName
  );



BOOL WINAPI ORemoveFontResourceW(LPCWSTR);



 APIENTRY    OReplaceTextW(LPFINDREPLACEW);



BOOL
WINAPI
OReportEventW (
   HANDLE     hEventLog,
   WORD       wType,
   WORD       wCategory,
   DWORD      dwEventID,
   PSID       lpUserSid,
   WORD       wNumStrings,
   DWORD      dwDataSize,
   LPCWSTR   *lpStrings,
   LPVOID     lpRawData
  );



BOOL
WINAPI
OResetPrinterW(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSW pDefault
);



RPC_STATUS RPC_ENTRY
ORpcBindingFromStringBindingW (
  IN unsigned short __RPC_FAR * StringBinding,
  OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
  );



RPC_STATUS RPC_ENTRY
ORpcBindingInqAuthClientW (
  IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
  OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
  OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
  OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
  OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
  OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
  );



RPC_STATUS RPC_ENTRY
ORpcBindingToStringBindingW (
  IN RPC_BINDING_HANDLE Binding,
  OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding
  );



RPC_STATUS RPC_ENTRY
ORpcEpRegisterNoReplaceW (
  IN RPC_IF_HANDLE IfSpec,
  IN RPC_BINDING_VECTOR * BindingVector,
  IN UUID_VECTOR * UuidVector OPTIONAL,
  IN unsigned short  * Annotation
  );



RPC_STATUS RPC_ENTRY
ORpcMgmtEpEltInqNextW (
  IN RPC_EP_INQ_HANDLE InquiryContext,
  OUT RPC_IF_ID __RPC_FAR * IfId,
  OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
  OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
  OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
  );



RPC_STATUS RPC_ENTRY
ORpcMgmtInqServerPrincNameW (
  IN RPC_BINDING_HANDLE Binding,
  IN unsigned long AuthnSvc,
  OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName
  );



RPC_STATUS RPC_ENTRY
ORpcNetworkInqProtseqsW (
  OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
  );



RPC_STATUS RPC_ENTRY
ORpcNetworkIsProtseqValidW (
  IN unsigned short __RPC_FAR * Protseq
  );



RPC_STATUS RPC_ENTRY
ORpcNsBindingInqEntryNameW (
  IN RPC_BINDING_HANDLE Binding,
  IN unsigned long EntryNameSyntax,
  OUT unsigned short __RPC_FAR * __RPC_FAR * EntryName
  );



RPC_STATUS RPC_ENTRY
ORpcProtseqVectorFreeW (
  IN OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
  );



RPC_STATUS RPC_ENTRY
ORpcServerInqDefaultPrincNameW (
  IN unsigned long AuthnSvc,
  OUT unsigned short __RPC_FAR * __RPC_FAR * PrincName
  );



RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqW (
  IN unsigned short __RPC_FAR * Protseq,
  IN unsigned int MaxCalls,
  IN void __RPC_FAR * SecurityDescriptor OPTIONAL
  );



RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqEpW (
  IN unsigned short __RPC_FAR * Protseq,
  IN unsigned int MaxCalls,
  IN unsigned short __RPC_FAR * Endpoint,
  IN void __RPC_FAR * SecurityDescriptor OPTIONAL
  );



RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqIfW (
  IN unsigned short __RPC_FAR * Protseq,
  IN unsigned int MaxCalls,
  IN RPC_IF_HANDLE IfSpec,
  IN void __RPC_FAR * SecurityDescriptor OPTIONAL
  );



RPC_STATUS RPC_ENTRY
ORpcStringBindingComposeW (
  IN unsigned short __RPC_FAR * ObjUuid OPTIONAL,
  IN unsigned short __RPC_FAR * Protseq OPTIONAL,
  IN unsigned short __RPC_FAR * NetworkAddr OPTIONAL,
  IN unsigned short __RPC_FAR * Endpoint OPTIONAL,
  IN unsigned short __RPC_FAR * Options OPTIONAL,
  OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
  );



RPC_STATUS RPC_ENTRY
ORpcStringBindingParseW (
  IN unsigned short __RPC_FAR * StringBinding,
  OUT unsigned short __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
  OUT unsigned short __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
  OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
  OUT unsigned short __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
  OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
  );



RPC_STATUS RPC_ENTRY
ORpcStringFreeW (
  IN OUT unsigned short __RPC_FAR * __RPC_FAR * String
  );



BOOL
WINAPI
OScrollConsoleScreenBufferW(
  HANDLE hConsoleOutput,
  CONST SMALL_RECT *lpScrollRectangle,
  CONST SMALL_RECT *lpClipRectangle,
  COORD dwDestinationOrigin,
  CONST CHAR_INFO *lpFill
  );



DWORD
WINAPI
OSearchPathW(
  LPCWSTR lpPath,
  LPCWSTR lpFileName,
  LPCWSTR lpExtension,
  DWORD nBufferLength,
  LPWSTR lpBuffer,
  LPWSTR *lpFilePart
  );



BOOL
WINAPI
OSendMessageCallbackW(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam,
  SENDASYNCPROC lpResultCallBack,
  DWORD dwData);



LRESULT
WINAPI
OSendMessageTimeoutW(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam,
  UINT fuFlags,
  UINT uTimeout,
  LPDWORD lpdwResult);



BOOL
WINAPI
OSetComputerNameW (
  LPCWSTR lpComputerName
  );



BOOL
WINAPI
OSetConsoleTitleW(
  LPCWSTR lpConsoleTitle
  );



BOOL
WINAPI
OSetDefaultCommConfigW(
  LPCWSTR lpszName,
  LPCOMMCONFIG lpCC,
  DWORD dwSize
  );



BOOL
WINAPI
OSetFileSecurityW (
  LPCWSTR lpFileName,
  SECURITY_INFORMATION SecurityInformation,
  PSECURITY_DESCRIPTOR pSecurityDescriptor
  );



BOOL
WINAPI
OSetFormW(
  HANDLE  hPrinter,
  LPWSTR   pFormName,
  DWORD   Level,
  LPBYTE  pForm
);



WINAPI OSetICMProfileW(HDC,LPWSTR);



BOOL
WINAPI
OSetJobW(
  HANDLE  hPrinter,
  DWORD   JobId,
  DWORD   Level,
  LPBYTE  pJob,
  DWORD   Command
);



BOOL
WINAPI
OSetPrinterW(
  HANDLE  hPrinter,
  DWORD   Level,
  LPBYTE  pPrinter,
  DWORD   Command
);



DWORD
WINAPI
OSetPrinterDataW(
  HANDLE  hPrinter,
  LPWSTR   pValueName,
  DWORD   Type,
  LPBYTE  pData,
  DWORD   cbData
);



INT
APIENTRY
OSetServiceW (
  IN     DWORD                dwNameSpace,
  IN     DWORD                dwOperation,
  IN     DWORD                dwFlags,
  IN     LPSERVICE_INFOW      lpServiceInfo,
  IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo,
  IN OUT LPDWORD              lpdwStatusFlags
  );



BOOL
WINAPI
OSetUserObjectInformationW(
  HANDLE hObj,
  int nIndex,
  PVOID pvInfo,
  DWORD nLength);



BOOL
WINAPI
OSetVolumeLabelW(
  LPCWSTR lpRootPathName,
  LPCWSTR lpVolumeName
  );



HHOOK
WINAPI
OSetWindowsHookW(
  int nFilterType,
  HOOKPROC pfnFilterProc);



INT       APIENTRY OShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon);



HINSTANCE APIENTRY OShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);



int WINAPI OSHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp);



BOOL WINAPI OSHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName,
               BOOL FAR * pfMustCopy, UINT uFlags);



BOOL WINAPI OsndPlaySoundW(LPCWSTR pszSound, UINT fuSound);



DWORD
WINAPI
OStartDocPrinterW(
  HANDLE  hPrinter,
  DWORD   Level,
  LPBYTE  pDocInfo
);


#if 0 //UNDONE_POST_98 - We should wrap these as being NT only...

BOOL
WINAPI
OStartServiceW(
  SC_HANDLE            hService,
  DWORD                dwNumServiceArgs,
  LPCWSTR             *lpServiceArgVectors
  );



BOOL
WINAPI
OStartServiceCtrlDispatcherW(
  LPSERVICE_TABLE_ENTRYW    lpServiceStartTable
  );
#endif


// Commented since gdi32.dll on Win95 provides the wrapper for this function.
/*

BOOL  WINAPI OTextOutW(HDC, int, int, LPCWSTR, int);
*/



HRESULT WINAPI OTranslateURLW(PCWSTR pcszURL,
                     DWORD dwInFlags,
                     PWSTR *ppszTranslatedURL);



WINAPI OUpdateICMRegKeyW(DWORD, DWORD, LPWSTR, UINT);



HRESULT WINAPI OURLAssociationDialogW(HWND hwndParent,
                         DWORD dwInFlags,
                         PCWSTR pcszFile,
                         PCWSTR pcszURL,
                         PWSTR pszAppBuf,
                         UINT ucAppBufLen);



/* client/server */
RPC_STATUS RPC_ENTRY
OUuidFromStringW (
  IN unsigned short __RPC_FAR * StringUuid,
  OUT UUID __RPC_FAR * Uuid
  );



DWORD
APIENTRY
OVerFindFileW(
    DWORD uFlags,
    LPWSTR szFileName,
    LPWSTR szWinDir,
    LPWSTR szAppDir,
    LPWSTR szCurDir,
    PUINT lpuCurDirLen,
    LPWSTR szDestDir,
    PUINT lpuDestDirLen
    );



DWORD
APIENTRY
OVerInstallFileW(
    DWORD uFlags,
    LPWSTR szSrcFileName,
    LPWSTR szDestFileName,
    LPWSTR szSrcDir,
    LPWSTR szDestDir,
    LPWSTR szCurDir,
    LPWSTR szTmpFile,
    PUINT lpuTmpFileLen
    );



WINAPI OVkKeyScanExW(
  WCHAR  ch,
  HKL   dwhkl);



BOOL
WINAPI
OWaitNamedPipeW(
  LPCWSTR lpNamedPipeName,
  DWORD nTimeOut
  );



MMRESULT WINAPI OwaveInGetDevCapsW(UINT uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic);



MMRESULT WINAPI OwaveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);



MMRESULT WINAPI OwaveOutGetDevCapsW(UINT uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc);



MMRESULT WINAPI OwaveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);



BOOL  WINAPI OwglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);



BOOL  WINAPI OwglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
                       FLOAT, int, LPGLYPHMETRICSFLOAT);



void WINAPI OWinExecErrorW(HWND hwnd, int error, LPCWSTR lpstrFileName, LPCWSTR lpstrTitle);



DWORD APIENTRY
OWNetAddConnectionW(
   LPCWSTR   lpRemoteName,
   LPCWSTR   lpPassword,
   LPCWSTR   lpLocalName
  );



DWORD APIENTRY
OWNetAddConnection2W(
   LPNETRESOURCEW lpNetResource,
   LPCWSTR       lpPassword,
   LPCWSTR       lpUserName,
   DWORD          dwFlags
  );



DWORD APIENTRY
OWNetAddConnection3W(
   HWND           hwndOwner,
   LPNETRESOURCEW lpNetResource,
   LPCWSTR       lpPassword,
   LPCWSTR       lpUserName,
   DWORD          dwFlags
  );



DWORD APIENTRY
OWNetCancelConnectionW(
   LPCWSTR lpName,
   BOOL     fForce
  );



DWORD APIENTRY
OWNetCancelConnection2W(
   LPCWSTR lpName,
   DWORD    dwFlags,
   BOOL     fForce
  );



DWORD APIENTRY
OWNetConnectionDialog1W(
  LPCONNECTDLGSTRUCTW lpConnDlgStruct
  );



DWORD APIENTRY
OWNetDisconnectDialog1W(
  LPDISCDLGSTRUCTW lpConnDlgStruct
  );



DWORD APIENTRY
OWNetEnumResourceW(
   HANDLE  hEnum,
   LPDWORD lpcCount,
   LPVOID  lpBuffer,
   LPDWORD lpBufferSize
  );




DWORD APIENTRY
OWNetGetLastErrorW(
   LPDWORD    lpError,
   LPWSTR    lpErrorBuf,
   DWORD      nErrorBufSize,
   LPWSTR    lpNameBuf,
   DWORD      nNameBufSize
  );



DWORD APIENTRY
OWNetGetNetworkInformationW(
  LPCWSTR          lpProvider,
  LPNETINFOSTRUCT   lpNetInfoStruct
  );



DWORD APIENTRY
OWNetGetProviderNameW(
  DWORD   dwNetType,
  LPWSTR lpProviderName,
  LPDWORD lpBufferSize
  );



DWORD APIENTRY
OWNetGetUniversalNameW(
   LPCWSTR lpLocalPath,
   DWORD    dwInfoLevel,
   LPVOID   lpBuffer,
   LPDWORD  lpBufferSize
   );



DWORD APIENTRY
OWNetGetUserW(
   LPCWSTR  lpName,
   LPWSTR   lpUserName,
   LPDWORD   lpnLength
  );



DWORD APIENTRY
OWNetOpenEnumW(
   DWORD          dwScope,
   DWORD          dwType,
   DWORD          dwUsage,
   LPNETRESOURCEW lpNetResource,
   LPHANDLE       lphEnum
  );



DWORD APIENTRY
OWNetSetConnectionW(
  LPCWSTR    lpName,
  DWORD       dwProperties,
  LPVOID      pvValues
  );



DWORD APIENTRY
OWNetUseConnectionW(
  HWND            hwndOwner,
  LPNETRESOURCEW  lpNetResource,
  LPCWSTR        lpUserID,
  LPCWSTR        lpPassword,
  DWORD           dwFlags,
  LPWSTR         lpAccessName,
  LPDWORD         lpBufferSize,
  LPDWORD         lpResult
  );



BOOL
WINAPI
OWriteConsoleW(
  HANDLE hConsoleOutput,
  CONST VOID *lpBuffer,
  DWORD nNumberOfCharsToWrite,
  LPDWORD lpNumberOfCharsWritten,
  LPVOID lpReserved
  );



BOOL
WINAPI
OWriteConsoleInputW(
  HANDLE hConsoleInput,
  CONST INPUT_RECORD *lpBuffer,
  DWORD nLength,
  LPDWORD lpNumberOfEventsWritten
  );



BOOL
WINAPI
OWriteConsoleOutputW(
  HANDLE hConsoleOutput,
  CONST CHAR_INFO *lpBuffer,
  COORD dwBufferSize,
  COORD dwBufferCoord,
  PSMALL_RECT lpWriteRegion
  );



BOOL
WINAPI
OWriteConsoleOutputCharacterW(
  HANDLE hConsoleOutput,
  LPCWSTR lpCharacter,
  DWORD nLength,
  COORD dwWriteCoord,
  LPDWORD lpNumberOfCharsWritten
  );



BOOL
WINAPI
OWritePrivateProfileSectionW(
  LPCWSTR lpAppName,
  LPCWSTR lpString,
  LPCWSTR lpFileName
  );



BOOL
WINAPI
OWritePrivateProfileStructW(
  LPCWSTR lpszSection,
  LPCWSTR lpszKey,
  LPVOID   lpStruct,
  UINT     uSizeStruct,
  LPCWSTR szFile
  );



BOOL
WINAPI
OWriteProfileSectionW(
  LPCWSTR lpAppName,
  LPCWSTR lpString
  );



BOOL
WINAPI
OWriteProfileStringW(
  LPCWSTR lpAppName,
  LPCWSTR lpKeyName,
  LPCWSTR lpString
  );



DWORD
WINAPI
ODdeQueryStringW(
  DWORD idInst,
  HSZ hsz,
  LPWSTR psz,
  DWORD cchMax,
  int iCodePage);



int WINAPI
OGetClipboardFormatNameW(
  UINT format,
  LPWSTR lpszFormatName,
  int cchMaxCount);



int
WINAPI
OGetKeyNameTextW(
  LONG lParam,
  LPWSTR lpString,
  int nSize);



int
WINAPI
OGetMenuStringW(
  HMENU hMenu,
  UINT uIDItem,
  LPWSTR lpString,
  int nMaxCount,
  UINT uFlag);



//CONSIDER 5525 (daVinci97) - see comment at beginning of file
#endif    //ifdef _DEBUG

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\debugger\idl\obj\i386\dbgdlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( enc )
EXTERN_PROXY_FILE( msdbg )
EXTERN_PROXY_FILE( sh )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( enc ),
  REFERENCE_PROXY_FILE( msdbg ),
  REFERENCE_PROXY_FILE( sh ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\debugger\idl\obj\i386\enc.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:13:57 2002
 */
/* Compiler settings for enc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDebugENC,0xB104D8B7,0xAF19,0x11d2,0x92,0x2C,0x00,0xA0,0x24,0x48,0x79,0x9A);


MIDL_DEFINE_GUID(IID, IID_IDebugENCLineMap,0x8706233B,0xBD4C,0x11d2,0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A);


MIDL_DEFINE_GUID(IID, IID_IDebugENCInfo2,0x6B56106F,0xBD51,0x11d2,0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugENCInfo2,0x7B076AD1,0xBD51,0x11d2,0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A);


MIDL_DEFINE_GUID(IID, IID_IDebugENCRelinkInfo2,0xCBB63A8D,0xBD57,0x11d2,0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugENCRelinkInfo2,0xE51BE743,0xBD57,0x11d2,0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A);


MIDL_DEFINE_GUID(IID, IID_IDebugIDBInfo2,0x9B7DE9A9,0xBD59,0x11d2,0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugIDBInfo2,0xB34E469B,0xBD59,0x11d2,0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A);


MIDL_DEFINE_GUID(IID, IID_IDebugENCBuildInfo2,0xEA70281B,0xBD58,0x11d2,0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A);


MIDL_DEFINE_GUID(IID, IID_IDebugENCUpdateOnRelinkEvent2,0x0EBF1959,0xBD57,0x11d2,0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A);


MIDL_DEFINE_GUID(IID, IID_IDebugENCUpdateOnStaleCodeEvent2,0x2F01EB29,0xBD57,0x11d2,0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A);


MIDL_DEFINE_GUID(IID, IID_IDebugENCUpdate,0x978BAEE7,0xBD4C,0x11d2,0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A);


MIDL_DEFINE_GUID(IID, IID_IDebugENCSnapshot2,0xf6f94d0e,0x78c2,0x11d2,0x8f,0xfe,0x00,0xc0,0x4f,0xa3,0x83,0x14);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugENCSnapshots2,0xf6f94d1a,0x78c2,0x11d2,0x8f,0xfe,0x00,0xc0,0x4f,0xa3,0x83,0x14);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugErrorInfos2,0xf6f94d23,0x78c2,0x11d2,0x8f,0xfe,0x00,0xc0,0x4f,0xa3,0x83,0x14);


MIDL_DEFINE_GUID(IID, IID_IDebugComPlusSnapshot2,0xf6f94d20,0x78c2,0x11d2,0x8f,0xfe,0x00,0xc0,0x4f,0xa3,0x83,0x14);


MIDL_DEFINE_GUID(IID, IID_IDebugNativeSnapshot2,0x461fda3e,0xbba5,0x11d2,0xb1,0x0f,0x00,0xc0,0x4f,0x72,0xdc,0x32);


MIDL_DEFINE_GUID(IID, IID_IDebugENCStackFrame2,0xB3C64D7F,0xDB9D,0x47c7,0xB4,0x79,0xC5,0x79,0xC7,0xF0,0x71,0x03);


MIDL_DEFINE_GUID(IID, IID_IDebugMetaDataEmit2,0xf6f94d21,0x78c2,0x11d2,0x8f,0xfe,0x00,0xc0,0x4f,0xa3,0x83,0x14);


MIDL_DEFINE_GUID(IID, IID_IDebugMetaDataDebugEmit2,0xf6f94d22,0x78c2,0x11d2,0x8f,0xfe,0x00,0xc0,0x4f,0xa3,0x83,0x14);


MIDL_DEFINE_GUID(IID, IID_IDebugENCStateEvents,0xec80d064,0x102e,0x435f,0xaa,0xfb,0xd3,0x7e,0x2a,0x4e,0xf6,0x54);


MIDL_DEFINE_GUID(IID, LIBID_EncLib,0x5C4922D9,0xAF1D,0x11d2,0x92,0x2C,0x00,0xA0,0x24,0x48,0x79,0x9A);


MIDL_DEFINE_GUID(CLSID, CLSID_EncMgr,0x99A426F1,0xAF1D,0x11d2,0x92,0x2C,0x00,0xA0,0x24,0x48,0x79,0x9A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\debugger\inc\toolhrt.h ===
/*++

Copyright(c) !YEAR Microsoft Corporation

Module Name:

	ToolHrt.h

Abstract:

	Useful stuff for listing processes, getting info from a PE image, etc.

Author:

    Matthew D Hendel (math) 03-Oct-1997

Environment:

	Win95, Win98, NT 4.0, NT 5.0.

--*/


#ifndef _TOOLHRT_H_
#define _TOOLHRT_H_

#ifdef __cplusplus
extern "C" {
#endif


#ifndef LOCAL
#define LOCAL static
#endif


enum IMAGE_TYPE {
	IMAGE_TYPE_UNKNOWN,
	IMAGE_TYPE_DOS_STUB,
	IMAGE_TYPE_WIN16_OR_OS2,
	IMAGE_TYPE_WIN32,
	IMAGE_TYPE_CRASHDUMP,
	IMAGE_TYPE_MINIDUMP,
	IMAGE_TYPE_WIN64
};

#include "pshpack4.h"

typedef struct _IMAGE_INFO {

	DWORD	Size;			// Must be initialized prior to the call
	DWORD	ImageType;

	union {
		struct {
			ULONG	Subsystem;
			WORD	Characteristics;
			WORD	Machine;
			BOOL	ManagedCode;
			BOOL	ManagedOnly;
		} Win32;

		struct {
			BOOL	fUserMode;
			WORD	Machine;
		} CrashDump;
	} u;

} IMAGE_INFO;

#include "poppack.h"


//
// Get information about a binary executable file.
//

BOOL
WINAPI
GetImageInfo(
	LPCSTR		ImageName,
	IMAGE_INFO*	ImageInfo
	);

//
// Is this image a valid Win32 subsystem image
//

#define IS_WIN32_SUBSYSTEM_IMAGE(ii)	\
	((ii).ImageType == IMAGE_TYPE_WIN32 &&	\
	((ii).u.Win32.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI ||	\
	 (ii).u.Win32.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI))


#define WINDOW_TITLE_SIZE		64
#define PROCESS_NAME_SIZE		_MAX_FNAME

#define TASK_SYSTEM_PROCESS		0x0001
#define TASK_BEING_DEBUGGED		0x0002
#define TASK_16_BIT				0x0004
#define TASK_64_BIT				0x0008

#include "pshpack4.h"

typedef struct _TASK_ENTRY {
	//
	// Basic Info
    DWORD	dwProcessId;
	DWORD	dwFlags;

	// 
	// Extended Info
	//
	struct {
		DWORD   dwSessionId;
        DWORD	dwParentPid;
    	DWORD	dwImageType;

	    union{
	        HWND	hWnd;
	        DWORDLONG AlignhWnd;
	    };
        CHAR	szProcessName [PROCESS_NAME_SIZE];
        CHAR	szWindowTitle [WINDOW_TITLE_SIZE];
    	CHAR	szImageName [_MAX_PATH];
	} exInfo;
} TASK_ENTRY, *PTASK_ENTRY;

#include "poppack.h"

//
// Get just the dwProcessId and dwFlags fields for all processes
//
#define TASKENTRY_PROCESSID		0x00000001
#define TASKENTRY_FLAGS			0x00000002
#define TASKENTRY_EXTENDEDINFO	0x00000004
//
// Get the complete _TASK_ENTRY fields for all proccess
//
#define TASKENTRY_ALL			0x00000007



//
// Get a task list.
//

BOOL
WINAPI
GetTaskList(
	OUT TASK_ENTRY rgTasks [],
	IN OUT DWORD* lpdwTaskCount,
	IN DWORD      dwFlags
    );

//
// Check whether a process is a system (server) process or not.
//

BOOL
WINAPI
IsSystemProcess(
	DWORD dwProcessId
	);

//
// On Windows NT, change the SE_DEBUG_PRIVILEGE value. On Win9x, NOP.
//

BOOL
WINAPI
SetDebugPrivilege(
	BOOL fEnable
	);

BOOL
WINAPI
IsDebuggerPresentEx(
	DWORD dwPid
	);



HANDLE
OpenProcessEx(
	DWORD   dwDesiredAccess,
	BOOL    bInheritHandle,
	DWORD   dwProcessId,
	LPBOOL  lpfResetDebugPriv
	);

//
//	For dynimcally loading psapi.dll -- WinNT only
//

typedef DWORD (WINAPI *GETMODULEFILENAMEEXA)(
	HANDLE hProcess,
	HMODULE hModule,
	LPSTR lpFilename,
	DWORD nSize
	);

BOOL
WINAPI
GetImageName(
	DWORD dwProcessId,
	LPTSTR szImageName,
	DWORD cbBufferSize
	);
    

BOOL
WINAPI
GetSessionIdForProcess(
	DWORD   processId,
	LPDWORD lpSessionId
	);

BOOL
WINAPI
GetImageNameUsingPsapiEx(
	HANDLE               hProcess,
	HMODULE              hDll,
	DWORD                dwProcessId,
    GETMODULEFILENAMEEXA pfnGetModuleFileNameExA,
	LPTSTR               szImageName,
	DWORD                cbBufferSize
	);

BOOL
IsWin9x(
  );

BOOL
IsNT4(
 );

BOOL
WINAPI
IsProcess64Bit(
	DWORD dwProcessId
	);

BOOL
InitDbgProxy(
		);
VOID
UnInitDbgProxy(
    );

BOOL
ReconcileWithProxy(
    DWORD       dwCount,
	PTASK_ENTRY rgTasks,
	DWORD       dwFlags
	);

BOOL
ProxyIsDetachedPid(
	DWORD   dwPid,
	LPDWORD lpfIsDetached
	);

HANDLE
LoadUsrProfile(
	HANDLE hToken
	);

BOOL
UnLoadUsrProfile(
	HANDLE hToken,
	HANDLE hProfile
	);

BOOL
GetEnvironmentBlock(
	HANDLE  hToken,
	LPVOID* ppEnvBlock
	);
BOOL
ReleaseEnvironmentBlock(
	LPVOID pEnvBlock
	);



DECLARE_HANDLE(HJIT);

HJIT
NotifyOleRpcStepInitiate(
	);

BOOL
NotifyOleRpcStepComplete(
	HJIT hJit
	);

BOOL
GetPidForOleRpcJit(
	LPDWORD lpdwPid
	);

#ifdef __cplusplus
};		// extern "C"
#endif

#endif // _TOOLHRT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\debugger\idl\obj\i386\sh.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:01 2002
 */
/* Compiler settings for sh.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDebugSymbolProvider,0xc2e34eae,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IDebugComPlusSymbolProvider,0xc2e34eaf,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IDebugNativeSymbolProvider,0xc2e34eb0,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IDebugField,0xc2e34eb1,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IDebugContainerField,0xc2e34eb2,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IDebugMethodField,0xc2e34eb4,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IDebugClassField,0xc2e34eb5,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IDebugPropertyField,0xc2e34eb6,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IDebugArrayField,0xc2e34eb7,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IDebugPointerField,0xc2e34eb8,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IDebugEnumField,0xc2e34eb9,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IDebugBitField,0xc2e34eba,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IDebugDynamicField,0xB5A2A5EA,0xD5AB,0x11d2,0x90,0x33,0x00,0xC0,0x4F,0xA3,0x02,0xA1);


MIDL_DEFINE_GUID(IID, IID_IDebugDynamicFieldCOMPlus,0xB5B20820,0xE233,0x11d2,0x90,0x37,0x00,0xC0,0x4F,0xA3,0x02,0xA1);


MIDL_DEFINE_GUID(IID, IID_IDebugEngineSymbolProviderServices,0x83919262,0xACD6,0x11d2,0x90,0x28,0x00,0xC0,0x4F,0xA3,0x02,0xA1);


MIDL_DEFINE_GUID(IID, IID_IDebugAddress,0xc2e34ebb,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugFields,0xc2e34ebc,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugAddresses,0xc2e34ebd,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(IID, IID_IDebugCustomAttributeQuery,0xDFD37B5A,0x1E3A,0x4f15,0x80,0x98,0x22,0x0A,0xBA,0xDC,0x62,0x0B);


MIDL_DEFINE_GUID(IID, LIBID_SHLib,0xc2e34ebe,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);


MIDL_DEFINE_GUID(CLSID, CLSID_SHManaged,0xc2e34ebf,0x8b9d,0x11d2,0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\debugger\idl\obj\i386\msdbg.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:13:59 2002
 */
/* Compiler settings for msdbg.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDebugMachine2,0x17bf8fa3,0x4c5a,0x49a3,0xb2,0xf8,0x59,0x42,0xe1,0xea,0x28,0x7e);


MIDL_DEFINE_GUID(IID, IID_IDebugMachineEx2,0xae27b230,0xa0bf,0x47ff,0xa2,0xd1,0x22,0xc2,0x9a,0x17,0x8e,0xac);


MIDL_DEFINE_GUID(IID, IID_IDebugPortSupplier2,0x53f68191,0x7b2f,0x4f14,0x8e,0x55,0x40,0xb1,0xb6,0xe5,0xdf,0x66);


MIDL_DEFINE_GUID(IID, IID_IDebugPort2,0x79293cc8,0xd9d9,0x43f5,0x97,0xad,0x0b,0xcc,0x5a,0x68,0x87,0x76);


MIDL_DEFINE_GUID(IID, IID_IDebugPortRequest2,0x8d36beb8,0x9bfe,0x47dd,0xa1,0x1b,0x7b,0xa1,0xde,0x18,0xe4,0x49);


MIDL_DEFINE_GUID(IID, IID_IDebugPortNotify2,0xfb8d2032,0x2858,0x414c,0x83,0xd9,0xf7,0x32,0x66,0x4e,0x0c,0x7a);


MIDL_DEFINE_GUID(IID, IID_IDebugPortEvents2,0x564fa275,0x12e1,0x4b5f,0x83,0x16,0x4d,0x79,0xbc,0xef,0x72,0x46);


MIDL_DEFINE_GUID(IID, IID_IDebugMDMUtil2,0xf3062547,0x43d8,0x4dc2,0xb1,0x8e,0xe1,0x46,0x0f,0xf2,0xc4,0x22);


MIDL_DEFINE_GUID(IID, IID_IDebugSession2,0x8948300f,0x8bd5,0x4728,0xa1,0xd8,0x83,0xd1,0x72,0x29,0x5a,0x9d);


MIDL_DEFINE_GUID(IID, IID_IDebugEngine2,0xba105b52,0x12f1,0x4038,0xae,0x64,0xd9,0x57,0x85,0x87,0x4c,0x47);


MIDL_DEFINE_GUID(IID, IID_IDebugEngineLaunch2,0xc7c1462f,0x9736,0x466c,0xb2,0xc1,0xb6,0xb2,0xde,0xdb,0xf4,0xa7);


MIDL_DEFINE_GUID(IID, IID_IDebugEventCallback2,0xade2eeb9,0xfc85,0x4f5b,0xb5,0xd9,0xd4,0x31,0xb4,0xaa,0xc3,0x1a);


MIDL_DEFINE_GUID(IID, IID_IDebugEvent2,0x423238d6,0xda42,0x4989,0x96,0xfb,0x6b,0xba,0x26,0xe7,0x2e,0x09);


MIDL_DEFINE_GUID(IID, IID_IDebugSessionCreateEvent2,0x2c2b15b7,0xfc6d,0x45b3,0x96,0x22,0x29,0x66,0x5d,0x96,0x4a,0x76);


MIDL_DEFINE_GUID(IID, IID_IDebugSessionDestroyEvent2,0xf199b2c2,0x88fe,0x4c5d,0xa0,0xfd,0xaa,0x04,0x6b,0x0d,0xc0,0xdc);


MIDL_DEFINE_GUID(IID, IID_IDebugEngineCreateEvent2,0xfe5b734c,0x759d,0x4e59,0xab,0x04,0xf1,0x03,0x34,0x3b,0xdd,0x06);


MIDL_DEFINE_GUID(IID, IID_IDebugProcessCreateEvent2,0xbac3780f,0x04da,0x4726,0x90,0x1c,0xba,0x6a,0x46,0x33,0xe1,0xca);


MIDL_DEFINE_GUID(IID, IID_IDebugProcessDestroyEvent2,0x3e2a0832,0x17e1,0x4886,0x8c,0x0e,0x20,0x4d,0xa2,0x42,0x99,0x5f);


MIDL_DEFINE_GUID(IID, IID_IDebugProgramCreateEvent2,0x96cd11ee,0xecd4,0x4e89,0x95,0x7e,0xb5,0xd4,0x96,0xfc,0x41,0x39);


MIDL_DEFINE_GUID(IID, IID_IDebugProgramDestroyEvent2,0xe147e9e3,0x6440,0x4073,0xa7,0xb7,0xa6,0x55,0x92,0xc7,0x14,0xb5);


MIDL_DEFINE_GUID(IID, IID_IDebugThreadCreateEvent2,0x2090ccfc,0x70c5,0x491d,0xa5,0xe8,0xba,0xd2,0xdd,0x9e,0xe3,0xea);


MIDL_DEFINE_GUID(IID, IID_IDebugThreadDestroyEvent2,0x2c3b7532,0xa36f,0x4a6e,0x90,0x72,0x49,0xbe,0x64,0x9b,0x85,0x41);


MIDL_DEFINE_GUID(IID, IID_IDebugLoadCompleteEvent2,0xb1844850,0x1349,0x45d4,0x9f,0x12,0x49,0x52,0x12,0xf5,0xeb,0x0b);


MIDL_DEFINE_GUID(IID, IID_IDebugEntryPointEvent2,0xe8414a3e,0x1642,0x48ec,0x82,0x9e,0x5f,0x40,0x40,0xe1,0x6d,0xa9);


MIDL_DEFINE_GUID(IID, IID_IDebugStepCompleteEvent2,0x0f7f24c1,0x74d9,0x4ea6,0xa3,0xea,0x7e,0xdb,0x2d,0x81,0x44,0x1d);


MIDL_DEFINE_GUID(IID, IID_IDebugCanStopEvent2,0xb5b0d747,0xd4d2,0x4e2d,0x87,0x2d,0x74,0xda,0x22,0x03,0x78,0x26);


MIDL_DEFINE_GUID(IID, IID_IDebugBreakEvent2,0xc7405d1d,0xe24b,0x44e0,0xb7,0x07,0xd8,0xa5,0xa4,0xe1,0x64,0x1b);


MIDL_DEFINE_GUID(IID, IID_IDebugBreakpointEvent2,0x501c1e21,0xc557,0x48b8,0xba,0x30,0xa1,0xea,0xb0,0xbc,0x4a,0x74);


MIDL_DEFINE_GUID(IID, IID_IDebugExceptionEvent2,0x51a94113,0x8788,0x4a54,0xae,0x15,0x08,0xb7,0x4f,0xf9,0x22,0xd0);


MIDL_DEFINE_GUID(IID, IID_IDebugOutputStringEvent2,0x569c4bb1,0x7b82,0x46fc,0xae,0x28,0x45,0x36,0xdd,0xad,0x75,0x3e);


MIDL_DEFINE_GUID(IID, IID_IDebugModuleLoadEvent2,0x989db083,0x0d7c,0x40d1,0xa9,0xd9,0x92,0x1b,0xf6,0x11,0xa4,0xb2);


MIDL_DEFINE_GUID(IID, IID_IDebugPropertyCreateEvent2,0xded6d613,0xa3db,0x4e35,0xbb,0x5b,0xa9,0x23,0x91,0x13,0x3f,0x03);


MIDL_DEFINE_GUID(IID, IID_IDebugPropertyDestroyEvent2,0xf3765f18,0xf395,0x4b8c,0x8e,0x95,0xdc,0xb3,0xfe,0x8e,0x7e,0xc8);


MIDL_DEFINE_GUID(IID, IID_IDebugBreakpointBoundEvent2,0x1dddb704,0xcf99,0x4b8a,0xb7,0x46,0xda,0xbb,0x01,0xdd,0x13,0xa0);


MIDL_DEFINE_GUID(IID, IID_IDebugBreakpointUnboundEvent2,0x78d1db4f,0xc557,0x4dc5,0xa2,0xdd,0x53,0x69,0xd2,0x1b,0x1c,0x8c);


MIDL_DEFINE_GUID(IID, IID_IDebugBreakpointErrorEvent2,0xabb0ca42,0xf82b,0x4622,0x84,0xe4,0x69,0x03,0xae,0x90,0xf2,0x10);


MIDL_DEFINE_GUID(IID, IID_IDebugExpressionEvaluationCompleteEvent2,0xc0e13a85,0x238a,0x4800,0x83,0x15,0xd9,0x47,0xc9,0x60,0xa8,0x43);


MIDL_DEFINE_GUID(IID, IID_IDebugReturnValueEvent2,0x0da4d4cc,0x2d0b,0x410f,0x8d,0x5d,0xb6,0xb7,0x3a,0x5d,0x35,0xd8);


MIDL_DEFINE_GUID(IID, IID_IDebugFindSymbolEvent2,0x4072ae37,0x3739,0x43c9,0xac,0x88,0xca,0x2e,0xa7,0x9e,0xd3,0x2b);


MIDL_DEFINE_GUID(IID, IID_IDebugNoSymbolsEvent2,0x3ad4fb48,0x647e,0x4b03,0x9c,0x1e,0x52,0x75,0x4e,0x80,0xc8,0x80);


MIDL_DEFINE_GUID(IID, IID_IDebugProgramNameChangedEvent2,0xe05c2dfd,0x59d5,0x46d3,0xa7,0x1c,0x5d,0x07,0x66,0x5d,0x85,0xaf);


MIDL_DEFINE_GUID(IID, IID_IDebugThreadNameChangedEvent2,0x1ef4ef78,0x2c44,0x4b7a,0x84,0x73,0x8f,0x43,0x57,0x61,0x17,0x29);


MIDL_DEFINE_GUID(IID, IID_IDebugMessageEvent2,0x3bdb28cf,0xdbd2,0x4d24,0xaf,0x03,0x01,0x07,0x2b,0x67,0xeb,0x9e);


MIDL_DEFINE_GUID(IID, IID_IDebugActivateDocumentEvent2,0x58f36c3d,0x7d07,0x4eba,0xa0,0x41,0x62,0xf6,0x3e,0x18,0x80,0x37);


MIDL_DEFINE_GUID(IID, IID_IDebugProcess2,0x43286fea,0x6997,0x4543,0x80,0x3e,0x60,0xa2,0x0c,0x47,0x3d,0xe5);


MIDL_DEFINE_GUID(IID, IID_IDebugProgram2,0x69d172ef,0xf2c4,0x44e1,0x89,0xf7,0xc8,0x62,0x31,0xe7,0x06,0xe9);


MIDL_DEFINE_GUID(IID, IID_IDebugEngineProgram2,0x7ce3e768,0x654d,0x4ba7,0x8d,0x95,0xcd,0xaa,0xc6,0x42,0xb1,0x41);


MIDL_DEFINE_GUID(IID, IID_IDebugProgramHost2,0xc99d588f,0x778c,0x44fe,0x8b,0x2e,0x40,0x12,0x4a,0x73,0x88,0x91);


MIDL_DEFINE_GUID(IID, IID_IDebugProgramNode2,0x426e255c,0xf1ce,0x4d02,0xa9,0x31,0xf9,0xa2,0x54,0xbf,0x7f,0x0f);


MIDL_DEFINE_GUID(IID, IID_IDebugProgramEngines2,0xfda24a6b,0xb142,0x447d,0xbb,0xbc,0x86,0x54,0xa3,0xd8,0x4f,0x80);


MIDL_DEFINE_GUID(IID, IID_IDebugThread2,0xd5168050,0xa57a,0x465c,0xbe,0xa9,0x97,0x4f,0x40,0x5e,0xba,0x13);


MIDL_DEFINE_GUID(IID, IID_IDebugLogicalThread2,0x88d2f75b,0xd329,0x4e03,0x9b,0x75,0x20,0x1f,0x77,0x82,0xd8,0xbd);


MIDL_DEFINE_GUID(IID, IID_IDebugProperty2,0xa7ee3e7e,0x2dd2,0x4ad7,0x96,0x97,0xf4,0xaa,0xe3,0x42,0x77,0x62);


MIDL_DEFINE_GUID(IID, IID_IDebugReference2,0x10b793ac,0x0c47,0x4679,0x84,0x54,0xad,0xb3,0x6f,0x29,0xf8,0x02);


MIDL_DEFINE_GUID(IID, IID_IDebugStackFrame2,0x1412926f,0x5dd6,0x4e58,0xb6,0x48,0xe1,0xc6,0x3e,0x01,0x3d,0x51);


MIDL_DEFINE_GUID(IID, IID_IDebugMemoryContext2,0x1ab276dd,0xf27b,0x4445,0x82,0x5d,0x5d,0xf0,0xb4,0xa0,0x4a,0x3a);


MIDL_DEFINE_GUID(IID, IID_IDebugCodeContext2,0xac17b76b,0x2b09,0x419a,0xad,0x5f,0x7d,0x74,0x02,0xda,0x88,0x75);


MIDL_DEFINE_GUID(IID, IID_IDebugMemoryBytes2,0x925837d1,0x3aa1,0x451a,0xb7,0xfe,0xcc,0x04,0xbb,0x42,0xcf,0xb8);


MIDL_DEFINE_GUID(IID, IID_IDebugDisassemblyStream2,0xe5b017fe,0xdfb0,0x411c,0x82,0x66,0x7c,0x64,0xd6,0xf5,0x19,0xf8);


MIDL_DEFINE_GUID(IID, IID_IDebugDocumentContext2,0x931516ad,0xb600,0x419c,0x88,0xfc,0xdc,0xf5,0x18,0x3b,0x5f,0xa9);


MIDL_DEFINE_GUID(IID, IID_IDebugExpressionContext2,0x37a44580,0xd5fc,0x473e,0xa0,0x48,0x21,0x70,0x2e,0xbf,0xc4,0x66);


MIDL_DEFINE_GUID(IID, IID_IDebugBreakpointRequest2,0x6015fd18,0x8257,0x4df3,0xac,0x42,0xf0,0x74,0xde,0xdd,0x4c,0xbd);


MIDL_DEFINE_GUID(IID, IID_IDebugBreakpointResolution2,0xb7e66f28,0x035a,0x401a,0xaf,0xc7,0x2e,0x30,0x0b,0xd2,0x97,0x11);


MIDL_DEFINE_GUID(IID, IID_IDebugErrorBreakpointResolution2,0x603aedf8,0x9575,0x4d30,0xb8,0xca,0x12,0x4d,0x1c,0x98,0xeb,0xd8);


MIDL_DEFINE_GUID(IID, IID_IDebugBoundBreakpoint2,0xd533d975,0x3f32,0x4876,0xab,0xd0,0x6d,0x37,0xfd,0xa5,0x63,0xe7);


MIDL_DEFINE_GUID(IID, IID_IDebugPendingBreakpoint2,0x6e215ef3,0xe44c,0x44d1,0xb7,0xba,0xb2,0x40,0x1f,0x7d,0xc2,0x3d);


MIDL_DEFINE_GUID(IID, IID_IDebugErrorBreakpoint2,0x74570ef7,0x2486,0x4089,0x80,0x0c,0x56,0xe3,0x82,0x9b,0x5c,0xa4);


MIDL_DEFINE_GUID(IID, IID_IDebugExpression2,0xf7473fd0,0x7f75,0x478d,0x8d,0x85,0xa4,0x85,0x20,0x4e,0x7a,0x2d);


MIDL_DEFINE_GUID(IID, IID_IDebugModule2,0x0fc1cd9a,0xb912,0x405c,0xa0,0x4c,0x43,0xce,0x02,0xcd,0x7d,0xf2);


MIDL_DEFINE_GUID(IID, IID_IDebugModuleManaged,0x232397F8,0xB232,0x479d,0xB1,0xBB,0x2F,0x04,0x4C,0x70,0xA0,0xF9);


MIDL_DEFINE_GUID(IID, IID_IDebugDocument2,0x1606dd73,0x5d5f,0x405c,0xb4,0xf4,0xce,0x32,0xba,0xba,0x25,0x01);


MIDL_DEFINE_GUID(IID, IID_IDebugDocumentText2,0x4b0645aa,0x08ef,0x4cb9,0xad,0xb9,0x03,0x95,0xd6,0xed,0xad,0x35);


MIDL_DEFINE_GUID(IID, IID_IDebugDocumentPosition2,0xbdde0eee,0x3b8d,0x4c82,0xb5,0x29,0x33,0xf1,0x6b,0x42,0x83,0x2e);


MIDL_DEFINE_GUID(IID, IID_IDebugDocumentPositionOffset2,0x037edd0f,0x8551,0x4f7f,0x8c,0xa0,0x04,0xd9,0xe2,0x9f,0x53,0x2d);


MIDL_DEFINE_GUID(IID, IID_IDebugFunctionPosition2,0x1ede3b4b,0x35e7,0x4b97,0x81,0x33,0x02,0x84,0x5d,0x60,0x01,0x74);


MIDL_DEFINE_GUID(IID, IID_IDebugDocumentTextEvents2,0x33ec72e3,0x002f,0x4966,0xb9,0x1c,0x5c,0xe2,0xf7,0xba,0x51,0x24);


MIDL_DEFINE_GUID(IID, IID_IDebugQueryEngine2,0xc989adc9,0xf305,0x4ef5,0x8c,0xa2,0x20,0x89,0x8e,0x8d,0x0e,0x28);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugProcesses2,0x96c74ef4,0x185d,0x4f9a,0x8a,0x43,0x4d,0x27,0x23,0x75,0x8e,0x0a);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugPrograms2,0x8d14bca6,0x34ce,0x4efe,0xac,0x7e,0x0a,0xbc,0x61,0xda,0xdb,0x20);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugThreads2,0x0d30dc12,0xc4f8,0x433d,0x9f,0xcc,0x9f,0xf1,0x17,0xe5,0xe5,0xf4);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugStackFrames2,0xcd39102b,0x4b69,0x4495,0x8f,0x29,0xe0,0xb2,0x5c,0x4a,0x88,0x55);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugCodeContexts2,0xad47a80b,0xeda7,0x459e,0xaf,0x82,0x64,0x7c,0xc9,0xfb,0xaa,0x50);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugBoundBreakpoints2,0x0f6b37e0,0xfcfe,0x44d9,0x91,0x12,0x39,0x4c,0xa9,0xb9,0x21,0x14);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugPendingBreakpoints2,0x70d2dc1e,0x4dcc,0x4786,0xa0,0x72,0x9a,0x3b,0x60,0x0c,0x21,0x6b);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugErrorBreakpoints2,0xe158f5aa,0x31fe,0x491b,0xa9,0xf6,0xcf,0xf9,0x34,0xb0,0x3a,0x01);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugMachines2,0x61d986ec,0x1eac,0x46b6,0x90,0xff,0x40,0x2a,0x00,0x8f,0x15,0xd1);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugExceptionInfo2,0x8e4bbd34,0xa2f4,0x41ef,0x87,0xb5,0xc5,0x63,0xb4,0xad,0x6e,0xe7);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugFrameInfo2,0x98bbba48,0x4c4d,0x4fff,0x83,0x40,0x60,0x97,0xbe,0xc9,0xc8,0x94);


MIDL_DEFINE_GUID(IID, IID_IEnumCodePaths2,0x9b13f80d,0xcfc6,0x4b78,0x81,0xef,0x1f,0x7c,0xc3,0x3f,0x76,0x39);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugModules2,0x4c4a2835,0x682e,0x4ce1,0xae,0xbc,0x1e,0x6b,0x3a,0x16,0x5b,0x44);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugPortSuppliers2,0x59c9dc99,0x3eff,0x4ff3,0xb2,0x01,0x98,0xac,0xd0,0x1b,0x0d,0x87);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugPorts2,0xbc827c5e,0x99ae,0x4ac8,0x83,0xad,0x2e,0xa5,0xc2,0x03,0x43,0x33);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugPropertyInfo2,0x6c7072c3,0x3ac4,0x408f,0xa6,0x80,0xfc,0x5a,0x2f,0x96,0x90,0x3e);


MIDL_DEFINE_GUID(IID, IID_IEnumDebugReferenceInfo2,0xe459dd12,0x864f,0x4aaa,0xab,0xc1,0xdc,0xec,0xbc,0x26,0x7f,0x04);


MIDL_DEFINE_GUID(IID, LIBID_AD2Lib,0xd191c0d7,0x4c8b,0x4a15,0xa7,0xb3,0x86,0x2d,0xcd,0x8d,0xae,0xfb);


MIDL_DEFINE_GUID(CLSID, CLSID_SDMServer,0x5eb7d9f7,0xaf21,0x400e,0xa2,0xc4,0x7f,0xd6,0x39,0x6f,0x86,0x41);


MIDL_DEFINE_GUID(CLSID, CLSID_MsMachineDebugManager,0x05e1b201,0x493d,0x4678,0xbb,0xcb,0x18,0xd9,0xca,0xf5,0xc0,0xa9);


MIDL_DEFINE_GUID(CLSID, CLSID_MDMUtilServer,0x89370a13,0x3977,0x4e7d,0xae,0xa0,0x0a,0x97,0x51,0xae,0x59,0x6b);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\debugger\idl\obj\i386\msdbg_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:13:59 2002
 */
/* Compiler settings for msdbg.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "msdbg.h"

#define TYPE_FORMAT_STRING_SIZE   5453                              
#define PROC_FORMAT_STRING_SIZE   9271                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   2            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugMachine2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugMachine2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugMachineEx2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugMachineEx2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugPortSupplier2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugPortSupplier2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugPort2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugPort2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugPortRequest2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugPortRequest2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugPortNotify2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugPortNotify2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugPortEvents2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugPortEvents2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugMDMUtil2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugMDMUtil2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugSession2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugSession2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugEngine2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugEngine2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugEngineLaunch2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugEngineLaunch2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugEventCallback2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugEventCallback2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugSessionCreateEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugSessionCreateEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugSessionDestroyEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugSessionDestroyEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugEngineCreateEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugEngineCreateEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugProcessCreateEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugProcessCreateEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugProcessDestroyEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugProcessDestroyEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugProgramCreateEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugProgramCreateEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugProgramDestroyEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugProgramDestroyEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugThreadCreateEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugThreadCreateEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugThreadDestroyEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugThreadDestroyEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugLoadCompleteEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugLoadCompleteEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugEntryPointEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugEntryPointEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugStepCompleteEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugStepCompleteEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugCanStopEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugCanStopEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugBreakEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugBreakEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugBreakpointEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugBreakpointEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugExceptionEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugExceptionEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugOutputStringEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugOutputStringEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugModuleLoadEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugModuleLoadEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugPropertyCreateEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugPropertyCreateEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugPropertyDestroyEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugPropertyDestroyEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugBreakpointBoundEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugBreakpointBoundEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugBreakpointUnboundEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugBreakpointUnboundEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugBreakpointErrorEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugBreakpointErrorEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugExpressionEvaluationCompleteEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugExpressionEvaluationCompleteEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugReturnValueEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugReturnValueEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugFindSymbolEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugFindSymbolEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugNoSymbolsEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugNoSymbolsEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugProgramNameChangedEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugProgramNameChangedEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugThreadNameChangedEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugThreadNameChangedEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugMessageEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugMessageEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugActivateDocumentEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugActivateDocumentEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugProcess2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugProcess2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugProgram2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugProgram2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugEngineProgram2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugEngineProgram2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugProgramHost2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugProgramHost2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugProgramNode2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugProgramNode2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugProgramEngines2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugProgramEngines2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugThread2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugThread2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugLogicalThread2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugLogicalThread2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugProperty2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugProperty2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugReference2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugReference2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugStackFrame2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugStackFrame2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugMemoryContext2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugMemoryContext2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugCodeContext2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugCodeContext2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugMemoryBytes2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugMemoryBytes2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugDisassemblyStream2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugDisassemblyStream2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugDocumentContext2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugDocumentContext2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugExpressionContext2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugExpressionContext2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugBreakpointRequest2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugBreakpointRequest2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugBreakpointResolution2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugBreakpointResolution2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugErrorBreakpointResolution2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugErrorBreakpointResolution2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugBoundBreakpoint2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugBoundBreakpoint2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugPendingBreakpoint2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugPendingBreakpoint2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugErrorBreakpoint2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugErrorBreakpoint2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugExpression2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugExpression2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugModule2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugModule2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugModuleManaged_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugModuleManaged_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugDocument2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugDocument2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugDocumentText2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugDocumentText2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugDocumentPosition2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugDocumentPosition2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugDocumentPositionOffset2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugDocumentPositionOffset2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugFunctionPosition2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugFunctionPosition2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugDocumentTextEvents2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugDocumentTextEvents2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugQueryEngine2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugQueryEngine2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugProcesses2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugProcesses2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugPrograms2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugPrograms2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugThreads2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugThreads2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugStackFrames2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugStackFrames2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugCodeContexts2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugCodeContexts2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugBoundBreakpoints2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugBoundBreakpoints2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugPendingBreakpoints2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugPendingBreakpoints2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugErrorBreakpoints2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugErrorBreakpoints2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugMachines2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugMachines2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugExceptionInfo2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugExceptionInfo2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugFrameInfo2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugFrameInfo2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumCodePaths2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumCodePaths2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugModules2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugModules2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugPortSuppliers2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugPortSuppliers2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugPorts2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugPorts2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugPropertyInfo2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugPropertyInfo2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugReferenceInfo2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugReferenceInfo2_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure GetInfo */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 10 */	NdrFcShort( 0x8 ),	/* 8 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter Fields */

/* 16 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pMachineInfo */

/* 22 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	NdrFcShort( 0x28 ),	/* Type Offset=40 */

	/* Return value */

/* 28 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 30 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 32 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetName */


	/* Procedure GetName */


	/* Procedure GetExceptionDescription */


	/* Procedure GetName */

/* 34 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 36 */	NdrFcLong( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x4 ),	/* 4 */
/* 42 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 44 */	NdrFcShort( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0x8 ),	/* 8 */
/* 48 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pbstrName */


	/* Parameter pbstrName */


	/* Parameter pbstrDescription */


	/* Parameter pbstrName */

/* 50 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 52 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 54 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */

/* 56 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 58 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 60 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPortSupplier */

/* 62 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 64 */	NdrFcLong( 0x0 ),	/* 0 */
/* 68 */	NdrFcShort( 0x5 ),	/* 5 */
/* 70 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 72 */	NdrFcShort( 0x44 ),	/* 68 */
/* 74 */	NdrFcShort( 0x8 ),	/* 8 */
/* 76 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter guidPortSupplier */

/* 78 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 80 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 82 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter ppPortSupplier */

/* 84 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 86 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 88 */	NdrFcShort( 0x52 ),	/* Type Offset=82 */

	/* Return value */

/* 90 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 92 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 94 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPort */

/* 96 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 98 */	NdrFcLong( 0x0 ),	/* 0 */
/* 102 */	NdrFcShort( 0x6 ),	/* 6 */
/* 104 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 106 */	NdrFcShort( 0x44 ),	/* 68 */
/* 108 */	NdrFcShort( 0x8 ),	/* 8 */
/* 110 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter guidPort */

/* 112 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 114 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 116 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter ppPort */

/* 118 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 120 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 122 */	NdrFcShort( 0x68 ),	/* Type Offset=104 */

	/* Return value */

/* 124 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 126 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 128 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumPorts */

/* 130 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 132 */	NdrFcLong( 0x0 ),	/* 0 */
/* 136 */	NdrFcShort( 0x7 ),	/* 7 */
/* 138 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 142 */	NdrFcShort( 0x8 ),	/* 8 */
/* 144 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 146 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 148 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 150 */	NdrFcShort( 0x7e ),	/* Type Offset=126 */

	/* Return value */

/* 152 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 154 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 156 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumPortSuppliers */

/* 158 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 160 */	NdrFcLong( 0x0 ),	/* 0 */
/* 164 */	NdrFcShort( 0x8 ),	/* 8 */
/* 166 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 168 */	NdrFcShort( 0x0 ),	/* 0 */
/* 170 */	NdrFcShort( 0x8 ),	/* 8 */
/* 172 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 174 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 176 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 178 */	NdrFcShort( 0x94 ),	/* Type Offset=148 */

	/* Return value */

/* 180 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 182 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMachineUtilities */

/* 186 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 188 */	NdrFcLong( 0x0 ),	/* 0 */
/* 192 */	NdrFcShort( 0x9 ),	/* 9 */
/* 194 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 198 */	NdrFcShort( 0x8 ),	/* 8 */
/* 200 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppUtil */

/* 202 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 204 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 206 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */

/* 208 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 210 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 212 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnableAutoAttachOnProgramCreate */

/* 214 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 216 */	NdrFcLong( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x3 ),	/* 3 */
/* 222 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 224 */	NdrFcShort( 0x44 ),	/* 68 */
/* 226 */	NdrFcShort( 0x24 ),	/* 36 */
/* 228 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter pszProcessNames */

/* 230 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 232 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 234 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Parameter guidEngine */

/* 236 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 238 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 240 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter pszSessionId */

/* 242 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 244 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 246 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Parameter pdwCookie */

/* 248 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 250 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 252 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 254 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 256 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 258 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure SetResponse */


	/* Procedure CanStop */


	/* Procedure DisableAutoAttachOnEvent */

/* 260 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 262 */	NdrFcLong( 0x0 ),	/* 0 */
/* 266 */	NdrFcShort( 0x4 ),	/* 4 */
/* 268 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 270 */	NdrFcShort( 0x8 ),	/* 8 */
/* 272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 274 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter celt */


	/* Parameter dwResponse */


	/* Parameter fCanStop */


	/* Parameter dwCookie */

/* 276 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 280 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */

/* 282 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 284 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 286 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPortSupplierEx */

/* 288 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 290 */	NdrFcLong( 0x0 ),	/* 0 */
/* 294 */	NdrFcShort( 0x5 ),	/* 5 */
/* 296 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 298 */	NdrFcShort( 0x44 ),	/* 68 */
/* 300 */	NdrFcShort( 0x8 ),	/* 8 */
/* 302 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter wstrRegistryRoot */

/* 304 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 306 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 308 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Parameter guidPortSupplier */

/* 310 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 312 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 314 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter ppPortSupplier */

/* 316 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 318 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 320 */	NdrFcShort( 0x52 ),	/* Type Offset=82 */

	/* Return value */

/* 322 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 324 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 326 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPortEx */

/* 328 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 330 */	NdrFcLong( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x6 ),	/* 6 */
/* 336 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 338 */	NdrFcShort( 0x44 ),	/* 68 */
/* 340 */	NdrFcShort( 0x8 ),	/* 8 */
/* 342 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter wstrRegistryRoot */

/* 344 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 346 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 348 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Parameter guidPort */

/* 350 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 352 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 354 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter ppPort */

/* 356 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 358 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 360 */	NdrFcShort( 0x68 ),	/* Type Offset=104 */

	/* Return value */

/* 362 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 364 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumPortsEx */

/* 368 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 370 */	NdrFcLong( 0x0 ),	/* 0 */
/* 374 */	NdrFcShort( 0x7 ),	/* 7 */
/* 376 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x8 ),	/* 8 */
/* 382 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter wstrRegistryRoot */

/* 384 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 386 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 388 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Parameter ppEnum */

/* 390 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 392 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 394 */	NdrFcShort( 0x7e ),	/* Type Offset=126 */

	/* Return value */

/* 396 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 398 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 400 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumPortSuppliersEx */

/* 402 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 404 */	NdrFcLong( 0x0 ),	/* 0 */
/* 408 */	NdrFcShort( 0x8 ),	/* 8 */
/* 410 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x8 ),	/* 8 */
/* 416 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter wstrRegistryRoot */

/* 418 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 420 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 422 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Parameter ppEnum */

/* 424 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 426 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 428 */	NdrFcShort( 0x94 ),	/* Type Offset=148 */

	/* Return value */

/* 430 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 432 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 434 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFunctionName */


	/* Procedure GetFileName */


	/* Procedure GetName */


	/* Procedure GetName */


	/* Procedure GetProgramName */


	/* Procedure GetString */


	/* Procedure GetName */


	/* Procedure GetPortName */


	/* Procedure GetPortName */


	/* Procedure GetPortSupplierName */

/* 436 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 438 */	NdrFcLong( 0x0 ),	/* 0 */
/* 442 */	NdrFcShort( 0x3 ),	/* 3 */
/* 444 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 446 */	NdrFcShort( 0x0 ),	/* 0 */
/* 448 */	NdrFcShort( 0x8 ),	/* 8 */
/* 450 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pbstrFunctionName */


	/* Parameter pbstrFileName */


	/* Parameter pbstrName */


	/* Parameter pbstrName */


	/* Parameter pbstrProgramName */


	/* Parameter pbstrString */


	/* Parameter pbstrName */


	/* Parameter pbstrPortName */


	/* Parameter pbstrName */


	/* Parameter pbstrName */

/* 452 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 454 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 456 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */

/* 458 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 460 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 462 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDocumentClassId */


	/* Procedure GetPortId */


	/* Procedure GetPortSupplierId */

/* 464 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 466 */	NdrFcLong( 0x0 ),	/* 0 */
/* 470 */	NdrFcShort( 0x4 ),	/* 4 */
/* 472 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 476 */	NdrFcShort( 0x4c ),	/* 76 */
/* 478 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pclsid */


	/* Parameter pguidPort */


	/* Parameter pguidPortSupplier */

/* 480 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 482 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 484 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */


	/* Return value */


	/* Return value */

/* 486 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 488 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPort */

/* 492 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 494 */	NdrFcLong( 0x0 ),	/* 0 */
/* 498 */	NdrFcShort( 0x5 ),	/* 5 */
/* 500 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 502 */	NdrFcShort( 0x44 ),	/* 68 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter guidPort */

/* 508 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 510 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 512 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter ppPort */

/* 514 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 516 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 518 */	NdrFcShort( 0x68 ),	/* Type Offset=104 */

	/* Return value */

/* 520 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 522 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 524 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumPorts */

/* 526 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 528 */	NdrFcLong( 0x0 ),	/* 0 */
/* 532 */	NdrFcShort( 0x6 ),	/* 6 */
/* 534 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 538 */	NdrFcShort( 0x8 ),	/* 8 */
/* 540 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 542 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 544 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 546 */	NdrFcShort( 0x7e ),	/* Type Offset=126 */

	/* Return value */

/* 548 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 550 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 552 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Terminate */


	/* Procedure CanAddPort */

/* 554 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 556 */	NdrFcLong( 0x0 ),	/* 0 */
/* 560 */	NdrFcShort( 0x7 ),	/* 7 */
/* 562 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 566 */	NdrFcShort( 0x8 ),	/* 8 */
/* 568 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */


	/* Return value */

/* 570 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 572 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 574 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddPort */

/* 576 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 578 */	NdrFcLong( 0x0 ),	/* 0 */
/* 582 */	NdrFcShort( 0x8 ),	/* 8 */
/* 584 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 588 */	NdrFcShort( 0x8 ),	/* 8 */
/* 590 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pRequest */

/* 592 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 594 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 596 */	NdrFcShort( 0xcc ),	/* Type Offset=204 */

	/* Parameter ppPort */

/* 598 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 600 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 602 */	NdrFcShort( 0x68 ),	/* Type Offset=104 */

	/* Return value */

/* 604 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 606 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 608 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemovePort */

/* 610 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 612 */	NdrFcLong( 0x0 ),	/* 0 */
/* 616 */	NdrFcShort( 0x9 ),	/* 9 */
/* 618 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x8 ),	/* 8 */
/* 624 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pPort */

/* 626 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 628 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 630 */	NdrFcShort( 0x6c ),	/* Type Offset=108 */

	/* Return value */

/* 632 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 634 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 636 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPortRequest */

/* 638 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 640 */	NdrFcLong( 0x0 ),	/* 0 */
/* 644 */	NdrFcShort( 0x5 ),	/* 5 */
/* 646 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 650 */	NdrFcShort( 0x8 ),	/* 8 */
/* 652 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppRequest */

/* 654 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 656 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 658 */	NdrFcShort( 0xde ),	/* Type Offset=222 */

	/* Return value */

/* 660 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 662 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 664 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPortSupplier */

/* 666 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 668 */	NdrFcLong( 0x0 ),	/* 0 */
/* 672 */	NdrFcShort( 0x6 ),	/* 6 */
/* 674 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 676 */	NdrFcShort( 0x0 ),	/* 0 */
/* 678 */	NdrFcShort( 0x8 ),	/* 8 */
/* 680 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppSupplier */

/* 682 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 684 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 686 */	NdrFcShort( 0x52 ),	/* Type Offset=82 */

	/* Return value */

/* 688 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 690 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 692 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProcess */

/* 694 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 696 */	NdrFcLong( 0x0 ),	/* 0 */
/* 700 */	NdrFcShort( 0x7 ),	/* 7 */
/* 702 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 704 */	NdrFcShort( 0x0 ),	/* 0 */
/* 706 */	NdrFcShort( 0x8 ),	/* 8 */
/* 708 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter ProcessId */

/* 710 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 712 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 714 */	NdrFcShort( 0xe2 ),	/* Type Offset=226 */

	/* Parameter ppProcess */

/* 716 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 718 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 720 */	NdrFcShort( 0xf6 ),	/* Type Offset=246 */

	/* Return value */

/* 722 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 724 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 726 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumProcesses */

/* 728 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 730 */	NdrFcLong( 0x0 ),	/* 0 */
/* 734 */	NdrFcShort( 0x8 ),	/* 8 */
/* 736 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 738 */	NdrFcShort( 0x0 ),	/* 0 */
/* 740 */	NdrFcShort( 0x8 ),	/* 8 */
/* 742 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 744 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 746 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 748 */	NdrFcShort( 0x10c ),	/* Type Offset=268 */

	/* Return value */

/* 750 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 752 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 754 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddProgramNode */

/* 756 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 758 */	NdrFcLong( 0x0 ),	/* 0 */
/* 762 */	NdrFcShort( 0x3 ),	/* 3 */
/* 764 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 766 */	NdrFcShort( 0x0 ),	/* 0 */
/* 768 */	NdrFcShort( 0x8 ),	/* 8 */
/* 770 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pProgramNode */

/* 772 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 774 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 776 */	NdrFcShort( 0x122 ),	/* Type Offset=290 */

	/* Return value */

/* 778 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 780 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 782 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoveProgramNode */

/* 784 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 786 */	NdrFcLong( 0x0 ),	/* 0 */
/* 790 */	NdrFcShort( 0x4 ),	/* 4 */
/* 792 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 796 */	NdrFcShort( 0x8 ),	/* 8 */
/* 798 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pProgramNode */

/* 800 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 802 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 804 */	NdrFcShort( 0x122 ),	/* Type Offset=290 */

	/* Return value */

/* 806 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 808 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 810 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Event */

/* 812 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 814 */	NdrFcLong( 0x0 ),	/* 0 */
/* 818 */	NdrFcShort( 0x3 ),	/* 3 */
/* 820 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 822 */	NdrFcShort( 0x44 ),	/* 68 */
/* 824 */	NdrFcShort( 0x8 ),	/* 8 */
/* 826 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter pMachine */

/* 828 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 830 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 832 */	NdrFcShort( 0x134 ),	/* Type Offset=308 */

	/* Parameter pPort */

/* 834 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 836 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 838 */	NdrFcShort( 0x146 ),	/* Type Offset=326 */

	/* Parameter pProcess */

/* 840 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 842 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 844 */	NdrFcShort( 0x158 ),	/* Type Offset=344 */

	/* Parameter pProgram */

/* 846 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 848 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 850 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter pEvent */

/* 852 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 854 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 856 */	NdrFcShort( 0x17c ),	/* Type Offset=380 */

	/* Parameter riidEvent */

/* 858 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 860 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 862 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 864 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 866 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 868 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddPIDToIgnore */

/* 870 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 872 */	NdrFcLong( 0x0 ),	/* 0 */
/* 876 */	NdrFcShort( 0x3 ),	/* 3 */
/* 878 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 880 */	NdrFcShort( 0x4c ),	/* 76 */
/* 882 */	NdrFcShort( 0x8 ),	/* 8 */
/* 884 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter guidEngine */

/* 886 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 888 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 890 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter dwPid */

/* 892 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 894 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 896 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 898 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 900 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 902 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemovePIDToIgnore */

/* 904 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 906 */	NdrFcLong( 0x0 ),	/* 0 */
/* 910 */	NdrFcShort( 0x4 ),	/* 4 */
/* 912 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 914 */	NdrFcShort( 0x4c ),	/* 76 */
/* 916 */	NdrFcShort( 0x8 ),	/* 8 */
/* 918 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter guidEngine */

/* 920 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 922 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 924 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter dwPid */

/* 926 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 928 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 930 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 932 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 934 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 936 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddPIDToDebug */

/* 938 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 940 */	NdrFcLong( 0x0 ),	/* 0 */
/* 944 */	NdrFcShort( 0x5 ),	/* 5 */
/* 946 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 948 */	NdrFcShort( 0x4c ),	/* 76 */
/* 950 */	NdrFcShort( 0x8 ),	/* 8 */
/* 952 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter guidEngine */

/* 954 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 956 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 958 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter dwPid */

/* 960 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 962 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 964 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 966 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 968 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 970 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemovePIDToDebug */

/* 972 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 974 */	NdrFcLong( 0x0 ),	/* 0 */
/* 978 */	NdrFcShort( 0x6 ),	/* 6 */
/* 980 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 982 */	NdrFcShort( 0x4c ),	/* 76 */
/* 984 */	NdrFcShort( 0x8 ),	/* 8 */
/* 986 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter guidEngine */

/* 988 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 990 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 992 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter dwPid */

/* 994 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 996 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 998 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1000 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1002 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1004 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetDynamicDebuggingFlags */

/* 1006 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1008 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1012 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1014 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1016 */	NdrFcShort( 0x4c ),	/* 76 */
/* 1018 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1020 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter guidEngine */

/* 1022 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1024 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1026 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter dwFlags */

/* 1028 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1030 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1032 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1034 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1036 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1038 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDynamicDebuggingFlags */

/* 1040 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1042 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1046 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1048 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1050 */	NdrFcShort( 0x44 ),	/* 68 */
/* 1052 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1054 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter guidEngine */

/* 1056 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1058 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1060 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter pdwFlags */

/* 1062 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1064 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1066 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1068 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1070 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1072 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetDefaultJITServer */

/* 1074 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1076 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1080 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1082 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1084 */	NdrFcShort( 0x44 ),	/* 68 */
/* 1086 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1088 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter clsidJITServer */

/* 1090 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1092 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1094 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 1096 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1098 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1100 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProgramId */


	/* Procedure GetDefaultJITServer */

/* 1102 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1104 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1108 */	NdrFcShort( 0xa ),	/* 10 */
/* 1110 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1112 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1114 */	NdrFcShort( 0x4c ),	/* 76 */
/* 1116 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pguidProgramId */


	/* Parameter pClsidJITServer */

/* 1118 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 1120 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1122 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */


	/* Return value */

/* 1124 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1126 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1128 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RegisterJITDebugEngines */

/* 1130 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 1132 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1136 */	NdrFcShort( 0xb ),	/* 11 */
/* 1138 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1140 */	NdrFcShort( 0x54 ),	/* 84 */
/* 1142 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1144 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter clsidJITServer */

/* 1146 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1148 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1150 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter arrguidEngines */

/* 1152 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1154 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1156 */	NdrFcShort( 0x192 ),	/* Type Offset=402 */

	/* Parameter arrRemoteFlags */

/* 1158 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1160 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1162 */	NdrFcShort( 0x1a0 ),	/* Type Offset=416 */

	/* Parameter celtEngs */

/* 1164 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1166 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1168 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter fRegister */

/* 1170 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1172 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1174 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1176 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1178 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1180 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CanDebugPID */

/* 1182 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1184 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0xc ),	/* 12 */
/* 1190 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1192 */	NdrFcShort( 0x4c ),	/* 76 */
/* 1194 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1196 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter guidEngine */

/* 1198 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1200 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1202 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter pid */

/* 1204 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1206 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1208 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1210 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1212 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetName */

/* 1216 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1218 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1222 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1224 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1228 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1230 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pszName */

/* 1232 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1234 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1236 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Return value */

/* 1238 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1240 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1242 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumProcesses */

/* 1244 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1246 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1250 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1252 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1254 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1256 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1258 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 1260 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1262 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1264 */	NdrFcShort( 0x10c ),	/* Type Offset=268 */

	/* Return value */

/* 1266 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1268 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1270 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Launch */

/* 1272 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 1274 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1278 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1280 */	NdrFcShort( 0x48 ),	/* x86 Stack size/offset = 72 */
/* 1282 */	NdrFcShort( 0x6c ),	/* 108 */
/* 1284 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1286 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x11,		/* 17 */

	/* Parameter pszMachine */

/* 1288 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1290 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1292 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter pPort */

/* 1294 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1296 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1298 */	NdrFcShort( 0x146 ),	/* Type Offset=326 */

	/* Parameter pszExe */

/* 1300 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1302 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1304 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter pszArgs */

/* 1306 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1308 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1310 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter pszDir */

/* 1312 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1314 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1316 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter bstrEnv */

/* 1318 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 1320 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1322 */	NdrFcShort( 0x1b6 ),	/* Type Offset=438 */

	/* Parameter pszOptions */

/* 1324 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1326 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1328 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter dwLaunchFlags */

/* 1330 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1332 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1334 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter hStdInput */

/* 1336 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1338 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 1340 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter hStdOutput */

/* 1342 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1344 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 1346 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter hStdError */

/* 1348 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1350 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 1352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidLaunchingEngine */

/* 1354 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1356 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 1358 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter pCallback */

/* 1360 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1362 */	NdrFcShort( 0x34 ),	/* x86 Stack size/offset = 52 */
/* 1364 */	NdrFcShort( 0x1c0 ),	/* Type Offset=448 */

	/* Parameter rgguidSpecificEngines */

/* 1366 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1368 */	NdrFcShort( 0x38 ),	/* x86 Stack size/offset = 56 */
/* 1370 */	NdrFcShort( 0x1d6 ),	/* Type Offset=470 */

	/* Parameter celtSpecificEngines */

/* 1372 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1374 */	NdrFcShort( 0x3c ),	/* x86 Stack size/offset = 60 */
/* 1376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppProcess */

/* 1378 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1380 */	NdrFcShort( 0x40 ),	/* x86 Stack size/offset = 64 */
/* 1382 */	NdrFcShort( 0x1e4 ),	/* Type Offset=484 */

	/* Return value */

/* 1384 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1386 */	NdrFcShort( 0x44 ),	/* x86 Stack size/offset = 68 */
/* 1388 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RegisterJITServer */

/* 1390 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1392 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1396 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1398 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1400 */	NdrFcShort( 0x44 ),	/* 68 */
/* 1402 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1404 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter clsidJITServer */

/* 1406 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1408 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1410 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 1412 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1414 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1416 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure onUpdateDocumentAttributes */


	/* Procedure Enable */


	/* Procedure SetHitCount */


	/* Procedure Terminate */

/* 1418 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1420 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1424 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1426 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1428 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1430 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1432 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter textdocattr */


	/* Parameter fEnable */


	/* Parameter dwHitCount */


	/* Parameter fForce */

/* 1434 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1436 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1438 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */

/* 1440 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1442 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1444 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DetachDebugger */


	/* Procedure Detach */


	/* Procedure CanDetach */


	/* Procedure Detach */

/* 1446 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1448 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1452 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1454 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1458 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1460 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */

/* 1462 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1464 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1466 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Detach */


	/* Procedure CauseBreak */

/* 1468 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1470 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1474 */	NdrFcShort( 0xa ),	/* 10 */
/* 1476 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1478 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1480 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1482 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */


	/* Return value */

/* 1484 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1486 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1488 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreatePendingBreakpoint */

/* 1490 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1492 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1496 */	NdrFcShort( 0xb ),	/* 11 */
/* 1498 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1500 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1502 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1504 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pBPRequest */

/* 1506 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1508 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1510 */	NdrFcShort( 0x1e8 ),	/* Type Offset=488 */

	/* Parameter ppPendingBP */

/* 1512 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1514 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1516 */	NdrFcShort( 0x1fa ),	/* Type Offset=506 */

	/* Return value */

/* 1518 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1520 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1522 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumPendingBreakpoints */

/* 1524 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 1526 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1530 */	NdrFcShort( 0xc ),	/* 12 */
/* 1532 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1536 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1538 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pProgram */

/* 1540 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1542 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1544 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter pszProgram */

/* 1546 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1548 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1550 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter ppEnumBPs */

/* 1552 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1554 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1556 */	NdrFcShort( 0x210 ),	/* Type Offset=528 */

	/* Return value */

/* 1558 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1560 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumMachines */

/* 1564 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1566 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1570 */	NdrFcShort( 0xd ),	/* 13 */
/* 1572 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1576 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1578 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 1580 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1582 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1584 */	NdrFcShort( 0x226 ),	/* Type Offset=550 */

	/* Return value */

/* 1586 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1588 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1590 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddMachine */

/* 1592 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 1594 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1598 */	NdrFcShort( 0xe ),	/* 14 */
/* 1600 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1602 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1604 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1606 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pszMachine */

/* 1608 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1610 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1612 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter ppMachine */

/* 1614 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1616 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1618 */	NdrFcShort( 0x23c ),	/* Type Offset=572 */

	/* Return value */

/* 1620 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1622 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1624 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoveMachine */

/* 1626 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1628 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1632 */	NdrFcShort( 0xf ),	/* 15 */
/* 1634 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1636 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1638 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1640 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pMachine */

/* 1642 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1644 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1646 */	NdrFcShort( 0x134 ),	/* Type Offset=308 */

	/* Return value */

/* 1648 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1650 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1652 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ShutdownSession */

/* 1654 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1656 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1660 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1662 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1664 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1666 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1668 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 1670 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1672 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1674 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumCodeContexts */

/* 1676 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1678 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1682 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1684 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1688 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1690 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pProgram */

/* 1692 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1694 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1696 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter pDocPos */

/* 1698 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1700 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1702 */	NdrFcShort( 0x240 ),	/* Type Offset=576 */

	/* Parameter ppEnum */

/* 1704 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1706 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1708 */	NdrFcShort( 0x252 ),	/* Type Offset=594 */

	/* Return value */

/* 1710 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1712 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1714 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetException */

/* 1716 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1718 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1722 */	NdrFcShort( 0x12 ),	/* 18 */
/* 1724 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1726 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1728 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1730 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pException */

/* 1732 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1734 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1736 */	NdrFcShort( 0x26c ),	/* Type Offset=620 */

	/* Return value */

/* 1738 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1740 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1742 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumSetExceptions */

/* 1744 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 1746 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1750 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1752 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1754 */	NdrFcShort( 0x44 ),	/* 68 */
/* 1756 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1758 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter pProgram */

/* 1760 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1762 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1764 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter pszProgram */

/* 1766 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1768 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1770 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter guidType */

/* 1772 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1774 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1776 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter ppEnum */

/* 1778 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1780 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1782 */	NdrFcShort( 0x288 ),	/* Type Offset=648 */

	/* Return value */

/* 1784 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1786 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1788 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoveSetException */

/* 1790 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1792 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1796 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1798 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1800 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1802 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1804 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pException */

/* 1806 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1808 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1810 */	NdrFcShort( 0x26c ),	/* Type Offset=620 */

	/* Return value */

/* 1812 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1814 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1816 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoveAllSetExceptions */

/* 1818 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1820 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1824 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1826 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1828 */	NdrFcShort( 0x44 ),	/* 68 */
/* 1830 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1832 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter guidType */

/* 1834 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1836 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1838 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 1840 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1842 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1844 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumDefaultExceptions */

/* 1846 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 1848 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1852 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1854 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1856 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1858 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1860 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pParentException */

/* 1862 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1864 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1866 */	NdrFcShort( 0x29e ),	/* Type Offset=670 */

	/* Parameter ppEnum */

/* 1868 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1870 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1872 */	NdrFcShort( 0x288 ),	/* Type Offset=648 */

	/* Return value */

/* 1874 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1876 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1878 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetENCUpdate */

/* 1880 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1882 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1886 */	NdrFcShort( 0x17 ),	/* 23 */
/* 1888 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1890 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1892 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1894 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pProgram */

/* 1896 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1898 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1900 */	NdrFcShort( 0x16a ),	/* Type Offset=362 */

	/* Parameter ppUpdate */

/* 1902 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1904 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1906 */	NdrFcShort( 0x2a2 ),	/* Type Offset=674 */

	/* Return value */

/* 1908 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1910 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1912 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetLocale */

/* 1914 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1916 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1920 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1922 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1924 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1926 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1928 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter wLangID */

/* 1930 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1932 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1934 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 1936 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1938 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1940 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetRegistryRoot */

/* 1942 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 1944 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1948 */	NdrFcShort( 0x19 ),	/* 25 */
/* 1950 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1954 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1956 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pszRegistryRoot */

/* 1958 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1960 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1962 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Return value */

/* 1964 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1966 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1968 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsAlive */

/* 1970 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1972 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1976 */	NdrFcShort( 0x1a ),	/* 26 */
/* 1978 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1980 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1982 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1984 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 1986 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1988 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1990 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ClearAllSessionThreadStackFrames */

/* 1992 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1994 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1998 */	NdrFcShort( 0x1b ),	/* 27 */
/* 2000 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2004 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2006 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 2008 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2010 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2012 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSessionId */

/* 2014 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 2016 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2020 */	NdrFcShort( 0x1c ),	/* 28 */
/* 2022 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2024 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2026 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2028 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter pCallback */

/* 2030 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2032 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2034 */	NdrFcShort( 0x1c0 ),	/* Type Offset=448 */

	/* Parameter rgguidSpecificEngines */

/* 2036 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2038 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2040 */	NdrFcShort( 0x2b8 ),	/* Type Offset=696 */

	/* Parameter celtSpecificEngines */

/* 2042 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2044 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2046 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pszStartPageUrl */

/* 2048 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2050 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2052 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter pbstrSessionId */

/* 2054 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 2056 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2058 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Return value */

/* 2060 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2062 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2064 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetEngineMetric */

/* 2066 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2068 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2072 */	NdrFcShort( 0x1d ),	/* 29 */
/* 2074 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 2076 */	NdrFcShort( 0x44 ),	/* 68 */
/* 2078 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2080 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter guidEngine */

/* 2082 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2084 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2086 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter pszMetric */

/* 2088 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2090 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2092 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Parameter varValue */

/* 2094 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 2096 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2098 */	NdrFcShort( 0x6a4 ),	/* Type Offset=1700 */

	/* Return value */

/* 2100 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2102 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2104 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetStoppingModel */

/* 2106 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2108 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2112 */	NdrFcShort( 0x1e ),	/* 30 */
/* 2114 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2116 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2118 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2120 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter dwStoppingModel */

/* 2122 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2124 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2126 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2128 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2130 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2132 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetStoppingModel */

/* 2134 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2136 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2140 */	NdrFcShort( 0x1f ),	/* 31 */
/* 2142 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2146 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2148 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pdwStoppingModel */

/* 2150 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2152 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2156 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2158 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RegisterSessionWithServer */

/* 2162 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2164 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2168 */	NdrFcShort( 0x20 ),	/* 32 */
/* 2170 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2172 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2174 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2176 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pwszServerName */

/* 2178 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2180 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2182 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Return value */

/* 2184 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2186 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2188 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumPrograms */

/* 2190 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2192 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2196 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2198 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2202 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2204 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 2206 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2208 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2210 */	NdrFcShort( 0x6ae ),	/* Type Offset=1710 */

	/* Return value */

/* 2212 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2214 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2216 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Attach */

/* 2218 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2220 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2224 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2226 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2228 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2230 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2232 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter rgpPrograms */

/* 2234 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2236 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2238 */	NdrFcShort( 0x6da ),	/* Type Offset=1754 */

	/* Parameter rgpProgramNodes */

/* 2240 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2242 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2244 */	NdrFcShort( 0x702 ),	/* Type Offset=1794 */

	/* Parameter celtPrograms */

/* 2246 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2248 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2250 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pCallback */

/* 2252 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2254 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2256 */	NdrFcShort( 0x714 ),	/* Type Offset=1812 */

	/* Parameter dwReason */

/* 2258 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2260 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2262 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2264 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2266 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2268 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreatePendingBreakpoint */

/* 2270 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2272 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2276 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2278 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2280 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2282 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2284 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pBPRequest */

/* 2286 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2288 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2290 */	NdrFcShort( 0x726 ),	/* Type Offset=1830 */

	/* Parameter ppPendingBP */

/* 2292 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2294 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2296 */	NdrFcShort( 0x738 ),	/* Type Offset=1848 */

	/* Return value */

/* 2298 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2300 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2302 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetException */

/* 2304 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2306 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2310 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2312 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2316 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2318 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pException */

/* 2320 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2322 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2324 */	NdrFcShort( 0x26c ),	/* Type Offset=620 */

	/* Return value */

/* 2326 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2328 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2330 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoveSetException */

/* 2332 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2334 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2338 */	NdrFcShort( 0x7 ),	/* 7 */
/* 2340 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2344 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2346 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pException */

/* 2348 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2350 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2352 */	NdrFcShort( 0x26c ),	/* Type Offset=620 */

	/* Return value */

/* 2354 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2356 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoveAllSetExceptions */

/* 2360 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2362 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2366 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2368 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2370 */	NdrFcShort( 0x44 ),	/* 68 */
/* 2372 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2374 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter guidType */

/* 2376 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2378 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2380 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 2382 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2384 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2386 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetEngineId */

/* 2388 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2390 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2394 */	NdrFcShort( 0x9 ),	/* 9 */
/* 2396 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2400 */	NdrFcShort( 0x4c ),	/* 76 */
/* 2402 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pguidEngine */

/* 2404 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 2406 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2408 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 2410 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2412 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2414 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DestroyProgram */

/* 2416 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2418 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2422 */	NdrFcShort( 0xa ),	/* 10 */
/* 2424 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2426 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2428 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2430 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pProgram */

/* 2432 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2434 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2436 */	NdrFcShort( 0x6c8 ),	/* Type Offset=1736 */

	/* Return value */

/* 2438 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2440 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2442 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ContinueFromSynchronousEvent */

/* 2444 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2446 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2450 */	NdrFcShort( 0xb ),	/* 11 */
/* 2452 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2454 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2456 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2458 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pEvent */

/* 2460 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2462 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2464 */	NdrFcShort( 0x74e ),	/* Type Offset=1870 */

	/* Return value */

/* 2466 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2468 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2470 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetLocale */

/* 2472 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2474 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2478 */	NdrFcShort( 0xc ),	/* 12 */
/* 2480 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2482 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2484 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2486 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter wLangID */

/* 2488 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2490 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2492 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Return value */

/* 2494 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2496 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetRegistryRoot */

/* 2500 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 2502 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2506 */	NdrFcShort( 0xd ),	/* 13 */
/* 2508 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2512 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2514 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pszRegistryRoot */

/* 2516 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2518 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2520 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Return value */

/* 2522 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2524 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2526 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetMetric */

/* 2528 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2530 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2534 */	NdrFcShort( 0xe ),	/* 14 */
/* 2536 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2538 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2540 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2542 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pszMetric */

/* 2544 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2546 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2548 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Parameter varValue */

/* 2550 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 2552 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2554 */	NdrFcShort( 0x6a4 ),	/* Type Offset=1700 */

	/* Return value */

/* 2556 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2558 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2560 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CauseBreak */


	/* Procedure CauseBreak */


	/* Procedure CauseBreak */

/* 2562 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2564 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2568 */	NdrFcShort( 0xf ),	/* 15 */
/* 2570 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2572 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2574 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2576 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */


	/* Return value */


	/* Return value */

/* 2578 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2580 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2582 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LaunchSuspended */

/* 2584 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 2586 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2590 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2592 */	NdrFcShort( 0x3c ),	/* x86 Stack size/offset = 60 */
/* 2594 */	NdrFcShort( 0x20 ),	/* 32 */
/* 2596 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2598 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0xe,		/* 14 */

	/* Parameter pszMachine */

/* 2600 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2602 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2604 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter pPort */

/* 2606 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2608 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2610 */	NdrFcShort( 0x760 ),	/* Type Offset=1888 */

	/* Parameter pszExe */

/* 2612 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2614 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2616 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter pszArgs */

/* 2618 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2620 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2622 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter pszDir */

/* 2624 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2626 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2628 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter bstrEnv */

/* 2630 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 2632 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2634 */	NdrFcShort( 0x1b6 ),	/* Type Offset=438 */

	/* Parameter pszOptions */

/* 2636 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2638 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2640 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter dwLaunchFlags */

/* 2642 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2644 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 2646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter hStdInput */

/* 2648 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2650 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 2652 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter hStdOutput */

/* 2654 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2656 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 2658 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter hStdError */

/* 2660 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2662 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 2664 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pCallback */

/* 2666 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2668 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 2670 */	NdrFcShort( 0x714 ),	/* Type Offset=1812 */

	/* Parameter ppProcess */

/* 2672 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2674 */	NdrFcShort( 0x34 ),	/* x86 Stack size/offset = 52 */
/* 2676 */	NdrFcShort( 0x772 ),	/* Type Offset=1906 */

	/* Return value */

/* 2678 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2680 */	NdrFcShort( 0x38 ),	/* x86 Stack size/offset = 56 */
/* 2682 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ResumeProcess */

/* 2684 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2686 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2690 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2692 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2694 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2696 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2698 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pProcess */

/* 2700 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2702 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2704 */	NdrFcShort( 0x776 ),	/* Type Offset=1910 */

	/* Return value */

/* 2706 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2708 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2710 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CanTerminateProcess */

/* 2712 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2714 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2718 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2720 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2722 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2724 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2726 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pProcess */

/* 2728 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2730 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2732 */	NdrFcShort( 0x776 ),	/* Type Offset=1910 */

	/* Return value */

/* 2734 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2736 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2738 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure TerminateProcess */

/* 2740 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2742 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2746 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2748 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2750 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2752 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2754 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pProcess */

/* 2756 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2758 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2760 */	NdrFcShort( 0x776 ),	/* Type Offset=1910 */

	/* Return value */

/* 2762 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2764 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2766 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Event */

/* 2768 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2770 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2774 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2776 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 2778 */	NdrFcShort( 0x4c ),	/* 76 */
/* 2780 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2782 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x8,		/* 8 */

	/* Parameter pEngine */

/* 2784 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2786 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2788 */	NdrFcShort( 0x788 ),	/* Type Offset=1928 */

	/* Parameter pProcess */

/* 2790 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2792 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2794 */	NdrFcShort( 0x776 ),	/* Type Offset=1910 */

	/* Parameter pProgram */

/* 2796 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2798 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2800 */	NdrFcShort( 0x6c8 ),	/* Type Offset=1736 */

	/* Parameter pThread */

/* 2802 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2804 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2806 */	NdrFcShort( 0x79a ),	/* Type Offset=1946 */

	/* Parameter pEvent */

/* 2808 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2810 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2812 */	NdrFcShort( 0x7ac ),	/* Type Offset=1964 */

	/* Parameter riidEvent */

/* 2814 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2816 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2818 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter dwAttrib */

/* 2820 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2822 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2824 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2826 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2828 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 2830 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetBreakpointType */


	/* Procedure GetBreakpointType */


	/* Procedure GetLocationType */


	/* Procedure GetReason */


	/* Procedure GetExitCode */


	/* Procedure GetExitCode */


	/* Procedure GetAttributes */

/* 2832 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2834 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2838 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2840 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2842 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2844 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2846 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pBPType */


	/* Parameter pBPType */


	/* Parameter pBPLocationType */


	/* Parameter pcr */


	/* Parameter pdwExit */


	/* Parameter pdwExit */


	/* Parameter pdwAttrib */

/* 2848 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2850 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2852 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */

/* 2854 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2856 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2858 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetEngine */

/* 2860 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2862 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2866 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2868 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2870 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2872 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2874 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pEngine */

/* 2876 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2878 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2880 */	NdrFcShort( 0x7be ),	/* Type Offset=1982 */

	/* Return value */

/* 2882 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2884 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDocumentContext */

/* 2888 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2890 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2894 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2896 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2898 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2900 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2902 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppDocCxt */

/* 2904 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2906 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2908 */	NdrFcShort( 0x7c2 ),	/* Type Offset=1986 */

	/* Return value */

/* 2910 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2912 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2914 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCodeContext */

/* 2916 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2918 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2922 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2924 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2926 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2928 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2930 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppCodeContext */

/* 2932 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2934 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2936 */	NdrFcShort( 0x7d8 ),	/* Type Offset=2008 */

	/* Return value */

/* 2938 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2940 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2942 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumBreakpoints */

/* 2944 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2946 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2950 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2952 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2954 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2956 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2958 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 2960 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2962 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2964 */	NdrFcShort( 0x7ee ),	/* Type Offset=2030 */

	/* Return value */

/* 2966 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2968 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2970 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetException */

/* 2972 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2974 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2978 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2980 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2982 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2984 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2986 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pExceptionInfo */

/* 2988 */	NdrFcShort( 0xa113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=40 */
/* 2990 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2992 */	NdrFcShort( 0x26c ),	/* Type Offset=620 */

	/* Return value */

/* 2994 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2996 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2998 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure CanPassToDebuggee */

/* 3000 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3002 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3006 */	NdrFcShort( 0x5 ),	/* 5 */
/* 3008 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3010 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3012 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3014 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */

/* 3016 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3018 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3020 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure PassToDebuggee */

/* 3022 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3024 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3028 */	NdrFcShort( 0x6 ),	/* 6 */
/* 3030 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3032 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3034 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3036 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter fPass */

/* 3038 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3040 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3042 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3044 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3046 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3048 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetModule */

/* 3050 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3052 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3056 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3058 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3060 */	NdrFcShort( 0x1c ),	/* 28 */
/* 3062 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3064 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pModule */

/* 3066 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3068 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3070 */	NdrFcShort( 0x808 ),	/* Type Offset=2056 */

	/* Parameter pbstrDebugMessage */

/* 3072 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 3074 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3076 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter pbLoad */

/* 3078 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 3080 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3082 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3084 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3086 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3088 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDebugProperty */


	/* Procedure GetDebugProperty */

/* 3090 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3092 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3096 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3098 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3100 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3104 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppProperty */


	/* Parameter ppProperty */

/* 3106 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3108 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3110 */	NdrFcShort( 0x826 ),	/* Type Offset=2086 */

	/* Return value */


	/* Return value */

/* 3112 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3114 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3116 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPendingBreakpoint */

/* 3118 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3120 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3124 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3126 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3128 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3130 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3132 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppPendingBP */

/* 3134 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3136 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3138 */	NdrFcShort( 0x738 ),	/* Type Offset=1848 */

	/* Return value */

/* 3140 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3142 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3144 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumBoundBreakpoints */

/* 3146 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3148 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3152 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3154 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3156 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3158 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3160 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 3162 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3164 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3166 */	NdrFcShort( 0x83c ),	/* Type Offset=2108 */

	/* Return value */

/* 3168 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3170 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3172 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetBreakpoint */

/* 3174 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3176 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3180 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3182 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3186 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3188 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppBP */

/* 3190 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3192 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3194 */	NdrFcShort( 0x852 ),	/* Type Offset=2130 */

	/* Return value */

/* 3196 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3198 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetState */


	/* Procedure GetReason */

/* 3202 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3204 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3208 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3210 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3214 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3216 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pState */


	/* Parameter pdwUnboundReason */

/* 3218 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3220 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 3224 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3226 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3228 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetErrorBreakpoint */

/* 3230 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3232 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3236 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3238 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3240 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3242 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3244 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppErrorBP */

/* 3246 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3248 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3250 */	NdrFcShort( 0x868 ),	/* Type Offset=2152 */

	/* Return value */

/* 3252 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3254 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3256 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetExpression */

/* 3258 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3260 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3264 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3266 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3268 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3270 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3272 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppExpr */

/* 3274 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3276 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3278 */	NdrFcShort( 0x87e ),	/* Type Offset=2174 */

	/* Return value */

/* 3280 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3282 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3284 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetResult */

/* 3286 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3288 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3292 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3294 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3296 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3298 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3300 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppResult */

/* 3302 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3304 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3306 */	NdrFcShort( 0x894 ),	/* Type Offset=2196 */

	/* Return value */

/* 3308 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3310 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3312 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetReturnValue */

/* 3314 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3316 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3320 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3322 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3324 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3326 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3328 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppReturnValue */

/* 3330 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3332 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3334 */	NdrFcShort( 0x894 ),	/* Type Offset=2196 */

	/* Return value */

/* 3336 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3338 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3340 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SearchWithPath */

/* 3342 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3344 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3348 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3350 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3352 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3354 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3356 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pszSymbolSearchURL */

/* 3358 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3360 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3362 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Return value */

/* 3364 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3366 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3368 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMessage */

/* 3370 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3372 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3376 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3378 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3380 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3382 */	NdrFcShort( 0x5c ),	/* 92 */
/* 3384 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x6,		/* 6 */

	/* Parameter pMessageType */

/* 3386 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3388 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3390 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrMessage */

/* 3392 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 3394 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3396 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter pdwType */

/* 3398 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3400 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3402 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrHelpFileName */

/* 3404 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 3406 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3408 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter pdwHelpId */

/* 3410 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3412 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3414 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3416 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3418 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3420 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDocument */

/* 3422 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3424 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3428 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3430 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3432 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3434 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3436 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppDoc */

/* 3438 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3440 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3442 */	NdrFcShort( 0x8aa ),	/* Type Offset=2218 */

	/* Return value */

/* 3444 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3446 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3448 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDocumentContext */

/* 3450 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3452 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3456 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3458 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3462 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3464 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppDocContext */

/* 3466 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3468 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3470 */	NdrFcShort( 0x8c0 ),	/* Type Offset=2240 */

	/* Return value */

/* 3472 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3474 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3476 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInfo */

/* 3478 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3480 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3484 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3486 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3488 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3490 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3492 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter Fields */

/* 3494 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3496 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pProcessInfo */

/* 3500 */	NdrFcShort( 0xe113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=56 */
/* 3502 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3504 */	NdrFcShort( 0x8da ),	/* Type Offset=2266 */

	/* Return value */

/* 3506 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3508 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3510 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumPrograms */

/* 3512 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3514 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3518 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3520 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3522 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3524 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3526 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 3528 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3530 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3532 */	NdrFcShort( 0x8fe ),	/* Type Offset=2302 */

	/* Return value */

/* 3534 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3536 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3538 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetName */

/* 3540 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3542 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3546 */	NdrFcShort( 0x5 ),	/* 5 */
/* 3548 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3550 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3552 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3554 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter gnType */

/* 3556 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3558 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3560 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrName */

/* 3562 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 3564 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3566 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Return value */

/* 3568 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3570 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3572 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMachine */

/* 3574 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3576 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3580 */	NdrFcShort( 0x6 ),	/* 6 */
/* 3582 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3584 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3586 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3588 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppMachine */

/* 3590 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3592 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3594 */	NdrFcShort( 0x914 ),	/* Type Offset=2324 */

	/* Return value */

/* 3596 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3598 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3600 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Attach */

/* 3602 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3604 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3608 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3610 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3612 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3614 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3616 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter pCallback */

/* 3618 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3620 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3622 */	NdrFcShort( 0x92a ),	/* Type Offset=2346 */

	/* Parameter rgguidSpecificEngines */

/* 3624 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3626 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3628 */	NdrFcShort( 0x2bc ),	/* Type Offset=700 */

	/* Parameter celtSpecificEngines */

/* 3630 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3632 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3634 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rghrEngineAttach */

/* 3636 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 3638 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3640 */	NdrFcShort( 0x944 ),	/* Type Offset=2372 */

	/* Return value */

/* 3642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3644 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPhysicalProcessId */

/* 3648 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3654 */	NdrFcShort( 0xb ),	/* 11 */
/* 3656 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3658 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3660 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3662 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pProcessId */

/* 3664 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 3666 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3668 */	NdrFcShort( 0xe2 ),	/* Type Offset=226 */

	/* Return value */

/* 3670 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3672 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3674 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProcessId */

/* 3676 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3678 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3682 */	NdrFcShort( 0xc ),	/* 12 */
/* 3684 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3688 */	NdrFcShort( 0x4c ),	/* 76 */
/* 3690 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pguidProcessId */

/* 3692 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 3694 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3696 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 3698 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3700 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3702 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAttachedSessionName */

/* 3704 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3706 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3710 */	NdrFcShort( 0xd ),	/* 13 */
/* 3712 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3714 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3716 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3718 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pbstrSessionName */

/* 3720 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 3722 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3724 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Return value */

/* 3726 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3728 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumThreads */

/* 3732 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3734 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3738 */	NdrFcShort( 0xe ),	/* 14 */
/* 3740 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3742 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3744 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3746 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 3748 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3750 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3752 */	NdrFcShort( 0x956 ),	/* Type Offset=2390 */

	/* Return value */

/* 3754 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3756 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3758 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPort */

/* 3760 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3762 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3766 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3768 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3770 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3772 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3774 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppPort */

/* 3776 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3778 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3780 */	NdrFcShort( 0x96c ),	/* Type Offset=2412 */

	/* Return value */

/* 3782 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3784 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3786 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumThreads */

/* 3788 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3790 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3794 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3796 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3798 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3800 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3802 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 3804 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3806 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3808 */	NdrFcShort( 0x982 ),	/* Type Offset=2434 */

	/* Return value */

/* 3810 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3812 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3814 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProcess */

/* 3816 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3818 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3822 */	NdrFcShort( 0x5 ),	/* 5 */
/* 3824 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3828 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3830 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppProcess */

/* 3832 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3834 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3836 */	NdrFcShort( 0x998 ),	/* Type Offset=2456 */

	/* Return value */

/* 3838 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3840 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3842 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Terminate */

/* 3844 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3846 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3850 */	NdrFcShort( 0x6 ),	/* 6 */
/* 3852 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3854 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3856 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3858 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 3860 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3862 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3864 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Attach */

/* 3866 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3868 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3872 */	NdrFcShort( 0x7 ),	/* 7 */
/* 3874 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3876 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3878 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3880 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pCallback */

/* 3882 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3884 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3886 */	NdrFcShort( 0x9ae ),	/* Type Offset=2478 */

	/* Return value */

/* 3888 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3890 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3892 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CanDetach */

/* 3894 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3896 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3900 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3902 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3904 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3906 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3908 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 3910 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3912 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3914 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDebugProperty */

/* 3916 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3918 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3922 */	NdrFcShort( 0xb ),	/* 11 */
/* 3924 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3926 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3928 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3930 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppProperty */

/* 3932 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3934 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3936 */	NdrFcShort( 0x9c0 ),	/* Type Offset=2496 */

	/* Return value */

/* 3938 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3940 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3942 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Execute */

/* 3944 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3946 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3950 */	NdrFcShort( 0xc ),	/* 12 */
/* 3952 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3954 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3956 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3958 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 3960 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3962 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3964 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Continue */

/* 3966 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3968 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3972 */	NdrFcShort( 0xd ),	/* 13 */
/* 3974 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3976 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3978 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3980 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pThread */

/* 3982 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3984 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3986 */	NdrFcShort( 0x9d6 ),	/* Type Offset=2518 */

	/* Return value */

/* 3988 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3990 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3992 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Step */

/* 3994 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3996 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4000 */	NdrFcShort( 0xe ),	/* 14 */
/* 4002 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4004 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4006 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4008 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pThread */

/* 4010 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4012 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4014 */	NdrFcShort( 0x9d6 ),	/* Type Offset=2518 */

	/* Parameter sk */

/* 4016 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4018 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4020 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter step */

/* 4022 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4024 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4026 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4028 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4030 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4032 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetEngineInfo */

/* 4034 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4036 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4040 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4042 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4044 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4046 */	NdrFcShort( 0x4c ),	/* 76 */
/* 4048 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter pbstrEngine */

/* 4050 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 4052 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4054 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter pguidEngine */

/* 4056 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 4058 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4060 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 4062 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4064 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4066 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumCodeContexts */

/* 4068 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4070 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4074 */	NdrFcShort( 0x11 ),	/* 17 */
/* 4076 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4078 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4080 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4082 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pDocPos */

/* 4084 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4086 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4088 */	NdrFcShort( 0x9e8 ),	/* Type Offset=2536 */

	/* Parameter ppEnum */

/* 4090 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4092 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4094 */	NdrFcShort( 0x9fa ),	/* Type Offset=2554 */

	/* Return value */

/* 4096 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4098 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4100 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMemoryBytes */

/* 4102 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4104 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4108 */	NdrFcShort( 0x12 ),	/* 18 */
/* 4110 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4112 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4114 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4116 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppMemoryBytes */

/* 4118 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4120 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4122 */	NdrFcShort( 0xa10 ),	/* Type Offset=2576 */

	/* Return value */

/* 4124 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4126 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4128 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDisassemblyStream */

/* 4130 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4132 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4136 */	NdrFcShort( 0x13 ),	/* 19 */
/* 4138 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4140 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4142 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4144 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter dwScope */

/* 4146 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4148 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4150 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pCodeContext */

/* 4152 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4154 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4156 */	NdrFcShort( 0xa26 ),	/* Type Offset=2598 */

	/* Parameter ppDisassemblyStream */

/* 4158 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4160 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4162 */	NdrFcShort( 0xa38 ),	/* Type Offset=2616 */

	/* Return value */

/* 4164 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4166 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4168 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumModules */

/* 4170 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4172 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4176 */	NdrFcShort( 0x14 ),	/* 20 */
/* 4178 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4180 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4182 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4184 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 4186 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4188 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4190 */	NdrFcShort( 0xa4e ),	/* Type Offset=2638 */

	/* Return value */

/* 4192 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4194 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetENCUpdate */

/* 4198 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4200 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4204 */	NdrFcShort( 0x15 ),	/* 21 */
/* 4206 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4210 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4212 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppUpdate */

/* 4214 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4216 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4218 */	NdrFcShort( 0xa64 ),	/* Type Offset=2660 */

	/* Return value */

/* 4220 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4222 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4224 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumCodePaths */

/* 4226 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 4228 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4232 */	NdrFcShort( 0x16 ),	/* 22 */
/* 4234 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 4236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4240 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter pszHint */

/* 4242 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4244 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4246 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter pStart */

/* 4248 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4250 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4252 */	NdrFcShort( 0xa7a ),	/* Type Offset=2682 */

	/* Parameter pFrame */

/* 4254 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4256 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4258 */	NdrFcShort( 0xa8c ),	/* Type Offset=2700 */

	/* Parameter fSource */

/* 4260 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4262 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppEnum */

/* 4266 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4268 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4270 */	NdrFcShort( 0xa9e ),	/* Type Offset=2718 */

	/* Parameter ppSafety */

/* 4272 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4274 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 4276 */	NdrFcShort( 0xab4 ),	/* Type Offset=2740 */

	/* Return value */

/* 4278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4280 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 4282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteDump */

/* 4284 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4290 */	NdrFcShort( 0x17 ),	/* 23 */
/* 4292 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4294 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4296 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4298 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter DumpType */

/* 4300 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4302 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4304 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pszDumpUrl */

/* 4306 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 4308 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4310 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Return value */

/* 4312 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4314 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4316 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure onDestroy */


	/* Procedure Stop */

/* 4318 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4320 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4324 */	NdrFcShort( 0x3 ),	/* 3 */
/* 4326 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4328 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4330 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4332 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */


	/* Return value */

/* 4334 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4336 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4338 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WatchForThreadStep */

/* 4340 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4342 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4346 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4348 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 4350 */	NdrFcShort( 0x18 ),	/* 24 */
/* 4352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4354 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter pOriginatingProgram */

/* 4356 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4358 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4360 */	NdrFcShort( 0xab8 ),	/* Type Offset=2744 */

	/* Parameter dwTid */

/* 4362 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4364 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter fWatch */

/* 4368 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4370 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4372 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwFrame */

/* 4374 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4376 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4378 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4380 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4382 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4384 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WatchForExpressionEvaluationOnThread */

/* 4386 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4388 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4392 */	NdrFcShort( 0x5 ),	/* 5 */
/* 4394 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 4396 */	NdrFcShort( 0x18 ),	/* 24 */
/* 4398 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4400 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter pOriginatingProgram */

/* 4402 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4404 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4406 */	NdrFcShort( 0xab8 ),	/* Type Offset=2744 */

	/* Parameter dwTid */

/* 4408 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4410 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwEvalFlags */

/* 4414 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4416 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4418 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pExprCallback */

/* 4420 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4422 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4424 */	NdrFcShort( 0x92a ),	/* Type Offset=2346 */

	/* Parameter fWatch */

/* 4426 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4428 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4432 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4434 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 4436 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetName */


	/* Procedure GetHostName */

/* 4438 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4440 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4444 */	NdrFcShort( 0x3 ),	/* 3 */
/* 4446 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4448 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4450 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4452 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter gnType */


	/* Parameter dwType */

/* 4454 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4456 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4458 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrFileName */


	/* Parameter pbstrHostName */

/* 4460 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 4462 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4464 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Return value */


	/* Return value */

/* 4466 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4468 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4470 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetHostId */

/* 4472 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4474 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4478 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4480 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4482 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4484 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4486 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pProcessId */

/* 4488 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 4490 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4492 */	NdrFcShort( 0xe2 ),	/* Type Offset=226 */

	/* Return value */

/* 4494 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4496 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetName */


	/* Procedure GetHostMachineName */

/* 4500 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4502 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4506 */	NdrFcShort( 0x5 ),	/* 5 */
/* 4508 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4512 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4514 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pbstrName */


	/* Parameter pbstrHostMachineName */

/* 4516 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 4518 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4520 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Return value */


	/* Return value */

/* 4522 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4524 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4526 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetName */


	/* Procedure GetHostName */

/* 4528 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4530 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4534 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4536 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4538 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4540 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4542 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter gnType */


	/* Parameter dwHostNameType */

/* 4544 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4546 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4548 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrFileName */


	/* Parameter pbstrHostName */

/* 4550 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 4552 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4554 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Return value */


	/* Return value */

/* 4556 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4558 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4560 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetHostPid */

/* 4562 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4564 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4568 */	NdrFcShort( 0x5 ),	/* 5 */
/* 4570 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4572 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4574 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4576 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pHostProcessId */

/* 4578 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 4580 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4582 */	NdrFcShort( 0xe2 ),	/* Type Offset=226 */

	/* Return value */

/* 4584 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4586 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4588 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetHostMachineName */

/* 4590 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4592 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4596 */	NdrFcShort( 0x6 ),	/* 6 */
/* 4598 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4600 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4602 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4604 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pbstrHostMachineName */

/* 4606 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 4608 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4610 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Return value */

/* 4612 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4614 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4616 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Attach */

/* 4618 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4620 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4624 */	NdrFcShort( 0x7 ),	/* 7 */
/* 4626 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4628 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4630 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4632 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pMDMProgram */

/* 4634 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4636 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4638 */	NdrFcShort( 0xab8 ),	/* Type Offset=2744 */

	/* Parameter pCallback */

/* 4640 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4642 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4644 */	NdrFcShort( 0x92a ),	/* Type Offset=2346 */

	/* Parameter dwReason */

/* 4646 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4648 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4650 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4652 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4654 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetEngineInfo */

/* 4658 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4660 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4664 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4666 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4668 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4670 */	NdrFcShort( 0x4c ),	/* 76 */
/* 4672 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter pbstrEngine */

/* 4674 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 4676 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4678 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter pguidEngine */

/* 4680 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 4682 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4684 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 4686 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4688 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4690 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumPossibleEngines */

/* 4692 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 4694 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4698 */	NdrFcShort( 0x3 ),	/* 3 */
/* 4700 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4702 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4704 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4706 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter celtBuffer */

/* 4708 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4710 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4712 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgguidEngines */

/* 4714 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 4716 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4718 */	NdrFcShort( 0xaca ),	/* Type Offset=2762 */

	/* Parameter pceltEngines */

/* 4720 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 4722 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4726 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4728 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetEngine */

/* 4732 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4734 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4738 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4740 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4742 */	NdrFcShort( 0x44 ),	/* 68 */
/* 4744 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4746 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter guidEngine */

/* 4748 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 4750 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4752 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 4754 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4756 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4758 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumFrameInfo */


	/* Procedure EnumFrameInfo */

/* 4760 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4762 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4766 */	NdrFcShort( 0x3 ),	/* 3 */
/* 4768 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4770 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4772 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4774 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter dwFieldSpec */


	/* Parameter dwFieldSpec */

/* 4776 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4778 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4780 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter nRadix */


	/* Parameter nRadix */

/* 4782 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4784 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4786 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppEnum */


	/* Parameter ppEnum */

/* 4788 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4790 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4792 */	NdrFcShort( 0xae0 ),	/* Type Offset=2784 */

	/* Return value */


	/* Return value */

/* 4794 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4796 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4798 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetThreadName */

/* 4800 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4802 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4806 */	NdrFcShort( 0x5 ),	/* 5 */
/* 4808 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4810 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4812 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4814 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pszName */

/* 4816 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 4818 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4820 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Return value */

/* 4822 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4824 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4826 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetProgram */

/* 4828 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4830 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4834 */	NdrFcShort( 0x6 ),	/* 6 */
/* 4836 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4838 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4840 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4842 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppProgram */

/* 4844 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4846 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4848 */	NdrFcShort( 0xaf6 ),	/* Type Offset=2806 */

	/* Return value */

/* 4850 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4852 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4854 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CanSetNextStatement */

/* 4856 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4858 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4862 */	NdrFcShort( 0x7 ),	/* 7 */
/* 4864 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4866 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4868 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4870 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pStackFrame */

/* 4872 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4874 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4876 */	NdrFcShort( 0xafa ),	/* Type Offset=2810 */

	/* Parameter pCodeContext */

/* 4878 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4880 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4882 */	NdrFcShort( 0xa26 ),	/* Type Offset=2598 */

	/* Return value */

/* 4884 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4886 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4888 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetNextStatement */

/* 4890 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4892 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4896 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4898 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4900 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4902 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4904 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pStackFrame */

/* 4906 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4908 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4910 */	NdrFcShort( 0xafa ),	/* Type Offset=2810 */

	/* Parameter pCodeContext */

/* 4912 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4914 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4916 */	NdrFcShort( 0xa26 ),	/* Type Offset=2598 */

	/* Return value */

/* 4918 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4920 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4922 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetScope */


	/* Procedure GetThreadId */

/* 4924 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4926 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4930 */	NdrFcShort( 0x9 ),	/* 9 */
/* 4932 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4934 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4936 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4938 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pdwScope */


	/* Parameter pdwThreadId */

/* 4940 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 4942 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4944 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 4946 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4948 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4950 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Suspend */

/* 4952 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4954 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4958 */	NdrFcShort( 0xa ),	/* 10 */
/* 4960 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4962 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4964 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4966 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pdwSuspendCount */

/* 4968 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 4970 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4972 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4974 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4976 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4978 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSize */


	/* Procedure GetSize */


	/* Procedure Resume */

/* 4980 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4982 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4986 */	NdrFcShort( 0xb ),	/* 11 */
/* 4988 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4990 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4992 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4994 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pdwSize */


	/* Parameter pdwSize */


	/* Parameter pdwSuspendCount */

/* 4996 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 4998 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5000 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */


	/* Return value */

/* 5002 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5004 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5006 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetThreadProperties */

/* 5008 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5010 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5014 */	NdrFcShort( 0xc ),	/* 12 */
/* 5016 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5018 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5020 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5022 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwFields */

/* 5024 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5026 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5028 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ptp */

/* 5030 */	NdrFcShort( 0x8113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=32 */
/* 5032 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5034 */	NdrFcShort( 0xb10 ),	/* Type Offset=2832 */

	/* Return value */

/* 5036 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5038 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5040 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLogicalThread */

/* 5042 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5044 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5048 */	NdrFcShort( 0xd ),	/* 13 */
/* 5050 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5052 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5054 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5056 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pStackFrame */

/* 5058 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5060 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5062 */	NdrFcShort( 0xafa ),	/* Type Offset=2810 */

	/* Parameter ppLogicalThread */

/* 5064 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5066 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5068 */	NdrFcShort( 0xb2a ),	/* Type Offset=2858 */

	/* Return value */

/* 5070 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5072 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5074 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPropertyInfo */

/* 5076 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 5078 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5082 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5084 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 5086 */	NdrFcShort( 0x20 ),	/* 32 */
/* 5088 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5090 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter dwFields */

/* 5092 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5094 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5096 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwRadix */

/* 5098 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5100 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5102 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwTimeout */

/* 5104 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5106 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5108 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpArgs */

/* 5110 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5112 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5114 */	NdrFcShort( 0xb40 ),	/* Type Offset=2880 */

	/* Parameter dwArgCount */

/* 5116 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5118 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5120 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pPropertyInfo */

/* 5122 */	NdrFcShort( 0x8113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=32 */
/* 5124 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 5126 */	NdrFcShort( 0xb7e ),	/* Type Offset=2942 */

	/* Return value */

/* 5128 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5130 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 5132 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetValueAsString */


	/* Procedure SetValueAsString */

/* 5134 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5136 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5140 */	NdrFcShort( 0x4 ),	/* 4 */
/* 5142 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5144 */	NdrFcShort( 0x10 ),	/* 16 */
/* 5146 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5148 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pszValue */


	/* Parameter pszValue */

/* 5150 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 5152 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5154 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Parameter dwRadix */


	/* Parameter dwRadix */

/* 5156 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5158 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwTimeout */


	/* Parameter dwTimeout */

/* 5162 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5164 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 5168 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5170 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5172 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetValueAsReference */

/* 5174 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 5176 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5180 */	NdrFcShort( 0x5 ),	/* 5 */
/* 5182 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 5184 */	NdrFcShort( 0x10 ),	/* 16 */
/* 5186 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5188 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter rgpArgs */

/* 5190 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5192 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5194 */	NdrFcShort( 0xb9e ),	/* Type Offset=2974 */

	/* Parameter dwArgCount */

/* 5196 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5198 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pValue */

/* 5202 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5204 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5206 */	NdrFcShort( 0xb44 ),	/* Type Offset=2884 */

	/* Parameter dwTimeout */

/* 5208 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5210 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5212 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5214 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5216 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5218 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumChildren */

/* 5220 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 5222 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5226 */	NdrFcShort( 0x6 ),	/* 6 */
/* 5228 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 5230 */	NdrFcShort( 0x6c ),	/* 108 */
/* 5232 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5234 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x8,		/* 8 */

	/* Parameter dwFields */

/* 5236 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5238 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwRadix */

/* 5242 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5244 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5246 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidFilter */

/* 5248 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 5250 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5252 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter dwAttribFilter */

/* 5254 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5256 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5258 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter pszNameFilter */

/* 5260 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5262 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 5264 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter dwTimeout */

/* 5266 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5268 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 5270 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppEnum */

/* 5272 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5274 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 5276 */	NdrFcShort( 0xbb4 ),	/* Type Offset=2996 */

	/* Return value */

/* 5278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5280 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 5282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetParent */

/* 5284 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5290 */	NdrFcShort( 0x7 ),	/* 7 */
/* 5292 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5296 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5298 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppParent */

/* 5300 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5302 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5304 */	NdrFcShort( 0xbca ),	/* Type Offset=3018 */

	/* Return value */

/* 5306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5308 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDerivedMostProperty */

/* 5312 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5318 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5320 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5324 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5326 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppDerivedMost */

/* 5328 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5330 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5332 */	NdrFcShort( 0xbca ),	/* Type Offset=3018 */

	/* Return value */

/* 5334 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5336 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5338 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMemoryBytes */

/* 5340 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5342 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5346 */	NdrFcShort( 0x9 ),	/* 9 */
/* 5348 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5350 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5354 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppMemoryBytes */

/* 5356 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5358 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5360 */	NdrFcShort( 0xa10 ),	/* Type Offset=2576 */

	/* Return value */

/* 5362 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5364 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMemoryContext */

/* 5368 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5370 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5374 */	NdrFcShort( 0xa ),	/* 10 */
/* 5376 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5380 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5382 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppMemory */

/* 5384 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5386 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5388 */	NdrFcShort( 0xbce ),	/* Type Offset=3022 */

	/* Return value */

/* 5390 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5392 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetReference */

/* 5396 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5398 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5402 */	NdrFcShort( 0xc ),	/* 12 */
/* 5404 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5408 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5410 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppReference */

/* 5412 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5414 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5416 */	NdrFcShort( 0xbe4 ),	/* Type Offset=3044 */

	/* Return value */

/* 5418 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5420 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5422 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetExtendedInfo */

/* 5424 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5426 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5430 */	NdrFcShort( 0xd ),	/* 13 */
/* 5432 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5434 */	NdrFcShort( 0x44 ),	/* 68 */
/* 5436 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5438 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter guidExtendedInfo */

/* 5440 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 5442 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5444 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter pExtendedInfo */

/* 5446 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
/* 5448 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5450 */	NdrFcShort( 0xc02 ),	/* Type Offset=3074 */

	/* Return value */

/* 5452 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5454 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5456 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetReferenceInfo */

/* 5458 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5460 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5464 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5466 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 5468 */	NdrFcShort( 0x20 ),	/* 32 */
/* 5470 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5472 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter dwFields */

/* 5474 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5476 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5478 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwRadix */

/* 5480 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5482 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5484 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwTimeout */

/* 5486 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5488 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpArgs */

/* 5492 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 5494 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5496 */	NdrFcShort( 0xc10 ),	/* Type Offset=3088 */

	/* Parameter dwArgCount */

/* 5498 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5500 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5502 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pReferenceInfo */

/* 5504 */	NdrFcShort( 0x8113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=32 */
/* 5506 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 5508 */	NdrFcShort( 0xc26 ),	/* Type Offset=3110 */

	/* Return value */

/* 5510 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5512 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 5514 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetValueAsReference */

/* 5516 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5518 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5522 */	NdrFcShort( 0x5 ),	/* 5 */
/* 5524 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 5526 */	NdrFcShort( 0x10 ),	/* 16 */
/* 5528 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5530 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter rgpArgs */

/* 5532 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 5534 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5536 */	NdrFcShort( 0xc46 ),	/* Type Offset=3142 */

	/* Parameter dwArgCount */

/* 5538 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5540 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5542 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pValue */

/* 5544 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5546 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5548 */	NdrFcShort( 0xbe8 ),	/* Type Offset=3048 */

	/* Parameter dwTimeout */

/* 5550 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5552 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5554 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5556 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5558 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5560 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumChildren */

/* 5562 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 5564 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5568 */	NdrFcShort( 0x6 ),	/* 6 */
/* 5570 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 5572 */	NdrFcShort( 0x28 ),	/* 40 */
/* 5574 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5576 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter dwFields */

/* 5578 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5580 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5582 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwRadix */

/* 5584 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5586 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5588 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwAttribFilter */

/* 5590 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5592 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5594 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter pszNameFilter */

/* 5596 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5598 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5600 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter dwTimeout */

/* 5602 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5604 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 5606 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppEnum */

/* 5608 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5610 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 5612 */	NdrFcShort( 0xc58 ),	/* Type Offset=3160 */

	/* Return value */

/* 5614 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5616 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 5618 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetParent */

/* 5620 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5622 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5626 */	NdrFcShort( 0x7 ),	/* 7 */
/* 5628 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5630 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5634 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppParent */

/* 5636 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5638 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5640 */	NdrFcShort( 0xbe4 ),	/* Type Offset=3044 */

	/* Return value */

/* 5642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5644 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDerivedMostReference */

/* 5648 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5654 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5656 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5658 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5660 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5662 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppDerivedMost */

/* 5664 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5666 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5668 */	NdrFcShort( 0xbe4 ),	/* Type Offset=3044 */

	/* Return value */

/* 5670 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5672 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5674 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMemoryBytes */

/* 5676 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5678 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5682 */	NdrFcShort( 0x9 ),	/* 9 */
/* 5684 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5688 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5690 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppMemoryBytes */

/* 5692 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5694 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5696 */	NdrFcShort( 0xc6e ),	/* Type Offset=3182 */

	/* Return value */

/* 5698 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5700 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5702 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMemoryContext */

/* 5704 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5706 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5710 */	NdrFcShort( 0xa ),	/* 10 */
/* 5712 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5714 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5716 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5718 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppMemory */

/* 5720 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5722 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5724 */	NdrFcShort( 0xc84 ),	/* Type Offset=3204 */

	/* Return value */

/* 5726 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5728 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetReferenceType */

/* 5732 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5734 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5738 */	NdrFcShort( 0xc ),	/* 12 */
/* 5740 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5742 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5744 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5746 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter dwRefType */

/* 5748 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5750 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5752 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 5754 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5756 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5758 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Compare */

/* 5760 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5762 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5766 */	NdrFcShort( 0xd ),	/* 13 */
/* 5768 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5770 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5772 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5774 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwCompare */

/* 5776 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5778 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5780 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pReference */

/* 5782 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5784 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5786 */	NdrFcShort( 0xc9a ),	/* Type Offset=3226 */

	/* Return value */

/* 5788 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5790 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5792 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCodeContext */

/* 5794 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5796 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5800 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5802 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5804 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5806 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5808 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppCodeCxt */

/* 5810 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5812 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5814 */	NdrFcShort( 0xcac ),	/* Type Offset=3244 */

	/* Return value */

/* 5816 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5818 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5820 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDocumentContext */

/* 5822 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5824 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5828 */	NdrFcShort( 0x4 ),	/* 4 */
/* 5830 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5832 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5834 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5836 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppCxt */

/* 5838 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5840 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5842 */	NdrFcShort( 0xcc2 ),	/* Type Offset=3266 */

	/* Return value */

/* 5844 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5846 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5848 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInfo */

/* 5850 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5852 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5856 */	NdrFcShort( 0x6 ),	/* 6 */
/* 5858 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 5860 */	NdrFcShort( 0x10 ),	/* 16 */
/* 5862 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5864 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter dwFieldSpec */

/* 5866 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5868 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter nRadix */

/* 5872 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5874 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5876 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pFrameInfo */

/* 5878 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 5880 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5882 */	NdrFcShort( 0xd00 ),	/* Type Offset=3328 */

	/* Return value */

/* 5884 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5886 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5888 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPhysicalStackRange */

/* 5890 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5892 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5896 */	NdrFcShort( 0x7 ),	/* 7 */
/* 5898 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5900 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5902 */	NdrFcShort( 0x50 ),	/* 80 */
/* 5904 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter paddrMin */

/* 5906 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5908 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5910 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter paddrMax */

/* 5912 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 5914 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5916 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 5918 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5920 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5922 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetExpressionContext */

/* 5924 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5926 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5930 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5932 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5934 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5936 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5938 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppExprCxt */

/* 5940 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5942 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5944 */	NdrFcShort( 0xd30 ),	/* Type Offset=3376 */

	/* Return value */

/* 5946 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5948 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5950 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLanguageInfo */


	/* Procedure GetLanguageInfo */

/* 5952 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 5954 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5958 */	NdrFcShort( 0x9 ),	/* 9 */
/* 5960 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 5962 */	NdrFcShort( 0x44 ),	/* 68 */
/* 5964 */	NdrFcShort( 0x4c ),	/* 76 */
/* 5966 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pbstrLanguage */


	/* Parameter pbstrLanguage */

/* 5968 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 5970 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5972 */	NdrFcShort( 0xd46 ),	/* Type Offset=3398 */

	/* Parameter pguidLanguage */


	/* Parameter pguidLanguage */

/* 5974 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 5976 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 5978 */	NdrFcShort( 0xd4a ),	/* Type Offset=3402 */

	/* Return value */


	/* Return value */

/* 5980 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5982 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5984 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDebugProperty */

/* 5986 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5988 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5992 */	NdrFcShort( 0xa ),	/* 10 */
/* 5994 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5996 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5998 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6000 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppProperty */

/* 6002 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6004 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6006 */	NdrFcShort( 0xd4e ),	/* Type Offset=3406 */

	/* Return value */

/* 6008 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6010 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6012 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumProperties */

/* 6014 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6016 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6020 */	NdrFcShort( 0xb ),	/* 11 */
/* 6022 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 6024 */	NdrFcShort( 0x5c ),	/* 92 */
/* 6026 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6028 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x7,		/* 7 */

	/* Parameter dwFields */

/* 6030 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6032 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6034 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter nRadix */

/* 6036 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6038 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6040 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidFilter */

/* 6042 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 6044 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6046 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Parameter dwTimeout */

/* 6048 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6050 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6052 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcelt */

/* 6054 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6056 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6058 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppEnum */

/* 6060 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6062 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 6064 */	NdrFcShort( 0xd64 ),	/* Type Offset=3428 */

	/* Return value */

/* 6066 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6068 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 6070 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetThread */

/* 6072 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6074 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6078 */	NdrFcShort( 0xc ),	/* 12 */
/* 6080 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6082 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6084 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6086 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppThread */

/* 6088 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6090 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6092 */	NdrFcShort( 0xd7a ),	/* Type Offset=3450 */

	/* Return value */

/* 6094 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6096 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6098 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInfo */

/* 6100 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6102 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6106 */	NdrFcShort( 0x4 ),	/* 4 */
/* 6108 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6110 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6112 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6114 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwFields */

/* 6116 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6118 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6120 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pInfo */

/* 6122 */	NdrFcShort( 0x8113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=32 */
/* 6124 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6126 */	NdrFcShort( 0xd94 ),	/* Type Offset=3476 */

	/* Return value */

/* 6128 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6130 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6132 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Add */

/* 6134 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6136 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6140 */	NdrFcShort( 0x5 ),	/* 5 */
/* 6142 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6144 */	NdrFcShort( 0x10 ),	/* 16 */
/* 6146 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6148 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwCount */

/* 6150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6152 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6154 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter ppMemCxt */

/* 6156 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6158 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6160 */	NdrFcShort( 0xdb6 ),	/* Type Offset=3510 */

	/* Return value */

/* 6162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6164 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Subtract */

/* 6168 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6174 */	NdrFcShort( 0x6 ),	/* 6 */
/* 6176 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6178 */	NdrFcShort( 0x10 ),	/* 16 */
/* 6180 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6182 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwCount */

/* 6184 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6186 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6188 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter ppMemCxt */

/* 6190 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6192 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6194 */	NdrFcShort( 0xdb6 ),	/* Type Offset=3510 */

	/* Return value */

/* 6196 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6198 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Compare */

/* 6202 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6204 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6208 */	NdrFcShort( 0x7 ),	/* 7 */
/* 6210 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 6212 */	NdrFcShort( 0x10 ),	/* 16 */
/* 6214 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6216 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter compare */

/* 6218 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6220 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpMemoryContextSet */

/* 6224 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 6226 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6228 */	NdrFcShort( 0xdd0 ),	/* Type Offset=3536 */

	/* Parameter dwMemoryContextSetLen */

/* 6230 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6232 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pdwMemoryContext */

/* 6236 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6238 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6242 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6244 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6246 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDocumentContext */

/* 6248 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6250 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6254 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6256 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6260 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6262 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppSrcCxt */

/* 6264 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6266 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6268 */	NdrFcShort( 0xde2 ),	/* Type Offset=3554 */

	/* Return value */

/* 6270 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6272 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6274 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReadAt */

/* 6276 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 6278 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6282 */	NdrFcShort( 0x3 ),	/* 3 */
/* 6284 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 6286 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6288 */	NdrFcShort( 0x40 ),	/* 64 */
/* 6290 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter pStartContext */

/* 6292 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 6294 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6296 */	NdrFcShort( 0xdba ),	/* Type Offset=3514 */

	/* Parameter dwCount */

/* 6298 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6300 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6302 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgbMemory */

/* 6304 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 6306 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6308 */	NdrFcShort( 0xdfc ),	/* Type Offset=3580 */

	/* Parameter pdwRead */

/* 6310 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6312 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6314 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pdwUnreadable */

/* 6316 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 6318 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6320 */	NdrFcShort( 0xe0a ),	/* Type Offset=3594 */

	/* Return value */

/* 6322 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6324 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 6326 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure WriteAt */

/* 6328 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6330 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6334 */	NdrFcShort( 0x4 ),	/* 4 */
/* 6336 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6338 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6340 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6342 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pStartContext */

/* 6344 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 6346 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6348 */	NdrFcShort( 0xdba ),	/* Type Offset=3514 */

	/* Parameter dwCount */

/* 6350 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6352 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6354 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgbMemory */

/* 6356 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 6358 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6360 */	NdrFcShort( 0xe12 ),	/* Type Offset=3602 */

	/* Return value */

/* 6362 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6364 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSize */

/* 6368 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6370 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6374 */	NdrFcShort( 0x5 ),	/* 5 */
/* 6376 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6380 */	NdrFcShort( 0x2c ),	/* 44 */
/* 6382 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pqwSize */

/* 6384 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6386 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6388 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 6390 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6392 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Read */

/* 6396 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6398 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6402 */	NdrFcShort( 0x3 ),	/* 3 */
/* 6404 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 6406 */	NdrFcShort( 0x10 ),	/* 16 */
/* 6408 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6410 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x5,		/* 5 */

	/* Parameter dwInstructions */

/* 6412 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6414 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6416 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwFields */

/* 6418 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6420 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6422 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pdwInstructionsRead */

/* 6424 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6426 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6428 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter prgDisassembly */

/* 6430 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 6432 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6434 */	NdrFcShort( 0xe58 ),	/* Type Offset=3672 */

	/* Return value */

/* 6436 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6438 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6440 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Seek */

/* 6442 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6444 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6448 */	NdrFcShort( 0x4 ),	/* 4 */
/* 6450 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 6452 */	NdrFcShort( 0x28 ),	/* 40 */
/* 6454 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6456 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter dwSeekStart */

/* 6458 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6460 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6462 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pCodeContext */

/* 6464 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 6466 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6468 */	NdrFcShort( 0xe6a ),	/* Type Offset=3690 */

	/* Parameter uCodeLocationId */

/* 6470 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6472 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6474 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter iInstructions */

/* 6476 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6478 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6480 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 6482 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6484 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 6486 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCodeLocationId */

/* 6488 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6490 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6494 */	NdrFcShort( 0x5 ),	/* 5 */
/* 6496 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6498 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6500 */	NdrFcShort( 0x2c ),	/* 44 */
/* 6502 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pCodeContext */

/* 6504 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 6506 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6508 */	NdrFcShort( 0xe6a ),	/* Type Offset=3690 */

	/* Parameter puCodeLocationId */

/* 6510 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6512 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6514 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 6516 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6518 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6520 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCodeContext */

/* 6522 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6524 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6528 */	NdrFcShort( 0x6 ),	/* 6 */
/* 6530 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6532 */	NdrFcShort( 0x10 ),	/* 16 */
/* 6534 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6536 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter uCodeLocationId */

/* 6538 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6540 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6542 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter ppCodeContext */

/* 6544 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6546 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6548 */	NdrFcShort( 0xe7c ),	/* Type Offset=3708 */

	/* Return value */

/* 6550 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6552 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6554 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCurrentLocation */

/* 6556 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6558 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6562 */	NdrFcShort( 0x7 ),	/* 7 */
/* 6564 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6566 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6568 */	NdrFcShort( 0x2c ),	/* 44 */
/* 6570 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter puCodeLocationId */

/* 6572 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6574 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6576 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 6578 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6580 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6582 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDocument */

/* 6584 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6586 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6590 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6592 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6594 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6596 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6598 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter bstrDocumentUrl */

/* 6600 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 6602 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6604 */	NdrFcShort( 0x1b6 ),	/* Type Offset=438 */

	/* Parameter ppDocument */

/* 6606 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6608 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6610 */	NdrFcShort( 0xe80 ),	/* Type Offset=3712 */

	/* Return value */

/* 6612 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6614 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6616 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSize */

/* 6618 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6620 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6624 */	NdrFcShort( 0xa ),	/* 10 */
/* 6626 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6628 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6630 */	NdrFcShort( 0x2c ),	/* 44 */
/* 6632 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pnSize */

/* 6634 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6636 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6638 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 6640 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6642 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6644 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDocument */

/* 6646 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6648 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6652 */	NdrFcShort( 0x3 ),	/* 3 */
/* 6654 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6656 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6658 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6660 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppDocument */

/* 6662 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6664 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6666 */	NdrFcShort( 0xe80 ),	/* Type Offset=3712 */

	/* Return value */

/* 6668 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6670 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6672 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumCodeContexts */

/* 6674 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6676 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6680 */	NdrFcShort( 0x5 ),	/* 5 */
/* 6682 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6684 */	NdrFcShort( 0x0 ),	/* 0 */
/* 6686 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6688 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnumCodeCxts */

/* 6690 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6692 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6694 */	NdrFcShort( 0xe96 ),	/* Type Offset=3734 */

	/* Return value */

/* 6696 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6698 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6700 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLanguageInfo */

/* 6702 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 6704 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6708 */	NdrFcShort( 0x6 ),	/* 6 */
/* 6710 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6712 */	NdrFcShort( 0x44 ),	/* 68 */
/* 6714 */	NdrFcShort( 0x4c ),	/* 76 */
/* 6716 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pbstrLanguage */

/* 6718 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 6720 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6722 */	NdrFcShort( 0xd46 ),	/* Type Offset=3398 */

	/* Parameter pguidLanguage */

/* 6724 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 6726 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6728 */	NdrFcShort( 0xd4a ),	/* Type Offset=3402 */

	/* Return value */

/* 6730 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6732 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6734 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetStatementRange */

/* 6736 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 6738 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6742 */	NdrFcShort( 0x7 ),	/* 7 */
/* 6744 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6746 */	NdrFcShort( 0x58 ),	/* 88 */
/* 6748 */	NdrFcShort( 0x60 ),	/* 96 */
/* 6750 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pBegPosition */

/* 6752 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 6754 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6756 */	NdrFcShort( 0xeac ),	/* Type Offset=3756 */

	/* Parameter pEndPosition */

/* 6758 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 6760 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6762 */	NdrFcShort( 0xeac ),	/* Type Offset=3756 */

	/* Return value */

/* 6764 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6766 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6768 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSourceRange */

/* 6770 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 6772 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6776 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6778 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6780 */	NdrFcShort( 0x58 ),	/* 88 */
/* 6782 */	NdrFcShort( 0x60 ),	/* 96 */
/* 6784 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pBegPosition */

/* 6786 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 6788 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6790 */	NdrFcShort( 0xeac ),	/* Type Offset=3756 */

	/* Parameter pEndPosition */

/* 6792 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 6794 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6796 */	NdrFcShort( 0xeac ),	/* Type Offset=3756 */

	/* Return value */

/* 6798 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6800 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6802 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Compare */

/* 6804 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6806 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6810 */	NdrFcShort( 0x9 ),	/* 9 */
/* 6812 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 6814 */	NdrFcShort( 0x10 ),	/* 16 */
/* 6816 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6818 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter compare */

/* 6820 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6822 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6824 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgpDocContextSet */

/* 6826 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 6828 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6830 */	NdrFcShort( 0xec6 ),	/* Type Offset=3782 */

	/* Parameter dwDocContextSetLen */

/* 6832 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6834 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6836 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pdwDocContext */

/* 6838 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6840 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6842 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6844 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6846 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6848 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Seek */

/* 6850 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6852 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6856 */	NdrFcShort( 0xa ),	/* 10 */
/* 6858 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6860 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6862 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6864 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter nCount */

/* 6866 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6868 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppDocContext */

/* 6872 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6874 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6876 */	NdrFcShort( 0xed8 ),	/* Type Offset=3800 */

	/* Return value */

/* 6878 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6880 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6882 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ParseText */

/* 6884 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6886 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6890 */	NdrFcShort( 0x4 ),	/* 4 */
/* 6892 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 6894 */	NdrFcShort( 0x10 ),	/* 16 */
/* 6896 */	NdrFcShort( 0x24 ),	/* 36 */
/* 6898 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter pszCode */

/* 6900 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 6902 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6904 */	NdrFcShort( 0xc2 ),	/* Type Offset=194 */

	/* Parameter dwFlags */

/* 6906 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6908 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6910 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter nRadix */

/* 6912 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6914 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6916 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppExpr */

/* 6918 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 6920 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6922 */	NdrFcShort( 0xedc ),	/* Type Offset=3804 */

	/* Parameter pbstrError */

/* 6924 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 6926 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 6928 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter pichError */

/* 6930 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 6932 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 6934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 6936 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6938 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 6940 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRequestInfo */

/* 6942 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6944 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6948 */	NdrFcShort( 0x4 ),	/* 4 */
/* 6950 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6952 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6954 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6956 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwFields */

/* 6958 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6960 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6962 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pBPRequestInfo */

/* 6964 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 6966 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 6968 */	NdrFcShort( 0x100a ),	/* Type Offset=4106 */

	/* Return value */

/* 6970 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 6972 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 6974 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetResolutionInfo */

/* 6976 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 6978 */	NdrFcLong( 0x0 ),	/* 0 */
/* 6982 */	NdrFcShort( 0x4 ),	/* 4 */
/* 6984 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 6986 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6988 */	NdrFcShort( 0x8 ),	/* 8 */
/* 6990 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwFields */

/* 6992 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 6994 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 6996 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pBPResolutionInfo */

/* 6998 */	NdrFcShort( 0x8113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=32 */
/* 7000 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7002 */	NdrFcShort( 0x1072 ),	/* Type Offset=4210 */

	/* Return value */

/* 7004 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7006 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7008 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetResolutionInfo */

/* 7010 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7012 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7016 */	NdrFcShort( 0x4 ),	/* 4 */
/* 7018 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7020 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7022 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7024 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwFields */

/* 7026 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7028 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7030 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pErrorResolutionInfo */

/* 7032 */	NdrFcShort( 0xa113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=40 */
/* 7034 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7036 */	NdrFcShort( 0x108c ),	/* Type Offset=4236 */

	/* Return value */

/* 7038 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7040 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7042 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPendingBreakpoint */

/* 7044 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7046 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7050 */	NdrFcShort( 0x3 ),	/* 3 */
/* 7052 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7054 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7056 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7058 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppPendingBreakpoint */

/* 7060 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7062 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7064 */	NdrFcShort( 0x10a8 ),	/* Type Offset=4264 */

	/* Return value */

/* 7066 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7068 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7070 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetHitCount */

/* 7072 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7074 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7078 */	NdrFcShort( 0x5 ),	/* 5 */
/* 7080 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7082 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7084 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7086 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pdwHitCount */

/* 7088 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7090 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7092 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7094 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7096 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7098 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetBreakpointResolution */

/* 7100 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7102 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7106 */	NdrFcShort( 0x6 ),	/* 6 */
/* 7108 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7112 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7114 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppBPResolution */

/* 7116 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7118 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7120 */	NdrFcShort( 0x10be ),	/* Type Offset=4286 */

	/* Return value */

/* 7122 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7124 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7126 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Virtualize */


	/* Procedure Enable */

/* 7128 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7130 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7134 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7136 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7138 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7140 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7142 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter fVirtualize */


	/* Parameter fEnable */

/* 7144 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7146 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 7150 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7152 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetCondition */


	/* Procedure SetCondition */

/* 7156 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7158 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7162 */	NdrFcShort( 0x9 ),	/* 9 */
/* 7164 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 7166 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7168 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7170 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter bpCondition */


	/* Parameter bpCondition */

/* 7172 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 7174 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7176 */	NdrFcShort( 0xff2 ),	/* Type Offset=4082 */

	/* Return value */


	/* Return value */

/* 7178 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7180 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 7182 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetPassCount */


	/* Procedure SetPassCount */

/* 7184 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7186 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7190 */	NdrFcShort( 0xa ),	/* 10 */
/* 7192 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7194 */	NdrFcShort( 0x18 ),	/* 24 */
/* 7196 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7198 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter bpPassCount */


	/* Parameter bpPassCount */

/* 7200 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 7202 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7204 */	NdrFcShort( 0x61e ),	/* Type Offset=1566 */

	/* Return value */


	/* Return value */

/* 7206 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7208 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Delete */

/* 7212 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7214 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7218 */	NdrFcShort( 0xb ),	/* 11 */
/* 7220 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7222 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7224 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7226 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 7228 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7230 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7232 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CanBind */

/* 7234 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7236 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7240 */	NdrFcShort( 0x3 ),	/* 3 */
/* 7242 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7246 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7248 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppErrorEnum */

/* 7250 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7252 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7254 */	NdrFcShort( 0x10c2 ),	/* Type Offset=4290 */

	/* Return value */

/* 7256 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7258 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7260 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Abort */


	/* Procedure Bind */

/* 7262 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7264 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7268 */	NdrFcShort( 0x4 ),	/* 4 */
/* 7270 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7274 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7276 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */


	/* Return value */

/* 7278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7280 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetState */

/* 7284 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7290 */	NdrFcShort( 0x5 ),	/* 5 */
/* 7292 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7296 */	NdrFcShort( 0x34 ),	/* 52 */
/* 7298 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pState */

/* 7300 */	NdrFcShort( 0x2112 ),	/* Flags:  must free, out, simple ref, srv alloc size=8 */
/* 7302 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7304 */	NdrFcShort( 0x61e ),	/* Type Offset=1566 */

	/* Return value */

/* 7306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7308 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetBreakpointRequest */

/* 7312 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7318 */	NdrFcShort( 0x6 ),	/* 6 */
/* 7320 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7324 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7326 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppBPRequest */

/* 7328 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7330 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7332 */	NdrFcShort( 0x10dc ),	/* Type Offset=4316 */

	/* Return value */

/* 7334 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7336 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7338 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumBoundBreakpoints */

/* 7340 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7342 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7346 */	NdrFcShort( 0xb ),	/* 11 */
/* 7348 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7350 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7354 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 7356 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7358 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7360 */	NdrFcShort( 0x10f2 ),	/* Type Offset=4338 */

	/* Return value */

/* 7362 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7364 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumErrorBreakpoints */

/* 7368 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7370 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7374 */	NdrFcShort( 0xc ),	/* 12 */
/* 7376 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7378 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7380 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7382 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter bpErrorType */

/* 7384 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7386 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7388 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppEnum */

/* 7390 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7392 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7394 */	NdrFcShort( 0x1108 ),	/* Type Offset=4360 */

	/* Return value */

/* 7396 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7398 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7400 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Delete */

/* 7402 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7404 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7408 */	NdrFcShort( 0xd ),	/* 13 */
/* 7410 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7414 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7416 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 7418 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7420 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7422 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPendingBreakpoint */

/* 7424 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7426 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7430 */	NdrFcShort( 0x3 ),	/* 3 */
/* 7432 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7434 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7436 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7438 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppPendingBreakpoint */

/* 7440 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7442 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7444 */	NdrFcShort( 0x111e ),	/* Type Offset=4382 */

	/* Return value */

/* 7446 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7448 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7450 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetBreakpointResolution */

/* 7452 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7454 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7458 */	NdrFcShort( 0x4 ),	/* 4 */
/* 7460 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7462 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7464 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7466 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppErrorResolution */

/* 7468 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7470 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7472 */	NdrFcShort( 0x1134 ),	/* Type Offset=4404 */

	/* Return value */

/* 7474 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7476 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7478 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EvaluateAsync */

/* 7480 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7482 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7486 */	NdrFcShort( 0x3 ),	/* 3 */
/* 7488 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7490 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7492 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7494 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwFlags */

/* 7496 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7498 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7500 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pExprCallback */

/* 7502 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 7504 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7506 */	NdrFcShort( 0x114a ),	/* Type Offset=4426 */

	/* Return value */

/* 7508 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7510 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7512 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EvaluateSync */

/* 7514 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7516 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7520 */	NdrFcShort( 0x5 ),	/* 5 */
/* 7522 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 7524 */	NdrFcShort( 0x10 ),	/* 16 */
/* 7526 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7528 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter dwFlags */

/* 7530 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7532 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7534 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwTimeout */

/* 7536 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7538 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7540 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pExprCallback */

/* 7542 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 7544 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7546 */	NdrFcShort( 0x114a ),	/* Type Offset=4426 */

	/* Parameter ppResult */

/* 7548 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7550 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7552 */	NdrFcShort( 0x115c ),	/* Type Offset=4444 */

	/* Return value */

/* 7554 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7556 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7558 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInfo */

/* 7560 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7562 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7566 */	NdrFcShort( 0x3 ),	/* 3 */
/* 7568 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7570 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7572 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7574 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwFields */

/* 7576 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7578 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7580 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pInfo */

/* 7582 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 7584 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7586 */	NdrFcShort( 0x1176 ),	/* Type Offset=4470 */

	/* Return value */

/* 7588 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7590 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7592 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReloadSymbols */

/* 7594 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 7596 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7600 */	NdrFcShort( 0x4 ),	/* 4 */
/* 7602 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7604 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7606 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7608 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pszUrlToSymbols */

/* 7610 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 7612 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7614 */	NdrFcShort( 0x1ae ),	/* Type Offset=430 */

	/* Parameter pbstrDebugMessage */

/* 7616 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 7618 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7620 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Return value */

/* 7622 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7624 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7626 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMvid */

/* 7628 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7630 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7634 */	NdrFcShort( 0x3 ),	/* 3 */
/* 7636 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7638 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7640 */	NdrFcShort( 0x4c ),	/* 76 */
/* 7642 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter mvid */

/* 7644 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 7646 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7648 */	NdrFcShort( 0x46 ),	/* Type Offset=70 */

	/* Return value */

/* 7650 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7652 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7654 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSize */

/* 7656 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 7658 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7662 */	NdrFcShort( 0x5 ),	/* 5 */
/* 7664 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7666 */	NdrFcShort( 0x38 ),	/* 56 */
/* 7668 */	NdrFcShort( 0x40 ),	/* 64 */
/* 7670 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pcNumLines */

/* 7672 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 7674 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7676 */	NdrFcShort( 0xe0a ),	/* Type Offset=3594 */

	/* Parameter pcNumChars */

/* 7678 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 7680 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7682 */	NdrFcShort( 0xe0a ),	/* Type Offset=3594 */

	/* Return value */

/* 7684 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7686 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7688 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetText */

/* 7690 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7692 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7696 */	NdrFcShort( 0x6 ),	/* 6 */
/* 7698 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 7700 */	NdrFcShort( 0x20 ),	/* 32 */
/* 7702 */	NdrFcShort( 0x24 ),	/* 36 */
/* 7704 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x5,		/* 5 */

	/* Parameter pos */

/* 7706 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 7708 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7710 */	NdrFcShort( 0x61e ),	/* Type Offset=1566 */

	/* Parameter cMaxChars */

/* 7712 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7714 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7716 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pText */

/* 7718 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 7720 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7722 */	NdrFcShort( 0x11a2 ),	/* Type Offset=4514 */

	/* Parameter pcNumChars */

/* 7724 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 7726 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7728 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7730 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7732 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 7734 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDocument */

/* 7736 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7738 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7742 */	NdrFcShort( 0x4 ),	/* 4 */
/* 7744 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7746 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7748 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7750 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppDoc */

/* 7752 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 7754 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7756 */	NdrFcShort( 0x11b0 ),	/* Type Offset=4528 */

	/* Return value */

/* 7758 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7760 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7762 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsPositionInDocument */

/* 7764 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7766 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7770 */	NdrFcShort( 0x5 ),	/* 5 */
/* 7772 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7774 */	NdrFcShort( 0x0 ),	/* 0 */
/* 7776 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7778 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pDoc */

/* 7780 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 7782 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7784 */	NdrFcShort( 0x11b4 ),	/* Type Offset=4532 */

	/* Return value */

/* 7786 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7788 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7790 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRange */

/* 7792 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 7794 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7798 */	NdrFcShort( 0x6 ),	/* 6 */
/* 7800 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7802 */	NdrFcShort( 0x58 ),	/* 88 */
/* 7804 */	NdrFcShort( 0x60 ),	/* 96 */
/* 7806 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pBegPosition */

/* 7808 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 7810 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7812 */	NdrFcShort( 0xeac ),	/* Type Offset=3756 */

	/* Parameter pEndPosition */

/* 7814 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 7816 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7818 */	NdrFcShort( 0xeac ),	/* Type Offset=3756 */

	/* Return value */

/* 7820 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7822 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7824 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRange */

/* 7826 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 7828 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7832 */	NdrFcShort( 0x3 ),	/* 3 */
/* 7834 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7836 */	NdrFcShort( 0x38 ),	/* 56 */
/* 7838 */	NdrFcShort( 0x40 ),	/* 64 */
/* 7840 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pdwBegOffset */

/* 7842 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 7844 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7846 */	NdrFcShort( 0xe0a ),	/* Type Offset=3594 */

	/* Parameter pdwEndOffset */

/* 7848 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 7850 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7852 */	NdrFcShort( 0xe0a ),	/* Type Offset=3594 */

	/* Return value */

/* 7854 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7856 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7858 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetOffset */

/* 7860 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 7862 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7866 */	NdrFcShort( 0x4 ),	/* 4 */
/* 7868 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7870 */	NdrFcShort( 0x2c ),	/* 44 */
/* 7872 */	NdrFcShort( 0x34 ),	/* 52 */
/* 7874 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pPosition */

/* 7876 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 7878 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7880 */	NdrFcShort( 0xeac ),	/* Type Offset=3756 */

	/* Return value */

/* 7882 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7884 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 7886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure onInsertText */

/* 7888 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7890 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7894 */	NdrFcShort( 0x4 ),	/* 4 */
/* 7896 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7898 */	NdrFcShort( 0x20 ),	/* 32 */
/* 7900 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7902 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pos */

/* 7904 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 7906 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7908 */	NdrFcShort( 0x61e ),	/* Type Offset=1566 */

	/* Parameter dwNumToInsert */

/* 7910 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7912 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7914 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7916 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7918 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7920 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure onRemoveText */

/* 7922 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7924 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7928 */	NdrFcShort( 0x5 ),	/* 5 */
/* 7930 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7932 */	NdrFcShort( 0x20 ),	/* 32 */
/* 7934 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7936 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pos */

/* 7938 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 7940 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7942 */	NdrFcShort( 0x61e ),	/* Type Offset=1566 */

	/* Parameter dwNumToRemove */

/* 7944 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7946 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7948 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7950 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7952 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7954 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure onReplaceText */

/* 7956 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7958 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7962 */	NdrFcShort( 0x6 ),	/* 6 */
/* 7964 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 7966 */	NdrFcShort( 0x20 ),	/* 32 */
/* 7968 */	NdrFcShort( 0x8 ),	/* 8 */
/* 7970 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pos */

/* 7972 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 7974 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 7976 */	NdrFcShort( 0x61e ),	/* Type Offset=1566 */

	/* Parameter dwNumToReplace */

/* 7978 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 7980 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 7982 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 7984 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 7986 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 7988 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure onUpdateTextAttributes */

/* 7990 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 7992 */	NdrFcLong( 0x0 ),	/* 0 */
/* 7996 */	NdrFcShort( 0x7 ),	/* 7 */
/* 7998 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8000 */	NdrFcShort( 0x20 ),	/* 32 */
/* 8002 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8004 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pos */

/* 8006 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 8008 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8010 */	NdrFcShort( 0x61e ),	/* Type Offset=1566 */

	/* Parameter dwNumToUpdate */

/* 8012 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8014 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8016 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8018 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8020 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8022 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetEngineInterface */

/* 8024 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8026 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8030 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8032 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8034 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8036 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8038 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppUnk */

/* 8040 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8042 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8044 */	NdrFcShort( 0x11c6 ),	/* Type Offset=4550 */

	/* Return value */

/* 8046 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8048 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8050 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8052 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8054 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8058 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8060 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8062 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8064 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8066 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 8068 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8070 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8072 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 8074 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 8076 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8078 */	NdrFcShort( 0x11f2 ),	/* Type Offset=4594 */

	/* Parameter pceltFetched */

/* 8080 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8082 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8084 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8086 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8088 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 8092 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8094 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8098 */	NdrFcShort( 0x6 ),	/* 6 */
/* 8100 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8102 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8104 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8106 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 8108 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8110 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8112 */	NdrFcShort( 0x1204 ),	/* Type Offset=4612 */

	/* Return value */

/* 8114 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8116 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8118 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */

/* 8120 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8122 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8126 */	NdrFcShort( 0x7 ),	/* 7 */
/* 8128 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8130 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8132 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8134 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter pcelt */

/* 8136 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 8138 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8140 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */

/* 8142 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8144 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8146 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8148 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8150 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8154 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8156 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8158 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8160 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8162 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 8164 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8166 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8168 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 8170 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 8172 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8174 */	NdrFcShort( 0x1230 ),	/* Type Offset=4656 */

	/* Parameter pceltFetched */

/* 8176 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8178 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8180 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8182 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8184 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8186 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 8188 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8190 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8194 */	NdrFcShort( 0x6 ),	/* 6 */
/* 8196 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8200 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8202 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 8204 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8206 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8208 */	NdrFcShort( 0x1242 ),	/* Type Offset=4674 */

	/* Return value */

/* 8210 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8212 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8216 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8218 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8222 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8224 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8226 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8228 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8230 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 8232 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8234 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8236 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 8238 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 8240 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8242 */	NdrFcShort( 0x126e ),	/* Type Offset=4718 */

	/* Parameter pceltFetched */

/* 8244 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8246 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8248 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8250 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8252 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 8256 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8258 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8262 */	NdrFcShort( 0x6 ),	/* 6 */
/* 8264 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8268 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8270 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 8272 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8274 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8276 */	NdrFcShort( 0x1280 ),	/* Type Offset=4736 */

	/* Return value */

/* 8278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8280 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8284 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8290 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8292 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8294 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8296 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8298 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 8300 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8302 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8304 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 8306 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 8308 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8310 */	NdrFcShort( 0x12ac ),	/* Type Offset=4780 */

	/* Parameter pceltFetched */

/* 8312 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8314 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8316 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8318 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8320 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8322 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 8324 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8326 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8330 */	NdrFcShort( 0x6 ),	/* 6 */
/* 8332 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8336 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8338 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 8340 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8342 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8344 */	NdrFcShort( 0x12be ),	/* Type Offset=4798 */

	/* Return value */

/* 8346 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8348 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8350 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetIndex */

/* 8352 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8354 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8358 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8360 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8362 */	NdrFcShort( 0x1c ),	/* 28 */
/* 8364 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8366 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pStackFrame */

/* 8368 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 8370 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8372 */	NdrFcShort( 0x129a ),	/* Type Offset=4762 */

	/* Parameter pIndex */

/* 8374 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8376 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8378 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8380 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8382 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8384 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8386 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8388 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8392 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8394 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8396 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8398 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8400 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 8402 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8404 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8406 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 8408 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 8410 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8412 */	NdrFcShort( 0x12ea ),	/* Type Offset=4842 */

	/* Parameter pceltFetched */

/* 8414 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8416 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8418 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8420 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8422 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8424 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 8426 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8428 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8432 */	NdrFcShort( 0x6 ),	/* 6 */
/* 8434 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8438 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8440 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 8442 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8444 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8446 */	NdrFcShort( 0x12fc ),	/* Type Offset=4860 */

	/* Return value */

/* 8448 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8450 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8452 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8454 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8456 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8460 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8462 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8464 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8466 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8468 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 8470 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8472 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8474 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 8476 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 8478 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8480 */	NdrFcShort( 0x1328 ),	/* Type Offset=4904 */

	/* Parameter pceltFetched */

/* 8482 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8484 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8486 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8488 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8490 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8492 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 8494 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8496 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8500 */	NdrFcShort( 0x6 ),	/* 6 */
/* 8502 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8504 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8506 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8508 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 8510 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8512 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8514 */	NdrFcShort( 0x133a ),	/* Type Offset=4922 */

	/* Return value */

/* 8516 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8518 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8520 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8522 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8524 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8528 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8530 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8532 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8534 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8536 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 8538 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8540 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8542 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 8544 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 8546 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8548 */	NdrFcShort( 0x1354 ),	/* Type Offset=4948 */

	/* Parameter pceltFetched */

/* 8550 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8552 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8554 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8556 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8558 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8560 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 8562 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8564 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8568 */	NdrFcShort( 0x6 ),	/* 6 */
/* 8570 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8572 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8574 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8576 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 8578 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8580 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8582 */	NdrFcShort( 0x1366 ),	/* Type Offset=4966 */

	/* Return value */

/* 8584 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8586 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8588 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8590 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8592 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8596 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8598 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8600 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8602 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8604 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 8606 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8608 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8610 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 8612 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 8614 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8616 */	NdrFcShort( 0x1392 ),	/* Type Offset=5010 */

	/* Parameter pceltFetched */

/* 8618 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8620 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8622 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8624 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8626 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8628 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 8630 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8632 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8636 */	NdrFcShort( 0x6 ),	/* 6 */
/* 8638 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8640 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8642 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8644 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 8646 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8648 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8650 */	NdrFcShort( 0x1108 ),	/* Type Offset=4360 */

	/* Return value */

/* 8652 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8654 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8658 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8660 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8664 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8666 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8668 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8670 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8672 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 8674 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8676 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8678 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 8680 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 8682 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8684 */	NdrFcShort( 0x13ba ),	/* Type Offset=5050 */

	/* Parameter pceltFetched */

/* 8686 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8688 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8690 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8692 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8694 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8696 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 8698 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8700 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8704 */	NdrFcShort( 0x6 ),	/* 6 */
/* 8706 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8708 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8710 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8712 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 8714 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8716 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8718 */	NdrFcShort( 0x13cc ),	/* Type Offset=5068 */

	/* Return value */

/* 8720 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8722 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8726 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8728 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8732 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8734 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8736 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8738 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8740 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 8742 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8744 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8746 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 8748 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 8750 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8752 */	NdrFcShort( 0x13e6 ),	/* Type Offset=5094 */

	/* Parameter pceltFetched */

/* 8754 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8756 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8758 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8760 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8762 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8764 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 8766 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8768 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8772 */	NdrFcShort( 0x6 ),	/* 6 */
/* 8774 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8776 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8778 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8780 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 8782 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8784 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8786 */	NdrFcShort( 0x13f8 ),	/* Type Offset=5112 */

	/* Return value */

/* 8788 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8790 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8792 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8794 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8796 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8800 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8802 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8804 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8806 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8808 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 8810 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8812 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8814 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 8816 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 8818 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8820 */	NdrFcShort( 0x1412 ),	/* Type Offset=5138 */

	/* Parameter pceltFetched */

/* 8822 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8824 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8826 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8828 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8830 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8832 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 8834 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8836 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8840 */	NdrFcShort( 0x6 ),	/* 6 */
/* 8842 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8844 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8846 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8848 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 8850 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8852 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8854 */	NdrFcShort( 0xae0 ),	/* Type Offset=2784 */

	/* Return value */

/* 8856 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8858 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8860 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8862 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8864 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8868 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8870 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8872 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8874 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8876 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 8878 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8880 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8882 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 8884 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 8886 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8888 */	NdrFcShort( 0x143a ),	/* Type Offset=5178 */

	/* Parameter pceltFetched */

/* 8890 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8892 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8894 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8896 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8898 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8900 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 8902 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8904 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8908 */	NdrFcShort( 0x6 ),	/* 6 */
/* 8910 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8912 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8914 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8916 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 8918 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8920 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8922 */	NdrFcShort( 0xa9e ),	/* Type Offset=2718 */

	/* Return value */

/* 8924 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8926 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8928 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8930 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8932 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8936 */	NdrFcShort( 0x3 ),	/* 3 */
/* 8938 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 8940 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8942 */	NdrFcShort( 0x24 ),	/* 36 */
/* 8944 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 8946 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 8948 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8950 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 8952 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 8954 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8956 */	NdrFcShort( 0x1450 ),	/* Type Offset=5200 */

	/* Parameter pceltFetched */

/* 8958 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 8960 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8962 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 8964 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8966 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 8968 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 8970 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 8972 */	NdrFcLong( 0x0 ),	/* 0 */
/* 8976 */	NdrFcShort( 0x6 ),	/* 6 */
/* 8978 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 8980 */	NdrFcShort( 0x0 ),	/* 0 */
/* 8982 */	NdrFcShort( 0x8 ),	/* 8 */
/* 8984 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 8986 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 8988 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 8990 */	NdrFcShort( 0x1462 ),	/* Type Offset=5218 */

	/* Return value */

/* 8992 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 8994 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 8996 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 8998 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 9000 */	NdrFcLong( 0x0 ),	/* 0 */
/* 9004 */	NdrFcShort( 0x3 ),	/* 3 */
/* 9006 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 9008 */	NdrFcShort( 0x24 ),	/* 36 */
/* 9010 */	NdrFcShort( 0x24 ),	/* 36 */
/* 9012 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 9014 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 9016 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 9018 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 9020 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 9022 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 9024 */	NdrFcShort( 0x148e ),	/* Type Offset=5262 */

	/* Parameter pceltFetched */

/* 9026 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 9028 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 9030 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 9032 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 9034 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 9036 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 9038 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 9040 */	NdrFcLong( 0x0 ),	/* 0 */
/* 9044 */	NdrFcShort( 0x6 ),	/* 6 */
/* 9046 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 9048 */	NdrFcShort( 0x0 ),	/* 0 */
/* 9050 */	NdrFcShort( 0x8 ),	/* 8 */
/* 9052 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 9054 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 9056 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 9058 */	NdrFcShort( 0x14a0 ),	/* Type Offset=5280 */

	/* Return value */

/* 9060 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 9062 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 9064 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 9066 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 9068 */	NdrFcLong( 0x0 ),	/* 0 */
/* 9072 */	NdrFcShort( 0x3 ),	/* 3 */
/* 9074 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 9076 */	NdrFcShort( 0x24 ),	/* 36 */
/* 9078 */	NdrFcShort( 0x24 ),	/* 36 */
/* 9080 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 9082 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 9084 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 9086 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 9088 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 9090 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 9092 */	NdrFcShort( 0x14cc ),	/* Type Offset=5324 */

	/* Parameter pceltFetched */

/* 9094 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 9096 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 9098 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 9100 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 9102 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 9104 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 9106 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 9108 */	NdrFcLong( 0x0 ),	/* 0 */
/* 9112 */	NdrFcShort( 0x6 ),	/* 6 */
/* 9114 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 9116 */	NdrFcShort( 0x0 ),	/* 0 */
/* 9118 */	NdrFcShort( 0x8 ),	/* 8 */
/* 9120 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 9122 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 9124 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 9126 */	NdrFcShort( 0x14de ),	/* Type Offset=5342 */

	/* Return value */

/* 9128 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 9130 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 9132 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 9134 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 9136 */	NdrFcLong( 0x0 ),	/* 0 */
/* 9140 */	NdrFcShort( 0x3 ),	/* 3 */
/* 9142 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 9144 */	NdrFcShort( 0x8 ),	/* 8 */
/* 9146 */	NdrFcShort( 0x24 ),	/* 36 */
/* 9148 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 9150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 9152 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 9154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 9156 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 9158 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 9160 */	NdrFcShort( 0x14f8 ),	/* Type Offset=5368 */

	/* Parameter pceltFetched */

/* 9162 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 9164 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 9166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 9168 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 9170 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 9172 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 9174 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 9176 */	NdrFcLong( 0x0 ),	/* 0 */
/* 9180 */	NdrFcShort( 0x6 ),	/* 6 */
/* 9182 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 9184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 9186 */	NdrFcShort( 0x8 ),	/* 8 */
/* 9188 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 9190 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 9192 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 9194 */	NdrFcShort( 0x150a ),	/* Type Offset=5386 */

	/* Return value */

/* 9196 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 9198 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 9200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 9202 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 9204 */	NdrFcLong( 0x0 ),	/* 0 */
/* 9208 */	NdrFcShort( 0x3 ),	/* 3 */
/* 9210 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 9212 */	NdrFcShort( 0x8 ),	/* 8 */
/* 9214 */	NdrFcShort( 0x24 ),	/* 36 */
/* 9216 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 9218 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 9220 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 9222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 9224 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 9226 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 9228 */	NdrFcShort( 0x1524 ),	/* Type Offset=5412 */

	/* Parameter pceltFetched */

/* 9230 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 9232 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 9234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 9236 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 9238 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 9240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 9242 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 9244 */	NdrFcLong( 0x0 ),	/* 0 */
/* 9248 */	NdrFcShort( 0x6 ),	/* 6 */
/* 9250 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 9252 */	NdrFcShort( 0x0 ),	/* 0 */
/* 9254 */	NdrFcShort( 0x8 ),	/* 8 */
/* 9256 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 9258 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 9260 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 9262 */	NdrFcShort( 0x1536 ),	/* Type Offset=5430 */

	/* Return value */

/* 9264 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 9266 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 9268 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/*  4 */	NdrFcShort( 0x24 ),	/* Offset= 36 (40) */
/*  6 */	
			0x13, 0x0,	/* FC_OP */
/*  8 */	NdrFcShort( 0xc ),	/* Offset= 12 (20) */
/* 10 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
/* 14 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 16 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 18 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 20 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 22 */	NdrFcShort( 0x8 ),	/* 8 */
/* 24 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (10) */
/* 26 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 28 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 30 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 32 */	NdrFcShort( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x4 ),	/* 4 */
/* 36 */	NdrFcShort( 0x0 ),	/* 0 */
/* 38 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (6) */
/* 40 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 42 */	NdrFcShort( 0xc ),	/* 12 */
/* 44 */	NdrFcShort( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0x0 ),	/* Offset= 0 (46) */
/* 48 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 50 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffeb ),	/* Offset= -21 (30) */
			0x8,		/* FC_LONG */
/* 54 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 56 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 58 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (30) */
/* 60 */	
			0x11, 0x0,	/* FC_RP */
/* 62 */	NdrFcShort( 0x8 ),	/* Offset= 8 (70) */
/* 64 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 66 */	NdrFcShort( 0x8 ),	/* 8 */
/* 68 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 70 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 72 */	NdrFcShort( 0x10 ),	/* 16 */
/* 74 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 76 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 78 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (64) */
			0x5b,		/* FC_END */
/* 82 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 84 */	NdrFcShort( 0x2 ),	/* Offset= 2 (86) */
/* 86 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 88 */	NdrFcLong( 0x53f68191 ),	/* 1408663953 */
/* 92 */	NdrFcShort( 0x7b2f ),	/* 31535 */
/* 94 */	NdrFcShort( 0x4f14 ),	/* 20244 */
/* 96 */	0x8e,		/* 142 */
			0x55,		/* 85 */
/* 98 */	0x40,		/* 64 */
			0xb1,		/* 177 */
/* 100 */	0xb6,		/* 182 */
			0xe5,		/* 229 */
/* 102 */	0xdf,		/* 223 */
			0x66,		/* 102 */
/* 104 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 106 */	NdrFcShort( 0x2 ),	/* Offset= 2 (108) */
/* 108 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 110 */	NdrFcLong( 0x79293cc8 ),	/* 2032745672 */
/* 114 */	NdrFcShort( 0xd9d9 ),	/* -9767 */
/* 116 */	NdrFcShort( 0x43f5 ),	/* 17397 */
/* 118 */	0x97,		/* 151 */
			0xad,		/* 173 */
/* 120 */	0xb,		/* 11 */
			0xcc,		/* 204 */
/* 122 */	0x5a,		/* 90 */
			0x68,		/* 104 */
/* 124 */	0x87,		/* 135 */
			0x76,		/* 118 */
/* 126 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 128 */	NdrFcShort( 0x2 ),	/* Offset= 2 (130) */
/* 130 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 132 */	NdrFcLong( 0xbc827c5e ),	/* -1132299170 */
/* 136 */	NdrFcShort( 0x99ae ),	/* -26194 */
/* 138 */	NdrFcShort( 0x4ac8 ),	/* 19144 */
/* 140 */	0x83,		/* 131 */
			0xad,		/* 173 */
/* 142 */	0x2e,		/* 46 */
			0xa5,		/* 165 */
/* 144 */	0xc2,		/* 194 */
			0x3,		/* 3 */
/* 146 */	0x43,		/* 67 */
			0x33,		/* 51 */
/* 148 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 150 */	NdrFcShort( 0x2 ),	/* Offset= 2 (152) */
/* 152 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 154 */	NdrFcLong( 0x59c9dc99 ),	/* 1506401433 */
/* 158 */	NdrFcShort( 0x3eff ),	/* 16127 */
/* 160 */	NdrFcShort( 0x4ff3 ),	/* 20467 */
/* 162 */	0xb2,		/* 178 */
			0x1,		/* 1 */
/* 164 */	0x98,		/* 152 */
			0xac,		/* 172 */
/* 166 */	0xd0,		/* 208 */
			0x1b,		/* 27 */
/* 168 */	0xd,		/* 13 */
			0x87,		/* 135 */
/* 170 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 172 */	NdrFcShort( 0x2 ),	/* Offset= 2 (174) */
/* 174 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 176 */	NdrFcLong( 0xf3062547 ),	/* -217701049 */
/* 180 */	NdrFcShort( 0x43d8 ),	/* 17368 */
/* 182 */	NdrFcShort( 0x4dc2 ),	/* 19906 */
/* 184 */	0xb1,		/* 177 */
			0x8e,		/* 142 */
/* 186 */	0xe1,		/* 225 */
			0x46,		/* 70 */
/* 188 */	0xf,		/* 15 */
			0xf2,		/* 242 */
/* 190 */	0xc4,		/* 196 */
			0x22,		/* 34 */
/* 192 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 194 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 196 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 198 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 200 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 202 */	NdrFcShort( 0xffffff7c ),	/* Offset= -132 (70) */
/* 204 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 206 */	NdrFcLong( 0x8d36beb8 ),	/* -1925792072 */
/* 210 */	NdrFcShort( 0x9bfe ),	/* -25602 */
/* 212 */	NdrFcShort( 0x47dd ),	/* 18397 */
/* 214 */	0xa1,		/* 161 */
			0x1b,		/* 27 */
/* 216 */	0x7b,		/* 123 */
			0xa1,		/* 161 */
/* 218 */	0xde,		/* 222 */
			0x18,		/* 24 */
/* 220 */	0xe4,		/* 228 */
			0x49,		/* 73 */
/* 222 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 224 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (204) */
/* 226 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 228 */	NdrFcShort( 0x10 ),	/* 16 */
/* 230 */	NdrFcShort( 0x2 ),	/* 2 */
/* 232 */	NdrFcLong( 0x0 ),	/* 0 */
/* 236 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 238 */	NdrFcLong( 0x1 ),	/* 1 */
/* 242 */	NdrFcShort( 0xffffff54 ),	/* Offset= -172 (70) */
/* 244 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 246 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 248 */	NdrFcShort( 0x2 ),	/* Offset= 2 (250) */
/* 250 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 252 */	NdrFcLong( 0x43286fea ),	/* 1126723562 */
/* 256 */	NdrFcShort( 0x6997 ),	/* 27031 */
/* 258 */	NdrFcShort( 0x4543 ),	/* 17731 */
/* 260 */	0x80,		/* 128 */
			0x3e,		/* 62 */
/* 262 */	0x60,		/* 96 */
			0xa2,		/* 162 */
/* 264 */	0xc,		/* 12 */
			0x47,		/* 71 */
/* 266 */	0x3d,		/* 61 */
			0xe5,		/* 229 */
/* 268 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 270 */	NdrFcShort( 0x2 ),	/* Offset= 2 (272) */
/* 272 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 274 */	NdrFcLong( 0x96c74ef4 ),	/* -1765323020 */
/* 278 */	NdrFcShort( 0x185d ),	/* 6237 */
/* 280 */	NdrFcShort( 0x4f9a ),	/* 20378 */
/* 282 */	0x8a,		/* 138 */
			0x43,		/* 67 */
/* 284 */	0x4d,		/* 77 */
			0x27,		/* 39 */
/* 286 */	0x23,		/* 35 */
			0x75,		/* 117 */
/* 288 */	0x8e,		/* 142 */
			0xa,		/* 10 */
/* 290 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 292 */	NdrFcLong( 0x426e255c ),	/* 1114514780 */
/* 296 */	NdrFcShort( 0xf1ce ),	/* -3634 */
/* 298 */	NdrFcShort( 0x4d02 ),	/* 19714 */
/* 300 */	0xa9,		/* 169 */
			0x31,		/* 49 */
/* 302 */	0xf9,		/* 249 */
			0xa2,		/* 162 */
/* 304 */	0x54,		/* 84 */
			0xbf,		/* 191 */
/* 306 */	0x7f,		/* 127 */
			0xf,		/* 15 */
/* 308 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 310 */	NdrFcLong( 0x17bf8fa3 ),	/* 398430115 */
/* 314 */	NdrFcShort( 0x4c5a ),	/* 19546 */
/* 316 */	NdrFcShort( 0x49a3 ),	/* 18851 */
/* 318 */	0xb2,		/* 178 */
			0xf8,		/* 248 */
/* 320 */	0x59,		/* 89 */
			0x42,		/* 66 */
/* 322 */	0xe1,		/* 225 */
			0xea,		/* 234 */
/* 324 */	0x28,		/* 40 */
			0x7e,		/* 126 */
/* 326 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 328 */	NdrFcLong( 0x79293cc8 ),	/* 2032745672 */
/* 332 */	NdrFcShort( 0xd9d9 ),	/* -9767 */
/* 334 */	NdrFcShort( 0x43f5 ),	/* 17397 */
/* 336 */	0x97,		/* 151 */
			0xad,		/* 173 */
/* 338 */	0xb,		/* 11 */
			0xcc,		/* 204 */
/* 340 */	0x5a,		/* 90 */
			0x68,		/* 104 */
/* 342 */	0x87,		/* 135 */
			0x76,		/* 118 */
/* 344 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 346 */	NdrFcLong( 0x43286fea ),	/* 1126723562 */
/* 350 */	NdrFcShort( 0x6997 ),	/* 27031 */
/* 352 */	NdrFcShort( 0x4543 ),	/* 17731 */
/* 354 */	0x80,		/* 128 */
			0x3e,		/* 62 */
/* 356 */	0x60,		/* 96 */
			0xa2,		/* 162 */
/* 358 */	0xc,		/* 12 */
			0x47,		/* 71 */
/* 360 */	0x3d,		/* 61 */
			0xe5,		/* 229 */
/* 362 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 364 */	NdrFcLong( 0x69d172ef ),	/* 1775334127 */
/* 368 */	NdrFcShort( 0xf2c4 ),	/* -3388 */
/* 370 */	NdrFcShort( 0x44e1 ),	/* 17633 */
/* 372 */	0x89,		/* 137 */
			0xf7,		/* 247 */
/* 374 */	0xc8,		/* 200 */
			0x62,		/* 98 */
/* 376 */	0x31,		/* 49 */
			0xe7,		/* 231 */
/* 378 */	0x6,		/* 6 */
			0xe9,		/* 233 */
/* 380 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 382 */	NdrFcLong( 0x423238d6 ),	/* 1110587606 */
/* 386 */	NdrFcShort( 0xda42 ),	/* -9662 */
/* 388 */	NdrFcShort( 0x4989 ),	/* 18825 */
/* 390 */	0x96,		/* 150 */
			0xfb,		/* 251 */
/* 392 */	0x6b,		/* 107 */
			0xba,		/* 186 */
/* 394 */	0x26,		/* 38 */
			0xe7,		/* 231 */
/* 396 */	0x2e,		/* 46 */
			0x9,		/* 9 */
/* 398 */	
			0x11, 0x0,	/* FC_RP */
/* 400 */	NdrFcShort( 0x2 ),	/* Offset= 2 (402) */
/* 402 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 404 */	NdrFcShort( 0x10 ),	/* 16 */
/* 406 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 408 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 410 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 412 */	NdrFcShort( 0xfffffeaa ),	/* Offset= -342 (70) */
/* 414 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 416 */	
			0x14, 0x0,	/* FC_FP */
/* 418 */	NdrFcShort( 0x2 ),	/* Offset= 2 (420) */
/* 420 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 422 */	NdrFcShort( 0x4 ),	/* 4 */
/* 424 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 426 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 428 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 430 */	
			0x14, 0x8,	/* FC_FP [simple_pointer] */
/* 432 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 434 */	
			0x12, 0x0,	/* FC_UP */
/* 436 */	NdrFcShort( 0xfffffe60 ),	/* Offset= -416 (20) */
/* 438 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 440 */	NdrFcShort( 0x0 ),	/* 0 */
/* 442 */	NdrFcShort( 0x4 ),	/* 4 */
/* 444 */	NdrFcShort( 0x0 ),	/* 0 */
/* 446 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (434) */
/* 448 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 450 */	NdrFcLong( 0xade2eeb9 ),	/* -1377636679 */
/* 454 */	NdrFcShort( 0xfc85 ),	/* -891 */
/* 456 */	NdrFcShort( 0x4f5b ),	/* 20315 */
/* 458 */	0xb5,		/* 181 */
			0xd9,		/* 217 */
/* 460 */	0xd4,		/* 212 */
			0x31,		/* 49 */
/* 462 */	0xb4,		/* 180 */
			0xaa,		/* 170 */
/* 464 */	0xc3,		/* 195 */
			0x1a,		/* 26 */
/* 466 */	
			0x11, 0x0,	/* FC_RP */
/* 468 */	NdrFcShort( 0x2 ),	/* Offset= 2 (470) */
/* 470 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 472 */	NdrFcShort( 0x10 ),	/* 16 */
/* 474 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 476 */	NdrFcShort( 0x3c ),	/* x86 Stack size/offset = 60 */
/* 478 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 480 */	NdrFcShort( 0xfffffe66 ),	/* Offset= -410 (70) */
/* 482 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 484 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 486 */	NdrFcShort( 0xffffff72 ),	/* Offset= -142 (344) */
/* 488 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 490 */	NdrFcLong( 0x6015fd18 ),	/* 1612053784 */
/* 494 */	NdrFcShort( 0x8257 ),	/* -32169 */
/* 496 */	NdrFcShort( 0x4df3 ),	/* 19955 */
/* 498 */	0xac,		/* 172 */
			0x42,		/* 66 */
/* 500 */	0xf0,		/* 240 */
			0x74,		/* 116 */
/* 502 */	0xde,		/* 222 */
			0xdd,		/* 221 */
/* 504 */	0x4c,		/* 76 */
			0xbd,		/* 189 */
/* 506 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 508 */	NdrFcShort( 0x2 ),	/* Offset= 2 (510) */
/* 510 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 512 */	NdrFcLong( 0x6e215ef3 ),	/* 1847680755 */
/* 516 */	NdrFcShort( 0xe44c ),	/* -7092 */
/* 518 */	NdrFcShort( 0x44d1 ),	/* 17617 */
/* 520 */	0xb7,		/* 183 */
			0xba,		/* 186 */
/* 522 */	0xb2,		/* 178 */
			0x40,		/* 64 */
/* 524 */	0x1f,		/* 31 */
			0x7d,		/* 125 */
/* 526 */	0xc2,		/* 194 */
			0x3d,		/* 61 */
/* 528 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 530 */	NdrFcShort( 0x2 ),	/* Offset= 2 (532) */
/* 532 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 534 */	NdrFcLong( 0x70d2dc1e ),	/* 1892867102 */
/* 538 */	NdrFcShort( 0x4dcc ),	/* 19916 */
/* 540 */	NdrFcShort( 0x4786 ),	/* 18310 */
/* 542 */	0xa0,		/* 160 */
			0x72,		/* 114 */
/* 544 */	0x9a,		/* 154 */
			0x3b,		/* 59 */
/* 546 */	0x60,		/* 96 */
			0xc,		/* 12 */
/* 548 */	0x21,		/* 33 */
			0x6b,		/* 107 */
/* 550 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 552 */	NdrFcShort( 0x2 ),	/* Offset= 2 (554) */
/* 554 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 556 */	NdrFcLong( 0x61d986ec ),	/* 1641645804 */
/* 560 */	NdrFcShort( 0x1eac ),	/* 7852 */
/* 562 */	NdrFcShort( 0x46b6 ),	/* 18102 */
/* 564 */	0x90,		/* 144 */
			0xff,		/* 255 */
/* 566 */	0x40,		/* 64 */
			0x2a,		/* 42 */
/* 568 */	0x0,		/* 0 */
			0x8f,		/* 143 */
/* 570 */	0x15,		/* 21 */
			0xd1,		/* 209 */
/* 572 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 574 */	NdrFcShort( 0xfffffef6 ),	/* Offset= -266 (308) */
/* 576 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 578 */	NdrFcLong( 0xbdde0eee ),	/* -1109520658 */
/* 582 */	NdrFcShort( 0x3b8d ),	/* 15245 */
/* 584 */	NdrFcShort( 0x4c82 ),	/* 19586 */
/* 586 */	0xb5,		/* 181 */
			0x29,		/* 41 */
/* 588 */	0x33,		/* 51 */
			0xf1,		/* 241 */
/* 590 */	0x6b,		/* 107 */
			0x42,		/* 66 */
/* 592 */	0x83,		/* 131 */
			0x2e,		/* 46 */
/* 594 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 596 */	NdrFcShort( 0x2 ),	/* Offset= 2 (598) */
/* 598 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 600 */	NdrFcLong( 0xad47a80b ),	/* -1387812853 */
/* 604 */	NdrFcShort( 0xeda7 ),	/* -4697 */
/* 606 */	NdrFcShort( 0x459e ),	/* 17822 */
/* 608 */	0xaf,		/* 175 */
			0x82,		/* 130 */
/* 610 */	0x64,		/* 100 */
			0x7c,		/* 124 */
/* 612 */	0xc9,		/* 201 */
			0xfb,		/* 251 */
/* 614 */	0xaa,		/* 170 */
			0x50,		/* 80 */
/* 616 */	0x11, 0x0,	/* FC_RP */
/* 618 */	NdrFcShort( 0x2 ),	/* Offset= 2 (620) */
/* 620 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 622 */	NdrFcShort( 0x24 ),	/* 36 */
/* 624 */	NdrFcShort( 0x0 ),	/* 0 */
/* 626 */	NdrFcShort( 0x16 ),	/* Offset= 22 (648) */
/* 628 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 630 */	NdrFcShort( 0xfffffef4 ),	/* Offset= -268 (362) */
/* 632 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 634 */	NdrFcShort( 0xffffff3c ),	/* Offset= -196 (438) */
/* 636 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 638 */	NdrFcShort( 0xffffff38 ),	/* Offset= -200 (438) */
/* 640 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 642 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 644 */	NdrFcShort( 0xfffffdc2 ),	/* Offset= -574 (70) */
/* 646 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 648 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 650 */	NdrFcShort( 0x2 ),	/* Offset= 2 (652) */
/* 652 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 654 */	NdrFcLong( 0x8e4bbd34 ),	/* -1907638988 */
/* 658 */	NdrFcShort( 0xa2f4 ),	/* -23820 */
/* 660 */	NdrFcShort( 0x41ef ),	/* 16879 */
/* 662 */	0x87,		/* 135 */
			0xb5,		/* 181 */
/* 664 */	0xc5,		/* 197 */
			0x63,		/* 99 */
/* 666 */	0xb4,		/* 180 */
			0xad,		/* 173 */
/* 668 */	0x6e,		/* 110 */
			0xe7,		/* 231 */
/* 670 */	
			0x14, 0x0,	/* FC_FP */
/* 672 */	NdrFcShort( 0xffffffcc ),	/* Offset= -52 (620) */
/* 674 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 676 */	NdrFcShort( 0x2 ),	/* Offset= 2 (678) */
/* 678 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 680 */	NdrFcLong( 0x978baee7 ),	/* -1752453401 */
/* 684 */	NdrFcShort( 0xbd4c ),	/* -17076 */
/* 686 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 688 */	0x92,		/* 146 */
			0x38,		/* 56 */
/* 690 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 692 */	0x24,		/* 36 */
			0x48,		/* 72 */
/* 694 */	0x79,		/* 121 */
			0x9a,		/* 154 */
/* 696 */	
			0x14, 0x0,	/* FC_FP */
/* 698 */	NdrFcShort( 0x2 ),	/* Offset= 2 (700) */
/* 700 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 702 */	NdrFcShort( 0x10 ),	/* 16 */
/* 704 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 706 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 708 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 710 */	NdrFcShort( 0xfffffd80 ),	/* Offset= -640 (70) */
/* 712 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 714 */	
			0x12, 0x0,	/* FC_UP */
/* 716 */	NdrFcShort( 0x3c4 ),	/* Offset= 964 (1680) */
/* 718 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 720 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 722 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 724 */	NdrFcShort( 0x2 ),	/* Offset= 2 (726) */
/* 726 */	NdrFcShort( 0x10 ),	/* 16 */
/* 728 */	NdrFcShort( 0x2f ),	/* 47 */
/* 730 */	NdrFcLong( 0x14 ),	/* 20 */
/* 734 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 736 */	NdrFcLong( 0x3 ),	/* 3 */
/* 740 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 742 */	NdrFcLong( 0x11 ),	/* 17 */
/* 746 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 748 */	NdrFcLong( 0x2 ),	/* 2 */
/* 752 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 754 */	NdrFcLong( 0x4 ),	/* 4 */
/* 758 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 760 */	NdrFcLong( 0x5 ),	/* 5 */
/* 764 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 766 */	NdrFcLong( 0xb ),	/* 11 */
/* 770 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 772 */	NdrFcLong( 0xa ),	/* 10 */
/* 776 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 778 */	NdrFcLong( 0x6 ),	/* 6 */
/* 782 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (1014) */
/* 784 */	NdrFcLong( 0x7 ),	/* 7 */
/* 788 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 790 */	NdrFcLong( 0x8 ),	/* 8 */
/* 794 */	NdrFcShort( 0xfffffe98 ),	/* Offset= -360 (434) */
/* 796 */	NdrFcLong( 0xd ),	/* 13 */
/* 800 */	NdrFcShort( 0xdc ),	/* Offset= 220 (1020) */
/* 802 */	NdrFcLong( 0x9 ),	/* 9 */
/* 806 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (1038) */
/* 808 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 812 */	NdrFcShort( 0xf4 ),	/* Offset= 244 (1056) */
/* 814 */	NdrFcLong( 0x24 ),	/* 36 */
/* 818 */	NdrFcShort( 0x314 ),	/* Offset= 788 (1606) */
/* 820 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 824 */	NdrFcShort( 0x30e ),	/* Offset= 782 (1606) */
/* 826 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 830 */	NdrFcShort( 0x30c ),	/* Offset= 780 (1610) */
/* 832 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 836 */	NdrFcShort( 0x30a ),	/* Offset= 778 (1614) */
/* 838 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 842 */	NdrFcShort( 0x308 ),	/* Offset= 776 (1618) */
/* 844 */	NdrFcLong( 0x4014 ),	/* 16404 */
/* 848 */	NdrFcShort( 0x306 ),	/* Offset= 774 (1622) */
/* 850 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 854 */	NdrFcShort( 0x304 ),	/* Offset= 772 (1626) */
/* 856 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 860 */	NdrFcShort( 0x302 ),	/* Offset= 770 (1630) */
/* 862 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 866 */	NdrFcShort( 0x2ec ),	/* Offset= 748 (1614) */
/* 868 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 872 */	NdrFcShort( 0x2ea ),	/* Offset= 746 (1618) */
/* 874 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 878 */	NdrFcShort( 0x2f4 ),	/* Offset= 756 (1634) */
/* 880 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 884 */	NdrFcShort( 0x2ea ),	/* Offset= 746 (1630) */
/* 886 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 890 */	NdrFcShort( 0x2ec ),	/* Offset= 748 (1638) */
/* 892 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 896 */	NdrFcShort( 0x2ea ),	/* Offset= 746 (1642) */
/* 898 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 902 */	NdrFcShort( 0x2e8 ),	/* Offset= 744 (1646) */
/* 904 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 908 */	NdrFcShort( 0x2e6 ),	/* Offset= 742 (1650) */
/* 910 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 914 */	NdrFcShort( 0x2e4 ),	/* Offset= 740 (1654) */
/* 916 */	NdrFcLong( 0x10 ),	/* 16 */
/* 920 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 922 */	NdrFcLong( 0x12 ),	/* 18 */
/* 926 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 928 */	NdrFcLong( 0x13 ),	/* 19 */
/* 932 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 934 */	NdrFcLong( 0x15 ),	/* 21 */
/* 938 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 940 */	NdrFcLong( 0x16 ),	/* 22 */
/* 944 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 946 */	NdrFcLong( 0x17 ),	/* 23 */
/* 950 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 952 */	NdrFcLong( 0xe ),	/* 14 */
/* 956 */	NdrFcShort( 0x2c2 ),	/* Offset= 706 (1662) */
/* 958 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 962 */	NdrFcShort( 0x2c6 ),	/* Offset= 710 (1672) */
/* 964 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 968 */	NdrFcShort( 0x2c4 ),	/* Offset= 708 (1676) */
/* 970 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 974 */	NdrFcShort( 0x280 ),	/* Offset= 640 (1614) */
/* 976 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 980 */	NdrFcShort( 0x27e ),	/* Offset= 638 (1618) */
/* 982 */	NdrFcLong( 0x4015 ),	/* 16405 */
/* 986 */	NdrFcShort( 0x27c ),	/* Offset= 636 (1622) */
/* 988 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 992 */	NdrFcShort( 0x272 ),	/* Offset= 626 (1618) */
/* 994 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 998 */	NdrFcShort( 0x26c ),	/* Offset= 620 (1618) */
/* 1000 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1004 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1004) */
/* 1006 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1010 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1010) */
/* 1012 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (1011) */
/* 1014 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 1016 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1018 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1020 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1022 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1026 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1028 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1030 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1032 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1034 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1036 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1038 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1040 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 1044 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1046 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1048 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1050 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1052 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1054 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1056 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 1058 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1060) */
/* 1060 */	
			0x12, 0x0,	/* FC_UP */
/* 1062 */	NdrFcShort( 0x20e ),	/* Offset= 526 (1588) */
/* 1064 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 1066 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1068 */	NdrFcShort( 0xa ),	/* 10 */
/* 1070 */	NdrFcLong( 0x8 ),	/* 8 */
/* 1074 */	NdrFcShort( 0x58 ),	/* Offset= 88 (1162) */
/* 1076 */	NdrFcLong( 0xd ),	/* 13 */
/* 1080 */	NdrFcShort( 0x8a ),	/* Offset= 138 (1218) */
/* 1082 */	NdrFcLong( 0x9 ),	/* 9 */
/* 1086 */	NdrFcShort( 0xb8 ),	/* Offset= 184 (1270) */
/* 1088 */	NdrFcLong( 0xc ),	/* 12 */
/* 1092 */	NdrFcShort( 0xe0 ),	/* Offset= 224 (1316) */
/* 1094 */	NdrFcLong( 0x24 ),	/* 36 */
/* 1098 */	NdrFcShort( 0x138 ),	/* Offset= 312 (1410) */
/* 1100 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 1104 */	NdrFcShort( 0x142 ),	/* Offset= 322 (1426) */
/* 1106 */	NdrFcLong( 0x10 ),	/* 16 */
/* 1110 */	NdrFcShort( 0x15a ),	/* Offset= 346 (1456) */
/* 1112 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1116 */	NdrFcShort( 0x172 ),	/* Offset= 370 (1486) */
/* 1118 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1122 */	NdrFcShort( 0x18a ),	/* Offset= 394 (1516) */
/* 1124 */	NdrFcLong( 0x14 ),	/* 20 */
/* 1128 */	NdrFcShort( 0x1a2 ),	/* Offset= 418 (1546) */
/* 1130 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (1129) */
/* 1132 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1134 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1136 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1138 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1140 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1142 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1144 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1148 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1150 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1154 */	0x12, 0x0,	/* FC_UP */
/* 1156 */	NdrFcShort( 0xfffffb90 ),	/* Offset= -1136 (20) */
/* 1158 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1160 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1162 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1164 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1166 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1168 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1170 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1172 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1174 */	0x11, 0x0,	/* FC_RP */
/* 1176 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (1132) */
/* 1178 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1180 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1182 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1184 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1190 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1192 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1194 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1196 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1198 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1200 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1202 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1204 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1208 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1212 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1214 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1182) */
/* 1216 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1218 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1220 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1222 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1224 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1230) */
/* 1226 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1228 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1230 */	
			0x11, 0x0,	/* FC_RP */
/* 1232 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1200) */
/* 1234 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1236 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 1240 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1242 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1244 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1246 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1248 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1250 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1252 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1254 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1256 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1260 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1264 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1266 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1234) */
/* 1268 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1270 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1274 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1276 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1282) */
/* 1278 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1280 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1282 */	
			0x11, 0x0,	/* FC_RP */
/* 1284 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1252) */
/* 1286 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1288 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1290 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1294 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1296 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1298 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1302 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1304 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1306 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1308 */	0x12, 0x0,	/* FC_UP */
/* 1310 */	NdrFcShort( 0x172 ),	/* Offset= 370 (1680) */
/* 1312 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1314 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1316 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1318 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1320 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1322 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1328) */
/* 1324 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1326 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1328 */	
			0x11, 0x0,	/* FC_RP */
/* 1330 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (1286) */
/* 1332 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1334 */	NdrFcLong( 0x2f ),	/* 47 */
/* 1338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1340 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1342 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1344 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1346 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1348 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1350 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1352 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1354 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1356 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1358 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1360 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1362 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1364 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1366 */	NdrFcShort( 0xa ),	/* Offset= 10 (1376) */
/* 1368 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1370 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1372 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (1332) */
/* 1374 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1376 */	
			0x12, 0x0,	/* FC_UP */
/* 1378 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (1350) */
/* 1380 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1382 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1384 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1388 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1390 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1392 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1396 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1400 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1402 */	0x12, 0x0,	/* FC_UP */
/* 1404 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (1360) */
/* 1406 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1408 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1410 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1412 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1414 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1416 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1422) */
/* 1418 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1420 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1422 */	
			0x11, 0x0,	/* FC_RP */
/* 1424 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (1380) */
/* 1426 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1428 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1430 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1432 */	NdrFcShort( 0xa ),	/* Offset= 10 (1442) */
/* 1434 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1436 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1438 */	NdrFcShort( 0xfffffaa8 ),	/* Offset= -1368 (70) */
/* 1440 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1442 */	
			0x11, 0x0,	/* FC_RP */
/* 1444 */	NdrFcShort( 0xffffff0c ),	/* Offset= -244 (1200) */
/* 1446 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1448 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1450 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1452 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1454 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1456 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1458 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1460 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1462 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1464 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1466 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1468 */	0x12, 0x0,	/* FC_UP */
/* 1470 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1446) */
/* 1472 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1474 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1476 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1478 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1480 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1482 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1484 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1486 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1488 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1490 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1492 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1494 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1496 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1498 */	0x12, 0x0,	/* FC_UP */
/* 1500 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1476) */
/* 1502 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1504 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1506 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1508 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1510 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1512 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1514 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1516 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1518 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1520 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1522 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1524 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1526 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1528 */	0x12, 0x0,	/* FC_UP */
/* 1530 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1506) */
/* 1532 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1534 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1536 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1538 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1540 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1542 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1544 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1546 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1548 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1550 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1552 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1554 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1556 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1558 */	0x12, 0x0,	/* FC_UP */
/* 1560 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (1536) */
/* 1562 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1564 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1566 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 1568 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1570 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1572 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1574 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1576 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1578 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1580 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 1582 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1584 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (1566) */
/* 1586 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1588 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1590 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1592 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (1574) */
/* 1594 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1594) */
/* 1596 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1598 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1600 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1602 */	NdrFcShort( 0xfffffde6 ),	/* Offset= -538 (1064) */
/* 1604 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1606 */	
			0x12, 0x0,	/* FC_UP */
/* 1608 */	NdrFcShort( 0xffffff08 ),	/* Offset= -248 (1360) */
/* 1610 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1612 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 1614 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1616 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 1618 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1620 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1622 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1624 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 1626 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1628 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 1630 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1632 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 1634 */	
			0x12, 0x0,	/* FC_UP */
/* 1636 */	NdrFcShort( 0xfffffd92 ),	/* Offset= -622 (1014) */
/* 1638 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 1640 */	NdrFcShort( 0xfffffb4a ),	/* Offset= -1206 (434) */
/* 1642 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 1644 */	NdrFcShort( 0xfffffe32 ),	/* Offset= -462 (1182) */
/* 1646 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 1648 */	NdrFcShort( 0xfffffe62 ),	/* Offset= -414 (1234) */
/* 1650 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 1652 */	NdrFcShort( 0xfffffdac ),	/* Offset= -596 (1056) */
/* 1654 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 1656 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1658) */
/* 1658 */	
			0x12, 0x0,	/* FC_UP */
/* 1660 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1680) */
/* 1662 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 1664 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1666 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 1668 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 1670 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1672 */	
			0x12, 0x0,	/* FC_UP */
/* 1674 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1662) */
/* 1676 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1678 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 1680 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 1682 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1684 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1686 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1686) */
/* 1688 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1690 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1692 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1694 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1696 */	NdrFcShort( 0xfffffc2e ),	/* Offset= -978 (718) */
/* 1698 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1700 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1702 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1704 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1706 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1708 */	NdrFcShort( 0xfffffc1e ),	/* Offset= -994 (714) */
/* 1710 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1712 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1714) */
/* 1714 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1716 */	NdrFcLong( 0x8d14bca6 ),	/* -1928020826 */
/* 1720 */	NdrFcShort( 0x34ce ),	/* 13518 */
/* 1722 */	NdrFcShort( 0x4efe ),	/* 20222 */
/* 1724 */	0xac,		/* 172 */
			0x7e,		/* 126 */
/* 1726 */	0xa,		/* 10 */
			0xbc,		/* 188 */
/* 1728 */	0x61,		/* 97 */
			0xda,		/* 218 */
/* 1730 */	0xdb,		/* 219 */
			0x20,		/* 32 */
/* 1732 */	
			0x11, 0x0,	/* FC_RP */
/* 1734 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1754) */
/* 1736 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1738 */	NdrFcLong( 0x69d172ef ),	/* 1775334127 */
/* 1742 */	NdrFcShort( 0xf2c4 ),	/* -3388 */
/* 1744 */	NdrFcShort( 0x44e1 ),	/* 17633 */
/* 1746 */	0x89,		/* 137 */
			0xf7,		/* 247 */
/* 1748 */	0xc8,		/* 200 */
			0x62,		/* 98 */
/* 1750 */	0x31,		/* 49 */
			0xe7,		/* 231 */
/* 1752 */	0x6,		/* 6 */
			0xe9,		/* 233 */
/* 1754 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1758 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1760 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1762 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1764 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1766 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1768 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1736) */
/* 1770 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1772 */	
			0x11, 0x0,	/* FC_RP */
/* 1774 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1794) */
/* 1776 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1778 */	NdrFcLong( 0x426e255c ),	/* 1114514780 */
/* 1782 */	NdrFcShort( 0xf1ce ),	/* -3634 */
/* 1784 */	NdrFcShort( 0x4d02 ),	/* 19714 */
/* 1786 */	0xa9,		/* 169 */
			0x31,		/* 49 */
/* 1788 */	0xf9,		/* 249 */
			0xa2,		/* 162 */
/* 1790 */	0x54,		/* 84 */
			0xbf,		/* 191 */
/* 1792 */	0x7f,		/* 127 */
			0xf,		/* 15 */
/* 1794 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1796 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1798 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1800 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1802 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1804 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1806 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1808 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (1776) */
/* 1810 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1812 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1814 */	NdrFcLong( 0xade2eeb9 ),	/* -1377636679 */
/* 1818 */	NdrFcShort( 0xfc85 ),	/* -891 */
/* 1820 */	NdrFcShort( 0x4f5b ),	/* 20315 */
/* 1822 */	0xb5,		/* 181 */
			0xd9,		/* 217 */
/* 1824 */	0xd4,		/* 212 */
			0x31,		/* 49 */
/* 1826 */	0xb4,		/* 180 */
			0xaa,		/* 170 */
/* 1828 */	0xc3,		/* 195 */
			0x1a,		/* 26 */
/* 1830 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1832 */	NdrFcLong( 0x6015fd18 ),	/* 1612053784 */
/* 1836 */	NdrFcShort( 0x8257 ),	/* -32169 */
/* 1838 */	NdrFcShort( 0x4df3 ),	/* 19955 */
/* 1840 */	0xac,		/* 172 */
			0x42,		/* 66 */
/* 1842 */	0xf0,		/* 240 */
			0x74,		/* 116 */
/* 1844 */	0xde,		/* 222 */
			0xdd,		/* 221 */
/* 1846 */	0x4c,		/* 76 */
			0xbd,		/* 189 */
/* 1848 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1850 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1852) */
/* 1852 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1854 */	NdrFcLong( 0x6e215ef3 ),	/* 1847680755 */
/* 1858 */	NdrFcShort( 0xe44c ),	/* -7092 */
/* 1860 */	NdrFcShort( 0x44d1 ),	/* 17617 */
/* 1862 */	0xb7,		/* 183 */
			0xba,		/* 186 */
/* 1864 */	0xb2,		/* 178 */
			0x40,		/* 64 */
/* 1866 */	0x1f,		/* 31 */
			0x7d,		/* 125 */
/* 1868 */	0xc2,		/* 194 */
			0x3d,		/* 61 */
/* 1870 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1872 */	NdrFcLong( 0x423238d6 ),	/* 1110587606 */
/* 1876 */	NdrFcShort( 0xda42 ),	/* -9662 */
/* 1878 */	NdrFcShort( 0x4989 ),	/* 18825 */
/* 1880 */	0x96,		/* 150 */
			0xfb,		/* 251 */
/* 1882 */	0x6b,		/* 107 */
			0xba,		/* 186 */
/* 1884 */	0x26,		/* 38 */
			0xe7,		/* 231 */
/* 1886 */	0x2e,		/* 46 */
			0x9,		/* 9 */
/* 1888 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1890 */	NdrFcLong( 0x79293cc8 ),	/* 2032745672 */
/* 1894 */	NdrFcShort( 0xd9d9 ),	/* -9767 */
/* 1896 */	NdrFcShort( 0x43f5 ),	/* 17397 */
/* 1898 */	0x97,		/* 151 */
			0xad,		/* 173 */
/* 1900 */	0xb,		/* 11 */
			0xcc,		/* 204 */
/* 1902 */	0x5a,		/* 90 */
			0x68,		/* 104 */
/* 1904 */	0x87,		/* 135 */
			0x76,		/* 118 */
/* 1906 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1908 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1910) */
/* 1910 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1912 */	NdrFcLong( 0x43286fea ),	/* 1126723562 */
/* 1916 */	NdrFcShort( 0x6997 ),	/* 27031 */
/* 1918 */	NdrFcShort( 0x4543 ),	/* 17731 */
/* 1920 */	0x80,		/* 128 */
			0x3e,		/* 62 */
/* 1922 */	0x60,		/* 96 */
			0xa2,		/* 162 */
/* 1924 */	0xc,		/* 12 */
			0x47,		/* 71 */
/* 1926 */	0x3d,		/* 61 */
			0xe5,		/* 229 */
/* 1928 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1930 */	NdrFcLong( 0xba105b52 ),	/* -1173333166 */
/* 1934 */	NdrFcShort( 0x12f1 ),	/* 4849 */
/* 1936 */	NdrFcShort( 0x4038 ),	/* 16440 */
/* 1938 */	0xae,		/* 174 */
			0x64,		/* 100 */
/* 1940 */	0xd9,		/* 217 */
			0x57,		/* 87 */
/* 1942 */	0x85,		/* 133 */
			0x87,		/* 135 */
/* 1944 */	0x4c,		/* 76 */
			0x47,		/* 71 */
/* 1946 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1948 */	NdrFcLong( 0xd5168050 ),	/* -719945648 */
/* 1952 */	NdrFcShort( 0xa57a ),	/* -23174 */
/* 1954 */	NdrFcShort( 0x465c ),	/* 18012 */
/* 1956 */	0xbe,		/* 190 */
			0xa9,		/* 169 */
/* 1958 */	0x97,		/* 151 */
			0x4f,		/* 79 */
/* 1960 */	0x40,		/* 64 */
			0x5e,		/* 94 */
/* 1962 */	0xba,		/* 186 */
			0x13,		/* 19 */
/* 1964 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1966 */	NdrFcLong( 0x423238d6 ),	/* 1110587606 */
/* 1970 */	NdrFcShort( 0xda42 ),	/* -9662 */
/* 1972 */	NdrFcShort( 0x4989 ),	/* 18825 */
/* 1974 */	0x96,		/* 150 */
			0xfb,		/* 251 */
/* 1976 */	0x6b,		/* 107 */
			0xba,		/* 186 */
/* 1978 */	0x26,		/* 38 */
			0xe7,		/* 231 */
/* 1980 */	0x2e,		/* 46 */
			0x9,		/* 9 */
/* 1982 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1984 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (1928) */
/* 1986 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1988 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1990) */
/* 1990 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1992 */	NdrFcLong( 0x931516ad ),	/* -1827334483 */
/* 1996 */	NdrFcShort( 0xb600 ),	/* -18944 */
/* 1998 */	NdrFcShort( 0x419c ),	/* 16796 */
/* 2000 */	0x88,		/* 136 */
			0xfc,		/* 252 */
/* 2002 */	0xdc,		/* 220 */
			0xf5,		/* 245 */
/* 2004 */	0x18,		/* 24 */
			0x3b,		/* 59 */
/* 2006 */	0x5f,		/* 95 */
			0xa9,		/* 169 */
/* 2008 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2010 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2012) */
/* 2012 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2014 */	NdrFcLong( 0xac17b76b ),	/* -1407731861 */
/* 2018 */	NdrFcShort( 0x2b09 ),	/* 11017 */
/* 2020 */	NdrFcShort( 0x419a ),	/* 16794 */
/* 2022 */	0xad,		/* 173 */
			0x5f,		/* 95 */
/* 2024 */	0x7d,		/* 125 */
			0x74,		/* 116 */
/* 2026 */	0x2,		/* 2 */
			0xda,		/* 218 */
/* 2028 */	0x88,		/* 136 */
			0x75,		/* 117 */
/* 2030 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2032 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2034) */
/* 2034 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2036 */	NdrFcLong( 0xf6b37e0 ),	/* 258684896 */
/* 2040 */	NdrFcShort( 0xfcfe ),	/* -770 */
/* 2042 */	NdrFcShort( 0x44d9 ),	/* 17625 */
/* 2044 */	0x91,		/* 145 */
			0x12,		/* 18 */
/* 2046 */	0x39,		/* 57 */
			0x4c,		/* 76 */
/* 2048 */	0xa9,		/* 169 */
			0xb9,		/* 185 */
/* 2050 */	0x21,		/* 33 */
			0x14,		/* 20 */
/* 2052 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 2054 */	NdrFcShort( 0xfffffa66 ),	/* Offset= -1434 (620) */
/* 2056 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2058 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2060) */
/* 2060 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2062 */	NdrFcLong( 0xfc1cd9a ),	/* 264359322 */
/* 2066 */	NdrFcShort( 0xb912 ),	/* -18158 */
/* 2068 */	NdrFcShort( 0x405c ),	/* 16476 */
/* 2070 */	0xa0,		/* 160 */
			0x4c,		/* 76 */
/* 2072 */	0x43,		/* 67 */
			0xce,		/* 206 */
/* 2074 */	0x2,		/* 2 */
			0xcd,		/* 205 */
/* 2076 */	0x7d,		/* 125 */
			0xf2,		/* 242 */
/* 2078 */	
			0x11, 0x0,	/* FC_RP */
/* 2080 */	NdrFcShort( 0xfffff7fe ),	/* Offset= -2050 (30) */
/* 2082 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 2084 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 2086 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2088 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2090) */
/* 2090 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2092 */	NdrFcLong( 0xa7ee3e7e ),	/* -1477558658 */
/* 2096 */	NdrFcShort( 0x2dd2 ),	/* 11730 */
/* 2098 */	NdrFcShort( 0x4ad7 ),	/* 19159 */
/* 2100 */	0x96,		/* 150 */
			0x97,		/* 151 */
/* 2102 */	0xf4,		/* 244 */
			0xaa,		/* 170 */
/* 2104 */	0xe3,		/* 227 */
			0x42,		/* 66 */
/* 2106 */	0x77,		/* 119 */
			0x62,		/* 98 */
/* 2108 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2110 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2112) */
/* 2112 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2114 */	NdrFcLong( 0xf6b37e0 ),	/* 258684896 */
/* 2118 */	NdrFcShort( 0xfcfe ),	/* -770 */
/* 2120 */	NdrFcShort( 0x44d9 ),	/* 17625 */
/* 2122 */	0x91,		/* 145 */
			0x12,		/* 18 */
/* 2124 */	0x39,		/* 57 */
			0x4c,		/* 76 */
/* 2126 */	0xa9,		/* 169 */
			0xb9,		/* 185 */
/* 2128 */	0x21,		/* 33 */
			0x14,		/* 20 */
/* 2130 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2132 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2134) */
/* 2134 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2136 */	NdrFcLong( 0xd533d975 ),	/* -718022283 */
/* 2140 */	NdrFcShort( 0x3f32 ),	/* 16178 */
/* 2142 */	NdrFcShort( 0x4876 ),	/* 18550 */
/* 2144 */	0xab,		/* 171 */
			0xd0,		/* 208 */
/* 2146 */	0x6d,		/* 109 */
			0x37,		/* 55 */
/* 2148 */	0xfd,		/* 253 */
			0xa5,		/* 165 */
/* 2150 */	0x63,		/* 99 */
			0xe7,		/* 231 */
/* 2152 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2154 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2156) */
/* 2156 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2158 */	NdrFcLong( 0x74570ef7 ),	/* 1951862519 */
/* 2162 */	NdrFcShort( 0x2486 ),	/* 9350 */
/* 2164 */	NdrFcShort( 0x4089 ),	/* 16521 */
/* 2166 */	0x80,		/* 128 */
			0xc,		/* 12 */
/* 2168 */	0x56,		/* 86 */
			0xe3,		/* 227 */
/* 2170 */	0x82,		/* 130 */
			0x9b,		/* 155 */
/* 2172 */	0x5c,		/* 92 */
			0xa4,		/* 164 */
/* 2174 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2176 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2178) */
/* 2178 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2180 */	NdrFcLong( 0xf7473fd0 ),	/* -146325552 */
/* 2184 */	NdrFcShort( 0x7f75 ),	/* 32629 */
/* 2186 */	NdrFcShort( 0x478d ),	/* 18317 */
/* 2188 */	0x8d,		/* 141 */
			0x85,		/* 133 */
/* 2190 */	0xa4,		/* 164 */
			0x85,		/* 133 */
/* 2192 */	0x20,		/* 32 */
			0x4e,		/* 78 */
/* 2194 */	0x7a,		/* 122 */
			0x2d,		/* 45 */
/* 2196 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2198 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2200) */
/* 2200 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2202 */	NdrFcLong( 0xa7ee3e7e ),	/* -1477558658 */
/* 2206 */	NdrFcShort( 0x2dd2 ),	/* 11730 */
/* 2208 */	NdrFcShort( 0x4ad7 ),	/* 19159 */
/* 2210 */	0x96,		/* 150 */
			0x97,		/* 151 */
/* 2212 */	0xf4,		/* 244 */
			0xaa,		/* 170 */
/* 2214 */	0xe3,		/* 227 */
			0x42,		/* 66 */
/* 2216 */	0x77,		/* 119 */
			0x62,		/* 98 */
/* 2218 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2220 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2222) */
/* 2222 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2224 */	NdrFcLong( 0x1606dd73 ),	/* 369548659 */
/* 2228 */	NdrFcShort( 0x5d5f ),	/* 23903 */
/* 2230 */	NdrFcShort( 0x405c ),	/* 16476 */
/* 2232 */	0xb4,		/* 180 */
			0xf4,		/* 244 */
/* 2234 */	0xce,		/* 206 */
			0x32,		/* 50 */
/* 2236 */	0xba,		/* 186 */
			0xba,		/* 186 */
/* 2238 */	0x25,		/* 37 */
			0x1,		/* 1 */
/* 2240 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2242 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2244) */
/* 2244 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2246 */	NdrFcLong( 0x931516ad ),	/* -1827334483 */
/* 2250 */	NdrFcShort( 0xb600 ),	/* -18944 */
/* 2252 */	NdrFcShort( 0x419c ),	/* 16796 */
/* 2254 */	0x88,		/* 136 */
			0xfc,		/* 252 */
/* 2256 */	0xdc,		/* 220 */
			0xf5,		/* 245 */
/* 2258 */	0x18,		/* 24 */
			0x3b,		/* 59 */
/* 2260 */	0x5f,		/* 95 */
			0xa9,		/* 169 */
/* 2262 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 2264 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2266) */
/* 2266 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2268 */	NdrFcShort( 0x38 ),	/* 56 */
/* 2270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2272 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2272) */
/* 2274 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2276 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff739 ),	/* Offset= -2247 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2280 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff735 ),	/* Offset= -2251 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2284 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff731 ),	/* Offset= -2255 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2288 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff7f1 ),	/* Offset= -2063 (226) */
			0x8,		/* FC_LONG */
/* 2292 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2294 */	NdrFcShort( 0xfffff728 ),	/* Offset= -2264 (30) */
/* 2296 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2298 */	NdrFcShort( 0xfffffd24 ),	/* Offset= -732 (1566) */
/* 2300 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2302 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2304 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2306) */
/* 2306 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2308 */	NdrFcLong( 0x8d14bca6 ),	/* -1928020826 */
/* 2312 */	NdrFcShort( 0x34ce ),	/* 13518 */
/* 2314 */	NdrFcShort( 0x4efe ),	/* 20222 */
/* 2316 */	0xac,		/* 172 */
			0x7e,		/* 126 */
/* 2318 */	0xa,		/* 10 */
			0xbc,		/* 188 */
/* 2320 */	0x61,		/* 97 */
			0xda,		/* 218 */
/* 2322 */	0xdb,		/* 219 */
			0x20,		/* 32 */
/* 2324 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2326 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2328) */
/* 2328 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2330 */	NdrFcLong( 0x17bf8fa3 ),	/* 398430115 */
/* 2334 */	NdrFcShort( 0x4c5a ),	/* 19546 */
/* 2336 */	NdrFcShort( 0x49a3 ),	/* 18851 */
/* 2338 */	0xb2,		/* 178 */
			0xf8,		/* 248 */
/* 2340 */	0x59,		/* 89 */
			0x42,		/* 66 */
/* 2342 */	0xe1,		/* 225 */
			0xea,		/* 234 */
/* 2344 */	0x28,		/* 40 */
			0x7e,		/* 126 */
/* 2346 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2348 */	NdrFcLong( 0xade2eeb9 ),	/* -1377636679 */
/* 2352 */	NdrFcShort( 0xfc85 ),	/* -891 */
/* 2354 */	NdrFcShort( 0x4f5b ),	/* 20315 */
/* 2356 */	0xb5,		/* 181 */
			0xd9,		/* 217 */
/* 2358 */	0xd4,		/* 212 */
			0x31,		/* 49 */
/* 2360 */	0xb4,		/* 180 */
			0xaa,		/* 170 */
/* 2362 */	0xc3,		/* 195 */
			0x1a,		/* 26 */
/* 2364 */	
			0x11, 0x0,	/* FC_RP */
/* 2366 */	NdrFcShort( 0xfffff97e ),	/* Offset= -1666 (700) */
/* 2368 */	
			0x11, 0x0,	/* FC_RP */
/* 2370 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2372) */
/* 2372 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 2374 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2376 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2378 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2380 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2382 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2384 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 2386 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 2388 */	NdrFcShort( 0xfffff78e ),	/* Offset= -2162 (226) */
/* 2390 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2392 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2394) */
/* 2394 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2396 */	NdrFcLong( 0xd30dc12 ),	/* 221305874 */
/* 2400 */	NdrFcShort( 0xc4f8 ),	/* -15112 */
/* 2402 */	NdrFcShort( 0x433d ),	/* 17213 */
/* 2404 */	0x9f,		/* 159 */
			0xcc,		/* 204 */
/* 2406 */	0x9f,		/* 159 */
			0xf1,		/* 241 */
/* 2408 */	0x17,		/* 23 */
			0xe5,		/* 229 */
/* 2410 */	0xe5,		/* 229 */
			0xf4,		/* 244 */
/* 2412 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2414 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2416) */
/* 2416 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2418 */	NdrFcLong( 0x79293cc8 ),	/* 2032745672 */
/* 2422 */	NdrFcShort( 0xd9d9 ),	/* -9767 */
/* 2424 */	NdrFcShort( 0x43f5 ),	/* 17397 */
/* 2426 */	0x97,		/* 151 */
			0xad,		/* 173 */
/* 2428 */	0xb,		/* 11 */
			0xcc,		/* 204 */
/* 2430 */	0x5a,		/* 90 */
			0x68,		/* 104 */
/* 2432 */	0x87,		/* 135 */
			0x76,		/* 118 */
/* 2434 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2436 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2438) */
/* 2438 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2440 */	NdrFcLong( 0xd30dc12 ),	/* 221305874 */
/* 2444 */	NdrFcShort( 0xc4f8 ),	/* -15112 */
/* 2446 */	NdrFcShort( 0x433d ),	/* 17213 */
/* 2448 */	0x9f,		/* 159 */
			0xcc,		/* 204 */
/* 2450 */	0x9f,		/* 159 */
			0xf1,		/* 241 */
/* 2452 */	0x17,		/* 23 */
			0xe5,		/* 229 */
/* 2454 */	0xe5,		/* 229 */
			0xf4,		/* 244 */
/* 2456 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2458 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2460) */
/* 2460 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2462 */	NdrFcLong( 0x43286fea ),	/* 1126723562 */
/* 2466 */	NdrFcShort( 0x6997 ),	/* 27031 */
/* 2468 */	NdrFcShort( 0x4543 ),	/* 17731 */
/* 2470 */	0x80,		/* 128 */
			0x3e,		/* 62 */
/* 2472 */	0x60,		/* 96 */
			0xa2,		/* 162 */
/* 2474 */	0xc,		/* 12 */
			0x47,		/* 71 */
/* 2476 */	0x3d,		/* 61 */
			0xe5,		/* 229 */
/* 2478 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2480 */	NdrFcLong( 0xade2eeb9 ),	/* -1377636679 */
/* 2484 */	NdrFcShort( 0xfc85 ),	/* -891 */
/* 2486 */	NdrFcShort( 0x4f5b ),	/* 20315 */
/* 2488 */	0xb5,		/* 181 */
			0xd9,		/* 217 */
/* 2490 */	0xd4,		/* 212 */
			0x31,		/* 49 */
/* 2492 */	0xb4,		/* 180 */
			0xaa,		/* 170 */
/* 2494 */	0xc3,		/* 195 */
			0x1a,		/* 26 */
/* 2496 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2498 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2500) */
/* 2500 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2502 */	NdrFcLong( 0xa7ee3e7e ),	/* -1477558658 */
/* 2506 */	NdrFcShort( 0x2dd2 ),	/* 11730 */
/* 2508 */	NdrFcShort( 0x4ad7 ),	/* 19159 */
/* 2510 */	0x96,		/* 150 */
			0x97,		/* 151 */
/* 2512 */	0xf4,		/* 244 */
			0xaa,		/* 170 */
/* 2514 */	0xe3,		/* 227 */
			0x42,		/* 66 */
/* 2516 */	0x77,		/* 119 */
			0x62,		/* 98 */
/* 2518 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2520 */	NdrFcLong( 0xd5168050 ),	/* -719945648 */
/* 2524 */	NdrFcShort( 0xa57a ),	/* -23174 */
/* 2526 */	NdrFcShort( 0x465c ),	/* 18012 */
/* 2528 */	0xbe,		/* 190 */
			0xa9,		/* 169 */
/* 2530 */	0x97,		/* 151 */
			0x4f,		/* 79 */
/* 2532 */	0x40,		/* 64 */
			0x5e,		/* 94 */
/* 2534 */	0xba,		/* 186 */
			0x13,		/* 19 */
/* 2536 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2538 */	NdrFcLong( 0xbdde0eee ),	/* -1109520658 */
/* 2542 */	NdrFcShort( 0x3b8d ),	/* 15245 */
/* 2544 */	NdrFcShort( 0x4c82 ),	/* 19586 */
/* 2546 */	0xb5,		/* 181 */
			0x29,		/* 41 */
/* 2548 */	0x33,		/* 51 */
			0xf1,		/* 241 */
/* 2550 */	0x6b,		/* 107 */
			0x42,		/* 66 */
/* 2552 */	0x83,		/* 131 */
			0x2e,		/* 46 */
/* 2554 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2556 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2558) */
/* 2558 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2560 */	NdrFcLong( 0xad47a80b ),	/* -1387812853 */
/* 2564 */	NdrFcShort( 0xeda7 ),	/* -4697 */
/* 2566 */	NdrFcShort( 0x459e ),	/* 17822 */
/* 2568 */	0xaf,		/* 175 */
			0x82,		/* 130 */
/* 2570 */	0x64,		/* 100 */
			0x7c,		/* 124 */
/* 2572 */	0xc9,		/* 201 */
			0xfb,		/* 251 */
/* 2574 */	0xaa,		/* 170 */
			0x50,		/* 80 */
/* 2576 */	0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2578 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2580) */
/* 2580 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2582 */	NdrFcLong( 0x925837d1 ),	/* -1839712303 */
/* 2586 */	NdrFcShort( 0x3aa1 ),	/* 15009 */
/* 2588 */	NdrFcShort( 0x451a ),	/* 17690 */
/* 2590 */	0xb7,		/* 183 */
			0xfe,		/* 254 */
/* 2592 */	0xcc,		/* 204 */
			0x4,		/* 4 */
/* 2594 */	0xbb,		/* 187 */
			0x42,		/* 66 */
/* 2596 */	0xcf,		/* 207 */
			0xb8,		/* 184 */
/* 2598 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2600 */	NdrFcLong( 0xac17b76b ),	/* -1407731861 */
/* 2604 */	NdrFcShort( 0x2b09 ),	/* 11017 */
/* 2606 */	NdrFcShort( 0x419a ),	/* 16794 */
/* 2608 */	0xad,		/* 173 */
			0x5f,		/* 95 */
/* 2610 */	0x7d,		/* 125 */
			0x74,		/* 116 */
/* 2612 */	0x2,		/* 2 */
			0xda,		/* 218 */
/* 2614 */	0x88,		/* 136 */
			0x75,		/* 117 */
/* 2616 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2618 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2620) */
/* 2620 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2622 */	NdrFcLong( 0xe5b017fe ),	/* -441444354 */
/* 2626 */	NdrFcShort( 0xdfb0 ),	/* -8272 */
/* 2628 */	NdrFcShort( 0x411c ),	/* 16668 */
/* 2630 */	0x82,		/* 130 */
			0x66,		/* 102 */
/* 2632 */	0x7c,		/* 124 */
			0x64,		/* 100 */
/* 2634 */	0xd6,		/* 214 */
			0xf5,		/* 245 */
/* 2636 */	0x19,		/* 25 */
			0xf8,		/* 248 */
/* 2638 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2640 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2642) */
/* 2642 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2644 */	NdrFcLong( 0x4c4a2835 ),	/* 1279928373 */
/* 2648 */	NdrFcShort( 0x682e ),	/* 26670 */
/* 2650 */	NdrFcShort( 0x4ce1 ),	/* 19681 */
/* 2652 */	0xae,		/* 174 */
			0xbc,		/* 188 */
/* 2654 */	0x1e,		/* 30 */
			0x6b,		/* 107 */
/* 2656 */	0x3a,		/* 58 */
			0x16,		/* 22 */
/* 2658 */	0x5b,		/* 91 */
			0x44,		/* 68 */
/* 2660 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2662 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2664) */
/* 2664 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2666 */	NdrFcLong( 0x978baee7 ),	/* -1752453401 */
/* 2670 */	NdrFcShort( 0xbd4c ),	/* -17076 */
/* 2672 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 2674 */	0x92,		/* 146 */
			0x38,		/* 56 */
/* 2676 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 2678 */	0x24,		/* 36 */
			0x48,		/* 72 */
/* 2680 */	0x79,		/* 121 */
			0x9a,		/* 154 */
/* 2682 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2684 */	NdrFcLong( 0xac17b76b ),	/* -1407731861 */
/* 2688 */	NdrFcShort( 0x2b09 ),	/* 11017 */
/* 2690 */	NdrFcShort( 0x419a ),	/* 16794 */
/* 2692 */	0xad,		/* 173 */
			0x5f,		/* 95 */
/* 2694 */	0x7d,		/* 125 */
			0x74,		/* 116 */
/* 2696 */	0x2,		/* 2 */
			0xda,		/* 218 */
/* 2698 */	0x88,		/* 136 */
			0x75,		/* 117 */
/* 2700 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2702 */	NdrFcLong( 0x1412926f ),	/* 336761455 */
/* 2706 */	NdrFcShort( 0x5dd6 ),	/* 24022 */
/* 2708 */	NdrFcShort( 0x4e58 ),	/* 20056 */
/* 2710 */	0xb6,		/* 182 */
			0x48,		/* 72 */
/* 2712 */	0xe1,		/* 225 */
			0xc6,		/* 198 */
/* 2714 */	0x3e,		/* 62 */
			0x1,		/* 1 */
/* 2716 */	0x3d,		/* 61 */
			0x51,		/* 81 */
/* 2718 */	0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2720 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2722) */
/* 2722 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2724 */	NdrFcLong( 0x9b13f80d ),	/* -1693190131 */
/* 2728 */	NdrFcShort( 0xcfc6 ),	/* -12346 */
/* 2730 */	NdrFcShort( 0x4b78 ),	/* 19320 */
/* 2732 */	0x81,		/* 129 */
			0xef,		/* 239 */
/* 2734 */	0x1f,		/* 31 */
			0x7c,		/* 124 */
/* 2736 */	0xc3,		/* 195 */
			0x3f,		/* 63 */
/* 2738 */	0x76,		/* 118 */
			0x39,		/* 57 */
/* 2740 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2742 */	NdrFcShort( 0xffffffc4 ),	/* Offset= -60 (2682) */
/* 2744 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2746 */	NdrFcLong( 0x69d172ef ),	/* 1775334127 */
/* 2750 */	NdrFcShort( 0xf2c4 ),	/* -3388 */
/* 2752 */	NdrFcShort( 0x44e1 ),	/* 17633 */
/* 2754 */	0x89,		/* 137 */
			0xf7,		/* 247 */
/* 2756 */	0xc8,		/* 200 */
			0x62,		/* 98 */
/* 2758 */	0x31,		/* 49 */
			0xe7,		/* 231 */
/* 2760 */	0x6,		/* 6 */
			0xe9,		/* 233 */
/* 2762 */	
			0x14, 0x0,	/* FC_FP */
/* 2764 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2766) */
/* 2766 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 2768 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2770 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2772 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2774 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 2776 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2778 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2780 */	NdrFcShort( 0xfffff56a ),	/* Offset= -2710 (70) */
/* 2782 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2784 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2786 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2788) */
/* 2788 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2790 */	NdrFcLong( 0x98bbba48 ),	/* -1732527544 */
/* 2794 */	NdrFcShort( 0x4c4d ),	/* 19533 */
/* 2796 */	NdrFcShort( 0x4fff ),	/* 20479 */
/* 2798 */	0x83,		/* 131 */
			0x40,		/* 64 */
/* 2800 */	0x60,		/* 96 */
			0x97,		/* 151 */
/* 2802 */	0xbe,		/* 190 */
			0xc9,		/* 201 */
/* 2804 */	0xc8,		/* 200 */
			0x94,		/* 148 */
/* 2806 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2808 */	NdrFcShort( 0xffffffc0 ),	/* Offset= -64 (2744) */
/* 2810 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2812 */	NdrFcLong( 0x1412926f ),	/* 336761455 */
/* 2816 */	NdrFcShort( 0x5dd6 ),	/* 24022 */
/* 2818 */	NdrFcShort( 0x4e58 ),	/* 20056 */
/* 2820 */	0xb6,		/* 182 */
			0x48,		/* 72 */
/* 2822 */	0xe1,		/* 225 */
			0xc6,		/* 198 */
/* 2824 */	0x3e,		/* 62 */
			0x1,		/* 1 */
/* 2826 */	0x3d,		/* 61 */
			0x51,		/* 81 */
/* 2828 */	0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 2830 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2832) */
/* 2832 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2834 */	NdrFcShort( 0x1c ),	/* 28 */
/* 2836 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2838 */	NdrFcShort( 0x0 ),	/* Offset= 0 (2838) */
/* 2840 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 2842 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 2844 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2846 */	NdrFcShort( 0xfffff500 ),	/* Offset= -2816 (30) */
/* 2848 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2850 */	NdrFcShort( 0xfffff4fc ),	/* Offset= -2820 (30) */
/* 2852 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2854 */	NdrFcShort( 0xfffff4f8 ),	/* Offset= -2824 (30) */
/* 2856 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2858 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2860 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2862) */
/* 2862 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2864 */	NdrFcLong( 0x88d2f75b ),	/* -1999440037 */
/* 2868 */	NdrFcShort( 0xd329 ),	/* -11479 */
/* 2870 */	NdrFcShort( 0x4e03 ),	/* 19971 */
/* 2872 */	0x9b,		/* 155 */
			0x75,		/* 117 */
/* 2874 */	0x20,		/* 32 */
			0x1f,		/* 31 */
/* 2876 */	0x77,		/* 119 */
			0x82,		/* 130 */
/* 2878 */	0xd8,		/* 216 */
			0xbd,		/* 189 */
/* 2880 */	
			0x14, 0x0,	/* FC_FP */
/* 2882 */	NdrFcShort( 0x14 ),	/* Offset= 20 (2902) */
/* 2884 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2886 */	NdrFcLong( 0x10b793ac ),	/* 280466348 */
/* 2890 */	NdrFcShort( 0xc47 ),	/* 3143 */
/* 2892 */	NdrFcShort( 0x4679 ),	/* 18041 */
/* 2894 */	0x84,		/* 132 */
			0x54,		/* 84 */
/* 2896 */	0xad,		/* 173 */
			0xb3,		/* 179 */
/* 2898 */	0x6f,		/* 111 */
			0x29,		/* 41 */
/* 2900 */	0xf8,		/* 248 */
			0x2,		/* 2 */
/* 2902 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2904 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2906 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2908 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2910 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2912 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2914 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2916 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (2884) */
/* 2918 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2920 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 2922 */	NdrFcShort( 0x14 ),	/* Offset= 20 (2942) */
/* 2924 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2926 */	NdrFcLong( 0xa7ee3e7e ),	/* -1477558658 */
/* 2930 */	NdrFcShort( 0x2dd2 ),	/* 11730 */
/* 2932 */	NdrFcShort( 0x4ad7 ),	/* 19159 */
/* 2934 */	0x96,		/* 150 */
			0x97,		/* 151 */
/* 2936 */	0xf4,		/* 244 */
			0xaa,		/* 170 */
/* 2938 */	0xe3,		/* 227 */
			0x42,		/* 66 */
/* 2940 */	0x77,		/* 119 */
			0x62,		/* 98 */
/* 2942 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 2944 */	NdrFcShort( 0x20 ),	/* 32 */
/* 2946 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2948 */	NdrFcShort( 0x1a ),	/* Offset= 26 (2974) */
/* 2950 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2952 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff495 ),	/* Offset= -2923 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2956 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff491 ),	/* Offset= -2927 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2960 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff48d ),	/* Offset= -2931 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2964 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff489 ),	/* Offset= -2935 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 2968 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd3 ),	/* Offset= -45 (2924) */
			0xb,		/* FC_HYPER */
/* 2972 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2974 */	
			0x14, 0x0,	/* FC_FP */
/* 2976 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2978) */
/* 2978 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2980 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2982 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2984 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2986 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 2988 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2990 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2992 */	NdrFcShort( 0xffffff94 ),	/* Offset= -108 (2884) */
/* 2994 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2996 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 2998 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3000) */
/* 3000 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3002 */	NdrFcLong( 0x6c7072c3 ),	/* 1819308739 */
/* 3006 */	NdrFcShort( 0x3ac4 ),	/* 15044 */
/* 3008 */	NdrFcShort( 0x408f ),	/* 16527 */
/* 3010 */	0xa6,		/* 166 */
			0x80,		/* 128 */
/* 3012 */	0xfc,		/* 252 */
			0x5a,		/* 90 */
/* 3014 */	0x2f,		/* 47 */
			0x96,		/* 150 */
/* 3016 */	0x90,		/* 144 */
			0x3e,		/* 62 */
/* 3018 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3020 */	NdrFcShort( 0xffffffa0 ),	/* Offset= -96 (2924) */
/* 3022 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3024 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3026) */
/* 3026 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3028 */	NdrFcLong( 0x1ab276dd ),	/* 447903453 */
/* 3032 */	NdrFcShort( 0xf27b ),	/* -3461 */
/* 3034 */	NdrFcShort( 0x4445 ),	/* 17477 */
/* 3036 */	0x82,		/* 130 */
			0x5d,		/* 93 */
/* 3038 */	0x5d,		/* 93 */
			0xf0,		/* 240 */
/* 3040 */	0xb4,		/* 180 */
			0xa0,		/* 160 */
/* 3042 */	0x4a,		/* 74 */
			0x3a,		/* 58 */
/* 3044 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3046 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3048) */
/* 3048 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3050 */	NdrFcLong( 0x10b793ac ),	/* 280466348 */
/* 3054 */	NdrFcShort( 0xc47 ),	/* 3143 */
/* 3056 */	NdrFcShort( 0x4679 ),	/* 18041 */
/* 3058 */	0x84,		/* 132 */
			0x54,		/* 84 */
/* 3060 */	0xad,		/* 173 */
			0xb3,		/* 179 */
/* 3062 */	0x6f,		/* 111 */
			0x29,		/* 41 */
/* 3064 */	0xf8,		/* 248 */
			0x2,		/* 2 */
/* 3066 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 3068 */	NdrFcShort( 0x6 ),	/* Offset= 6 (3074) */
/* 3070 */	
			0x13, 0x0,	/* FC_OP */
/* 3072 */	NdrFcShort( 0xfffffa90 ),	/* Offset= -1392 (1680) */
/* 3074 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 3076 */	NdrFcShort( 0x1 ),	/* 1 */
/* 3078 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3080 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3082 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (3070) */
/* 3084 */	
			0x11, 0x0,	/* FC_RP */
/* 3086 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3088) */
/* 3088 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3090 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3092 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3094 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3096 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3098 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3100 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3102 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (3048) */
/* 3104 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3106 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 3108 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3110) */
/* 3110 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 3112 */	NdrFcShort( 0x20 ),	/* 32 */
/* 3114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3116 */	NdrFcShort( 0x16 ),	/* Offset= 22 (3138) */
/* 3118 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3120 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff3ed ),	/* Offset= -3091 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3124 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff3e9 ),	/* Offset= -3095 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3128 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff3e5 ),	/* Offset= -3099 (30) */
			0xb,		/* FC_HYPER */
/* 3132 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3134 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffa9 ),	/* Offset= -87 (3048) */
			0x5b,		/* FC_END */
/* 3138 */	
			0x11, 0x0,	/* FC_RP */
/* 3140 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3142) */
/* 3142 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3146 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3148 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3150 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3152 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3154 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3156 */	NdrFcShort( 0xffffff94 ),	/* Offset= -108 (3048) */
/* 3158 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3160 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3162 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3164) */
/* 3164 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3166 */	NdrFcLong( 0xe459dd12 ),	/* -463872750 */
/* 3170 */	NdrFcShort( 0x864f ),	/* -31153 */
/* 3172 */	NdrFcShort( 0x4aaa ),	/* 19114 */
/* 3174 */	0xab,		/* 171 */
			0xc1,		/* 193 */
/* 3176 */	0xdc,		/* 220 */
			0xec,		/* 236 */
/* 3178 */	0xbc,		/* 188 */
			0x26,		/* 38 */
/* 3180 */	0x7f,		/* 127 */
			0x4,		/* 4 */
/* 3182 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3184 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3186) */
/* 3186 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3188 */	NdrFcLong( 0x925837d1 ),	/* -1839712303 */
/* 3192 */	NdrFcShort( 0x3aa1 ),	/* 15009 */
/* 3194 */	NdrFcShort( 0x451a ),	/* 17690 */
/* 3196 */	0xb7,		/* 183 */
			0xfe,		/* 254 */
/* 3198 */	0xcc,		/* 204 */
			0x4,		/* 4 */
/* 3200 */	0xbb,		/* 187 */
			0x42,		/* 66 */
/* 3202 */	0xcf,		/* 207 */
			0xb8,		/* 184 */
/* 3204 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3206 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3208) */
/* 3208 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3210 */	NdrFcLong( 0x1ab276dd ),	/* 447903453 */
/* 3214 */	NdrFcShort( 0xf27b ),	/* -3461 */
/* 3216 */	NdrFcShort( 0x4445 ),	/* 17477 */
/* 3218 */	0x82,		/* 130 */
			0x5d,		/* 93 */
/* 3220 */	0x5d,		/* 93 */
			0xf0,		/* 240 */
/* 3222 */	0xb4,		/* 180 */
			0xa0,		/* 160 */
/* 3224 */	0x4a,		/* 74 */
			0x3a,		/* 58 */
/* 3226 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3228 */	NdrFcLong( 0x10b793ac ),	/* 280466348 */
/* 3232 */	NdrFcShort( 0xc47 ),	/* 3143 */
/* 3234 */	NdrFcShort( 0x4679 ),	/* 18041 */
/* 3236 */	0x84,		/* 132 */
			0x54,		/* 84 */
/* 3238 */	0xad,		/* 173 */
			0xb3,		/* 179 */
/* 3240 */	0x6f,		/* 111 */
			0x29,		/* 41 */
/* 3242 */	0xf8,		/* 248 */
			0x2,		/* 2 */
/* 3244 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3246 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3248) */
/* 3248 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3250 */	NdrFcLong( 0xac17b76b ),	/* -1407731861 */
/* 3254 */	NdrFcShort( 0x2b09 ),	/* 11017 */
/* 3256 */	NdrFcShort( 0x419a ),	/* 16794 */
/* 3258 */	0xad,		/* 173 */
			0x5f,		/* 95 */
/* 3260 */	0x7d,		/* 125 */
			0x74,		/* 116 */
/* 3262 */	0x2,		/* 2 */
			0xda,		/* 218 */
/* 3264 */	0x88,		/* 136 */
			0x75,		/* 117 */
/* 3266 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3268 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3270) */
/* 3270 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3272 */	NdrFcLong( 0x931516ad ),	/* -1827334483 */
/* 3276 */	NdrFcShort( 0xb600 ),	/* -18944 */
/* 3278 */	NdrFcShort( 0x419c ),	/* 16796 */
/* 3280 */	0x88,		/* 136 */
			0xfc,		/* 252 */
/* 3282 */	0xdc,		/* 220 */
			0xf5,		/* 245 */
/* 3284 */	0x18,		/* 24 */
			0x3b,		/* 59 */
/* 3286 */	0x5f,		/* 95 */
			0xa9,		/* 169 */
/* 3288 */	
			0x11, 0x0,	/* FC_RP */
/* 3290 */	NdrFcShort( 0x26 ),	/* Offset= 38 (3328) */
/* 3292 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3294 */	NdrFcLong( 0x1412926f ),	/* 336761455 */
/* 3298 */	NdrFcShort( 0x5dd6 ),	/* 24022 */
/* 3300 */	NdrFcShort( 0x4e58 ),	/* 20056 */
/* 3302 */	0xb6,		/* 182 */
			0x48,		/* 72 */
/* 3304 */	0xe1,		/* 225 */
			0xc6,		/* 198 */
/* 3306 */	0x3e,		/* 62 */
			0x1,		/* 1 */
/* 3308 */	0x3d,		/* 61 */
			0x51,		/* 81 */
/* 3310 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3312 */	NdrFcLong( 0xfc1cd9a ),	/* 264359322 */
/* 3316 */	NdrFcShort( 0xb912 ),	/* -18158 */
/* 3318 */	NdrFcShort( 0x405c ),	/* 16476 */
/* 3320 */	0xa0,		/* 160 */
			0x4c,		/* 76 */
/* 3322 */	0x43,		/* 67 */
			0xce,		/* 206 */
/* 3324 */	0x2,		/* 2 */
			0xcd,		/* 205 */
/* 3326 */	0x7d,		/* 125 */
			0xf2,		/* 242 */
/* 3328 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 3330 */	NdrFcShort( 0x40 ),	/* 64 */
/* 3332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3334 */	NdrFcShort( 0x26 ),	/* Offset= 38 (3372) */
/* 3336 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3338 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff313 ),	/* Offset= -3309 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3342 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff30f ),	/* Offset= -3313 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3346 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff30b ),	/* Offset= -3317 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3350 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff307 ),	/* Offset= -3321 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3354 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff303 ),	/* Offset= -3325 (30) */
			0xb,		/* FC_HYPER */
/* 3358 */	0xb,		/* FC_HYPER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3360 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffbb ),	/* Offset= -69 (3292) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3364 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc9 ),	/* Offset= -55 (3310) */
			0x8,		/* FC_LONG */
/* 3368 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 3370 */	0x40,		/* FC_STRUCTPAD4 */
			0x5b,		/* FC_END */
/* 3372 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 3374 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 3376 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3378 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3380) */
/* 3380 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3382 */	NdrFcLong( 0x37a44580 ),	/* 933512576 */
/* 3386 */	NdrFcShort( 0xd5fc ),	/* -10756 */
/* 3388 */	NdrFcShort( 0x473e ),	/* 18238 */
/* 3390 */	0xa0,		/* 160 */
			0x48,		/* 72 */
/* 3392 */	0x21,		/* 33 */
			0x70,		/* 112 */
/* 3394 */	0x2e,		/* 46 */
			0xbf,		/* 191 */
/* 3396 */	0xc4,		/* 196 */
			0x66,		/* 102 */
/* 3398 */	
			0x14, 0x0,	/* FC_FP */
/* 3400 */	NdrFcShort( 0xfffff2d6 ),	/* Offset= -3370 (30) */
/* 3402 */	
			0x14, 0x0,	/* FC_FP */
/* 3404 */	NdrFcShort( 0xfffff2fa ),	/* Offset= -3334 (70) */
/* 3406 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3408 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3410) */
/* 3410 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3412 */	NdrFcLong( 0xa7ee3e7e ),	/* -1477558658 */
/* 3416 */	NdrFcShort( 0x2dd2 ),	/* 11730 */
/* 3418 */	NdrFcShort( 0x4ad7 ),	/* 19159 */
/* 3420 */	0x96,		/* 150 */
			0x97,		/* 151 */
/* 3422 */	0xf4,		/* 244 */
			0xaa,		/* 170 */
/* 3424 */	0xe3,		/* 227 */
			0x42,		/* 66 */
/* 3426 */	0x77,		/* 119 */
			0x62,		/* 98 */
/* 3428 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3430 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3432) */
/* 3432 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3434 */	NdrFcLong( 0x6c7072c3 ),	/* 1819308739 */
/* 3438 */	NdrFcShort( 0x3ac4 ),	/* 15044 */
/* 3440 */	NdrFcShort( 0x408f ),	/* 16527 */
/* 3442 */	0xa6,		/* 166 */
			0x80,		/* 128 */
/* 3444 */	0xfc,		/* 252 */
			0x5a,		/* 90 */
/* 3446 */	0x2f,		/* 47 */
			0x96,		/* 150 */
/* 3448 */	0x90,		/* 144 */
			0x3e,		/* 62 */
/* 3450 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3452 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3454) */
/* 3454 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3456 */	NdrFcLong( 0xd5168050 ),	/* -719945648 */
/* 3460 */	NdrFcShort( 0xa57a ),	/* -23174 */
/* 3462 */	NdrFcShort( 0x465c ),	/* 18012 */
/* 3464 */	0xbe,		/* 190 */
			0xa9,		/* 169 */
/* 3466 */	0x97,		/* 151 */
			0x4f,		/* 79 */
/* 3468 */	0x40,		/* 64 */
			0x5e,		/* 94 */
/* 3470 */	0xba,		/* 186 */
			0x13,		/* 19 */
/* 3472 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 3474 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3476) */
/* 3476 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 3478 */	NdrFcShort( 0x20 ),	/* 32 */
/* 3480 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3482 */	NdrFcShort( 0x0 ),	/* Offset= 0 (3482) */
/* 3484 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3486 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff27f ),	/* Offset= -3457 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3490 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff27b ),	/* Offset= -3461 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3494 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff877 ),	/* Offset= -1929 (1566) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3498 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff273 ),	/* Offset= -3469 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3502 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff26f ),	/* Offset= -3473 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3506 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff26b ),	/* Offset= -3477 (30) */
			0x5b,		/* FC_END */
/* 3510 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3512 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3514) */
/* 3514 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3516 */	NdrFcLong( 0x1ab276dd ),	/* 447903453 */
/* 3520 */	NdrFcShort( 0xf27b ),	/* -3461 */
/* 3522 */	NdrFcShort( 0x4445 ),	/* 17477 */
/* 3524 */	0x82,		/* 130 */
			0x5d,		/* 93 */
/* 3526 */	0x5d,		/* 93 */
			0xf0,		/* 240 */
/* 3528 */	0xb4,		/* 180 */
			0xa0,		/* 160 */
/* 3530 */	0x4a,		/* 74 */
			0x3a,		/* 58 */
/* 3532 */	
			0x11, 0x0,	/* FC_RP */
/* 3534 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3536) */
/* 3536 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3538 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3540 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3542 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3544 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3546 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3548 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3550 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (3514) */
/* 3552 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3554 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3556 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3558) */
/* 3558 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3560 */	NdrFcLong( 0x931516ad ),	/* -1827334483 */
/* 3564 */	NdrFcShort( 0xb600 ),	/* -18944 */
/* 3566 */	NdrFcShort( 0x419c ),	/* 16796 */
/* 3568 */	0x88,		/* 136 */
			0xfc,		/* 252 */
/* 3570 */	0xdc,		/* 220 */
			0xf5,		/* 245 */
/* 3572 */	0x18,		/* 24 */
			0x3b,		/* 59 */
/* 3574 */	0x5f,		/* 95 */
			0xa9,		/* 169 */
/* 3576 */	
			0x11, 0x0,	/* FC_RP */
/* 3578 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3580) */
/* 3580 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 3582 */	NdrFcShort( 0x1 ),	/* 1 */
/* 3584 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3586 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3588 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 3590 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3592 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 3594 */	
			0x14, 0x8,	/* FC_FP [simple_pointer] */
/* 3596 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 3598 */	
			0x11, 0x0,	/* FC_RP */
/* 3600 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3602) */
/* 3602 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 3604 */	NdrFcShort( 0x1 ),	/* 1 */
/* 3606 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3608 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3610 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3612 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3614 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 3616 */	
			0x11, 0x0,	/* FC_RP */
/* 3618 */	NdrFcShort( 0x36 ),	/* Offset= 54 (3672) */
/* 3620 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 3622 */	NdrFcShort( 0x48 ),	/* 72 */
/* 3624 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3626 */	NdrFcShort( 0x0 ),	/* Offset= 0 (3626) */
/* 3628 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3630 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff1ef ),	/* Offset= -3601 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3634 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff1eb ),	/* Offset= -3605 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3638 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff1e7 ),	/* Offset= -3609 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3642 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff1e3 ),	/* Offset= -3613 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3646 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff1df ),	/* Offset= -3617 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3650 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff1db ),	/* Offset= -3621 (30) */
			0x40,		/* FC_STRUCTPAD4 */
/* 3654 */	0xb,		/* FC_HYPER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3656 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff7d5 ),	/* Offset= -2091 (1566) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3660 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff7d1 ),	/* Offset= -2095 (1566) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3664 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff1cd ),	/* Offset= -3635 (30) */
			0x8,		/* FC_LONG */
/* 3668 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 3670 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3672 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 3674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3676 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3678 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3680 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 3682 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3684 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3686 */	NdrFcShort( 0xffffffbe ),	/* Offset= -66 (3620) */
/* 3688 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3690 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3692 */	NdrFcLong( 0xac17b76b ),	/* -1407731861 */
/* 3696 */	NdrFcShort( 0x2b09 ),	/* 11017 */
/* 3698 */	NdrFcShort( 0x419a ),	/* 16794 */
/* 3700 */	0xad,		/* 173 */
			0x5f,		/* 95 */
/* 3702 */	0x7d,		/* 125 */
			0x74,		/* 116 */
/* 3704 */	0x2,		/* 2 */
			0xda,		/* 218 */
/* 3706 */	0x88,		/* 136 */
			0x75,		/* 117 */
/* 3708 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3710 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (3690) */
/* 3712 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3714 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3716) */
/* 3716 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3718 */	NdrFcLong( 0x1606dd73 ),	/* 369548659 */
/* 3722 */	NdrFcShort( 0x5d5f ),	/* 23903 */
/* 3724 */	NdrFcShort( 0x405c ),	/* 16476 */
/* 3726 */	0xb4,		/* 180 */
			0xf4,		/* 244 */
/* 3728 */	0xce,		/* 206 */
			0x32,		/* 50 */
/* 3730 */	0xba,		/* 186 */
			0xba,		/* 186 */
/* 3732 */	0x25,		/* 37 */
			0x1,		/* 1 */
/* 3734 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3736 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3738) */
/* 3738 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3740 */	NdrFcLong( 0xad47a80b ),	/* -1387812853 */
/* 3744 */	NdrFcShort( 0xeda7 ),	/* -4697 */
/* 3746 */	NdrFcShort( 0x459e ),	/* 17822 */
/* 3748 */	0xaf,		/* 175 */
			0x82,		/* 130 */
/* 3750 */	0x64,		/* 100 */
			0x7c,		/* 124 */
/* 3752 */	0xc9,		/* 201 */
			0xfb,		/* 251 */
/* 3754 */	0xaa,		/* 170 */
			0x50,		/* 80 */
/* 3756 */	0x14, 0x0,	/* FC_FP */
/* 3758 */	NdrFcShort( 0xfffff770 ),	/* Offset= -2192 (1566) */
/* 3760 */	
			0x11, 0x0,	/* FC_RP */
/* 3762 */	NdrFcShort( 0x14 ),	/* Offset= 20 (3782) */
/* 3764 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3766 */	NdrFcLong( 0x931516ad ),	/* -1827334483 */
/* 3770 */	NdrFcShort( 0xb600 ),	/* -18944 */
/* 3772 */	NdrFcShort( 0x419c ),	/* 16796 */
/* 3774 */	0x88,		/* 136 */
			0xfc,		/* 252 */
/* 3776 */	0xdc,		/* 220 */
			0xf5,		/* 245 */
/* 3778 */	0x18,		/* 24 */
			0x3b,		/* 59 */
/* 3780 */	0x5f,		/* 95 */
			0xa9,		/* 169 */
/* 3782 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3784 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3786 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3788 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3790 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3792 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3794 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3796 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (3764) */
/* 3798 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3800 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3802 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (3764) */
/* 3804 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3806 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3808) */
/* 3808 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3810 */	NdrFcLong( 0xf7473fd0 ),	/* -146325552 */
/* 3814 */	NdrFcShort( 0x7f75 ),	/* 32629 */
/* 3816 */	NdrFcShort( 0x478d ),	/* 18317 */
/* 3818 */	0x8d,		/* 141 */
			0x85,		/* 133 */
/* 3820 */	0xa4,		/* 164 */
			0x85,		/* 133 */
/* 3822 */	0x20,		/* 32 */
			0x4e,		/* 78 */
/* 3824 */	0x7a,		/* 122 */
			0x2d,		/* 45 */
/* 3826 */	
			0x11, 0x0,	/* FC_RP */
/* 3828 */	NdrFcShort( 0x116 ),	/* Offset= 278 (4106) */
/* 3830 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 3832 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3834 */	NdrFcShort( 0x7 ),	/* 7 */
/* 3836 */	NdrFcLong( 0x10001 ),	/* 65537 */
/* 3840 */	NdrFcShort( 0x3a ),	/* Offset= 58 (3898) */
/* 3842 */	NdrFcLong( 0x20001 ),	/* 131073 */
/* 3846 */	NdrFcShort( 0x58 ),	/* Offset= 88 (3934) */
/* 3848 */	NdrFcLong( 0x30001 ),	/* 196609 */
/* 3852 */	NdrFcShort( 0x64 ),	/* Offset= 100 (3952) */
/* 3854 */	NdrFcLong( 0x40001 ),	/* 262145 */
/* 3858 */	NdrFcShort( 0x6c ),	/* Offset= 108 (3966) */
/* 3860 */	NdrFcLong( 0x50001 ),	/* 327681 */
/* 3864 */	NdrFcShort( 0x78 ),	/* Offset= 120 (3984) */
/* 3866 */	NdrFcLong( 0x40002 ),	/* 262146 */
/* 3870 */	NdrFcShort( 0x8c ),	/* Offset= 140 (4010) */
/* 3872 */	NdrFcLong( 0x60000 ),	/* 393216 */
/* 3876 */	NdrFcShort( 0xae ),	/* Offset= 174 (4050) */
/* 3878 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 3880 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3882 */	NdrFcLong( 0xbdde0eee ),	/* -1109520658 */
/* 3886 */	NdrFcShort( 0x3b8d ),	/* 15245 */
/* 3888 */	NdrFcShort( 0x4c82 ),	/* 19586 */
/* 3890 */	0xb5,		/* 181 */
			0x29,		/* 41 */
/* 3892 */	0x33,		/* 51 */
			0xf1,		/* 241 */
/* 3894 */	0x6b,		/* 107 */
			0x42,		/* 66 */
/* 3896 */	0x83,		/* 131 */
			0x2e,		/* 46 */
/* 3898 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 3900 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3902 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3904 */	NdrFcShort( 0xc ),	/* Offset= 12 (3916) */
/* 3906 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3908 */	NdrFcShort( 0xfffff0da ),	/* Offset= -3878 (30) */
/* 3910 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3912 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (3880) */
/* 3914 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3916 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 3918 */	NdrFcLong( 0x1ede3b4b ),	/* 517880651 */
/* 3922 */	NdrFcShort( 0x35e7 ),	/* 13799 */
/* 3924 */	NdrFcShort( 0x4b97 ),	/* 19351 */
/* 3926 */	0x81,		/* 129 */
			0x33,		/* 51 */
/* 3928 */	0x2,		/* 2 */
			0x84,		/* 132 */
/* 3930 */	0x5d,		/* 93 */
			0x60,		/* 96 */
/* 3932 */	0x1,		/* 1 */
			0x74,		/* 116 */
/* 3934 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 3936 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3938 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3940 */	NdrFcShort( 0xc ),	/* Offset= 12 (3952) */
/* 3942 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3944 */	NdrFcShort( 0xfffff0b6 ),	/* Offset= -3914 (30) */
/* 3946 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3948 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (3916) */
/* 3950 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3952 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 3954 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3956 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3958 */	NdrFcShort( 0x8 ),	/* Offset= 8 (3966) */
/* 3960 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3962 */	NdrFcShort( 0xfffffef0 ),	/* Offset= -272 (3690) */
/* 3964 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3966 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 3968 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3970 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3972 */	NdrFcShort( 0x0 ),	/* Offset= 0 (3972) */
/* 3974 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3976 */	NdrFcShort( 0xfffff096 ),	/* Offset= -3946 (30) */
/* 3978 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3980 */	NdrFcShort( 0xfffff092 ),	/* Offset= -3950 (30) */
/* 3982 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3984 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 3986 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3988 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3990 */	NdrFcShort( 0x0 ),	/* Offset= 0 (3990) */
/* 3992 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3994 */	NdrFcShort( 0xfffff084 ),	/* Offset= -3964 (30) */
/* 3996 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3998 */	NdrFcShort( 0xfffff080 ),	/* Offset= -3968 (30) */
/* 4000 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4002 */	NdrFcShort( 0xfffff07c ),	/* Offset= -3972 (30) */
/* 4004 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4006 */	NdrFcShort( 0xfffff078 ),	/* Offset= -3976 (30) */
/* 4008 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4010 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 4012 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4014 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4016 */	NdrFcShort( 0x10 ),	/* Offset= 16 (4032) */
/* 4018 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4020 */	NdrFcShort( 0xfffffdca ),	/* Offset= -566 (3454) */
/* 4022 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4024 */	NdrFcShort( 0xfffff066 ),	/* Offset= -3994 (30) */
/* 4026 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4028 */	NdrFcShort( 0xfffff062 ),	/* Offset= -3998 (30) */
/* 4030 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4032 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4034 */	NdrFcLong( 0xb7e66f28 ),	/* -1209635032 */
/* 4038 */	NdrFcShort( 0x35a ),	/* 858 */
/* 4040 */	NdrFcShort( 0x401a ),	/* 16410 */
/* 4042 */	0xaf,		/* 175 */
			0xc7,		/* 199 */
/* 4044 */	0x2e,		/* 46 */
			0x30,		/* 48 */
/* 4046 */	0xb,		/* 11 */
			0xd2,		/* 210 */
/* 4048 */	0x97,		/* 151 */
			0x11,		/* 17 */
/* 4050 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 4052 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4054 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4056 */	NdrFcShort( 0x8 ),	/* Offset= 8 (4064) */
/* 4058 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4060 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (4032) */
/* 4062 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4064 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4066 */	NdrFcLong( 0x69d172ef ),	/* 1775334127 */
/* 4070 */	NdrFcShort( 0xf2c4 ),	/* -3388 */
/* 4072 */	NdrFcShort( 0x44e1 ),	/* 17633 */
/* 4074 */	0x89,		/* 137 */
			0xf7,		/* 247 */
/* 4076 */	0xc8,		/* 200 */
			0x62,		/* 98 */
/* 4078 */	0x31,		/* 49 */
			0xe7,		/* 231 */
/* 4080 */	0x6,		/* 6 */
			0xe9,		/* 233 */
/* 4082 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 4084 */	NdrFcShort( 0x14 ),	/* 20 */
/* 4086 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4088 */	NdrFcShort( 0x12 ),	/* Offset= 18 (4106) */
/* 4090 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4092 */	NdrFcShort( 0xfffffd82 ),	/* Offset= -638 (3454) */
/* 4094 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4096 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff01d ),	/* Offset= -4067 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4100 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff019 ),	/* Offset= -4071 (30) */
			0x8,		/* FC_LONG */
/* 4104 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4106 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 4108 */	NdrFcShort( 0x58 ),	/* 88 */
/* 4110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4112 */	NdrFcShort( 0x26 ),	/* Offset= 38 (4150) */
/* 4114 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4116 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff031 ),	/* Offset= -4047 (70) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4120 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffedd ),	/* Offset= -291 (3830) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4124 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc3 ),	/* Offset= -61 (4064) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4128 */	0x0,		/* 0 */
			NdrFcShort( 0xffffeffd ),	/* Offset= -4099 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4132 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd59 ),	/* Offset= -679 (3454) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4136 */	0x0,		/* 0 */
			NdrFcShort( 0xffffeff5 ),	/* Offset= -4107 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4140 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc5 ),	/* Offset= -59 (4082) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4144 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff5ed ),	/* Offset= -2579 (1566) */
			0x8,		/* FC_LONG */
/* 4148 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4150 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 4152 */	NdrFcShort( 0x3a ),	/* Offset= 58 (4210) */
/* 4154 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 4156 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4158 */	NdrFcShort( 0x2 ),	/* 2 */
/* 4160 */	NdrFcLong( 0x1 ),	/* 1 */
/* 4164 */	NdrFcShort( 0xa ),	/* Offset= 10 (4174) */
/* 4166 */	NdrFcLong( 0x2 ),	/* 2 */
/* 4170 */	NdrFcShort( 0x12 ),	/* Offset= 18 (4188) */
/* 4172 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 4174 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 4176 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4180 */	NdrFcShort( 0x8 ),	/* Offset= 8 (4188) */
/* 4182 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4184 */	NdrFcShort( 0xfffffe12 ),	/* Offset= -494 (3690) */
/* 4186 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4188 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 4190 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4192 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4194 */	NdrFcShort( 0x0 ),	/* Offset= 0 (4194) */
/* 4196 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4198 */	NdrFcShort( 0xffffefb8 ),	/* Offset= -4168 (30) */
/* 4200 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4202 */	NdrFcShort( 0xffffefb4 ),	/* Offset= -4172 (30) */
/* 4204 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4206 */	NdrFcShort( 0xffffefb0 ),	/* Offset= -4176 (30) */
/* 4208 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4210 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 4212 */	NdrFcShort( 0x20 ),	/* 32 */
/* 4214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4216 */	NdrFcShort( 0x10 ),	/* Offset= 16 (4232) */
/* 4218 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4220 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffbd ),	/* Offset= -67 (4154) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4224 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff5f ),	/* Offset= -161 (4064) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4228 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffcf9 ),	/* Offset= -775 (3454) */
			0x5b,		/* FC_END */
/* 4232 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 4234 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4236) */
/* 4236 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 4238 */	NdrFcShort( 0x28 ),	/* 40 */
/* 4240 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4242 */	NdrFcShort( 0x16 ),	/* Offset= 22 (4264) */
/* 4244 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4246 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffa3 ),	/* Offset= -93 (4154) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4250 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff45 ),	/* Offset= -187 (4064) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4254 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffcdf ),	/* Offset= -801 (3454) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4258 */	0x0,		/* 0 */
			NdrFcShort( 0xffffef7b ),	/* Offset= -4229 (30) */
			0x8,		/* FC_LONG */
/* 4262 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4264 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4266 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4268) */
/* 4268 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4270 */	NdrFcLong( 0x6e215ef3 ),	/* 1847680755 */
/* 4274 */	NdrFcShort( 0xe44c ),	/* -7092 */
/* 4276 */	NdrFcShort( 0x44d1 ),	/* 17617 */
/* 4278 */	0xb7,		/* 183 */
			0xba,		/* 186 */
/* 4280 */	0xb2,		/* 178 */
			0x40,		/* 64 */
/* 4282 */	0x1f,		/* 31 */
			0x7d,		/* 125 */
/* 4284 */	0xc2,		/* 194 */
			0x3d,		/* 61 */
/* 4286 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4288 */	NdrFcShort( 0xffffff00 ),	/* Offset= -256 (4032) */
/* 4290 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4292 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4294) */
/* 4294 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4296 */	NdrFcLong( 0xe158f5aa ),	/* -514263638 */
/* 4300 */	NdrFcShort( 0x31fe ),	/* 12798 */
/* 4302 */	NdrFcShort( 0x491b ),	/* 18715 */
/* 4304 */	0xa9,		/* 169 */
			0xf6,		/* 246 */
/* 4306 */	0xcf,		/* 207 */
			0xf9,		/* 249 */
/* 4308 */	0x34,		/* 52 */
			0xb0,		/* 176 */
/* 4310 */	0x3a,		/* 58 */
			0x1,		/* 1 */
/* 4312 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 4314 */	NdrFcShort( 0xfffff544 ),	/* Offset= -2748 (1566) */
/* 4316 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4318 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4320) */
/* 4320 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4322 */	NdrFcLong( 0x6015fd18 ),	/* 1612053784 */
/* 4326 */	NdrFcShort( 0x8257 ),	/* -32169 */
/* 4328 */	NdrFcShort( 0x4df3 ),	/* 19955 */
/* 4330 */	0xac,		/* 172 */
			0x42,		/* 66 */
/* 4332 */	0xf0,		/* 240 */
			0x74,		/* 116 */
/* 4334 */	0xde,		/* 222 */
			0xdd,		/* 221 */
/* 4336 */	0x4c,		/* 76 */
			0xbd,		/* 189 */
/* 4338 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4340 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4342) */
/* 4342 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4344 */	NdrFcLong( 0xf6b37e0 ),	/* 258684896 */
/* 4348 */	NdrFcShort( 0xfcfe ),	/* -770 */
/* 4350 */	NdrFcShort( 0x44d9 ),	/* 17625 */
/* 4352 */	0x91,		/* 145 */
			0x12,		/* 18 */
/* 4354 */	0x39,		/* 57 */
			0x4c,		/* 76 */
/* 4356 */	0xa9,		/* 169 */
			0xb9,		/* 185 */
/* 4358 */	0x21,		/* 33 */
			0x14,		/* 20 */
/* 4360 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4362 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4364) */
/* 4364 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4366 */	NdrFcLong( 0xe158f5aa ),	/* -514263638 */
/* 4370 */	NdrFcShort( 0x31fe ),	/* 12798 */
/* 4372 */	NdrFcShort( 0x491b ),	/* 18715 */
/* 4374 */	0xa9,		/* 169 */
			0xf6,		/* 246 */
/* 4376 */	0xcf,		/* 207 */
			0xf9,		/* 249 */
/* 4378 */	0x34,		/* 52 */
			0xb0,		/* 176 */
/* 4380 */	0x3a,		/* 58 */
			0x1,		/* 1 */
/* 4382 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4384 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4386) */
/* 4386 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4388 */	NdrFcLong( 0x6e215ef3 ),	/* 1847680755 */
/* 4392 */	NdrFcShort( 0xe44c ),	/* -7092 */
/* 4394 */	NdrFcShort( 0x44d1 ),	/* 17617 */
/* 4396 */	0xb7,		/* 183 */
			0xba,		/* 186 */
/* 4398 */	0xb2,		/* 178 */
			0x40,		/* 64 */
/* 4400 */	0x1f,		/* 31 */
			0x7d,		/* 125 */
/* 4402 */	0xc2,		/* 194 */
			0x3d,		/* 61 */
/* 4404 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4406 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4408) */
/* 4408 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4410 */	NdrFcLong( 0x603aedf8 ),	/* 1614474744 */
/* 4414 */	NdrFcShort( 0x9575 ),	/* -27275 */
/* 4416 */	NdrFcShort( 0x4d30 ),	/* 19760 */
/* 4418 */	0xb8,		/* 184 */
			0xca,		/* 202 */
/* 4420 */	0x12,		/* 18 */
			0x4d,		/* 77 */
/* 4422 */	0x1c,		/* 28 */
			0x98,		/* 152 */
/* 4424 */	0xeb,		/* 235 */
			0xd8,		/* 216 */
/* 4426 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4428 */	NdrFcLong( 0xade2eeb9 ),	/* -1377636679 */
/* 4432 */	NdrFcShort( 0xfc85 ),	/* -891 */
/* 4434 */	NdrFcShort( 0x4f5b ),	/* 20315 */
/* 4436 */	0xb5,		/* 181 */
			0xd9,		/* 217 */
/* 4438 */	0xd4,		/* 212 */
			0x31,		/* 49 */
/* 4440 */	0xb4,		/* 180 */
			0xaa,		/* 170 */
/* 4442 */	0xc3,		/* 195 */
			0x1a,		/* 26 */
/* 4444 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4446 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4448) */
/* 4448 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4450 */	NdrFcLong( 0xa7ee3e7e ),	/* -1477558658 */
/* 4454 */	NdrFcShort( 0x2dd2 ),	/* 11730 */
/* 4456 */	NdrFcShort( 0x4ad7 ),	/* 19159 */
/* 4458 */	0x96,		/* 150 */
			0x97,		/* 151 */
/* 4460 */	0xf4,		/* 244 */
			0xaa,		/* 170 */
/* 4462 */	0xe3,		/* 227 */
			0x42,		/* 66 */
/* 4464 */	0x77,		/* 119 */
			0x62,		/* 98 */
/* 4466 */	
			0x11, 0x0,	/* FC_RP */
/* 4468 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4470) */
/* 4470 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 4472 */	NdrFcShort( 0x40 ),	/* 64 */
/* 4474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4476 */	NdrFcShort( 0x0 ),	/* Offset= 0 (4476) */
/* 4478 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4480 */	0x0,		/* 0 */
			NdrFcShort( 0xffffee9d ),	/* Offset= -4451 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4484 */	0x0,		/* 0 */
			NdrFcShort( 0xffffee99 ),	/* Offset= -4455 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4488 */	0x0,		/* 0 */
			NdrFcShort( 0xffffee95 ),	/* Offset= -4459 (30) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4492 */	0x0,		/* 0 */
			NdrFcShort( 0xffffee91 ),	/* Offset= -4463 (30) */
			0x40,		/* FC_STRUCTPAD4 */
/* 4496 */	0xb,		/* FC_HYPER */
			0xb,		/* FC_HYPER */
/* 4498 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 4500 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4502 */	NdrFcShort( 0xfffff488 ),	/* Offset= -2936 (1566) */
/* 4504 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4506 */	NdrFcShort( 0xffffee84 ),	/* Offset= -4476 (30) */
/* 4508 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4510 */	
			0x11, 0x0,	/* FC_RP */
/* 4512 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4514) */
/* 4514 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 4516 */	NdrFcShort( 0x2 ),	/* 2 */
/* 4518 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4520 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4522 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4524 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4526 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 4528 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4530 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4532) */
/* 4532 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4534 */	NdrFcLong( 0x1606dd73 ),	/* 369548659 */
/* 4538 */	NdrFcShort( 0x5d5f ),	/* 23903 */
/* 4540 */	NdrFcShort( 0x405c ),	/* 16476 */
/* 4542 */	0xb4,		/* 180 */
			0xf4,		/* 244 */
/* 4544 */	0xce,		/* 206 */
			0x32,		/* 50 */
/* 4546 */	0xba,		/* 186 */
			0xba,		/* 186 */
/* 4548 */	0x25,		/* 37 */
			0x1,		/* 1 */
/* 4550 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4552 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4554) */
/* 4554 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4556 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4560 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4564 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 4566 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 4568 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 4570 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 4572 */	
			0x11, 0x0,	/* FC_RP */
/* 4574 */	NdrFcShort( 0x14 ),	/* Offset= 20 (4594) */
/* 4576 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4578 */	NdrFcLong( 0x43286fea ),	/* 1126723562 */
/* 4582 */	NdrFcShort( 0x6997 ),	/* 27031 */
/* 4584 */	NdrFcShort( 0x4543 ),	/* 17731 */
/* 4586 */	0x80,		/* 128 */
			0x3e,		/* 62 */
/* 4588 */	0x60,		/* 96 */
			0xa2,		/* 162 */
/* 4590 */	0xc,		/* 12 */
			0x47,		/* 71 */
/* 4592 */	0x3d,		/* 61 */
			0xe5,		/* 229 */
/* 4594 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4596 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4598 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4600 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4602 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4604 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4606 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4608 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4576) */
/* 4610 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4612 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4614 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4616) */
/* 4616 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4618 */	NdrFcLong( 0x96c74ef4 ),	/* -1765323020 */
/* 4622 */	NdrFcShort( 0x185d ),	/* 6237 */
/* 4624 */	NdrFcShort( 0x4f9a ),	/* 20378 */
/* 4626 */	0x8a,		/* 138 */
			0x43,		/* 67 */
/* 4628 */	0x4d,		/* 77 */
			0x27,		/* 39 */
/* 4630 */	0x23,		/* 35 */
			0x75,		/* 117 */
/* 4632 */	0x8e,		/* 142 */
			0xa,		/* 10 */
/* 4634 */	
			0x11, 0x0,	/* FC_RP */
/* 4636 */	NdrFcShort( 0x14 ),	/* Offset= 20 (4656) */
/* 4638 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4640 */	NdrFcLong( 0x69d172ef ),	/* 1775334127 */
/* 4644 */	NdrFcShort( 0xf2c4 ),	/* -3388 */
/* 4646 */	NdrFcShort( 0x44e1 ),	/* 17633 */
/* 4648 */	0x89,		/* 137 */
			0xf7,		/* 247 */
/* 4650 */	0xc8,		/* 200 */
			0x62,		/* 98 */
/* 4652 */	0x31,		/* 49 */
			0xe7,		/* 231 */
/* 4654 */	0x6,		/* 6 */
			0xe9,		/* 233 */
/* 4656 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4658 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4660 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4662 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4664 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4666 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4668 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4670 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4638) */
/* 4672 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4674 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4676 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4678) */
/* 4678 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4680 */	NdrFcLong( 0x8d14bca6 ),	/* -1928020826 */
/* 4684 */	NdrFcShort( 0x34ce ),	/* 13518 */
/* 4686 */	NdrFcShort( 0x4efe ),	/* 20222 */
/* 4688 */	0xac,		/* 172 */
			0x7e,		/* 126 */
/* 4690 */	0xa,		/* 10 */
			0xbc,		/* 188 */
/* 4692 */	0x61,		/* 97 */
			0xda,		/* 218 */
/* 4694 */	0xdb,		/* 219 */
			0x20,		/* 32 */
/* 4696 */	
			0x11, 0x0,	/* FC_RP */
/* 4698 */	NdrFcShort( 0x14 ),	/* Offset= 20 (4718) */
/* 4700 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4702 */	NdrFcLong( 0xd5168050 ),	/* -719945648 */
/* 4706 */	NdrFcShort( 0xa57a ),	/* -23174 */
/* 4708 */	NdrFcShort( 0x465c ),	/* 18012 */
/* 4710 */	0xbe,		/* 190 */
			0xa9,		/* 169 */
/* 4712 */	0x97,		/* 151 */
			0x4f,		/* 79 */
/* 4714 */	0x40,		/* 64 */
			0x5e,		/* 94 */
/* 4716 */	0xba,		/* 186 */
			0x13,		/* 19 */
/* 4718 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4722 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4724 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4726 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4728 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4730 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4732 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4700) */
/* 4734 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4736 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4738 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4740) */
/* 4740 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4742 */	NdrFcLong( 0xd30dc12 ),	/* 221305874 */
/* 4746 */	NdrFcShort( 0xc4f8 ),	/* -15112 */
/* 4748 */	NdrFcShort( 0x433d ),	/* 17213 */
/* 4750 */	0x9f,		/* 159 */
			0xcc,		/* 204 */
/* 4752 */	0x9f,		/* 159 */
			0xf1,		/* 241 */
/* 4754 */	0x17,		/* 23 */
			0xe5,		/* 229 */
/* 4756 */	0xe5,		/* 229 */
			0xf4,		/* 244 */
/* 4758 */	
			0x11, 0x0,	/* FC_RP */
/* 4760 */	NdrFcShort( 0x14 ),	/* Offset= 20 (4780) */
/* 4762 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4764 */	NdrFcLong( 0x1412926f ),	/* 336761455 */
/* 4768 */	NdrFcShort( 0x5dd6 ),	/* 24022 */
/* 4770 */	NdrFcShort( 0x4e58 ),	/* 20056 */
/* 4772 */	0xb6,		/* 182 */
			0x48,		/* 72 */
/* 4774 */	0xe1,		/* 225 */
			0xc6,		/* 198 */
/* 4776 */	0x3e,		/* 62 */
			0x1,		/* 1 */
/* 4778 */	0x3d,		/* 61 */
			0x51,		/* 81 */
/* 4780 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4782 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4784 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4786 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4788 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4790 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4792 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4794 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4762) */
/* 4796 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4798 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4800 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4802) */
/* 4802 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4804 */	NdrFcLong( 0xcd39102b ),	/* -851898325 */
/* 4808 */	NdrFcShort( 0x4b69 ),	/* 19305 */
/* 4810 */	NdrFcShort( 0x4495 ),	/* 17557 */
/* 4812 */	0x8f,		/* 143 */
			0x29,		/* 41 */
/* 4814 */	0xe0,		/* 224 */
			0xb2,		/* 178 */
/* 4816 */	0x5c,		/* 92 */
			0x4a,		/* 74 */
/* 4818 */	0x88,		/* 136 */
			0x55,		/* 85 */
/* 4820 */	
			0x11, 0x0,	/* FC_RP */
/* 4822 */	NdrFcShort( 0x14 ),	/* Offset= 20 (4842) */
/* 4824 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4826 */	NdrFcLong( 0xac17b76b ),	/* -1407731861 */
/* 4830 */	NdrFcShort( 0x2b09 ),	/* 11017 */
/* 4832 */	NdrFcShort( 0x419a ),	/* 16794 */
/* 4834 */	0xad,		/* 173 */
			0x5f,		/* 95 */
/* 4836 */	0x7d,		/* 125 */
			0x74,		/* 116 */
/* 4838 */	0x2,		/* 2 */
			0xda,		/* 218 */
/* 4840 */	0x88,		/* 136 */
			0x75,		/* 117 */
/* 4842 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4844 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4846 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4848 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4850 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4852 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4854 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4856 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4824) */
/* 4858 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4860 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4862 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4864) */
/* 4864 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4866 */	NdrFcLong( 0xad47a80b ),	/* -1387812853 */
/* 4870 */	NdrFcShort( 0xeda7 ),	/* -4697 */
/* 4872 */	NdrFcShort( 0x459e ),	/* 17822 */
/* 4874 */	0xaf,		/* 175 */
			0x82,		/* 130 */
/* 4876 */	0x64,		/* 100 */
			0x7c,		/* 124 */
/* 4878 */	0xc9,		/* 201 */
			0xfb,		/* 251 */
/* 4880 */	0xaa,		/* 170 */
			0x50,		/* 80 */
/* 4882 */	0x11, 0x0,	/* FC_RP */
/* 4884 */	NdrFcShort( 0x14 ),	/* Offset= 20 (4904) */
/* 4886 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4888 */	NdrFcLong( 0xd533d975 ),	/* -718022283 */
/* 4892 */	NdrFcShort( 0x3f32 ),	/* 16178 */
/* 4894 */	NdrFcShort( 0x4876 ),	/* 18550 */
/* 4896 */	0xab,		/* 171 */
			0xd0,		/* 208 */
/* 4898 */	0x6d,		/* 109 */
			0x37,		/* 55 */
/* 4900 */	0xfd,		/* 253 */
			0xa5,		/* 165 */
/* 4902 */	0x63,		/* 99 */
			0xe7,		/* 231 */
/* 4904 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4906 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4908 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4910 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4912 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4914 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4916 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4918 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4886) */
/* 4920 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4922 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4924 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4926) */
/* 4926 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4928 */	NdrFcLong( 0xf6b37e0 ),	/* 258684896 */
/* 4932 */	NdrFcShort( 0xfcfe ),	/* -770 */
/* 4934 */	NdrFcShort( 0x44d9 ),	/* 17625 */
/* 4936 */	0x91,		/* 145 */
			0x12,		/* 18 */
/* 4938 */	0x39,		/* 57 */
			0x4c,		/* 76 */
/* 4940 */	0xa9,		/* 169 */
			0xb9,		/* 185 */
/* 4942 */	0x21,		/* 33 */
			0x14,		/* 20 */
/* 4944 */	
			0x11, 0x0,	/* FC_RP */
/* 4946 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4948) */
/* 4948 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4950 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4952 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4954 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4956 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4958 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4960 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4962 */	NdrFcShort( 0xfffffdc0 ),	/* Offset= -576 (4386) */
/* 4964 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4966 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4968 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4970) */
/* 4970 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4972 */	NdrFcLong( 0x70d2dc1e ),	/* 1892867102 */
/* 4976 */	NdrFcShort( 0x4dcc ),	/* 19916 */
/* 4978 */	NdrFcShort( 0x4786 ),	/* 18310 */
/* 4980 */	0xa0,		/* 160 */
			0x72,		/* 114 */
/* 4982 */	0x9a,		/* 154 */
			0x3b,		/* 59 */
/* 4984 */	0x60,		/* 96 */
			0xc,		/* 12 */
/* 4986 */	0x21,		/* 33 */
			0x6b,		/* 107 */
/* 4988 */	
			0x11, 0x0,	/* FC_RP */
/* 4990 */	NdrFcShort( 0x14 ),	/* Offset= 20 (5010) */
/* 4992 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4994 */	NdrFcLong( 0x74570ef7 ),	/* 1951862519 */
/* 4998 */	NdrFcShort( 0x2486 ),	/* 9350 */
/* 5000 */	NdrFcShort( 0x4089 ),	/* 16521 */
/* 5002 */	0x80,		/* 128 */
			0xc,		/* 12 */
/* 5004 */	0x56,		/* 86 */
			0xe3,		/* 227 */
/* 5006 */	0x82,		/* 130 */
			0x9b,		/* 155 */
/* 5008 */	0x5c,		/* 92 */
			0xa4,		/* 164 */
/* 5010 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 5012 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5014 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 5016 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5018 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 5020 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5022 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5024 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4992) */
/* 5026 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5028 */	
			0x11, 0x0,	/* FC_RP */
/* 5030 */	NdrFcShort( 0x14 ),	/* Offset= 20 (5050) */
/* 5032 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 5034 */	NdrFcLong( 0x17bf8fa3 ),	/* 398430115 */
/* 5038 */	NdrFcShort( 0x4c5a ),	/* 19546 */
/* 5040 */	NdrFcShort( 0x49a3 ),	/* 18851 */
/* 5042 */	0xb2,		/* 178 */
			0xf8,		/* 248 */
/* 5044 */	0x59,		/* 89 */
			0x42,		/* 66 */
/* 5046 */	0xe1,		/* 225 */
			0xea,		/* 234 */
/* 5048 */	0x28,		/* 40 */
			0x7e,		/* 126 */
/* 5050 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 5052 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5054 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 5056 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5058 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 5060 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5062 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5064 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (5032) */
/* 5066 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5068 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 5070 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5072) */
/* 5072 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 5074 */	NdrFcLong( 0x61d986ec ),	/* 1641645804 */
/* 5078 */	NdrFcShort( 0x1eac ),	/* 7852 */
/* 5080 */	NdrFcShort( 0x46b6 ),	/* 18102 */
/* 5082 */	0x90,		/* 144 */
			0xff,		/* 255 */
/* 5084 */	0x40,		/* 64 */
			0x2a,		/* 42 */
/* 5086 */	0x0,		/* 0 */
			0x8f,		/* 143 */
/* 5088 */	0x15,		/* 21 */
			0xd1,		/* 209 */
/* 5090 */	
			0x11, 0x0,	/* FC_RP */
/* 5092 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5094) */
/* 5094 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 5096 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5098 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 5100 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5102 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 5104 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5106 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5108 */	NdrFcShort( 0xffffee78 ),	/* Offset= -4488 (620) */
/* 5110 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5112 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 5114 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5116) */
/* 5116 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 5118 */	NdrFcLong( 0x8e4bbd34 ),	/* -1907638988 */
/* 5122 */	NdrFcShort( 0xa2f4 ),	/* -23820 */
/* 5124 */	NdrFcShort( 0x41ef ),	/* 16879 */
/* 5126 */	0x87,		/* 135 */
			0xb5,		/* 181 */
/* 5128 */	0xc5,		/* 197 */
			0x63,		/* 99 */
/* 5130 */	0xb4,		/* 180 */
			0xad,		/* 173 */
/* 5132 */	0x6e,		/* 110 */
			0xe7,		/* 231 */
/* 5134 */	
			0x11, 0x0,	/* FC_RP */
/* 5136 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5138) */
/* 5138 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 5140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5142 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 5144 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5146 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 5148 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5150 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5152 */	NdrFcShort( 0xfffff8e0 ),	/* Offset= -1824 (3328) */
/* 5154 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5156 */	
			0x11, 0x0,	/* FC_RP */
/* 5158 */	NdrFcShort( 0x14 ),	/* Offset= 20 (5178) */
/* 5160 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 5162 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5166 */	NdrFcShort( 0xc ),	/* Offset= 12 (5178) */
/* 5168 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5170 */	NdrFcShort( 0xffffebec ),	/* Offset= -5140 (30) */
/* 5172 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5174 */	NdrFcShort( 0xfffff3a6 ),	/* Offset= -3162 (2012) */
/* 5176 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5178 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 5180 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5182 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 5184 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5186 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 5188 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5190 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5192 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (5160) */
/* 5194 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5196 */	
			0x11, 0x0,	/* FC_RP */
/* 5198 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5200) */
/* 5200 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 5202 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5204 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 5206 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5208 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 5210 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5212 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5214 */	NdrFcShort( 0xfffff3ae ),	/* Offset= -3154 (2060) */
/* 5216 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5218 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 5220 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5222) */
/* 5222 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 5224 */	NdrFcLong( 0x4c4a2835 ),	/* 1279928373 */
/* 5228 */	NdrFcShort( 0x682e ),	/* 26670 */
/* 5230 */	NdrFcShort( 0x4ce1 ),	/* 19681 */
/* 5232 */	0xae,		/* 174 */
			0xbc,		/* 188 */
/* 5234 */	0x1e,		/* 30 */
			0x6b,		/* 107 */
/* 5236 */	0x3a,		/* 58 */
			0x16,		/* 22 */
/* 5238 */	0x5b,		/* 91 */
			0x44,		/* 68 */
/* 5240 */	
			0x11, 0x0,	/* FC_RP */
/* 5242 */	NdrFcShort( 0x14 ),	/* Offset= 20 (5262) */
/* 5244 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 5246 */	NdrFcLong( 0x53f68191 ),	/* 1408663953 */
/* 5250 */	NdrFcShort( 0x7b2f ),	/* 31535 */
/* 5252 */	NdrFcShort( 0x4f14 ),	/* 20244 */
/* 5254 */	0x8e,		/* 142 */
			0x55,		/* 85 */
/* 5256 */	0x40,		/* 64 */
			0xb1,		/* 177 */
/* 5258 */	0xb6,		/* 182 */
			0xe5,		/* 229 */
/* 5260 */	0xdf,		/* 223 */
			0x66,		/* 102 */
/* 5262 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 5264 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5266 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 5268 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5270 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 5272 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5274 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5276 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (5244) */
/* 5278 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5280 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 5282 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5284) */
/* 5284 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 5286 */	NdrFcLong( 0x59c9dc99 ),	/* 1506401433 */
/* 5290 */	NdrFcShort( 0x3eff ),	/* 16127 */
/* 5292 */	NdrFcShort( 0x4ff3 ),	/* 20467 */
/* 5294 */	0xb2,		/* 178 */
			0x1,		/* 1 */
/* 5296 */	0x98,		/* 152 */
			0xac,		/* 172 */
/* 5298 */	0xd0,		/* 208 */
			0x1b,		/* 27 */
/* 5300 */	0xd,		/* 13 */
			0x87,		/* 135 */
/* 5302 */	
			0x11, 0x0,	/* FC_RP */
/* 5304 */	NdrFcShort( 0x14 ),	/* Offset= 20 (5324) */
/* 5306 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 5308 */	NdrFcLong( 0x79293cc8 ),	/* 2032745672 */
/* 5312 */	NdrFcShort( 0xd9d9 ),	/* -9767 */
/* 5314 */	NdrFcShort( 0x43f5 ),	/* 17397 */
/* 5316 */	0x97,		/* 151 */
			0xad,		/* 173 */
/* 5318 */	0xb,		/* 11 */
			0xcc,		/* 204 */
/* 5320 */	0x5a,		/* 90 */
			0x68,		/* 104 */
/* 5322 */	0x87,		/* 135 */
			0x76,		/* 118 */
/* 5324 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 5326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5328 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 5330 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5332 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 5334 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5336 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5338 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (5306) */
/* 5340 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5342 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 5344 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5346) */
/* 5346 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 5348 */	NdrFcLong( 0xbc827c5e ),	/* -1132299170 */
/* 5352 */	NdrFcShort( 0x99ae ),	/* -26194 */
/* 5354 */	NdrFcShort( 0x4ac8 ),	/* 19144 */
/* 5356 */	0x83,		/* 131 */
			0xad,		/* 173 */
/* 5358 */	0x2e,		/* 46 */
			0xa5,		/* 165 */
/* 5360 */	0xc2,		/* 194 */
			0x3,		/* 3 */
/* 5362 */	0x43,		/* 67 */
			0x33,		/* 51 */
/* 5364 */	
			0x11, 0x0,	/* FC_RP */
/* 5366 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5368) */
/* 5368 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 5370 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5372 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 5374 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5376 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 5378 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5380 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5382 */	NdrFcShort( 0xfffff678 ),	/* Offset= -2440 (2942) */
/* 5384 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5386 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 5388 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5390) */
/* 5390 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 5392 */	NdrFcLong( 0x6c7072c3 ),	/* 1819308739 */
/* 5396 */	NdrFcShort( 0x3ac4 ),	/* 15044 */
/* 5398 */	NdrFcShort( 0x408f ),	/* 16527 */
/* 5400 */	0xa6,		/* 166 */
			0x80,		/* 128 */
/* 5402 */	0xfc,		/* 252 */
			0x5a,		/* 90 */
/* 5404 */	0x2f,		/* 47 */
			0x96,		/* 150 */
/* 5406 */	0x90,		/* 144 */
			0x3e,		/* 62 */
/* 5408 */	
			0x11, 0x0,	/* FC_RP */
/* 5410 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5412) */
/* 5412 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 5414 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5416 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 5418 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 5420 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 5422 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 5424 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5426 */	NdrFcShort( 0xfffff6f4 ),	/* Offset= -2316 (3110) */
/* 5428 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5430 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 5432 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5434) */
/* 5434 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 5436 */	NdrFcLong( 0xe459dd12 ),	/* -463872750 */
/* 5440 */	NdrFcShort( 0x864f ),	/* -31153 */
/* 5442 */	NdrFcShort( 0x4aaa ),	/* 19114 */
/* 5444 */	0xab,		/* 171 */
			0xc1,		/* 193 */
/* 5446 */	0xdc,		/* 220 */
			0xec,		/* 236 */
/* 5448 */	0xbc,		/* 188 */
			0x26,		/* 38 */
/* 5450 */	0x7f,		/* 127 */
			0x4,		/* 4 */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            },
            {
            VARIANT_UserSize
            ,VARIANT_UserMarshal
            ,VARIANT_UserUnmarshal
            ,VARIANT_UserFree
            }

        };



/* Standard interface: __MIDL_itf_msdbg_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDebugMachine2, ver. 0.0,
   GUID={0x17bf8fa3,0x4c5a,0x49a3,{0xb2,0xf8,0x59,0x42,0xe1,0xea,0x28,0x7e}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugMachine2_FormatStringOffsetTable[] =
    {
    0,
    34,
    62,
    96,
    130,
    158,
    186
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugMachine2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugMachine2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugMachine2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugMachine2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(10) _IDebugMachine2ProxyVtbl = 
{
    &IDebugMachine2_ProxyInfo,
    &IID_IDebugMachine2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugMachine2::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugMachine2::GetName */ ,
    (void *) (INT_PTR) -1 /* IDebugMachine2::GetPortSupplier */ ,
    (void *) (INT_PTR) -1 /* IDebugMachine2::GetPort */ ,
    (void *) (INT_PTR) -1 /* IDebugMachine2::EnumPorts */ ,
    (void *) (INT_PTR) -1 /* IDebugMachine2::EnumPortSuppliers */ ,
    (void *) (INT_PTR) -1 /* IDebugMachine2::GetMachineUtilities */
};

const CInterfaceStubVtbl _IDebugMachine2StubVtbl =
{
    &IID_IDebugMachine2,
    &IDebugMachine2_ServerInfo,
    10,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugMachineEx2, ver. 0.0,
   GUID={0xae27b230,0xa0bf,0x47ff,{0xa2,0xd1,0x22,0xc2,0x9a,0x17,0x8e,0xac}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugMachineEx2_FormatStringOffsetTable[] =
    {
    214,
    260,
    288,
    328,
    368,
    402
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugMachineEx2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugMachineEx2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugMachineEx2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugMachineEx2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(9) _IDebugMachineEx2ProxyVtbl = 
{
    &IDebugMachineEx2_ProxyInfo,
    &IID_IDebugMachineEx2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugMachineEx2::EnableAutoAttachOnProgramCreate */ ,
    (void *) (INT_PTR) -1 /* IDebugMachineEx2::DisableAutoAttachOnEvent */ ,
    (void *) (INT_PTR) -1 /* IDebugMachineEx2::GetPortSupplierEx */ ,
    (void *) (INT_PTR) -1 /* IDebugMachineEx2::GetPortEx */ ,
    (void *) (INT_PTR) -1 /* IDebugMachineEx2::EnumPortsEx */ ,
    (void *) (INT_PTR) -1 /* IDebugMachineEx2::EnumPortSuppliersEx */
};

const CInterfaceStubVtbl _IDebugMachineEx2StubVtbl =
{
    &IID_IDebugMachineEx2,
    &IDebugMachineEx2_ServerInfo,
    9,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugPortSupplier2, ver. 0.0,
   GUID={0x53f68191,0x7b2f,0x4f14,{0x8e,0x55,0x40,0xb1,0xb6,0xe5,0xdf,0x66}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugPortSupplier2_FormatStringOffsetTable[] =
    {
    436,
    464,
    492,
    526,
    554,
    576,
    610
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugPortSupplier2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugPortSupplier2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugPortSupplier2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugPortSupplier2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(10) _IDebugPortSupplier2ProxyVtbl = 
{
    &IDebugPortSupplier2_ProxyInfo,
    &IID_IDebugPortSupplier2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugPortSupplier2::GetPortSupplierName */ ,
    (void *) (INT_PTR) -1 /* IDebugPortSupplier2::GetPortSupplierId */ ,
    (void *) (INT_PTR) -1 /* IDebugPortSupplier2::GetPort */ ,
    (void *) (INT_PTR) -1 /* IDebugPortSupplier2::EnumPorts */ ,
    (void *) (INT_PTR) -1 /* IDebugPortSupplier2::CanAddPort */ ,
    (void *) (INT_PTR) -1 /* IDebugPortSupplier2::AddPort */ ,
    (void *) (INT_PTR) -1 /* IDebugPortSupplier2::RemovePort */
};

const CInterfaceStubVtbl _IDebugPortSupplier2StubVtbl =
{
    &IID_IDebugPortSupplier2,
    &IDebugPortSupplier2_ServerInfo,
    10,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugPort2, ver. 0.0,
   GUID={0x79293cc8,0xd9d9,0x43f5,{0x97,0xad,0x0b,0xcc,0x5a,0x68,0x87,0x76}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugPort2_FormatStringOffsetTable[] =
    {
    436,
    464,
    638,
    666,
    694,
    728
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugPort2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugPort2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugPort2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugPort2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(9) _IDebugPort2ProxyVtbl = 
{
    &IDebugPort2_ProxyInfo,
    &IID_IDebugPort2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugPort2::GetPortName */ ,
    (void *) (INT_PTR) -1 /* IDebugPort2::GetPortId */ ,
    (void *) (INT_PTR) -1 /* IDebugPort2::GetPortRequest */ ,
    (void *) (INT_PTR) -1 /* IDebugPort2::GetPortSupplier */ ,
    (void *) (INT_PTR) -1 /* IDebugPort2::GetProcess */ ,
    (void *) (INT_PTR) -1 /* IDebugPort2::EnumProcesses */
};

const CInterfaceStubVtbl _IDebugPort2StubVtbl =
{
    &IID_IDebugPort2,
    &IDebugPort2_ServerInfo,
    9,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugPortRequest2, ver. 0.0,
   GUID={0x8d36beb8,0x9bfe,0x47dd,{0xa1,0x1b,0x7b,0xa1,0xde,0x18,0xe4,0x49}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugPortRequest2_FormatStringOffsetTable[] =
    {
    436
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugPortRequest2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugPortRequest2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugPortRequest2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugPortRequest2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugPortRequest2ProxyVtbl = 
{
    &IDebugPortRequest2_ProxyInfo,
    &IID_IDebugPortRequest2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugPortRequest2::GetPortName */
};

const CInterfaceStubVtbl _IDebugPortRequest2StubVtbl =
{
    &IID_IDebugPortRequest2,
    &IDebugPortRequest2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugPortNotify2, ver. 0.0,
   GUID={0xfb8d2032,0x2858,0x414c,{0x83,0xd9,0xf7,0x32,0x66,0x4e,0x0c,0x7a}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugPortNotify2_FormatStringOffsetTable[] =
    {
    756,
    784
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugPortNotify2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugPortNotify2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugPortNotify2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugPortNotify2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugPortNotify2ProxyVtbl = 
{
    &IDebugPortNotify2_ProxyInfo,
    &IID_IDebugPortNotify2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugPortNotify2::AddProgramNode */ ,
    (void *) (INT_PTR) -1 /* IDebugPortNotify2::RemoveProgramNode */
};

const CInterfaceStubVtbl _IDebugPortNotify2StubVtbl =
{
    &IID_IDebugPortNotify2,
    &IDebugPortNotify2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugPortEvents2, ver. 0.0,
   GUID={0x564fa275,0x12e1,0x4b5f,{0x83,0x16,0x4d,0x79,0xbc,0xef,0x72,0x46}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugPortEvents2_FormatStringOffsetTable[] =
    {
    812
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugPortEvents2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugPortEvents2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugPortEvents2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugPortEvents2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugPortEvents2ProxyVtbl = 
{
    &IDebugPortEvents2_ProxyInfo,
    &IID_IDebugPortEvents2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugPortEvents2::Event */
};

const CInterfaceStubVtbl _IDebugPortEvents2StubVtbl =
{
    &IID_IDebugPortEvents2,
    &IDebugPortEvents2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugMDMUtil2, ver. 0.0,
   GUID={0xf3062547,0x43d8,0x4dc2,{0xb1,0x8e,0xe1,0x46,0x0f,0xf2,0xc4,0x22}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugMDMUtil2_FormatStringOffsetTable[] =
    {
    870,
    904,
    938,
    972,
    1006,
    1040,
    1074,
    1102,
    1130,
    1182
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugMDMUtil2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugMDMUtil2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugMDMUtil2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugMDMUtil2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(13) _IDebugMDMUtil2ProxyVtbl = 
{
    &IDebugMDMUtil2_ProxyInfo,
    &IID_IDebugMDMUtil2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugMDMUtil2::AddPIDToIgnore */ ,
    (void *) (INT_PTR) -1 /* IDebugMDMUtil2::RemovePIDToIgnore */ ,
    (void *) (INT_PTR) -1 /* IDebugMDMUtil2::AddPIDToDebug */ ,
    (void *) (INT_PTR) -1 /* IDebugMDMUtil2::RemovePIDToDebug */ ,
    (void *) (INT_PTR) -1 /* IDebugMDMUtil2::SetDynamicDebuggingFlags */ ,
    (void *) (INT_PTR) -1 /* IDebugMDMUtil2::GetDynamicDebuggingFlags */ ,
    (void *) (INT_PTR) -1 /* IDebugMDMUtil2::SetDefaultJITServer */ ,
    (void *) (INT_PTR) -1 /* IDebugMDMUtil2::GetDefaultJITServer */ ,
    (void *) (INT_PTR) -1 /* IDebugMDMUtil2::RegisterJITDebugEngines */ ,
    (void *) (INT_PTR) -1 /* IDebugMDMUtil2::CanDebugPID */
};

const CInterfaceStubVtbl _IDebugMDMUtil2StubVtbl =
{
    &IID_IDebugMDMUtil2,
    &IDebugMDMUtil2_ServerInfo,
    13,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugSession2, ver. 0.0,
   GUID={0x8948300f,0x8bd5,0x4728,{0xa1,0xd8,0x83,0xd1,0x72,0x29,0x5a,0x9d}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugSession2_FormatStringOffsetTable[] =
    {
    436,
    1216,
    1244,
    1272,
    1390,
    1418,
    1446,
    1468,
    1490,
    1524,
    1564,
    1592,
    1626,
    1654,
    1676,
    1716,
    1744,
    1790,
    1818,
    1846,
    1880,
    1914,
    1942,
    1970,
    1992,
    2014,
    2066,
    2106,
    2134,
    2162
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugSession2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugSession2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugSession2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugSession2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(33) _IDebugSession2ProxyVtbl = 
{
    &IDebugSession2_ProxyInfo,
    &IID_IDebugSession2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugSession2::GetName */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::SetName */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::EnumProcesses */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::Launch */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::RegisterJITServer */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::Terminate */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::Detach */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::CauseBreak */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::CreatePendingBreakpoint */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::EnumPendingBreakpoints */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::EnumMachines */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::AddMachine */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::RemoveMachine */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::ShutdownSession */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::EnumCodeContexts */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::SetException */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::EnumSetExceptions */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::RemoveSetException */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::RemoveAllSetExceptions */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::EnumDefaultExceptions */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::GetENCUpdate */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::SetLocale */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::SetRegistryRoot */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::IsAlive */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::ClearAllSessionThreadStackFrames */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::GetSessionId */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::SetEngineMetric */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::SetStoppingModel */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::GetStoppingModel */ ,
    (void *) (INT_PTR) -1 /* IDebugSession2::RegisterSessionWithServer */
};

const CInterfaceStubVtbl _IDebugSession2StubVtbl =
{
    &IID_IDebugSession2,
    &IDebugSession2_ServerInfo,
    33,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugEngine2, ver. 0.0,
   GUID={0xba105b52,0x12f1,0x4038,{0xae,0x64,0xd9,0x57,0x85,0x87,0x4c,0x47}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugEngine2_FormatStringOffsetTable[] =
    {
    2190,
    2218,
    2270,
    2304,
    2332,
    2360,
    2388,
    2416,
    2444,
    2472,
    2500,
    2528,
    2562
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugEngine2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugEngine2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugEngine2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugEngine2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(16) _IDebugEngine2ProxyVtbl = 
{
    &IDebugEngine2_ProxyInfo,
    &IID_IDebugEngine2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugEngine2::EnumPrograms */ ,
    (void *) (INT_PTR) -1 /* IDebugEngine2::Attach */ ,
    (void *) (INT_PTR) -1 /* IDebugEngine2::CreatePendingBreakpoint */ ,
    (void *) (INT_PTR) -1 /* IDebugEngine2::SetException */ ,
    (void *) (INT_PTR) -1 /* IDebugEngine2::RemoveSetException */ ,
    (void *) (INT_PTR) -1 /* IDebugEngine2::RemoveAllSetExceptions */ ,
    (void *) (INT_PTR) -1 /* IDebugEngine2::GetEngineId */ ,
    (void *) (INT_PTR) -1 /* IDebugEngine2::DestroyProgram */ ,
    (void *) (INT_PTR) -1 /* IDebugEngine2::ContinueFromSynchronousEvent */ ,
    (void *) (INT_PTR) -1 /* IDebugEngine2::SetLocale */ ,
    (void *) (INT_PTR) -1 /* IDebugEngine2::SetRegistryRoot */ ,
    (void *) (INT_PTR) -1 /* IDebugEngine2::SetMetric */ ,
    (void *) (INT_PTR) -1 /* IDebugEngine2::CauseBreak */
};

const CInterfaceStubVtbl _IDebugEngine2StubVtbl =
{
    &IID_IDebugEngine2,
    &IDebugEngine2_ServerInfo,
    16,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugEngineLaunch2, ver. 0.0,
   GUID={0xc7c1462f,0x9736,0x466c,{0xb2,0xc1,0xb6,0xb2,0xde,0xdb,0xf4,0xa7}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugEngineLaunch2_FormatStringOffsetTable[] =
    {
    2584,
    2684,
    2712,
    2740
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugEngineLaunch2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugEngineLaunch2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugEngineLaunch2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugEngineLaunch2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IDebugEngineLaunch2ProxyVtbl = 
{
    &IDebugEngineLaunch2_ProxyInfo,
    &IID_IDebugEngineLaunch2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugEngineLaunch2::LaunchSuspended */ ,
    (void *) (INT_PTR) -1 /* IDebugEngineLaunch2::ResumeProcess */ ,
    (void *) (INT_PTR) -1 /* IDebugEngineLaunch2::CanTerminateProcess */ ,
    (void *) (INT_PTR) -1 /* IDebugEngineLaunch2::TerminateProcess */
};

const CInterfaceStubVtbl _IDebugEngineLaunch2StubVtbl =
{
    &IID_IDebugEngineLaunch2,
    &IDebugEngineLaunch2_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugEventCallback2, ver. 0.0,
   GUID={0xade2eeb9,0xfc85,0x4f5b,{0xb5,0xd9,0xd4,0x31,0xb4,0xaa,0xc3,0x1a}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugEventCallback2_FormatStringOffsetTable[] =
    {
    2768
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugEventCallback2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugEventCallback2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugEventCallback2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugEventCallback2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugEventCallback2ProxyVtbl = 
{
    &IDebugEventCallback2_ProxyInfo,
    &IID_IDebugEventCallback2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugEventCallback2::Event */
};

const CInterfaceStubVtbl _IDebugEventCallback2StubVtbl =
{
    &IID_IDebugEventCallback2,
    &IDebugEventCallback2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugEvent2, ver. 0.0,
   GUID={0x423238d6,0xda42,0x4989,{0x96,0xfb,0x6b,0xba,0x26,0xe7,0x2e,0x09}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugEvent2_FormatStringOffsetTable[] =
    {
    2832
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugEvent2ProxyVtbl = 
{
    &IDebugEvent2_ProxyInfo,
    &IID_IDebugEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugEvent2::GetAttributes */
};

const CInterfaceStubVtbl _IDebugEvent2StubVtbl =
{
    &IID_IDebugEvent2,
    &IDebugEvent2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugSessionCreateEvent2, ver. 0.0,
   GUID={0x2c2b15b7,0xfc6d,0x45b3,{0x96,0x22,0x29,0x66,0x5d,0x96,0x4a,0x76}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugSessionCreateEvent2_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugSessionCreateEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugSessionCreateEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugSessionCreateEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugSessionCreateEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(3) _IDebugSessionCreateEvent2ProxyVtbl = 
{
    0,
    &IID_IDebugSessionCreateEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};

const CInterfaceStubVtbl _IDebugSessionCreateEvent2StubVtbl =
{
    &IID_IDebugSessionCreateEvent2,
    &IDebugSessionCreateEvent2_ServerInfo,
    3,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugSessionDestroyEvent2, ver. 0.0,
   GUID={0xf199b2c2,0x88fe,0x4c5d,{0xa0,0xfd,0xaa,0x04,0x6b,0x0d,0xc0,0xdc}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugSessionDestroyEvent2_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugSessionDestroyEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugSessionDestroyEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugSessionDestroyEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugSessionDestroyEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(3) _IDebugSessionDestroyEvent2ProxyVtbl = 
{
    0,
    &IID_IDebugSessionDestroyEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};

const CInterfaceStubVtbl _IDebugSessionDestroyEvent2StubVtbl =
{
    &IID_IDebugSessionDestroyEvent2,
    &IDebugSessionDestroyEvent2_ServerInfo,
    3,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugEngineCreateEvent2, ver. 0.0,
   GUID={0xfe5b734c,0x759d,0x4e59,{0xab,0x04,0xf1,0x03,0x34,0x3b,0xdd,0x06}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugEngineCreateEvent2_FormatStringOffsetTable[] =
    {
    2860
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugEngineCreateEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugEngineCreateEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugEngineCreateEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugEngineCreateEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugEngineCreateEvent2ProxyVtbl = 
{
    &IDebugEngineCreateEvent2_ProxyInfo,
    &IID_IDebugEngineCreateEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugEngineCreateEvent2::GetEngine */
};

const CInterfaceStubVtbl _IDebugEngineCreateEvent2StubVtbl =
{
    &IID_IDebugEngineCreateEvent2,
    &IDebugEngineCreateEvent2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugProcessCreateEvent2, ver. 0.0,
   GUID={0xbac3780f,0x04da,0x4726,{0x90,0x1c,0xba,0x6a,0x46,0x33,0xe1,0xca}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugProcessCreateEvent2_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugProcessCreateEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugProcessCreateEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugProcessCreateEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugProcessCreateEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(3) _IDebugProcessCreateEvent2ProxyVtbl = 
{
    0,
    &IID_IDebugProcessCreateEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};

const CInterfaceStubVtbl _IDebugProcessCreateEvent2StubVtbl =
{
    &IID_IDebugProcessCreateEvent2,
    &IDebugProcessCreateEvent2_ServerInfo,
    3,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugProcessDestroyEvent2, ver. 0.0,
   GUID={0x3e2a0832,0x17e1,0x4886,{0x8c,0x0e,0x20,0x4d,0xa2,0x42,0x99,0x5f}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugProcessDestroyEvent2_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugProcessDestroyEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugProcessDestroyEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugProcessDestroyEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugProcessDestroyEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(3) _IDebugProcessDestroyEvent2ProxyVtbl = 
{
    0,
    &IID_IDebugProcessDestroyEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};

const CInterfaceStubVtbl _IDebugProcessDestroyEvent2StubVtbl =
{
    &IID_IDebugProcessDestroyEvent2,
    &IDebugProcessDestroyEvent2_ServerInfo,
    3,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugProgramCreateEvent2, ver. 0.0,
   GUID={0x96cd11ee,0xecd4,0x4e89,{0x95,0x7e,0xb5,0xd4,0x96,0xfc,0x41,0x39}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugProgramCreateEvent2_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugProgramCreateEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugProgramCreateEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugProgramCreateEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugProgramCreateEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(3) _IDebugProgramCreateEvent2ProxyVtbl = 
{
    0,
    &IID_IDebugProgramCreateEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};

const CInterfaceStubVtbl _IDebugProgramCreateEvent2StubVtbl =
{
    &IID_IDebugProgramCreateEvent2,
    &IDebugProgramCreateEvent2_ServerInfo,
    3,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugProgramDestroyEvent2, ver. 0.0,
   GUID={0xe147e9e3,0x6440,0x4073,{0xa7,0xb7,0xa6,0x55,0x92,0xc7,0x14,0xb5}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugProgramDestroyEvent2_FormatStringOffsetTable[] =
    {
    2832
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugProgramDestroyEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugProgramDestroyEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugProgramDestroyEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugProgramDestroyEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugProgramDestroyEvent2ProxyVtbl = 
{
    &IDebugProgramDestroyEvent2_ProxyInfo,
    &IID_IDebugProgramDestroyEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugProgramDestroyEvent2::GetExitCode */
};

const CInterfaceStubVtbl _IDebugProgramDestroyEvent2StubVtbl =
{
    &IID_IDebugProgramDestroyEvent2,
    &IDebugProgramDestroyEvent2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugThreadCreateEvent2, ver. 0.0,
   GUID={0x2090ccfc,0x70c5,0x491d,{0xa5,0xe8,0xba,0xd2,0xdd,0x9e,0xe3,0xea}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugThreadCreateEvent2_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugThreadCreateEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugThreadCreateEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugThreadCreateEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugThreadCreateEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(3) _IDebugThreadCreateEvent2ProxyVtbl = 
{
    0,
    &IID_IDebugThreadCreateEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};

const CInterfaceStubVtbl _IDebugThreadCreateEvent2StubVtbl =
{
    &IID_IDebugThreadCreateEvent2,
    &IDebugThreadCreateEvent2_ServerInfo,
    3,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugThreadDestroyEvent2, ver. 0.0,
   GUID={0x2c3b7532,0xa36f,0x4a6e,{0x90,0x72,0x49,0xbe,0x64,0x9b,0x85,0x41}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugThreadDestroyEvent2_FormatStringOffsetTable[] =
    {
    2832
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugThreadDestroyEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugThreadDestroyEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugThreadDestroyEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugThreadDestroyEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugThreadDestroyEvent2ProxyVtbl = 
{
    &IDebugThreadDestroyEvent2_ProxyInfo,
    &IID_IDebugThreadDestroyEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugThreadDestroyEvent2::GetExitCode */
};

const CInterfaceStubVtbl _IDebugThreadDestroyEvent2StubVtbl =
{
    &IID_IDebugThreadDestroyEvent2,
    &IDebugThreadDestroyEvent2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugLoadCompleteEvent2, ver. 0.0,
   GUID={0xb1844850,0x1349,0x45d4,{0x9f,0x12,0x49,0x52,0x12,0xf5,0xeb,0x0b}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugLoadCompleteEvent2_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugLoadCompleteEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugLoadCompleteEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugLoadCompleteEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugLoadCompleteEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(3) _IDebugLoadCompleteEvent2ProxyVtbl = 
{
    0,
    &IID_IDebugLoadCompleteEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};

const CInterfaceStubVtbl _IDebugLoadCompleteEvent2StubVtbl =
{
    &IID_IDebugLoadCompleteEvent2,
    &IDebugLoadCompleteEvent2_ServerInfo,
    3,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugEntryPointEvent2, ver. 0.0,
   GUID={0xe8414a3e,0x1642,0x48ec,{0x82,0x9e,0x5f,0x40,0x40,0xe1,0x6d,0xa9}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugEntryPointEvent2_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugEntryPointEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugEntryPointEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugEntryPointEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugEntryPointEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(3) _IDebugEntryPointEvent2ProxyVtbl = 
{
    0,
    &IID_IDebugEntryPointEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};

const CInterfaceStubVtbl _IDebugEntryPointEvent2StubVtbl =
{
    &IID_IDebugEntryPointEvent2,
    &IDebugEntryPointEvent2_ServerInfo,
    3,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugStepCompleteEvent2, ver. 0.0,
   GUID={0x0f7f24c1,0x74d9,0x4ea6,{0xa3,0xea,0x7e,0xdb,0x2d,0x81,0x44,0x1d}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugStepCompleteEvent2_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugStepCompleteEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugStepCompleteEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugStepCompleteEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugStepCompleteEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(3) _IDebugStepCompleteEvent2ProxyVtbl = 
{
    0,
    &IID_IDebugStepCompleteEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};

const CInterfaceStubVtbl _IDebugStepCompleteEvent2StubVtbl =
{
    &IID_IDebugStepCompleteEvent2,
    &IDebugStepCompleteEvent2_ServerInfo,
    3,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugCanStopEvent2, ver. 0.0,
   GUID={0xb5b0d747,0xd4d2,0x4e2d,{0x87,0x2d,0x74,0xda,0x22,0x03,0x78,0x26}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugCanStopEvent2_FormatStringOffsetTable[] =
    {
    2832,
    260,
    2888,
    2916
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugCanStopEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugCanStopEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugCanStopEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugCanStopEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IDebugCanStopEvent2ProxyVtbl = 
{
    &IDebugCanStopEvent2_ProxyInfo,
    &IID_IDebugCanStopEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugCanStopEvent2::GetReason */ ,
    (void *) (INT_PTR) -1 /* IDebugCanStopEvent2::CanStop */ ,
    (void *) (INT_PTR) -1 /* IDebugCanStopEvent2::GetDocumentContext */ ,
    (void *) (INT_PTR) -1 /* IDebugCanStopEvent2::GetCodeContext */
};

const CInterfaceStubVtbl _IDebugCanStopEvent2StubVtbl =
{
    &IID_IDebugCanStopEvent2,
    &IDebugCanStopEvent2_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugBreakEvent2, ver. 0.0,
   GUID={0xc7405d1d,0xe24b,0x44e0,{0xb7,0x07,0xd8,0xa5,0xa4,0xe1,0x64,0x1b}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugBreakEvent2_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugBreakEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugBreakEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(3) _IDebugBreakEvent2ProxyVtbl = 
{
    0,
    &IID_IDebugBreakEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};

const CInterfaceStubVtbl _IDebugBreakEvent2StubVtbl =
{
    &IID_IDebugBreakEvent2,
    &IDebugBreakEvent2_ServerInfo,
    3,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugBreakpointEvent2, ver. 0.0,
   GUID={0x501c1e21,0xc557,0x48b8,{0xba,0x30,0xa1,0xea,0xb0,0xbc,0x4a,0x74}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugBreakpointEvent2_FormatStringOffsetTable[] =
    {
    2944
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugBreakpointEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakpointEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugBreakpointEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakpointEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugBreakpointEvent2ProxyVtbl = 
{
    &IDebugBreakpointEvent2_ProxyInfo,
    &IID_IDebugBreakpointEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugBreakpointEvent2::EnumBreakpoints */
};

const CInterfaceStubVtbl _IDebugBreakpointEvent2StubVtbl =
{
    &IID_IDebugBreakpointEvent2,
    &IDebugBreakpointEvent2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugExceptionEvent2, ver. 0.0,
   GUID={0x51a94113,0x8788,0x4a54,{0xae,0x15,0x08,0xb7,0x4f,0xf9,0x22,0xd0}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugExceptionEvent2_FormatStringOffsetTable[] =
    {
    2972,
    34,
    3000,
    3022
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugExceptionEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugExceptionEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugExceptionEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugExceptionEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IDebugExceptionEvent2ProxyVtbl = 
{
    &IDebugExceptionEvent2_ProxyInfo,
    &IID_IDebugExceptionEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugExceptionEvent2::GetException */ ,
    (void *) (INT_PTR) -1 /* IDebugExceptionEvent2::GetExceptionDescription */ ,
    (void *) (INT_PTR) -1 /* IDebugExceptionEvent2::CanPassToDebuggee */ ,
    (void *) (INT_PTR) -1 /* IDebugExceptionEvent2::PassToDebuggee */
};

const CInterfaceStubVtbl _IDebugExceptionEvent2StubVtbl =
{
    &IID_IDebugExceptionEvent2,
    &IDebugExceptionEvent2_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugOutputStringEvent2, ver. 0.0,
   GUID={0x569c4bb1,0x7b82,0x46fc,{0xae,0x28,0x45,0x36,0xdd,0xad,0x75,0x3e}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugOutputStringEvent2_FormatStringOffsetTable[] =
    {
    436
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugOutputStringEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugOutputStringEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugOutputStringEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugOutputStringEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugOutputStringEvent2ProxyVtbl = 
{
    &IDebugOutputStringEvent2_ProxyInfo,
    &IID_IDebugOutputStringEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugOutputStringEvent2::GetString */
};

const CInterfaceStubVtbl _IDebugOutputStringEvent2StubVtbl =
{
    &IID_IDebugOutputStringEvent2,
    &IDebugOutputStringEvent2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugModuleLoadEvent2, ver. 0.0,
   GUID={0x989db083,0x0d7c,0x40d1,{0xa9,0xd9,0x92,0x1b,0xf6,0x11,0xa4,0xb2}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugModuleLoadEvent2_FormatStringOffsetTable[] =
    {
    3050
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugModuleLoadEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugModuleLoadEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugModuleLoadEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugModuleLoadEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugModuleLoadEvent2ProxyVtbl = 
{
    &IDebugModuleLoadEvent2_ProxyInfo,
    &IID_IDebugModuleLoadEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugModuleLoadEvent2::GetModule */
};

const CInterfaceStubVtbl _IDebugModuleLoadEvent2StubVtbl =
{
    &IID_IDebugModuleLoadEvent2,
    &IDebugModuleLoadEvent2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugPropertyCreateEvent2, ver. 0.0,
   GUID={0xded6d613,0xa3db,0x4e35,{0xbb,0x5b,0xa9,0x23,0x91,0x13,0x3f,0x03}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugPropertyCreateEvent2_FormatStringOffsetTable[] =
    {
    3090
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugPropertyCreateEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugPropertyCreateEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugPropertyCreateEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugPropertyCreateEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugPropertyCreateEvent2ProxyVtbl = 
{
    &IDebugPropertyCreateEvent2_ProxyInfo,
    &IID_IDebugPropertyCreateEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugPropertyCreateEvent2::GetDebugProperty */
};

const CInterfaceStubVtbl _IDebugPropertyCreateEvent2StubVtbl =
{
    &IID_IDebugPropertyCreateEvent2,
    &IDebugPropertyCreateEvent2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugPropertyDestroyEvent2, ver. 0.0,
   GUID={0xf3765f18,0xf395,0x4b8c,{0x8e,0x95,0xdc,0xb3,0xfe,0x8e,0x7e,0xc8}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugPropertyDestroyEvent2_FormatStringOffsetTable[] =
    {
    3090
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugPropertyDestroyEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugPropertyDestroyEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugPropertyDestroyEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugPropertyDestroyEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugPropertyDestroyEvent2ProxyVtbl = 
{
    &IDebugPropertyDestroyEvent2_ProxyInfo,
    &IID_IDebugPropertyDestroyEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugPropertyDestroyEvent2::GetDebugProperty */
};

const CInterfaceStubVtbl _IDebugPropertyDestroyEvent2StubVtbl =
{
    &IID_IDebugPropertyDestroyEvent2,
    &IDebugPropertyDestroyEvent2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugBreakpointBoundEvent2, ver. 0.0,
   GUID={0x1dddb704,0xcf99,0x4b8a,{0xb7,0x46,0xda,0xbb,0x01,0xdd,0x13,0xa0}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugBreakpointBoundEvent2_FormatStringOffsetTable[] =
    {
    3118,
    3146
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugBreakpointBoundEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakpointBoundEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugBreakpointBoundEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakpointBoundEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugBreakpointBoundEvent2ProxyVtbl = 
{
    &IDebugBreakpointBoundEvent2_ProxyInfo,
    &IID_IDebugBreakpointBoundEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugBreakpointBoundEvent2::GetPendingBreakpoint */ ,
    (void *) (INT_PTR) -1 /* IDebugBreakpointBoundEvent2::EnumBoundBreakpoints */
};

const CInterfaceStubVtbl _IDebugBreakpointBoundEvent2StubVtbl =
{
    &IID_IDebugBreakpointBoundEvent2,
    &IDebugBreakpointBoundEvent2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugBreakpointUnboundEvent2, ver. 0.0,
   GUID={0x78d1db4f,0xc557,0x4dc5,{0xa2,0xdd,0x53,0x69,0xd2,0x1b,0x1c,0x8c}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugBreakpointUnboundEvent2_FormatStringOffsetTable[] =
    {
    3174,
    3202
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugBreakpointUnboundEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakpointUnboundEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugBreakpointUnboundEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakpointUnboundEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugBreakpointUnboundEvent2ProxyVtbl = 
{
    &IDebugBreakpointUnboundEvent2_ProxyInfo,
    &IID_IDebugBreakpointUnboundEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugBreakpointUnboundEvent2::GetBreakpoint */ ,
    (void *) (INT_PTR) -1 /* IDebugBreakpointUnboundEvent2::GetReason */
};

const CInterfaceStubVtbl _IDebugBreakpointUnboundEvent2StubVtbl =
{
    &IID_IDebugBreakpointUnboundEvent2,
    &IDebugBreakpointUnboundEvent2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugBreakpointErrorEvent2, ver. 0.0,
   GUID={0xabb0ca42,0xf82b,0x4622,{0x84,0xe4,0x69,0x03,0xae,0x90,0xf2,0x10}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugBreakpointErrorEvent2_FormatStringOffsetTable[] =
    {
    3230
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugBreakpointErrorEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakpointErrorEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugBreakpointErrorEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakpointErrorEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugBreakpointErrorEvent2ProxyVtbl = 
{
    &IDebugBreakpointErrorEvent2_ProxyInfo,
    &IID_IDebugBreakpointErrorEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugBreakpointErrorEvent2::GetErrorBreakpoint */
};

const CInterfaceStubVtbl _IDebugBreakpointErrorEvent2StubVtbl =
{
    &IID_IDebugBreakpointErrorEvent2,
    &IDebugBreakpointErrorEvent2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugExpressionEvaluationCompleteEvent2, ver. 0.0,
   GUID={0xc0e13a85,0x238a,0x4800,{0x83,0x15,0xd9,0x47,0xc9,0x60,0xa8,0x43}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugExpressionEvaluationCompleteEvent2_FormatStringOffsetTable[] =
    {
    3258,
    3286
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugExpressionEvaluationCompleteEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugExpressionEvaluationCompleteEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugExpressionEvaluationCompleteEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugExpressionEvaluationCompleteEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugExpressionEvaluationCompleteEvent2ProxyVtbl = 
{
    &IDebugExpressionEvaluationCompleteEvent2_ProxyInfo,
    &IID_IDebugExpressionEvaluationCompleteEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugExpressionEvaluationCompleteEvent2::GetExpression */ ,
    (void *) (INT_PTR) -1 /* IDebugExpressionEvaluationCompleteEvent2::GetResult */
};

const CInterfaceStubVtbl _IDebugExpressionEvaluationCompleteEvent2StubVtbl =
{
    &IID_IDebugExpressionEvaluationCompleteEvent2,
    &IDebugExpressionEvaluationCompleteEvent2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugReturnValueEvent2, ver. 0.0,
   GUID={0x0da4d4cc,0x2d0b,0x410f,{0x8d,0x5d,0xb6,0xb7,0x3a,0x5d,0x35,0xd8}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugReturnValueEvent2_FormatStringOffsetTable[] =
    {
    3314
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugReturnValueEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugReturnValueEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugReturnValueEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugReturnValueEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugReturnValueEvent2ProxyVtbl = 
{
    &IDebugReturnValueEvent2_ProxyInfo,
    &IID_IDebugReturnValueEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugReturnValueEvent2::GetReturnValue */
};

const CInterfaceStubVtbl _IDebugReturnValueEvent2StubVtbl =
{
    &IID_IDebugReturnValueEvent2,
    &IDebugReturnValueEvent2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugFindSymbolEvent2, ver. 0.0,
   GUID={0x4072ae37,0x3739,0x43c9,{0xac,0x88,0xca,0x2e,0xa7,0x9e,0xd3,0x2b}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugFindSymbolEvent2_FormatStringOffsetTable[] =
    {
    3342
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugFindSymbolEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugFindSymbolEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugFindSymbolEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugFindSymbolEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugFindSymbolEvent2ProxyVtbl = 
{
    &IDebugFindSymbolEvent2_ProxyInfo,
    &IID_IDebugFindSymbolEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugFindSymbolEvent2::SearchWithPath */
};

const CInterfaceStubVtbl _IDebugFindSymbolEvent2StubVtbl =
{
    &IID_IDebugFindSymbolEvent2,
    &IDebugFindSymbolEvent2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugNoSymbolsEvent2, ver. 0.0,
   GUID={0x3ad4fb48,0x647e,0x4b03,{0x9c,0x1e,0x52,0x75,0x4e,0x80,0xc8,0x80}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugNoSymbolsEvent2_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugNoSymbolsEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugNoSymbolsEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugNoSymbolsEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugNoSymbolsEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(3) _IDebugNoSymbolsEvent2ProxyVtbl = 
{
    0,
    &IID_IDebugNoSymbolsEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};

const CInterfaceStubVtbl _IDebugNoSymbolsEvent2StubVtbl =
{
    &IID_IDebugNoSymbolsEvent2,
    &IDebugNoSymbolsEvent2_ServerInfo,
    3,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugProgramNameChangedEvent2, ver. 0.0,
   GUID={0xe05c2dfd,0x59d5,0x46d3,{0xa7,0x1c,0x5d,0x07,0x66,0x5d,0x85,0xaf}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugProgramNameChangedEvent2_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugProgramNameChangedEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugProgramNameChangedEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugProgramNameChangedEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugProgramNameChangedEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(3) _IDebugProgramNameChangedEvent2ProxyVtbl = 
{
    0,
    &IID_IDebugProgramNameChangedEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};

const CInterfaceStubVtbl _IDebugProgramNameChangedEvent2StubVtbl =
{
    &IID_IDebugProgramNameChangedEvent2,
    &IDebugProgramNameChangedEvent2_ServerInfo,
    3,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugThreadNameChangedEvent2, ver. 0.0,
   GUID={0x1ef4ef78,0x2c44,0x4b7a,{0x84,0x73,0x8f,0x43,0x57,0x61,0x17,0x29}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugThreadNameChangedEvent2_FormatStringOffsetTable[] =
    {
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugThreadNameChangedEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugThreadNameChangedEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugThreadNameChangedEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugThreadNameChangedEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(3) _IDebugThreadNameChangedEvent2ProxyVtbl = 
{
    0,
    &IID_IDebugThreadNameChangedEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy
};

const CInterfaceStubVtbl _IDebugThreadNameChangedEvent2StubVtbl =
{
    &IID_IDebugThreadNameChangedEvent2,
    &IDebugThreadNameChangedEvent2_ServerInfo,
    3,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugMessageEvent2, ver. 0.0,
   GUID={0x3bdb28cf,0xdbd2,0x4d24,{0xaf,0x03,0x01,0x07,0x2b,0x67,0xeb,0x9e}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugMessageEvent2_FormatStringOffsetTable[] =
    {
    3370,
    260
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugMessageEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugMessageEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugMessageEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugMessageEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugMessageEvent2ProxyVtbl = 
{
    &IDebugMessageEvent2_ProxyInfo,
    &IID_IDebugMessageEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugMessageEvent2::GetMessage */ ,
    (void *) (INT_PTR) -1 /* IDebugMessageEvent2::SetResponse */
};

const CInterfaceStubVtbl _IDebugMessageEvent2StubVtbl =
{
    &IID_IDebugMessageEvent2,
    &IDebugMessageEvent2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugActivateDocumentEvent2, ver. 0.0,
   GUID={0x58f36c3d,0x7d07,0x4eba,{0xa0,0x41,0x62,0xf6,0x3e,0x18,0x80,0x37}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugActivateDocumentEvent2_FormatStringOffsetTable[] =
    {
    3422,
    3450
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugActivateDocumentEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugActivateDocumentEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugActivateDocumentEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugActivateDocumentEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugActivateDocumentEvent2ProxyVtbl = 
{
    &IDebugActivateDocumentEvent2_ProxyInfo,
    &IID_IDebugActivateDocumentEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugActivateDocumentEvent2::GetDocument */ ,
    (void *) (INT_PTR) -1 /* IDebugActivateDocumentEvent2::GetDocumentContext */
};

const CInterfaceStubVtbl _IDebugActivateDocumentEvent2StubVtbl =
{
    &IID_IDebugActivateDocumentEvent2,
    &IDebugActivateDocumentEvent2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugProcess2, ver. 0.0,
   GUID={0x43286fea,0x6997,0x4543,{0x80,0x3e,0x60,0xa2,0x0c,0x47,0x3d,0xe5}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugProcess2_FormatStringOffsetTable[] =
    {
    3478,
    3512,
    3540,
    3574,
    554,
    3602,
    1446,
    1468,
    3648,
    3676,
    3704,
    3732,
    2562,
    3760
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugProcess2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugProcess2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugProcess2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugProcess2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(17) _IDebugProcess2ProxyVtbl = 
{
    &IDebugProcess2_ProxyInfo,
    &IID_IDebugProcess2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::EnumPrograms */ ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::GetName */ ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::GetMachine */ ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::Terminate */ ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::Attach */ ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::CanDetach */ ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::Detach */ ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::GetPhysicalProcessId */ ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::GetProcessId */ ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::GetAttachedSessionName */ ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::EnumThreads */ ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::CauseBreak */ ,
    (void *) (INT_PTR) -1 /* IDebugProcess2::GetPort */
};

const CInterfaceStubVtbl _IDebugProcess2StubVtbl =
{
    &IID_IDebugProcess2,
    &IDebugProcess2_ServerInfo,
    17,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugProgram2, ver. 0.0,
   GUID={0x69d172ef,0xf2c4,0x44e1,{0x89,0xf7,0xc8,0x62,0x31,0xe7,0x06,0xe9}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugProgram2_FormatStringOffsetTable[] =
    {
    3788,
    34,
    3816,
    3844,
    3866,
    3894,
    1446,
    1102,
    3916,
    3944,
    3966,
    3994,
    2562,
    4034,
    4068,
    4102,
    4130,
    4170,
    4198,
    4226,
    4284
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugProgram2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugProgram2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugProgram2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugProgram2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(24) _IDebugProgram2ProxyVtbl = 
{
    &IDebugProgram2_ProxyInfo,
    &IID_IDebugProgram2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::EnumThreads */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::GetName */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::GetProcess */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::Terminate */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::Attach */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::CanDetach */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::Detach */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::GetProgramId */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::GetDebugProperty */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::Execute */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::Continue */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::Step */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::CauseBreak */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::GetEngineInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::EnumCodeContexts */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::GetMemoryBytes */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::GetDisassemblyStream */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::EnumModules */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::GetENCUpdate */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::EnumCodePaths */ ,
    (void *) (INT_PTR) -1 /* IDebugProgram2::WriteDump */
};

const CInterfaceStubVtbl _IDebugProgram2StubVtbl =
{
    &IID_IDebugProgram2,
    &IDebugProgram2_ServerInfo,
    24,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugEngineProgram2, ver. 0.0,
   GUID={0x7ce3e768,0x654d,0x4ba7,{0x8d,0x95,0xcd,0xaa,0xc6,0x42,0xb1,0x41}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugEngineProgram2_FormatStringOffsetTable[] =
    {
    4318,
    4340,
    4386
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugEngineProgram2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugEngineProgram2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugEngineProgram2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugEngineProgram2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IDebugEngineProgram2ProxyVtbl = 
{
    &IDebugEngineProgram2_ProxyInfo,
    &IID_IDebugEngineProgram2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugEngineProgram2::Stop */ ,
    (void *) (INT_PTR) -1 /* IDebugEngineProgram2::WatchForThreadStep */ ,
    (void *) (INT_PTR) -1 /* IDebugEngineProgram2::WatchForExpressionEvaluationOnThread */
};

const CInterfaceStubVtbl _IDebugEngineProgram2StubVtbl =
{
    &IID_IDebugEngineProgram2,
    &IDebugEngineProgram2_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugProgramHost2, ver. 0.0,
   GUID={0xc99d588f,0x778c,0x44fe,{0x8b,0x2e,0x40,0x12,0x4a,0x73,0x88,0x91}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugProgramHost2_FormatStringOffsetTable[] =
    {
    4438,
    4472,
    4500
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugProgramHost2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugProgramHost2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugProgramHost2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugProgramHost2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IDebugProgramHost2ProxyVtbl = 
{
    &IDebugProgramHost2_ProxyInfo,
    &IID_IDebugProgramHost2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugProgramHost2::GetHostName */ ,
    (void *) (INT_PTR) -1 /* IDebugProgramHost2::GetHostId */ ,
    (void *) (INT_PTR) -1 /* IDebugProgramHost2::GetHostMachineName */
};

const CInterfaceStubVtbl _IDebugProgramHost2StubVtbl =
{
    &IID_IDebugProgramHost2,
    &IDebugProgramHost2_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugProgramNode2, ver. 0.0,
   GUID={0x426e255c,0xf1ce,0x4d02,{0xa9,0x31,0xf9,0xa2,0x54,0xbf,0x7f,0x0f}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugProgramNode2_FormatStringOffsetTable[] =
    {
    436,
    4528,
    4562,
    4590,
    4618,
    4658,
    1446
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugProgramNode2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugProgramNode2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugProgramNode2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugProgramNode2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(10) _IDebugProgramNode2ProxyVtbl = 
{
    &IDebugProgramNode2_ProxyInfo,
    &IID_IDebugProgramNode2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugProgramNode2::GetProgramName */ ,
    (void *) (INT_PTR) -1 /* IDebugProgramNode2::GetHostName */ ,
    (void *) (INT_PTR) -1 /* IDebugProgramNode2::GetHostPid */ ,
    (void *) (INT_PTR) -1 /* IDebugProgramNode2::GetHostMachineName */ ,
    (void *) (INT_PTR) -1 /* IDebugProgramNode2::Attach */ ,
    (void *) (INT_PTR) -1 /* IDebugProgramNode2::GetEngineInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugProgramNode2::DetachDebugger */
};

const CInterfaceStubVtbl _IDebugProgramNode2StubVtbl =
{
    &IID_IDebugProgramNode2,
    &IDebugProgramNode2_ServerInfo,
    10,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugProgramEngines2, ver. 0.0,
   GUID={0xfda24a6b,0xb142,0x447d,{0xbb,0xbc,0x86,0x54,0xa3,0xd8,0x4f,0x80}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugProgramEngines2_FormatStringOffsetTable[] =
    {
    4692,
    4732
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugProgramEngines2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugProgramEngines2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugProgramEngines2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugProgramEngines2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugProgramEngines2ProxyVtbl = 
{
    &IDebugProgramEngines2_ProxyInfo,
    &IID_IDebugProgramEngines2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugProgramEngines2::EnumPossibleEngines */ ,
    (void *) (INT_PTR) -1 /* IDebugProgramEngines2::SetEngine */
};

const CInterfaceStubVtbl _IDebugProgramEngines2StubVtbl =
{
    &IID_IDebugProgramEngines2,
    &IDebugProgramEngines2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugThread2, ver. 0.0,
   GUID={0xd5168050,0xa57a,0x465c,{0xbe,0xa9,0x97,0x4f,0x40,0x5e,0xba,0x13}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugThread2_FormatStringOffsetTable[] =
    {
    4760,
    34,
    4800,
    4828,
    4856,
    4890,
    4924,
    4952,
    4980,
    5008,
    5042
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugThread2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugThread2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugThread2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugThread2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(14) _IDebugThread2ProxyVtbl = 
{
    &IDebugThread2_ProxyInfo,
    &IID_IDebugThread2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugThread2::EnumFrameInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugThread2::GetName */ ,
    (void *) (INT_PTR) -1 /* IDebugThread2::SetThreadName */ ,
    (void *) (INT_PTR) -1 /* IDebugThread2::GetProgram */ ,
    (void *) (INT_PTR) -1 /* IDebugThread2::CanSetNextStatement */ ,
    (void *) (INT_PTR) -1 /* IDebugThread2::SetNextStatement */ ,
    (void *) (INT_PTR) -1 /* IDebugThread2::GetThreadId */ ,
    (void *) (INT_PTR) -1 /* IDebugThread2::Suspend */ ,
    (void *) (INT_PTR) -1 /* IDebugThread2::Resume */ ,
    (void *) (INT_PTR) -1 /* IDebugThread2::GetThreadProperties */ ,
    (void *) (INT_PTR) -1 /* IDebugThread2::GetLogicalThread */
};

const CInterfaceStubVtbl _IDebugThread2StubVtbl =
{
    &IID_IDebugThread2,
    &IDebugThread2_ServerInfo,
    14,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugLogicalThread2, ver. 0.0,
   GUID={0x88d2f75b,0xd329,0x4e03,{0x9b,0x75,0x20,0x1f,0x77,0x82,0xd8,0xbd}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugLogicalThread2_FormatStringOffsetTable[] =
    {
    4760
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugLogicalThread2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugLogicalThread2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugLogicalThread2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugLogicalThread2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugLogicalThread2ProxyVtbl = 
{
    &IDebugLogicalThread2_ProxyInfo,
    &IID_IDebugLogicalThread2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugLogicalThread2::EnumFrameInfo */
};

const CInterfaceStubVtbl _IDebugLogicalThread2StubVtbl =
{
    &IID_IDebugLogicalThread2,
    &IDebugLogicalThread2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_msdbg_0350, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDebugProperty2, ver. 0.0,
   GUID={0xa7ee3e7e,0x2dd2,0x4ad7,{0x96,0x97,0xf4,0xaa,0xe3,0x42,0x77,0x62}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugProperty2_FormatStringOffsetTable[] =
    {
    5076,
    5134,
    5174,
    5220,
    5284,
    5312,
    5340,
    5368,
    4980,
    5396,
    5424
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugProperty2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugProperty2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugProperty2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugProperty2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(14) _IDebugProperty2ProxyVtbl = 
{
    &IDebugProperty2_ProxyInfo,
    &IID_IDebugProperty2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugProperty2::GetPropertyInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugProperty2::SetValueAsString */ ,
    (void *) (INT_PTR) -1 /* IDebugProperty2::SetValueAsReference */ ,
    (void *) (INT_PTR) -1 /* IDebugProperty2::EnumChildren */ ,
    (void *) (INT_PTR) -1 /* IDebugProperty2::GetParent */ ,
    (void *) (INT_PTR) -1 /* IDebugProperty2::GetDerivedMostProperty */ ,
    (void *) (INT_PTR) -1 /* IDebugProperty2::GetMemoryBytes */ ,
    (void *) (INT_PTR) -1 /* IDebugProperty2::GetMemoryContext */ ,
    (void *) (INT_PTR) -1 /* IDebugProperty2::GetSize */ ,
    (void *) (INT_PTR) -1 /* IDebugProperty2::GetReference */ ,
    (void *) (INT_PTR) -1 /* IDebugProperty2::GetExtendedInfo */
};

const CInterfaceStubVtbl _IDebugProperty2StubVtbl =
{
    &IID_IDebugProperty2,
    &IDebugProperty2_ServerInfo,
    14,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_msdbg_0351, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDebugReference2, ver. 0.0,
   GUID={0x10b793ac,0x0c47,0x4679,{0x84,0x54,0xad,0xb3,0x6f,0x29,0xf8,0x02}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugReference2_FormatStringOffsetTable[] =
    {
    5458,
    5134,
    5516,
    5562,
    5620,
    5648,
    5676,
    5704,
    4980,
    5732,
    5760
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugReference2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugReference2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugReference2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugReference2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(14) _IDebugReference2ProxyVtbl = 
{
    &IDebugReference2_ProxyInfo,
    &IID_IDebugReference2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugReference2::GetReferenceInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugReference2::SetValueAsString */ ,
    (void *) (INT_PTR) -1 /* IDebugReference2::SetValueAsReference */ ,
    (void *) (INT_PTR) -1 /* IDebugReference2::EnumChildren */ ,
    (void *) (INT_PTR) -1 /* IDebugReference2::GetParent */ ,
    (void *) (INT_PTR) -1 /* IDebugReference2::GetDerivedMostReference */ ,
    (void *) (INT_PTR) -1 /* IDebugReference2::GetMemoryBytes */ ,
    (void *) (INT_PTR) -1 /* IDebugReference2::GetMemoryContext */ ,
    (void *) (INT_PTR) -1 /* IDebugReference2::GetSize */ ,
    (void *) (INT_PTR) -1 /* IDebugReference2::SetReferenceType */ ,
    (void *) (INT_PTR) -1 /* IDebugReference2::Compare */
};

const CInterfaceStubVtbl _IDebugReference2StubVtbl =
{
    &IID_IDebugReference2,
    &IDebugReference2_ServerInfo,
    14,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugStackFrame2, ver. 0.0,
   GUID={0x1412926f,0x5dd6,0x4e58,{0xb6,0x48,0xe1,0xc6,0x3e,0x01,0x3d,0x51}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugStackFrame2_FormatStringOffsetTable[] =
    {
    5794,
    5822,
    4500,
    5850,
    5890,
    5924,
    5952,
    5986,
    6014,
    6072
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugStackFrame2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugStackFrame2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugStackFrame2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugStackFrame2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(13) _IDebugStackFrame2ProxyVtbl = 
{
    &IDebugStackFrame2_ProxyInfo,
    &IID_IDebugStackFrame2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugStackFrame2::GetCodeContext */ ,
    (void *) (INT_PTR) -1 /* IDebugStackFrame2::GetDocumentContext */ ,
    (void *) (INT_PTR) -1 /* IDebugStackFrame2::GetName */ ,
    (void *) (INT_PTR) -1 /* IDebugStackFrame2::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugStackFrame2::GetPhysicalStackRange */ ,
    (void *) (INT_PTR) -1 /* IDebugStackFrame2::GetExpressionContext */ ,
    (void *) (INT_PTR) -1 /* IDebugStackFrame2::GetLanguageInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugStackFrame2::GetDebugProperty */ ,
    (void *) (INT_PTR) -1 /* IDebugStackFrame2::EnumProperties */ ,
    (void *) (INT_PTR) -1 /* IDebugStackFrame2::GetThread */
};

const CInterfaceStubVtbl _IDebugStackFrame2StubVtbl =
{
    &IID_IDebugStackFrame2,
    &IDebugStackFrame2_ServerInfo,
    13,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugMemoryContext2, ver. 0.0,
   GUID={0x1ab276dd,0xf27b,0x4445,{0x82,0x5d,0x5d,0xf0,0xb4,0xa0,0x4a,0x3a}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugMemoryContext2_FormatStringOffsetTable[] =
    {
    436,
    6100,
    6134,
    6168,
    6202
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugMemoryContext2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugMemoryContext2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugMemoryContext2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugMemoryContext2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IDebugMemoryContext2ProxyVtbl = 
{
    &IDebugMemoryContext2_ProxyInfo,
    &IID_IDebugMemoryContext2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugMemoryContext2::GetName */ ,
    (void *) (INT_PTR) -1 /* IDebugMemoryContext2::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugMemoryContext2::Add */ ,
    (void *) (INT_PTR) -1 /* IDebugMemoryContext2::Subtract */ ,
    (void *) (INT_PTR) -1 /* IDebugMemoryContext2::Compare */
};

const CInterfaceStubVtbl _IDebugMemoryContext2StubVtbl =
{
    &IID_IDebugMemoryContext2,
    &IDebugMemoryContext2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugCodeContext2, ver. 0.0,
   GUID={0xac17b76b,0x2b09,0x419a,{0xad,0x5f,0x7d,0x74,0x02,0xda,0x88,0x75}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugCodeContext2_FormatStringOffsetTable[] =
    {
    436,
    6100,
    6134,
    6168,
    6202,
    6248,
    5952
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugCodeContext2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugCodeContext2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugCodeContext2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugCodeContext2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(10) _IDebugCodeContext2ProxyVtbl = 
{
    &IDebugCodeContext2_ProxyInfo,
    &IID_IDebugCodeContext2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugMemoryContext2::GetName */ ,
    (void *) (INT_PTR) -1 /* IDebugMemoryContext2::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugMemoryContext2::Add */ ,
    (void *) (INT_PTR) -1 /* IDebugMemoryContext2::Subtract */ ,
    (void *) (INT_PTR) -1 /* IDebugMemoryContext2::Compare */ ,
    (void *) (INT_PTR) -1 /* IDebugCodeContext2::GetDocumentContext */ ,
    (void *) (INT_PTR) -1 /* IDebugCodeContext2::GetLanguageInfo */
};

const CInterfaceStubVtbl _IDebugCodeContext2StubVtbl =
{
    &IID_IDebugCodeContext2,
    &IDebugCodeContext2_ServerInfo,
    10,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugMemoryBytes2, ver. 0.0,
   GUID={0x925837d1,0x3aa1,0x451a,{0xb7,0xfe,0xcc,0x04,0xbb,0x42,0xcf,0xb8}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugMemoryBytes2_FormatStringOffsetTable[] =
    {
    6276,
    6328,
    6368
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugMemoryBytes2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugMemoryBytes2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugMemoryBytes2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugMemoryBytes2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IDebugMemoryBytes2ProxyVtbl = 
{
    &IDebugMemoryBytes2_ProxyInfo,
    &IID_IDebugMemoryBytes2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugMemoryBytes2::ReadAt */ ,
    (void *) (INT_PTR) -1 /* IDebugMemoryBytes2::WriteAt */ ,
    (void *) (INT_PTR) -1 /* IDebugMemoryBytes2::GetSize */
};

const CInterfaceStubVtbl _IDebugMemoryBytes2StubVtbl =
{
    &IID_IDebugMemoryBytes2,
    &IDebugMemoryBytes2_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugDisassemblyStream2, ver. 0.0,
   GUID={0xe5b017fe,0xdfb0,0x411c,{0x82,0x66,0x7c,0x64,0xd6,0xf5,0x19,0xf8}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugDisassemblyStream2_FormatStringOffsetTable[] =
    {
    6396,
    6442,
    6488,
    6522,
    6556,
    6584,
    4924,
    6618
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugDisassemblyStream2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugDisassemblyStream2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugDisassemblyStream2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugDisassemblyStream2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(11) _IDebugDisassemblyStream2ProxyVtbl = 
{
    &IDebugDisassemblyStream2_ProxyInfo,
    &IID_IDebugDisassemblyStream2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugDisassemblyStream2::Read */ ,
    (void *) (INT_PTR) -1 /* IDebugDisassemblyStream2::Seek */ ,
    (void *) (INT_PTR) -1 /* IDebugDisassemblyStream2::GetCodeLocationId */ ,
    (void *) (INT_PTR) -1 /* IDebugDisassemblyStream2::GetCodeContext */ ,
    (void *) (INT_PTR) -1 /* IDebugDisassemblyStream2::GetCurrentLocation */ ,
    (void *) (INT_PTR) -1 /* IDebugDisassemblyStream2::GetDocument */ ,
    (void *) (INT_PTR) -1 /* IDebugDisassemblyStream2::GetScope */ ,
    (void *) (INT_PTR) -1 /* IDebugDisassemblyStream2::GetSize */
};

const CInterfaceStubVtbl _IDebugDisassemblyStream2StubVtbl =
{
    &IID_IDebugDisassemblyStream2,
    &IDebugDisassemblyStream2_ServerInfo,
    11,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugDocumentContext2, ver. 0.0,
   GUID={0x931516ad,0xb600,0x419c,{0x88,0xfc,0xdc,0xf5,0x18,0x3b,0x5f,0xa9}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugDocumentContext2_FormatStringOffsetTable[] =
    {
    6646,
    4528,
    6674,
    6702,
    6736,
    6770,
    6804,
    6850
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugDocumentContext2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugDocumentContext2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugDocumentContext2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugDocumentContext2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(11) _IDebugDocumentContext2ProxyVtbl = 
{
    &IDebugDocumentContext2_ProxyInfo,
    &IID_IDebugDocumentContext2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugDocumentContext2::GetDocument */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentContext2::GetName */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentContext2::EnumCodeContexts */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentContext2::GetLanguageInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentContext2::GetStatementRange */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentContext2::GetSourceRange */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentContext2::Compare */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentContext2::Seek */
};

const CInterfaceStubVtbl _IDebugDocumentContext2StubVtbl =
{
    &IID_IDebugDocumentContext2,
    &IDebugDocumentContext2_ServerInfo,
    11,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugExpressionContext2, ver. 0.0,
   GUID={0x37a44580,0xd5fc,0x473e,{0xa0,0x48,0x21,0x70,0x2e,0xbf,0xc4,0x66}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugExpressionContext2_FormatStringOffsetTable[] =
    {
    436,
    6884
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugExpressionContext2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugExpressionContext2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugExpressionContext2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugExpressionContext2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugExpressionContext2ProxyVtbl = 
{
    &IDebugExpressionContext2_ProxyInfo,
    &IID_IDebugExpressionContext2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugExpressionContext2::GetName */ ,
    (void *) (INT_PTR) -1 /* IDebugExpressionContext2::ParseText */
};

const CInterfaceStubVtbl _IDebugExpressionContext2StubVtbl =
{
    &IID_IDebugExpressionContext2,
    &IDebugExpressionContext2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_msdbg_0359, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDebugBreakpointRequest2, ver. 0.0,
   GUID={0x6015fd18,0x8257,0x4df3,{0xac,0x42,0xf0,0x74,0xde,0xdd,0x4c,0xbd}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugBreakpointRequest2_FormatStringOffsetTable[] =
    {
    2832,
    6942
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugBreakpointRequest2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakpointRequest2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugBreakpointRequest2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakpointRequest2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugBreakpointRequest2ProxyVtbl = 
{
    &IDebugBreakpointRequest2_ProxyInfo,
    &IID_IDebugBreakpointRequest2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugBreakpointRequest2::GetLocationType */ ,
    (void *) (INT_PTR) -1 /* IDebugBreakpointRequest2::GetRequestInfo */
};

const CInterfaceStubVtbl _IDebugBreakpointRequest2StubVtbl =
{
    &IID_IDebugBreakpointRequest2,
    &IDebugBreakpointRequest2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_msdbg_0360, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDebugBreakpointResolution2, ver. 0.0,
   GUID={0xb7e66f28,0x035a,0x401a,{0xaf,0xc7,0x2e,0x30,0x0b,0xd2,0x97,0x11}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugBreakpointResolution2_FormatStringOffsetTable[] =
    {
    2832,
    6976
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugBreakpointResolution2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakpointResolution2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugBreakpointResolution2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugBreakpointResolution2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugBreakpointResolution2ProxyVtbl = 
{
    &IDebugBreakpointResolution2_ProxyInfo,
    &IID_IDebugBreakpointResolution2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugBreakpointResolution2::GetBreakpointType */ ,
    (void *) (INT_PTR) -1 /* IDebugBreakpointResolution2::GetResolutionInfo */
};

const CInterfaceStubVtbl _IDebugBreakpointResolution2StubVtbl =
{
    &IID_IDebugBreakpointResolution2,
    &IDebugBreakpointResolution2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_msdbg_0361, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDebugErrorBreakpointResolution2, ver. 0.0,
   GUID={0x603aedf8,0x9575,0x4d30,{0xb8,0xca,0x12,0x4d,0x1c,0x98,0xeb,0xd8}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugErrorBreakpointResolution2_FormatStringOffsetTable[] =
    {
    2832,
    7010
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugErrorBreakpointResolution2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugErrorBreakpointResolution2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugErrorBreakpointResolution2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugErrorBreakpointResolution2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugErrorBreakpointResolution2ProxyVtbl = 
{
    &IDebugErrorBreakpointResolution2_ProxyInfo,
    &IID_IDebugErrorBreakpointResolution2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugErrorBreakpointResolution2::GetBreakpointType */ ,
    (void *) (INT_PTR) -1 /* IDebugErrorBreakpointResolution2::GetResolutionInfo */
};

const CInterfaceStubVtbl _IDebugErrorBreakpointResolution2StubVtbl =
{
    &IID_IDebugErrorBreakpointResolution2,
    &IDebugErrorBreakpointResolution2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugBoundBreakpoint2, ver. 0.0,
   GUID={0xd533d975,0x3f32,0x4876,{0xab,0xd0,0x6d,0x37,0xfd,0xa5,0x63,0xe7}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugBoundBreakpoint2_FormatStringOffsetTable[] =
    {
    7044,
    3202,
    7072,
    7100,
    7128,
    1418,
    7156,
    7184,
    7212
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugBoundBreakpoint2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugBoundBreakpoint2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugBoundBreakpoint2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugBoundBreakpoint2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(12) _IDebugBoundBreakpoint2ProxyVtbl = 
{
    &IDebugBoundBreakpoint2_ProxyInfo,
    &IID_IDebugBoundBreakpoint2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugBoundBreakpoint2::GetPendingBreakpoint */ ,
    (void *) (INT_PTR) -1 /* IDebugBoundBreakpoint2::GetState */ ,
    (void *) (INT_PTR) -1 /* IDebugBoundBreakpoint2::GetHitCount */ ,
    (void *) (INT_PTR) -1 /* IDebugBoundBreakpoint2::GetBreakpointResolution */ ,
    (void *) (INT_PTR) -1 /* IDebugBoundBreakpoint2::Enable */ ,
    (void *) (INT_PTR) -1 /* IDebugBoundBreakpoint2::SetHitCount */ ,
    (void *) (INT_PTR) -1 /* IDebugBoundBreakpoint2::SetCondition */ ,
    (void *) (INT_PTR) -1 /* IDebugBoundBreakpoint2::SetPassCount */ ,
    (void *) (INT_PTR) -1 /* IDebugBoundBreakpoint2::Delete */
};

const CInterfaceStubVtbl _IDebugBoundBreakpoint2StubVtbl =
{
    &IID_IDebugBoundBreakpoint2,
    &IDebugBoundBreakpoint2_ServerInfo,
    12,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugPendingBreakpoint2, ver. 0.0,
   GUID={0x6e215ef3,0xe44c,0x44d1,{0xb7,0xba,0xb2,0x40,0x1f,0x7d,0xc2,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugPendingBreakpoint2_FormatStringOffsetTable[] =
    {
    7234,
    7262,
    7284,
    7312,
    7128,
    1418,
    7156,
    7184,
    7340,
    7368,
    7402
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugPendingBreakpoint2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugPendingBreakpoint2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugPendingBreakpoint2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugPendingBreakpoint2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(14) _IDebugPendingBreakpoint2ProxyVtbl = 
{
    &IDebugPendingBreakpoint2_ProxyInfo,
    &IID_IDebugPendingBreakpoint2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugPendingBreakpoint2::CanBind */ ,
    (void *) (INT_PTR) -1 /* IDebugPendingBreakpoint2::Bind */ ,
    (void *) (INT_PTR) -1 /* IDebugPendingBreakpoint2::GetState */ ,
    (void *) (INT_PTR) -1 /* IDebugPendingBreakpoint2::GetBreakpointRequest */ ,
    (void *) (INT_PTR) -1 /* IDebugPendingBreakpoint2::Virtualize */ ,
    (void *) (INT_PTR) -1 /* IDebugPendingBreakpoint2::Enable */ ,
    (void *) (INT_PTR) -1 /* IDebugPendingBreakpoint2::SetCondition */ ,
    (void *) (INT_PTR) -1 /* IDebugPendingBreakpoint2::SetPassCount */ ,
    (void *) (INT_PTR) -1 /* IDebugPendingBreakpoint2::EnumBoundBreakpoints */ ,
    (void *) (INT_PTR) -1 /* IDebugPendingBreakpoint2::EnumErrorBreakpoints */ ,
    (void *) (INT_PTR) -1 /* IDebugPendingBreakpoint2::Delete */
};

const CInterfaceStubVtbl _IDebugPendingBreakpoint2StubVtbl =
{
    &IID_IDebugPendingBreakpoint2,
    &IDebugPendingBreakpoint2_ServerInfo,
    14,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugErrorBreakpoint2, ver. 0.0,
   GUID={0x74570ef7,0x2486,0x4089,{0x80,0x0c,0x56,0xe3,0x82,0x9b,0x5c,0xa4}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugErrorBreakpoint2_FormatStringOffsetTable[] =
    {
    7424,
    7452
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugErrorBreakpoint2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugErrorBreakpoint2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugErrorBreakpoint2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugErrorBreakpoint2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugErrorBreakpoint2ProxyVtbl = 
{
    &IDebugErrorBreakpoint2_ProxyInfo,
    &IID_IDebugErrorBreakpoint2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugErrorBreakpoint2::GetPendingBreakpoint */ ,
    (void *) (INT_PTR) -1 /* IDebugErrorBreakpoint2::GetBreakpointResolution */
};

const CInterfaceStubVtbl _IDebugErrorBreakpoint2StubVtbl =
{
    &IID_IDebugErrorBreakpoint2,
    &IDebugErrorBreakpoint2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugExpression2, ver. 0.0,
   GUID={0xf7473fd0,0x7f75,0x478d,{0x8d,0x85,0xa4,0x85,0x20,0x4e,0x7a,0x2d}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugExpression2_FormatStringOffsetTable[] =
    {
    7480,
    7262,
    7514
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugExpression2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugExpression2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugExpression2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugExpression2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IDebugExpression2ProxyVtbl = 
{
    &IDebugExpression2_ProxyInfo,
    &IID_IDebugExpression2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugExpression2::EvaluateAsync */ ,
    (void *) (INT_PTR) -1 /* IDebugExpression2::Abort */ ,
    (void *) (INT_PTR) -1 /* IDebugExpression2::EvaluateSync */
};

const CInterfaceStubVtbl _IDebugExpression2StubVtbl =
{
    &IID_IDebugExpression2,
    &IDebugExpression2_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugModule2, ver. 0.0,
   GUID={0x0fc1cd9a,0xb912,0x405c,{0xa0,0x4c,0x43,0xce,0x02,0xcd,0x7d,0xf2}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugModule2_FormatStringOffsetTable[] =
    {
    7560,
    7594
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugModule2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugModule2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugModule2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugModule2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugModule2ProxyVtbl = 
{
    &IDebugModule2_ProxyInfo,
    &IID_IDebugModule2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugModule2::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugModule2::ReloadSymbols */
};

const CInterfaceStubVtbl _IDebugModule2StubVtbl =
{
    &IID_IDebugModule2,
    &IDebugModule2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugModuleManaged, ver. 0.0,
   GUID={0x232397F8,0xB232,0x479d,{0xB1,0xBB,0x2F,0x04,0x4C,0x70,0xA0,0xF9}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugModuleManaged_FormatStringOffsetTable[] =
    {
    7628
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugModuleManaged_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugModuleManaged_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugModuleManaged_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugModuleManaged_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugModuleManagedProxyVtbl = 
{
    &IDebugModuleManaged_ProxyInfo,
    &IID_IDebugModuleManaged,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugModuleManaged::GetMvid */
};

const CInterfaceStubVtbl _IDebugModuleManagedStubVtbl =
{
    &IID_IDebugModuleManaged,
    &IDebugModuleManaged_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugDocument2, ver. 0.0,
   GUID={0x1606dd73,0x5d5f,0x405c,{0xb4,0xf4,0xce,0x32,0xba,0xba,0x25,0x01}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugDocument2_FormatStringOffsetTable[] =
    {
    4438,
    464
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugDocument2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugDocument2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugDocument2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugDocument2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugDocument2ProxyVtbl = 
{
    &IDebugDocument2_ProxyInfo,
    &IID_IDebugDocument2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugDocument2::GetName */ ,
    (void *) (INT_PTR) -1 /* IDebugDocument2::GetDocumentClassId */
};

const CInterfaceStubVtbl _IDebugDocument2StubVtbl =
{
    &IID_IDebugDocument2,
    &IDebugDocument2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugDocumentText2, ver. 0.0,
   GUID={0x4b0645aa,0x08ef,0x4cb9,{0xad,0xb9,0x03,0x95,0xd6,0xed,0xad,0x35}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugDocumentText2_FormatStringOffsetTable[] =
    {
    4438,
    464,
    7656,
    7690
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugDocumentText2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugDocumentText2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugDocumentText2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugDocumentText2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IDebugDocumentText2ProxyVtbl = 
{
    &IDebugDocumentText2_ProxyInfo,
    &IID_IDebugDocumentText2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugDocument2::GetName */ ,
    (void *) (INT_PTR) -1 /* IDebugDocument2::GetDocumentClassId */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentText2::GetSize */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentText2::GetText */
};

const CInterfaceStubVtbl _IDebugDocumentText2StubVtbl =
{
    &IID_IDebugDocumentText2,
    &IDebugDocumentText2_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugDocumentPosition2, ver. 0.0,
   GUID={0xbdde0eee,0x3b8d,0x4c82,{0xb5,0x29,0x33,0xf1,0x6b,0x42,0x83,0x2e}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugDocumentPosition2_FormatStringOffsetTable[] =
    {
    436,
    7736,
    7764,
    7792
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugDocumentPosition2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugDocumentPosition2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugDocumentPosition2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugDocumentPosition2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IDebugDocumentPosition2ProxyVtbl = 
{
    &IDebugDocumentPosition2_ProxyInfo,
    &IID_IDebugDocumentPosition2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugDocumentPosition2::GetFileName */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentPosition2::GetDocument */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentPosition2::IsPositionInDocument */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentPosition2::GetRange */
};

const CInterfaceStubVtbl _IDebugDocumentPosition2StubVtbl =
{
    &IID_IDebugDocumentPosition2,
    &IDebugDocumentPosition2_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugDocumentPositionOffset2, ver. 0.0,
   GUID={0x037edd0f,0x8551,0x4f7f,{0x8c,0xa0,0x04,0xd9,0xe2,0x9f,0x53,0x2d}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugDocumentPositionOffset2_FormatStringOffsetTable[] =
    {
    7826
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugDocumentPositionOffset2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugDocumentPositionOffset2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugDocumentPositionOffset2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugDocumentPositionOffset2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugDocumentPositionOffset2ProxyVtbl = 
{
    &IDebugDocumentPositionOffset2_ProxyInfo,
    &IID_IDebugDocumentPositionOffset2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugDocumentPositionOffset2::GetRange */
};

const CInterfaceStubVtbl _IDebugDocumentPositionOffset2StubVtbl =
{
    &IID_IDebugDocumentPositionOffset2,
    &IDebugDocumentPositionOffset2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugFunctionPosition2, ver. 0.0,
   GUID={0x1ede3b4b,0x35e7,0x4b97,{0x81,0x33,0x02,0x84,0x5d,0x60,0x01,0x74}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugFunctionPosition2_FormatStringOffsetTable[] =
    {
    436,
    7860
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugFunctionPosition2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugFunctionPosition2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugFunctionPosition2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugFunctionPosition2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugFunctionPosition2ProxyVtbl = 
{
    &IDebugFunctionPosition2_ProxyInfo,
    &IID_IDebugFunctionPosition2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugFunctionPosition2::GetFunctionName */ ,
    (void *) (INT_PTR) -1 /* IDebugFunctionPosition2::GetOffset */
};

const CInterfaceStubVtbl _IDebugFunctionPosition2StubVtbl =
{
    &IID_IDebugFunctionPosition2,
    &IDebugFunctionPosition2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugDocumentTextEvents2, ver. 0.0,
   GUID={0x33ec72e3,0x002f,0x4966,{0xb9,0x1c,0x5c,0xe2,0xf7,0xba,0x51,0x24}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugDocumentTextEvents2_FormatStringOffsetTable[] =
    {
    4318,
    7888,
    7922,
    7956,
    7990,
    1418
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugDocumentTextEvents2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugDocumentTextEvents2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugDocumentTextEvents2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugDocumentTextEvents2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(9) _IDebugDocumentTextEvents2ProxyVtbl = 
{
    &IDebugDocumentTextEvents2_ProxyInfo,
    &IID_IDebugDocumentTextEvents2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugDocumentTextEvents2::onDestroy */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentTextEvents2::onInsertText */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentTextEvents2::onRemoveText */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentTextEvents2::onReplaceText */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentTextEvents2::onUpdateTextAttributes */ ,
    (void *) (INT_PTR) -1 /* IDebugDocumentTextEvents2::onUpdateDocumentAttributes */
};

const CInterfaceStubVtbl _IDebugDocumentTextEvents2StubVtbl =
{
    &IID_IDebugDocumentTextEvents2,
    &IDebugDocumentTextEvents2_ServerInfo,
    9,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugQueryEngine2, ver. 0.0,
   GUID={0xc989adc9,0xf305,0x4ef5,{0x8c,0xa2,0x20,0x89,0x8e,0x8d,0x0e,0x28}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugQueryEngine2_FormatStringOffsetTable[] =
    {
    8024
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugQueryEngine2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugQueryEngine2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugQueryEngine2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugQueryEngine2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugQueryEngine2ProxyVtbl = 
{
    &IDebugQueryEngine2_ProxyInfo,
    &IID_IDebugQueryEngine2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugQueryEngine2::GetEngineInterface */
};

const CInterfaceStubVtbl _IDebugQueryEngine2StubVtbl =
{
    &IID_IDebugQueryEngine2,
    &IDebugQueryEngine2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugProcesses2, ver. 0.0,
   GUID={0x96c74ef4,0x185d,0x4f9a,{0x8a,0x43,0x4d,0x27,0x23,0x75,0x8e,0x0a}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugProcesses2_FormatStringOffsetTable[] =
    {
    8052,
    260,
    3000,
    8092,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugProcesses2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugProcesses2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugProcesses2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugProcesses2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugProcesses2ProxyVtbl = 
{
    &IEnumDebugProcesses2_ProxyInfo,
    &IID_IEnumDebugProcesses2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugProcesses2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugProcesses2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugProcesses2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugProcesses2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugProcesses2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugProcesses2StubVtbl =
{
    &IID_IEnumDebugProcesses2,
    &IEnumDebugProcesses2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugPrograms2, ver. 0.0,
   GUID={0x8d14bca6,0x34ce,0x4efe,{0xac,0x7e,0x0a,0xbc,0x61,0xda,0xdb,0x20}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugPrograms2_FormatStringOffsetTable[] =
    {
    8148,
    260,
    3000,
    8188,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugPrograms2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugPrograms2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugPrograms2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugPrograms2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugPrograms2ProxyVtbl = 
{
    &IEnumDebugPrograms2_ProxyInfo,
    &IID_IEnumDebugPrograms2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugPrograms2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPrograms2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPrograms2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPrograms2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPrograms2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugPrograms2StubVtbl =
{
    &IID_IEnumDebugPrograms2,
    &IEnumDebugPrograms2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugThreads2, ver. 0.0,
   GUID={0x0d30dc12,0xc4f8,0x433d,{0x9f,0xcc,0x9f,0xf1,0x17,0xe5,0xe5,0xf4}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugThreads2_FormatStringOffsetTable[] =
    {
    8216,
    260,
    3000,
    8256,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugThreads2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugThreads2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugThreads2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugThreads2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugThreads2ProxyVtbl = 
{
    &IEnumDebugThreads2_ProxyInfo,
    &IID_IEnumDebugThreads2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugThreads2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugThreads2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugThreads2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugThreads2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugThreads2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugThreads2StubVtbl =
{
    &IID_IEnumDebugThreads2,
    &IEnumDebugThreads2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugStackFrames2, ver. 0.0,
   GUID={0xcd39102b,0x4b69,0x4495,{0x8f,0x29,0xe0,0xb2,0x5c,0x4a,0x88,0x55}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugStackFrames2_FormatStringOffsetTable[] =
    {
    8284,
    260,
    3000,
    8324,
    8120,
    8352
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugStackFrames2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugStackFrames2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugStackFrames2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugStackFrames2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(9) _IEnumDebugStackFrames2ProxyVtbl = 
{
    &IEnumDebugStackFrames2_ProxyInfo,
    &IID_IEnumDebugStackFrames2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugStackFrames2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugStackFrames2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugStackFrames2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugStackFrames2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugStackFrames2::GetCount */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugStackFrames2::GetIndex */
};

const CInterfaceStubVtbl _IEnumDebugStackFrames2StubVtbl =
{
    &IID_IEnumDebugStackFrames2,
    &IEnumDebugStackFrames2_ServerInfo,
    9,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugCodeContexts2, ver. 0.0,
   GUID={0xad47a80b,0xeda7,0x459e,{0xaf,0x82,0x64,0x7c,0xc9,0xfb,0xaa,0x50}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugCodeContexts2_FormatStringOffsetTable[] =
    {
    8386,
    260,
    3000,
    8426,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugCodeContexts2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugCodeContexts2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugCodeContexts2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugCodeContexts2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugCodeContexts2ProxyVtbl = 
{
    &IEnumDebugCodeContexts2_ProxyInfo,
    &IID_IEnumDebugCodeContexts2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugCodeContexts2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugCodeContexts2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugCodeContexts2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugCodeContexts2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugCodeContexts2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugCodeContexts2StubVtbl =
{
    &IID_IEnumDebugCodeContexts2,
    &IEnumDebugCodeContexts2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugBoundBreakpoints2, ver. 0.0,
   GUID={0x0f6b37e0,0xfcfe,0x44d9,{0x91,0x12,0x39,0x4c,0xa9,0xb9,0x21,0x14}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugBoundBreakpoints2_FormatStringOffsetTable[] =
    {
    8454,
    260,
    3000,
    8494,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugBoundBreakpoints2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugBoundBreakpoints2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugBoundBreakpoints2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugBoundBreakpoints2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugBoundBreakpoints2ProxyVtbl = 
{
    &IEnumDebugBoundBreakpoints2_ProxyInfo,
    &IID_IEnumDebugBoundBreakpoints2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugBoundBreakpoints2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugBoundBreakpoints2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugBoundBreakpoints2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugBoundBreakpoints2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugBoundBreakpoints2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugBoundBreakpoints2StubVtbl =
{
    &IID_IEnumDebugBoundBreakpoints2,
    &IEnumDebugBoundBreakpoints2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugPendingBreakpoints2, ver. 0.0,
   GUID={0x70d2dc1e,0x4dcc,0x4786,{0xa0,0x72,0x9a,0x3b,0x60,0x0c,0x21,0x6b}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugPendingBreakpoints2_FormatStringOffsetTable[] =
    {
    8522,
    260,
    3000,
    8562,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugPendingBreakpoints2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugPendingBreakpoints2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugPendingBreakpoints2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugPendingBreakpoints2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugPendingBreakpoints2ProxyVtbl = 
{
    &IEnumDebugPendingBreakpoints2_ProxyInfo,
    &IID_IEnumDebugPendingBreakpoints2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugPendingBreakpoints2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPendingBreakpoints2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPendingBreakpoints2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPendingBreakpoints2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPendingBreakpoints2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugPendingBreakpoints2StubVtbl =
{
    &IID_IEnumDebugPendingBreakpoints2,
    &IEnumDebugPendingBreakpoints2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugErrorBreakpoints2, ver. 0.0,
   GUID={0xe158f5aa,0x31fe,0x491b,{0xa9,0xf6,0xcf,0xf9,0x34,0xb0,0x3a,0x01}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugErrorBreakpoints2_FormatStringOffsetTable[] =
    {
    8590,
    260,
    3000,
    8630,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugErrorBreakpoints2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugErrorBreakpoints2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugErrorBreakpoints2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugErrorBreakpoints2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugErrorBreakpoints2ProxyVtbl = 
{
    &IEnumDebugErrorBreakpoints2_ProxyInfo,
    &IID_IEnumDebugErrorBreakpoints2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugErrorBreakpoints2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugErrorBreakpoints2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugErrorBreakpoints2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugErrorBreakpoints2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugErrorBreakpoints2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugErrorBreakpoints2StubVtbl =
{
    &IID_IEnumDebugErrorBreakpoints2,
    &IEnumDebugErrorBreakpoints2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugMachines2, ver. 0.0,
   GUID={0x61d986ec,0x1eac,0x46b6,{0x90,0xff,0x40,0x2a,0x00,0x8f,0x15,0xd1}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugMachines2_FormatStringOffsetTable[] =
    {
    8658,
    260,
    3000,
    8698,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugMachines2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugMachines2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugMachines2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugMachines2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugMachines2ProxyVtbl = 
{
    &IEnumDebugMachines2_ProxyInfo,
    &IID_IEnumDebugMachines2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugMachines2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugMachines2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugMachines2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugMachines2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugMachines2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugMachines2StubVtbl =
{
    &IID_IEnumDebugMachines2,
    &IEnumDebugMachines2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugExceptionInfo2, ver. 0.0,
   GUID={0x8e4bbd34,0xa2f4,0x41ef,{0x87,0xb5,0xc5,0x63,0xb4,0xad,0x6e,0xe7}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugExceptionInfo2_FormatStringOffsetTable[] =
    {
    8726,
    260,
    3000,
    8766,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugExceptionInfo2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugExceptionInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugExceptionInfo2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugExceptionInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugExceptionInfo2ProxyVtbl = 
{
    &IEnumDebugExceptionInfo2_ProxyInfo,
    &IID_IEnumDebugExceptionInfo2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugExceptionInfo2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugExceptionInfo2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugExceptionInfo2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugExceptionInfo2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugExceptionInfo2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugExceptionInfo2StubVtbl =
{
    &IID_IEnumDebugExceptionInfo2,
    &IEnumDebugExceptionInfo2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugFrameInfo2, ver. 0.0,
   GUID={0x98bbba48,0x4c4d,0x4fff,{0x83,0x40,0x60,0x97,0xbe,0xc9,0xc8,0x94}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugFrameInfo2_FormatStringOffsetTable[] =
    {
    8794,
    260,
    3000,
    8834,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugFrameInfo2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugFrameInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugFrameInfo2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugFrameInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugFrameInfo2ProxyVtbl = 
{
    &IEnumDebugFrameInfo2_ProxyInfo,
    &IID_IEnumDebugFrameInfo2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugFrameInfo2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugFrameInfo2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugFrameInfo2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugFrameInfo2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugFrameInfo2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugFrameInfo2StubVtbl =
{
    &IID_IEnumDebugFrameInfo2,
    &IEnumDebugFrameInfo2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumCodePaths2, ver. 0.0,
   GUID={0x9b13f80d,0xcfc6,0x4b78,{0x81,0xef,0x1f,0x7c,0xc3,0x3f,0x76,0x39}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumCodePaths2_FormatStringOffsetTable[] =
    {
    8862,
    260,
    3000,
    8902,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumCodePaths2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumCodePaths2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumCodePaths2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumCodePaths2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumCodePaths2ProxyVtbl = 
{
    &IEnumCodePaths2_ProxyInfo,
    &IID_IEnumCodePaths2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumCodePaths2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumCodePaths2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumCodePaths2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumCodePaths2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumCodePaths2::GetCount */
};

const CInterfaceStubVtbl _IEnumCodePaths2StubVtbl =
{
    &IID_IEnumCodePaths2,
    &IEnumCodePaths2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugModules2, ver. 0.0,
   GUID={0x4c4a2835,0x682e,0x4ce1,{0xae,0xbc,0x1e,0x6b,0x3a,0x16,0x5b,0x44}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugModules2_FormatStringOffsetTable[] =
    {
    8930,
    260,
    3000,
    8970,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugModules2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugModules2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugModules2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugModules2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugModules2ProxyVtbl = 
{
    &IEnumDebugModules2_ProxyInfo,
    &IID_IEnumDebugModules2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugModules2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugModules2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugModules2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugModules2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugModules2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugModules2StubVtbl =
{
    &IID_IEnumDebugModules2,
    &IEnumDebugModules2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugPortSuppliers2, ver. 0.0,
   GUID={0x59c9dc99,0x3eff,0x4ff3,{0xb2,0x01,0x98,0xac,0xd0,0x1b,0x0d,0x87}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugPortSuppliers2_FormatStringOffsetTable[] =
    {
    8998,
    260,
    3000,
    9038,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugPortSuppliers2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugPortSuppliers2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugPortSuppliers2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugPortSuppliers2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugPortSuppliers2ProxyVtbl = 
{
    &IEnumDebugPortSuppliers2_ProxyInfo,
    &IID_IEnumDebugPortSuppliers2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugPortSuppliers2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPortSuppliers2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPortSuppliers2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPortSuppliers2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPortSuppliers2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugPortSuppliers2StubVtbl =
{
    &IID_IEnumDebugPortSuppliers2,
    &IEnumDebugPortSuppliers2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugPorts2, ver. 0.0,
   GUID={0xbc827c5e,0x99ae,0x4ac8,{0x83,0xad,0x2e,0xa5,0xc2,0x03,0x43,0x33}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugPorts2_FormatStringOffsetTable[] =
    {
    9066,
    260,
    3000,
    9106,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugPorts2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugPorts2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugPorts2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugPorts2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugPorts2ProxyVtbl = 
{
    &IEnumDebugPorts2_ProxyInfo,
    &IID_IEnumDebugPorts2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugPorts2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPorts2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPorts2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPorts2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPorts2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugPorts2StubVtbl =
{
    &IID_IEnumDebugPorts2,
    &IEnumDebugPorts2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugPropertyInfo2, ver. 0.0,
   GUID={0x6c7072c3,0x3ac4,0x408f,{0xa6,0x80,0xfc,0x5a,0x2f,0x96,0x90,0x3e}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugPropertyInfo2_FormatStringOffsetTable[] =
    {
    9134,
    260,
    3000,
    9174,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugPropertyInfo2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugPropertyInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugPropertyInfo2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugPropertyInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugPropertyInfo2ProxyVtbl = 
{
    &IEnumDebugPropertyInfo2_ProxyInfo,
    &IID_IEnumDebugPropertyInfo2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugPropertyInfo2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPropertyInfo2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPropertyInfo2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPropertyInfo2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugPropertyInfo2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugPropertyInfo2StubVtbl =
{
    &IID_IEnumDebugPropertyInfo2,
    &IEnumDebugPropertyInfo2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugReferenceInfo2, ver. 0.0,
   GUID={0xe459dd12,0x864f,0x4aaa,{0xab,0xc1,0xdc,0xec,0xbc,0x26,0x7f,0x04}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugReferenceInfo2_FormatStringOffsetTable[] =
    {
    9202,
    260,
    3000,
    9242,
    8120
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugReferenceInfo2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugReferenceInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugReferenceInfo2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugReferenceInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugReferenceInfo2ProxyVtbl = 
{
    &IEnumDebugReferenceInfo2_ProxyInfo,
    &IID_IEnumDebugReferenceInfo2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugReferenceInfo2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugReferenceInfo2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugReferenceInfo2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugReferenceInfo2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugReferenceInfo2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugReferenceInfo2StubVtbl =
{
    &IID_IEnumDebugReferenceInfo2,
    &IEnumDebugReferenceInfo2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _msdbg_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IDebugBreakpointBoundEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugCodeContexts2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumCodePaths2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugSession2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugProcessCreateEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugDocumentPositionOffset2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugThreads2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugReferenceInfo2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugExceptionEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugPropertyCreateEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugPropertyDestroyEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugBreakpointRequest2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugBreakEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugPendingBreakpoints2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugBreakpointEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugBreakpointResolution2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugStackFrames2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugEngineLaunch2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugMachineEx2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugProcessDestroyEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugPortNotify2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugThreadDestroyEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugExceptionInfo2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugModules2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugFindSymbolEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugActivateDocumentEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugEntryPointEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugBreakpointErrorEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugMDMUtil2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugCanStopEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugFrameInfo2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugNoSymbolsEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugFunctionPosition2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugEngineCreateEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugBreakpointUnboundEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugLoadCompleteEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugThread2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugEngine2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugLogicalThread2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugProgramNode2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugPorts2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugEngineProgram2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugProgramEngines2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugCodeContext2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugStackFrame2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugDocument2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugPortEvents2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugBoundBreakpoint2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugThreadNameChangedEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugProperty2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugExpressionContext2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugModuleLoadEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugExpressionEvaluationCompleteEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugProgramHost2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugPortSupplier2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugPortSuppliers2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugModule2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugMachine2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugPrograms2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugDocumentText2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugErrorBreakpoints2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugReference2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugDocumentContext2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugOutputStringEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugSessionCreateEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugPortRequest2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugEventCallback2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugStepCompleteEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugSessionDestroyEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugPropertyInfo2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugPort2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugQueryEngine2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugReturnValueEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugMessageEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugExpression2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugMemoryBytes2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugMemoryContext2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugBoundBreakpoints2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugDocumentTextEvents2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugProgramDestroyEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugProcess2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugMachines2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugDocumentPosition2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugProgramCreateEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugProgram2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugPendingBreakpoint2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugProcesses2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugErrorBreakpoint2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugModuleManagedProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugErrorBreakpointResolution2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugThreadCreateEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugProgramNameChangedEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugDisassemblyStream2ProxyVtbl,
    0
};

const CInterfaceStubVtbl * _msdbg_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IDebugBreakpointBoundEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugCodeContexts2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumCodePaths2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugSession2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugProcessCreateEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugDocumentPositionOffset2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugThreads2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugReferenceInfo2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugExceptionEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugPropertyCreateEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugPropertyDestroyEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugBreakpointRequest2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugBreakEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugPendingBreakpoints2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugBreakpointEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugBreakpointResolution2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugStackFrames2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugEngineLaunch2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugMachineEx2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugProcessDestroyEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugPortNotify2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugThreadDestroyEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugExceptionInfo2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugModules2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugFindSymbolEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugActivateDocumentEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugEntryPointEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugBreakpointErrorEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugMDMUtil2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugCanStopEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugFrameInfo2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugNoSymbolsEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugFunctionPosition2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugEngineCreateEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugBreakpointUnboundEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugLoadCompleteEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugThread2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugEngine2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugLogicalThread2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugProgramNode2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugPorts2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugEngineProgram2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugProgramEngines2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugCodeContext2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugStackFrame2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugDocument2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugPortEvents2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugBoundBreakpoint2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugThreadNameChangedEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugProperty2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugExpressionContext2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugModuleLoadEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugExpressionEvaluationCompleteEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugProgramHost2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugPortSupplier2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugPortSuppliers2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugModule2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugMachine2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugPrograms2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugDocumentText2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugErrorBreakpoints2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugReference2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugDocumentContext2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugOutputStringEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugSessionCreateEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugPortRequest2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugEventCallback2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugStepCompleteEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugSessionDestroyEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugPropertyInfo2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugPort2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugQueryEngine2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugReturnValueEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugMessageEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugExpression2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugMemoryBytes2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugMemoryContext2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugBoundBreakpoints2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugDocumentTextEvents2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugProgramDestroyEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugProcess2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugMachines2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugDocumentPosition2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugProgramCreateEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugProgram2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugPendingBreakpoint2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugProcesses2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugErrorBreakpoint2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugModuleManagedStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugErrorBreakpointResolution2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugThreadCreateEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugProgramNameChangedEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugDisassemblyStream2StubVtbl,
    0
};

PCInterfaceName const _msdbg_InterfaceNamesList[] = 
{
    "IDebugBreakpointBoundEvent2",
    "IEnumDebugCodeContexts2",
    "IEnumCodePaths2",
    "IDebugSession2",
    "IDebugProcessCreateEvent2",
    "IDebugDocumentPositionOffset2",
    "IEnumDebugThreads2",
    "IEnumDebugReferenceInfo2",
    "IDebugExceptionEvent2",
    "IDebugPropertyCreateEvent2",
    "IDebugPropertyDestroyEvent2",
    "IDebugBreakpointRequest2",
    "IDebugBreakEvent2",
    "IEnumDebugPendingBreakpoints2",
    "IDebugBreakpointEvent2",
    "IDebugBreakpointResolution2",
    "IEnumDebugStackFrames2",
    "IDebugEngineLaunch2",
    "IDebugMachineEx2",
    "IDebugProcessDestroyEvent2",
    "IDebugPortNotify2",
    "IDebugThreadDestroyEvent2",
    "IEnumDebugExceptionInfo2",
    "IEnumDebugModules2",
    "IDebugFindSymbolEvent2",
    "IDebugActivateDocumentEvent2",
    "IDebugEntryPointEvent2",
    "IDebugBreakpointErrorEvent2",
    "IDebugMDMUtil2",
    "IDebugCanStopEvent2",
    "IEnumDebugFrameInfo2",
    "IDebugNoSymbolsEvent2",
    "IDebugFunctionPosition2",
    "IDebugEngineCreateEvent2",
    "IDebugBreakpointUnboundEvent2",
    "IDebugLoadCompleteEvent2",
    "IDebugThread2",
    "IDebugEngine2",
    "IDebugLogicalThread2",
    "IDebugProgramNode2",
    "IEnumDebugPorts2",
    "IDebugEngineProgram2",
    "IDebugProgramEngines2",
    "IDebugCodeContext2",
    "IDebugStackFrame2",
    "IDebugDocument2",
    "IDebugPortEvents2",
    "IDebugBoundBreakpoint2",
    "IDebugThreadNameChangedEvent2",
    "IDebugProperty2",
    "IDebugExpressionContext2",
    "IDebugModuleLoadEvent2",
    "IDebugExpressionEvaluationCompleteEvent2",
    "IDebugProgramHost2",
    "IDebugPortSupplier2",
    "IEnumDebugPortSuppliers2",
    "IDebugModule2",
    "IDebugMachine2",
    "IEnumDebugPrograms2",
    "IDebugDocumentText2",
    "IEnumDebugErrorBreakpoints2",
    "IDebugReference2",
    "IDebugDocumentContext2",
    "IDebugOutputStringEvent2",
    "IDebugSessionCreateEvent2",
    "IDebugPortRequest2",
    "IDebugEventCallback2",
    "IDebugStepCompleteEvent2",
    "IDebugSessionDestroyEvent2",
    "IEnumDebugPropertyInfo2",
    "IDebugPort2",
    "IDebugQueryEngine2",
    "IDebugReturnValueEvent2",
    "IDebugMessageEvent2",
    "IDebugExpression2",
    "IDebugMemoryBytes2",
    "IDebugEvent2",
    "IDebugMemoryContext2",
    "IEnumDebugBoundBreakpoints2",
    "IDebugDocumentTextEvents2",
    "IDebugProgramDestroyEvent2",
    "IDebugProcess2",
    "IEnumDebugMachines2",
    "IDebugDocumentPosition2",
    "IDebugProgramCreateEvent2",
    "IDebugProgram2",
    "IDebugPendingBreakpoint2",
    "IEnumDebugProcesses2",
    "IDebugErrorBreakpoint2",
    "IDebugModuleManaged",
    "IDebugErrorBreakpointResolution2",
    "IDebugThreadCreateEvent2",
    "IDebugProgramNameChangedEvent2",
    "IDebugDisassemblyStream2",
    0
};


#define _msdbg_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _msdbg, pIID, n)

int __stdcall _msdbg_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _msdbg, 94, 64 )
    IID_BS_LOOKUP_NEXT_TEST( _msdbg, 32 )
    IID_BS_LOOKUP_NEXT_TEST( _msdbg, 16 )
    IID_BS_LOOKUP_NEXT_TEST( _msdbg, 8 )
    IID_BS_LOOKUP_NEXT_TEST( _msdbg, 4 )
    IID_BS_LOOKUP_NEXT_TEST( _msdbg, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _msdbg, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _msdbg, 94, *pIndex )
    
}

const ExtendedProxyFileInfo msdbg_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _msdbg_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _msdbg_StubVtblList,
    (const PCInterfaceName * ) & _msdbg_InterfaceNamesList,
    0, // no delegation
    & _msdbg_IID_Lookup, 
    94,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\debugger\idl\obj\i386\sh_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:01 2002
 */
/* Compiler settings for sh.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "sh.h"

#define TYPE_FORMAT_STRING_SIZE   765                               
#define PROC_FORMAT_STRING_SIZE   2923                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugSymbolProvider_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugSymbolProvider_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugComPlusSymbolProvider_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugComPlusSymbolProvider_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugNativeSymbolProvider_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugNativeSymbolProvider_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugField_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugField_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugContainerField_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugContainerField_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugMethodField_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugMethodField_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugClassField_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugClassField_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugPropertyField_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugPropertyField_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugArrayField_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugArrayField_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugPointerField_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugPointerField_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugEnumField_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugEnumField_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugBitField_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugBitField_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugDynamicField_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugDynamicField_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugDynamicFieldCOMPlus_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugDynamicFieldCOMPlus_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugEngineSymbolProviderServices_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugEngineSymbolProviderServices_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugAddress_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugAddress_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugFields_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugFields_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugAddresses_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugAddresses_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugCustomAttributeQuery_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugCustomAttributeQuery_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Initialize */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pServices */

/* 16 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 22 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Uninitialize */

/* 28 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 30 */	NdrFcLong( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x4 ),	/* 4 */
/* 36 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
/* 42 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 44 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 46 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 48 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetContainerField */

/* 50 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x5 ),	/* 5 */
/* 58 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 60 */	NdrFcShort( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x8 ),	/* 8 */
/* 64 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAddress */

/* 66 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 68 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 70 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter ppContainerField */

/* 72 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 74 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 76 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Return value */

/* 78 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 80 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 82 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetField */

/* 84 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 86 */	NdrFcLong( 0x0 ),	/* 0 */
/* 90 */	NdrFcShort( 0x6 ),	/* 6 */
/* 92 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x8 ),	/* 8 */
/* 98 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pAddress */

/* 100 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 102 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 104 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter pAddressCur */

/* 106 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 108 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 110 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter ppField */

/* 112 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 114 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 116 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Return value */

/* 118 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 120 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 122 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAddressesFromPosition */

/* 124 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 126 */	NdrFcLong( 0x0 ),	/* 0 */
/* 130 */	NdrFcShort( 0x7 ),	/* 7 */
/* 132 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 134 */	NdrFcShort( 0x8 ),	/* 8 */
/* 136 */	NdrFcShort( 0x8 ),	/* 8 */
/* 138 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter pDocPos */

/* 140 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 142 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 144 */	NdrFcShort( 0x52 ),	/* Type Offset=82 */

	/* Parameter fStatmentOnly */

/* 146 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 148 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 150 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppEnumBegAddresses */

/* 152 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 154 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 156 */	NdrFcShort( 0x64 ),	/* Type Offset=100 */

	/* Parameter ppEnumEndAddresses */

/* 158 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 160 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 162 */	NdrFcShort( 0x64 ),	/* Type Offset=100 */

	/* Return value */

/* 164 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 166 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 168 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAddressesFromContext */

/* 170 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 172 */	NdrFcLong( 0x0 ),	/* 0 */
/* 176 */	NdrFcShort( 0x8 ),	/* 8 */
/* 178 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 180 */	NdrFcShort( 0x8 ),	/* 8 */
/* 182 */	NdrFcShort( 0x8 ),	/* 8 */
/* 184 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter pDocContext */

/* 186 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 188 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 190 */	NdrFcShort( 0x7a ),	/* Type Offset=122 */

	/* Parameter fStatmentOnly */

/* 192 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 194 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppEnumBegAddresses */

/* 198 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 200 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 202 */	NdrFcShort( 0x64 ),	/* Type Offset=100 */

	/* Parameter ppEnumEndAddresses */

/* 204 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 206 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 208 */	NdrFcShort( 0x64 ),	/* Type Offset=100 */

	/* Return value */

/* 210 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 212 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetContextFromAddress */

/* 216 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 218 */	NdrFcLong( 0x0 ),	/* 0 */
/* 222 */	NdrFcShort( 0x9 ),	/* 9 */
/* 224 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 228 */	NdrFcShort( 0x8 ),	/* 8 */
/* 230 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAddress */

/* 232 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 234 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 236 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter ppDocContext */

/* 238 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 240 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 242 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Return value */

/* 244 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 246 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 248 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLanguage */

/* 250 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 252 */	NdrFcLong( 0x0 ),	/* 0 */
/* 256 */	NdrFcShort( 0xa ),	/* 10 */
/* 258 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 262 */	NdrFcShort( 0x90 ),	/* 144 */
/* 264 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pAddress */

/* 266 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 268 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 270 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter pguidLanguage */

/* 272 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 274 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 276 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter pguidLanguageVendor */

/* 278 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 280 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 282 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Return value */

/* 284 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 286 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 288 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetGlobalContainer */

/* 290 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 292 */	NdrFcLong( 0x0 ),	/* 0 */
/* 296 */	NdrFcShort( 0xb ),	/* 11 */
/* 298 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 302 */	NdrFcShort( 0x8 ),	/* 8 */
/* 304 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pField */

/* 306 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 308 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 310 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Return value */

/* 312 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 314 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 316 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMethodFieldsByName */

/* 318 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 320 */	NdrFcLong( 0x0 ),	/* 0 */
/* 324 */	NdrFcShort( 0xc ),	/* 12 */
/* 326 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 328 */	NdrFcShort( 0x6 ),	/* 6 */
/* 330 */	NdrFcShort( 0x8 ),	/* 8 */
/* 332 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pszFullName */

/* 334 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 336 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 338 */	NdrFcShort( 0xa6 ),	/* Type Offset=166 */

	/* Parameter nameMatch */

/* 340 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 342 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 344 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ppEnum */

/* 346 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 348 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 350 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */

/* 352 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 354 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 356 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetClassTypeByName */

/* 358 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 360 */	NdrFcLong( 0x0 ),	/* 0 */
/* 364 */	NdrFcShort( 0xd ),	/* 13 */
/* 366 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 368 */	NdrFcShort( 0x6 ),	/* 6 */
/* 370 */	NdrFcShort( 0x8 ),	/* 8 */
/* 372 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pszClassName */

/* 374 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 376 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 378 */	NdrFcShort( 0xa6 ),	/* Type Offset=166 */

	/* Parameter nameMatch */

/* 380 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 382 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 384 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ppField */

/* 386 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 388 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 390 */	NdrFcShort( 0xc0 ),	/* Type Offset=192 */

	/* Return value */

/* 392 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 394 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 396 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetNamespacesUsedAtAddress */

/* 398 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 400 */	NdrFcLong( 0x0 ),	/* 0 */
/* 404 */	NdrFcShort( 0xe ),	/* 14 */
/* 406 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 410 */	NdrFcShort( 0x8 ),	/* 8 */
/* 412 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAddress */

/* 414 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 416 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 418 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter ppEnum */

/* 420 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 422 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 424 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */

/* 426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 428 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTypeByName */

/* 432 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0xf ),	/* 15 */
/* 440 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 442 */	NdrFcShort( 0x6 ),	/* 6 */
/* 444 */	NdrFcShort( 0x8 ),	/* 8 */
/* 446 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pszClassName */

/* 448 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 450 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 452 */	NdrFcShort( 0xa6 ),	/* Type Offset=166 */

	/* Parameter nameMatch */

/* 454 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 456 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 458 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ppField */

/* 460 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 462 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 464 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Return value */

/* 466 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 468 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 470 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetNextAddress */

/* 472 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 474 */	NdrFcLong( 0x0 ),	/* 0 */
/* 478 */	NdrFcShort( 0x10 ),	/* 16 */
/* 480 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 482 */	NdrFcShort( 0x8 ),	/* 8 */
/* 484 */	NdrFcShort( 0x8 ),	/* 8 */
/* 486 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pAddress */

/* 488 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 490 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 492 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter fStatmentOnly */

/* 494 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 496 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppAddress */

/* 500 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 502 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 504 */	NdrFcShort( 0xd6 ),	/* Type Offset=214 */

	/* Return value */

/* 506 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 508 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 510 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LoadSymbols */

/* 512 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 514 */	NdrFcLong( 0x0 ),	/* 0 */
/* 518 */	NdrFcShort( 0x11 ),	/* 17 */
/* 520 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 522 */	NdrFcShort( 0x48 ),	/* 72 */
/* 524 */	NdrFcShort( 0x8 ),	/* 8 */
/* 526 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter ulAppDomainID */

/* 528 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 530 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 532 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 534 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 536 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 538 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter baseAddress */

/* 540 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 542 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 544 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter pUnkMetadataImport */

/* 546 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 548 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 550 */	NdrFcShort( 0xda ),	/* Type Offset=218 */

	/* Parameter bstrModuleName */

/* 552 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 554 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 556 */	NdrFcShort( 0x104 ),	/* Type Offset=260 */

	/* Parameter bstrSymSearchPath */

/* 558 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 560 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 562 */	NdrFcShort( 0x104 ),	/* Type Offset=260 */

	/* Return value */

/* 564 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 566 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 568 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UnloadSymbols */

/* 570 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 572 */	NdrFcLong( 0x0 ),	/* 0 */
/* 576 */	NdrFcShort( 0x12 ),	/* 18 */
/* 578 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 580 */	NdrFcShort( 0x38 ),	/* 56 */
/* 582 */	NdrFcShort( 0x8 ),	/* 8 */
/* 584 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter ulAppDomainID */

/* 586 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 588 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 590 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 592 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 594 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 596 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Return value */

/* 598 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 600 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 602 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetEntryPoint */

/* 604 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 606 */	NdrFcLong( 0x0 ),	/* 0 */
/* 610 */	NdrFcShort( 0x13 ),	/* 19 */
/* 612 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 614 */	NdrFcShort( 0x38 ),	/* 56 */
/* 616 */	NdrFcShort( 0x8 ),	/* 8 */
/* 618 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter ulAppDomainID */

/* 620 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 622 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 624 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 626 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 628 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 630 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter ppAddress */

/* 632 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 634 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 636 */	NdrFcShort( 0xd6 ),	/* Type Offset=214 */

	/* Return value */

/* 638 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 640 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 642 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTypeFromAddress */

/* 644 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 646 */	NdrFcLong( 0x0 ),	/* 0 */
/* 650 */	NdrFcShort( 0x14 ),	/* 20 */
/* 652 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 654 */	NdrFcShort( 0x0 ),	/* 0 */
/* 656 */	NdrFcShort( 0x8 ),	/* 8 */
/* 658 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAddress */

/* 660 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 662 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 664 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter ppField */

/* 666 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 668 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 670 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Return value */

/* 672 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 674 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 676 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UpdateSymbols */

/* 678 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 680 */	NdrFcLong( 0x0 ),	/* 0 */
/* 684 */	NdrFcShort( 0x15 ),	/* 21 */
/* 686 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 688 */	NdrFcShort( 0x38 ),	/* 56 */
/* 690 */	NdrFcShort( 0x8 ),	/* 8 */
/* 692 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter ulAppDomainID */

/* 694 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 696 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 698 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 700 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 702 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 704 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter pUpdateStream */

/* 706 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 708 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 710 */	NdrFcShort( 0x10e ),	/* Type Offset=270 */

	/* Return value */

/* 712 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 714 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 716 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateTypeFromPrimitive */

/* 718 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 720 */	NdrFcLong( 0x0 ),	/* 0 */
/* 724 */	NdrFcShort( 0x16 ),	/* 22 */
/* 726 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 728 */	NdrFcShort( 0x8 ),	/* 8 */
/* 730 */	NdrFcShort( 0x8 ),	/* 8 */
/* 732 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter dwPrimType */

/* 734 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 736 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 738 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pAddress */

/* 740 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 742 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 744 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter ppType */

/* 746 */	NdrFcShort( 0x200b ),	/* Flags:  must size, must free, in, srv alloc size=8 */
/* 748 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 750 */	NdrFcShort( 0x120 ),	/* Type Offset=288 */

	/* Return value */

/* 752 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 754 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 756 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFunctionLineOffset */

/* 758 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 760 */	NdrFcLong( 0x0 ),	/* 0 */
/* 764 */	NdrFcShort( 0x17 ),	/* 23 */
/* 766 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 768 */	NdrFcShort( 0x8 ),	/* 8 */
/* 770 */	NdrFcShort( 0x8 ),	/* 8 */
/* 772 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pAddress */

/* 774 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 776 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 778 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter dwLine */

/* 780 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 782 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 784 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppNewAddress */

/* 786 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 788 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 790 */	NdrFcShort( 0xd6 ),	/* Type Offset=214 */

	/* Return value */

/* 792 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 794 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 796 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAddressesInModuleFromPosition */

/* 798 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 800 */	NdrFcLong( 0x0 ),	/* 0 */
/* 804 */	NdrFcShort( 0x18 ),	/* 24 */
/* 806 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 808 */	NdrFcShort( 0x40 ),	/* 64 */
/* 810 */	NdrFcShort( 0x8 ),	/* 8 */
/* 812 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter ulAppDomainID */

/* 814 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 816 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 818 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 820 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 822 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 824 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter pDocPos */

/* 826 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 828 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 830 */	NdrFcShort( 0x52 ),	/* Type Offset=82 */

	/* Parameter fStatmentOnly */

/* 832 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 834 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 836 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppEnumBegAddresses */

/* 838 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 840 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 842 */	NdrFcShort( 0x64 ),	/* Type Offset=100 */

	/* Parameter ppEnumEndAddresses */

/* 844 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 846 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 848 */	NdrFcShort( 0x64 ),	/* Type Offset=100 */

	/* Return value */

/* 850 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 852 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 854 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetArrayTypeFromAddress */

/* 856 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 858 */	NdrFcLong( 0x0 ),	/* 0 */
/* 862 */	NdrFcShort( 0x19 ),	/* 25 */
/* 864 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 866 */	NdrFcShort( 0x8 ),	/* 8 */
/* 868 */	NdrFcShort( 0x8 ),	/* 8 */
/* 870 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter pAddress */

/* 872 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 874 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 876 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter pSig */

/* 878 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 880 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 882 */	NdrFcShort( 0x128 ),	/* Type Offset=296 */

	/* Parameter dwSigLength */

/* 884 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 886 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 888 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppField */

/* 890 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 892 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 894 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Return value */

/* 896 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 898 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 900 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSymAttribute */

/* 902 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 904 */	NdrFcLong( 0x0 ),	/* 0 */
/* 908 */	NdrFcShort( 0x1a ),	/* 26 */
/* 910 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 912 */	NdrFcShort( 0x48 ),	/* 72 */
/* 914 */	NdrFcShort( 0x24 ),	/* 36 */
/* 916 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x8,		/* 8 */

	/* Parameter ulAppDomainID */

/* 918 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 920 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 922 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 924 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 926 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 928 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter tokParent */

/* 930 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 932 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pstrName */

/* 936 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 938 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 940 */	NdrFcShort( 0x138 ),	/* Type Offset=312 */

	/* Parameter cBuffer */

/* 942 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 944 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 946 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcBuffer */

/* 948 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 950 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 952 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter buffer */

/* 954 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 956 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 958 */	NdrFcShort( 0x13e ),	/* Type Offset=318 */

	/* Return value */

/* 960 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 962 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 964 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReplaceSymbols */

/* 966 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 968 */	NdrFcLong( 0x0 ),	/* 0 */
/* 972 */	NdrFcShort( 0x1b ),	/* 27 */
/* 974 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 976 */	NdrFcShort( 0x38 ),	/* 56 */
/* 978 */	NdrFcShort( 0x8 ),	/* 8 */
/* 980 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter ulAppDomainID */

/* 982 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 984 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 986 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 988 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 990 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 992 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter pStream */

/* 994 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 996 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 998 */	NdrFcShort( 0x10e ),	/* Type Offset=270 */

	/* Return value */

/* 1000 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1002 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1004 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AreSymbolsLoaded */

/* 1006 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1008 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1012 */	NdrFcShort( 0x1c ),	/* 28 */
/* 1014 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1016 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1018 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1020 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter ulAppDomainID */

/* 1022 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1024 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1026 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 1028 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 1030 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1032 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Return value */

/* 1034 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1036 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1038 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LoadSymbolsFromStream */

/* 1040 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1042 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1046 */	NdrFcShort( 0x1d ),	/* 29 */
/* 1048 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 1050 */	NdrFcShort( 0x48 ),	/* 72 */
/* 1052 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1054 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter ulAppDomainID */

/* 1056 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1058 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1060 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 1062 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 1064 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1066 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter baseAddress */

/* 1068 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1070 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1072 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter pUnkMetadataImport */

/* 1074 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1076 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1078 */	NdrFcShort( 0xda ),	/* Type Offset=218 */

	/* Parameter pStream */

/* 1080 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1082 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 1084 */	NdrFcShort( 0x10e ),	/* Type Offset=270 */

	/* Return value */

/* 1086 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1088 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 1090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSymUnmanagedReader */

/* 1092 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1094 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1098 */	NdrFcShort( 0x1e ),	/* 30 */
/* 1100 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1102 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1104 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1106 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter ulAppDomainID */

/* 1108 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1110 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1112 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 1114 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 1116 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1118 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter ppSymUnmanagedReader */

/* 1120 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1122 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1124 */	NdrFcShort( 0x14c ),	/* Type Offset=332 */

	/* Return value */

/* 1126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1128 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAttributedClassesinModule */

/* 1132 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1134 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1138 */	NdrFcShort( 0x1f ),	/* 31 */
/* 1140 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 1142 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1144 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1146 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter ulAppDomainID */

/* 1148 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1150 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1152 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 1154 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 1156 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1158 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter pstrAttribute */

/* 1160 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1162 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1164 */	NdrFcShort( 0x138 ),	/* Type Offset=312 */

	/* Parameter ppEnum */

/* 1166 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1168 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1170 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */

/* 1172 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1174 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1176 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAttributedClassesForLanguage */

/* 1178 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1180 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1184 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1186 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1188 */	NdrFcShort( 0x30 ),	/* 48 */
/* 1190 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1192 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter guidLanguage */

/* 1194 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 1196 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1198 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter pstrAttribute */

/* 1200 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1202 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1204 */	NdrFcShort( 0x138 ),	/* Type Offset=312 */

	/* Parameter ppEnum */

/* 1206 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1208 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1210 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */

/* 1212 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1214 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1216 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsHiddenCode */

/* 1218 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1220 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1224 */	NdrFcShort( 0x21 ),	/* 33 */
/* 1226 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1230 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1232 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pAddress */

/* 1234 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1236 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1238 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Return value */

/* 1240 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1242 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1244 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsFunctionDeleted */

/* 1246 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1248 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1252 */	NdrFcShort( 0x22 ),	/* 34 */
/* 1254 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1256 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1258 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1260 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pAddress */

/* 1262 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1264 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1266 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Return value */

/* 1268 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1270 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1272 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetNameFromToken */

/* 1274 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1276 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1280 */	NdrFcShort( 0x23 ),	/* 35 */
/* 1282 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1284 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1286 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1288 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pMetadataImport */

/* 1290 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1292 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1294 */	NdrFcShort( 0xda ),	/* Type Offset=218 */

	/* Parameter dwToken */

/* 1296 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1298 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1300 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrName */

/* 1302 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1304 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1306 */	NdrFcShort( 0x158 ),	/* Type Offset=344 */

	/* Return value */

/* 1308 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1310 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1312 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsFunctionStale */

/* 1314 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1316 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1320 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1322 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1324 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1326 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1328 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pAddress */

/* 1330 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1332 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1334 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Return value */

/* 1336 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1338 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1340 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetLocalVariablelayout */

/* 1342 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1344 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1348 */	NdrFcShort( 0x25 ),	/* 37 */
/* 1350 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 1352 */	NdrFcShort( 0x40 ),	/* 64 */
/* 1354 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1356 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter ulAppDomainID */

/* 1358 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1360 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1362 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 1364 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 1366 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1368 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter cMethods */

/* 1370 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1372 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1374 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgMethodTokens */

/* 1376 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1378 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1380 */	NdrFcShort( 0x162 ),	/* Type Offset=354 */

	/* Parameter pStreamLayout */

/* 1382 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1384 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1386 */	NdrFcShort( 0x16c ),	/* Type Offset=364 */

	/* Return value */

/* 1388 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1390 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 1392 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAssemblyName */

/* 1394 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1396 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1400 */	NdrFcShort( 0x26 ),	/* 38 */
/* 1402 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1404 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1406 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1408 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter ulAppDomainID */

/* 1410 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1412 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1414 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 1416 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 1418 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1420 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter pbstrName */

/* 1422 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1424 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1426 */	NdrFcShort( 0x158 ),	/* Type Offset=344 */

	/* Return value */

/* 1428 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1430 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1432 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LoadSymbols */

/* 1434 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1436 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1440 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1442 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1444 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1446 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1448 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pszFileName */

/* 1450 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1452 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1454 */	NdrFcShort( 0x138 ),	/* Type Offset=312 */

	/* Return value */

/* 1456 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1458 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1460 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInfo */

/* 1462 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1464 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1468 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1470 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1472 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1474 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1476 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwFields */

/* 1478 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1480 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1482 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pFieldInfo */

/* 1484 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 1486 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1488 */	NdrFcShort( 0x174 ),	/* Type Offset=372 */

	/* Return value */

/* 1490 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1492 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1494 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetKind */

/* 1496 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1498 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1502 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1504 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1506 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1508 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1510 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pdwKind */

/* 1512 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1514 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1516 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1518 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1520 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1522 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetType */

/* 1524 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1526 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1530 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1532 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1536 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1538 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppType */

/* 1540 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1542 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1544 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Return value */

/* 1546 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1548 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1550 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetContainer */

/* 1552 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1554 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1558 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1560 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1564 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1566 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppContainerField */

/* 1568 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1570 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1572 */	NdrFcShort( 0x26 ),	/* Type Offset=38 */

	/* Return value */

/* 1574 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1576 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1578 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAddress */

/* 1580 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1582 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1586 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1588 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1592 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1594 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppAddress */

/* 1596 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1598 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1600 */	NdrFcShort( 0xd6 ),	/* Type Offset=214 */

	/* Return value */

/* 1602 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1604 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1606 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSize */

/* 1608 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1610 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1614 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1616 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1618 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1620 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1622 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pdwSize */

/* 1624 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1626 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1628 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1630 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1632 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1634 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetExtendedInfo */

/* 1636 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1638 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1642 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1644 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1646 */	NdrFcShort( 0x60 ),	/* 96 */
/* 1648 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1650 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter guidExtendedInfo */

/* 1652 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1654 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1656 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter prgBuffer */

/* 1658 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 1660 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1662 */	NdrFcShort( 0x194 ),	/* Type Offset=404 */

	/* Parameter pdwLen */

/* 1664 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1666 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1668 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1670 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1672 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1674 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Equal */

/* 1676 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1678 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1682 */	NdrFcShort( 0xa ),	/* 10 */
/* 1684 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1688 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1690 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pField */

/* 1692 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1694 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1696 */	NdrFcShort( 0x40 ),	/* Type Offset=64 */

	/* Return value */

/* 1698 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1700 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1702 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTypeInfo */

/* 1704 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1706 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1710 */	NdrFcShort( 0xb ),	/* 11 */
/* 1712 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1714 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1716 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1718 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pTypeInfo */

/* 1720 */	NdrFcShort( 0x8113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=32 */
/* 1722 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1724 */	NdrFcShort( 0x1be ),	/* Type Offset=446 */

	/* Return value */

/* 1726 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1728 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumFields */

/* 1732 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 1734 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1738 */	NdrFcShort( 0xc ),	/* 12 */
/* 1740 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1742 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1744 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1746 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter dwKindFilter */

/* 1748 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1750 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1752 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwModifiersFilter */

/* 1754 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1756 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1758 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pszNameFilter */

/* 1760 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1762 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1764 */	NdrFcShort( 0xa6 ),	/* Type Offset=166 */

	/* Parameter nameMatch */

/* 1766 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1768 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1770 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ppEnum */

/* 1772 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1774 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1776 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */

/* 1778 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1780 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1782 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumBaseClasses */


	/* Procedure EnumParameters */

/* 1784 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1786 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1790 */	NdrFcShort( 0xd ),	/* 13 */
/* 1792 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1796 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1798 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */


	/* Parameter ppParams */

/* 1800 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1802 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1804 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */


	/* Return value */

/* 1806 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1808 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1810 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetThis */

/* 1812 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1814 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1818 */	NdrFcShort( 0xe ),	/* 14 */
/* 1820 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1824 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1826 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppClass */

/* 1828 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1830 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1832 */	NdrFcShort( 0xc0 ),	/* Type Offset=192 */

	/* Return value */

/* 1834 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1836 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1838 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumAllLocals */

/* 1840 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1842 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1846 */	NdrFcShort( 0xf ),	/* 15 */
/* 1848 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1850 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1852 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1854 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAddress */

/* 1856 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1858 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1860 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter ppLocals */

/* 1862 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1864 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1866 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */

/* 1868 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1870 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1872 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumLocals */

/* 1874 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1876 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1880 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1882 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1884 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1886 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1888 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pAddress */

/* 1890 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1892 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1894 */	NdrFcShort( 0x14 ),	/* Type Offset=20 */

	/* Parameter ppLocals */

/* 1896 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1898 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1900 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */

/* 1902 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1904 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1906 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsCustomAttributeDefined */

/* 1908 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 1910 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1914 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1916 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1918 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1920 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1922 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pszCustomAttributeName */

/* 1924 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1926 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1928 */	NdrFcShort( 0xa6 ),	/* Type Offset=166 */

	/* Return value */

/* 1930 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1932 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumStaticLocals */

/* 1936 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1938 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1942 */	NdrFcShort( 0x12 ),	/* 18 */
/* 1944 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1946 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1948 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1950 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppLocals */

/* 1952 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1954 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1956 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */

/* 1958 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1960 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1962 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetGlobalContainer */

/* 1964 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1966 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1970 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1972 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1974 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1976 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1978 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppClass */

/* 1980 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1982 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1984 */	NdrFcShort( 0xc0 ),	/* Type Offset=192 */

	/* Return value */

/* 1986 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1988 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1990 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumNestedEnums */


	/* Procedure EnumArguments */

/* 1992 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1994 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1998 */	NdrFcShort( 0x14 ),	/* 20 */
/* 2000 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2004 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2006 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */


	/* Parameter ppParams */

/* 2008 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2010 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2012 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */


	/* Return value */

/* 2014 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2016 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2018 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DoesInterfaceExist */

/* 2020 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 2022 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2026 */	NdrFcShort( 0xe ),	/* 14 */
/* 2028 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2030 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2032 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2034 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pszInterfaceName */

/* 2036 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2038 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2040 */	NdrFcShort( 0xa6 ),	/* Type Offset=166 */

	/* Return value */

/* 2042 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2044 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2046 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumNestedClasses */

/* 2048 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2050 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2054 */	NdrFcShort( 0xf ),	/* 15 */
/* 2056 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2058 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2060 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2062 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 2064 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2066 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2068 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */

/* 2070 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2072 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2074 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetEnclosingClass */

/* 2076 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2078 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2082 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2084 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2086 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2088 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2090 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppClassField */

/* 2092 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2094 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2096 */	NdrFcShort( 0xc0 ),	/* Type Offset=192 */

	/* Return value */

/* 2098 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2100 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2102 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumInterfacesImplemented */

/* 2104 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2106 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2110 */	NdrFcShort( 0x11 ),	/* 17 */
/* 2112 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2116 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2118 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 2120 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2122 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2124 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */

/* 2126 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2128 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumConstructors */

/* 2132 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2134 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2138 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2140 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2142 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2144 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2146 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter cMatch */

/* 2148 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2150 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2152 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ppEnum */

/* 2154 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2156 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2158 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */

/* 2160 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2162 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2164 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetDefaultIndexer */

/* 2166 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2168 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2172 */	NdrFcShort( 0x13 ),	/* 19 */
/* 2174 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2178 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2180 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pbstrIndexer */

/* 2182 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 2184 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2186 */	NdrFcShort( 0x158 ),	/* Type Offset=344 */

	/* Return value */

/* 2188 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2190 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPropertyGetter */

/* 2194 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2196 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2200 */	NdrFcShort( 0xd ),	/* 13 */
/* 2202 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2204 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2206 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2208 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppField */

/* 2210 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2212 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2214 */	NdrFcShort( 0x1de ),	/* Type Offset=478 */

	/* Return value */

/* 2216 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2218 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2220 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetPropertySetter */

/* 2222 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2224 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2228 */	NdrFcShort( 0xe ),	/* 14 */
/* 2230 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2232 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2234 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2236 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppField */

/* 2238 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2240 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2242 */	NdrFcShort( 0x1de ),	/* Type Offset=478 */

	/* Return value */

/* 2244 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2246 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2248 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetNumberOfElements */

/* 2250 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2252 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2256 */	NdrFcShort( 0xd ),	/* 13 */
/* 2258 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2262 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2264 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pdwNumElements */

/* 2266 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2268 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2270 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2272 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2274 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2276 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetElementType */

/* 2278 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2280 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2284 */	NdrFcShort( 0xe ),	/* 14 */
/* 2286 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2288 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2290 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2292 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppType */

/* 2294 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2296 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2298 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Return value */

/* 2300 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2302 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2304 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRank */

/* 2306 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2308 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2312 */	NdrFcShort( 0xf ),	/* 15 */
/* 2314 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2316 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2318 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2320 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pdwRank */

/* 2322 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2324 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2326 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2328 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2330 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2332 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetUnderlyingSymbol */


	/* Procedure GetDereferencedField */

/* 2334 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2336 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2340 */	NdrFcShort( 0xd ),	/* 13 */
/* 2342 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2346 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2348 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppField */


	/* Parameter ppField */

/* 2350 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2352 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2354 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Return value */


	/* Return value */

/* 2356 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2358 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2360 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetStringFromValue */

/* 2362 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2364 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2368 */	NdrFcShort( 0xe ),	/* 14 */
/* 2370 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2372 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2374 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2376 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter value */

/* 2378 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2380 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2382 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter pbstrValue */

/* 2384 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 2386 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2388 */	NdrFcShort( 0x158 ),	/* Type Offset=344 */

	/* Return value */

/* 2390 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2392 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetValueFromString */

/* 2396 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 2398 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2402 */	NdrFcShort( 0xf ),	/* 15 */
/* 2404 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2408 */	NdrFcShort( 0x2c ),	/* 44 */
/* 2410 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pszValue */

/* 2412 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2414 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2416 */	NdrFcShort( 0xa6 ),	/* Type Offset=166 */

	/* Parameter pvalue */

/* 2418 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2420 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2422 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 2424 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2426 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2428 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetValueFromStringCaseInsensitive */

/* 2430 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 2432 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2436 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2438 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2440 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2442 */	NdrFcShort( 0x2c ),	/* 44 */
/* 2444 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pszValue */

/* 2446 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2448 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2450 */	NdrFcShort( 0xa6 ),	/* Type Offset=166 */

	/* Parameter pvalue */

/* 2452 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2454 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2456 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 2458 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2460 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2462 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetStart */

/* 2464 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2466 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2470 */	NdrFcShort( 0xc ),	/* 12 */
/* 2472 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2476 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2478 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pdwBitOffset */

/* 2480 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2482 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2484 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2486 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2488 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTypeFromPrimitive */

/* 2492 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2494 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2498 */	NdrFcShort( 0xc ),	/* 12 */
/* 2500 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2502 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2506 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter dwCorElementType */

/* 2508 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2510 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2512 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppType */

/* 2514 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2516 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2518 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Return value */

/* 2520 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2522 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2524 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTypeFromTypeDef */

/* 2526 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2528 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2532 */	NdrFcShort( 0xd ),	/* 13 */
/* 2534 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 2536 */	NdrFcShort( 0x40 ),	/* 64 */
/* 2538 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2540 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x5,		/* 5 */

	/* Parameter ulAppDomainID */

/* 2542 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2544 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2546 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter guidModule */

/* 2548 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 2550 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2552 */	NdrFcShort( 0x9a ),	/* Type Offset=154 */

	/* Parameter tokClass */

/* 2554 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2556 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2558 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppType */

/* 2560 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2562 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2564 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Return value */

/* 2566 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2568 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 2570 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumCodeContexts */

/* 2572 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2574 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2578 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2580 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2582 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2584 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2586 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter rgpAddresses */

/* 2588 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2590 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2592 */	NdrFcShort( 0x1fc ),	/* Type Offset=508 */

	/* Parameter celtAddresses */

/* 2594 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2596 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2598 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppEnum */

/* 2600 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2602 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2604 */	NdrFcShort( 0x20e ),	/* Type Offset=526 */

	/* Return value */

/* 2606 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2608 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2610 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAddress */

/* 2612 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2614 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2618 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2620 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2622 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2624 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2626 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pAddress */

/* 2628 */	NdrFcShort( 0xe113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=56 */
/* 2630 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2632 */	NdrFcShort( 0x2aa ),	/* Type Offset=682 */

	/* Return value */

/* 2634 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2636 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2638 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 2640 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2642 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2646 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2648 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2650 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2652 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2654 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 2656 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2658 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2660 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 2662 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 2664 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2666 */	NdrFcShort( 0x2c2 ),	/* Type Offset=706 */

	/* Parameter pceltFetched */

/* 2668 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2670 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2672 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2674 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2676 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2678 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Skip */


	/* Procedure Skip */

/* 2680 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2682 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2686 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2688 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2690 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2692 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2694 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter celt */


	/* Parameter celt */

/* 2696 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2698 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2700 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 2702 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2704 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2706 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Reset */


	/* Procedure Reset */

/* 2708 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2710 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2714 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2716 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2718 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2720 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2722 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */


	/* Return value */

/* 2724 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2726 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2728 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 2730 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2732 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2736 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2738 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2740 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2742 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2744 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 2746 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2748 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2750 */	NdrFcShort( 0xaa ),	/* Type Offset=170 */

	/* Return value */

/* 2752 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2754 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2756 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCount */


	/* Procedure GetCount */

/* 2758 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2760 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2764 */	NdrFcShort( 0x7 ),	/* 7 */
/* 2766 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2768 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2770 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2772 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pcelt */


	/* Parameter pcelt */

/* 2774 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2776 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2778 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 2780 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2782 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2784 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 2786 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2788 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2792 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2794 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2796 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2798 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2800 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 2802 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2804 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2806 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 2808 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 2810 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2812 */	NdrFcShort( 0x2d8 ),	/* Type Offset=728 */

	/* Parameter pceltFetched */

/* 2814 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2816 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2818 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2820 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2822 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2824 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 2826 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2828 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2832 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2834 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2836 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2838 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2840 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 2842 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2844 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2846 */	NdrFcShort( 0x64 ),	/* Type Offset=100 */

	/* Return value */

/* 2848 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2850 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2852 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsCustomAttributeDefined */

/* 2854 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 2856 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2860 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2862 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2864 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2866 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2868 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pszCustomAttributeName */

/* 2870 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2872 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2874 */	NdrFcShort( 0xa6 ),	/* Type Offset=166 */

	/* Return value */

/* 2876 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2878 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2880 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCustomAttributeByName */

/* 2882 */	0x33,		/* FC_AUTO_HANDLE */
			0x6d,		/* Old Flags:  full ptr, object, Oi2 */
/* 2884 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2888 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2890 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2892 */	NdrFcShort( 0x1c ),	/* 28 */
/* 2894 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2896 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pszCustomAttributeName */

/* 2898 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2900 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2902 */	NdrFcShort( 0xa6 ),	/* Type Offset=166 */

	/* Parameter ppBlob */

/* 2904 */	NdrFcShort( 0x11b ),	/* Flags:  must size, must free, in, out, simple ref, */
/* 2906 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2908 */	NdrFcShort( 0x2ee ),	/* Type Offset=750 */

	/* Parameter pdwLen */

/* 2910 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2912 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2914 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2916 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2918 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2920 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  4 */	NdrFcLong( 0x83919262 ),	/* -2087611806 */
/*  8 */	NdrFcShort( 0xacd6 ),	/* -21290 */
/* 10 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 12 */	0x90,		/* 144 */
			0x28,		/* 40 */
/* 14 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 16 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 18 */	0x2,		/* 2 */
			0xa1,		/* 161 */
/* 20 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 22 */	NdrFcLong( 0xc2e34ebb ),	/* -1025290565 */
/* 26 */	NdrFcShort( 0x8b9d ),	/* -29795 */
/* 28 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 30 */	0x90,		/* 144 */
			0x14,		/* 20 */
/* 32 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 34 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 36 */	0x83,		/* 131 */
			0x38,		/* 56 */
/* 38 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 40 */	NdrFcShort( 0x2 ),	/* Offset= 2 (42) */
/* 42 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 44 */	NdrFcLong( 0xc2e34eb2 ),	/* -1025290574 */
/* 48 */	NdrFcShort( 0x8b9d ),	/* -29795 */
/* 50 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 52 */	0x90,		/* 144 */
			0x14,		/* 20 */
/* 54 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 56 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 58 */	0x83,		/* 131 */
			0x38,		/* 56 */
/* 60 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 62 */	NdrFcShort( 0x2 ),	/* Offset= 2 (64) */
/* 64 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 66 */	NdrFcLong( 0xc2e34eb1 ),	/* -1025290575 */
/* 70 */	NdrFcShort( 0x8b9d ),	/* -29795 */
/* 72 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 74 */	0x90,		/* 144 */
			0x14,		/* 20 */
/* 76 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 78 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 80 */	0x83,		/* 131 */
			0x38,		/* 56 */
/* 82 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 84 */	NdrFcLong( 0xbdde0eee ),	/* -1109520658 */
/* 88 */	NdrFcShort( 0x3b8d ),	/* 15245 */
/* 90 */	NdrFcShort( 0x4c82 ),	/* 19586 */
/* 92 */	0xb5,		/* 181 */
			0x29,		/* 41 */
/* 94 */	0x33,		/* 51 */
			0xf1,		/* 241 */
/* 96 */	0x6b,		/* 107 */
			0x42,		/* 66 */
/* 98 */	0x83,		/* 131 */
			0x2e,		/* 46 */
/* 100 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 102 */	NdrFcShort( 0x2 ),	/* Offset= 2 (104) */
/* 104 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 106 */	NdrFcLong( 0xc2e34ebd ),	/* -1025290563 */
/* 110 */	NdrFcShort( 0x8b9d ),	/* -29795 */
/* 112 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 114 */	0x90,		/* 144 */
			0x14,		/* 20 */
/* 116 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 118 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 120 */	0x83,		/* 131 */
			0x38,		/* 56 */
/* 122 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 124 */	NdrFcLong( 0x931516ad ),	/* -1827334483 */
/* 128 */	NdrFcShort( 0xb600 ),	/* -18944 */
/* 130 */	NdrFcShort( 0x419c ),	/* 16796 */
/* 132 */	0x88,		/* 136 */
			0xfc,		/* 252 */
/* 134 */	0xdc,		/* 220 */
			0xf5,		/* 245 */
/* 136 */	0x18,		/* 24 */
			0x3b,		/* 59 */
/* 138 */	0x5f,		/* 95 */
			0xa9,		/* 169 */
/* 140 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 142 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (122) */
/* 144 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 146 */	NdrFcShort( 0x8 ),	/* Offset= 8 (154) */
/* 148 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 150 */	NdrFcShort( 0x8 ),	/* 8 */
/* 152 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 154 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 156 */	NdrFcShort( 0x10 ),	/* 16 */
/* 158 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 160 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 162 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (148) */
			0x5b,		/* FC_END */
/* 166 */	
			0x14, 0x8,	/* FC_FP [simple_pointer] */
/* 168 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 170 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 172 */	NdrFcShort( 0x2 ),	/* Offset= 2 (174) */
/* 174 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 176 */	NdrFcLong( 0xc2e34ebc ),	/* -1025290564 */
/* 180 */	NdrFcShort( 0x8b9d ),	/* -29795 */
/* 182 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 184 */	0x90,		/* 144 */
			0x14,		/* 20 */
/* 186 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 188 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 190 */	0x83,		/* 131 */
			0x38,		/* 56 */
/* 192 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 194 */	NdrFcShort( 0x2 ),	/* Offset= 2 (196) */
/* 196 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 198 */	NdrFcLong( 0xc2e34eb5 ),	/* -1025290571 */
/* 202 */	NdrFcShort( 0x8b9d ),	/* -29795 */
/* 204 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 206 */	0x90,		/* 144 */
			0x14,		/* 20 */
/* 208 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 210 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 212 */	0x83,		/* 131 */
			0x38,		/* 56 */
/* 214 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 216 */	NdrFcShort( 0xffffff3c ),	/* Offset= -196 (20) */
/* 218 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 220 */	NdrFcLong( 0x0 ),	/* 0 */
/* 224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 228 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 230 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 232 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 234 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 236 */	
			0x12, 0x0,	/* FC_UP */
/* 238 */	NdrFcShort( 0xc ),	/* Offset= 12 (250) */
/* 240 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 242 */	NdrFcShort( 0x2 ),	/* 2 */
/* 244 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 246 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 248 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 250 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 252 */	NdrFcShort( 0x8 ),	/* 8 */
/* 254 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (240) */
/* 256 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 258 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 260 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0x4 ),	/* 4 */
/* 266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 268 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (236) */
/* 270 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 272 */	NdrFcLong( 0xc ),	/* 12 */
/* 276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 278 */	NdrFcShort( 0x0 ),	/* 0 */
/* 280 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 282 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 284 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 286 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 288 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 290 */	NdrFcShort( 0xffffff1e ),	/* Offset= -226 (64) */
/* 292 */	
			0x11, 0x0,	/* FC_RP */
/* 294 */	NdrFcShort( 0x2 ),	/* Offset= 2 (296) */
/* 296 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 298 */	NdrFcShort( 0x1 ),	/* 1 */
/* 300 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 302 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 304 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 306 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 308 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 310 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 312 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 314 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 316 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 318 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 320 */	NdrFcShort( 0x1 ),	/* 1 */
/* 322 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 324 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 326 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 328 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 330 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 332 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 334 */	NdrFcShort( 0xffffff8c ),	/* Offset= -116 (218) */
/* 336 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 338 */	NdrFcShort( 0x6 ),	/* Offset= 6 (344) */
/* 340 */	
			0x13, 0x0,	/* FC_OP */
/* 342 */	NdrFcShort( 0xffffffa4 ),	/* Offset= -92 (250) */
/* 344 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
/* 348 */	NdrFcShort( 0x4 ),	/* 4 */
/* 350 */	NdrFcShort( 0x0 ),	/* 0 */
/* 352 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (340) */
/* 354 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 356 */	NdrFcShort( 0x4 ),	/* 4 */
/* 358 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 360 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 362 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 364 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 366 */	NdrFcShort( 0xffffffa0 ),	/* Offset= -96 (270) */
/* 368 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 370 */	NdrFcShort( 0x2 ),	/* Offset= 2 (372) */
/* 372 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 374 */	NdrFcShort( 0x14 ),	/* 20 */
/* 376 */	NdrFcShort( 0x0 ),	/* 0 */
/* 378 */	NdrFcShort( 0x0 ),	/* Offset= 0 (378) */
/* 380 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 382 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd9 ),	/* Offset= -39 (344) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 386 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd5 ),	/* Offset= -43 (344) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 390 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd1 ),	/* Offset= -47 (344) */
			0x8,		/* FC_LONG */
/* 394 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 396 */	
			0x11, 0x0,	/* FC_RP */
/* 398 */	NdrFcShort( 0xffffff0c ),	/* Offset= -244 (154) */
/* 400 */	
			0x11, 0x0,	/* FC_RP */
/* 402 */	NdrFcShort( 0x2 ),	/* Offset= 2 (404) */
/* 404 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 406 */	NdrFcShort( 0x4 ),	/* 4 */
/* 408 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 410 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 412 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 414 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 416 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 418 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x4a,		/* FC_VARIABLE_OFFSET */
/* 420 */	NdrFcShort( 0x4 ),	/* 4 */
/* 422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 424 */	NdrFcShort( 0x1 ),	/* 1 */
/* 426 */	NdrFcShort( 0x0 ),	/* 0 */
/* 428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 430 */	0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 432 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 434 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 436 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 438 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 440 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 442 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 444 */	NdrFcShort( 0x2 ),	/* Offset= 2 (446) */
/* 446 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 448 */	NdrFcShort( 0x18 ),	/* 24 */
/* 450 */	NdrFcShort( 0x2 ),	/* 2 */
/* 452 */	NdrFcLong( 0x1 ),	/* 1 */
/* 456 */	NdrFcShort( 0xa ),	/* Offset= 10 (466) */
/* 458 */	NdrFcLong( 0x2 ),	/* 2 */
/* 462 */	NdrFcShort( 0x4 ),	/* Offset= 4 (466) */
/* 464 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 466 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 468 */	NdrFcShort( 0x18 ),	/* 24 */
/* 470 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 472 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffec1 ),	/* Offset= -319 (154) */
			0x8,		/* FC_LONG */
/* 476 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 478 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 480 */	NdrFcShort( 0x2 ),	/* Offset= 2 (482) */
/* 482 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 484 */	NdrFcLong( 0xc2e34eb4 ),	/* -1025290572 */
/* 488 */	NdrFcShort( 0x8b9d ),	/* -29795 */
/* 490 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 492 */	0x90,		/* 144 */
			0x14,		/* 20 */
/* 494 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 496 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 498 */	0x83,		/* 131 */
			0x38,		/* 56 */
/* 500 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 502 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 504 */	
			0x11, 0x0,	/* FC_RP */
/* 506 */	NdrFcShort( 0x2 ),	/* Offset= 2 (508) */
/* 508 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 514 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 516 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 518 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 520 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 522 */	NdrFcShort( 0xfffffe0a ),	/* Offset= -502 (20) */
/* 524 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 526 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 528 */	NdrFcShort( 0x2 ),	/* Offset= 2 (530) */
/* 530 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 532 */	NdrFcLong( 0xad47a80b ),	/* -1387812853 */
/* 536 */	NdrFcShort( 0xeda7 ),	/* -4697 */
/* 538 */	NdrFcShort( 0x459e ),	/* 17822 */
/* 540 */	0xaf,		/* 175 */
			0x82,		/* 130 */
/* 542 */	0x64,		/* 100 */
			0x7c,		/* 124 */
/* 544 */	0xc9,		/* 201 */
			0xfb,		/* 251 */
/* 546 */	0xaa,		/* 170 */
			0x50,		/* 80 */
/* 548 */	0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 550 */	NdrFcShort( 0x84 ),	/* Offset= 132 (682) */
/* 552 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x89,		/* 137 */
/* 554 */	NdrFcShort( 0x18 ),	/* 24 */
/* 556 */	NdrFcShort( 0x9 ),	/* 9 */
/* 558 */	NdrFcLong( 0x1 ),	/* 1 */
/* 562 */	NdrFcShort( 0x34 ),	/* Offset= 52 (614) */
/* 564 */	NdrFcLong( 0x2 ),	/* 2 */
/* 568 */	NdrFcShort( 0x34 ),	/* Offset= 52 (620) */
/* 570 */	NdrFcLong( 0x5 ),	/* 5 */
/* 574 */	NdrFcShort( 0x36 ),	/* Offset= 54 (628) */
/* 576 */	NdrFcLong( 0x10 ),	/* 16 */
/* 580 */	NdrFcShort( 0x28 ),	/* Offset= 40 (620) */
/* 582 */	NdrFcLong( 0x11 ),	/* 17 */
/* 586 */	NdrFcShort( 0x1c ),	/* Offset= 28 (614) */
/* 588 */	NdrFcLong( 0x12 ),	/* 18 */
/* 592 */	NdrFcShort( 0x2a ),	/* Offset= 42 (634) */
/* 594 */	NdrFcLong( 0x13 ),	/* 19 */
/* 598 */	NdrFcShort( 0x16 ),	/* Offset= 22 (620) */
/* 600 */	NdrFcLong( 0x14 ),	/* 20 */
/* 604 */	NdrFcShort( 0x2e ),	/* Offset= 46 (650) */
/* 606 */	NdrFcLong( 0x15 ),	/* 21 */
/* 610 */	NdrFcShort( 0x36 ),	/* Offset= 54 (664) */
/* 612 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 614 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 616 */	NdrFcShort( 0x4 ),	/* 4 */
/* 618 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 620 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 622 */	NdrFcShort( 0xc ),	/* 12 */
/* 624 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 626 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 628 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 630 */	NdrFcShort( 0x8 ),	/* 8 */
/* 632 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 634 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 636 */	NdrFcShort( 0xc ),	/* 12 */
/* 638 */	NdrFcShort( 0x0 ),	/* 0 */
/* 640 */	NdrFcShort( 0xa ),	/* Offset= 10 (650) */
/* 642 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 644 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe55 ),	/* Offset= -427 (218) */
			0x8,		/* FC_LONG */
/* 648 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 650 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 652 */	NdrFcShort( 0x8 ),	/* 8 */
/* 654 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 656 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 658 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 660 */	NdrFcShort( 0xa ),	/* 10 */
/* 662 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 664 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 666 */	NdrFcShort( 0x18 ),	/* 24 */
/* 668 */	NdrFcShort( 0x0 ),	/* 0 */
/* 670 */	NdrFcShort( 0x0 ),	/* Offset= 0 (670) */
/* 672 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 674 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 676 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffed ),	/* Offset= -19 (658) */
			0x3e,		/* FC_STRUCTPAD2 */
/* 680 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 682 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 684 */	NdrFcShort( 0x38 ),	/* 56 */
/* 686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 688 */	NdrFcShort( 0x0 ),	/* Offset= 0 (688) */
/* 690 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 692 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffde5 ),	/* Offset= -539 (154) */
			0x8,		/* FC_LONG */
/* 696 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 698 */	NdrFcShort( 0xffffff6e ),	/* Offset= -146 (552) */
/* 700 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 702 */	
			0x11, 0x0,	/* FC_RP */
/* 704 */	NdrFcShort( 0x2 ),	/* Offset= 2 (706) */
/* 706 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 708 */	NdrFcShort( 0x0 ),	/* 0 */
/* 710 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 712 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 714 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 716 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 718 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 720 */	NdrFcShort( 0xfffffd70 ),	/* Offset= -656 (64) */
/* 722 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 724 */	
			0x11, 0x0,	/* FC_RP */
/* 726 */	NdrFcShort( 0x2 ),	/* Offset= 2 (728) */
/* 728 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 730 */	NdrFcShort( 0x0 ),	/* 0 */
/* 732 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 734 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 736 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 738 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 740 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 742 */	NdrFcShort( 0xfffffd2e ),	/* Offset= -722 (20) */
/* 744 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 746 */	
			0x11, 0x0,	/* FC_RP */
/* 748 */	NdrFcShort( 0x2 ),	/* Offset= 2 (750) */
/* 750 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 752 */	NdrFcShort( 0x1 ),	/* 1 */
/* 754 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 756 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 758 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 760 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 762 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };



/* Standard interface: __MIDL_itf_sh_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDebugSymbolProvider, ver. 0.0,
   GUID={0xc2e34eae,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugSymbolProvider_FormatStringOffsetTable[] =
    {
    0,
    28,
    50,
    84,
    124,
    170,
    216,
    250,
    290,
    318,
    358,
    398,
    432,
    472
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugSymbolProvider_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugSymbolProvider_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugSymbolProvider_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugSymbolProvider_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(17) _IDebugSymbolProviderProxyVtbl = 
{
    &IDebugSymbolProvider_ProxyInfo,
    &IID_IDebugSymbolProvider,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::Initialize */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::Uninitialize */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetContainerField */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetField */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetAddressesFromPosition */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetAddressesFromContext */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetContextFromAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetLanguage */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetGlobalContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetMethodFieldsByName */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetClassTypeByName */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetNamespacesUsedAtAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetTypeByName */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetNextAddress */
};

const CInterfaceStubVtbl _IDebugSymbolProviderStubVtbl =
{
    &IID_IDebugSymbolProvider,
    &IDebugSymbolProvider_ServerInfo,
    17,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugComPlusSymbolProvider, ver. 0.0,
   GUID={0xc2e34eaf,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugComPlusSymbolProvider_FormatStringOffsetTable[] =
    {
    0,
    28,
    50,
    84,
    124,
    170,
    216,
    250,
    290,
    318,
    358,
    398,
    432,
    472,
    512,
    570,
    604,
    644,
    678,
    718,
    758,
    798,
    856,
    902,
    966,
    1006,
    1040,
    1092,
    1132,
    1178,
    1218,
    1246,
    1274,
    1314,
    1342,
    1394
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugComPlusSymbolProvider_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugComPlusSymbolProvider_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugComPlusSymbolProvider_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugComPlusSymbolProvider_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(39) _IDebugComPlusSymbolProviderProxyVtbl = 
{
    &IDebugComPlusSymbolProvider_ProxyInfo,
    &IID_IDebugComPlusSymbolProvider,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::Initialize */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::Uninitialize */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetContainerField */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetField */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetAddressesFromPosition */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetAddressesFromContext */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetContextFromAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetLanguage */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetGlobalContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetMethodFieldsByName */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetClassTypeByName */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetNamespacesUsedAtAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetTypeByName */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetNextAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::LoadSymbols */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::UnloadSymbols */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::GetEntryPoint */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::GetTypeFromAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::UpdateSymbols */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::CreateTypeFromPrimitive */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::GetFunctionLineOffset */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::GetAddressesInModuleFromPosition */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::GetArrayTypeFromAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::GetSymAttribute */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::ReplaceSymbols */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::AreSymbolsLoaded */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::LoadSymbolsFromStream */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::GetSymUnmanagedReader */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::GetAttributedClassesinModule */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::GetAttributedClassesForLanguage */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::IsHiddenCode */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::IsFunctionDeleted */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::GetNameFromToken */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::IsFunctionStale */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::GetLocalVariablelayout */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSymbolProvider::GetAssemblyName */
};

const CInterfaceStubVtbl _IDebugComPlusSymbolProviderStubVtbl =
{
    &IID_IDebugComPlusSymbolProvider,
    &IDebugComPlusSymbolProvider_ServerInfo,
    39,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugNativeSymbolProvider, ver. 0.0,
   GUID={0xc2e34eb0,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugNativeSymbolProvider_FormatStringOffsetTable[] =
    {
    0,
    28,
    50,
    84,
    124,
    170,
    216,
    250,
    290,
    318,
    358,
    398,
    432,
    472,
    1434
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugNativeSymbolProvider_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugNativeSymbolProvider_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugNativeSymbolProvider_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugNativeSymbolProvider_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(18) _IDebugNativeSymbolProviderProxyVtbl = 
{
    &IDebugNativeSymbolProvider_ProxyInfo,
    &IID_IDebugNativeSymbolProvider,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::Initialize */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::Uninitialize */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetContainerField */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetField */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetAddressesFromPosition */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetAddressesFromContext */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetContextFromAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetLanguage */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetGlobalContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetMethodFieldsByName */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetClassTypeByName */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetNamespacesUsedAtAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetTypeByName */ ,
    (void *) (INT_PTR) -1 /* IDebugSymbolProvider::GetNextAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugNativeSymbolProvider::LoadSymbols */
};

const CInterfaceStubVtbl _IDebugNativeSymbolProviderStubVtbl =
{
    &IID_IDebugNativeSymbolProvider,
    &IDebugNativeSymbolProvider_ServerInfo,
    18,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugField, ver. 0.0,
   GUID={0xc2e34eb1,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugField_FormatStringOffsetTable[] =
    {
    1462,
    1496,
    1524,
    1552,
    1580,
    1608,
    1636,
    1676,
    1704
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugField_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugField_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugField_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugField_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(12) _IDebugFieldProxyVtbl = 
{
    &IDebugField_ProxyInfo,
    &IID_IDebugField,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugField::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetKind */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetType */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetSize */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetExtendedInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::Equal */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetTypeInfo */
};

const CInterfaceStubVtbl _IDebugFieldStubVtbl =
{
    &IID_IDebugField,
    &IDebugField_ServerInfo,
    12,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugContainerField, ver. 0.0,
   GUID={0xc2e34eb2,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugContainerField_FormatStringOffsetTable[] =
    {
    1462,
    1496,
    1524,
    1552,
    1580,
    1608,
    1636,
    1676,
    1704,
    1732
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugContainerField_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugContainerField_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugContainerField_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugContainerField_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(13) _IDebugContainerFieldProxyVtbl = 
{
    &IDebugContainerField_ProxyInfo,
    &IID_IDebugContainerField,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugField::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetKind */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetType */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetSize */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetExtendedInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::Equal */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetTypeInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugContainerField::EnumFields */
};

const CInterfaceStubVtbl _IDebugContainerFieldStubVtbl =
{
    &IID_IDebugContainerField,
    &IDebugContainerField_ServerInfo,
    13,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugMethodField, ver. 0.0,
   GUID={0xc2e34eb4,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugMethodField_FormatStringOffsetTable[] =
    {
    1462,
    1496,
    1524,
    1552,
    1580,
    1608,
    1636,
    1676,
    1704,
    1732,
    1784,
    1812,
    1840,
    1874,
    1908,
    1936,
    1964,
    1992
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugMethodField_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugMethodField_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugMethodField_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugMethodField_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(21) _IDebugMethodFieldProxyVtbl = 
{
    &IDebugMethodField_ProxyInfo,
    &IID_IDebugMethodField,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugField::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetKind */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetType */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetSize */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetExtendedInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::Equal */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetTypeInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugContainerField::EnumFields */ ,
    (void *) (INT_PTR) -1 /* IDebugMethodField::EnumParameters */ ,
    (void *) (INT_PTR) -1 /* IDebugMethodField::GetThis */ ,
    (void *) (INT_PTR) -1 /* IDebugMethodField::EnumAllLocals */ ,
    (void *) (INT_PTR) -1 /* IDebugMethodField::EnumLocals */ ,
    (void *) (INT_PTR) -1 /* IDebugMethodField::IsCustomAttributeDefined */ ,
    (void *) (INT_PTR) -1 /* IDebugMethodField::EnumStaticLocals */ ,
    (void *) (INT_PTR) -1 /* IDebugMethodField::GetGlobalContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugMethodField::EnumArguments */
};

const CInterfaceStubVtbl _IDebugMethodFieldStubVtbl =
{
    &IID_IDebugMethodField,
    &IDebugMethodField_ServerInfo,
    21,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_sh_0379, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDebugClassField, ver. 0.0,
   GUID={0xc2e34eb5,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugClassField_FormatStringOffsetTable[] =
    {
    1462,
    1496,
    1524,
    1552,
    1580,
    1608,
    1636,
    1676,
    1704,
    1732,
    1784,
    2020,
    2048,
    2076,
    2104,
    2132,
    2166,
    1992
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugClassField_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugClassField_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugClassField_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugClassField_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(21) _IDebugClassFieldProxyVtbl = 
{
    &IDebugClassField_ProxyInfo,
    &IID_IDebugClassField,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugField::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetKind */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetType */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetSize */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetExtendedInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::Equal */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetTypeInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugContainerField::EnumFields */ ,
    (void *) (INT_PTR) -1 /* IDebugClassField::EnumBaseClasses */ ,
    (void *) (INT_PTR) -1 /* IDebugClassField::DoesInterfaceExist */ ,
    (void *) (INT_PTR) -1 /* IDebugClassField::EnumNestedClasses */ ,
    (void *) (INT_PTR) -1 /* IDebugClassField::GetEnclosingClass */ ,
    (void *) (INT_PTR) -1 /* IDebugClassField::EnumInterfacesImplemented */ ,
    (void *) (INT_PTR) -1 /* IDebugClassField::EnumConstructors */ ,
    (void *) (INT_PTR) -1 /* IDebugClassField::GetDefaultIndexer */ ,
    (void *) (INT_PTR) -1 /* IDebugClassField::EnumNestedEnums */
};

const CInterfaceStubVtbl _IDebugClassFieldStubVtbl =
{
    &IID_IDebugClassField,
    &IDebugClassField_ServerInfo,
    21,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugPropertyField, ver. 0.0,
   GUID={0xc2e34eb6,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugPropertyField_FormatStringOffsetTable[] =
    {
    1462,
    1496,
    1524,
    1552,
    1580,
    1608,
    1636,
    1676,
    1704,
    1732,
    2194,
    2222
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugPropertyField_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugPropertyField_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugPropertyField_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugPropertyField_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(15) _IDebugPropertyFieldProxyVtbl = 
{
    &IDebugPropertyField_ProxyInfo,
    &IID_IDebugPropertyField,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugField::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetKind */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetType */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetSize */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetExtendedInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::Equal */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetTypeInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugContainerField::EnumFields */ ,
    (void *) (INT_PTR) -1 /* IDebugPropertyField::GetPropertyGetter */ ,
    (void *) (INT_PTR) -1 /* IDebugPropertyField::GetPropertySetter */
};

const CInterfaceStubVtbl _IDebugPropertyFieldStubVtbl =
{
    &IID_IDebugPropertyField,
    &IDebugPropertyField_ServerInfo,
    15,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugArrayField, ver. 0.0,
   GUID={0xc2e34eb7,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugArrayField_FormatStringOffsetTable[] =
    {
    1462,
    1496,
    1524,
    1552,
    1580,
    1608,
    1636,
    1676,
    1704,
    1732,
    2250,
    2278,
    2306
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugArrayField_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugArrayField_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugArrayField_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugArrayField_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(16) _IDebugArrayFieldProxyVtbl = 
{
    &IDebugArrayField_ProxyInfo,
    &IID_IDebugArrayField,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugField::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetKind */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetType */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetSize */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetExtendedInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::Equal */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetTypeInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugContainerField::EnumFields */ ,
    (void *) (INT_PTR) -1 /* IDebugArrayField::GetNumberOfElements */ ,
    (void *) (INT_PTR) -1 /* IDebugArrayField::GetElementType */ ,
    (void *) (INT_PTR) -1 /* IDebugArrayField::GetRank */
};

const CInterfaceStubVtbl _IDebugArrayFieldStubVtbl =
{
    &IID_IDebugArrayField,
    &IDebugArrayField_ServerInfo,
    16,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugPointerField, ver. 0.0,
   GUID={0xc2e34eb8,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugPointerField_FormatStringOffsetTable[] =
    {
    1462,
    1496,
    1524,
    1552,
    1580,
    1608,
    1636,
    1676,
    1704,
    1732,
    2334
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugPointerField_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugPointerField_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugPointerField_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugPointerField_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(14) _IDebugPointerFieldProxyVtbl = 
{
    &IDebugPointerField_ProxyInfo,
    &IID_IDebugPointerField,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugField::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetKind */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetType */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetSize */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetExtendedInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::Equal */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetTypeInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugContainerField::EnumFields */ ,
    (void *) (INT_PTR) -1 /* IDebugPointerField::GetDereferencedField */
};

const CInterfaceStubVtbl _IDebugPointerFieldStubVtbl =
{
    &IID_IDebugPointerField,
    &IDebugPointerField_ServerInfo,
    14,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugEnumField, ver. 0.0,
   GUID={0xc2e34eb9,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugEnumField_FormatStringOffsetTable[] =
    {
    1462,
    1496,
    1524,
    1552,
    1580,
    1608,
    1636,
    1676,
    1704,
    1732,
    2334,
    2362,
    2396,
    2430
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugEnumField_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugEnumField_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugEnumField_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugEnumField_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(17) _IDebugEnumFieldProxyVtbl = 
{
    &IDebugEnumField_ProxyInfo,
    &IID_IDebugEnumField,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugField::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetKind */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetType */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetSize */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetExtendedInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::Equal */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetTypeInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugContainerField::EnumFields */ ,
    (void *) (INT_PTR) -1 /* IDebugEnumField::GetUnderlyingSymbol */ ,
    (void *) (INT_PTR) -1 /* IDebugEnumField::GetStringFromValue */ ,
    (void *) (INT_PTR) -1 /* IDebugEnumField::GetValueFromString */ ,
    (void *) (INT_PTR) -1 /* IDebugEnumField::GetValueFromStringCaseInsensitive */
};

const CInterfaceStubVtbl _IDebugEnumFieldStubVtbl =
{
    &IID_IDebugEnumField,
    &IDebugEnumField_ServerInfo,
    17,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugBitField, ver. 0.0,
   GUID={0xc2e34eba,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugBitField_FormatStringOffsetTable[] =
    {
    1462,
    1496,
    1524,
    1552,
    1580,
    1608,
    1636,
    1676,
    1704,
    2464
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugBitField_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugBitField_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugBitField_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugBitField_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(13) _IDebugBitFieldProxyVtbl = 
{
    &IDebugBitField_ProxyInfo,
    &IID_IDebugBitField,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugField::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetKind */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetType */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetSize */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetExtendedInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::Equal */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetTypeInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugBitField::GetStart */
};

const CInterfaceStubVtbl _IDebugBitFieldStubVtbl =
{
    &IID_IDebugBitField,
    &IDebugBitField_ServerInfo,
    13,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugDynamicField, ver. 0.0,
   GUID={0xB5A2A5EA,0xD5AB,0x11d2,{0x90,0x33,0x00,0xC0,0x4F,0xA3,0x02,0xA1}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugDynamicField_FormatStringOffsetTable[] =
    {
    1462,
    1496,
    1524,
    1552,
    1580,
    1608,
    1636,
    1676,
    1704,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugDynamicField_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugDynamicField_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugDynamicField_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugDynamicField_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(12) _IDebugDynamicFieldProxyVtbl = 
{
    0,
    &IID_IDebugDynamicField,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* forced delegation IDebugField::GetInfo */ ,
    0 /* forced delegation IDebugField::GetKind */ ,
    0 /* forced delegation IDebugField::GetType */ ,
    0 /* forced delegation IDebugField::GetContainer */ ,
    0 /* forced delegation IDebugField::GetAddress */ ,
    0 /* forced delegation IDebugField::GetSize */ ,
    0 /* forced delegation IDebugField::GetExtendedInfo */ ,
    0 /* forced delegation IDebugField::Equal */ ,
    0 /* forced delegation IDebugField::GetTypeInfo */
};


static const PRPC_STUB_FUNCTION IDebugDynamicField_table[] =
{
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IDebugDynamicFieldStubVtbl =
{
    &IID_IDebugDynamicField,
    &IDebugDynamicField_ServerInfo,
    12,
    &IDebugDynamicField_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Object interface: IDebugDynamicFieldCOMPlus, ver. 0.0,
   GUID={0xB5B20820,0xE233,0x11d2,{0x90,0x37,0x00,0xC0,0x4F,0xA3,0x02,0xA1}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugDynamicFieldCOMPlus_FormatStringOffsetTable[] =
    {
    1462,
    1496,
    1524,
    1552,
    1580,
    1608,
    1636,
    1676,
    1704,
    2492,
    2526
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugDynamicFieldCOMPlus_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugDynamicFieldCOMPlus_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugDynamicFieldCOMPlus_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugDynamicFieldCOMPlus_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(14) _IDebugDynamicFieldCOMPlusProxyVtbl = 
{
    &IDebugDynamicFieldCOMPlus_ProxyInfo,
    &IID_IDebugDynamicFieldCOMPlus,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugField::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetKind */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetType */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetContainer */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetAddress */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetSize */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetExtendedInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugField::Equal */ ,
    (void *) (INT_PTR) -1 /* IDebugField::GetTypeInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugDynamicFieldCOMPlus::GetTypeFromPrimitive */ ,
    (void *) (INT_PTR) -1 /* IDebugDynamicFieldCOMPlus::GetTypeFromTypeDef */
};

const CInterfaceStubVtbl _IDebugDynamicFieldCOMPlusStubVtbl =
{
    &IID_IDebugDynamicFieldCOMPlus,
    &IDebugDynamicFieldCOMPlus_ServerInfo,
    14,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugEngineSymbolProviderServices, ver. 0.0,
   GUID={0x83919262,0xACD6,0x11d2,{0x90,0x28,0x00,0xC0,0x4F,0xA3,0x02,0xA1}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugEngineSymbolProviderServices_FormatStringOffsetTable[] =
    {
    2572
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugEngineSymbolProviderServices_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugEngineSymbolProviderServices_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugEngineSymbolProviderServices_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugEngineSymbolProviderServices_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugEngineSymbolProviderServicesProxyVtbl = 
{
    &IDebugEngineSymbolProviderServices_ProxyInfo,
    &IID_IDebugEngineSymbolProviderServices,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugEngineSymbolProviderServices::EnumCodeContexts */
};

const CInterfaceStubVtbl _IDebugEngineSymbolProviderServicesStubVtbl =
{
    &IID_IDebugEngineSymbolProviderServices,
    &IDebugEngineSymbolProviderServices_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugAddress, ver. 0.0,
   GUID={0xc2e34ebb,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugAddress_FormatStringOffsetTable[] =
    {
    2612
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugAddress_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugAddress_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugAddress_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugAddress_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugAddressProxyVtbl = 
{
    &IDebugAddress_ProxyInfo,
    &IID_IDebugAddress,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugAddress::GetAddress */
};

const CInterfaceStubVtbl _IDebugAddressStubVtbl =
{
    &IID_IDebugAddress,
    &IDebugAddress_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugFields, ver. 0.0,
   GUID={0xc2e34ebc,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugFields_FormatStringOffsetTable[] =
    {
    2640,
    2680,
    2708,
    2730,
    2758
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugFields_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugFields_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugFields_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugFields_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugFieldsProxyVtbl = 
{
    &IEnumDebugFields_ProxyInfo,
    &IID_IEnumDebugFields,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugFields::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugFields::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugFields::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugFields::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugFields::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugFieldsStubVtbl =
{
    &IID_IEnumDebugFields,
    &IEnumDebugFields_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugAddresses, ver. 0.0,
   GUID={0xc2e34ebd,0x8b9d,0x11d2,{0x90,0x14,0x00,0xc0,0x4f,0xa3,0x83,0x38}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugAddresses_FormatStringOffsetTable[] =
    {
    2786,
    2680,
    2708,
    2826,
    2758
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugAddresses_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugAddresses_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugAddresses_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugAddresses_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugAddressesProxyVtbl = 
{
    &IEnumDebugAddresses_ProxyInfo,
    &IID_IEnumDebugAddresses,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugAddresses::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugAddresses::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugAddresses::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugAddresses::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugAddresses::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugAddressesStubVtbl =
{
    &IID_IEnumDebugAddresses,
    &IEnumDebugAddresses_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugCustomAttributeQuery, ver. 0.0,
   GUID={0xDFD37B5A,0x1E3A,0x4f15,{0x80,0x98,0x22,0x0A,0xBA,0xDC,0x62,0x0B}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugCustomAttributeQuery_FormatStringOffsetTable[] =
    {
    2854,
    2882
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugCustomAttributeQuery_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugCustomAttributeQuery_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugCustomAttributeQuery_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugCustomAttributeQuery_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugCustomAttributeQueryProxyVtbl = 
{
    &IDebugCustomAttributeQuery_ProxyInfo,
    &IID_IDebugCustomAttributeQuery,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugCustomAttributeQuery::IsCustomAttributeDefined */ ,
    (void *) (INT_PTR) -1 /* IDebugCustomAttributeQuery::GetCustomAttributeByName */
};

const CInterfaceStubVtbl _IDebugCustomAttributeQueryStubVtbl =
{
    &IID_IDebugCustomAttributeQuery,
    &IDebugCustomAttributeQuery_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _sh_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IDebugDynamicFieldCOMPlusProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugCustomAttributeQueryProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugEngineSymbolProviderServicesProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugSymbolProviderProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugComPlusSymbolProviderProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugNativeSymbolProviderProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugFieldProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugContainerFieldProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugMethodFieldProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugClassFieldProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugPropertyFieldProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugArrayFieldProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugPointerFieldProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugEnumFieldProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugBitFieldProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugAddressProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugFieldsProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugAddressesProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugDynamicFieldProxyVtbl,
    0
};

const CInterfaceStubVtbl * _sh_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IDebugDynamicFieldCOMPlusStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugCustomAttributeQueryStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugEngineSymbolProviderServicesStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugSymbolProviderStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugComPlusSymbolProviderStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugNativeSymbolProviderStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugFieldStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugContainerFieldStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugMethodFieldStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugClassFieldStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugPropertyFieldStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugArrayFieldStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugPointerFieldStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugEnumFieldStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugBitFieldStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugAddressStubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugFieldsStubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugAddressesStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugDynamicFieldStubVtbl,
    0
};

PCInterfaceName const _sh_InterfaceNamesList[] = 
{
    "IDebugDynamicFieldCOMPlus",
    "IDebugCustomAttributeQuery",
    "IDebugEngineSymbolProviderServices",
    "IDebugSymbolProvider",
    "IDebugComPlusSymbolProvider",
    "IDebugNativeSymbolProvider",
    "IDebugField",
    "IDebugContainerField",
    "IDebugMethodField",
    "IDebugClassField",
    "IDebugPropertyField",
    "IDebugArrayField",
    "IDebugPointerField",
    "IDebugEnumField",
    "IDebugBitField",
    "IDebugAddress",
    "IEnumDebugFields",
    "IEnumDebugAddresses",
    "IDebugDynamicField",
    0
};

const IID *  _sh_BaseIIDList[] = 
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    &IID_IDebugField,   /* forced */
    0
};


#define _sh_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _sh, pIID, n)

int __stdcall _sh_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _sh, 19, 16 )
    IID_BS_LOOKUP_NEXT_TEST( _sh, 8 )
    IID_BS_LOOKUP_NEXT_TEST( _sh, 4 )
    IID_BS_LOOKUP_NEXT_TEST( _sh, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _sh, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _sh, 19, *pIndex )
    
}

const ExtendedProxyFileInfo sh_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _sh_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _sh_StubVtblList,
    (const PCInterfaceName * ) & _sh_InterfaceNamesList,
    (const IID ** ) & _sh_BaseIIDList,
    & _sh_IID_Lookup, 
    19,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\env\misc\pkgs\solution\makefile.inc ===
# Additional rules
# 
# $(TARGETPATHUI)\$(TARGETNAME)ui.dll : $(O)\solution.res
# 	@if not exist $(TARGETPATHUI) mkdir $(TARGETPATHUI)
# 	$(LINK_NAME) $(LINKER_VC6PDBS) -out:$(TARGETPATHUI)\$(TARGETNAME)ui.dll -machine:$(MACHINE_TYPE) -base:@$(COFFBASE_TXT_FILE),vsslnui -noentry -nodefaultlib -dll -subsystem:windows,4.00 $(O)\solution.res
# !if "$(BUILD_RETAIL)"=="yes"
# 	$(COPYEXE_CMD)
# !endif
# 
# $(O)\solution.res : solution.rc $(O)\solnmenu.cto $(O)\vssln.tlb spkg.rgs res\build1.bmp
# 
# $(O)\solnmenu.cto: solnmenu.ctc solnmnid.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\debugger\idl\obj\i386\enc_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:13:57 2002
 */
/* Compiler settings for enc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "enc.h"

#define TYPE_FORMAT_STRING_SIZE   1325                              
#define PROC_FORMAT_STRING_SIZE   4127                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugENC_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugENC_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugENCLineMap_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugENCLineMap_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugENCInfo2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugENCInfo2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugENCInfo2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugENCInfo2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugENCRelinkInfo2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugENCRelinkInfo2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugENCRelinkInfo2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugENCRelinkInfo2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugIDBInfo2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugIDBInfo2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugIDBInfo2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugIDBInfo2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugENCBuildInfo2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugENCBuildInfo2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugENCUpdateOnRelinkEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugENCUpdateOnRelinkEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugENCUpdateOnStaleCodeEvent2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugENCUpdateOnStaleCodeEvent2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugENCUpdate_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugENCUpdate_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugENCSnapshot2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugENCSnapshot2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugENCSnapshots2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugENCSnapshots2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IEnumDebugErrorInfos2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IEnumDebugErrorInfos2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugComPlusSnapshot2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugComPlusSnapshot2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugNativeSnapshot2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugNativeSnapshot2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugENCStackFrame2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugENCStackFrame2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugMetaDataEmit2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugMetaDataEmit2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugMetaDataDebugEmit2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugMetaDataDebugEmit2_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDebugENCStateEvents_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDebugENCStateEvents_ProxyInfo;


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute, more than 32 methods in the interface.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure HasDependentTargets */


	/* Procedure SetRegistryRoot */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pszSourcePath */


	/* Parameter in_szRegistryRoot */

/* 16 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */


	/* Return value */

/* 22 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnterDebuggingSession */

/* 28 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 30 */	NdrFcLong( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x4 ),	/* 4 */
/* 36 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
/* 42 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter in_pServiceProvider */

/* 44 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 46 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 48 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 50 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 52 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 54 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetENCProjectBuildOption */

/* 56 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 58 */	NdrFcLong( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x5 ),	/* 5 */
/* 64 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 66 */	NdrFcShort( 0x44 ),	/* 68 */
/* 68 */	NdrFcShort( 0x8 ),	/* 8 */
/* 70 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter in_guidOption */

/* 72 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 74 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 76 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter in_szOptionValue */

/* 78 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 80 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 82 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 84 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 86 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 88 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure InquireENCState */

/* 90 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 92 */	NdrFcLong( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x6 ),	/* 6 */
/* 98 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 100 */	NdrFcShort( 0x22 ),	/* 34 */
/* 102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 104 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter in_pENCSTATE */

/* 106 */	NdrFcShort( 0x2008 ),	/* Flags:  in, srv alloc size=8 */
/* 108 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 110 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Parameter fOnContinue */

/* 112 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 114 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 116 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 118 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 120 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 122 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure InquireENCRelinkState */

/* 124 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 126 */	NdrFcLong( 0x0 ),	/* 0 */
/* 130 */	NdrFcShort( 0x7 ),	/* 7 */
/* 132 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 134 */	NdrFcShort( 0x1c ),	/* 28 */
/* 136 */	NdrFcShort( 0x8 ),	/* 8 */
/* 138 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter in_pbENCRelinking */

/* 140 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 142 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 144 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 146 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 148 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 150 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure MapToEdited */

/* 152 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 154 */	NdrFcLong( 0x0 ),	/* 0 */
/* 158 */	NdrFcShort( 0x8 ),	/* 8 */
/* 160 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 162 */	NdrFcShort( 0x10 ),	/* 16 */
/* 164 */	NdrFcShort( 0x40 ),	/* 64 */
/* 166 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter in_szFile */

/* 168 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 170 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 172 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter in_LineNo */

/* 174 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 176 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter in_ColumnNo */

/* 180 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 182 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter out_pLineNo */

/* 186 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 188 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 190 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter out_pColumnNo */

/* 192 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 194 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 198 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 200 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 202 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure MapToSuperceded */

/* 204 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 206 */	NdrFcLong( 0x0 ),	/* 0 */
/* 210 */	NdrFcShort( 0x9 ),	/* 9 */
/* 212 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 214 */	NdrFcShort( 0x10 ),	/* 16 */
/* 216 */	NdrFcShort( 0x40 ),	/* 64 */
/* 218 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter in_szFile */

/* 220 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 222 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 224 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter in_LineNo */

/* 226 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 228 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 230 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter in_ColumnNo */

/* 232 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 234 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 236 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter out_pLineNo */

/* 238 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 240 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 242 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter out_pColumnNo */

/* 244 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 246 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 248 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 250 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 252 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ApplyCodeChanges */

/* 256 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 258 */	NdrFcLong( 0x0 ),	/* 0 */
/* 262 */	NdrFcShort( 0xa ),	/* 10 */
/* 264 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 266 */	NdrFcShort( 0x8 ),	/* 8 */
/* 268 */	NdrFcShort( 0x22 ),	/* 34 */
/* 270 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter in_pSession */

/* 272 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 274 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 276 */	NdrFcShort( 0x3a ),	/* Type Offset=58 */

	/* Parameter in_fOnContinue */

/* 278 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 280 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter result */

/* 284 */	NdrFcShort( 0x2010 ),	/* Flags:  out, srv alloc size=8 */
/* 286 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 288 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Return value */

/* 290 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 292 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 294 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CancelApplyCodeChanges */

/* 296 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 298 */	NdrFcLong( 0x0 ),	/* 0 */
/* 302 */	NdrFcShort( 0xb ),	/* 11 */
/* 304 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 306 */	NdrFcShort( 0x0 ),	/* 0 */
/* 308 */	NdrFcShort( 0x8 ),	/* 8 */
/* 310 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter in_pProgram */

/* 312 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 314 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 316 */	NdrFcShort( 0x4c ),	/* Type Offset=76 */

	/* Return value */

/* 318 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 320 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 322 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure LeaveDebuggingSession */

/* 324 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 326 */	NdrFcLong( 0x0 ),	/* 0 */
/* 330 */	NdrFcShort( 0xc ),	/* 12 */
/* 332 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x8 ),	/* 8 */
/* 338 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 340 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 342 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 344 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AdviseENCStateEvents */

/* 346 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 348 */	NdrFcLong( 0x0 ),	/* 0 */
/* 352 */	NdrFcShort( 0xd ),	/* 13 */
/* 354 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 358 */	NdrFcShort( 0x8 ),	/* 8 */
/* 360 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter in_pENCStateEvents */

/* 362 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 364 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 366 */	NdrFcShort( 0x5e ),	/* Type Offset=94 */

	/* Return value */

/* 368 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 370 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 372 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UnadviseENCStateEvents */

/* 374 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 376 */	NdrFcLong( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0xe ),	/* 14 */
/* 382 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 384 */	NdrFcShort( 0x0 ),	/* 0 */
/* 386 */	NdrFcShort( 0x8 ),	/* 8 */
/* 388 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter in_pENCStateEvents */

/* 390 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 392 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 394 */	NdrFcShort( 0x5e ),	/* Type Offset=94 */

	/* Return value */

/* 396 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 398 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 400 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFileName */

/* 402 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 404 */	NdrFcLong( 0x0 ),	/* 0 */
/* 408 */	NdrFcShort( 0xf ),	/* 15 */
/* 410 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x8 ),	/* 8 */
/* 416 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter in_szURL */

/* 418 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 420 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 422 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter out_pbstrFileName */

/* 424 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 426 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 428 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Return value */

/* 430 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 432 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 434 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFileDisplayName */

/* 436 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 438 */	NdrFcLong( 0x0 ),	/* 0 */
/* 442 */	NdrFcShort( 0x10 ),	/* 16 */
/* 444 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 446 */	NdrFcShort( 0x0 ),	/* 0 */
/* 448 */	NdrFcShort( 0x8 ),	/* 8 */
/* 450 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter in_szURL */

/* 452 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 454 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 456 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter out_pbstrDisplayFileName */

/* 458 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 460 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 462 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Return value */

/* 464 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 466 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 468 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ClearENCState */

/* 470 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 472 */	NdrFcLong( 0x0 ),	/* 0 */
/* 476 */	NdrFcShort( 0x11 ),	/* 17 */
/* 478 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 480 */	NdrFcShort( 0x0 ),	/* 0 */
/* 482 */	NdrFcShort( 0x8 ),	/* 8 */
/* 484 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 486 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 488 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInfo */


	/* Procedure GetEditedSource */

/* 492 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 494 */	NdrFcLong( 0x0 ),	/* 0 */
/* 498 */	NdrFcShort( 0x3 ),	/* 3 */
/* 500 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 502 */	NdrFcShort( 0x0 ),	/* 0 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter out_pbstrIDBFile */


	/* Parameter out_pbstrEditedSource */

/* 508 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 510 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 512 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Return value */


	/* Return value */

/* 514 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 516 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 518 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSupercededSource */

/* 520 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 522 */	NdrFcLong( 0x0 ),	/* 0 */
/* 526 */	NdrFcShort( 0x4 ),	/* 4 */
/* 528 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
/* 532 */	NdrFcShort( 0x8 ),	/* 8 */
/* 534 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter out_pbstrSupercededSource */

/* 536 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 538 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 540 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Return value */

/* 542 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 544 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 546 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsLineModified */

/* 548 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 550 */	NdrFcLong( 0x0 ),	/* 0 */
/* 554 */	NdrFcShort( 0x5 ),	/* 5 */
/* 556 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 558 */	NdrFcShort( 0x8 ),	/* 8 */
/* 560 */	NdrFcShort( 0x8 ),	/* 8 */
/* 562 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter in_LineNoFromSupercededSource */

/* 564 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 566 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 568 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 570 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 572 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 574 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSaveSize */


	/* Procedure LineMap */

/* 576 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 578 */	NdrFcLong( 0x0 ),	/* 0 */
/* 582 */	NdrFcShort( 0x6 ),	/* 6 */
/* 584 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 586 */	NdrFcShort( 0x8 ),	/* 8 */
/* 588 */	NdrFcShort( 0x24 ),	/* 36 */
/* 590 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter fSave */


	/* Parameter in_LineNoFromSupercededSource */

/* 592 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 594 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 596 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pdwSaveSize */


	/* Parameter out_pLineNoFromEditedSource */

/* 598 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 600 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 602 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */

/* 604 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 606 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 608 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ReverseLineMap */

/* 610 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 612 */	NdrFcLong( 0x0 ),	/* 0 */
/* 616 */	NdrFcShort( 0x7 ),	/* 7 */
/* 618 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 620 */	NdrFcShort( 0x8 ),	/* 8 */
/* 622 */	NdrFcShort( 0x24 ),	/* 36 */
/* 624 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter in_LineNoFromEditedSource */

/* 626 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 628 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 630 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter out_pLineNoFromSupercededSource */

/* 632 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 634 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 636 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 638 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 640 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 642 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInfo */

/* 644 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 646 */	NdrFcLong( 0x0 ),	/* 0 */
/* 650 */	NdrFcShort( 0x3 ),	/* 3 */
/* 652 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 654 */	NdrFcShort( 0x0 ),	/* 0 */
/* 656 */	NdrFcShort( 0x8 ),	/* 8 */
/* 658 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter out_pENCINFO */

/* 660 */	NdrFcShort( 0x8113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=32 */
/* 662 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 664 */	NdrFcShort( 0xd0 ),	/* Type Offset=208 */

	/* Return value */

/* 666 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 668 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 670 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 672 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 674 */	NdrFcLong( 0x0 ),	/* 0 */
/* 678 */	NdrFcShort( 0x3 ),	/* 3 */
/* 680 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 682 */	NdrFcShort( 0x8 ),	/* 8 */
/* 684 */	NdrFcShort( 0x24 ),	/* 36 */
/* 686 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter in_NoOfElementsRequested */

/* 688 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 690 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 692 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter out_ArrayOfpENCInfo */

/* 694 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 696 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 698 */	NdrFcShort( 0x102 ),	/* Type Offset=258 */

	/* Parameter out_pNoOfElementsFetched */

/* 700 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 702 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 704 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 706 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 708 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 710 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */


	/* Procedure Skip */

/* 712 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 714 */	NdrFcLong( 0x0 ),	/* 0 */
/* 718 */	NdrFcShort( 0x4 ),	/* 4 */
/* 720 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 722 */	NdrFcShort( 0x8 ),	/* 8 */
/* 724 */	NdrFcShort( 0x8 ),	/* 8 */
/* 726 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter celt */


	/* Parameter celt */


	/* Parameter in_NoOfElements */


	/* Parameter in_NoOfElements */


	/* Parameter in_NoOfElements */

/* 728 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 730 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 732 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */

/* 734 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 736 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 738 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure CancelENC */


	/* Procedure Reset */


	/* Procedure Reset */


	/* Procedure Reset */

/* 740 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 742 */	NdrFcLong( 0x0 ),	/* 0 */
/* 746 */	NdrFcShort( 0x5 ),	/* 5 */
/* 748 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 750 */	NdrFcShort( 0x0 ),	/* 0 */
/* 752 */	NdrFcShort( 0x8 ),	/* 8 */
/* 754 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */

/* 756 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 758 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 760 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 762 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 764 */	NdrFcLong( 0x0 ),	/* 0 */
/* 768 */	NdrFcShort( 0x6 ),	/* 6 */
/* 770 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 772 */	NdrFcShort( 0x0 ),	/* 0 */
/* 774 */	NdrFcShort( 0x8 ),	/* 8 */
/* 776 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter out_ppEnumENCInfo */

/* 778 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 780 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 782 */	NdrFcShort( 0x114 ),	/* Type Offset=276 */

	/* Return value */

/* 784 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 786 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 788 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */


	/* Procedure GetCount */

/* 790 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 792 */	NdrFcLong( 0x0 ),	/* 0 */
/* 796 */	NdrFcShort( 0x7 ),	/* 7 */
/* 798 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 800 */	NdrFcShort( 0x0 ),	/* 0 */
/* 802 */	NdrFcShort( 0x24 ),	/* 36 */
/* 804 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pcelt */


	/* Parameter pcelt */


	/* Parameter out_pCount */


	/* Parameter out_pCount */


	/* Parameter out_pCount */

/* 806 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 808 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 810 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */

/* 812 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 814 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 816 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInfo */

/* 818 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 820 */	NdrFcLong( 0x0 ),	/* 0 */
/* 824 */	NdrFcShort( 0x3 ),	/* 3 */
/* 826 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 828 */	NdrFcShort( 0x0 ),	/* 0 */
/* 830 */	NdrFcShort( 0x24 ),	/* 36 */
/* 832 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x6,		/* 6 */

	/* Parameter out_pbstrWorkingDir */

/* 834 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 836 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 838 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Parameter out_pbstrCommand */

/* 840 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 842 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 844 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Parameter out_pbstrOutFile */

/* 846 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 848 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 850 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Parameter out_pbstrDebugFile */

/* 852 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 854 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 856 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Parameter out_pbEditFromLib */

/* 858 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 860 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 862 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 864 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 866 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 868 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 870 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 872 */	NdrFcLong( 0x0 ),	/* 0 */
/* 876 */	NdrFcShort( 0x3 ),	/* 3 */
/* 878 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 880 */	NdrFcShort( 0x8 ),	/* 8 */
/* 882 */	NdrFcShort( 0x24 ),	/* 36 */
/* 884 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter in_NoOfElementsRequested */

/* 886 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 888 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 890 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter out_ArrayOfpENCInfo */

/* 892 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 894 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 896 */	NdrFcShort( 0x140 ),	/* Type Offset=320 */

	/* Parameter out_pNoOfElementsFetched */

/* 898 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 900 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 902 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 904 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 906 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 908 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 910 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 912 */	NdrFcLong( 0x0 ),	/* 0 */
/* 916 */	NdrFcShort( 0x6 ),	/* 6 */
/* 918 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 920 */	NdrFcShort( 0x0 ),	/* 0 */
/* 922 */	NdrFcShort( 0x8 ),	/* 8 */
/* 924 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter out_ppEnumENCRelinkInfo */

/* 926 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 928 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 930 */	NdrFcShort( 0x152 ),	/* Type Offset=338 */

	/* Return value */

/* 932 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 934 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 936 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 938 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 940 */	NdrFcLong( 0x0 ),	/* 0 */
/* 944 */	NdrFcShort( 0x3 ),	/* 3 */
/* 946 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 948 */	NdrFcShort( 0x8 ),	/* 8 */
/* 950 */	NdrFcShort( 0x24 ),	/* 36 */
/* 952 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter in_NoOfElementsRequested */

/* 954 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 956 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 958 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter out_ArrayOfpIDBInfo2 */

/* 960 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 962 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 964 */	NdrFcShort( 0x17e ),	/* Type Offset=382 */

	/* Parameter out_pNoOfElementsFetched */

/* 966 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 968 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 970 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 972 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 974 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 976 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 978 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 980 */	NdrFcLong( 0x0 ),	/* 0 */
/* 984 */	NdrFcShort( 0x6 ),	/* 6 */
/* 986 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 988 */	NdrFcShort( 0x0 ),	/* 0 */
/* 990 */	NdrFcShort( 0x8 ),	/* 8 */
/* 992 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter out_ppEnumIDBInfo2 */

/* 994 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 996 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 998 */	NdrFcShort( 0x190 ),	/* Type Offset=400 */

	/* Return value */

/* 1000 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1002 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1004 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTargetBuildInfo */

/* 1006 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1008 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1012 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1014 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1016 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1018 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1020 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter in_szTargetPath */

/* 1022 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1024 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1026 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter out_pbstrSourcePath */

/* 1028 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1030 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1032 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Parameter out_pbstrCommand */

/* 1034 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1036 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1038 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Parameter out_pbstrCurrentdir */

/* 1040 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1042 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1044 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Return value */

/* 1046 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1048 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1050 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsTargetEligible */

/* 1052 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1054 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1058 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1060 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1062 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1064 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1066 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter in_szTargetPath */

/* 1068 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1070 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1072 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 1074 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1076 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1078 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumDebugIDBInfo */

/* 1080 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1082 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1086 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1088 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1090 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1092 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1094 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter out_ppEnumIDBInfo */

/* 1096 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1098 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1100 */	NdrFcShort( 0x190 ),	/* Type Offset=400 */

	/* Return value */

/* 1102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1104 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInfo */

/* 1108 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1110 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1114 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1116 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1120 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1122 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter out_ppEnumENCRelinkInfo */

/* 1124 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1126 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1128 */	NdrFcShort( 0x152 ),	/* Type Offset=338 */

	/* Return value */

/* 1130 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1132 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1134 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetInfo */

/* 1136 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1138 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1142 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1144 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1150 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter out_ppEnumENCInfo */

/* 1152 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1154 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1156 */	NdrFcShort( 0x114 ),	/* Type Offset=276 */

	/* Return value */

/* 1158 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1160 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1162 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetHResult */

/* 1164 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1166 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1170 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1172 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1174 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1176 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1178 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter out_pHResult */

/* 1180 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1182 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1186 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1188 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1190 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumENCSnapshots */

/* 1192 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1194 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1198 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1200 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1202 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1204 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1206 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pszModule */

/* 1208 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1210 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1212 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ppEnum */

/* 1214 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1216 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1218 */	NdrFcShort( 0x1a6 ),	/* Type Offset=422 */

	/* Return value */

/* 1220 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1222 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1224 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumENCSnapshotsByGuid */

/* 1226 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1228 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1232 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1234 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1236 */	NdrFcShort( 0x44 ),	/* 68 */
/* 1238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1240 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x3,		/* 3 */

	/* Parameter guidModule */

/* 1242 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1244 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1246 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter ppEnum */

/* 1248 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1250 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1252 */	NdrFcShort( 0x1a6 ),	/* Type Offset=422 */

	/* Return value */

/* 1254 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1256 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1258 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure OnENCAttemptComplete */

/* 1260 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1262 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1266 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1268 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1274 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 1276 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1278 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1280 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetENCSnapshotInfo */

/* 1282 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1284 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1288 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1290 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1294 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1296 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter pSnapshotInfo */

/* 1298 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
/* 1300 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1302 */	NdrFcShort( 0x20c ),	/* Type Offset=524 */

	/* Return value */

/* 1304 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1306 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1308 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure ApplyCodeChange */

/* 1310 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1312 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1316 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1318 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1320 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1324 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter in_NoOfLineMaps */

/* 1326 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1328 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1330 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter in_ArrayOfLineMaps */

/* 1332 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1334 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1336 */	NdrFcShort( 0x234 ),	/* Type Offset=564 */

	/* Parameter in_pServiceProvider */

/* 1338 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1340 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1342 */	NdrFcShort( 0x246 ),	/* Type Offset=582 */

	/* Parameter in_fOnContinue */

/* 1344 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1346 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1348 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter out_ppEnumENCInfo */

/* 1350 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1352 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1354 */	NdrFcShort( 0x114 ),	/* Type Offset=276 */

	/* Return value */

/* 1356 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1358 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1360 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CommitChange */

/* 1362 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1364 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1368 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1370 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1372 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1374 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1376 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter out_ppEnumENCInfo */

/* 1378 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1380 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1382 */	NdrFcShort( 0x114 ),	/* Type Offset=276 */

	/* Return value */

/* 1384 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1386 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1388 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 1390 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1392 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1396 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1398 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1400 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1402 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1404 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 1406 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1408 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1410 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 1412 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 1414 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1416 */	NdrFcShort( 0x26e ),	/* Type Offset=622 */

	/* Parameter pceltFetched */

/* 1418 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1420 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1422 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1424 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1426 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1428 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 1430 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1432 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1436 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1438 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1440 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1442 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1444 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 1446 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1448 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1450 */	NdrFcShort( 0x280 ),	/* Type Offset=640 */

	/* Return value */

/* 1452 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1454 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1456 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Next */

/* 1458 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1460 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1464 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1466 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1468 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1470 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1472 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x4,		/* 4 */

	/* Parameter celt */

/* 1474 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1476 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1478 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgelt */

/* 1480 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 1482 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1484 */	NdrFcShort( 0x2ac ),	/* Type Offset=684 */

	/* Parameter pceltFetched */

/* 1486 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1488 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1492 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1494 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1496 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Clone */

/* 1498 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1500 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1504 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1506 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1508 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1510 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1512 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppEnum */

/* 1514 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1516 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1518 */	NdrFcShort( 0x2be ),	/* Type Offset=702 */

	/* Return value */

/* 1520 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1522 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1524 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CopyMetaData */

/* 1526 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1528 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1532 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1534 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x4c ),	/* 76 */
/* 1540 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pIStream */

/* 1542 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1544 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1546 */	NdrFcShort( 0x2d4 ),	/* Type Offset=724 */

	/* Parameter pMvid */

/* 1548 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 1550 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1552 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Return value */

/* 1554 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1556 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1558 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetMvid */

/* 1560 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1562 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1566 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1568 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1570 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1572 */	NdrFcShort( 0x4c ),	/* 76 */
/* 1574 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pMvid */

/* 1576 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 1578 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1580 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Return value */

/* 1582 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1584 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1586 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRoDataRVA */

/* 1588 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1590 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1594 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1596 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1598 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1600 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1602 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRoDataRVA */

/* 1604 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1606 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1608 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1610 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1612 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1614 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetRwDataRVA */

/* 1616 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1618 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1622 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1624 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1626 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1628 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1630 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pRwDataRVA */

/* 1632 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1634 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1636 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1638 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1640 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1642 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetPEBytes */

/* 1644 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1646 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1650 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1652 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1654 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1656 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1658 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pBytes */

/* 1660 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1662 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1664 */	NdrFcShort( 0x2ee ),	/* Type Offset=750 */

	/* Parameter dwBytes */

/* 1666 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1668 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1670 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1672 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1674 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1676 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetILMap */

/* 1678 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1680 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1684 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1686 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1688 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1690 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1692 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter mdFunction */

/* 1694 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1696 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1698 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cMapSize */

/* 1700 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1702 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1704 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter map */

/* 1706 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1708 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1710 */	NdrFcShort( 0x304 ),	/* Type Offset=772 */

	/* Return value */

/* 1712 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1714 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1716 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetSymbolBytes */

/* 1718 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1720 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1724 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1726 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1728 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1730 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1732 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pBytes */

/* 1734 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1736 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1738 */	NdrFcShort( 0x2ee ),	/* Type Offset=750 */

	/* Parameter dwBytes */

/* 1740 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1742 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1744 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1746 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1748 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1750 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSymbolProvider */

/* 1752 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1754 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1758 */	NdrFcShort( 0xa ),	/* 10 */
/* 1760 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1762 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1764 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1766 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppSym */

/* 1768 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1770 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1772 */	NdrFcShort( 0x312 ),	/* Type Offset=786 */

	/* Return value */

/* 1774 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1776 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1778 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAppDomainAndModuleIDs */

/* 1780 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1782 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1786 */	NdrFcShort( 0xb ),	/* 11 */
/* 1788 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1790 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1792 */	NdrFcShort( 0x68 ),	/* 104 */
/* 1794 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pulAppDomainID */

/* 1796 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1798 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1800 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pguidModule */

/* 1802 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 1804 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1806 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Return value */

/* 1808 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1810 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1812 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RequestILMap */

/* 1814 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1816 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1820 */	NdrFcShort( 0xc ),	/* 12 */
/* 1822 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1824 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1826 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1828 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter mdFunction */

/* 1830 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1832 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1834 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1836 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1838 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1840 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure CreateILMaps */

/* 1842 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1844 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1848 */	NdrFcShort( 0xd ),	/* 13 */
/* 1850 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1852 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1854 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1856 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter in_NoOfLineMaps */

/* 1858 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1860 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1862 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter in_ArrayOfLineMaps */

/* 1864 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1866 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1868 */	NdrFcShort( 0x33e ),	/* Type Offset=830 */

	/* Return value */

/* 1870 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1872 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1874 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumDependentImages */

/* 1876 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1878 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1882 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1884 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1886 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1888 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1890 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pszSourcePath */

/* 1892 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1894 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1896 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ppEnum */

/* 1898 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1900 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1902 */	NdrFcShort( 0x350 ),	/* Type Offset=848 */

	/* Return value */

/* 1904 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1906 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1908 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EnumDependentTargets */

/* 1910 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1912 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1916 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1918 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1920 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1922 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1924 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter cSrc */

/* 1926 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1928 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1930 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pszSourcePath */

/* 1932 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1934 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1936 */	NdrFcShort( 0x366 ),	/* Type Offset=870 */

	/* Parameter ppEnum */

/* 1938 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1940 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1942 */	NdrFcShort( 0x350 ),	/* Type Offset=848 */

	/* Return value */

/* 1944 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1946 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1948 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTargetBuildInfo */

/* 1950 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1952 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1956 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1958 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1960 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1962 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1964 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter pszTargetPath */

/* 1966 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1968 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1970 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter pbstrSourcePath */

/* 1972 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1974 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1976 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Parameter pbstrCommand */

/* 1978 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1980 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1982 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Parameter pbstrCommandArgs */

/* 1984 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1986 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1988 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Parameter pbstrCurrentDir */

/* 1990 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 1992 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1994 */	NdrFcShort( 0x8c ),	/* Type Offset=140 */

	/* Return value */

/* 1996 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1998 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2000 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Notify */

/* 2002 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2004 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2008 */	NdrFcShort( 0x7 ),	/* 7 */
/* 2010 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2012 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2014 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2016 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter encnotify */

/* 2018 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2020 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2022 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 2024 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2026 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2028 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure IsTargetEligible */

/* 2030 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2032 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2036 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2038 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2040 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2042 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2044 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x2,		/* 2 */

	/* Parameter pszTargetPath */

/* 2046 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2048 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2050 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 2052 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2054 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2056 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure AddRecompiledTarget */

/* 2058 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2060 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2064 */	NdrFcShort( 0x9 ),	/* 9 */
/* 2066 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2068 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2070 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2072 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter in_szTargetPath */

/* 2074 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2076 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2078 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter in_szSavedTargetPath */

/* 2080 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2082 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2084 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 2086 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2088 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAllLocalsProperty */

/* 2092 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2094 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2098 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2100 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2102 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2104 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2106 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppProperty */

/* 2108 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2110 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2112 */	NdrFcShort( 0x384 ),	/* Type Offset=900 */

	/* Return value */

/* 2114 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2116 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2118 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetModuleProps */

/* 2120 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2122 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2126 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2128 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2130 */	NdrFcShort( 0x4c ),	/* 76 */
/* 2132 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2134 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter szName */

/* 2136 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2138 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2140 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ppid */

/* 2142 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2144 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2146 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter lcid */

/* 2148 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2150 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2152 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2154 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2156 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Save */

/* 2160 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2166 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2168 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2170 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2172 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2174 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter szFile */

/* 2176 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2178 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2180 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter dwSaveFlags */

/* 2182 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2184 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2186 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2188 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2190 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SaveToStream */

/* 2194 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2196 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2200 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2202 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2204 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2206 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2208 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter pIStream */

/* 2210 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2212 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2214 */	NdrFcShort( 0x2d4 ),	/* Type Offset=724 */

	/* Parameter dwSaveFlags */

/* 2216 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2218 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2220 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2222 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2224 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineCustomValueAsBlob */

/* 2228 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2230 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2234 */	NdrFcShort( 0x7 ),	/* 7 */
/* 2236 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2238 */	NdrFcShort( 0x2c ),	/* 44 */
/* 2240 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2242 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter tkObj */

/* 2244 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2246 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2248 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 2250 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2252 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2254 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter pCustomValue */

/* 2256 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2258 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2260 */	NdrFcShort( 0x39e ),	/* Type Offset=926 */

	/* Parameter cbCustomValue */

/* 2262 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2264 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2266 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcv */

/* 2268 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 2270 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2272 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2274 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2276 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2278 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineTypeDef */

/* 2280 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2282 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2286 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2288 */	NdrFcShort( 0x38 ),	/* x86 Stack size/offset = 56 */
/* 2290 */	NdrFcShort( 0x90 ),	/* 144 */
/* 2292 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2294 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0xd,		/* 13 */

	/* Parameter szNamespace */

/* 2296 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2298 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2300 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter szTypeDef */

/* 2302 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2304 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2306 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter pguid */

/* 2308 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2310 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2312 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter pVer */

/* 2314 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 2316 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2318 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter dwTypeDefFlags */

/* 2320 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2322 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2324 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter tkExtends */

/* 2326 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2328 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2330 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwExtendsFlags */

/* 2332 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2334 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2336 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwImplements */

/* 2338 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2340 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 2342 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rtkImplements */

/* 2344 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 2346 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 2348 */	NdrFcShort( 0x3ac ),	/* Type Offset=940 */

	/* Parameter dwEvents */

/* 2350 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2352 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 2354 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rtkEvents */

/* 2356 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 2358 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 2360 */	NdrFcShort( 0x3ba ),	/* Type Offset=954 */

	/* Parameter ptd */

/* 2362 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2364 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 2366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2368 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2370 */	NdrFcShort( 0x34 ),	/* x86 Stack size/offset = 52 */
/* 2372 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetTypeDefProps */

/* 2374 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2376 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2380 */	NdrFcShort( 0x9 ),	/* 9 */
/* 2382 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 2384 */	NdrFcShort( 0x54 ),	/* 84 */
/* 2386 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2388 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0xa,		/* 10 */

	/* Parameter td */

/* 2390 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2392 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pVer */

/* 2396 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 2398 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2400 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter dwTypeDefFlags */

/* 2402 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2404 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2406 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter tkExtends */

/* 2408 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2410 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwExtendsFlags */

/* 2414 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2416 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2418 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwImplements */

/* 2420 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2422 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2424 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rtkImplements */

/* 2426 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2428 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2430 */	NdrFcShort( 0x3c8 ),	/* Type Offset=968 */

	/* Parameter dwEvents */

/* 2432 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2434 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 2436 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rtkEvents */

/* 2438 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2440 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 2442 */	NdrFcShort( 0x3ac ),	/* Type Offset=940 */

	/* Return value */

/* 2444 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2446 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 2448 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetClassSvcsContext */

/* 2450 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2452 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2456 */	NdrFcShort( 0xa ),	/* 10 */
/* 2458 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2460 */	NdrFcShort( 0x28 ),	/* 40 */
/* 2462 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2464 */	0x4,		/* Oi2 Flags:  has return, */
			0x6,		/* 6 */

	/* Parameter td */

/* 2466 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2468 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2470 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwClassActivateAttr */

/* 2472 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2474 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2476 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwClassThreadAttr */

/* 2478 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2480 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2482 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwXactionAttr */

/* 2484 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2486 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2488 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwSynchAttr */

/* 2490 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2492 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2494 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2496 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2498 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2500 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineTypeRefByGUID */

/* 2502 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2504 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2508 */	NdrFcShort( 0xb ),	/* 11 */
/* 2510 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2512 */	NdrFcShort( 0x44 ),	/* 68 */
/* 2514 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2516 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter pguid */

/* 2518 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2520 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2522 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter ptr */

/* 2524 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2526 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2528 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2530 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2532 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2534 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetModuleReg */

/* 2536 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2538 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2542 */	NdrFcShort( 0xc ),	/* 12 */
/* 2544 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2546 */	NdrFcShort( 0x4c ),	/* 76 */
/* 2548 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2550 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter dwModuleRegAttr */

/* 2552 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2554 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2556 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pguid */

/* 2558 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2560 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2562 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Return value */

/* 2564 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2566 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2568 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetClassReg */

/* 2570 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2572 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2576 */	NdrFcShort( 0xd ),	/* 13 */
/* 2578 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 2580 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2582 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2584 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x9,		/* 9 */

	/* Parameter td */

/* 2586 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2588 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2590 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szProgID */

/* 2592 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2594 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2596 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter szVIProgID */

/* 2598 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2600 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2602 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter szIconURL */

/* 2604 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2606 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2608 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ulIconResource */

/* 2610 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2612 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2614 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szSmallIconURL */

/* 2616 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2618 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2620 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ulSmallIconResource */

/* 2622 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2624 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2626 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szDefaultDispName */

/* 2628 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2630 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 2632 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 2634 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2636 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 2638 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetIfaceReg */

/* 2640 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2642 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2646 */	NdrFcShort( 0xe ),	/* 14 */
/* 2648 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2650 */	NdrFcShort( 0x54 ),	/* 84 */
/* 2652 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2654 */	0x4,		/* Oi2 Flags:  has return, */
			0x4,		/* 4 */

	/* Parameter td */

/* 2656 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2658 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2660 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwIfaceSvcs */

/* 2662 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2664 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2666 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter proxyStub */

/* 2668 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2670 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2672 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Return value */

/* 2674 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2676 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2678 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetCategoryImpl */

/* 2680 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2682 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2686 */	NdrFcShort( 0xf ),	/* 15 */
/* 2688 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2690 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2692 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2694 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter td */

/* 2696 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2698 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2700 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwImpl */

/* 2702 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2704 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2706 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rGuidCoCatImpl */

/* 2708 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2710 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2712 */	NdrFcShort( 0x3d6 ),	/* Type Offset=982 */

	/* Parameter dwReqd */

/* 2714 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2716 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2718 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rGuidCoCatReqd */

/* 2720 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2722 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2724 */	NdrFcShort( 0x3e8 ),	/* Type Offset=1000 */

	/* Return value */

/* 2726 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2728 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetRedirectProgID */

/* 2732 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2734 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2738 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2740 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2742 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2744 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2746 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter td */

/* 2748 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2750 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2752 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwProgIds */

/* 2754 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2756 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2758 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rszRedirectProgID */

/* 2760 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2762 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2764 */	NdrFcShort( 0x3fa ),	/* Type Offset=1018 */

	/* Return value */

/* 2766 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2768 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2770 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetMimeTypeImpl */

/* 2772 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2774 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2778 */	NdrFcShort( 0x11 ),	/* 17 */
/* 2780 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2782 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2784 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2786 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter td */

/* 2788 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2790 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2792 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwTypes */

/* 2794 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2796 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2798 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rszMimeType */

/* 2800 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2802 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2804 */	NdrFcShort( 0x3fa ),	/* Type Offset=1018 */

	/* Return value */

/* 2806 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2808 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2810 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetFormatImpl */

/* 2812 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2814 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2818 */	NdrFcShort( 0x12 ),	/* 18 */
/* 2820 */	NdrFcShort( 0x3c ),	/* x86 Stack size/offset = 60 */
/* 2822 */	NdrFcShort( 0x38 ),	/* 56 */
/* 2824 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2826 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0xe,		/* 14 */

	/* Parameter td */

/* 2828 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2830 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2832 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwSupported */

/* 2834 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2836 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2838 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rszFormatSupported */

/* 2840 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2842 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2844 */	NdrFcShort( 0x3fa ),	/* Type Offset=1018 */

	/* Parameter dwFrom */

/* 2846 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2848 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2850 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rszFormatConvertsFrom */

/* 2852 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2854 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2856 */	NdrFcShort( 0x41c ),	/* Type Offset=1052 */

	/* Parameter dwTo */

/* 2858 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2860 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2862 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rszFormatConvertsTo */

/* 2864 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2866 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2868 */	NdrFcShort( 0x43e ),	/* Type Offset=1086 */

	/* Parameter dwDefault */

/* 2870 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2872 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 2874 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rszFormatDefault */

/* 2876 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2878 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 2880 */	NdrFcShort( 0x460 ),	/* Type Offset=1120 */

	/* Parameter dwExt */

/* 2882 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2884 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 2886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rszFileExt */

/* 2888 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2890 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 2892 */	NdrFcShort( 0x482 ),	/* Type Offset=1154 */

	/* Parameter dwType */

/* 2894 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2896 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 2898 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rszFileType */

/* 2900 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2902 */	NdrFcShort( 0x34 ),	/* x86 Stack size/offset = 52 */
/* 2904 */	NdrFcShort( 0x4a4 ),	/* Type Offset=1188 */

	/* Return value */

/* 2906 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2908 */	NdrFcShort( 0x38 ),	/* x86 Stack size/offset = 56 */
/* 2910 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetRoleCheck */

/* 2912 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2914 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2918 */	NdrFcShort( 0x13 ),	/* 19 */
/* 2920 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 2922 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2924 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2926 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter tk */

/* 2928 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2930 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2932 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwNames */

/* 2934 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2936 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2938 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rszName */

/* 2940 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2942 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2944 */	NdrFcShort( 0x3fa ),	/* Type Offset=1018 */

	/* Parameter dwFlags */

/* 2946 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2948 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 2950 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rdwRoleFlags */

/* 2952 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2954 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 2956 */	NdrFcShort( 0x4c6 ),	/* Type Offset=1222 */

	/* Return value */

/* 2958 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2960 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 2962 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineMethod */

/* 2964 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2966 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2970 */	NdrFcShort( 0x14 ),	/* 20 */
/* 2972 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 2974 */	NdrFcShort( 0x30 ),	/* 48 */
/* 2976 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2978 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0xa,		/* 10 */

	/* Parameter td */

/* 2980 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2982 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 2984 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 2986 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2988 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 2990 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter dwMethodFlags */

/* 2992 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2994 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 2996 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pvSigBlob */

/* 2998 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3000 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3002 */	NdrFcShort( 0x4d8 ),	/* Type Offset=1240 */

	/* Parameter cbSigBlob */

/* 3004 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3006 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3008 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ulSlot */

/* 3010 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3012 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3014 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ulCodeRVA */

/* 3016 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3018 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3020 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwImplFlags */

/* 3022 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3024 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 3026 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pmd */

/* 3028 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3030 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 3032 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3034 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3036 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 3038 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineField */

/* 3040 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3042 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3046 */	NdrFcShort( 0x15 ),	/* 21 */
/* 3048 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 3050 */	NdrFcShort( 0x28 ),	/* 40 */
/* 3052 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3054 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0xa,		/* 10 */

	/* Parameter td */

/* 3056 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3058 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3060 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 3062 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3064 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3066 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter dwFieldFlags */

/* 3068 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3070 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3072 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pvSigBlob */

/* 3074 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3076 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3078 */	NdrFcShort( 0x4d8 ),	/* Type Offset=1240 */

	/* Parameter cbSigBlob */

/* 3080 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3082 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3084 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwCPlusTypeFlag */

/* 3086 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3088 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pValue */

/* 3092 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3094 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3096 */	NdrFcShort( 0x4e6 ),	/* Type Offset=1254 */

	/* Parameter cbValue */

/* 3098 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3100 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 3102 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pmd */

/* 3104 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3106 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 3108 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3110 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3112 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 3114 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetParamProps */

/* 3116 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3118 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3122 */	NdrFcShort( 0x16 ),	/* 22 */
/* 3124 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 3126 */	NdrFcShort( 0x28 ),	/* 40 */
/* 3128 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3130 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x9,		/* 9 */

	/* Parameter md */

/* 3132 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3134 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ulParamSeq */

/* 3138 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3140 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 3144 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3146 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3148 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter dwParamFlags */

/* 3150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3152 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwCPlusTypeFlag */

/* 3156 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3158 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pValue */

/* 3162 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3164 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3166 */	NdrFcShort( 0x4f4 ),	/* Type Offset=1268 */

	/* Parameter cbValue */

/* 3168 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3170 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3172 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppd */

/* 3174 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3176 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 3178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3180 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3182 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 3184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineMethodImpl */

/* 3186 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3188 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3192 */	NdrFcShort( 0x17 ),	/* 23 */
/* 3194 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3196 */	NdrFcShort( 0x20 ),	/* 32 */
/* 3198 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3200 */	0x4,		/* Oi2 Flags:  has return, */
			0x6,		/* 6 */

	/* Parameter td */

/* 3202 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3204 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3206 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter tk */

/* 3208 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3210 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3212 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ulCodeRVA */

/* 3214 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3216 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3218 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwImplFlags */

/* 3220 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3222 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3224 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pmi */

/* 3226 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3228 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3230 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3232 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3234 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3236 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetRVA */

/* 3238 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3240 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3244 */	NdrFcShort( 0x18 ),	/* 24 */
/* 3246 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3248 */	NdrFcShort( 0x18 ),	/* 24 */
/* 3250 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3252 */	0x4,		/* Oi2 Flags:  has return, */
			0x4,		/* 4 */

	/* Parameter md */

/* 3254 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3256 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3258 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ulCodeRVA */

/* 3260 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3262 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwImplFlags */

/* 3266 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3268 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3270 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3272 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3274 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3276 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineTypeRefByName */

/* 3278 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3280 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3284 */	NdrFcShort( 0x19 ),	/* 25 */
/* 3286 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3288 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3290 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3292 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter szNamespace */

/* 3294 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3296 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3298 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter szType */

/* 3300 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3302 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3304 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ptr */

/* 3306 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3308 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3312 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3314 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3316 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetTypeRefBind */

/* 3318 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3320 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3324 */	NdrFcShort( 0x1a ),	/* 26 */
/* 3326 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3328 */	NdrFcShort( 0x20 ),	/* 32 */
/* 3330 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3332 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter tr */

/* 3334 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3336 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3338 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwBindFlags */

/* 3340 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3342 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3344 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwMinVersion */

/* 3346 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3348 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3350 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwMaxVersion */

/* 3352 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3354 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3356 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szCodebase */

/* 3358 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3360 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3362 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 3364 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3366 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3368 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineMemberRef */

/* 3370 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3372 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3376 */	NdrFcShort( 0x1b ),	/* 27 */
/* 3378 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3380 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3382 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3384 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter tkImport */

/* 3386 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3388 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3390 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szName */

/* 3392 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3394 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3396 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter pvSigBlob */

/* 3398 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3400 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3402 */	NdrFcShort( 0x39e ),	/* Type Offset=926 */

	/* Parameter cbSigBlob */

/* 3404 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3406 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3408 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pmr */

/* 3410 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3412 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3414 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3416 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3418 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3420 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineException */

/* 3422 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3424 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3428 */	NdrFcShort( 0x1c ),	/* 28 */
/* 3430 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3432 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3434 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3436 */	0x4,		/* Oi2 Flags:  has return, */
			0x4,		/* 4 */

	/* Parameter mb */

/* 3438 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3440 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3442 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter tk */

/* 3444 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3446 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3448 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pex */

/* 3450 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3452 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3454 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3456 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3458 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3460 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineProperty */

/* 3462 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3464 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3468 */	NdrFcShort( 0x1d ),	/* 29 */
/* 3470 */	NdrFcShort( 0x50 ),	/* x86 Stack size/offset = 80 */
/* 3472 */	NdrFcShort( 0x68 ),	/* 104 */
/* 3474 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3476 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x13,		/* 19 */

	/* Parameter td */

/* 3478 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3480 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3482 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szProperty */

/* 3484 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3486 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3488 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter dwPropFlags */

/* 3490 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3492 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3494 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pvSig */

/* 3496 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3498 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3500 */	NdrFcShort( 0x4d8 ),	/* Type Offset=1240 */

	/* Parameter cbSig */

/* 3502 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3504 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3506 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwCPlusTypeFlag */

/* 3508 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3510 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3512 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pValue */

/* 3514 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3516 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3518 */	NdrFcShort( 0x4e6 ),	/* Type Offset=1254 */

	/* Parameter cbValue */

/* 3520 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3522 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 3524 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter mdSetter */

/* 3526 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3528 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 3530 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter mdGetter */

/* 3532 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3534 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 3536 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter mdReset */

/* 3538 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3540 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 3542 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter mdTestDefault */

/* 3544 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3546 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 3548 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwOthers */

/* 3550 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3552 */	NdrFcShort( 0x34 ),	/* x86 Stack size/offset = 52 */
/* 3554 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rmdOtherMethods */

/* 3556 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3558 */	NdrFcShort( 0x38 ),	/* x86 Stack size/offset = 56 */
/* 3560 */	NdrFcShort( 0x4fe ),	/* Type Offset=1278 */

	/* Parameter evNotifyChanging */

/* 3562 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3564 */	NdrFcShort( 0x3c ),	/* x86 Stack size/offset = 60 */
/* 3566 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter evNotifyChanged */

/* 3568 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3570 */	NdrFcShort( 0x40 ),	/* x86 Stack size/offset = 64 */
/* 3572 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter fdBackingField */

/* 3574 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3576 */	NdrFcShort( 0x44 ),	/* x86 Stack size/offset = 68 */
/* 3578 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pmdProp */

/* 3580 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3582 */	NdrFcShort( 0x48 ),	/* x86 Stack size/offset = 72 */
/* 3584 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3586 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3588 */	NdrFcShort( 0x4c ),	/* x86 Stack size/offset = 76 */
/* 3590 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineEvent */

/* 3592 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3594 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3598 */	NdrFcShort( 0x1e ),	/* 30 */
/* 3600 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 3602 */	NdrFcShort( 0x38 ),	/* 56 */
/* 3604 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3606 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0xb,		/* 11 */

	/* Parameter td */

/* 3608 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3610 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3612 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter szEvent */

/* 3614 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3616 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3618 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter dwEventFlags */

/* 3620 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3622 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3624 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter tkEventType */

/* 3626 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3628 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3630 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter mdAddOn */

/* 3632 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3634 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3636 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter mdRemoveOn */

/* 3638 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3640 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3642 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter mdFire */

/* 3644 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3646 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3648 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwOthers */

/* 3650 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3652 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 3654 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rmdOtherMethods */

/* 3656 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3658 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 3660 */	NdrFcShort( 0x3ac ),	/* Type Offset=940 */

	/* Parameter pmdEvent */

/* 3662 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3664 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 3666 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3668 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3670 */	NdrFcShort( 0x2c ),	/* x86 Stack size/offset = 44 */
/* 3672 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetFieldMarshal */

/* 3674 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3676 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3680 */	NdrFcShort( 0x1f ),	/* 31 */
/* 3682 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3684 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3686 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3688 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter tk */

/* 3690 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3692 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3694 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pvNativeType */

/* 3696 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3698 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3700 */	NdrFcShort( 0x510 ),	/* Type Offset=1296 */

	/* Parameter cbNativeType */

/* 3702 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3704 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3706 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3708 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3710 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3712 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefinePermissionSet */

/* 3714 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3716 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3720 */	NdrFcShort( 0x20 ),	/* 32 */
/* 3722 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 3724 */	NdrFcShort( 0x18 ),	/* 24 */
/* 3726 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3728 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter tk */

/* 3730 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3732 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3734 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwAction */

/* 3736 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3738 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3740 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pvPermission */

/* 3742 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3744 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3746 */	NdrFcShort( 0x39e ),	/* Type Offset=926 */

	/* Parameter cbPermission */

/* 3748 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3750 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3752 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppm */

/* 3754 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3756 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3758 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3760 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3762 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3764 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetMemberIndex */

/* 3766 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3768 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3772 */	NdrFcShort( 0x21 ),	/* 33 */
/* 3774 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3776 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3778 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3780 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter md */

/* 3782 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3784 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3786 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ulIndex */

/* 3788 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3790 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3792 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3794 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3796 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3798 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTokenFromSig */

/* 3800 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3802 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3806 */	NdrFcShort( 0x22 ),	/* 34 */
/* 3808 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3810 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3812 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3814 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pvSig */

/* 3816 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3818 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3820 */	NdrFcShort( 0x51e ),	/* Type Offset=1310 */

	/* Parameter cbSig */

/* 3822 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3824 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3826 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pmsig */

/* 3828 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 3830 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3832 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3834 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3836 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3838 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineModuleRef */

/* 3840 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3842 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3846 */	NdrFcShort( 0x23 ),	/* 35 */
/* 3848 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 3850 */	NdrFcShort( 0x88 ),	/* 136 */
/* 3852 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3854 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter szName */

/* 3856 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3858 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3860 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter pguid */

/* 3862 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 3864 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3866 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter pmvid */

/* 3868 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 3870 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3872 */	NdrFcShort( 0x22 ),	/* Type Offset=34 */

	/* Parameter pmur */

/* 3874 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3876 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3878 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3880 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3882 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3884 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetParent */

/* 3886 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3888 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3892 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3894 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3896 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3898 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3900 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter mr */

/* 3902 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3904 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3906 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter tk */

/* 3908 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3910 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3912 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3914 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3916 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3918 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTokenFromArraySpec */

/* 3920 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3922 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3926 */	NdrFcShort( 0x25 ),	/* 37 */
/* 3928 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 3930 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3932 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3934 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter pvSig */

/* 3936 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3938 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3940 */	NdrFcShort( 0x51e ),	/* Type Offset=1310 */

	/* Parameter cbSig */

/* 3942 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3944 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3946 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter parrspec */

/* 3948 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3950 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3952 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3954 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3956 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3958 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineSourceFile */

/* 3960 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3962 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3966 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3968 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 3970 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3972 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3974 */	0x6,		/* Oi2 Flags:  clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter szFileName */

/* 3976 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3978 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 3980 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter psourcefile */

/* 3982 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3984 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 3986 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 3988 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3990 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 3992 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineBlock */

/* 3994 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3996 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4000 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4002 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 4004 */	NdrFcShort( 0x31 ),	/* 49 */
/* 4006 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4008 */	0x4,		/* Oi2 Flags:  has return, */
			0x5,		/* 5 */

	/* Parameter member */

/* 4010 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4012 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4014 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter sourcefile */

/* 4016 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4018 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4020 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pAttr */

/* 4022 */	NdrFcShort( 0x148 ),	/* Flags:  in, base type, simple ref, */
/* 4024 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4026 */	0x1,		/* FC_BYTE */
			0x0,		/* 0 */

	/* Parameter cbAttr */

/* 4028 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4030 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4032 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4034 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4036 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4038 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DefineLocalVarScope */

/* 4040 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4042 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4046 */	NdrFcShort( 0x5 ),	/* 5 */
/* 4048 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 4050 */	NdrFcShort( 0x20 ),	/* 32 */
/* 4052 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4054 */	0x4,		/* Oi2 Flags:  has return, */
			0x6,		/* 6 */

	/* Parameter scopeParent */

/* 4056 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4058 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4060 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ulStartLine */

/* 4062 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4064 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4066 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ulEndLine */

/* 4068 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4070 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4072 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter member */

/* 4074 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4076 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4078 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter plocalvarscope */

/* 4080 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 4082 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 4084 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4086 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4088 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 4090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure OnStateChange */

/* 4092 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4094 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4098 */	NdrFcShort( 0x3 ),	/* 3 */
/* 4100 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 4102 */	NdrFcShort( 0x22 ),	/* 34 */
/* 4104 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4106 */	0x4,		/* Oi2 Flags:  has return, */
			0x3,		/* 3 */

	/* Parameter in_pENCSTATE */

/* 4108 */	NdrFcShort( 0x2008 ),	/* Flags:  in, srv alloc size=8 */
/* 4110 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 4112 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Parameter in_fReserved */

/* 4114 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4116 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 4118 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 4120 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4122 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 4124 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/*  8 */	NdrFcLong( 0x6d5140c1 ),	/* 1834041537 */
/* 12 */	NdrFcShort( 0x7436 ),	/* 29750 */
/* 14 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 16 */	0x80,		/* 128 */
			0x34,		/* 52 */
/* 18 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 20 */	0x0,		/* 0 */
			0x60,		/* 96 */
/* 22 */	0x9,		/* 9 */
			0xfa,		/* 250 */
/* 24 */	
			0x11, 0x0,	/* FC_RP */
/* 26 */	NdrFcShort( 0x8 ),	/* Offset= 8 (34) */
/* 28 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 34 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 36 */	NdrFcShort( 0x10 ),	/* 16 */
/* 38 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 40 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 42 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (28) */
			0x5b,		/* FC_END */
/* 46 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 48 */	0xd,		/* FC_ENUM16 */
			0x5c,		/* FC_PAD */
/* 50 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 52 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 54 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 56 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 58 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 60 */	NdrFcLong( 0x8948300f ),	/* -1991757809 */
/* 64 */	NdrFcShort( 0x8bd5 ),	/* -29739 */
/* 66 */	NdrFcShort( 0x4728 ),	/* 18216 */
/* 68 */	0xa1,		/* 161 */
			0xd8,		/* 216 */
/* 70 */	0x83,		/* 131 */
			0xd1,		/* 209 */
/* 72 */	0x72,		/* 114 */
			0x29,		/* 41 */
/* 74 */	0x5a,		/* 90 */
			0x9d,		/* 157 */
/* 76 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 78 */	NdrFcLong( 0x69d172ef ),	/* 1775334127 */
/* 82 */	NdrFcShort( 0xf2c4 ),	/* -3388 */
/* 84 */	NdrFcShort( 0x44e1 ),	/* 17633 */
/* 86 */	0x89,		/* 137 */
			0xf7,		/* 247 */
/* 88 */	0xc8,		/* 200 */
			0x62,		/* 98 */
/* 90 */	0x31,		/* 49 */
			0xe7,		/* 231 */
/* 92 */	0x6,		/* 6 */
			0xe9,		/* 233 */
/* 94 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 96 */	NdrFcLong( 0xec80d064 ),	/* -327102364 */
/* 100 */	NdrFcShort( 0x102e ),	/* 4142 */
/* 102 */	NdrFcShort( 0x435f ),	/* 17247 */
/* 104 */	0xaa,		/* 170 */
			0xfb,		/* 251 */
/* 106 */	0xd3,		/* 211 */
			0x7e,		/* 126 */
/* 108 */	0x2a,		/* 42 */
			0x4e,		/* 78 */
/* 110 */	0xf6,		/* 246 */
			0x54,		/* 84 */
/* 112 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 114 */	NdrFcShort( 0x1a ),	/* Offset= 26 (140) */
/* 116 */	
			0x13, 0x0,	/* FC_OP */
/* 118 */	NdrFcShort( 0xc ),	/* Offset= 12 (130) */
/* 120 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 122 */	NdrFcShort( 0x2 ),	/* 2 */
/* 124 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 126 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 128 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 130 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 132 */	NdrFcShort( 0x8 ),	/* 8 */
/* 134 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (120) */
/* 136 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 138 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 140 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 144 */	NdrFcShort( 0x4 ),	/* 4 */
/* 146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 148 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (116) */
/* 150 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 152 */	NdrFcShort( 0x38 ),	/* Offset= 56 (208) */
/* 154 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 156 */	NdrFcLong( 0x1412926f ),	/* 336761455 */
/* 160 */	NdrFcShort( 0x5dd6 ),	/* 24022 */
/* 162 */	NdrFcShort( 0x4e58 ),	/* 20056 */
/* 164 */	0xb6,		/* 182 */
			0x48,		/* 72 */
/* 166 */	0xe1,		/* 225 */
			0xc6,		/* 198 */
/* 168 */	0x3e,		/* 62 */
			0x1,		/* 1 */
/* 170 */	0x3d,		/* 61 */
			0x51,		/* 81 */
/* 172 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 174 */	NdrFcLong( 0xac17b76b ),	/* -1407731861 */
/* 178 */	NdrFcShort( 0x2b09 ),	/* 11017 */
/* 180 */	NdrFcShort( 0x419a ),	/* 16794 */
/* 182 */	0xad,		/* 173 */
			0x5f,		/* 95 */
/* 184 */	0x7d,		/* 125 */
			0x74,		/* 116 */
/* 186 */	0x2,		/* 2 */
			0xda,		/* 218 */
/* 188 */	0x88,		/* 136 */
			0x75,		/* 117 */
/* 190 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 192 */	NdrFcLong( 0x0 ),	/* 0 */
/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 202 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 204 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 206 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 208 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 210 */	NdrFcShort( 0x1c ),	/* 28 */
/* 212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 214 */	NdrFcShort( 0x16 ),	/* Offset= 22 (236) */
/* 216 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 218 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffbf ),	/* Offset= -65 (154) */
			0x8,		/* FC_LONG */
/* 222 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 224 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffab ),	/* Offset= -85 (140) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 228 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc7 ),	/* Offset= -57 (172) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 232 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd5 ),	/* Offset= -43 (190) */
			0x5b,		/* FC_END */
/* 236 */	
			0x11, 0x0,	/* FC_RP */
/* 238 */	NdrFcShort( 0x14 ),	/* Offset= 20 (258) */
/* 240 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 242 */	NdrFcLong( 0x6b56106f ),	/* 1800802415 */
/* 246 */	NdrFcShort( 0xbd51 ),	/* -17071 */
/* 248 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 250 */	0x92,		/* 146 */
			0x38,		/* 56 */
/* 252 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 254 */	0x24,		/* 36 */
			0x48,		/* 72 */
/* 256 */	0x79,		/* 121 */
			0x9a,		/* 154 */
/* 258 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 262 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 264 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 266 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 268 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 270 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 272 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (240) */
/* 274 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 276 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 278 */	NdrFcShort( 0x2 ),	/* Offset= 2 (280) */
/* 280 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 282 */	NdrFcLong( 0x7b076ad1 ),	/* 2064083665 */
/* 286 */	NdrFcShort( 0xbd51 ),	/* -17071 */
/* 288 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 290 */	0x92,		/* 146 */
			0x38,		/* 56 */
/* 292 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 294 */	0x24,		/* 36 */
			0x48,		/* 72 */
/* 296 */	0x79,		/* 121 */
			0x9a,		/* 154 */
/* 298 */	
			0x11, 0x0,	/* FC_RP */
/* 300 */	NdrFcShort( 0x14 ),	/* Offset= 20 (320) */
/* 302 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 304 */	NdrFcLong( 0xcbb63a8d ),	/* -877249907 */
/* 308 */	NdrFcShort( 0xbd57 ),	/* -17065 */
/* 310 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 312 */	0x92,		/* 146 */
			0x38,		/* 56 */
/* 314 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 316 */	0x24,		/* 36 */
			0x48,		/* 72 */
/* 318 */	0x79,		/* 121 */
			0x9a,		/* 154 */
/* 320 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 324 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 326 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 328 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 330 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 332 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 334 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (302) */
/* 336 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 338 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 340 */	NdrFcShort( 0x2 ),	/* Offset= 2 (342) */
/* 342 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 344 */	NdrFcLong( 0xe51be743 ),	/* -451156157 */
/* 348 */	NdrFcShort( 0xbd57 ),	/* -17065 */
/* 350 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 352 */	0x92,		/* 146 */
			0x38,		/* 56 */
/* 354 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 356 */	0x24,		/* 36 */
			0x48,		/* 72 */
/* 358 */	0x79,		/* 121 */
			0x9a,		/* 154 */
/* 360 */	
			0x11, 0x0,	/* FC_RP */
/* 362 */	NdrFcShort( 0x14 ),	/* Offset= 20 (382) */
/* 364 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 366 */	NdrFcLong( 0x9b7de9a9 ),	/* -1686246999 */
/* 370 */	NdrFcShort( 0xbd59 ),	/* -17063 */
/* 372 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 374 */	0x92,		/* 146 */
			0x38,		/* 56 */
/* 376 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 378 */	0x24,		/* 36 */
			0x48,		/* 72 */
/* 380 */	0x79,		/* 121 */
			0x9a,		/* 154 */
/* 382 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 384 */	NdrFcShort( 0x0 ),	/* 0 */
/* 386 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 388 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 390 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 392 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 394 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 396 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (364) */
/* 398 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 400 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 402 */	NdrFcShort( 0x2 ),	/* Offset= 2 (404) */
/* 404 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 406 */	NdrFcLong( 0xb34e469b ),	/* -1286715749 */
/* 410 */	NdrFcShort( 0xbd59 ),	/* -17063 */
/* 412 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 414 */	0x92,		/* 146 */
			0x38,		/* 56 */
/* 416 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 418 */	0x24,		/* 36 */
			0x48,		/* 72 */
/* 420 */	0x79,		/* 121 */
			0x9a,		/* 154 */
/* 422 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 424 */	NdrFcShort( 0x2 ),	/* Offset= 2 (426) */
/* 426 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 428 */	NdrFcLong( 0xf6f94d1a ),	/* -151433958 */
/* 432 */	NdrFcShort( 0x78c2 ),	/* 30914 */
/* 434 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 436 */	0x8f,		/* 143 */
			0xfe,		/* 254 */
/* 438 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 440 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 442 */	0x83,		/* 131 */
			0x14,		/* 20 */
/* 444 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 446 */	NdrFcShort( 0x4e ),	/* Offset= 78 (524) */
/* 448 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 450 */	NdrFcLong( 0x69d172ef ),	/* 1775334127 */
/* 454 */	NdrFcShort( 0xf2c4 ),	/* -3388 */
/* 456 */	NdrFcShort( 0x44e1 ),	/* 17633 */
/* 458 */	0x89,		/* 137 */
			0xf7,		/* 247 */
/* 460 */	0xc8,		/* 200 */
			0x62,		/* 98 */
/* 462 */	0x31,		/* 49 */
			0xe7,		/* 231 */
/* 464 */	0x6,		/* 6 */
			0xe9,		/* 233 */
/* 466 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 468 */	NdrFcShort( 0x4 ),	/* 4 */
/* 470 */	NdrFcShort( 0x2 ),	/* 2 */
/* 472 */	NdrFcLong( 0x1 ),	/* 1 */
/* 476 */	NdrFcShort( 0x1c ),	/* Offset= 28 (504) */
/* 478 */	NdrFcLong( 0x2 ),	/* 2 */
/* 482 */	NdrFcShort( 0x24 ),	/* Offset= 36 (518) */
/* 484 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 486 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 488 */	NdrFcLong( 0xf6f94d20 ),	/* -151433952 */
/* 492 */	NdrFcShort( 0x78c2 ),	/* 30914 */
/* 494 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 496 */	0x8f,		/* 143 */
			0xfe,		/* 254 */
/* 498 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 500 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 502 */	0x83,		/* 131 */
			0x14,		/* 20 */
/* 504 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 506 */	NdrFcShort( 0x4 ),	/* 4 */
/* 508 */	NdrFcShort( 0x0 ),	/* 0 */
/* 510 */	NdrFcShort( 0x8 ),	/* Offset= 8 (518) */
/* 512 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 514 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (486) */
/* 516 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 518 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 520 */	NdrFcShort( 0x4 ),	/* 4 */
/* 522 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 524 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 526 */	NdrFcShort( 0xc ),	/* 12 */
/* 528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 530 */	NdrFcShort( 0xc ),	/* Offset= 12 (542) */
/* 532 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 534 */	NdrFcShort( 0xffffffaa ),	/* Offset= -86 (448) */
/* 536 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 538 */	NdrFcShort( 0xffffffb8 ),	/* Offset= -72 (466) */
/* 540 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 542 */	
			0x11, 0x0,	/* FC_RP */
/* 544 */	NdrFcShort( 0x14 ),	/* Offset= 20 (564) */
/* 546 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 548 */	NdrFcLong( 0x8706233b ),	/* -2029640901 */
/* 552 */	NdrFcShort( 0xbd4c ),	/* -17076 */
/* 554 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 556 */	0x92,		/* 146 */
			0x38,		/* 56 */
/* 558 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 560 */	0x24,		/* 36 */
			0x48,		/* 72 */
/* 562 */	0x79,		/* 121 */
			0x9a,		/* 154 */
/* 564 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 566 */	NdrFcShort( 0x0 ),	/* 0 */
/* 568 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 570 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 572 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 576 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 578 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (546) */
/* 580 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 582 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 584 */	NdrFcLong( 0x6d5140c1 ),	/* 1834041537 */
/* 588 */	NdrFcShort( 0x7436 ),	/* 29750 */
/* 590 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 592 */	0x80,		/* 128 */
			0x34,		/* 52 */
/* 594 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 596 */	0x0,		/* 0 */
			0x60,		/* 96 */
/* 598 */	0x9,		/* 9 */
			0xfa,		/* 250 */
/* 600 */	
			0x11, 0x0,	/* FC_RP */
/* 602 */	NdrFcShort( 0x14 ),	/* Offset= 20 (622) */
/* 604 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 606 */	NdrFcLong( 0xf6f94d0e ),	/* -151433970 */
/* 610 */	NdrFcShort( 0x78c2 ),	/* 30914 */
/* 612 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 614 */	0x8f,		/* 143 */
			0xfe,		/* 254 */
/* 616 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 618 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 620 */	0x83,		/* 131 */
			0x14,		/* 20 */
/* 622 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 624 */	NdrFcShort( 0x0 ),	/* 0 */
/* 626 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 628 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 630 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 632 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 634 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 636 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (604) */
/* 638 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 640 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 642 */	NdrFcShort( 0x2 ),	/* Offset= 2 (644) */
/* 644 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 646 */	NdrFcLong( 0xf6f94d1a ),	/* -151433958 */
/* 650 */	NdrFcShort( 0x78c2 ),	/* 30914 */
/* 652 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 654 */	0x8f,		/* 143 */
			0xfe,		/* 254 */
/* 656 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 658 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 660 */	0x83,		/* 131 */
			0x14,		/* 20 */
/* 662 */	
			0x11, 0x0,	/* FC_RP */
/* 664 */	NdrFcShort( 0x14 ),	/* Offset= 20 (684) */
/* 666 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 668 */	NdrFcLong( 0x1cf2b120 ),	/* 485667104 */
/* 672 */	NdrFcShort( 0x547d ),	/* 21629 */
/* 674 */	NdrFcShort( 0x101b ),	/* 4123 */
/* 676 */	0x8e,		/* 142 */
			0x65,		/* 101 */
/* 678 */	0x8,		/* 8 */
			0x0,		/* 0 */
/* 680 */	0x2b,		/* 43 */
			0x2b,		/* 43 */
/* 682 */	0xd1,		/* 209 */
			0x19,		/* 25 */
/* 684 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 688 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 690 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 692 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 694 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 696 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 698 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (666) */
/* 700 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 702 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 704 */	NdrFcShort( 0x2 ),	/* Offset= 2 (706) */
/* 706 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 708 */	NdrFcLong( 0xf6f94d23 ),	/* -151433949 */
/* 712 */	NdrFcShort( 0x78c2 ),	/* 30914 */
/* 714 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 716 */	0x8f,		/* 143 */
			0xfe,		/* 254 */
/* 718 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 720 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 722 */	0x83,		/* 131 */
			0x14,		/* 20 */
/* 724 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 726 */	NdrFcLong( 0xc ),	/* 12 */
/* 730 */	NdrFcShort( 0x0 ),	/* 0 */
/* 732 */	NdrFcShort( 0x0 ),	/* 0 */
/* 734 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 736 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 738 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 740 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 742 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 744 */	NdrFcShort( 0xfffffd3a ),	/* Offset= -710 (34) */
/* 746 */	
			0x11, 0x0,	/* FC_RP */
/* 748 */	NdrFcShort( 0x2 ),	/* Offset= 2 (750) */
/* 750 */	
			0x1c,		/* FC_CVARRAY */
			0x0,		/* 0 */
/* 752 */	NdrFcShort( 0x1 ),	/* 1 */
/* 754 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 756 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 758 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 760 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 762 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 764 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 766 */	NdrFcShort( 0xc ),	/* 12 */
/* 768 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 770 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 772 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 774 */	NdrFcShort( 0xc ),	/* 12 */
/* 776 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 778 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 780 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 782 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (764) */
/* 784 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 786 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 788 */	NdrFcShort( 0x2 ),	/* Offset= 2 (790) */
/* 790 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 792 */	NdrFcLong( 0xc2e34eaf ),	/* -1025290577 */
/* 796 */	NdrFcShort( 0x8b9d ),	/* -29795 */
/* 798 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 800 */	0x90,		/* 144 */
			0x14,		/* 20 */
/* 802 */	0x0,		/* 0 */
			0xc0,		/* 192 */
/* 804 */	0x4f,		/* 79 */
			0xa3,		/* 163 */
/* 806 */	0x83,		/* 131 */
			0x38,		/* 56 */
/* 808 */	
			0x11, 0x0,	/* FC_RP */
/* 810 */	NdrFcShort( 0x14 ),	/* Offset= 20 (830) */
/* 812 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 814 */	NdrFcLong( 0x8706233b ),	/* -2029640901 */
/* 818 */	NdrFcShort( 0xbd4c ),	/* -17076 */
/* 820 */	NdrFcShort( 0x11d2 ),	/* 4562 */
/* 822 */	0x92,		/* 146 */
			0x38,		/* 56 */
/* 824 */	0x0,		/* 0 */
			0xa0,		/* 160 */
/* 826 */	0x24,		/* 36 */
			0x48,		/* 72 */
/* 828 */	0x79,		/* 121 */
			0x9a,		/* 154 */
/* 830 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 832 */	NdrFcShort( 0x0 ),	/* 0 */
/* 834 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 836 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 838 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 842 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 844 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (812) */
/* 846 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 848 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 850 */	NdrFcShort( 0x2 ),	/* Offset= 2 (852) */
/* 852 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 854 */	NdrFcLong( 0x101 ),	/* 257 */
/* 858 */	NdrFcShort( 0x0 ),	/* 0 */
/* 860 */	NdrFcShort( 0x0 ),	/* 0 */
/* 862 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 864 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 866 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 868 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 870 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 872 */	NdrFcShort( 0x4 ),	/* 4 */
/* 874 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 876 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 878 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 880 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 882 */	NdrFcShort( 0x4 ),	/* 4 */
/* 884 */	NdrFcShort( 0x0 ),	/* 0 */
/* 886 */	NdrFcShort( 0x1 ),	/* 1 */
/* 888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 890 */	NdrFcShort( 0x0 ),	/* 0 */
/* 892 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 894 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 896 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 898 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 900 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 902 */	NdrFcShort( 0x2 ),	/* Offset= 2 (904) */
/* 904 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 906 */	NdrFcLong( 0xa7ee3e7e ),	/* -1477558658 */
/* 910 */	NdrFcShort( 0x2dd2 ),	/* 11730 */
/* 912 */	NdrFcShort( 0x4ad7 ),	/* 19159 */
/* 914 */	0x96,		/* 150 */
			0x97,		/* 151 */
/* 916 */	0xf4,		/* 244 */
			0xaa,		/* 170 */
/* 918 */	0xe3,		/* 227 */
			0x42,		/* 66 */
/* 920 */	0x77,		/* 119 */
			0x62,		/* 98 */
/* 922 */	
			0x11, 0x0,	/* FC_RP */
/* 924 */	NdrFcShort( 0x2 ),	/* Offset= 2 (926) */
/* 926 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 928 */	NdrFcShort( 0x1 ),	/* 1 */
/* 930 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 932 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 934 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 936 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 938 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 940 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 942 */	NdrFcShort( 0x4 ),	/* 4 */
/* 944 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 946 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 948 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 950 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 952 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 954 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 956 */	NdrFcShort( 0x4 ),	/* 4 */
/* 958 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 960 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 962 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 964 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 966 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 968 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 970 */	NdrFcShort( 0x4 ),	/* 4 */
/* 972 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 974 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 976 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 978 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 980 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 982 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 984 */	NdrFcShort( 0x10 ),	/* 16 */
/* 986 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 988 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 990 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 992 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 994 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 996 */	NdrFcShort( 0xfffffc3e ),	/* Offset= -962 (34) */
/* 998 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1000 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 1002 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1004 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1006 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1008 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1010 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1012 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1014 */	NdrFcShort( 0xfffffc2c ),	/* Offset= -980 (34) */
/* 1016 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1018 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 1020 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1022 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1024 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1026 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1028 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1030 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1032 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x4a,		/* FC_VARIABLE_OFFSET */
/* 1034 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1036 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1038 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1040 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1042 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1044 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1046 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1048 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1050 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1052 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 1054 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1056 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1058 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1060 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1062 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1064 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1066 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x4a,		/* FC_VARIABLE_OFFSET */
/* 1068 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1070 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1072 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1074 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1076 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1078 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1080 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1082 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1084 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1086 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 1088 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1090 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1092 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1094 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1096 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1098 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1100 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x4a,		/* FC_VARIABLE_OFFSET */
/* 1102 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1104 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1106 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1112 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1114 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1116 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1118 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1120 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 1122 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1124 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1126 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1128 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1130 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1132 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1134 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x4a,		/* FC_VARIABLE_OFFSET */
/* 1136 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1138 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1140 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1146 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1148 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1150 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1152 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1154 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 1156 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1158 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1160 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 1162 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1164 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 1166 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1168 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x4a,		/* FC_VARIABLE_OFFSET */
/* 1170 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1172 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1174 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1180 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1182 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1184 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1186 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1188 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 1190 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1192 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1194 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 1196 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1198 */	NdrFcShort( 0x30 ),	/* x86 Stack size/offset = 48 */
/* 1200 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1202 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x4a,		/* FC_VARIABLE_OFFSET */
/* 1204 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1208 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1210 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1214 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1216 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1218 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1220 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1222 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 1224 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1226 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1228 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1230 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1232 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1234 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1236 */	
			0x11, 0x0,	/* FC_RP */
/* 1238 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1240) */
/* 1240 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1242 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1244 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1246 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1248 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1250 */	
			0x11, 0x0,	/* FC_RP */
/* 1252 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1254) */
/* 1254 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1256 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1258 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1260 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1262 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1264 */	
			0x11, 0x0,	/* FC_RP */
/* 1266 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1268) */
/* 1268 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1270 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1272 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1274 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1276 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1278 */	
			0x1c,		/* FC_CVARRAY */
			0x3,		/* 3 */
/* 1280 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1282 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1284 */	NdrFcShort( 0x34 ),	/* x86 Stack size/offset = 52 */
/* 1286 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1288 */	NdrFcShort( 0x34 ),	/* x86 Stack size/offset = 52 */
/* 1290 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1292 */	
			0x11, 0x0,	/* FC_RP */
/* 1294 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1296) */
/* 1296 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1298 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1300 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1302 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1304 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1306 */	
			0x11, 0x0,	/* FC_RP */
/* 1308 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1310) */
/* 1310 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1312 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1314 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1316 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1318 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1320 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1322 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };



/* Standard interface: __MIDL_itf_enc_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDebugENC, ver. 0.0,
   GUID={0xB104D8B7,0xAF19,0x11d2,{0x92,0x2C,0x00,0xA0,0x24,0x48,0x79,0x9A}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugENC_FormatStringOffsetTable[] =
    {
    0,
    28,
    56,
    90,
    124,
    152,
    204,
    256,
    296,
    324,
    346,
    374,
    402,
    436,
    470
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugENC_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugENC_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugENC_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugENC_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(18) _IDebugENCProxyVtbl = 
{
    &IDebugENC_ProxyInfo,
    &IID_IDebugENC,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugENC::SetRegistryRoot */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::EnterDebuggingSession */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::SetENCProjectBuildOption */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::InquireENCState */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::InquireENCRelinkState */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::MapToEdited */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::MapToSuperceded */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::ApplyCodeChanges */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::CancelApplyCodeChanges */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::LeaveDebuggingSession */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::AdviseENCStateEvents */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::UnadviseENCStateEvents */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::GetFileName */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::GetFileDisplayName */ ,
    (void *) (INT_PTR) -1 /* IDebugENC::ClearENCState */
};

const CInterfaceStubVtbl _IDebugENCStubVtbl =
{
    &IID_IDebugENC,
    &IDebugENC_ServerInfo,
    18,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugENCLineMap, ver. 0.0,
   GUID={0x8706233B,0xBD4C,0x11d2,{0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugENCLineMap_FormatStringOffsetTable[] =
    {
    492,
    520,
    548,
    576,
    610
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugENCLineMap_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugENCLineMap_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugENCLineMap_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugENCLineMap_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IDebugENCLineMapProxyVtbl = 
{
    &IDebugENCLineMap_ProxyInfo,
    &IID_IDebugENCLineMap,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugENCLineMap::GetEditedSource */ ,
    (void *) (INT_PTR) -1 /* IDebugENCLineMap::GetSupercededSource */ ,
    (void *) (INT_PTR) -1 /* IDebugENCLineMap::IsLineModified */ ,
    (void *) (INT_PTR) -1 /* IDebugENCLineMap::LineMap */ ,
    (void *) (INT_PTR) -1 /* IDebugENCLineMap::ReverseLineMap */
};

const CInterfaceStubVtbl _IDebugENCLineMapStubVtbl =
{
    &IID_IDebugENCLineMap,
    &IDebugENCLineMap_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_enc_0373, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDebugENCInfo2, ver. 0.0,
   GUID={0x6B56106F,0xBD51,0x11d2,{0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugENCInfo2_FormatStringOffsetTable[] =
    {
    644
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugENCInfo2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugENCInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugENCInfo2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugENCInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugENCInfo2ProxyVtbl = 
{
    &IDebugENCInfo2_ProxyInfo,
    &IID_IDebugENCInfo2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugENCInfo2::GetInfo */
};

const CInterfaceStubVtbl _IDebugENCInfo2StubVtbl =
{
    &IID_IDebugENCInfo2,
    &IDebugENCInfo2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugENCInfo2, ver. 0.0,
   GUID={0x7B076AD1,0xBD51,0x11d2,{0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugENCInfo2_FormatStringOffsetTable[] =
    {
    672,
    712,
    740,
    762,
    790
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugENCInfo2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugENCInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugENCInfo2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugENCInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugENCInfo2ProxyVtbl = 
{
    &IEnumDebugENCInfo2_ProxyInfo,
    &IID_IEnumDebugENCInfo2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCInfo2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCInfo2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCInfo2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCInfo2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCInfo2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugENCInfo2StubVtbl =
{
    &IID_IEnumDebugENCInfo2,
    &IEnumDebugENCInfo2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugENCRelinkInfo2, ver. 0.0,
   GUID={0xCBB63A8D,0xBD57,0x11d2,{0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugENCRelinkInfo2_FormatStringOffsetTable[] =
    {
    818
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugENCRelinkInfo2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugENCRelinkInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugENCRelinkInfo2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugENCRelinkInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugENCRelinkInfo2ProxyVtbl = 
{
    &IDebugENCRelinkInfo2_ProxyInfo,
    &IID_IDebugENCRelinkInfo2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugENCRelinkInfo2::GetInfo */
};

const CInterfaceStubVtbl _IDebugENCRelinkInfo2StubVtbl =
{
    &IID_IDebugENCRelinkInfo2,
    &IDebugENCRelinkInfo2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugENCRelinkInfo2, ver. 0.0,
   GUID={0xE51BE743,0xBD57,0x11d2,{0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugENCRelinkInfo2_FormatStringOffsetTable[] =
    {
    870,
    712,
    740,
    910,
    790
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugENCRelinkInfo2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugENCRelinkInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugENCRelinkInfo2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugENCRelinkInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugENCRelinkInfo2ProxyVtbl = 
{
    &IEnumDebugENCRelinkInfo2_ProxyInfo,
    &IID_IEnumDebugENCRelinkInfo2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCRelinkInfo2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCRelinkInfo2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCRelinkInfo2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCRelinkInfo2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCRelinkInfo2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugENCRelinkInfo2StubVtbl =
{
    &IID_IEnumDebugENCRelinkInfo2,
    &IEnumDebugENCRelinkInfo2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugIDBInfo2, ver. 0.0,
   GUID={0x9B7DE9A9,0xBD59,0x11d2,{0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugIDBInfo2_FormatStringOffsetTable[] =
    {
    492
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugIDBInfo2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugIDBInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugIDBInfo2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugIDBInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugIDBInfo2ProxyVtbl = 
{
    &IDebugIDBInfo2_ProxyInfo,
    &IID_IDebugIDBInfo2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugIDBInfo2::GetInfo */
};

const CInterfaceStubVtbl _IDebugIDBInfo2StubVtbl =
{
    &IID_IDebugIDBInfo2,
    &IDebugIDBInfo2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugIDBInfo2, ver. 0.0,
   GUID={0xB34E469B,0xBD59,0x11d2,{0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugIDBInfo2_FormatStringOffsetTable[] =
    {
    938,
    712,
    740,
    978,
    790
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugIDBInfo2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugIDBInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugIDBInfo2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugIDBInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugIDBInfo2ProxyVtbl = 
{
    &IEnumDebugIDBInfo2_ProxyInfo,
    &IID_IEnumDebugIDBInfo2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugIDBInfo2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugIDBInfo2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugIDBInfo2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugIDBInfo2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugIDBInfo2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugIDBInfo2StubVtbl =
{
    &IID_IEnumDebugIDBInfo2,
    &IEnumDebugIDBInfo2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugENCBuildInfo2, ver. 0.0,
   GUID={0xEA70281B,0xBD58,0x11d2,{0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugENCBuildInfo2_FormatStringOffsetTable[] =
    {
    1006,
    1052,
    1080
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugENCBuildInfo2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugENCBuildInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugENCBuildInfo2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugENCBuildInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IDebugENCBuildInfo2ProxyVtbl = 
{
    &IDebugENCBuildInfo2_ProxyInfo,
    &IID_IDebugENCBuildInfo2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugENCBuildInfo2::GetTargetBuildInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugENCBuildInfo2::IsTargetEligible */ ,
    (void *) (INT_PTR) -1 /* IDebugENCBuildInfo2::EnumDebugIDBInfo */
};

const CInterfaceStubVtbl _IDebugENCBuildInfo2StubVtbl =
{
    &IID_IDebugENCBuildInfo2,
    &IDebugENCBuildInfo2_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugENCUpdateOnRelinkEvent2, ver. 0.0,
   GUID={0x0EBF1959,0xBD57,0x11d2,{0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugENCUpdateOnRelinkEvent2_FormatStringOffsetTable[] =
    {
    1108
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugENCUpdateOnRelinkEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugENCUpdateOnRelinkEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugENCUpdateOnRelinkEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugENCUpdateOnRelinkEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugENCUpdateOnRelinkEvent2ProxyVtbl = 
{
    &IDebugENCUpdateOnRelinkEvent2_ProxyInfo,
    &IID_IDebugENCUpdateOnRelinkEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugENCUpdateOnRelinkEvent2::GetInfo */
};

const CInterfaceStubVtbl _IDebugENCUpdateOnRelinkEvent2StubVtbl =
{
    &IID_IDebugENCUpdateOnRelinkEvent2,
    &IDebugENCUpdateOnRelinkEvent2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugENCUpdateOnStaleCodeEvent2, ver. 0.0,
   GUID={0x2F01EB29,0xBD57,0x11d2,{0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugENCUpdateOnStaleCodeEvent2_FormatStringOffsetTable[] =
    {
    1136,
    1164
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugENCUpdateOnStaleCodeEvent2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugENCUpdateOnStaleCodeEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugENCUpdateOnStaleCodeEvent2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugENCUpdateOnStaleCodeEvent2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDebugENCUpdateOnStaleCodeEvent2ProxyVtbl = 
{
    &IDebugENCUpdateOnStaleCodeEvent2_ProxyInfo,
    &IID_IDebugENCUpdateOnStaleCodeEvent2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugENCUpdateOnStaleCodeEvent2::GetInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugENCUpdateOnStaleCodeEvent2::GetHResult */
};

const CInterfaceStubVtbl _IDebugENCUpdateOnStaleCodeEvent2StubVtbl =
{
    &IID_IDebugENCUpdateOnStaleCodeEvent2,
    &IDebugENCUpdateOnStaleCodeEvent2_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugENCUpdate, ver. 0.0,
   GUID={0x978BAEE7,0xBD4C,0x11d2,{0x92,0x38,0x00,0xA0,0x24,0x48,0x79,0x9A}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugENCUpdate_FormatStringOffsetTable[] =
    {
    1192,
    1226,
    740,
    1260
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugENCUpdate_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugENCUpdate_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugENCUpdate_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugENCUpdate_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IDebugENCUpdateProxyVtbl = 
{
    &IDebugENCUpdate_ProxyInfo,
    &IID_IDebugENCUpdate,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugENCUpdate::EnumENCSnapshots */ ,
    (void *) (INT_PTR) -1 /* IDebugENCUpdate::EnumENCSnapshotsByGuid */ ,
    (void *) (INT_PTR) -1 /* IDebugENCUpdate::CancelENC */ ,
    (void *) (INT_PTR) -1 /* IDebugENCUpdate::OnENCAttemptComplete */
};

const CInterfaceStubVtbl _IDebugENCUpdateStubVtbl =
{
    &IID_IDebugENCUpdate,
    &IDebugENCUpdate_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugENCSnapshot2, ver. 0.0,
   GUID={0xf6f94d0e,0x78c2,0x11d2,{0x8f,0xfe,0x00,0xc0,0x4f,0xa3,0x83,0x14}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugENCSnapshot2_FormatStringOffsetTable[] =
    {
    1282,
    1310,
    1362
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugENCSnapshot2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugENCSnapshot2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugENCSnapshot2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugENCSnapshot2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IDebugENCSnapshot2ProxyVtbl = 
{
    &IDebugENCSnapshot2_ProxyInfo,
    &IID_IDebugENCSnapshot2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugENCSnapshot2::GetENCSnapshotInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugENCSnapshot2::ApplyCodeChange */ ,
    (void *) (INT_PTR) -1 /* IDebugENCSnapshot2::CommitChange */
};

const CInterfaceStubVtbl _IDebugENCSnapshot2StubVtbl =
{
    &IID_IDebugENCSnapshot2,
    &IDebugENCSnapshot2_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugENCSnapshots2, ver. 0.0,
   GUID={0xf6f94d1a,0x78c2,0x11d2,{0x8f,0xfe,0x00,0xc0,0x4f,0xa3,0x83,0x14}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugENCSnapshots2_FormatStringOffsetTable[] =
    {
    1390,
    712,
    740,
    1430,
    790
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugENCSnapshots2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugENCSnapshots2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugENCSnapshots2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugENCSnapshots2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugENCSnapshots2ProxyVtbl = 
{
    &IEnumDebugENCSnapshots2_ProxyInfo,
    &IID_IEnumDebugENCSnapshots2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCSnapshots2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCSnapshots2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCSnapshots2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCSnapshots2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugENCSnapshots2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugENCSnapshots2StubVtbl =
{
    &IID_IEnumDebugENCSnapshots2,
    &IEnumDebugENCSnapshots2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IEnumDebugErrorInfos2, ver. 0.0,
   GUID={0xf6f94d23,0x78c2,0x11d2,{0x8f,0xfe,0x00,0xc0,0x4f,0xa3,0x83,0x14}} */

#pragma code_seg(".orpc")
static const unsigned short IEnumDebugErrorInfos2_FormatStringOffsetTable[] =
    {
    1458,
    712,
    740,
    1498,
    790
    };

static const MIDL_STUBLESS_PROXY_INFO IEnumDebugErrorInfos2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugErrorInfos2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IEnumDebugErrorInfos2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IEnumDebugErrorInfos2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IEnumDebugErrorInfos2ProxyVtbl = 
{
    &IEnumDebugErrorInfos2_ProxyInfo,
    &IID_IEnumDebugErrorInfos2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IEnumDebugErrorInfos2::Next */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugErrorInfos2::Skip */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugErrorInfos2::Reset */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugErrorInfos2::Clone */ ,
    (void *) (INT_PTR) -1 /* IEnumDebugErrorInfos2::GetCount */
};

const CInterfaceStubVtbl _IEnumDebugErrorInfos2StubVtbl =
{
    &IID_IEnumDebugErrorInfos2,
    &IEnumDebugErrorInfos2_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugComPlusSnapshot2, ver. 0.0,
   GUID={0xf6f94d20,0x78c2,0x11d2,{0x8f,0xfe,0x00,0xc0,0x4f,0xa3,0x83,0x14}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugComPlusSnapshot2_FormatStringOffsetTable[] =
    {
    1526,
    1560,
    1588,
    1616,
    1644,
    1678,
    1718,
    1752,
    1780,
    1814,
    1842
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugComPlusSnapshot2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugComPlusSnapshot2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugComPlusSnapshot2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugComPlusSnapshot2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(14) _IDebugComPlusSnapshot2ProxyVtbl = 
{
    &IDebugComPlusSnapshot2_ProxyInfo,
    &IID_IDebugComPlusSnapshot2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSnapshot2::CopyMetaData */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSnapshot2::GetMvid */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSnapshot2::GetRoDataRVA */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSnapshot2::GetRwDataRVA */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSnapshot2::SetPEBytes */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSnapshot2::SetILMap */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSnapshot2::SetSymbolBytes */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSnapshot2::GetSymbolProvider */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSnapshot2::GetAppDomainAndModuleIDs */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSnapshot2::RequestILMap */ ,
    (void *) (INT_PTR) -1 /* IDebugComPlusSnapshot2::CreateILMaps */
};

const CInterfaceStubVtbl _IDebugComPlusSnapshot2StubVtbl =
{
    &IID_IDebugComPlusSnapshot2,
    &IDebugComPlusSnapshot2_ServerInfo,
    14,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugNativeSnapshot2, ver. 0.0,
   GUID={0x461fda3e,0xbba5,0x11d2,{0xb1,0x0f,0x00,0xc0,0x4f,0x72,0xdc,0x32}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugNativeSnapshot2_FormatStringOffsetTable[] =
    {
    0,
    1876,
    1910,
    1950,
    2002,
    2030,
    2058
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugNativeSnapshot2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugNativeSnapshot2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugNativeSnapshot2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugNativeSnapshot2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(10) _IDebugNativeSnapshot2ProxyVtbl = 
{
    &IDebugNativeSnapshot2_ProxyInfo,
    &IID_IDebugNativeSnapshot2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugNativeSnapshot2::HasDependentTargets */ ,
    (void *) (INT_PTR) -1 /* IDebugNativeSnapshot2::EnumDependentImages */ ,
    (void *) (INT_PTR) -1 /* IDebugNativeSnapshot2::EnumDependentTargets */ ,
    (void *) (INT_PTR) -1 /* IDebugNativeSnapshot2::GetTargetBuildInfo */ ,
    (void *) (INT_PTR) -1 /* IDebugNativeSnapshot2::Notify */ ,
    (void *) (INT_PTR) -1 /* IDebugNativeSnapshot2::IsTargetEligible */ ,
    (void *) (INT_PTR) -1 /* IDebugNativeSnapshot2::AddRecompiledTarget */
};

const CInterfaceStubVtbl _IDebugNativeSnapshot2StubVtbl =
{
    &IID_IDebugNativeSnapshot2,
    &IDebugNativeSnapshot2_ServerInfo,
    10,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugENCStackFrame2, ver. 0.0,
   GUID={0xB3C64D7F,0xDB9D,0x47c7,{0xB4,0x79,0xC5,0x79,0xC7,0xF0,0x71,0x03}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugENCStackFrame2_FormatStringOffsetTable[] =
    {
    2092
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugENCStackFrame2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugENCStackFrame2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugENCStackFrame2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugENCStackFrame2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugENCStackFrame2ProxyVtbl = 
{
    &IDebugENCStackFrame2_ProxyInfo,
    &IID_IDebugENCStackFrame2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugENCStackFrame2::GetAllLocalsProperty */
};

const CInterfaceStubVtbl _IDebugENCStackFrame2StubVtbl =
{
    &IID_IDebugENCStackFrame2,
    &IDebugENCStackFrame2_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_enc_0389, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDebugMetaDataEmit2, ver. 0.0,
   GUID={0xf6f94d21,0x78c2,0x11d2,{0x8f,0xfe,0x00,0xc0,0x4f,0xa3,0x83,0x14}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugMetaDataEmit2_FormatStringOffsetTable[] =
    {
    2120,
    2160,
    2194,
    576,
    2228,
    2280,
    2374,
    2450,
    2502,
    2536,
    2570,
    2640,
    2680,
    2732,
    2772,
    2812,
    2912,
    2964,
    3040,
    3116,
    3186,
    3238,
    3278,
    3318,
    3370,
    3422,
    3462,
    3592,
    3674,
    3714,
    3766,
    3800,
    3840,
    3886,
    3920
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugMetaDataEmit2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugMetaDataEmit2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugMetaDataEmit2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugMetaDataEmit2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(38) _IDebugMetaDataEmit2ProxyVtbl = 
{
    &IDebugMetaDataEmit2_ProxyInfo,
    &IID_IDebugMetaDataEmit2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetModuleProps */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::Save */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SaveToStream */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::GetSaveSize */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::DefineCustomValueAsBlob */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::DefineTypeDef */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetTypeDefProps */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetClassSvcsContext */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::DefineTypeRefByGUID */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetModuleReg */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetClassReg */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetIfaceReg */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetCategoryImpl */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetRedirectProgID */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetMimeTypeImpl */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetFormatImpl */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetRoleCheck */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::DefineMethod */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::DefineField */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetParamProps */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::DefineMethodImpl */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetRVA */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::DefineTypeRefByName */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetTypeRefBind */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::DefineMemberRef */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::DefineException */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::DefineProperty */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::DefineEvent */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetFieldMarshal */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::DefinePermissionSet */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetMemberIndex */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::GetTokenFromSig */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::DefineModuleRef */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::SetParent */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataEmit2::GetTokenFromArraySpec */
};

const CInterfaceStubVtbl _IDebugMetaDataEmit2StubVtbl =
{
    &IID_IDebugMetaDataEmit2,
    &IDebugMetaDataEmit2_ServerInfo,
    38,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugMetaDataDebugEmit2, ver. 0.0,
   GUID={0xf6f94d22,0x78c2,0x11d2,{0x8f,0xfe,0x00,0xc0,0x4f,0xa3,0x83,0x14}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugMetaDataDebugEmit2_FormatStringOffsetTable[] =
    {
    3960,
    3994,
    4040
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugMetaDataDebugEmit2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugMetaDataDebugEmit2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugMetaDataDebugEmit2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugMetaDataDebugEmit2_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IDebugMetaDataDebugEmit2ProxyVtbl = 
{
    &IDebugMetaDataDebugEmit2_ProxyInfo,
    &IID_IDebugMetaDataDebugEmit2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataDebugEmit2::DefineSourceFile */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataDebugEmit2::DefineBlock */ ,
    (void *) (INT_PTR) -1 /* IDebugMetaDataDebugEmit2::DefineLocalVarScope */
};

const CInterfaceStubVtbl _IDebugMetaDataDebugEmit2StubVtbl =
{
    &IID_IDebugMetaDataDebugEmit2,
    &IDebugMetaDataDebugEmit2_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDebugENCStateEvents, ver. 0.0,
   GUID={0xec80d064,0x102e,0x435f,{0xaa,0xfb,0xd3,0x7e,0x2a,0x4e,0xf6,0x54}} */

#pragma code_seg(".orpc")
static const unsigned short IDebugENCStateEvents_FormatStringOffsetTable[] =
    {
    4092
    };

static const MIDL_STUBLESS_PROXY_INFO IDebugENCStateEvents_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDebugENCStateEvents_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IDebugENCStateEvents_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDebugENCStateEvents_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDebugENCStateEventsProxyVtbl = 
{
    &IDebugENCStateEvents_ProxyInfo,
    &IID_IDebugENCStateEvents,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IDebugENCStateEvents::OnStateChange */
};

const CInterfaceStubVtbl _IDebugENCStateEventsStubVtbl =
{
    &IID_IDebugENCStateEvents,
    &IDebugENCStateEvents_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _enc_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IDebugENCSnapshot2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugENCSnapshots2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugENCBuildInfo2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugComPlusSnapshot2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugMetaDataEmit2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugMetaDataDebugEmit2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugErrorInfos2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugENCUpdateOnStaleCodeEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugENCLineMapProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugNativeSnapshot2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugENCRelinkInfo2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugENCUpdateOnRelinkEvent2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugENCStateEventsProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugENCInfo2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugENCStackFrame2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugENCRelinkInfo2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugIDBInfo2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugIDBInfo2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugENCProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IEnumDebugENCInfo2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDebugENCUpdateProxyVtbl,
    0
};

const CInterfaceStubVtbl * _enc_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IDebugENCSnapshot2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugENCSnapshots2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugENCBuildInfo2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugComPlusSnapshot2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugMetaDataEmit2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugMetaDataDebugEmit2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugErrorInfos2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugENCUpdateOnStaleCodeEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugENCLineMapStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugNativeSnapshot2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugENCRelinkInfo2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugENCUpdateOnRelinkEvent2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugENCStateEventsStubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugENCInfo2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugENCStackFrame2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugENCRelinkInfo2StubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugIDBInfo2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugIDBInfo2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugENCStubVtbl,
    ( CInterfaceStubVtbl *) &_IEnumDebugENCInfo2StubVtbl,
    ( CInterfaceStubVtbl *) &_IDebugENCUpdateStubVtbl,
    0
};

PCInterfaceName const _enc_InterfaceNamesList[] = 
{
    "IDebugENCSnapshot2",
    "IEnumDebugENCSnapshots2",
    "IDebugENCBuildInfo2",
    "IDebugComPlusSnapshot2",
    "IDebugMetaDataEmit2",
    "IDebugMetaDataDebugEmit2",
    "IEnumDebugErrorInfos2",
    "IDebugENCUpdateOnStaleCodeEvent2",
    "IDebugENCLineMap",
    "IDebugNativeSnapshot2",
    "IEnumDebugENCRelinkInfo2",
    "IDebugENCUpdateOnRelinkEvent2",
    "IDebugENCStateEvents",
    "IDebugENCInfo2",
    "IDebugENCStackFrame2",
    "IDebugENCRelinkInfo2",
    "IEnumDebugIDBInfo2",
    "IDebugIDBInfo2",
    "IDebugENC",
    "IEnumDebugENCInfo2",
    "IDebugENCUpdate",
    0
};


#define _enc_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _enc, pIID, n)

int __stdcall _enc_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _enc, 21, 16 )
    IID_BS_LOOKUP_NEXT_TEST( _enc, 8 )
    IID_BS_LOOKUP_NEXT_TEST( _enc, 4 )
    IID_BS_LOOKUP_NEXT_TEST( _enc, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _enc, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _enc, 21, *pIndex )
    
}

const ExtendedProxyFileInfo enc_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _enc_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _enc_StubVtblList,
    (const PCInterfaceName * ) & _enc_InterfaceNamesList,
    0, // no delegation
    & _enc_IID_Lookup, 
    21,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\env\misc\pkgs\solution\obj\i386\vssln.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:03 2002
 */
/* Compiler settings for vssln.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_VsSolutionPackageLib,0x44356D61,0x8CDE,0x11D0,0x8A,0x34,0x00,0xA0,0xC9,0x1E,0x2A,0xCD);


MIDL_DEFINE_GUID(CLSID, CLSID_VS_SOLUTION_PACKAGE,0x282BD676,0x8B5B,0x11D0,0x8A,0x34,0x00,0xA0,0xC9,0x1E,0x2A,0xCD);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\cvtypes.h ===
//  CVTYPES.H
//
//  This file contains a common set of base type declarations
//  between multiple CodeView projects.  If you touch this in one
//  project be sure to copy it to all other projects as well.

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef CV_PROJECT_BASE_TYPES
#define CV_PROJECT_BASE_TYPES

//#if !defined(DOLPHIN)
//#include "dbapiver.h"
//#endif

#pragma once

#include "types.h"
#include "util\debug.h"

typedef HANDLE HDEP;				// handle on host platform
typedef DWORDLONG HIND;				// type that works on all platforms

typedef HDEP FAR *  LPHDEP;
typedef HIND FAR *  LPHIND;

// HMEM should be avoided (HDEP should be used instead), but for now we'll
// define it for backwards compatibility.

typedef HDEP    HMEM;
typedef HMEM FAR *  LPHMEM;

typedef HIND HPID;
typedef HIND HTID;

DECLARE_HANDLE(HEMI);

typedef HPID FAR *LPHPID;
typedef HTID FAR *LPHTID;

// These values are used in the SegType field of the Expression Evaluator's
// TI structure, and as the third parameter to the Symbol Handler's
// SHGetNearestHsym function.

#define EECODE      0x01
#define EEDATA      0x02
#define EECLABEL    0x04
#define EEANYSEG    0xFFFF


typedef ULONG   SEGMENT;    // 32-bit compiler doesn't like "_segment"
typedef USHORT  SEG16;
typedef ULONG   SEG32;
typedef SEGMENT FAR * LPSEGMENT;
typedef ULONG   UOFF32;
typedef UOFF32 FAR * LPUOFF32;
typedef USHORT  UOFF16;
typedef UOFF16 FAR * LPUOFF16;
typedef LONG    OFF32;
typedef OFF32 FAR * LPOFF32;
typedef SHORT   OFF16;
typedef OFF16 FAR * LPOFF16;
typedef LONG64 OFF64;
typedef ULONG64 UOFF64;
typedef UOFF64 *LPUOFF64;

typedef UOFF64 UOFFSET;
typedef OFF64 OFFSET;
typedef UOFFSET FAR * LPUOFFSET;
typedef OFFSET FAR * LPOFFSET;

//  address definitions
//  the address packet is always a 16:32 address.

typedef struct {
	union {
		UOFF64		off64;
		UOFF32		off32;
	};
    SEGMENT     seg;
} address_t;

typedef struct {
    BYTE    fFlat   :1;         // true if address is flat
    BYTE    fOff32  :1;         // true if offset is 32 bits
    BYTE    fIsLI   :1;         // true if segment is linker index
    BYTE    fReal   :1;         // x86: is segment a real mode address
    BYTE    fOff64  :1;         // true if segment is 64 bits
    BYTE    unused  :3;         // unused
// OMNI
    BYTE    omnioff;            //used for omnibyte<->x86 addr conversion
// end OMNI
} memmode_t;

typedef struct ADDR {
    address_t   addr;
    union {
        DWORDLONG Align;
        HEMI        emi;
    };
    memmode_t   mode;
} ADDR, *PADDR, *LPADDR;                     // An address specifier

typedef const ADDR* LPCADDR;

#define addrAddr(a)         ((a).addr)
#define emiAddr(a)          ((a).emi)
#define modeAddr(a)         ((a).mode)

#define MODE_IS_FLAT(m)     ((m).fFlat)
#define MODE_IS_OFF32(m)    ((m).fOff32)
#define MODE_IS_LI(m)       ((m).fIsLI)
#define MODE_IS_REAL(m)     ((m).fReal)
#define MODE_IS_OFF64(m)    ((m).fOff64)

#define ADDR_IS_FLAT(a)     (MODE_IS_FLAT(modeAddr(a)))
#define ADDR_IS_OFF32(a)    (MODE_IS_OFF32(modeAddr(a)))
#define ADDR_IS_LI(a)       (MODE_IS_LI(modeAddr(a)))
#define ADDR_IS_REAL(a)     (MODE_IS_REAL(modeAddr(a)))
#define ADDR_IS_OFF64(a)    (MODE_IS_OFF64(modeAddr(a)))

#define ADDRSEG16(a)        {ADDR_IS_FLAT(a) = FALSE; ADDR_IS_OFF32(a) = FALSE; ADDR_IS_OFF64(a) = FALSE;}
#define ADDRSEG32(a)        {ADDR_IS_FLAT(a) = FALSE; ADDR_IS_OFF32(a) = TRUE; ADDR_IS_OFF64(a) = FALSE;}

#define ADDRLIN(a)			{ADDR_IS_FLAT(a) = TRUE;  ADDR_IS_REAL(a) = FALSE;}
#define ADDRLIN32(a)        {ADDRLIN(a);  ADDR_IS_OFF32(a) = TRUE;  ADDR_IS_OFF64(a) = FALSE;}
#define ADDRLIN64(a)        {ADDRLIN(a);  ADDR_IS_OFF32(a) = FALSE; ADDR_IS_OFF64(a) = TRUE;}

#define GetAddrSeg(a)       ((a).addr.seg)
#define SetAddrSeg(pa,s)    ((pa)->addr.seg = s)

#define GetAddrOff32(a)     ((a).addr.off32)
//
// Masked to not have RTC fires.
//
#define SetAddrOff32(pa,o)  ((pa)->addr.off32 = (UOFF32) (o & 0xFFFFFFFF))

#define GetAddrOff64(a)     ((a).addr.off64)
#define SetAddrOff64(pa,o)  ((pa)->addr.off64 = (UOFF64)(o))


//#define GetAddrOff(a)		(GetAddrOff64(a))
//#define SetAddrOff(pa,o)    { assert(                                             \
//		                       ADDR_IS_OFF64(*pa) + ADDR_IS_OFF32(*pa) == 1 || \
//							   GetAddrOff(*pa) == 0x0);                        \
//							  (SetAddrOff64(pa,o));                            \
//							  if (ADDR_IS_OFF32(*pa)) {\
//								  UOFFSET value = GetAddrOff64(*pa); \
//								  /* sign extension is OK */ \
//								  if (((value & 0xFFFFFFFF00000000) !=0) && \
//								      ((value & 0xFFFFFFFF00000000) != 0xFFFFFFFF00000000) \
//										  ) { \
//									  assert (!"32bit addr has non empty upper dword- fatal");\
//								  }\
//							  }\
//							}\



__inline
UOFFSET
GetAddrOff(
    ADDR addr
	)
{

	UOFFSET ret =  GetAddrOff64(addr);

#ifdef _DEBUG
	UOFFSET value =ret;

	// this shoudn't happen since upperDWORD is cleared out in SetAddrOff
	if (ADDR_IS_OFF32(addr) && (value & 0xFFFFFFFF00000000) !=0) { 
		Assert (!"32bit addr has non empty upper dword- fatal");
	}
#endif

	return ret;
}

__inline
void
SetAddrOff(
	LPADDR lpaddr,
	UOFFSET offset
	)
{
	Assert (ADDR_IS_OFF64(*lpaddr) + ADDR_IS_OFF32(*lpaddr) == 1 || 
			GetAddrOff(*lpaddr) == 0x0 || 
			!"Address cannot be 32 and 64 bit");


	//
	// clear upper DWROD for 32 bit values
	//
	if (ADDR_IS_OFF32(*lpaddr))  {
		offset &=0xFFFFFFFF;
	}
	SetAddrOff64(lpaddr,offset);
}



__inline
void
AddrInitEx(
    LPADDR paddr,
    HEMI emiSet,
    UOFFSET offset,
	BOOL f64,
    BOOL fLi
    )
{
	paddr->addr.seg = 0;
	paddr->emi = emiSet;
	paddr->mode.fFlat = TRUE;
	paddr->mode.fIsLI = (BYTE)fLi;
	paddr->mode.fOff64 = (BYTE)f64;
	paddr->mode.fOff32 = (BYTE)!f64;
	paddr->mode.fReal = FALSE;
	paddr->mode.omnioff = 0;
	paddr->mode.unused = 0;
	SetAddrOff(paddr,offset);

#if (defined(HOST_i386) && !defined(ENABLE_IA64_SUPPORT)) || defined (HOST_ALPHA) 
	assert (paddr->mode.fOff32 && !paddr->mode.fOff64 ||
			!"Incorrect address format");
#endif

#if defined(HOST_IA64)  || defined (HOST_AXP64) 
	//
	// (It is possible for 32 bit address to be present in 64 bit
	// eg UnFixedup Address? ADDR_IS_LI(addr) == 0) vvadimp - yes, addresses could be init'ed to 32-bit as LIs
	//
	assert (paddr->mode.fOff64 && !paddr->mode.fOff32  || paddr->mode.fIsLI ||
			!"Possibly incorrect address format");
#endif

}
__inline
void
AddrInit(
    LPADDR paddr,
    HEMI emiSet,
    SEGMENT segSet,
    UOFF64 offSet,
    BOOL fFlat,
    BOOL fOff32,
    BOOL fLi,
    BOOL fRealSet
    )
{
    assert(fRealSet == 0);
    AddrInitEx(paddr, emiSet, offSet, !fOff32, fLi);

    SetAddrSeg(paddr, segSet);
	paddr->mode.fFlat = (BYTE)fFlat;
	paddr->mode.fReal = (BYTE)fRealSet;
}

typedef struct FRAME {
    SEG16       SS;
    address_t   BP;
    SEG16       DS;
    memmode_t   mode;
    address_t   SLP;        // Static link pointer
    address_t   BSP;        // IA64 Back Store Pointer
} FRAME;
typedef FRAME *PFRAME;

#define addrFrameSS(a)     ((a).SS)
#define addrFrameBP(a)     ((a).BP)
#define addrFrameSLP(a)    ((a).SLP)
#define addrFrameBSP(a)	   ((a).BSP)

//#define GetFrameBPOff(a)   (MODE_IS_OFF64(FRAMEMODE(a))? addrFrameBP(a).off64: addrFrameBP(a). off32)
#define GetFrameBPOff(a)   (addrFrameBP(a).off64)
#define GetFrameBPSeg(a)   ((a).BP.seg)

//#define SetFrameBPOff(a,o) (MODE_IS_OFF64(FRAMEMODE(a))? addrFrameBP(a).off64 = (UOFF64) o : addrFrameBP(a). off32 = (UOFF32) o)
#define SetFrameBPOff(a,o) (addrFrameBP(a).off64 = (UOFF64)(o))
#define SetFrameBPSeg(a,s) ((a).BP.seg = s)

//#define GetFrameSLPOff(a) (MODE_IS_OFF64(FRAMEMODE(a))? addrFrameSLP(a).off64: addrFrameSLP(a).off32)
#define GetFrameSLPOff(a) (addrFrameSLP(a).off64)
#define GetFrameSLPSeg(a)  ((a).SLP.seg)

//#define SetFrameSLPOff(a,o) (MODE_IS_OFF64(FRAMEMODE(a))? addrFrameSLP(a).off64 = (UOFF64) o : addrFrameSLP(a). off32 = (UOFF32) o)
#define SetFrameSLPOff(a,o) (addrFrameSLP(a).off64 = (UOFF64)(o))
#define SetFrameSLPSeg(a,s) ((a).SLP.seg = s)

//#define GetFrameBSPOff(a) (MODE_IS_OFF64(FRAMEMODE(a))? addrFrameBSP(a).off64: addrFrameBSP(a).off32)
#define GetFrameBSPOff(a) (addrFrameBSP(a).off64)
#define GetFrameBSPSeg(a)  ((a).BSP.seg)

#define FRAMEMODE(a)       ((a).mode)
#define FrameLI(a)         MODE_IS_LI(FRAMEMODE(a))
#define FrameFlat(a)       MODE_IS_FLAT(FRAMEMODE(a))
#define FrameOff32(a)      MODE_IS_OFF32(FRAMEMODE(a))
#define FrameOff64(a)      MODE_IS_OFF64(FRAMEMODE(a))
#define FrameReal(a)       MODE_IS_REAL((FRAMEMODE(a))

//  A few public types related to the linked list manager

typedef HDEP    HLLI;       // A handle to a linked list
typedef HDEP    HLLE;       // A handle to a linked list entry

typedef void (FAR PASCAL * LPFNKILLNODE)(LPVOID);
typedef int  (FAR PASCAL * LPFNFCMPNODE)(LPVOID, LPVOID, LONG );

typedef DWORD          LLF;    // Linked List Flags
#define llfNull         (LLF)0x0
#define llfAscending    (LLF)0x1
#define llfDescending   (LLF)0x2
#define fCmpLT              (-1)
#define fCmpEQ              (0)
#define fCmpGT              (1)

//  EXPCALL indicates that a function should use whatever calling
//      convention is preferable for exported functions.

#define EXPCALL         __stdcall

typedef struct _MEMINFO {
    ADDR    addr;
    ADDR    addrAllocBase;
    UOFFSET uRegionSize;
    DWORD   dwProtect;
	DWORD   dwAllocationProtect;
    DWORD   dwState;
    DWORD   dwType;
} MEMINFO;
typedef MEMINFO FAR * LPMEMINFO;

//  Return values for mtrcProcessorType
typedef enum _MPT {
    mptUnknown = 0,
    mptix86  = 1,   // Intel X86
    mptm68k  = 2,   // Mac 68K
    mptdaxp  = 3,   // Alpha AXP
    mptmips  = 4,   // MIPS
    mptmppc  = 5,   // Mac PPC
    mptntppc = 6,   // NT PPC
	mptpegsh = 8,	// PEG SH
	mptpegmips = 9,	// PEG MIPS
	mptpegppc = 10,	// PEG PPC
	mptpegarm = 11,	// PEG ARM
	mptwin32nkpc = 12,	// PEG nkpc
	mptpegsh4 = 13,		// PEG SH4
// leave room for more WinCE types here
	mptia64 = 20,		// Intel Merced
	mptaxp64 = 21,		// Alpha 64-bit
} MPT;

#define CLEAR_UPPER_DWORD(x)                                   \
         Assert ((sizeof (x) >= 4  && sizeof(x)% 4 == 0) ||  \
				  !"Incorrect Usage");                       \
		 x = x & 0xFFFFFFFF


#include <dbgver.h>     // For AVS definition and support functions

#endif  // CV_PROJECT_BASE_TYPES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\dbgver.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dbgver.h

Abstract:

Author:

    Kent D. Forschmiedt (a-kentf) 25-Jan-1993

Environment:

    Win32, User Mode

--*/

#if ! defined _DBGVER_
#define _DBGVER_

#include <version.h>

/*
**  DBG_API_VERSION is the major version number used to specify the
**      api version of the debugger or debug dll.  For release versions
**      dlls will export this and debuggers will check against this
**      version to verify that it can use the dll.
**
**      For beta and debug versions, this number will be used in
**      conjunction with minor and revision numbers (probably derived
**      from SLM rmm & rup) to verify compatibility.
**
**      Until the API has stabilized, we will most likely have to
**      rev this version number for every major product release.
**
*/

#include "dbapiver.h"

/*  AVS - Api Version Structure:
**
**      All debug dlls should be prepared to return a pointer to this
**      structure conaining its vital statistics.  The debugger should
**      check first two characters of the dll's name against rgchType
**      and the version numbers as described in the DBG_API_VERSION
**      and show the user an error if any of these tests fail.
**
*/

typedef enum {
    rlvtRelease,
    rlvtBeta,
    rlvtDebug
} RLVT;     // ReLease Version Type

//
// WARNING!!!!
//
// For backward compatibility reasons - do not change the existing
// members of this structure in any WAY (name change ok / type /size change
// not ok)
//
// If new members need to be added - add to end of structure
//
// rajra
//

typedef struct _AVS {
    CHAR	rgchType [ 2 ];    // Component name (EE,EM,TL,SH,DM)
    WORD    rlvt;              // ReLease Version Type
    BYTE	iApiVer;           // DBG_API_VERSION
    BYTE	iApiSubVer;        // DBG_API_SUBVERSION
    WORD	iRup;              // Revision number
    DWORD	chBuild;           // Build of revision # (a,b,c,d)
    MPT		mpt;               // CPU binary is running on
    WORD	iRmj;              // Major version number
    WORD	iRmm;              // Minor version number
	union {
	LSZ		lszTitle;          // User readable text describing the DLL
	DWORDLONG Align;		   // make structure same size on all platforms
	};
} AVS;  // Api Version Structure
typedef AVS FAR *LPAVS;


/*  DBGVersionCheck:
**
**      All debug dlls should provide this API and support the return
**      of a pointer to the structure described above even before
**      initialization takes place.
*/

#if defined(_M_IX86)
#define __dbgver_cpu__ mptix86
#elif defined(_M_MRX000)
#define __dbgver_cpu__ mptmips
#elif defined(_M_ALPHA)
#define __dbgver_cpu__ mptdaxp
#elif defined(_M_PPC)
#define __dbgver_cpu__ mptntppc
#elif defined(_M_MPPC)
#define __dbgver_cpu__ mptmppc
#elif defined(_M_IA64)
#define __dbgver_cpu__ mptia64
#else
#error( "unknown target machine" );
#endif
//v-vadimp - changed the order to move the LSZ Title (only 32/64 bit var) to the last position to keep the structure aligned properly for 32/64 bit
#define DEBUG_VERSION(C1,C2,TITLE) \
AVS Avs = {      \
    { C1, C2 },         \
    rlvtDebug,          \
    DBG_API_VERSION,    \
    DBG_API_SUBVERSION, \
    rup,                \
    0,                  \
    __dbgver_cpu__,     \
    rmj,                \
    rmm,                \
    TITLE,              \
    };

#define RELEASE_VERSION(C1,C2,TITLE)    \
AVS Avs = {      \
    { C1, C2 },         \
    rlvtRelease,        \
    DBG_API_VERSION,    \
    DBG_API_SUBVERSION, \
    rup,                \
    0,                  \
    __dbgver_cpu__,     \
    rmj,                \
    rmm,                \
    TITLE,              \
};

#ifdef _DEBUG                   
	#define VERSION_INFO(C1,C2,TITLE)	DEBUG_VERSION(C1,C2,TITLE)	        
#else
	#define VERSION_INFO(C1,C2,TITLE)	RELEASE_VERSION(C1,C2,TITLE)	        
#endif                          


#undef MINOR
#undef MAJOR

inline bool 
operator==(
		const AVS& avs1,
		const AVS& avs2
		)
{
	if ( avs1.iApiVer    != avs2.iApiVer    || 
	     avs1.iApiSubVer != avs2.iApiSubVer || 
		 avs1.iRmj       != avs2.iRmj       || 
	     avs1.iRmm       != avs2.iRmm       ||  
		 avs1.rlvt       != avs2.rlvt   ) {

		assert(!"Version Mismatch");
		return false;
	}

	assert ( ( avs1.iRup == avs2.iRup && avs1.chBuild == avs2.chBuild ) ||
			 !"Version Mismatch - Proceed at your own risk");

	return true;
}
inline bool 
operator!=(
		const AVS& avs1,
		const AVS& avs2
		)
{

	return !(avs1 == avs2);
}
#define DBGVERSIONPROCNAME "OSDebug4VersionCheck"

typedef LPAVS (*DBGVERSIONPROC)(void);
LPAVS WINAPI OSDebug4VersionCheck( void );
LPAVS WINAPI WINDBGVersionCheck( void );


#define DBGVERSIONCHECK() \
    LPAVS WINAPI WINDBGVersionCheck( void ) { return &Avs; } \
    LPAVS WINAPI OSDebug4VersionCheck( void ) { return &Avs; }

#endif // _DBGVER_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\debugmem.h ===
#ifndef _debugmem_h
#define _debugmem_h

// redefine the old OSD macros to use the debug CRT heap

#include <malloc.h>
#include <crtdbg.h>

#ifdef _CRTDBG_MAP_ALLOC
#error Dont define _CRTDBG_MAP_ALLOC when using debugmem.h
#endif

// filenames point to DLLs which get unloaded by the time we exit, so we
// have to dupe them, but efficiently
extern const char * SafeDupeFilename( const char *x );

#define MHAlloc(x)   (_malloc_dbg(x,_NORMAL_BLOCK,SafeDupeFilename(__FILE__),__LINE__))
#define MHRealloc(a,b) (_realloc_dbg(a,b,_NORMAL_BLOCK,SafeDupeFilename(__FILE__),__LINE__))
#define MHFree(y)    (_free_dbg(y,_NORMAL_BLOCK))

#define MHAllocHuge(x)   (_malloc_dbg(x,_NORMAL_BLOCK,SafeDupeFilename(__FILE__),__LINE__))
#define MHFreeHuge(y)    (_free_dbg(y,_NORMAL_BLOCK))

#define MMAlloc(x)   (_malloc_dbg(x,_NORMAL_BLOCK,SafeDupeFilename(__FILE__),__LINE__))
#define MMFree(y)    (_free_dbg(y,_NORMAL_BLOCK))
#define	MMLock(a)	(LPVOID)(a)
#define	MMUnlock(a)

// exactly like _CRTDBG_MAP_ALLOC but wraps filename

#if defined(_DEBUG)

#if !defined(DONT_REDEFINE_MALLOC_ET_ALL)

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, SafeDupeFilename(__FILE__), __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, SafeDupeFilename(__FILE__), __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, SafeDupeFilename(__FILE__), __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)

#endif

#include <util\critleak.h>

#if defined(__cplusplus) && !defined(DONT_REDEFINE_DEBUG_NEW)

void* 
__cdecl operator new(
	size_t s, 
	const char *filename, 
	int nLine
	);

void 
__cdecl operator delete(
	void *p, 
	LPCSTR lpszFileName, 
	int nLine
	);

void* __cdecl 
operator new[] (
	size_t, 
	const char *, 
	int
	);

void __cdecl 
operator delete[](
	void *, 
	const char *, 
	int
	);

#define DEBUG_NEW new(__FILE__, __LINE__)

#if !defined(DONT_AUTODEFINE_DEBUG_NEW)
#define	new DEBUG_NEW
#endif

#endif // __cplusplus
#endif // _DEBUG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\dbapiver.h ===
#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

// 7.0 is first AD2-based release
#define DBG_API_VERSION	7
#define DBG_API_SUBVERSION 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\ctxptrs.h ===
#if defined( _NTMIPS_ )  ||  defined( _NTALPHA_ ) || defined( _NTPPC_ ) || defined( _NTIA64H_ )
#define _CTXPTRS_H_
#endif

#ifndef _CTXPTRS_H_
#define _CTXPTRS_H_

#if !defined( _ALPHA_ ) && !defined (TARGET_ALPHA) && !defined(_IA64_) && !defined(TARGET_IA64)

typedef  ULONG_PTR  KNONVOLATILE_CONTEXT_POINTERS;
typedef  ULONG_PTR* PKNONVOLATILE_CONTEXT_POINTERS;

#elif defined(_IA64_) || defined(TARGET_IA64)

//
// from ntia64.h
//

//
// Nonvolatile context pointer record.for IA64
//

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {
    PFLOAT128  LowFloatingContext[2];       // Intel-IA64-Filler
    PFLOAT128  FltS0;                       // Intel-IA64-Filler
    PFLOAT128  FltS1;                       // Intel-IA64-Filler
    PFLOAT128  FltS2;                       // Intel-IA64-Filler
    PFLOAT128  FltS3;                       // Intel-IA64-Filler
    PFLOAT128  HighFloatingContext[10];     // Intel-IA64-Filler
    PFLOAT128  FltS4;                       // Intel-IA64-Filler
    PFLOAT128  FltS5;                       // Intel-IA64-Filler
    PFLOAT128  FltS6;                       // Intel-IA64-Filler
    PFLOAT128  FltS7;                       // Intel-IA64-Filler
    PFLOAT128  FltS8;                       // Intel-IA64-Filler
    PFLOAT128  FltS9;                       // Intel-IA64-Filler
    PFLOAT128  FltS10;                      // Intel-IA64-Filler
    PFLOAT128  FltS11;                      // Intel-IA64-Filler
    PFLOAT128  FltS12;                      // Intel-IA64-Filler
    PFLOAT128  FltS13;                      // Intel-IA64-Filler
    PFLOAT128  FltS14;                      // Intel-IA64-Filler
    PFLOAT128  FltS15;                      // Intel-IA64-Filler
    PFLOAT128  FltS16;                      // Intel-IA64-Filler
    PFLOAT128  FltS17;                      // Intel-IA64-Filler
    PFLOAT128  FltS18;                      // Intel-IA64-Filler
    PFLOAT128  FltS19;                      // Intel-IA64-Filler

    PULONGLONG IntegerContext[3];           // Intel-IA64-Filler
    PULONGLONG IntS0;                       // Intel-IA64-Filler
    PULONGLONG IntS1;                       // Intel-IA64-Filler
    PULONGLONG IntS2;                       // Intel-IA64-Filler
    PULONGLONG IntS3;                       // Intel-IA64-Filler
    PULONGLONG IntV0;                       // Intel-IA64-Filler
    PULONGLONG IntAp;                       // Intel-IA64-Filler
    PULONGLONG IntT0;                       // Intel-IA64-Filler
    PULONGLONG IntT1;                       // Intel-IA64-Filler
    PULONGLONG IntSp;                       // Intel-IA64-Filler
    PULONGLONG IntNats;                     // Intel-IA64-Filler

    PULONGLONG Preds;                       // Intel-IA64-Filler

    PULONGLONG BrRp;                        // Intel-IA64-Filler
    PULONGLONG BrS0;                        // Intel-IA64-Filler
    PULONGLONG BrS1;                        // Intel-IA64-Filler
    PULONGLONG BrS2;                        // Intel-IA64-Filler
    PULONGLONG BrS3;                        // Intel-IA64-Filler
    PULONGLONG BrS4;                        // Intel-IA64-Filler

    PULONGLONG ApUNAT;                      // Intel-IA64-Filler
    PULONGLONG ApLC;                        // Intel-IA64-Filler
    PULONGLONG ApEC;                        // Intel-IA64-Filler
    PULONGLONG RsPFS;                       // Intel-IA64-Filler
    PULONGLONG RsRNAT;                      // Intel-IA64-Filler

    PULONGLONG StFSR;                       // Intel-IA64-Filler
    PULONGLONG StFIR;                       // Intel-IA64-Filler
    PULONGLONG StFDR;                       // Intel-IA64-Filler
    PULONGLONG Cflag;                       // Intel-IA64-Filler

} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;

#else

//
// modified from ntalpha.h   June 7, 1993.
//

//
// Nonvolatile context pointer record.
//

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {

    PLARGE_INTEGER FloatingContext[1];
    PLARGE_INTEGER FltF1;
    // Nonvolatile floating point registers start here.
    PLARGE_INTEGER FltF2;
    PLARGE_INTEGER FltF3;
    PLARGE_INTEGER FltF4;
    PLARGE_INTEGER FltF5;
    PLARGE_INTEGER FltF6;
    PLARGE_INTEGER FltF7;
    PLARGE_INTEGER FltF8;
    PLARGE_INTEGER FltF9;
    PLARGE_INTEGER FltF10;
    PLARGE_INTEGER FltF11;
    PLARGE_INTEGER FltF12;
    PLARGE_INTEGER FltF13;
    PLARGE_INTEGER FltF14;
    PLARGE_INTEGER FltF15;
    PLARGE_INTEGER FltF16;
    PLARGE_INTEGER FltF17;
    PLARGE_INTEGER FltF18;
    PLARGE_INTEGER FltF19;
    PLARGE_INTEGER FltF20;
    PLARGE_INTEGER FltF21;
    PLARGE_INTEGER FltF22;
    PLARGE_INTEGER FltF23;
    PLARGE_INTEGER FltF24;
    PLARGE_INTEGER FltF25;
    PLARGE_INTEGER FltF26;
    PLARGE_INTEGER FltF27;
    PLARGE_INTEGER FltF28;
    PLARGE_INTEGER FltF29;
    PLARGE_INTEGER FltF30;
    PLARGE_INTEGER FltF31;

    PLARGE_INTEGER IntegerContext[1];
    PLARGE_INTEGER IntT0;
    PLARGE_INTEGER IntT1;
    PLARGE_INTEGER IntT2;
    PLARGE_INTEGER IntT3;
    PLARGE_INTEGER IntT4;
    PLARGE_INTEGER IntT5;
    PLARGE_INTEGER IntT6;
    PLARGE_INTEGER IntT7;
    // Nonvolatile integer registers start here.
    PLARGE_INTEGER IntS0;
    PLARGE_INTEGER IntS1;
    PLARGE_INTEGER IntS2;
    PLARGE_INTEGER IntS3;
    PLARGE_INTEGER IntS4;
    PLARGE_INTEGER IntS5;
    PLARGE_INTEGER IntFp;
    PLARGE_INTEGER IntA0;
    PLARGE_INTEGER IntA1;
    PLARGE_INTEGER IntA2;
    PLARGE_INTEGER IntA3;
    PLARGE_INTEGER IntA4;
    PLARGE_INTEGER IntA5;
    PLARGE_INTEGER IntT8;
    PLARGE_INTEGER IntT9;
    PLARGE_INTEGER IntT10;
    PLARGE_INTEGER IntT11;
    PLARGE_INTEGER IntRa;
    PLARGE_INTEGER IntT12;
    PLARGE_INTEGER IntAt;
    PLARGE_INTEGER IntGp;
    PLARGE_INTEGER IntSp;
    PLARGE_INTEGER IntZero;

} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;

#endif  // !_ALPHA_ && !TARGET_ALPHA

#endif  //  _CTXPTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\sources.inc ===
#
# Pick up master directory definitions

BUILD_USING_VC7PDBS=1

!include $(VSROOT)\sources.inc

#
# if RCTOOL is not defined, default to "rc"
# this allows the use a different rc from NT-J
#

!if "$(RCTOOL)" == ""
RCTOOL=rc
!endif

DEBUGGER_ROOT=$(SRC_ROOT)\vc\debugger
DBGPROXY_IDL_ROOT=$(DEBUGGER_ROOT)\idl\dbgproxy

!ifndef LANGAPI
LANGAPI=$(SRC_ROOT)\vc\langapi
!endif


#
# compiler defines
#
USER_C_DEFINES = $(USER_C_DEFINES) -DHOST32 -DTARGET32 -DNT_BUILD -DSTRICT -D_ATL_NO_ATTRIBUTES -DCC_LAZYTYPES -D_WIN32_WINNT=0x400 -D_RTC -DENABLE_IA64_SUPPORT=1 -DLNGNM=1

#
# Is this a ship build, or are chickens made of cheese?
#


!if "$(_SHIP)" == "1"
!message Building _SHIPping version, really, honest.
USER_C_DEFINES = $(USER_C_DEFINES) -D_SHIP
!endif

!if !$(FREEBUILD)
MKTYPLIB_FLAGS=$(MKTYPLIB_FLAGS) /D_DEBUG
!if $(IA64)!=1
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /GR /RTCs /RTCu
!else
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /GR
!endif
!else
!endif


# Get all the other project paths.


NOT_LEAN_AND_MEAN=
386_STDCALL = 1
USE_NATIVE_EH = 0

DLLENTRY = _DllMainCRTStartup

USER_C_DEFINES = $(USER_C_DEFINES) -DWIN32 -DTARGET32 -DHOST32 -D_CROSS_PLATFORM_

MIPS_FLAGS = -DHOST_MIPS
386_FLAGS  = -DHOST_i386
ALPHA_FLAGS= -DHOST_ALPHA
PPC_FLAGS  = -DHOST_PPC
IA64_FLAGS = -DHOST_IA64
AXP64_FLAGS= -DHOST_AXP64

MIDL_FLAGS = $(MIDL_FLAGS) -D_MIDL_USER_MARSHAL_DISABLED=1

DEBUG_INCLUDES=$(DEBUGGER_ROOT)\include

USER_INCLUDES=$(DEBUG_INCLUDES);$(LANGAPI)\undname;$(SRC_ROOT)\debugger\inc
LAST_INCLUDES=$(LANGAPI)\include

#
# And some Lib paths
#

DEBUG_BIN=$(VSBUILT)\$(BUILT_FLAVOR)\bin
DEBUG_LIB=$(VSBUILT)\$(BUILT_FLAVOR)\lib

# define which MSPDB we link with
# change when we switch toolsets
MSPDBLIB = mspdb.lib
MSPDBLIBPATH = $(DEVTOOLS)\$(BUILD_TARGET_ARCHITECTURE)\$(VC)\lib\nonship
MSPDBDLL = mspdb70.dll
!if !$(FREEBUILD)
MSDISLIB = $(DEVTOOLS)\$(BUILD_TARGET_ARCHITECTURE)\$(VC)\lib\nonship\msds130d.lib
!else
MSDISLIB = $(DEVTOOLS)\$(BUILD_TARGET_ARCHITECTURE)\$(VC)\lib\nonship\msdis130.lib
!endif
MSOBJLIB = msobj.lib
MSOBJDLL = msobj10.dll
# temporary measure until symwriter talks 70
MSPDB70LIB = mspdb70.lib
MSPDB70DLL = mspdb70.dll


!if $(IA64)!=1
USER_C_FLAGS=$(USER_C_FLAGS) /GS
!endif

# Don't link to ntdll.lib
NO_NTDLL=1
USE_MSVCRT=1


#
# Do not create build.exe warning message for the following files:
#

CONDITIONAL_INCLUDES=\
		$(CONDITIONAL_INCLUDES)\
		winwlm.h		\
		macwin32.h		\
		rpcerr.h		\
		rpcmac.h		\
		macname1.h		\
		macapi.h		\
		macname2.h		\
		macpub.h		\
		strstream		\
		macocidl.h      \
		pshpck16.h      \
		new             \
		exception		\
		skbapi.h		\
		exdisp.odl		\
		vidsvr.odl		\
		afxres.h		\
		mipsinst.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\emdm.h ===
/**** EMDM.HMD - Common structures for Win32/NT EM and DM               ****
 *                                                                         *
 *                                                                         *
 *  Copyright <C> 1990, Microsoft Corp                                     *
 *                                                                         *
 *  Created: November 17, 1990 by David W. Gray                            *
 *                                                                         *
 *  Purpose:                                                               *
 *                                                                         *
 *      This file defines the types, enums, and constants that are common  *
 *      for all execution models, both debugger and debuggee end.          *
 *                                                                         *
 ***************************************************************************/

#ifndef _EMDM
#define _EMDM

//
// This is included to define a NONVOLATILE_CONTEXT_POINTERS structure
// of the appropriate size.  The goal is to keep any machine-specific
// reference out of emdp.c here, but we need to know how much data to
// transfer to the thread context on the different architectures.
//

#include "ctxptrs.h"

#define INITIAL_EMWBBUFFERSIZE   4096*2 
#define INITIAL_DMSENDBUFFERSIZE 1024 

#ifndef try
#define try __try
#endif
#ifndef except
#define except __except
#endif
#ifndef finally
#define finally __finally
#endif

typedef DWORD MTE;

#ifdef TARGET32
#define MAXBIGSEGS      3
#endif


typedef DWORD PID;
typedef DWORD TID;


typedef enum {
    dmfRemoteDied = -1,             /* debugger quit */
    dmfCommError  = -2,             /* transport layer error */

    dmfNull = 0,

    dmfInit,
    dmfUnInit,
    dmfSelect,
    dmfConnect,

    dmfCreatePid,
    dmfDestroyPid,

    dmfSetPath,
    dmfSpawnOrphan,
    dmfProgLoad,
	dmfLoadCrashDump,
    dmfProgFree,
    dmfDebugActive,
    dmfTerm,
    dmfDetach,

    dmfGo,
    dmfStop,
	dmfNextReadableMemory,
    dmfThreadManipulate,
	dmfLockUnLock,

    dmfSingleStep,
    dmfReturnStep,
    dmfNonLocalGoto,
    dmfRangeStep,
    dmfGoToReturn,

    dmfBreakpoint,
    dmfGetExceptionState,
    dmfSetExceptionState,

    dmfReadMem,
    dmfReadReg,
    dmfReadFrameReg,
    dmfWriteMem,
    dmfWriteReg,
    dmfWriteFrameReg,
    dmfVirtualAllocEx,
    dmfGetFP,
    dmfSetFP,
    dmfThreadStatus,
    dmfProcessStatus,
    dmfQueryTlsBase,
    dmfQuerySelector,
    dmfVirtualQuery,
    dmfReadRegEx,
    dmfWriteRegEx,
    dmfGetSections,

    dmfInit32SegValues,
    dmfSelLim,

    dmfSetMulti,
    dmfClearMulti,
    dmfDebugger,
    dmfSync,
    dmfSystemService,
    dmfGetPrompt,
    dmfSendChar,
    dmfGetDmInfo,

    dmfSetupExecute,
    dmfStartExecute,
    dmfCleanUpExecute,

    dmfRemoteUtility,       // for the mfile utility

	dmfGetSpecialReg,
	dmfSetSpecialReg,

	//
	// File I/O
	//

	dmfGetImageInformation,
	dmfFindFirstFile,
	dmfFindNextFile,
	dmfCloseFindFile,
	dmfOpenFile,
	dmfReadFile,
	dmfSeekFile,
	dmfCloseFile,
	dmfWriteCrashDump,

	dmfGetDebuggableTaskList,
    
    // Load Library
    dmfLoadLibrary,

	// Engine is ready for interop
	dmfEngineReady,


    dmfLast

} _DMF;

typedef LONG DMF;


typedef struct _DM_MSG {
    union {
        XOSD  xosdRet;
        DWORDLONG Alignment[2];
    };
    BYTE  rgb[1];
} DM_MSG;
typedef DM_MSG FAR *LPDM_MSG;

#define iflgMax 12

typedef struct _RTRNSTP {
   ADDR addrRA;         // Address to return to
   ADDR addrStack;       // Address of current SP.
   EXOP exop;
} RTRNSTP; // ReTuRN STeP packet
typedef RTRNSTP FAR *LPRTRNSTP;

#pragma pack(4)

typedef struct _RST {
#if defined(TARGET32) || defined(TARGET64)
    UOFFSET     offStart;
    UOFFSET     offEnd;
    UOFFSET     offPC;
#else
    ADDR addrStart;
    ADDR addrEnd;
    ADDR addrCSIP;
#endif
	EXOP	exop;
} RST; // Range STep Packet

typedef RST FAR *LPRST;

typedef struct _TCR {
    TID             tid;
    BOOL            bFiber;
    UOFFSET uoffTEB;
} TCR;  // Thread Create Return
typedef TCR FAR *LPTCR;

typedef struct _SETPTH {
    BOOL Set;
    TCHAR Path[1];
} SETPTH;

#pragma pack()

//
// DM Misc info structure.
//
// Some of these correspond to the debug metrics exposed by OSDebug.
// These cover the differences between user and kernel mode, Win32,
// Win32s and Win32c, maybe Cairo, whatever other DMs might be handled
// by the Win32 EM.
//
typedef struct _PROCESSOR {
    MPT   Type;
    DWORD Level;
    END   Endian;
	DWORD processorFlags;
	DWORD pageSize;
} PROCESSOR, FAR * LPPROCESSOR;

// Flags values, low word is general, high word is processor-specific
#define	PROCESSOR_FLAGS_EXTENDED	0x00000001
#define	PROCESSOR_FLAGS_I386_MMX	0x00010000
#define	PROCESSOR_FLAGS_I386_MMX2	0x00020000
#define	PROCESSOR_FLAGS_I386_MMX3	0x00040000
#define	PROCESSOR_FLAGS_I386_3DNOW	0x00080000

typedef struct _DMINFO {
    PROCESSOR Processor;
} DMINFO;
typedef DMINFO FAR * LPDMINFO;

typedef struct _EHP {
    DWORD iException;
    BOOL  fHandle;
} EHP; // Exception Handled Packet
typedef EHP FAR *LPEHP;

typedef struct _OBJD {
    UOFFSET     offset;
    DWORD	    rvaOffset;
    DWORD       cb;
    WORD        wSel;
    WORD        wPad;
} OBJD, FAR * LPOBJD;


#define	MAX_VERSION	20
typedef struct _MODULELOAD {
    SEGMENT              CSSel;
    SEGMENT              DSSel;
    LONG                 cobj;
    UOFFSET              uoffDataBase;

	MOD_INFO             modInfo;
	OSDIMAGEINFO         imageInfo;

	
	ULONG			     SectionAlignment;
    UOFFSET              uoffiTls;			// linear address in process of this module's tlsindex
    DWORD                isecTLS;			// index of .tls section
    DWORD                iTls;				// tls index, retrieved at initial breakpoint time
	TCHAR			     szVersion[MAX_VERSION];
	MODULE_DEBUG_INFO    debugInfo;         // Module Debug Info
    OBJD                 rgobjd[];
} MODULELOAD;

typedef MODULELOAD FAR *LPMODULELOAD;



//
// Whether the fourth parameter is a set of args or a command line depends
// on the dmf used: dmfSpawnOrphan = szCmdLine, dmfProgLoad = szArgs.
//

typedef struct _PROGLOAD {
	DWORD	   dwChildFlags;
	DWORD      fStartDmThread;
	LAUNCHMODE mode;
	TCHAR	   szExe [_MAX_PATH];
	TCHAR	   szDir [_MAX_PATH];

	union {
		TCHAR	szCmdLine [];		// variable length, NULL terminated
		TCHAR	szArgs [];			// variable length, NULL terminated
	};
} PROGLOAD;

typedef PROGLOAD* LPPROGLOAD;

// this struct is used by OSDOpenFile
typedef struct _FILELOAD {
	TCHAR      szExe[_MAX_PATH];    // name of the executable 
} FILELOAD, *LPFILELOAD;

// Used by OSDLoadLibrary
typedef struct _DLLLOAD {
    ADDR    addr;
    TCHAR   szDllName[_MAX_PATH];
} DLLLOAD, *LPDLLLOAD;

// this struct is used by OSDReadFile
typedef struct _FILEREAD {
	DWORD64 hFile;
	DWORD64 dwBytesToRead;	
} FILEREAD, *LPFILEREAD;

// this struct is used by OSDSeekFile
typedef struct _FILESEEK {
	DWORD64 hFile;
	DWORD64	dwLocation;	
	DWORD64	dwOrigin;	
} FILESEEK, *LPFILESEEK;

typedef struct _RWP {
    DWORD cb;
    ADDR addr;
    union {
        BYTE rgb[1];
        DWORDLONG Align;
    };
} RWP; // Read Write Packet

typedef RWP *PRWP;
typedef RWP FAR *LPRWP;

typedef struct _NPP {
    PID     pid;
    BOOL    fReallyNew;    
	DWORD   dwRegisterSet; // the register flag set;
	BOOL	fOnWin9x;      // running on win'9x?
	BOOL 	f64Bit;        // Is 64 bit?
} NPP;  // New Process Packet, used with dbcNewProc.
        // See od.h for description of fReallyNew.
typedef NPP FAR * LPNPP;

typedef struct _WPP {
    ADDR addr;
    WORD cb;
} WPP; // Watch Point Packet
typedef WPP FAR *LPWPP;

#if defined( TARGMAC68K )
typedef struct _SLI {
    DWORD dwBaseAddr;
    DWORD fExecute;
    short sRezID;
    unsigned char szName[];
} SLI;  // Segment Load Info
#else
typedef struct _SLI {
    WORD        wSelector;
    WORD        wSegNo;
    WORD        mte;
} SLI, FAR * LPSLI;
#endif

typedef SLI FAR *LPSLI;

// Exception command packet
typedef struct _EXCMD {
   EXCEPTION_CONTROL exc;
   EXCEPTION_DESCRIPTION exd;
} EXCMD;
typedef EXCMD FAR * LPEXCMD;

typedef struct _EXHDLR {
    DWORD count;
    ADDR addr[];
} EXHDLR;
typedef EXHDLR FAR * LPEXHDLR;

// 
// dbce's are packet ids meant for communication been dm and the osd
// layer, they never get propaged to the AD7 layer
//
// They may or maynot have return packets which convery information back
// to the DM
//
//
//
// The DBCEs always come back in an RTP structure, which has additional
// info.  The comments on the DBCEs below refer to the other fields of
// the RTP structure.
//
typedef enum {
    dbceAssignPID = dbcMax,     // Tell the EM what PID is associated with
                                // a given HPID.  At offset 0 of rtp.rgbVar[]
                                // is the PID.
    dbceCheckBpt,               // Find out if EM wants us to single-step
                                // over a specified breakpoint.  Upon return,
                                // rgbVar[0] is fStop to stop at this
                                // breakpoint; if fStop is FALSE, then
                                // rgbVar[1] is the byte with which to
                                // overwrite the INT 3.

    dbceExceptionDuringStep,    // Ask count prefix array of exception handlers
	dbceGetFrameWithSrc,		// Get closest frame with src
	dbceCreateThread,			// Create a thread struct and return the htid.
    dbceMax
} _DBCE;
typedef LONG DBCE;

typedef struct _DBB {
    DMF  dmf;
    union {
        HPID hpid;
        DWORDLONG Align1;
    };
    union {
        HTID htid;
        DWORDLONG Align2;
    };
    union {
        DWORDLONG Alignment;
        BYTE rgbVar[1];
    };
} DBB;

typedef DBB FAR *LPDBB;

typedef struct _RTP {
    ULONG dbc;                   // a DBC or a DBCE
    DWORD cb;                    // the length of rgbVar
    union {
        HPID hpid;
        DWORDLONG Align1;
    };
    union {
        HTID htid;
        DWORDLONG Align2;
    };
    union {
        DWORDLONG Alignment;
        BYTE rgbVar[1];         // additional information - see the
                                // definitions of the DBCE and DBC codes
    };
} RTP;

typedef RTP *PRTP;
typedef RTP FAR *LPRTP;

#define lpregDbb(dbb) ( (LPREG) &dbb )
#define lpfprDbb(dbb) ( (LPFPR) &dbb )
#define lszDbb(dbb)   ( (LSZ)   &dbb )

#define addrDbb(dbb)  (*( (LPADDR) &dbb ))
#define stpDbb(dbb)   (*( (LPSTP)  &dbb ))
#define rstDbb(dbb)   (*( (LPRST)  &dbb ))
#define gopDbb(dbb)   (*( (LPGOP)  &dbb ))
#define tstDbb(dbb)   (*( (LPTST)  &dbb ))
#define pstDbb(dbb)   (*( (LPF)    &dbb ))
#define rwpDbb(dbb)   (*( (LPRWP)  &dbb ))
#define fDbb(dbb)     (*( (LPF)    &dbb ))



/****************************************************************************
 *                                                                          *
 * Packets returned from the debuggee execution model to the debugger       *
 *  execution model.                                                        *
 *                                                                          *
 ****************************************************************************/


typedef struct _FRAME_INFO {
    CONTEXT frameRegs;
    KNONVOLATILE_CONTEXT_POINTERS frameRegPtrs;
} FRAME_INFO, * PFRAME_INFO;

typedef struct _DBGERROR {
	XOSD xosd;  // an xosd describing the Debugger error

} DBGERROR, *LPDBGERROR;

typedef struct _NLG {
    ADDR    addrNLGDispatch;
    ADDR    addrNLGDestination;
    ADDR    addrNLGReturn;
    ADDR    addrNLGReturn2;
    BOOL    fEnable;
	BOOL    fGotNLGReturn;
	BOOL    fGotNLGReturn2;
	union
	{
		HEMI    hemi;
		DWORDLONG	align;
	};
} NLG;
typedef NLG * PNLG;
typedef NLG FAR * LPNLG;


typedef struct _EMBUFFERINFO {
	LPBYTE lpEmWBBuf;
	LPBYTE lpDmSendBuf;
	DWORD  cbEmWBBuf;
	DWORD  cbDmSendBuf;
} EMBUFFERINFO;


typedef EMBUFFERINFO* LPEMBUFFERINFO;

typedef LPEMBUFFERINFO (__stdcall *PFNEMGETWBBUFFER)();

typedef struct _TLEMBUFFERMSG{
	DWORD  cbBuffer;
	union {
		PFNEMGETWBBUFFER pEmFunc;
		DWORDLONG        Align;
	}; 
		
} TLEMBUFFERMSG, *LPTLEMBUFFERMSG;

#endif  // _EMDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\dbc.h ===
//--------------------------------------------------------------------
// DBC.H
//
// This contains a list of all the debugger callback notifications.
//
// There are multiple users of this file.  To use it, you must
// define a DECL_DBC macro to extract the pieces of information that
// you are interested in from this file.  For example, if you want
// the numerical value, name (as a string), and fRequest flag for
// each callback, you could write the following:
//
//  typedef struct {
//      DBC     dbc;
//      LPCSTR  lszDbc;
//      BOOL    fRequest;
//  } DBCINFO;
//
//  #define DECL_DBC(name, fRequest, dbct) { dbc##name, "dbc" #name, fRequest },
//
//  DBCINFO rgdbcinfo[] = {
//      #include "dbc.h"
//  };
//
//  #undef DECL_DBC
//--------------------------------------------------------------------

DECL_DBC(Nil,             FALSE, dbctStop)

DECL_DBC(Bpt,             FALSE, dbctStop)



DECL_DBC(AsyncStop,       FALSE, dbctStop)     // Async stop has completed
DECL_DBC(EntryPoint,      FALSE, dbctStop)
DECL_DBC(LoadComplete,    FALSE, dbctStop)

DECL_DBC(Exception,		  FALSE, dbctStop)		// This one stops
DECL_DBC(NotifyException, FALSE, dbctContinue)	// This one continues

DECL_DBC(ExecuteDone,     FALSE, dbctContinue)
DECL_DBC(ExecuteFailed,   FALSE, dbctContinue)

DECL_DBC(Step,            FALSE, dbctStop)

DECL_DBC(CanStep,         TRUE,  dbctContinue)

DECL_DBC(NewProc,         FALSE, dbctContinue)
DECL_DBC(ProcTerm,        FALSE, dbctContinue)
DECL_DBC(DeleteProc,      FALSE, dbctContinue)


DECL_DBC(CreateThread,    FALSE,  dbctContinue)

DECL_DBC(ThreadTerm,      FALSE, dbctContinue)		// This one stops

DECL_DBC(ModLoad,         TRUE,	 dbctContinue)
DECL_DBC(ModFree,         FALSE, dbctContinue)

DECL_DBC(InfoAvail,       FALSE, dbctContinue) // i.e. OutputDebugString
DECL_DBC(Error,           FALSE, dbctContinue)     // misc error reporting

//
// We just exited a function (either stepped a RET, or stepped over a CALL)
//		wParam = nothing
//		lParam = LPADDR, points to some address in the function we just
//						 exited; NOT necessarily the very beginning of the func
//

DECL_DBC(ExitedFunction, TRUE,	dbctContinue)

// The name of a thread was changed
//
DECL_DBC(ThreadName, FALSE, dbctContinue)

DECL_DBC(RuntimeError,        FALSE, dbctStop)
DECL_DBC(NotifyRuntimeError,  FALSE, dbctContinue)

//
// The generic stopping and generic non-stopping events are to help out
// the shell.  They are NEVER generated by the DM or the EM.
//

DECL_DBC(GenericStoppingEvent,		FALSE, dbctStop)		
DECL_DBC(GenericNonstoppingEvent,	FALSE, dbctContinue)

DECL_DBC(SoftAsyncStop,       FALSE, dbctStop)     // Soft Break

DECL_DBC(Message,       FALSE, dbctContinue)     // a message for the shell 

DECL_DBC(NoSymbols,     FALSE, dbctContinue)     // no symbols for main binary (mod[0]) 

DECL_DBC(Max,             FALSE, dbctStop)

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\tltypes.h ===
// OSD-based types for Transport Layer
// Split our from odtypes.h so that the shell can use it

typedef
LONG (OSDAPI *
LPGETSETPROFILEPROC)(
    LPTSTR      KeyName,        // SubKey name (must be relative)
    LPTSTR      ValueName,      // value name
    DWORD*      dwType,         // type of data (valid only in the case of Set)
    BYTE*       Data,           // pointer to data
    DWORD       cbData,         // size of data (in bytes)
    BOOL        fSet            // TRUE = setting, FALSE = getting
    );

//
// Transport Layer Management
//

#define TLISINFOSIZE 80
typedef struct _TLIS {
    DWORD fCanSetup;
    DWORD dwMaxPacket;
    DWORD dwOptPacket;
    DWORD dwInfoSize;
    DWORD fRemote;
    MPT   mpt;
    MPT   mptRemote;
    TCHAR rgchInfo[TLISINFOSIZE];
} TLIS;
typedef TLIS * LPTLIS;

typedef struct _TLSS {
    DWORD fLoad;
    DWORD fInteractive;
    DWORD fSave;
    LPVOID lpvPrivate;
    LPARAM lParam;
    LPGETSETPROFILEPROC lpfnGetSet;
    MPT mpt;
    BOOL fRMAttached;
} TLSS;
typedef TLSS * LPTLSS;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\odp2.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    odp.h

Abstract:

    This is part of OSDebug version 4.

    These are types and data which are private to OSDebug and the
    components below it: TL, EM and DM.

Author:

    Kent D. Forschmiedt (kentf)

Environment:

    Win32, User Mode

--*/

#ifndef _ODP_
#define _ODP_

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
extern "C" {
#endif

#define DECL_EMF(emfName)       emf##emfName,

typedef enum _EMF {
#include "emf.h"
} EMF;

#undef DECL_EMF

typedef struct _DBCPK {
   DBC     dbc;
   HPID    hpid;
   HTID    htid;
   WPARAM  wValue;
   LPARAM  lValue;
} DBCPK; // a dbc package
typedef DBCPK FAR *LPDBCPK;


// There are not more than 
#define Number_of_dbce_events 10
typedef enum {
    dbcoCreateThread = dbcMax+Number_of_dbce_events,
    dbcoNewProc,

    dbcoMax
} DBCO;  // Debug CallBacks Osdebug specific

// the set of transport layer commands process by TLFunc and DMTLFunc

typedef enum {
    tlfInit,            // initialize/create a (specific) transport layer
    tlfDestroy,         // vaporize any tl structs created
    tlfConnect,         // connect to the companion transport layer
    tlfDisconnect,      // disconnected from the companion transport layer
    tlfSetEMBuffer,     // set the data buffer to by TL to communicate with EM  
    tlfSetDMBuffer,     // set the data buffer to by TL to communicate with DM  
    tlfDebugPacket,     // send the debug packet to the debug monitor
    tlfRequest,         // request data from the companion transport layer
    tlfReply,           // reply to a data request message
    tlfLoadDM,          // load the DM module
    tlfListen,          // Remote: wait for somebody to make a connection to us
    tlfPassiveConnect,      // the remote monitor connects to transport with this
    tlfSetErrorCB,      // Set the address of the error callback function
    tlfDebugPacketWithoutAck,     // send the debug packet to the debug monitor
    tlfMax
} _TLF;
typedef _TLF TLF;

//
// callbacks the TL uses to communicate with shell -- stub or client.
//
typedef enum {
    tlcbDisconnect,     // Transport layer was disconnected normally
    tlcbMax
} _TLCB;
typedef _TLCB TLCB;


typedef XOSD (*TLFUNC_ODP) ( TLF, HPID, WPARAM , LPARAM );
typedef XOSD (*EMFUNC_ODP) ( EMF, HPID, HTID, WPARAM , LPARAM);
typedef XOSD (*TLFUNCTYPE) ( TLF, HPID, WPARAM , LPARAM );
typedef XOSD (*DMTLFUNCTYPE) ( TLF, HPID, WPARAM , LPARAM );
typedef XOSD (*TLCALLBACKTYPE) (HPID, WPARAM , LPARAM );
//typedef VOID (*LPDMINIT) ( DMTLFUNCTYPE, LPVOID ); // I think this is wrong
typedef XOSD (*LPDMINIT) ( LPARAM );
typedef VOID (*LPDMFUNC) ( WPARAM, LPBYTE );
typedef XOSD (*TLSERVERCALLBACK) (TLCB, HPID, HTID, WPARAM , LPARAM  );



DECLARE_HANDLE32(HEMP);

typedef struct _THREADINFO {
    HPID hpid;
    HLLI llemp;
} THREADINFO;
typedef THREADINFO *LPTHREADINFO;   // Thread information

typedef struct _PROCESSINFO {
    HTL        htl;
    HEMP       hempNative;
    HLLI       llemp;
    //DWORD      fNative;
    //DWORD_PTR  lastmodel;
    LPFNSVC    lpfnsvcCC;
    HLLI       lltid;
#ifdef TRACK_HPIDS
	DWORD	   dwMagic;		// for testing and debugging
#endif

} PROCESSINFO;
typedef PROCESSINFO *LPPROCESSINFO;   // Process information

typedef struct _EMS {
	HEM			__unused;	// this structure should be aligned with
    EMFUNC_ODP  emfunc;		// the LPEMP for reasons only od.c
    EMTYPE      emtype;		// understands . . . 
    HLLI        llhpid;
    DWORD       model;
} EMS; // Execution Model Structure - per EM
typedef EMS *LPEMS;

typedef struct _EMP {
    HEM         hem;
    EMFUNC_ODP  emfunc;
    EMTYPE      emtype;
    DWORD       model;
} EMP; // Execution Model Structure - per process
typedef EMP *LPEMP;

typedef struct _TLS {
    TLFUNC_ODP  tlfunc;
} TLS; // Transport Layer Structure
typedef TLS *LPTL;

typedef struct _OSDFILE {
    HPID  hpid;
    DWORD dwPrivateData;    // EM's representation of the file
} OSDFILE;
typedef OSDFILE * LPOSDFILE;

//
// Compare Address Struct
//
typedef struct _CAS {
    LPADDR lpaddr1;
    LPADDR lpaddr2;
    LPDWORD lpResult;
} CAS;
typedef CAS * LPCAS;

//
// Range Step Struct
//
typedef struct _RSS {
    LPADDR lpaddrMin;
    LPADDR lpaddrMax;
    LPEXOP lpExop;
} RSS;
typedef RSS * LPRSS;

//
// read memory struct
//
typedef struct _RWMS {
    LPCADDR lpaddr;
    LPVOID lpbBuffer;
    DWORD cbBuffer;
    LPDWORD lpcb;
} RWMS;
typedef RWMS * LPRWMS;

// 
// Load Library structure
//
typedef struct _LDLLS {
    PADDR   paddr;
    LPCTSTR szDllName;
} LDLLS;
typedef LDLLS * LPLDLLS;

//
// Get Object Length struct
//
typedef struct _GOL {
    LPADDR lpaddr;
    LPUOFFSET lplBase;
    LPUOFFSET lplLen;
} GOL;
typedef GOL * LPGOL;

//
// Get Function Information Structure
//
typedef struct _GFI {
    LPADDR lpaddr;
    LPFUNCTION_INFORMATION lpFunctionInformation;
} GFI;
typedef GFI * LPGFI;

//
// Get Previous Instruction Structure
//
typedef struct _GPIS {
    LPADDR lpaddr;
	int iCount;						// how many instructions should we go back?
} GPIS;
typedef GPIS * LPGPIS;

//
// Set Debug Mode Structure
//
typedef struct _SDMS {
    DBM dbmService;
    LPVOID lpvData;
    DWORD cbData;
} SDMS;
typedef SDMS * LPSDMS;

typedef struct _SSS {
    SSVC ssvc;
    DWORD cbSend;
    DWORD cbReturned;
    BYTE rgbData[];
} SSS;
typedef SSS * LPSSS;

//
// The following structure is used by the emfSetupExecute message
//
typedef struct _EXECUTE_STRUCT {
    ADDR        addr;           /* Starting address for function        */
    HIND        hindDm;         /* This is the DMs handle               */
    HDEP        lphdep;         /* Handle of save area                  */
	DWORD		dwTimeout;		/* How long to wait						*/
    BOOL        fIgnoreEvents:1; /* Ignore events coming back?          */
} EXECUTE_STRUCT;
typedef EXECUTE_STRUCT * LPEXECUTE_STRUCT;

//
// Load DM packet, used by TL
//
// Warning; struct is used on 32 & 64 bit side needs to be properly
// aligned
//
//
typedef struct _LOADDMSTRUCT {
	union {
    	LPTSTR             lpDmName;
		DWORDLONG          pad0;
	};

	// these pointers are only valid for a local DMInit
	union {
		DMTLFUNCTYPE       lpDMTLFunc;
		DWORDLONG 		   pad2;
	};

	union {
		LPFNREFCOUNTENGINE lpRefFunc;
		DWORDLONG 		   pad3;
	};

	union {
		LPVOID             lpRefFuncParam;
		DWORDLONG		   pad4;
	};

} LOADDMSTRUCT, * LPLOADDMSTRUCT;

typedef struct _DMINITS {

	

	TCHAR 		szDMParams[512];
	TCHAR       szRegRoot[1024];


} DMINITS, *LPDMINITS;


void ODPDKill  ( LPVOID );

void EMKill    ( LPVOID );
int  EMHpidCmp ( LPVOID, LPVOID, LONG );
void EMPKill   ( LPVOID );

void TLKill    ( LPVOID );

void NullKill  ( LPVOID );
int  NullComp  ( LPVOID, LPVOID, LONG );

typedef struct _EMCB {
    XOSD (*lpfnCallBackDB) ( DBC, HPID, HTID, WPARAM, WPARAM, LPARAM );
    XOSD (*lpfnCallBackTL) ( TLF, HPID, WPARAM, LPARAM );
    XOSD (*lpfnCallBackNT) ( EMF, HPID, HTID, WPARAM, LPARAM );
    XOSD (*lpfnCallBackEM) ( EMF, HPID, HTID, WPARAM, WPARAM, LPARAM );
} EMCB; // Execution Model CallBacks
typedef EMCB *LPEMCB;

interface ISymbolHandler;

typedef struct _REMI {
    HEMI    hemi;
	HMODULE	hModule;
	ISymbolHandler *pSymHandler;
} REMI;     // Register EMI structure
typedef REMI * LPREMI;

//
// Packet used by OSDSpawnOrphan
//

typedef struct _SOS {
    DWORD   dwChildFlags;
    LPTSTR  lszRemoteExe;   // name of remote exe
    LPTSTR  lszCmdLine;     // command line
    LPTSTR  lszRemoteDir;	// initial dir of debuggee
	PROCESS_ID pid;			// OUT Parameter with the process id
} SOS;        // Spawn Orphan Structure
typedef SOS* LPSOS;


//
// packet used by NextReadableMemory
//
typedef struct _NREADMEM {
	UOFFSET offStart;
	DWORD   dwRange;
	UOFFSET offNextReadable;
} NREADMEM, *LPNREADMEM;


//
//	packet used by OSDProgramLoad
//

typedef struct _PRL {
    DWORD      dwChildFlags;
	DWORD      fStartDmThread; // Hack for stress restart failures on Tlloc 
    LPTSTR     lszRemoteExe;    // name of remote exe
    LPTSTR     lszCmdLine;      // command line
    LPTSTR     lszRemoteDir;    // initial dir of debuggee
	LAUNCHMODE mode;            // launch mode - native/complus/blah...
 } PRL; // PRogram Load structure
typedef PRL *   LPPRL;


//
//		Structures used by GetAddr and SetAddr
//

typedef struct _GETSETADDR {
	HFRAME	hFrame;
	ADR		adr;
	LPADDR	lpaddr;
} GETSETADDR;



typedef struct _GETSETREGISTERFLAG {
	HFRAME	hFrame;
	DWORD	dwIndex;
	LPDWORD attribs;					
	LPVOID	lpv;
} GETSETREGISTERFLAG;

//
//	Used by the FindFile functions
//

typedef struct FINDFILEFIRST {
	LPCSTR	szFileParam;
	HOSDFF*	lpFindFileHandle;
	OSDFINDFILEINFO* lpFileInfo;
} FINDFILEFIRST;


	
typedef struct TCSR {
    DWORD	dwTimeStamp;
    DWORD	dwCheckSum;
} TCSR;

typedef TCSR* LPTCSR;

#define LBAssert  (*lpdbf->lpfnLBAssert)

#ifdef  __cplusplus
}   // extern "C"
#endif

#ifndef VCDBG_DONOT_OVERRIDE_ALLOCACTORS

#include <debugmem.h>

#endif

#endif // _ODP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\odtypes.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    odtypes.h

Abstract:

Author:

    David J. Gilman (davegi) 05-Apr-1992

Environment:

    Win32, User Mode


--*/

#pragma once

#include "types.h"
#include "cvtypes.h"
#include "toolhrt.h"

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
#endif


//
// If the following definitions do not produce a 32 bit type on your
// platform, you must fix it.
//

typedef VOID FAR * HANDLE32;
typedef HANDLE32 FAR * LPHANDLE32;

#if !defined(DECLARE_HANDLE32)
#ifdef STRICT
#define DECLARE_HANDLE32(name) struct name##__32 { int unused; }; typedef struct name##__32 FAR *name
#else
#define DECLARE_HANDLE32(name) typedef HANDLE32 name
#endif
#endif

//
// Handle to a transport
//

DECLARE_HANDLE32(HTL);
typedef HTL  FAR *LPHTL;

//
// Handle to an EM
//

DECLARE_HANDLE32(HEM);
typedef HEM  FAR *LPHEM;

//
// Handle to an OSDebug file
//

DECLARE_HANDLE32(HOSDFILE);

//
// Handle to an OSD Find File object
//

DECLARE_HANDLE32(HOSDFF);

//
// Handle to a frame
//

DECLARE_HANDLE32(HFRAME);

typedef HEMI FAR *LPHEMI;


typedef char FAR *  LSZ;

#define OSDAPI WINAPI
#define OSDAPIV WINAPIV

#include "tltypes.h"


//
// Error status codes
//

#define DECL_XOSD(n,v,s) n = v,

typedef enum {
	#include "xosd.h"
} XOSD ;

#undef DECL_XOSD

typedef LONG  _XOSD;
typedef XOSD* LPXOSD;

#define IsValidXOSD(_xosd) ((_xosd) >= xosdNone && (_xosd) <= xosdInvalidMTE)

//
// Debugger callback types
//

typedef enum {			// debugger callback types
    dbctStop,           // debuggee has stopped -- no more dbc's will be sent
    dbctContinue		// debuggee is continuing to run
} DBCT;

//
// Debugger callbacks
//

#define DECL_DBC(name, fRequest, dbct)  dbc##name,


typedef enum {
        #include "dbc.h"
} DBC;

#undef DECL_DBC

#define IsValidDBC(_dbc) ((_dbc) > dbcNil && (_dbc) < dbcMax)


typedef DWORD PROCESS_ID;

//
// Debugger services export table
//

typedef struct {
    PVOID      (OSDAPI *  lpfnMHAlloc)        ( size_t );
    PVOID      (OSDAPI *  lpfnMHRealloc)      ( LPVOID, size_t );
    VOID       (OSDAPI *  lpfnMHFree)         ( LPVOID );


    LPSTR      (OSDAPI *  lpfnSHGetSymbol)    ( LPADDR  addr1,
                                                LPADDR  addr2,
                                                SHORT   sop, // should be SOP
                                                LPVOID  lpodr // should be LPODR
                                              );
    BOOL      (OSDAPI * lpfnSHGetPublicAddr) ( LPADDR, LSZ );

    LPSTR      (OSDAPI * lpfnSHAddrToPublicName)(LPADDR);
    LPVOID     (OSDAPI * lpfnSHGetDebugData)  ( HIND );

    PVOID      (OSDAPI *  lpfnSHLpGSNGetTable)( HIND );

    DWORD      (OSDAPI *  lpfnDHGetNumber)    ( LPSTR, LPLONG );
    MPT        (OSDAPI *  lpfnGetTargetProcessor)( HPID );
    LONG       (OSDAPI *  lpfnGetSet)         ( LPTSTR, LPTSTR, LPDWORD,
                                                BYTE*, DWORD, BOOL );
} DBF;  // Debugger callback Functions

typedef DBF FAR *LPDBF;


	


////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//
//	OSDebug callback function types
//
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// Shell callback
//

typedef XOSD (OSDAPI *
LPFNSVC)(
	DBC		dbc,
	HPID	hpid,
	HTID	htid,
	WPARAM  wParam,
	LPARAM   lParam
	);

//
// Callback to maintain Liveness of Engine
//

typedef enum {
	AddRefReq  = 0,
} REFCOUNTREQ;

	

typedef VOID (OSDAPI *
LPFNREFCOUNTENGINE)(
	LPVOID      lpRefParam,
	REFCOUNTREQ type,
	HANDLE      hThread
	);


//
// Transport callback.
//

typedef XOSD (OSDAPI *TLFUNC)();

//
// EM callback.
//

typedef XOSD (OSDAPI *EMFUNC)();


interface ISymbolHandler;


//
// EM Management
//


typedef enum _EMTYPE {
    emNative,
    emNonNative
} EMTYPE;

#define EMISINFOSIZE 80
typedef struct _EMIS {
    DWORD fCanSetup;
    DWORD dwMaxPacket;
    DWORD dwOptPacket;
    DWORD dwInfoSize;
    TCHAR rgchInfo[EMISINFOSIZE];
} EMIS;
typedef EMIS * LPEMIS;

typedef struct _EMSS {
    //
    // emfSetup is called to tell the EM to fetch workspace
    // values from the shell.
    //

    // The EM may support three phases of setup;
    // Load, interact and save.
    // Load means call GetSet for each workspace parameter
    //  with fSet == FALSE.  The value will be returned, and
    //  the EM must remember it.
    // Interact means allow the user to perform configuration
    //  operations, like clicking things in a dialog.  The new
    //  values are remembered by the EM.
    // Save means the EM will call GetSet with fSet == TRUE for
    //  each configuration value; the shell-provided GetSet
    //  will store these as workspace values.
    //
    DWORD fLoad;
    DWORD fInteractive;
    DWORD fSave;
    LPVOID lpvPrivate;

    //
    // lParam is an instance or "this" value supplied by the shell,
    // and is only used when calling lpfnGetSet().
    //
    LPARAM lParam;

    LPGETSETPROFILEPROC lpfnGetSet;
} EMSS;
typedef EMSS * LPEMSS;



// Thread State bits
typedef enum _TSTATE {
   tstRunnable   = 0,        // New thread, has not run yet.
   tstStopped    = 1,        // Thread is at a debug event
   tstRunning    = 2,        // Thread is currently running/runnable
   tstExiting    = 3,        // Thread is in the process of exiting
   tstDead       = 4,        // Thread is no longer schedulable
   tstRunMask    = 0xf,

   tstExcept1st  = 0x10,     // Thread is at first chance exception
   tstExcept2nd  = 0x20,     // Thread is at second change exception
   tstRip        = 0x30,     // Thread is in a RIP state
   tstExceptionMask = 0xf0,

   tstFrozen     = 0x100,    // Thread has been frozen by Debugger
   tstSuspended  = 0x200,    // Thread has been frozen by Other
   tstBlocked    = 0x300,    // Thread is blocked on something
                             // (i.e. a semaphore)
   tstSuspendMask= 0xf00,

   tstCritSec    = 0x1000,   // Thread is currently in a critical
                             // section.

   tstFiber      = 0x2000,   // Thread is really a Fiber (with a fake tid)

   tstOtherMask  = 0xf000
} TSTATE;



#define THREADNAMESIZE	100

//
// Thread state structure.
//

typedef struct _WORKER_HINT{
	ADDR	WorkerFn;
	ADDR	CreateThreadFn;
	ADDR	AfxBeginThreadFn;
} WORKER_HINT;

typedef struct _TST {
    DWORD dwThreadID;
    DWORD dwSuspendCount;
    DWORD dwPriority;
    DWORD dwState;
    UOFFSET dwTeb;
    TCHAR rgchThreadName [THREADNAMESIZE];
    WORKER_HINT WorkerHint;
	BOOL  fUpdateContext; // in param to signal update of context
} TST;
typedef TST * LPTST;


// Process state bits
typedef enum _PSTATE {
    pstRunning = 0,
    pstStopped = 1,
    pstDead    = 2 
} PSTATE;

//
// Process State structure.
//

typedef struct _PST {
    DWORD dwProcessID;
    DWORD dwProcessState;
	BOOL  fCanDetach;
	XOSD  xosdDetachFailure;
} PST;
typedef PST * LPPST;

//
// Debug metrics.
//

typedef enum _MTRC {
    mtrcProcessorType ,
    mtrcProcessorLevel,
	mtrcPageSize,
    mtrcEndian,
    mtrcAddressMode,

} MTRC;

//  Return values for mtrcEndian -- big or little endian -- which
//  byte is [0] most or least significat byte
typedef enum _END {
    endBig,
    endLittle
} END;

//  Return values for mtrcAddressMode
typedef enum _ADDRMODE {
    addressModeUnknown = 0,
    addressMode32Bit  = 1,
    addressMode64Bit  = 2
} ADDRMODE;

typedef enum _BPTS {
    bptsExec     = 0x0001,
    bptsDataC    = 0x0002,
    bptsDataW    = 0x0004,
    bptsDataR    = 0x0008,
    bptsRegC     = 0x0010,
    bptsRegW     = 0x0020,
    bptsRegR     = 0x0040,
    bptsMessage  = 0x0080,
    bptsMClass   = 0x0100,
    bptsRange    = 0x0200,
    bptsDataExec = 0x0400,
    bptsPrologOk = 0x0800   // BP in prolog is harmless
} BPTS;



//
// Address manipulation
//

typedef enum _ADR {
    adrCurrent,
    adrPC,
    adrBase,
    adrStack,
    adrData,
    adrTlsBase,
    adrBaseProlog,
    adrBackStore
} ADR;



////
//// Module lists
////
//
//typedef struct _MODULE_LIST {
//    DWORD           Count;
//} MODULE_LIST;
//typedef struct _MODULE_LIST * LPMODULE_LIST;

//
// Type of Debug_Info that the Dm conveys back to Sapi
// and engine
//
typedef enum {
    DBG_TYPE_NONE = 0,
	DBG_TYPE_PDB,
	DBG_TYPE_DBG
} DBG_TYPE;

//
// Module Debug Structure
//
// This sturcture is used by the DM to return
// debug information that it finds in a module
// back to the EM.
//

#pragma pack(push,4)

typedef struct _MODULE_DEBUG_INFO
{
	DBG_TYPE dbgType;
	DWORD dbgVersion;				// DEBUG_INFO_PDB6/7

	union {
		DWORDLONG All;
	    struct
	    {
			ULONG fmt;
			ULONG filepos;
            ULONG sig;
	        ULONG age;
	        TCHAR szMBCS[_MAX_PATH*3];
	    } pdbInfo6;
		struct
		{
			ULONG fmt;
			GUID guid;
			DWORD age;
			TCHAR szUTF8[_MAX_PATH*3];
		} pdbInfo7;
	};
} MODULE_DEBUG_INFO;

#pragma pack(pop)

#define	DEBUG_INFO_PDB6	'01BN'		// NB10
#define	DEBUG_INFO_PDB7	'SDSR'		// RSDS

typedef MODULE_DEBUG_INFO* LPMODULE_DEBUG_INFO;

//
// Module Information - Kept in the EM accessed by OSD
// layer
//
typedef struct _MOD_INFO {
	UOFFSET         BaseAddress;
	DWORD 			TimeDateStamp;
	DWORD 			CheckSum;
	DWORD           Size;
	UOFFSET         PrefferedBase;
	DWORD           LoadOrder;
	bool            f64Bit;              // is this a 64bit dll 

} MOD_INFO, *LPMOD_INFO;


typedef struct _MODULE_ENTRY {

//	MOD_INFO      modInfo;

//    UOFFSET            Base;
//	DWORD	           TimeDateStamp;
//	DWORD	           CheckSum;
//    UOFFSET            PreferredBase;
//    DWORD              LoadOrder;
//    UOFFSET            Limit;
//    DWORD              Segment;
//    DWORD              Selector;
//    DWORD              Type;

//	DWORD	           SectionAlignment;
//    DWORD              SectionCount;

//    DWORD              Flat;
//    DWORD              Real;

//    HEMI               hemi;

	DWORD              modId;
	MOD_INFO           modInfo;
    TCHAR              Name[ MAX_PATH ];
    TCHAR              Version[ MAX_PATH ];
	MODULE_DEBUG_INFO  debugInfo;
} MODULE_ENTRY;
typedef struct _MODULE_ENTRY * LPMODULE_ENTRY;






//
// Bit flags for dwFlags in OSDProgramLoad
//

#define ulfMultiProcess             0x0001L     // OS2, NT, and ?MAC?
#define ulfMinimizeApp              0x0002L     // Win32
#define ulfNoActivate               0x0004L     // Win32
#define ulfInheritHandles           0x0008L     // Win32  (DM only?)
//#define ulfWowVdm                   0x0010L     // Win32
//#define ulfSqlDebug                 0x0040L     // SQL debugging wanted
#define	ulfSuspended				0x0080L		// Win32


//
// DM specific launch codes - these determine which
// state the DM should launch the process in - currently there
// are three supported states
//
// 1. Native only
// 2. InterOp mode
// 3. Detach Mode

typedef enum  { 
	modeNative  = 0,
	modeComPlus,
	modeNub
}LAUNCHMODE;


//
// Target execution control
//

typedef struct _EXOP {
    BYTE fStepOver;
    BYTE fInitialBP;
    BYTE fPassException;
    BYTE fSetFocus;
	BYTE fInterOpStepInto;
	BYTE fInterOpConsumeAllEvents; // consume all events (interop only)
} EXOP;
typedef EXOP * LPEXOP;




///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//
// Types which we can't seem to escape
//

typedef struct {
    BYTE b[10];
} REAL10;
typedef REAL10 FAR * LPREAL10;



//
// Packet supplied to shell by dbcCanStep
//
//

typedef struct _CANSTEPREQ {
    ADDR      addr;
	BOOL      fGetThunkInfo;
	UOFFSET   validInstrAddr; // only needed if fGetThunkInfo is set
} CANSTEPREQ, *LPCANSTEPREQ;

typedef struct _CANSTEP {
    DWORD   Flags;

	//
	// These are returned if fGetThunkInfo is set
	//
	DWORD   ThunkInstrSize;           
	UOFFSET ThunkInstrOffset;             

	union {
		UOFFSET PrologOffset;		// when flags == CANSTEP_YES
		DWORD   ThunkSize;			// when flags == CANSTEP_THUNK_OVER
                                    //v-vadimp - ever more than 4G?
	};
} CANSTEP, *LPCANSTEP;

typedef CANSTEP FAR *LPCANSTEP;

enum {
	CANSTEP_NO			= 0x0000,
	CANSTEP_YES			= 0x0001,
	CANSTEP_THUNK		= 0x0002,
	CANSTEP_THUNK_OVER	= 0x0003
};

//
// This structure is used in communicating a stop event to the EM.  It
// contains the most basic of information about the stopped thread.  A
// "frame" pointer, a program counter and bits describing the type of
// segment stopped in.
//

typedef struct _BPR {
    DWORD_PTR   dwNotify;       // Tag to identify BP #
    UOFFSET     offEIP;			// Program Counter offset
    UOFFSET     offEBP;         // Frame pointer offset
    UOFFSET     offESP;         // Stack pointer offset
    SEGMENT     segCS;          // Program counter seletor
    SEGMENT     segSS;          // Frame & Stack pointer offset
    DWORD       fFlat : 1;
    DWORD       fOff32 : 1;
    DWORD       fReal : 1;
} BPR; // BreakPoint Return

typedef BPR FAR *LPBPR;

//
// Structure returned via dbcMsg*
//

typedef struct _MSGI {
    DWORD dwMessage;
    DWORD dwMask;
    ADDR  addr;
    CHAR  rgch [ ];
} MSGI;     // MeSsaGe Info
typedef MSGI FAR *LPMSGI;



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Exception Handling Data structures
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

typedef enum {
	ExceptionTypeCxx32,
	ExceptionTypeCxx64,
	ExceptionTypeNative32,
	ExceptionTypeNative64
} EXCEPTION_TYPE;

//
// BUGBUG: allow arbitrary length type names
//

typedef struct _TYPE_NAME {
	CHAR	szName [256];
} TYPE_NAME;

typedef struct _EPR {
    BPR   bpr;
    DWORD dwFirstChance;
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
	EXCEPTION_TYPE ExceptionType;

	union {

		struct {
			DWORDLONG Align;
		} JustForKicks;

		struct {
			DWORD NumberParameters;
			DWORD ExceptionInformation[];
		} Native32;

		struct {
			DWORDLONG NumberParameters;
			DWORDLONG ExceptionInformation[];
		} Native64;

		struct {
			DWORDLONG ThisPtr;
			DWORD NumberOfCatchableTypes;
			TYPE_NAME TypeNameArray [];
		} Cxx;

	} u;
	
} EPR; // Exception Return



//
// These are the actions which the debugger may take
// in response to an exception raised in the debuggee.
//

typedef enum _EXCEPTION_FILTER_DEFAULT {
    efdIgnore,
    efdNotify,
    efdCommand,
    efdStop
} EXCEPTION_FILTER_DEFAULT;
typedef EXCEPTION_FILTER_DEFAULT * LPEXCEPTION_FILTER_DEFAULT;

//
// commands understood by OSDGetExceptionState
//

typedef enum _EXCEPTION_CONTROL {
    exfFirst,
    exfNext,
    exfSpecified
} EXCEPTION_CONTROL;
typedef EXCEPTION_CONTROL * LPEXCEPTION_CONTROL;

//
// Exception information packet
//

#define EXCEPTION_STRING_SIZE 60
typedef struct _EXCEPTION_DESCRIPTION {
    DWORD                    dwExceptionCode;
    EXCEPTION_FILTER_DEFAULT efd;
    TCHAR                    rgchDescription[EXCEPTION_STRING_SIZE];
} EXCEPTION_DESCRIPTION;
typedef EXCEPTION_DESCRIPTION * LPEXCEPTION_DESCRIPTION;


typedef EPR FAR *LPEPR;

//
// Structure passed with dbcInfoAvail
//

typedef struct _INFOAVAIL {
    DWORD   fReply;
    DWORD   fUniCode;
    BYTE    buffer[];   // the string
} INFOAVAIL; // InfoAvail return
typedef INFOAVAIL FAR * LPINFOAVAIL;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//     Message information
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

enum {
    msgMaskNone  = 0x0,
    msgMaskWin   = 0x1,
    msgMaskInit  = 0x2,
    msgMaskInput = 0x4,
    msgMaskMouse = 0x8,
    msgMaskSys   = 0x10,
    msgMaskClip  = 0x20,
    msgMaskNC    = 0x40,
    msgMaskDDE   = 0x80,
    msgMaskOther = 0x100,
    msgMaskAll   = 0x0FFF,
};


typedef struct _MESSAGEINFO {
    DWORD   dwMsg;         //  Message number
    LPTSTR  lszMsgText;    //  Message Text
    DWORD   dwMsgMask;     //  Message mask
} MESSAGEINFO;
typedef struct _MESSAGEINFO *LPMESSAGEINFO;

//
//  MSG Map structure
//

typedef struct _MESSAGEMAP {
    DWORD          dwCount;      //  Number of elements
    LPMESSAGEINFO  lpMsgInfo;    //  Pointer to array
} MESSAGEMAP;
typedef struct _MESSAGEMAP *LPMESSAGEMAP;


typedef struct _MASKINFO {
    DWORD dwMask;
    LPTSTR lszMaskText;
} MASKINFO;
typedef MASKINFO * LPMASKINFO;

typedef struct _MASKMAP {
    DWORD dwCount;
    LPMASKINFO lpMaskInfo;
} MASKMAP;
typedef MASKMAP * LPMASKMAP;



//
// function information; derived from
// FPO, PDATA or whatever else there may be.
//
// This will contain information pertaining to the block
// containing the address specified in OSDGetFunctionInformation().
// It may be a nested block; it need not be an entire function.
//

typedef struct _FUNCTION_INFORMATION {
    ADDR    AddrStart;          // fixedup addresses
    ADDR    AddrPrologEnd;
    ADDR    AddrEnd;            // end of function
    //ADDR    FilterAddress;      // Address of exception filter
} FUNCTION_INFORMATION, *LPFUNCTION_INFORMATION;


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//	Register types --- flags describing recommendations on register display.
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

enum {
    rtProcessMask   = 0x0000000f,     // Mask for processor type bits
                                	  // these are enumerates, not bitfields.
    rtCPU           = 0x00000000,     // Central Processing Unit
	rtCPUSeg		= 0x00000001,	  // CPU Segment registers
    rtFPU           = 0x00000002,     // Floating Point Unit
	rtMMX			= 0x00000003,	  // Multimedia regs
	rtKatmai		= 0x00000004,	  // KatMai regs
    rtWillamette    = 0x00000005,
    rt3DNow         = 0x00000006,
	rtStacked		= 0x00000007,     // Merced stacked registers
    rtApplication   = 0x00000008,     // Merced application regs
	rtBranch		= 0x00000009,	  // Merced branch regs
	
    rtProcessMax    = 0x0000000a,	  // How many groups? 

    rtProcessorMask = 0x0000fff0,	  // Reg Groups - bitfields
	rtMMXProc		= 0x00000010,	  // Multimedia regs
	rtKatmaiProc	= 0x00000020,	  // KatMai regs
    rtWillametteProc= 0x00000040,
    rt3DNowProc     = 0x00000080,
                                      // This is the wrong place for this - JOC

    rtGroupMask     = 0x000f0000,     // Which group(s) register falls into
                                	  // Bitfields
    rtInvisible     = 0x00010000,     // Recommend no display
    rtRegular       = 0x00020000,     // Recommend regular display
    rtExtended      = 0x00040000,     // Recommend extended display
    rtSpecial       = 0x00080000,     // Special and hidden regs, e.g. kernel mode

    rtFmtTypeMask   = 0x00f00000,     // Mask of display formats
                                	  // these are enumerates, not bitfields.
    rtInteger       = 0x00100000,     // Unsigned integer format
    rtFloat         = 0x00200000,     // Floating point format
    rtAddress       = 0x00300000,     // Address format
    rtBit 			= 0x00400000,     // IA64 registers displayed as bits

    rtMiscMask      = 0x0f000000,     // misc info
	                               	  // Bitfields
    rtPC            = 0x01000000,     // this is the PC
    rtFrame         = 0x02000000,     // this reg affects the stack frame
    rtNewLine       = 0x04000000,     // print a newline when listing
    rtFlags         = 0x08000000,     // Flags register (cast is to avoid warning)

    rtIA64Mask      = 0xf0000000,     // Mask for IA64 special values
    rtStack         = 0x10000000,     // stacked IA64 register - check the stack frame before displaying - may not be used if stack registers are moved to a separate group
    rtNat           = 0x20000000      // has a NAT bit - check the NAT register and format accordingly
};
typedef DWORD RT;   // Register Types

#define rtFmtTypeShift  8

enum {
    ftProcessMask   = 0x0f,     // Mask for processor type bits
                                // these are enumerates, not bitfields.
    ftCPU           = 0x00,     // Central Processing Unit
    ftFPU           = 0x01,     // Floating Point Unit
    ftMMU           = 0x02,     // Memory Manager Unit
	ftProcessMax	= 0x03,		// How many groups?

    ftGroupMask     = 0xf0,     // Which group(s) register falls into
                                // Bitfields
    ftInvisible     = 0x10,     // Recommend no display
    ftRegular       = 0x20,     // Recommend regular display
    ftExtended      = 0x40,     // Recommend extended display
    ftSpecial       = 0x80,     // Special and hidden regs, e.g. kernel mode

    ftFmtTypeMask   = 0xf00,    // Mask of display formats
                                // these are enumerates, not bitfields.
    ftInteger       = 0x100,    // Unsigned integer format
    ftFloat         = 0x200,    // Floating point format
    ftAddress       = 0x300,    // Address format

    ftMiscMask      = 0xf000,   // misc info
                                // Bitfields
    ftPC            = 0x1000,   // this is the PC
    ftFrame         = 0x2000,   // this reg affects the stack frame
    ftNewLine       = 0x4000    // print a newline when listing
};
typedef DWORD FT;   // Flag Types

#define ftFmtTypeShift  8

//
//  Register description:  This structure contains the description for
//		a register on the machine.  Note that dwId must be used to get
//		the value for this register but a different index is used to get
//		this description structure.
//

typedef struct {
    LPTSTR      lszName;        /* Pointer into EM for registers name   */
    RT          rt;             /* Register Type flags                  */
    DWORD       dwcbits;        /* Number of bits in the register       */
    DWORD       dwGrp;
    DWORD       dwId;           /* Value to use with Read/Write Register*/
} RD;               // Register Description
typedef RD * LPRD;

enum _RegAttrib {
	REG_ISNAT		= 0x00000001,
	REG_ISINVALID	= 0x00000002
};

typedef struct _RWReg {
	LPDWORD	attribs;
	LPVOID	lpv;
} RWReg;

//
//  Flag Data description: This structure contains the description for
//      a flag on the machine. Note that the dwId field contains the
//      value to be used with Read/Write register to get the register which
//      contains this flag.
//

typedef struct _FD {
    LPTSTR         lszName;
    FT          ft;
    DWORD       dwcbits;
    DWORD       dwGrp;
    DWORD       dwId;
} FD;
typedef FD * LPFD;


////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//
// Breakpoint Data Structures
//
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

typedef enum {
    bptpExec,			// Standard code BP
    bptpDataC,			// data: ??
//    bptpDataW,			// data: Write
//    bptpDataR,			// data: Read
//    bptpDataExec,		// data: Execute
    bptpRange,			// Range
} BPTP;


typedef enum {
    bpnsStop,
    bpnsContinue,
    bpnsCheck,
    bpnsMax
} BPNS;

typedef struct _BPIS {
    BPTP   bptp;
    BPNS   bpns;
    DWORD  fOneThd;
    union {
        HTID   htid;
        DWORDLONG Align;
    };

	union {
        struct {
            ADDR	addr;
        } exec;
		
        struct {
            ADDR	addr;
            DWORD	cb;
            BOOL	fEmulate;
        } data;
		
        struct {
            DWORD	dwId;
        } reg;
		
        struct {
            ADDR	addr;
            DWORD	imsg;
            DWORD	cmsg;
        } msg;
		
        struct {
            ADDR	addr;
            DWORD	dwmask;
        } mcls;
		
        struct {
            DWORD	ipt;
        } ipt;
		
        struct {
            ADDR	addr;
            DWORD	cb;
        } rng;

		struct {
			ADDR	BaseOfImage;
			UINT	iSection;
		} module;
    };
} BPIS;
typedef BPIS * LPBPIS;


typedef struct _BPRS {
	BPIS	bpis;
    union {
        DWORDLONG Align;
        DWORD_PTR Notify;
    };
	XOSD	xosd;
} BPRS;
typedef BPRS* LPBPRS;


typedef struct _BPS {
    DWORD cbpis;
    DWORD fSet;
	BPRS  rgBprs [0];
} BPS;
typedef BPS * LPBPS;

#define SizeofBPS(B) ( sizeof (BPS) + ((LPBPS) (B))->cbpis * sizeof (BPRS) )


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//	Assembly and Disassembly Data structures
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

enum {
    dopNone     = 0x00000000,
    dopAddr     = 0x00000001,   // put address (w/ seg) in front of disassm
    dopFlatAddr = 0x00000002,   // put flat address (no seg)
    dopOpcode   = 0x00000004,   // dump the Opcode
    dopOperands = 0x00000008,   // dump the Operands
    dopRaw      = 0x00000010,   // dump the raw code bytes
    dopEA       = 0x00000020,   // calculate the effective address
    dopSym      = 0x00000040,   // output symbols
    dopUpper    = 0x00000080,   // force upper case for all chars except syms
    dopHexUpper = 0x00000100,   // force upper case for all hex constants
                                // (implied true if dopUpper is set)
    dopIP       = 0x00000200,   // addrIP is set
};
typedef DWORD DOP;              // Disassembly OPtions


typedef struct _SDI {
    DOP    dop;              // Disassembly OPtions (see above)
    ADDR   addr;             // The address to disassemble
	ADDR   addrIP;           // The address of the IP to align with (if dopIP is set)
    BOOL   fAssocNext;       // This instruction is associated w/ the next one
    BOOL   fIsBranch;
    BOOL   fIsCall;
    BOOL   fJumpTable;
    ADDR   addrEA0;          // First effective address
    ADDR   addrEA1;          // Second effective address
    ADDR   addrEA2;          // Third effective address
    DWORD  cbEA0;            // First effective address size
    DWORD  cbEA1;            // Second effective address size
    DWORD  cbEA2;            // Third effective address size
    LONG   ichAddr;
    LONG   ichBytes;
    LONG   ichOpcode;
    LONG   ichOperands;
    LONG   ichComment;
    LONG   ichEA0;
    LONG   ichEA1;
    LONG   ichEA2;
    LPTSTR lpch;
} SDI;  // Structured DiSsassembly
typedef SDI *LPSDI;


typedef struct _CALL_INFO {
	DWORD dwCount;			// IN: max ADDRs to return, OUT: how may we got
	ADDR addrStart;			// IN: where to start
	ADDR addrEnd;			// OUT:where to stop
	LPADDR addrList;		// OUT:list of ADDRs (size in dwCount)
} CALL_INFO;


////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//
//	File Management Data Structures
//
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

enum {
	OSD_IMAGE_UNKNOWN,
	OSD_IMAGE_TYPE_PE,
	OSD_IMAGE_TYPE_CRASHDUMP
};

typedef DWORD OSD_IMAGE_TYPE;

typedef struct _OSDIMAGEINFO {
    IMAGE_INFO ImageInfo;  // from toolhrt.h
} OSDIMAGEINFO;
	
typedef struct _OSDFINDFILEINFO {
	TCHAR	szFileName [MAX_PATH];
	DWORD	nFileSizeHigh;
	DWORD	nFileSizeLow;
	DWORD	nFileTimeLow;
	DWORD	nFileTimeHigh;
} OSDFINDFILEINFO;


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//     OS Specific info and control
//
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


typedef struct _OSDTASKENTRY {
	// from toolhrt.h
    TASK_ENTRY taskEntry;	
} OSDTASKENTRY;

typedef OSDTASKENTRY * LPOSDTASKENTRY;

typedef struct _OSDTASKLIST {
    DWORD			dwCount;
    OSDTASKENTRY	rgTasks [];
} OSDTASKLIST;
typedef OSDTASKLIST * LPOSDTASKLIST;

//
//
// Hard / Soft mode stuff which can probably be removed.
//

enum {
    dbmSoftMode,
    dbmHardMode
};

typedef DWORD DBM;

//
// Used for OSDSetDebugMode -- is this useful anymore??
//

typedef struct _DBMI {
    HWND hWndFrame;
    HWND hWndMDIClient;
    HANDLE hAccelTable;
} DBMI;

//
// Packet for DebugActiveProcess
//
//
typedef struct _DAP {

    DWORD      dwProcessId;
	LAUNCHMODE mode;
	BOOL       fInterOpLaunch; // an interop mode launch?
	BOOL       fStartDmThread;
	union {
	HPID       hpid;
	DWORDLONG  AlignHpid;
	};
	TCHAR      szFullPathHint[_MAX_PATH];
} DAP;

typedef DAP FAR * LPDAP;

//
// Length of a TL error.
//

#define TL_ERROR_BUFFER_LENGTH  1024

//
// System Services
//

#include "ssvc.h"
#define FIRST_PRIVATE_SSVC 0x8000

//
// Stack Range Walking stuff
//
//

typedef struct _STACK_RANGE {

	DWORDLONG eIp;
	DWORDLONG segCs;
	DWORDLONG segSs;
	DWORDLONG eSp;
	DWORDLONG startEbp;
	DWORDLONG endEbp;
	HFRAME  currFrame;

} STACK_RANGE, *LPSTACK_RANGE;


//
// Used by tlfConnect
//
//
typedef struct _TLFCONNECTMSG {
	LPFNREFCOUNTENGINE lpRefFunc;
	LPVOID             lpRefFuncParam;     
 	LPCTSTR            lszOptions;
	TCHAR              szRegRoot[1024];
} TLFCONNECTMSG, *LPTLFCONNECTMSG;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\internalnt.h ===
// contains items culled from NT DDK headers
// sorted by which file they were copied from

// this macro to use undefined types as pointers
#define	SOME_POINTER(foo)	void*

// from ntdef.h
typedef LONG NTSTATUS;

//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;

// from privnt.h
typedef LONG KPRIORITY;

// from ntdef.h
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

// from ntpsapi.h

//
// Thread Information Classes
//

typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair_Reusable,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending,
    ThreadHideFromDebugger,
    MaxThreadInfoClass
    } THREADINFOCLASS;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;

//
// Basic Thread Information
//  NtQueryInformationThread using ThreadBasicInfo
//

typedef struct _THREAD_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    SOME_POINTER(PTEB) TebBaseAddress;
    CLIENT_ID ClientId;
    ULONG_PTR AffinityMask;
    KPRIORITY Priority;
    LONG BasePriority;
} THREAD_BASIC_INFORMATION;
typedef THREAD_BASIC_INFORMATION *PTHREAD_BASIC_INFORMATION;

#ifdef _IA64_
#include <pshpck16.h>
#endif

typedef struct _FIBER {

    PVOID FiberData;

    //
    // Matches first three DWORDs of TEB
    //

    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;

    //
    // Used by base to free a thread's stack
    //

    PVOID DeallocationStack;

    CONTEXT FiberContext;

    SOME_POINTER(PWX86TIB) Wx86Tib;

#ifdef  _IA64_
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif

} FIBER, *PFIBER;

#ifdef _IA64_
#include <poppack.h>
#endif

//
// Gdi command batching
//

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH {
    ULONG    Offset;
    ULONG_PTR HDC;
    ULONG    Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH,*PGDI_TEB_BATCH;


//
// Wx86 thread state information
//

typedef struct _Wx86ThreadState {
    PULONG  CallBx86Eip;
    PVOID   DeallocationCpu;
    BOOLEAN UseKnownWx86Dll;
    char    OleStubInvoked;
} WX86THREAD, *PWX86THREAD;


//
//  TEB - The thread environment block
//

#define STATIC_UNICODE_BUFFER_LENGTH 261
#define WIN32_CLIENT_INFO_LENGTH 62

#define WIN32_CLIENT_INFO_SPIN_COUNT 1

typedef struct _TEB {
    NT_TIB NtTib;
    PVOID  EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    SOME_POINTER(PPEB) ProcessEnvironmentBlock;
    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;          // PtiCurrent
    ULONG User32Reserved[26];       // user32.dll items
    ULONG UserReserved[5];          // Winsrv SwitchStack
    PVOID WOW32Reserved;            // used by WOW
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister; // offset known by outsiders!
    PVOID SystemReserved1[54];      // Used by FP emulator
    NTSTATUS ExceptionCode;         // for RaiseUserException
    UCHAR SpareBytes1[44];
    GDI_TEB_BATCH GdiTebBatch;      // Gdi batching
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG_PTR Win32ClientInfo[WIN32_CLIENT_INFO_LENGTH]; // User32 Client Info
    PVOID glDispatchTable[233];     // OpenGL
    ULONG_PTR glReserved1[29];      // OpenGL
    PVOID glReserved2;              // OpenGL
    PVOID glSectionInfo;            // OpenGL
    PVOID glSection;                // OpenGL
    PVOID glTable;                  // OpenGL
    PVOID glCurrentRC;              // OpenGL
    PVOID glContext;                // OpenGL
    ULONG LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[STATIC_UNICODE_BUFFER_LENGTH];
    PVOID DeallocationStack;
    PVOID TlsSlots[TLS_MINIMUM_AVAILABLE];
    LIST_ENTRY TlsLinks;
    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];
    ULONG HardErrorsAreDisabled;
    PVOID Instrumentation[16];
    PVOID WinSockData;              // WinSock
    ULONG GdiBatchCount;
    BOOLEAN InDbgPrint;
    BOOLEAN SpareB1;
    BOOLEAN SpareB2;
    BOOLEAN SpareB3;
    ULONG Spare3;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    WX86THREAD Wx86Thread;
    PVOID *TlsExpansionSlots;
#ifdef  _IA64_
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    LCID ImpersonationLocale;      // Current locale of impersonated user
    ULONG IsImpersonating;         // Thread impersonation status
    PVOID NlsCache;                // NLS thread cache
} TEB;
typedef TEB *PTEB;

// from ntstatus.h

//
// MessageId: STATUS_DLL_NOT_FOUND
//
// MessageText:
//
//  {Unable To Locate DLL}
//  The dynamic link library %hs could not be found in the specified path %hs.
//
#define STATUS_DLL_NOT_FOUND             ((NTSTATUS)0xC0000135L)

//
// MessageId: STATUS_SUSPEND_COUNT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to suspend a thread whose suspend count was at its maximum.
//
#define STATUS_SUSPEND_COUNT_EXCEEDED    ((NTSTATUS)0xC000004AL)

//
// MessageId: STATUS_THREAD_IS_TERMINATING
//
// MessageText:
//
//  An attempt was made to suspend a thread that has begun termination.
//
#define STATUS_THREAD_IS_TERMINATING     ((NTSTATUS)0xC000004BL)

//
// MessageId: STATUS_DLL_INIT_FAILED
//
// MessageText:
//
//  {DLL Initialization Failed}
//  Initialization of the dynamic link library %hs failed. The process is terminating abnormally.
//
#define STATUS_DLL_INIT_FAILED           ((NTSTATUS)0xC0000142L)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\od.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Od.h

Abstract:

    This file contains types and prototypes which are exposed
    to all OSDebug components and clients.

Author:

    Kent Forschmiedt (kentf) 10-Sep-1993

Environment:

    Win32, User Mode

--*/

#pragma once

#include "odtypes.h"

#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
//     OSDebug API set
//

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


//
//	OSDebug Initialization/Termination
//


XOSD
OSDAPI
OSDInit(
    LPDBF lpdbf
    );

XOSD
OSDAPI
OSDTerm(
    VOID
    );

//
//	Execution Model Management
//

XOSD
OSDAPI
OSDAddEM(
    EMFUNC emfunc,
    LPDBF lpdbf,
    LPHEM lphem,
    EMTYPE emtype
    );

XOSD
OSDAPI
OSDDeleteEM(
    HEM hem
    );

XOSD
OSDAPI
OSDSetTLEMBuffer(
    HEM hem,
	HTL htl
    );

XOSD
OSDAPI
OSDGetCurrentEM(
    HPID hpid,
    HTID htid,
    LPHEM lphem
    );

XOSD
OSDAPI
OSDNativeOnly(
    HPID hpid,
    HTID htid,
    DWORD fNativeOnly
    );

XOSD
OSDAPI
OSDUseEM(
    HPID hpid,
    HEM hem
    );

XOSD
OSDAPI
OSDDiscardEM(
    HPID hpid,
    HTID htid,
    HEM hem
    );

XOSD
OSDAPI
OSDEMGetInfo(
    HEM hem,
    LPEMIS lpemis
    );

//XOSD
//OSDAPI
//OSDSetLocale (
//	HEM m_hem, 
//	WORD wLangID
//	);

XOSD
OSDAPI
OSDEMSetup(
    HEM hem,
    LPEMSS lpemss
    );

//
//	Transport Layer Management
//

XOSD
OSDAPI
OSDAddTL(
    TLFUNC tlfunc,
    LPDBF lpdbf,
    LPHTL lphtl
    );

XOSD
OSDAPI
OSDStartTL(
    HTL htl
    );

XOSD
OSDAPI
OSDDiscardTL(
	HPID	hpid,
	HTL     htl
	);

XOSD
OSDAPI
OSDDeleteTL(
    HTL htl
    );

XOSD
OSDAPI
OSDTLGetInfo(
    HTL htl,
    LPTLIS lptlis
    );

XOSD
OSDAPI
OSDTLSetup(
    HTL htl,
    LPTLSS lptlss
    );

XOSD
OSDAPI
OSDDisconnect(
    HPID hpid,
    HTID htid
    );

//
// Process, thread management
//

XOSD
OSDAPI
OSDCreateHpid(
    LPFNSVC lpfnsvcCallBack,
    HEM hemNative,
    HTL htl,
    LPHPID lphpid,
	LPTLFCONNECTMSG  lpTlfConnectMsg
    );

XOSD
OSDAPI
OSDDestroyHpid(
    HPID hpid
    );

XOSD
OSDAPI
OSDDestroyHtid(
    HPID hpid,
    HTID htid
    );

XOSD
OSDAPI
OSDGetThreadStatus(
    HPID hpid,
    HTID htid,
    LPTST lptst
    );

XOSD
OSDAPI
OSDGetProcessStatus(
    HPID hpid,
    LPPST lppst
    );

namespace od {
	enum ThreadManipulate {
		Thaw,
		Freeze,
		SetStopped
	};

	enum LockUnLock  {
		Lock,
		UnLock,
		HackLock
	};
		
};
	

XOSD
OSDAPI
OSDManipulateThread(
    HPID  				    hpid,
    HTID  				    htid,
	od::ThreadManipulate    manReq 
    );

XOSD
OSDAPI
OSDLockUnLock(
    HPID  				    hpid,
	od::LockUnLock			lockReq
    );

XOSD
OSDAPI
OSDSetThreadPriority(
    HPID hpid,
    HTID htid,
    DWORD dwPriority
    );

XOSD
OSDAPI
OSDGetAddr(
    HPID hpid,
    HTID htid,
	HFRAME hStackFrame,
    ADR adr,
    LPADDR lpaddr
    );

XOSD
OSDAPI
OSDSetAddr(
    HPID hpid,
    HTID htid,
	HFRAME hStackFrame,
    ADR adr,
    LPADDR lpaddr
    );

XOSD
OSDAPI
OSDFixupAddr(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr
    );

XOSD
OSDAPI
OSDUnFixupAddr(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr
    );

XOSD
OSDAPI
OSDSetEmi(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr
    );

XOSD
OSDAPI
OSDRegisterEmi(
    HPID	hpid,
	HMODULE	hModule,
    HEMI	hemi,
	ISymbolHandler*	sapi
	);

XOSD
OSDAPI
OSDUpdateEmi(
    HPID	hpid,
    HEMI	hemi,
	ISymbolHandler*	sapi
	);

XOSD
OSDAPI
OSDUnRegisterEmi(
    HPID hpid,
    HEMI hemi
    );

XOSD
OSDAPI
OSDCompareAddrs(
    HPID hpid,
    LPADDR lpaddr1,
    LPADDR lpaddr2,
    LPLONG lpdwResult
    );

//
// Program Load / Unload
//

XOSD
OSDAPI
OSDSpawnOrphan(
    HPID hpid,
    LPCTSTR lszRemoteExe,
    LPCTSTR	lszCmdLineArgs,
    LPCTSTR	lszRemoteDir,
    DWORD dwFlags,
	PROCESS_ID*	ProcessId
    );

XOSD
OSDAPI
OSDProgramLoad(
    HPID       hpid,
    LPTSTR     lszRemoteExe,
    LPTSTR     lszArgs,
    LPTSTR     lszWorkingDir,
    LPTSTR     lszDebugger,
    DWORD      dwFlags,
	LAUNCHMODE mode
    );

XOSD
OSDAPI
OSDDebugActive(
    HPID hpid,
    LPVOID lpvData,
    DWORD cbData
    );


XOSD
OSDAPI
OSDDetach(
    HPID hpid,
    DWORD dwFlags
    );

XOSD
OSDAPI
OSDLoadCrashDump(
	IN HPID hpid,
	IN LPCTSTR szDumpFile
	);

XOSD
OSDAPI
OSDProgramFree(
    HPID hpid
    );

XOSD
OSDAPI
OSDSetPath(
    HPID hpid,
    DWORD fSet,
    LPTSTR lszPath
    );

//
// Target Execution
//

XOSD
OSDAPI
OSDGo(
    HPID hpid,
    HTID htid,
    LPEXOP lpexop
    );

XOSD
OSDAPI
OSDSingleStep(
    HPID hpid,
    HTID htid,
    LPEXOP lpexop
    );

XOSD
OSDAPI
OSDRangeStep(
    HPID hpid,
    HTID htid,
    LPADDR lpaddrMin,
    LPADDR lpaddrMax,
    LPEXOP lpexop
    );

XOSD
OSDAPI
OSDReturnStep(
    HPID hpid,
    HTID htid,
	HFRAME hFrame,
    LPEXOP lpexop
    );

XOSD
OSDAPI
OSDAsyncStop(
    HPID hpid,
	BOOL fFastBreak
    );


XOSD
OSDAPI
OSDNextReadableMemory(
    HPID 	  hpid,
    HTID      htid,
	UOFFSET   addrStart,
	DWORD     dwRange,
	UOFFSET*  addrNextReadable
);

//
// Target function evaluation
//

XOSD
OSDAPI
OSDSetupExecute(
    HPID hpid,
    HTID htid,
    LPHIND lphind
    );

XOSD
OSDAPI
OSDStartExecute(
    HPID hpid,
    HIND hind,
    LPADDR lpaddr,
    DWORD fIgnoreEvents,
    DWORD fFar
    );

XOSD
OSDAPI
OSDCleanUpExecute(
    HPID hpid,
    HIND hind
    );


//
// Target information
//

XOSD
OSDAPI
OSDGetDebugMetric(
    HPID hpid,
    HTID htid,
    MTRC mtrc,
    LPVOID lpv
    );


XOSD
OSDAPI
OSDGetMemoryInformation(
    HPID hpid,
    HTID htid,
    LPMEMINFO lpMemInfo
    );


XOSD
OSDGetModuleInfo(
    HPID            hpid,
    HTID            htid,
	DWORD           modIndex,
	LPMOD_INFO      lpModuleInfo
    );


//
// Target memory and objects
//


XOSD
OSDAPI
OSDReadMemory(
    HPID hpid,
    HTID htid,
    LPCADDR lpaddr,
    LPVOID lpBuffer,
    DWORD cbBuffer,
    LPDWORD lpcbRead
    );

XOSD
OSDAPI
OSDWriteMemory(
    HPID hpid,
    HTID htid,
    LPCADDR lpaddr,
    LPVOID lpBuffer,
    DWORD cbBuffer,
    LPDWORD lpcbWritten
    );

XOSD
OSDAPI
OSDVirtualAllocEx(
    HPID hpid,
    LPADDR lpaddr,
    DWORD allocSize,
	LPUOFFSET allocOffset
    );

XOSD
OSDAPI
OSDLoadLibrary(
    HPID hpid,
    PADDR paddr,
    LPCTSTR szDllName
    );

XOSD
OSDAPI
OSDGetObjectLength(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
    LPUOFFSET lpuoffStart,
    LPUOFFSET lpuoffLength
    );

XOSD
OSDGetFunctionInformation(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
    LPFUNCTION_INFORMATION lpFunctionInformation
    );
	
//
// Register manipulation
//

XOSD
OSDAPI
OSDGetRegDesc(
    HPID hpid,
    HTID htid,
    DWORD ird,
    LPRD lprd
    );

XOSD
OSDAPI
OSDGetFlagDesc(
    HPID hpid,
    HTID htid,
    DWORD ifd,
    LPFD lpfd
    );

XOSD
OSDAPI
OSDReadRegister(
    HPID hpid,
    HTID htid,
	HFRAME hFrame,
    DWORD dwid,
    RWReg* lpValue
    );

XOSD
OSDAPI
OSDWriteRegister(
    HPID hpid,
    HTID htid,
	HFRAME hFrame,
    DWORD dwId,
    RWReg* lpValue
    );

XOSD
OSDAPI
OSDReadFlag(
    HPID hpid,
    HTID htid,
	HFRAME hFrame,
    DWORD dwId,
    LPVOID lpValue
    );

XOSD
OSDAPI
OSDWriteFlag(
    HPID hpid,
    HTID htid,
	HFRAME hFrame,
    DWORD dwId,
    LPVOID lpValue
    );

//
// Breakpoints
//

XOSD
OSDAPI
OSDBreakpoint(
    HPID hpid,
    LPBPS lpbps
    );

//
// Assembly, Unassembly
//

XOSD
OSDAPI
OSDUnassemble(
    HPID hpid,
    HTID htid,
    LPSDI lpsdi
    );

XOSD
OSDAPI
OSDGetPrevAddr(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
	int iCount
    );

XOSD
OSDAPI
OSDAssemble(
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
    LPTSTR lsz
    );

XOSD
OSDAPI
OSDGetCallInfo(
	HPID hpid,
	HTID htid,
	LPADDR addrStart,
	LPADDR addrEnd,
	LPDWORD pdwCount,
	LPADDR addrResult
	);

//
// Stack tracing
//

XOSD
OSDAPI
OSDGetFrame(
    HPID hpid,
    HTID htid,
	IN HFRAME hPrevStackFrame,
	OUT HFRAME*	lphStackFrame
    );

XOSD
OSDGetFrameWithinRange (
	IN HPID          hpid,
	IN HTID          htid,
	IN LPSTACK_RANGE  hStackRange,
	OUT HFRAME*      lphFrame
	);

XOSD
OSDAPI
OSDDestroyFrame(
	IN HPID	hpid,
	IN HFRAME	hStackFrame,
	IN DWORD  dwHack
	);



XOSD
OSDAPI
OSDGetImageInformation(
    IN	HPID hpid,
	IN LPCSTR szFileName,
	OUT	OSDIMAGEINFO* lpImgeInfo
    );

//
// Target File I/O
//
XOSD
OSDAPI
OSDFindFirstFile(
	IN HPID hpid,
	IN LPCSTR szFileParam,	OPTIONAL
	OUT HOSDFF* lpFindFileHandle,
	OUT OSDFINDFILEINFO* lpFileInfo
	);

XOSD
OSDAPI
OSDFindNextFile(
	IN HPID hpid,
	IN HOSDFF hFindFileHandle,
	OUT OSDFINDFILEINFO* lpFileInfo
	);

XOSD
OSDAPI
OSDCloseFindHandle(
	IN HPID hpid,
	IN HOSDFF hFindFileHandle
	);

XOSD
OSDAPI
OSDOpenFile(
	IN HPID hpid,
	IN LPCSTR szFileName,
	OUT HOSDFILE* lpFileHandle
	);

XOSD
OSDAPI
OSDReadFile(
	IN	HPID hpid,
	IN	HOSDFILE hFileHandle,
    OUT LPVOID lpBuffer,
	IN	DWORD64 nBytesToRead,
	OUT DWORD64* lpBytesRead
	);

XOSD
OSDAPI
OSDSeekFile(
	IN HPID hpid,
	IN HOSDFILE hFileHandle,
	IN DWORD64 dwLocation,
	IN DWORD64 dwOrigin
	);

XOSD
OSDAPI
OSDCloseFile(
	IN HPID hpid,
	IN HOSDFILE hFileHandle
	);

XOSD
OSDAPI
OSDWriteCrashDump(
	IN HPID hpid,
	IN DWORD dwType,
	IN LPSTR szDumpFile
	);

#if 0
XOSD
OSDAPI
OSDMakeFileHandle(
    HPID hpid,
    LPARAM lPrivateHandle,
    HOSDFILE * lphosdFile
    );

XOSD
OSDAPI
OSDDupFileHandle(
    HOSDFILE hosdFile,
    HOSDFILE * lphosdDup
    );

XOSD
OSDAPI
OSDCloseFile(
    HOSDFILE hosdFile
    );

XOSD
OSDAPI
OSDSeekFile(
    HOSDFILE hosdFile,
    DWORD dwLocationLo,
    DWORD dwLocationHi,
    DWORD dwOrigin
    );

XOSD
OSDAPI
OSDReadFile(
    HOSDFILE hosdFile,
    LPBYTE lpbBuffer,
    DWORD cbData,
    LPDWORD lpcbBytesRead
    );

XOSD
OSDAPI
OSDWriteFile(
    HOSDFILE hosdFile,
    LPBYTE lpbBuffer,
    DWORD cbData,
    LPDWORD lpdwBytesWritten
    );
#endif


//
// Exceptions
//

XOSD
OSDAPI
OSDGetExceptionState(
    HPID hpid,
    HTID htid,
    LPEXCEPTION_DESCRIPTION lpExd,
    EXCEPTION_CONTROL exf
    );

XOSD
OSDAPI
OSDSetExceptionState (
    HPID hpid,
    HTID htid,
    LPEXCEPTION_DESCRIPTION lpExd
    );


//
// Messages amd Message Maps
//

XOSD
OSDAPI
OSDGetMessageMap(
    HPID hpid,
    HTID htid,
    LPMESSAGEMAP * lplpMessageMap
    );

XOSD
OSDAPI
OSDGetMessageMaskMap(
    HPID hpid,
    HTID htid,
    LPMASKMAP * lplpMaskMap
    );

//
//	Miscellaneous control functions
//

XOSD
OSDAPI
OSDShowDebuggee(
    HPID hpid,
    DWORD fShow
    );

//
// Communication and synchronization with DM
//

XOSD
OSDAPI
OSDInfoReply(
    HPID hpid,
    HTID htid,
    LPVOID lpvData,
    DWORD cbData
    );


XOSD
OSDAPI
OSDContinue(
    HPID hpid,
    HTID htid
    );

// values for bReply above
#define	RUNTIME_ERROR_CRT		0
#define	RUNTIME_ERROR_IGNORE	1
#define	RUNTIME_ERROR_STOP		2

#define	RUNTIME_ERROR_STRLEN	512

typedef struct _tagRUNTIME_ERRORINFO
{
	DWORD dwErrorNo;
	BOOL bRealBug;
	UOFFSET pvReturnAddr;
	BYTE bRTReply;
	WCHAR wzUserMsg[RUNTIME_ERROR_STRLEN];
} RUNTIME_ERRORINFO;


//
// OS Specific info and control
//

XOSD
OSDAPI
OSDGetDebuggableTaskList(
    HPID hpid,
    LPOSDTASKLIST * lplpTaskList
    );

XOSD
OSDAPI
OSDSystemService(
    HPID hpid,
    HTID htid,
    SSVC ssvc,
    LPVOID lpvData,
    DWORD cbData,
    LPDWORD lpcbReturned
    );

XOSD
OSDAPI
OSDSetDebugMode(
    HPID hpid,
    DBM dbmService,
    LPVOID lpvData,
    DWORD cbData
    );

XOSD
OSDAPI
OSDEngineReady(
	HPID	hpid
	);


#define CRASHDUMP_EXTENSION _T("dmp")
#define MINIDUMP_EXTENSION  _T("mdmp")

#define DUMP_PATH_KEY _T("MODPATH")
#define DUMP_PATH_KEYEX _T("MODPATH=")

#define DUMP_EXT_KEY _T("EXTS")

#if 0
//XOSD
//OSDAPI
//OSDGetLastTLError(
//    HTL     hTL,
//    HPID    hpid,
//    LPSTR   Buffer,
//    ULONG   Length
//    );
#endif


#ifdef __cplusplus
} // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\types.h ===
/**		types.h - Generic types
 *
 *		This file contains generic types such as USHORT, ushort,
 *		WORD, etc., which are not directly related to CodeView.
 *		Every attempt is made to define them in such a way as they
 *		will not conflict with the standard header files such as
 *		windows.h and os2.h.
 */


/***	The master copy of this file resides in the CVINC project.
 *		All Microsoft projects are required to use the master copy without
 *		modification.  Modification of the master version or a copy
 *		without consultation with all parties concerned is extremely
 *		risky.
 *
 *		The projects known to use this file are:
 *
 *			CodeView (uses version in CVINC project)
 *			C/C++ expression evaluator (uses version in CVINC project)
 *			Symbol Handler (uses version in CVINC project)
 *			Stump (OSDebug) (uses version in CVINC project)
 */

#ifndef _VC_VER_INC
#include "..\include\vcver.h"
#endif

#ifndef CVINC_TYPES /* whole file */
#define CVINC_TYPES

#ifdef HOST32	/* { */

#define _export

#ifndef LOADDS
#define	LOADDS
#endif

#ifndef PASCAL
#define PASCAL __stdcall
#endif

#ifndef CDECL
#define	CDECL _cdecl
#endif

#ifndef FASTCALL
#define FASTCALL __fastcall
#endif

#ifndef far
#define far
#endif

#ifndef FAR
#define	FAR far
#endif

#ifndef near
#define near
#endif

#ifndef NEAR
#define NEAR near
#endif

#ifndef _HUGE_
#define _HUGE_
#endif

// Use SEGBASED for based on a segment [e.g. SEGBASED(__segname("_CODE"))]
#ifndef SEGBASED
#define SEGBASED(x)
#endif

/*
**	This set of functions need to be expanded to deal with
**	unicode and other problems.
*/

// These #defines are taken care of by windowsx.h

#ifndef _INC_WINDOWSX

#define _ncalloc    calloc
#define _nexpand    expand
#define _ffree      free
#define _fmalloc    malloc
#define _fmemccpy   _memccpy
#define _fmemchr    memchr
#define _fmemcmp    memcmp
#define _fmemcpy    memcpy
#define _fmemicmp   _memicmp
#define _fmemmove   memmove
#define _fmemset    memset
#define _fmsize     _msize
#define _frealloc   realloc
#define _fstrcat    strcat
#define _fstrchr    strchr
#define _fstrcmp    strcmp
#define _fstrcpy    strcpy
#define _fstrcspn   strcspn
#define _fstrdup    _strdup
#define _fstricmp   _stricmp
#define _fstrlen    strlen
#define _fstrlwr    _strlwr
#define _fstrncat   strncat
#define _fstrncmp   strncmp
#define _fstrncpy   strncpy
#define _fstrnicmp  _strnicmp
#define _fstrnset   _strnset
#define _fstrpbrk   strpbrk
#define _fstrrchr   strrchr
#define _fstrrev    _strrev
#define _fstrset    _strset
#define _fstrspn    strspn
#define _fstrstr    strstr
#define _fstrtok    strtok
#define _fstrupr    _strupr
#define _nfree      free
#define _nmalloc    malloc
#define _nmsize     msize
#define _nrealloc   realloc
#define _nstrdup    _strdup
#define hmemcpy     memcpy

#endif

#define FP_OFF(x) x

#else	// !HOST32 }{

#ifndef LOADDS
#define LOADDS _loadds
#endif

#ifndef PASCAL
#define PASCAL _pascal
#endif

#ifndef CDECL
#define	CDECL _cdecl
#endif

#ifndef FASTCALL
#define FASTCALL _fastcall
#endif

#ifndef FAR
#define FAR _far
#endif

#ifndef NEAR
#define NEAR _near
#endif

#ifndef _HUGE_
#define _HUGE_ _huge
#endif

// Use SEGBASED for based on a segment [e.g. SEGBASED(__segname("_CODE"))]
#ifndef SEGBASED
#define SEGBASED(x) _based(x)
#endif

#endif	// HOST32 }

#ifndef INTERRUPT
#define INTERRUPT _interrupt
#endif

#ifndef LOCAL
#ifdef DEBUGVER
#define LOCAL
#else
#define LOCAL static
#endif
#endif

#ifndef GLOBAL
#define GLOBAL
#endif

#ifndef INLINE
#define INLINE __inline
#endif

//
// Things that come from either windows.h or os2.h
//

#if !defined(LOWORD) && !defined(OS2_INCLUDED)

	#define VOID			void

	typedef unsigned char	BYTE;

	typedef int				BOOL;

	#define LONG			long

#endif

//
// Things that come from windows.h and cwindows.h
//

#if !defined(LOWORD)

#if defined ( _WIN32 ) || defined ( _M_MPPC ) || defined ( _M_M68K )
	typedef void *			HANDLE;
#else
	typedef unsigned int	HANDLE;
#endif

	typedef HANDLE			HWND;
	typedef char FAR *		LPSTR;

	typedef unsigned short	WORD;
	typedef unsigned long	DWORD;


#endif

#if !defined ( WIN32 ) && !defined ( WIN32S ) && !defined ( WIN )

    typedef unsigned long       DWORD;
    typedef int                 BOOL;
    typedef unsigned char       BYTE;
    typedef unsigned short      WORD;
    typedef float               FLOAT;
    typedef FLOAT               *PFLOAT;
    typedef BOOL near           *PBOOL;
    typedef BOOL far            *LPBOOL;
    typedef BYTE near           *PBYTE;
    typedef BYTE far            *LPBYTE;
    typedef int near            *PINT;
    typedef int far             *LPINT;
    typedef WORD near           *PWORD;
    typedef WORD far            *LPWORD;
    typedef long far            *LPLONG;
    typedef DWORD near          *PDWORD;
    typedef DWORD far           *LPDWORD;
    typedef void far            *LPVOID;

    typedef int                 INT;
    typedef unsigned int        UINT;
    typedef unsigned int        *PUINT;

    typedef HANDLE FAR          *LPHANDLE;

#endif


//
// Things that come from os2.h
//

#if !defined(OS2_INCLUDED)

	#define CHAR			char

	typedef	unsigned char	UCHAR;
	typedef short			SHORT;
	typedef int				INT;
	typedef unsigned short	USHORT;
	typedef unsigned int	UINT;
	typedef unsigned long	ULONG;

	typedef char *			PCH;

#endif

#if !defined(LOWORD)

    #define LOWORD(l)           ((WORD)(((DWORD)(l)) & 0xFFFF))
    #define HIWORD(l)           ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))

#endif

#ifndef NULL
	#define	NULL		((void *) 0)
#endif

#if !defined(TRUE) || !defined(FALSE)
	#undef TRUE
	#undef FALSE

	#define FALSE		0
	#define TRUE		1
#endif

#if !defined(fTrue) || !defined(fFalse)
	#undef fTrue
	#undef fFalse

	#define fFalse		0
	#define fTrue		1
#endif

#ifndef min
#define min(a,b)	(((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b)	(((a) > (b)) ? (a) : (b))
#endif

#ifndef Unreferenced
#define	Unreferenced(a) ((void)a)
#endif

typedef unsigned short ushort;
typedef unsigned char  uchar;
typedef unsigned long  ulong;
typedef unsigned int   uint;

typedef void *		PV;
typedef void FAR *	LPV;

typedef char *		SZ;
typedef char FAR *	LSZ;
typedef char FAR *	LPCH;

typedef BOOL FAR *	LPF;
typedef BYTE FAR *	LPB;
typedef WORD FAR *  LPW;
typedef DWORD FAR * LPDW;
typedef LONG FAR *	LPL;
typedef ULONG FAR *	LPUL;
typedef USHORT FAR *LPUS;
typedef DWORD FAR *	LPDWORD;

typedef short		SWORD;

#ifndef _NEW_SDK    // defined in new SDK
#if defined(_AXP64_) || defined (_IA64_) 
    typedef UINT_PTR            WPARAM;
    typedef LONG_PTR            LPARAM;
#else
    typedef UINT                WPARAM;
    typedef LONG                LPARAM;
#endif
#endif

#ifdef HOST32
typedef ULONG		IWORD;
#else
typedef USHORT		IWORD;
#endif

#endif /* CVINC_TYPES */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\emf.h ===
//--------------------------------------------------------------------
// EMF.H
//
// This contains a list of all the EM functions.
// 
// There are multiple users of this file.  To use it, you must
// define a DECL_EMF macro to extract the pieces of information that
// you are interested in from this file.  For example, if you want
// to define the emf enumeration, you could write the following:
//
//		#define DECL_EMF(name)	emf ## name,
//
//		typedef enum {
//			#include "emf.h"
//		} EMF;
//
//		#undef DECL_EMF
//--------------------------------------------------------------------

DECL_EMF(DebugPacket)

DECL_EMF(RegisterDBF)
DECL_EMF(Init)
DECL_EMF(GetModel)
DECL_EMF(UnInit)

DECL_EMF(SetTLEMBuffer)

DECL_EMF(Detach)
DECL_EMF(Attach)
DECL_EMF(GetInfo)
DECL_EMF(Setup)
DECL_EMF(Connect)
DECL_EMF(Disconnect)

DECL_EMF(CreateHpid)
DECL_EMF(DestroyHpid)
DECL_EMF(DestroyHtid)

DECL_EMF(SetMulti)
DECL_EMF(Debugger)

DECL_EMF(SpawnOrphan)
DECL_EMF(ProgramLoad)
DECL_EMF(LoadCrashDump)
DECL_EMF(DebugActive)
DECL_EMF(SetPath)
DECL_EMF(ProgramFree)

DECL_EMF(ThreadStatus)
DECL_EMF(ProcessStatus)
DECL_EMF(ManipulateThread)
DECL_EMF(LockUnLock)
DECL_EMF(SetThreadPriority)

DECL_EMF(GetExceptionState)
DECL_EMF(SetExceptionState)

DECL_EMF(GetModuleInfo)

DECL_EMF(Go)
DECL_EMF(SingleStep)
DECL_EMF(RangeStep)
DECL_EMF(ReturnStep)
DECL_EMF(Stop)

DECL_EMF(NextReadableMemory)

DECL_EMF(BreakPoint)

DECL_EMF(SetupExecute)
DECL_EMF(StartExecute)
DECL_EMF(CleanUpExecute)

DECL_EMF(GetAddr)
DECL_EMF(SetAddr)
DECL_EMF(FixupAddr)
DECL_EMF(UnFixupAddr)
DECL_EMF(SetEmi)
DECL_EMF(RegisterEmi)
DECL_EMF(UnRegisterEmi)
DECL_EMF(UpdateEmi)
DECL_EMF(CompareAddrs)
DECL_EMF(GetObjLength)
DECL_EMF(GetMemoryInfo)
DECL_EMF(GetFunctionInfo)

DECL_EMF(ReadMemory)
DECL_EMF(WriteMemory)
DECL_EMF(VirtualAllocEx)

DECL_EMF(GetRegStruct)
DECL_EMF(GetFlagStruct)
DECL_EMF(GetReg)
DECL_EMF(SetReg)
DECL_EMF(GetFlag)
DECL_EMF(SetFlag)
DECL_EMF(SaveRegs)
DECL_EMF(RestoreRegs)

DECL_EMF(Unassemble)
DECL_EMF(GetPrevInst)
DECL_EMF(Assemble)

DECL_EMF(GetFrame)
DECL_EMF(GetFrameWithinRange)
DECL_EMF(DestroyFrame)

DECL_EMF(Metric)


DECL_EMF(InfoReply)
DECL_EMF(Continue)


DECL_EMF(ShowDebuggee)
DECL_EMF(GetDebuggableTaskList)
DECL_EMF(SystemService)
DECL_EMF(SetDebugMode)

DECL_EMF(Dbc)

//
// Target File I/O
//

DECL_EMF(GetImageInformation)
DECL_EMF(FindFirstFile)
DECL_EMF(FindNextFile)
DECL_EMF(CloseFindFile)
DECL_EMF(OpenFile)
DECL_EMF(ReadFile)
DECL_EMF(SeekFile)
DECL_EMF(CloseFile)

//
// Crash Dump and other stuff
//
DECL_EMF(WriteCrashDump)

DECL_EMF(GetCallInfo)

DECL_EMF(Max)

// Load Library
DECL_EMF(LoadLibrary)

// Interop engine ready
DECL_EMF(EngineReady)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\xosd.h ===
//
// xosdNone must be 0.  The rest do not matter
//

//
// NOTE: If you modify this header file then you must rebuild the
// xosd.rc (in this directory) file as well.
//

DECL_XOSD(xosdNone,                 0, "No Error")

DECL_XOSD(xosdContinue,             1, "Continue processing EMF")
DECL_XOSD(xosdPunt,                 2, "Pass to next EM")

DECL_XOSD(xosdGeneral,              3, "API failed")
DECL_XOSD(xosdUnknown,				4, "General Debugger error")
DECL_XOSD(xosdUnsupported,          5, "Feature not available")
DECL_XOSD(xosdInvalidHandle,        6, "Invalid handle passed to API")
DECL_XOSD(xosdInvalidParameter,     7, "Invalid parameter")
DECL_XOSD(xosdDuplicate,            8, "Duplicate EM or TL")
DECL_XOSD(xosdInUse,                9, "EM or TL is in use")
DECL_XOSD(xosdOutOfMemory,         10, "Insufficient memory available")
DECL_XOSD(xosdFileNotFound,        11, "File not found")
DECL_XOSD(xosdAccessDenied,        12, "Access denied")
DECL_XOSD(xosdBadProcess,          13, "Os Failed to Init Debuggee Properly")
DECL_XOSD(xosdBadThread,           14, "Inappropriate or nonexistent thread")
DECL_XOSD(xosdBadAddress,          15, "Invalid address")
DECL_XOSD(xosdInvalidBreakPoint,   16, "nonexistent breakpoint")
DECL_XOSD(xosdBadVersion,          17, "Debugger component versions mismatched")
DECL_XOSD(xosdQueueEmpty,          18, "Queue Empty - no error")
DECL_XOSD(xosdProcRunning,         19, "Operation invalid when process is running")
DECL_XOSD(xosdRead,                20, "Read Failure")
DECL_XOSD(xosdWrite,               21, "Write Failure")
DECL_XOSD(xosdIORedirSyntax,       22, "Syntax error in IO redirection")
DECL_XOSD(xosdIORedirBadFile,      23, "Cannot redirect with this file")
DECL_XOSD(xosdAllThreadsSuspended, 24, "All debugee threads are suspended")
DECL_XOSD(xosdSoftBroken,          25, "Debugeee is softbroken")
DECL_XOSD(xosdEndOfStack,          26, "end of stack")

DECL_XOSD(xosdLoadMdError,         30, "Failed to load minidump dll")

DECL_XOSD(xosdDllNotFound,         31, "Loader failed to find a dll during load")
DECL_XOSD(xosdNonContinuableException, 32, "A non-continuable Exception was encounterred")


DECL_XOSD(xosdCannotSetStepBp,     33, "Failed to set Stepping bp")
DECL_XOSD(xosdInstrCannotStep,     34, "Failed to set Stepping bp")

DECL_XOSD(xosdAlreadyStopped,      35, "Stopped at a stopping event")
DECL_XOSD(xosdUnSafeToLock,        36, "Its not safe to Lock")
DECL_XOSD(xosdNotYetLoaded,        37, "Debuggee hasn't finished loading(interoP)")


DECL_XOSD(xosdNubInit,             40, "Failed to init dbgproxy")
DECL_XOSD(xosdNubImpersonate,      41, "dbgproxy could not impersonate current user")
DECL_XOSD(xosdNubTsUnsupported,    42, "cannot detach when running in a TS session")
DECL_XOSD(xosdWin32Detach,         44, "Detach Deffered to OS")

DECL_XOSD(xosdInterOpTransitionStub,  50, "cannot step because of transition stub")
DECL_XOSD(xosdInterOpORpcInit,  		  51, "Ole/RPC debugging unsupported in interop mode")

DECL_XOSD(xosdLineNotConnected,    70, "Not connected")
DECL_XOSD(xosdCannotConnect,       71, "cannot connect")
DECL_XOSD(xosdLineDisconnect,      72, "Connection has ben cut")


DECL_XOSD(xosdNotRemote,           76, "not remote")


DECL_XOSD(xosdBadIPAddress,	       80, "The IP Address is bad")
DECL_XOSD(xosdNoMsvcmon,	       81, "MsVCMON Not running on remote machine")
DECL_XOSD(xosdNoMsvcmonForUser,	   82, "No msvmcon on the remote machine in running under current user context")
DECL_XOSD(xosdMachineDown,	       83, "The Remote machine is down")
DECL_XOSD(xosdMachineUnspecified,  84, "The Remote machine is Unspecified")

DECL_XOSD(xosdCannotStep,          90, "cannot step")
DECL_XOSD(xosdTlsAddr,			   91, "the address requires a thread")
DECL_XOSD(xosdIgnoreException,	   92, "An exception has been ignored")
DECL_XOSD(xosdLoadDmError,	       93, "Debugger cannot load the DM")

DECL_XOSD(xosdMiniDumpReadOnWin9x, 94, "Reading of minidumps not supported on win'9x")
DECL_XOSD(xosdCrashDumpActive,     98, "Cannot Multiproc debug with an active crashdump")
DECL_XOSD(xosdCrashDump,           99, "Operation Not support on Crashdump")

DECL_XOSD(xosdPartialRead,         100,"Could only read some of the bytes requested")
DECL_XOSD(xosdUnSupportedBinary,   103,"This binary format is not supported")
DECL_XOSD(xosdBadDirectoryForWrite,104,"Cannot write to directory")
DECL_XOSD(xosdProcessFreed,        105,"The process structure was freed by this call")
DECL_XOSD(xosdMax,	               200, "The maxium XOSD value")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\tlxbox\debug.cpp ===
#include <precomp.h>

#ifdef DBG

TCHAR  rgchDebug[512];
ULONG  DBG_uDebugLevel = 0;

VOID
WINAPIV
DebugPrint(
    LPTSTR szFormat,
    ...
    )
{
    va_list  marker;
    int n;

    va_start( marker, szFormat );
    n = _vsnprintf(rgchDebug, ARRAYSIZE(rgchDebug), szFormat, marker );
    va_end( marker);

    if (n == -1) {
        rgchDebug[ARRAYSIZE(rgchDebug)-1] = 0;
    }

    OutputDebugString( rgchDebug );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\util\critleak.h ===
#pragma once

#include "util\debug.h"

#ifdef _DEBUG

extern "C" void * _ReturnAddress();


class dbgCRITICAL_SECTION
{
public:
	void
	Initialize(
		)
	{
		InitializeCriticalSection(&m_cs);
		m_ulLockCount = 0;
		m_dwOwningThread = 0;
	}

	void
	Enter( 
		)
	{
		EnterCriticalSection(&m_cs);
		if (m_ulLockCount == 0) {
			m_dwOwningThread = GetCurrentThreadId();
		}
		Assert(m_dwOwningThread == GetCurrentThreadId());
		++m_ulLockCount;
	}

//	BOOL
//	TryEnter(
//		)
//	{
//		if (TryEnterCriticalSection(&m_cs)) {
//			// Same as code for Enter().
//			if (m_ulLockCount == 0) {
//				m_dwOwningThread = GetCurrentThreadId();
//			}
//			Assert(m_dwOwningThread == GetCurrentThreadId());
//			++m_ulLockCount;
//		} else {
//			Assert(!IsOwnedByThisThread());
//		}
//	}

	void
	Leave(
	   )
	{
		--m_ulLockCount;
		Assert(m_dwOwningThread == GetCurrentThreadId());
		if (m_ulLockCount == 0) {
			m_dwOwningThread = 0;
		}
		LeaveCriticalSection(&m_cs);
	}

	void
	Delete(
	    )
	{
		Assert(m_dwOwningThread == 0);
		Assert(m_ulLockCount == 0);
		DeleteCriticalSection(&m_cs);
	}

	// This isn't suggested for anything other than debugging use.
	//	Its return result can be incorrect by the time its
	//	evaluated.
	bool
	IsOwned
		() const
	{
		return (m_ulLockCount > 0);
	}

	// This should always be safe and give consistent results.
	bool
	IsOwnedByThisThread(
		) const
	{
		return (m_dwOwningThread == GetCurrentThreadId());
	}

	operator LPCRITICAL_SECTION(
			) 
	{ 
		return &m_cs; 
	};


private:

	CRITICAL_SECTION m_cs;
	ULONG m_ulLockCount;
	DWORD m_dwOwningThread;
};

#define CRITICAL_SECTION dbgCRITICAL_SECTION

#define	InitializeCriticalSection(s)	InitializeCriticalSection_dbg(__FILE__,__LINE__,(dbgCRITICAL_SECTION*) s,_ReturnAddress())
#define	DeleteCriticalSection		DeleteCriticalSection_dbg
#define	LeaveCriticalSection(s)		LeaveCriticalSection_dbg((dbgCRITICAL_SECTION*) s,__FILE__,__LINE__)

EXTERN_C void 
WINAPI 
InitializeCriticalSection_dbg( 
	const char*, 
	int, 
	dbgCRITICAL_SECTION* lpSec, 
	void*pRet 
	);

EXTERN_C void 
WINAPI 
DeleteCriticalSection_dbg( 
	dbgCRITICAL_SECTION* lpsec 
	);



EXTERN_C void 
WINAPI 
LeaveCriticalSection_dbg(
	dbgCRITICAL_SECTION* lpsec, 
	const char *, 
	int
	);
EXTERN_C void 
WINAPI 
EnterCriticalSection_dbg(
	dbgCRITICAL_SECTION* lpsec , 
	const char *, 
	int
	);

EXTERN_C void 
WINAPI 
EnterCriticalSectionEx_dbg(
	dbgCRITICAL_SECTION* lpsec, 
	const char *, 
	int
	);

BOOL
WINAPI
IsCriticalSectionOwned(
	dbgCRITICAL_SECTION* CriticalSection
	);

BOOL
WINAPI
IsCriticalSectionUnOwned(
	dbgCRITICAL_SECTION CriticalSection
	);

#ifdef CRITS_NO_REENTRY 
#define	EnterCriticalSection(s)		EnterCriticalSection_dbg((dbgCRITICAL_SECTION*)s,__FILE__,__LINE__)
#define	EnterCriticalSectionEx(s)	EnterCriticalSectionEx_dbg((dbgCRITICAL_SECTION*)s,__FILE__,__LINE__)
#else
#define	EnterCriticalSection(s)		EnterCriticalSectionEx_dbg((dbgCRITICAL_SECTION*)s,__FILE__,__LINE__)
#define	EnterCriticalSectionEx(s)	EnterCriticalSectionEx_dbg((dbgCRITICAL_SECTION*)s,__FILE__,__LINE__)
#endif

#else
#define	EnterCriticalSectionEx(s) EnterCriticalSection(s)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\include\util\debug.h ===
/*++

Copyright (c) 1996 Microsoft Coporation

Module Name: debug.h

Abstract:

    Debugging macros and functions.

Author:

    Matthew D Hendel (math)

--*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// All asserts go through our assert
//

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef assert
#undef assert
#endif

#ifdef VERIFY
#undef VERIFY
#endif

#ifdef verify
#undef verify
#endif

#define ASSERT(_expr)			Assert(_expr)
#define assert(_expr)			Assert(_expr)
#define VERIFY(_expr)			Verify(_expr)
#define verify(_expr)			Verify(_expr)

    //
    // For util headers
    //
#define dbgutilASSERT(_expr)	Assert(_expr)
#define dbgutilVERIFY(_expr)	Verify(_expr)

#define DbgPrint _DbgPrint

				
void
__stdcall
DbgPrint(
	const char*,
	...
	);

unsigned long
__stdcall
AssertFailed(
	const char* cond,
	const char* file,
	unsigned long line,
	unsigned int*   pIgnoreAssert
	
	);

	
unsigned long
AssertFailHr(
	const char* cond,
	const char* file,
	unsigned long line,
	HRESULT hr
	);

#ifdef DEBUG


// Debug only.

#ifdef i386

	//
    // int 3 is a little nicer than DebugBreak since it doesn't throw you
    // into mixed mode
	//

#define DbgBreakPoint()				\
				do {                \
					_asm int 3      \
				} while (0)

#else

#define DbgBreakPoint()     DebugBreak()

#endif // i386


#define Assert(_arg)\
			do {															\
				if (! (_arg) ) {											\
					static unsigned int __ignore_assert = 0;							\
					if (__ignore_assert == 0 &&								\
						AssertFailed (#_arg, __FILE__, __LINE__, &__ignore_assert)) {			\
						DbgBreakPoint ();									\
					}														\
				}															\
			} while (0)


#define AssertWithMsg(_arg,msg)\
			do {														    \
				if (! (_arg) ) {											\
					static unsigned int __ignore_assert = 0;							\
					if (__ignore_assert == 0 &&								\
						AssertFailed (msg, __FILE__, __LINE__, &__ignore_assert)) {	        \
						DbgBreakPoint ();									\
					}														\
				}															\
			} while (0)

#define AssertHr(_arg,_hr)\
			do {															\
				if ( !(_arg) ) {											\
					static unsigned int __ignore_assert = 0;							\
					if (__ignore_assert == 0 &&								\
						AssertFailHr (#_arg, __FILE__, __LINE__, _hr)) {	\
						DbgBreakPoint ();									\
					}														\
				}															\
			} while (0)
			

#define Verify(_arg)	Assert(_arg)
#if defined(KdPrint)
#undef  KdPrint
#endif
#define KdPrint(_arg)   DbgPrint _arg



VOID
WINAPI
_DbgCheckHeap(
	);
	
#define DbgCheckHeap _DbgCheckHeap

#else   // DEBUG

#define Verify(_arg)    (_arg)

//
// these go away in retail

#if defined(KdPrint)
#undef  KdPrint
#endif

#define KdPrint(_arg) do {} while (0)
#define Assert(_arg) do {} while (0)
#define AssertHr(_arg,_hr) do {} while (0)
#define DbgBreakPoint() do {} while (0)
#define DbgCheckHeap() do {} while (0)

#endif // DEBUG


#ifdef __cplusplus

__inline void
AssertWritePtr(
	void* ptr,
	UINT cb = 1
	)
{
	Assert (ptr == NULL || !IsBadWritePtr (ptr, cb));
}

__inline void
AssertReadPtr(
	void* ptr,
	UINT cb = 1
	)
{
	Assert (ptr == NULL || !IsBadReadPtr (ptr, cb));
}

#endif // __cplusplus


/*++ macro CT_ASSERT

Macro Description:

	CT_ASSERT is a compile-time assert. The expression given as the parameter
	must be able to be evaluated at compile time. Generally this will be a
	sizeof or offsetof expression.

	If this assert fails, the compile time error:

		error C2118: negative subscript or subscript is too large

	will be generated.

--*/

#pragma warning (disable:4094)
	
#define CT_ASSERT(_cond)						\
    struct {									\
	        int _unused [(_cond) ? 1 : -1];		\
	};											\


BOOL
WINAPI
IsCalledFrom(
	UINT_PTR CallerAddress,
	HMODULE hModule
	);


//
// This is a compiler intrinsic function which return the return address of
// the caller. Very usefule for tracking memory leaks and the like.
//

extern "C" void*
_ReturnAddress();

#pragma intrinsic (_ReturnAddress)

#if defined (i386)
//
// This is a retail assert, not to be shipped.  It should be removed before RC
//
#define RASSERT(expr) 							\
do {											\
	if (!(expr)) { 								\
		_asm int 3 							\
	}											\
} while (0)
#endif

	
#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\tlxbox\debug.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    debug.h

Abstract:
    
    Define Debug Macros and Declare Debug Facilities.
    
--*/

#ifndef __DMXBOX_DEBUG__
#define __DMXBOX_DEBUG__

// We use DPRINT all over the place, it is kind of silly, but we will clean it up later.
#if DBG

#include <crtdbg.h>

extern ULONG DBG_uDebugLevel;
extern void  DebugPrint(char *, ...);
#define DPRINT(level, args) if (DBG_uDebugLevel >= level) { DebugPrint args; }
#define TR_RANGESTEP    0x00000001 //Debug level for range and step

// The DM's DispatchRequest method may not be called recursively. (This
// is why you shouldn't call the EM back in the context of a DM call.)
// These macros use TLS to keep us honest by causing assertion failures in
// debug builds.
extern DWORD g_dbg_RecursionCheck;
#define DMDBG_NO_RECURSION_DECLARE  DWORD g_dbg_RecursionCheck = 0;
#define DMDBG_NO_RECURSION_ALLOC    g_dbg_RecursionCheck = TlsAlloc();
#define DMDBG_NO_RECURSION_ENTER    _ASSERT(0==TlsGetValue(g_dbg_RecursionCheck)); TlsSetValue(g_dbg_RecursionCheck, (PVOID)1);
#define DMDBG_NO_RECURSION_LEAVE    TlsSetValue(g_dbg_RecursionCheck, NULL);
#define DMDBG_NO_RECURSION_ASSERT   _ASSERT(0==TlsGetValue(g_dbg_RecursionCheck));
#define DMDBG_NO_RECURSION_FREE     TlsFree(g_dbg_RecursionCheck);

#else

#define DPRINT(level, args)
#define DMDBG_NO_RECURSION_DECLARE
#define DMDBG_NO_RECURSION_INIT
#define DMDBG_NO_RECURSION_ENTER
#define DMDBG_NO_RECURSION_LEAVE
#define DMDBG_NO_RECURSION_ASSERT
#define DMDBG_NO_RECURSION_FREE

#endif

#endif //__DMXBOX_DEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\tlxbox\events.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    events.cpp

Abstract:

    Implementation of CDebugEventPump.  

    CDebugEventPump is a central receiving and translation facility for debug events.
    1) Set up notifications of debug events.
    2) Translates notifications into their proper debug events.
    3) Synchronizes access to debug events.

    Does not provide the polling thread, nor does it actually handle the event
    
Author:
    mitchd

--*/
#include <precomp.h>
#include <queue>
using namespace std;

//-----------------------------------------------------------------------------------
//  Static Member Initialization
//-----------------------------------------------------------------------------------
// BUGBUG: xboxdbg.dll won't hold a context for us, so we can currently have only
//         one instance which we store here.
CDebugEventPump *CDebugEventPump::sm_pTheOneAndOnly = NULL;

//-----------------------------------------------------------------------------------
//  Implementation of public members of CDebugEventPump
//-----------------------------------------------------------------------------------
HRESULT CDebugEventPump::Initialize(PDMN_SESSION pNotificationSession)
/*++
  Routine Description:
    Initialization is delayed from the c'tor to here.  As is often the case in C++, it is more
    convenient:  you don't need to initialize in the member initialize list of class if you
    include it as a member, you don't get a warning if you access the this pointer, you can
    return a meaningful error code rather throwing an exception, etc.
  
  Arguments:
    pNotificationSession   - notification session to use for getting callbacks from XboxDbg.dll.  Since
                             each session creates a thread, this is just reasonable optimization.
  Return Value:
    S_OK on success.  Otherwise, a win32 error code translated into an HRESULT.
--*/
{
    // We need two events for synchronizing the pump.
    //  QuitPump - StopNotification signals it to force GetDebugEvent to return FALSE;
    //  DebugEventPosted - Signaled when a debug event is added to the queue.
    m_hSynchronizationEvents[QuitPump] = CreateEvent(NULL, FALSE, TRUE, NULL);
    if(m_hSynchronizationEvents[QuitPump])
    {
        m_hSynchronizationEvents[DebugEventPosted] = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(!m_hSynchronizationEvents[DebugEventPosted])
        {
            CloseHandle(m_hSynchronizationEvents[QuitPump]);
            m_hSynchronizationEvents[QuitPump] = NULL;
        }
    }
    // If the events were not created, return and error
    if(!m_hSynchronizationEvents[QuitPump])
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Make sure that we are initializing the one and only instance.
    _ASSERTE(!sm_pTheOneAndOnly);
    sm_pTheOneAndOnly = this;

    // We will need a critical section to protect our queue (based on STL),
    // which is not multithread safe.
    InitializeCriticalSection(&m_CriticalSection);  

    // Make a copyof the notification session passed in by the caller
    m_pNotificationSession = pNotificationSession;
    return S_OK;
}

CDebugEventPump::~CDebugEventPump()
/*++
    Routine Description:
      D'tor cleans up.
--*/
{
    // They should be stopped, but this cannot hurt.
    StopNotifications();

    //  We borrowed the notification session, it was
    //  around before us, and will live after us.
    m_pNotificationSession = NULL;  
    
    
    // Destroy the two synchronization events we created/
    CloseHandle(m_hSynchronizationEvents[QuitPump]);
    CloseHandle(m_hSynchronizationEvents[DebugEventPosted]);
    m_hSynchronizationEvents[QuitPump] = NULL;
    m_hSynchronizationEvents[DebugEventPosted] = NULL;

    // We should be just a memory
    sm_pTheOneAndOnly = NULL;
}

HRESULT CDebugEventPump::StartNotifications()
/*++
  Routine Description:
    Called to start up notifications.  This starts asking XboxDbg.dll
    for notifications.  It also makes sure that GetDebugEvent will
    block if the queue is empty.
--*/
{
    DWORD dwNotification;
    HRESULT hr = S_OK;
    
    // Make sure GetDebugEvent will block properly
    ResetEvent(m_hSynchronizationEvents[QuitPump]);
    
    // Setup all of our notifications.
    hr = DmStopOn(DMSTOP_CREATETHREAD | DMSTOP_FCE, TRUE);
    if(SUCCEEDED(hr))
    {
        for(dwNotification=DM_BREAK; dwNotification <= DM_NOTIFYMAX; dwNotification++)
        {
            hr = DmNotify(m_pNotificationSession, dwNotification, CDebugEventPump::EventNotifications);
            if(FAILED(hr)) break;
        }
    }
    return hr;
}

HRESULT CDebugEventPump::StopNotifications()
/*++
  Routine Description:
    Not only stops XboxDbg.dll from sending us notification to post,
    it also unblocks GetDebugEvent.  When the queue is empty it will return
    FALSE.
--*/
{
    HRESULT hr = PauseNotifications();
    SetEvent(m_hSynchronizationEvents[QuitPump]);
    return hr;
}

BOOL CDebugEventPump::GetDebugEvent(OUT DEBUG_EVENT& DebugEvent)
/*++
  Routine Description:
    The header of CDebugEventPump.  It pulls an event off the queue and
    returns it to the caller.  Blocks indefinately if there are no events.
  
  Arugments:
    DebugEvent - [OUT] event from queue, returned by reference.

  Return Value:
    TRUE  - if there is a new event.
    FALSE - if the queue is empty AND terminate polling has been signalled.
--*/
{
    do
    {
        //Try to get an event
        { CHoldCriticalSection protectEventQueue(&m_CriticalSection);
            if(!m_EventQueue.empty())
            {
                //Found one, return it.
                DebugEvent = m_EventQueue.front();
                m_EventQueue.pop();
                return TRUE;
            }
        }
        // Wait for QuitPump or DebugEventPosted
    } while( (QuitPump + WAIT_OBJECT_0) !=
              WaitForMultipleObjects(
                ARRAYSIZE(m_hSynchronizationEvents),
                m_hSynchronizationEvents,
                FALSE, INFINITE)
                );
    

    // If we fell out, the QuitPump event was signaled. It is possible, 
    // though fairly unlikely, that the queue is not empty.  An event could
    // have been posted just before StopNotifications was signaled.  If this
    // thread hadn't run in between, we would be stuck with a non-empty queue.
    // So ... check again.
    CHoldCriticalSection protectEventQueue(&m_CriticalSection);
    if(!m_EventQueue.empty())
    {
        //Found one, return it.
        DebugEvent = m_EventQueue.front();
        m_EventQueue.pop();
        return TRUE;
    }
    return FALSE;
}

void CDebugEventPump::PostDebugEvent(const DEBUG_EVENT& DebugEvent)
/*++
    Routine Description:
      Used to stuff debug events into the queue.  
    Arguments:
      Event to stuff in queue.
    Motivation:
      Primarly: When attaching to a process (either launching a new one or attaching
      to a running one), the debugger expects events for module loads, and thread
      creates that Xbox doesn't provide these ex-post-facto.  So the attachment code
      goes and enumerates the modules and threads and posts them as debug events.
      Walla, when we start the polling thread starts pumping, the first debug events
      are all these things that the debugger was expecting.
--*/
{
    _ASSERTE(m_pNotificationSession);
    CHoldCriticalSection protectEventQueue(&m_CriticalSection);
    m_EventQueue.push(DebugEvent);
}

DWORD __stdcall CDebugEventPump::EventNotifications(ULONG dwNotification, DWORD dwParam)
/*++
  Routine Description:
    The normal way we get debug events.  The notifications sent by XboxDbg.dll do not
    exactly correspond to the Windows DEBUG_EVENTs that the debugger is expecting.  So
    we do some translation, sometimes here, sometimg
--*/
{
    DEBUG_EVENT debugEvent;
    ZeroStructure(debugEvent);
    CDebugEventPump *pTheDebugEventPump = CDebugEventPump::sm_pTheOneAndOnly;
    BOOL fPostEvent = TRUE;
    

    //  NOTE: We abuse debugEvent.dwProcessId:
    //  1) We are pumping messages for one process, the reader
    //     pulling the messages knows what it told the debugger
    //     the dwProcessId was.  So the caller of GetDebugEvent
    //     fills it in.  If we ever move to multi-Xbox debugging,
    //     it will be cleaner this way.
    //  2) We have flags we can stick there. Like DM_STOPTHREAD
    debugEvent.dwProcessId = dwNotification&DM_STOPTHREAD;
    dwNotification &= DM_NOTIFICATIONMASK;
    
    switch(dwNotification)
    {
        // DM_BREAK, DM_SINGLESTEP, and DM_DATABREAK are all EXCEPTION_BREAKPOINT.
        // There are some slight differences in how you fill it out, but they are similar.
        case DM_BREAK:
            debugEvent.u.Exception.ExceptionRecord.ExceptionCode = EXCEPTION_BREAKPOINT;
            //fall through - sort of ...
            if(dwNotification != DM_BREAK)  //If the compiler is smart, this will just be a jmp.
            {
        case DM_DATABREAK:
                debugEvent.u.Exception.ExceptionRecord.NumberParameters = 2;
                debugEvent.u.Exception.ExceptionRecord.ExceptionInformation[0] =
                                         reinterpret_cast<ULONG_PTR>(reinterpret_cast<DMN_DATABREAK *>(dwParam)->DataAddress);
                debugEvent.u.Exception.ExceptionRecord.ExceptionInformation[1] = 
                                        reinterpret_cast<DMN_DATABREAK *>(dwParam)->BreakType;
                //fall through
        case DM_SINGLESTEP:
                debugEvent.u.Exception.ExceptionRecord.ExceptionCode = EXCEPTION_SINGLE_STEP;
            }
            debugEvent.dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
            debugEvent.dwThreadId = reinterpret_cast<DMN_BREAK *>(dwParam)->ThreadId;
            debugEvent.u.Exception.ExceptionRecord.ExceptionAddress =
                                    reinterpret_cast<DMN_BREAK *>(dwParam)->Address;
            break;
    
        // The dwParam parameter contains a pointer to a DMN_DEBUGSTR structure. 
        case DM_DEBUGSTR:
            debugEvent.dwDebugEventCode = OUTPUT_DEBUG_STRING_EVENT;
            debugEvent.dwThreadId = reinterpret_cast<DMN_DEBUGSTR *>(dwParam)->ThreadId;
            debugEvent.u.DebugString.nDebugStringLength = static_cast<WORD>(reinterpret_cast<DMN_DEBUGSTR *>(dwParam)->Length);
            // Beware of leaks - we are copying the string.  Our queue is dumb, it will just
            // copy the pointer value.  That is actually good.  Debug events should all be pulled from
            // queue before the queue dies, and there is only one queue reader, so that reader owns
            // freeing the string.
            debugEvent.u.DebugString.lpDebugStringData = new char[debugEvent.u.DebugString.nDebugStringLength + 1];
            memcpy(
                debugEvent.u.DebugString.lpDebugStringData,
                reinterpret_cast<DMN_DEBUGSTR *>(dwParam)->String, 
                debugEvent.u.DebugString.nDebugStringLength
                );
            break;

        // The dwParam parameter contains a DMN_EXEC constant.
        case DM_EXEC:
            // Hmm, helps keep track of exec state.  If it 
            // went into the reboot state, we should generate
            // an EXIT_PROCESS_DEBUG_EVENT.  Otherwise, we
            // are not tracking the exec state, for now.
            if(dwParam == DMN_EXEC_REBOOT)
            {
              debugEvent.dwDebugEventCode = EXIT_PROCESS_DEBUG_EVENT;
              //debugEvent.u.ExitProcess.dwExitCode = 0; - Already 0.
              pTheDebugEventPump->PauseNotifications();
            } else
            {
              fPostEvent = FALSE;
            }
            break;
        // The dwParam parameter contains a pointer to a DMN_MODLOAD structure. 
        case DM_MODLOAD:
           // We are ill prepared to handle this here.
           debugEvent.dwDebugEventCode = LOAD_DLL_DEBUG_EVENT;
           debugEvent.u.LoadDll.hFile = (HANDLE)dwParam;  //For internal use.
           debugEvent.u.LoadDll.lpBaseOfDll = reinterpret_cast<DMN_MODLOAD *>(dwParam)->BaseAddress;
           /*  These are
           debugEvent.u.LoadDll.dwDebugInfoFileOffset = 0;
           debugEvent.u.LoadDll.nDebugInfoSize = 0 ;
           debugEvent.u.LoadDll.lpImageName = NULL; //Don't give the image name for now.
           *
           reinterpret_cast<DMN_MODLOAD *>(wParam)->CheckSum 
           reinterpret_cast<DMN_MODLOAD *>(wParam)->Flags 
           reinterpret_cast<DMN_MODLOAD *>(wParam)->Name 
           reinterpret_cast<DMN_MODLOAD *>(wParam)->Size 
           reinterpret_cast<DMN_MODLOAD *>(wParam)->TimeStamp 
           */
            break;

        // The dwParam parameter contains a pointer to a DMN_MODLOAD structure. 
        case DM_MODUNLOAD:
           // We are ill prepared to handle this here.
           debugEvent.dwDebugEventCode = UNLOAD_DLL_DEBUG_EVENT;
           debugEvent.u.UnloadDll.lpBaseOfDll = reinterpret_cast<DMN_MODLOAD *>(dwParam)->BaseAddress;
            break;

        // The dwParam parameter contains a pointer to a DMN_CREATETHREAD structure. 
        case DM_CREATETHREAD:
            debugEvent.dwDebugEventCode = CREATE_THREAD_DEBUG_EVENT;
            debugEvent.dwThreadId = reinterpret_cast<DMN_CREATETHREAD *>(dwParam)->ThreadId;
            debugEvent.u.CreateThread.lpStartAddress = 
                reinterpret_cast<LPTHREAD_START_ROUTINE>(reinterpret_cast<DMN_CREATETHREAD *>(dwParam)->StartAddress);
            {
                DM_THREADINFO dmThreadInfo;
                // Check for local storage - if it fails the lpThreadLocalBase is already NULL
                if(SUCCEEDED(DmGetThreadInfo(debugEvent.dwThreadId, &dmThreadInfo)))
                {
                    debugEvent.u.CreateThread.lpThreadLocalBase = dmThreadInfo.TlsBase;
                }
            }
            break;

        // The dwParam parameter contains the ID of the thread that was destroyed. 
        case DM_DESTROYTHREAD:
            debugEvent.dwDebugEventCode = EXIT_THREAD_DEBUG_EVENT;
            debugEvent.dwThreadId = dwParam;
            debugEvent.u.ExitThread.dwExitCode = 0; //Who cares?  Why do threads have exit codes?
            break;

        // The dwParam parameter contains a pointer to a DMN_EXCEPTION structure. 
        case DM_EXCEPTION:
            debugEvent.dwDebugEventCode =EXCEPTION_DEBUG_EVENT;
            debugEvent.dwThreadId = reinterpret_cast<DMN_EXCEPTION *>(dwParam)->ThreadId;
            debugEvent.u.Exception.dwFirstChance = reinterpret_cast<DMN_EXCEPTION *>(dwParam)->Flags & DM_EXCEPT_FIRSTCHANCE;
            debugEvent.u.Exception.ExceptionRecord.ExceptionCode = reinterpret_cast<DMN_EXCEPTION *>(dwParam)->Code;
            // Xbox doesn't tell us how many elements of the ExceptionInformation are in use, basically we
            // hard code off the ExceptionCode.  EXCEPTION_ACCESS_VIOLATION has two, nobody else has anything.
            // Seems like a short-coming, since I user defined exception might want to pass information.
            if(EXCEPTION_ACCESS_VIOLATION == debugEvent.u.Exception.ExceptionRecord.ExceptionCode)
            {
                debugEvent.u.Exception.ExceptionRecord.NumberParameters = 2;
                debugEvent.u.Exception.ExceptionRecord.ExceptionInformation[0] = reinterpret_cast<DMN_EXCEPTION *>(dwParam)->Information[0];
                debugEvent.u.Exception.ExceptionRecord.ExceptionInformation[1] = reinterpret_cast<DMN_EXCEPTION *>(dwParam)->Information[1];
            }
            debugEvent.u.Exception.ExceptionRecord.ExceptionAddress = reinterpret_cast<DMN_EXCEPTION *>(dwParam)->Address;
            debugEvent.u.Exception.ExceptionRecord.ExceptionFlags =
                (reinterpret_cast<DMN_EXCEPTION *>(dwParam)->Flags & DM_EXCEPT_NONCONTINUABLE) ?  EXCEPTION_NONCONTINUABLE : 0;
            break;

        // The dwParam parameter contains a pointer to a DMN_DEBUGSTR structure. 
        case DM_ASSERT:
            fPostEvent = FALSE;
            //TODO: HandleAssert(reinterpret_cast<DMN_DEBUGSTR *>(dwParam));
            break;

        // The dwParam parameter contains a pointer to a RIP_INFO structure. 
        case DM_RIP:
            debugEvent.dwDebugEventCode = RIP_EVENT;
            debugEvent.dwThreadId = reinterpret_cast<DMN_DEBUGSTR *>(dwParam)->ThreadId;
            // Beware of leaks - we are copying the string.  Our queue is dumb, it will just
            // copy the pointer value.  That is actually good.  Debug events should all be pulled from
            // queue before the queue dies, and there is only one queue reader, so that reader owns
            // freeing the string.
            if(reinterpret_cast<DMN_DEBUGSTR *>(dwParam)->String)
            {
                debugEvent.u.RipInfo.dwError = reinterpret_cast<DWORD>
                    (new char[reinterpret_cast<DMN_DEBUGSTR *>(dwParam)->Length + 1]);
                memcpy(
                    reinterpret_cast<PVOID>(debugEvent.u.DebugString.lpDebugStringData),
                    reinterpret_cast<DMN_DEBUGSTR *>(dwParam)->String, 
                    reinterpret_cast<DMN_DEBUGSTR *>(dwParam)->Length
                    );
            }
            break;
    }
    if(fPostEvent)
    {
        pTheDebugEventPump->PostDebugEvent(debugEvent);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\tlxbox\dmxbox.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    dmxbox.h

Abstract:
    
    Declarations for the Xbox Debug Monitor Plug-in.
    dmxbox plugs directly into the em without a real
    transport layer.
    
--*/

#ifndef _DMXBOX_H_
#define _DMXBOX_H_

//-----------------------------------------------------------------
//  Compile time constants and Macros
//-----------------------------------------------------------------
#define WAIT_FOR_REBOOT_TIMEOUT 12000 //Wait up to 12 seconds for a box to reboot
#define WAIT_FOR_LAUNCH_TIMEOUT 60000 //Wait up to 60 seconds for title to hit initial breakpoint (after DmGo)

//-----------------------------------------------------------------
//  Globals used by the Xbox Debug Monitor.
//-----------------------------------------------------------------
struct DM_GLOBALS
{
    //Communicate with EM
    TLCALLBACKTYPE   pfnCallEm;                                // Function to call EM
    PFNEMGETWBBUFFER pfnGetEmWBBuffer;                         // Function to get thread specific WB buffer from EM
    LPDBF            pDebugFunctions;                          // Debug Helper Functions
    LONG             cbEmWBBuffer;                             // Size of buffers EM returns from pfnGetEmWBBuffer. 
    char             bReceiveBuffer[INITIAL_DMSENDBUFFERSIZE]; // Buffer for storing replies from the EM.
};
extern DM_GLOBALS g_DmGlobals;

//-----------------------------------------------------------------
//  Exported Methods
//-----------------------------------------------------------------
int  WINAPI DllMain(HINSTANCE hModule, DWORD dwReason, DWORD dwReserved);
XOSD WINAPI TLFunc(TLF wCommand, HPID hpid, WPARAM wParam, LPARAM lParam);

//-----------------------------------------------------------------
//  Internal Methods
//-----------------------------------------------------------------
XOSD DMInit(TLCALLBACKTYPE pfnEntryPoint, LPDBF pdbf);
XOSD DispatchRequest(LPDBB lpdbb, DWORD cb);
void GetDebuggerInfo(OUT DMINFO *pDebuggerInfo);

// Process Management (process.cpp)
void ProcessSpawnOprhanCmd(LPDBB lpdbb);
HRESULT ProcessSetLaunchTitle(PROGLOAD *pProgramLoadInfo);
HRESULT EnsurePendingExecState();

//Notification Management (notify.cpp)
HRESULT StopNotifications();

#endif // _DMXBOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\tlxbox\events.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    events.h

Abstract:

    Declaration of CDebugEventPump.

    CDebugEventPump is a central receiving and translation facility for debug events.  This
    class is used by the processes polling thread.

    1) Set up notifications of debug events.
    2) Receives notifications from xboxdbg.dll.
    2) Translates notifications into debug events.
    3) Synchronizes access to debug events.
    
Author:
    mitchd

--*/

#ifndef __XBOX_EVENTS__
#define __XBOX_EVENTS__

typedef std::queue<DEBUG_EVENT> CDebugEventQueue;  //Yes, queue is from STL.
class CDebugEventPump
{
  public:
    CDebugEventPump() : m_pNotificationSession(NULL) {}
    ~CDebugEventPump();

    HRESULT Initialize(PDMN_SESSION pNotificationSession);
    HRESULT StartNotifications();
    inline HRESULT PauseNotifications() 
        {return DmNotify(m_pNotificationSession, DM_NONE, CDebugEventPump::EventNotifications);}
    HRESULT StopNotifications();
    
    BOOL GetDebugEvent(OUT DEBUG_EVENT& DebugEvent);
    void PostDebugEvent(const DEBUG_EVENT& DebugEvent);

private:
    
    static DWORD __stdcall EventNotifications(ULONG dwNotification, DWORD dwParam);
    static CDebugEventPump *sm_pTheOneAndOnly;

    CDebugEventQueue  m_EventQueue;
    PDMN_SESSION      m_pNotificationSession;
    CRITICAL_SECTION  m_CriticalSection;

    enum {QuitPump=0,DebugEventPosted=1};
    HANDLE  m_hSynchronizationEvents[2];

};

#endif //__XBOX_EVENTS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\tlxbox\utils.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    utils.h

Abstract:
    
    Various Utility Functions And Class - added as needed.

--*/

#ifndef __XBOX_UTILS__
#define __XBOX_UTILS__


//-----------------------------------------------------------------
// A very simple class for holding onto a critical section, within
// a particular scope.
//-----------------------------------------------------------------
class CHoldCriticalSection
{
  public:
     CHoldCriticalSection(CRITICAL_SECTION *pCriticalSection) : 
        m_pCriticalSection(pCriticalSection)
     {
        EnterCriticalSection(m_pCriticalSection);
     }
    ~CHoldCriticalSection()
    {
        LeaveCriticalSection(m_pCriticalSection);
    }
  private:
    CRITICAL_SECTION *m_pCriticalSection;
};

template<class T> inline void ZeroStructure(T& tStruct)
{
    memset(reinterpret_cast<void *>(&tStruct), 0, sizeof(T));
}

#endif //__XBOX_UTILS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\tlxbox\precomp.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:
    
    Precompiled header for the VC7 debugger plug-in for Xbox.
    
--*/

//Standard Windows\C\C++ stuff
#include <windows.h>
#include <process.h>
#include <stdlib.h>
#include <tchar.h>
#include <stdio.h>
#include <stdarg.h>
#include <queue>

//VC7 header files.
#include <internalnt.h>
#include <odtypes.h>
#include <od.h>
#include <odp2.h>
#include <emdm.h>
#include <vcexcept.h>

//Xbox Headers
#include <xboxdbg.h>

// Useful macros
#define ARRAYSIZE(_x_) (sizeof(_x_)/sizeof(_x_[0]))

//Header Files for this project
#include "debug.h"
#include "utils.h"
#include "dmxbox.h"
#include "events.h"
#include "xprocess.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\tlxbox\process.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    process.cpp

Abstract:

    Implementation of debugger routines related to launching and destroying processes on Xbox.
    
Author:

    mitchd

--*/
#include <precomp.h>

//-------------------------------------------------------------------------------------------------------------
// Default Exception Table:  I am not 100% sure where to put it.  It is need by CXboxProcess, but really
//                           feels like it should be separate.  We will put here has a static global, for now.
//-------------------------------------------------------------------------------------------------------------
// BUGBUG - The names of the default exceptions should arguably be localizable and stored in a resource.
//          They are hard-coded for now.  We could in the future restructure the table store to store resource
//          name and look them when needed.
#define efdDefault efdNotify
static EXCEPTION_DESCRIPTION g_DefaultExceptionTable[] = 
{
    // DBG_CONTROL_C and DBG_CONTROL_BREAK are *only*
    // raised if the app is being debugged.  The system
    // remotely creates a thread in the debuggee and then
    // raises one of these exceptions; the debugger must
    // respond to the first-chance exception if it wants
    // to trap it at all, because it will never see a
    // last-chance notification.
    {(DWORD)DBG_CONTROL_C,                    efdStop,    "Control-C"},
    {(DWORD)DBG_CONTROL_BREAK,                efdStop,    "Control-Break"},
    {(DWORD)EXCEPTION_DATATYPE_MISALIGNMENT,  efdDefault, "Datatype Misalignment"},
    {(DWORD)EXCEPTION_ACCESS_VIOLATION,       efdDefault, "Access Violation"},
    {(DWORD)EXCEPTION_IN_PAGE_ERROR,          efdDefault, "In Page Error"},
    {(DWORD)STATUS_ILLEGAL_INSTRUCTION,       efdDefault, "Illegal Instruction"},
    {(DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED,  efdDefault, "Array Bounds Exceeded"},
    // Floating point exceptions will only be raised if
    // the user calls _controlfp() to turn them on.
    {(DWORD)EXCEPTION_FLT_DENORMAL_OPERAND,   efdDefault, "Float Denormal Operand"},
    {(DWORD)EXCEPTION_FLT_DIVIDE_BY_ZERO,     efdDefault, "Float Divide by Zero"},
    {(DWORD)EXCEPTION_FLT_INEXACT_RESULT,     efdDefault, "Float Inexact Result"},
    {(DWORD)EXCEPTION_FLT_INVALID_OPERATION,  efdDefault, "Float Invalid Operation"},
    {(DWORD)EXCEPTION_FLT_OVERFLOW,           efdDefault, "Float Overflow"},
    {(DWORD)EXCEPTION_FLT_STACK_CHECK,        efdDefault, "Float Stack Check"},
    {(DWORD)EXCEPTION_FLT_UNDERFLOW,          efdDefault, "Float Underflow"},
    // STATUS_NO_MEMORY can be raised by HeapAlloc and
    // HeapRealloc.
    {(DWORD)STATUS_NO_MEMORY,                 efdDefault, "No Memory"},
    // STATUS_NONCONTINUABLE_EXCEPTION is raised if a
    // noncontinuable exception happens and an exception
    // filter return -1, meaning to resume execution.
    {(DWORD)STATUS_NONCONTINUABLE_EXCEPTION,  efdDefault, "Noncontinuable Exception"},
    // STATUS_INVALID_DISPOSITION means an NT exception
    // filter (which is slightly different from an MS C
    // exception filter) returned some value other than
    // 0 or 1 to the system.
    {(DWORD)STATUS_INVALID_DISPOSITION,       efdDefault, "Invalid Disposition"},
    {(DWORD)EXCEPTION_INT_DIVIDE_BY_ZERO,     efdDefault, "Integer Divide by Zero"},
    {(DWORD)EXCEPTION_INT_OVERFLOW,           efdDefault, "Integer Overflow"},
    {(DWORD)EXCEPTION_PRIV_INSTRUCTION,       efdDefault, "Privileged Instruction"},
    {(DWORD)STATUS_STACK_OVERFLOW,            efdDefault, "Stack Overflow"},
    {(DWORD)STATUS_DLL_NOT_FOUND,             efdDefault, "DLL Not Found"},
    {(DWORD)STATUS_DLL_INIT_FAILED,           efdDefault, "DLL Initialization Failed"},
    {(DWORD)VcppException(ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND),
                                              efdDefault, "Module Not Found"},
    {(DWORD)VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND),
                                              efdDefault, "Procedure Not Found"},
    {(DWORD)STATUS_INVALID_HANDLE,            efdStop,    "Invalid Handle"},
    {(DWORD)(0xE0000000 | 'msc'),             efdNotify,  "Microsoft C++ Exception"},
};
// This NULL exception is reference in a few places as a coding convenience.
static EXCEPTION_DESCRIPTION g_NullExceptionDescription = {0};

//-------------------------------------------------------------------------------------------------------------
// Declare\Initialize CXboxProcess's static members
//-------------------------------------------------------------------------------------------------------------
CXboxProcess     *CXboxProcess::sm_pProcessList = NULL;
CRITICAL_SECTION  CXboxProcess::sm_CriticalSection;

//-------------------------------------------------------------------------------------------------------------
//  Public CXboxProcess Methods
//     Implemeneted in the same in logical order as in the class declaration.
//-------------------------------------------------------------------------------------------------------------

XOSD CXboxProcess::InitializeCXboxProcessClass()
/*++
  Routine Description:
    CXboxProcess has several static members.  These are initialized here.  Called from DMInit.
  Return Value:
    Always xosdNone.
--*/
{
    _ASSERTE(NULL == sm_pProcessList);
    InitializeCriticalSection(&sm_CriticalSection);
    return xosdNone;
}

XOSD CXboxProcess::Create(HPID hPid)
/*++
  Routine Description:
    Creates a new process and inserts into the process list.
  Arguments:
    hPid - handle to process ID assigned by OSD.  If hPid is NULL, then it is not going to find a process.
  Return Value:
    error code.
--*/
{
    XOSD xosd;
    CXboxProcess *pNewProcess = new CXboxProcess(hPid);
    if(pNewProcess)
    {
        xosd = pNewProcess->InitializeAndInsertIntoProcessList();
    } else
    {
        xosd = xosdOutOfMemory;
    }
    return xosd; 
}

XOSD CXboxProcess::Destroy()
/*++
  Routine Description:
    Removes an existing process from the process list, and deletes it.
  Return Value:
    Reports xosdUnknown if the process was not in the list.
--*/
{
    XOSD xosd = xosdUnknown;
    //Find this process in the list and remove it.  The block is for the critical section
    {
        CHoldCriticalSection  manipulatingProcessList(&sm_CriticalSection);
        CXboxProcess *pPreviousProcess = NULL;
        CXboxProcess *pProcess = sm_pProcessList; 
        while(pProcess && (pProcess != this))
        {
            pPreviousProcess = pProcess;
            pProcess = pProcess->m_pNextProcess;
        }
        
        // short circuit here and return an error
        if(pProcess)
        {
            // We found the process so assume success;
            xosd = xosdNone;
            if(pPreviousProcess)
            {
                pPreviousProcess->m_pNextProcess = m_pNextProcess;
            } else
            {
                sm_pProcessList = m_pNextProcess;
            }
            m_pNextProcess = NULL;
        } else
        {
            _ASSERTE(FALSE && "Process being destroyed was not in list.");
        }
    }
    
    // whether in the list or not, delete ourselves.
    delete this;
    return xosd;
}

CXboxProcess *CXboxProcess::GetProcess(HPID hPid)
/*++
  Routine Description:
    Get a pointer to an existing CXboxProcess given an hPid.
  Arguments:
    hPid - handle to process ID assigned by OSD.  If hPid is NULL, then it is not going to find a process.
  Return Value:
    Pointer to corresponding process if found, otherwise NULL.
--*/
{
    CXboxProcess *pDesiredProcess = NULL;
    if(hPid) 
    {
        CHoldCriticalSection  searchingProcessList(&sm_CriticalSection);
        pDesiredProcess = sm_pProcessList;
        while(sm_pProcessList)
        {
            if(pDesiredProcess->m_hPid == hPid)
                break;
            pDesiredProcess = pDesiredProcess->m_pNextProcess;
        }
    }
    return pDesiredProcess;
}


XOSD CXboxProcess::ProgramLoad(LPPROGLOAD pProgamLoadInfo)
/*++
  Routine Description:
    Called in response to dmfProgLoad.  Loads or attaches to the specified process.
    This is largely responsible for the process of beginning to debug an Xbox process.
  Arguments:
    pProgramLoadInfo - information about the process to debug.
--*/
{
    HRESULT hr = S_OK;
    XOSD    xosd;
    
    // We need an initial start breakpoint event
    //
    if(!m_hStartBreakPointEvent)
    {
        m_hStartBreakPointEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if(!m_hStartBreakPointEvent)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    
    //BUGBUG:  For now always reboot the Xbox, we will need to
    //         get more subtle soon.
    if(SUCCEEDED(hr))
    {
        hr = EnsurePendingExecState();
    }

    // Set the launch title
    //
    if(SUCCEEDED(hr))
    {
        hr = SetTitle(pProgamLoadInfo);
    }

    // Set an initial break point
    //
    if(SUCCEEDED(hr))
    {
        hr = DmSetInitialBreakpoint();
    }

    if(SUCCEEDED(hr))
    {
        hr = DmStopOn(DMSTOP_CREATETHREAD, TRUE);
    }

    if(SUCCEEDED(hr))
    {
        ResetEvent(m_hStartBreakPointEvent);
        
        // Not our normal Notification Handle, but a special one, while
        // we are launching a process.
        //
        DmNotify(m_pDmNotificationSession, DM_CREATETHREAD, CXboxProcess::LaunchNotifications);
        DmNotify(m_pDmNotificationSession, DM_BREAK, CXboxProcess::LaunchNotifications);
        DmNotify(m_pDmNotificationSession, DM_EXCEPTION, CXboxProcess::LaunchNotifications);
        
        // We have not launched the title yet.
        _ASSERTE(0==m_tidMainThread);
        DmGo();

        // Wait for initial breakpoint, but not more than WAIT_FOR_LAUNCH_TIMEOUT
        WaitForSingleObject(m_hStartBreakPointEvent, WAIT_FOR_LAUNCH_TIMEOUT);

        if(m_tidMainThread && SUCCEEDED(DmConnectDebugger(TRUE)))
        {
            //xosd = XboxConnect(CONNECT_LAUNCH);
        } else
        {
            // We will do more elegant error handling
            /*
            char szError[256];
            xosd = xosdGeneral;
            if(LoadString(hInstance, IDS_ERR_NOSTART, szError, sizeof szError))
            {
                SendDBCError(hprc, xosd, szError);
            }
            */
        }
    } else
    {
        DPRINT(5, (_T("Can't start\n")));
        /* If we can't get our startup breakpoint, we'll start the
        * machine but fail to launch */
        DmGo();
        xosd = xosdGeneral;
        // Report the error please.
    }

    // Set the box running
    //
    return xosdNone;
}


XOSD CXboxProcess::GetExceptionInfo(LPEXCMD pExceptionCommand, OUT EXCEPTION_DESCRIPTION *pExceptionDescriptionRet)
/*++
  Routine Description:
    Called to get information about an exception.  Can be called with exfFirst and then
    exfNext to enumerate all the exception and their settings, or can be called with exfSpecified
    to get information about a particular exception.
  Arguments:
    pExceptionCommand - the data sent from the EM describing which exception it wants information about.
    pExceptionDescriptionRet- pointer to buffer to return the exepction description in.
  Return Value:
    Error Status
 
--*/
{
    XOSD                           xosd = xosdEndOfStack;
    PEXCEPTION_ITEM                pExceptionItem;
    
    CHoldCriticalSection  synchronizeAccessToProcess(&sm_CriticalSection);

    //Setup the first exception item
    pExceptionItem = m_pExceptionList;

    // If the caller does not want the first exception item,
    // then find the one that the caller wants/
    if(exfFirst != pExceptionCommand->exc)
    {
        while(pExceptionItem)
        {
            // Check for a match against the exception code that the caller passed in.
            if(pExceptionItem->Exception.dwExceptionCode == pExceptionCommand->exd.dwExceptionCode)
            {
                //  If the caller said exfNext, than the caller wants the one after the
                //  one it passed in.
                if(exfNext == pExceptionCommand->exc)
                {
                    pExceptionItem = pExceptionItem->NextExceptionItem;
                } else if(exfSpecified != pExceptionCommand->exc)
                //  exfFirst, exfNext, and exfSpecified are the only support
                //  commands, make sure the caller didn't send something else.
                {
                    pExceptionItem = NULL;
                    xosd = xosdUnknown;
                }
                break;
            }
            pExceptionItem = pExceptionItem->NextExceptionItem;
        }
    }

    //  We should now have an exception item, unless some
    //  error occured (such as reaching the end of the list).
    if(pExceptionItem)
    {
        xosd = xosdNone;
        *pExceptionDescriptionRet = pExceptionItem->Exception;
    }
    
    return xosd;
}


XOSD CXboxProcess::GetDefaultExceptionInfo(LPEXCMD pExceptionCommand, OUT EXCEPTION_DESCRIPTION *pExceptionDescriptionRet)
/*++
  Routine Description:
    See GetExceptionInfo, the only difference is that it queries the global defaults rather
    than the possibly modified list associated with a particular process.
--*/
{
    int index;
    XOSD                           xosd = xosdEndOfStack;

    // Find the correct index
    index=0;
    if(exfFirst != pExceptionCommand->exc)
    {
        for(; index < ARRAYSIZE(g_DefaultExceptionTable); index++)
        {
            // Check for a match against the exception code that the caller passed in.
            if(g_DefaultExceptionTable[index].dwExceptionCode == pExceptionCommand->exd.dwExceptionCode)
            {
                //  If the caller said exfNext, than the caller wants the one after the
                //  one it passed in.
                if(exfNext == pExceptionCommand->exc)
                {
                    index++;
                } else if( exfSpecified != pExceptionCommand->exc )
                {
                    index = ARRAYSIZE(g_DefaultExceptionTable);
                    xosd = xosdUnknown;
                }
                break;
            }
        }
    }

    //  If index is less than ARRAYSIZE(DefaultExceptionTable), then we
    //  found a matching index.
    if(ARRAYSIZE(g_DefaultExceptionTable) > index)
    {
        xosd = xosdNone;
        *pExceptionDescriptionRet = g_DefaultExceptionTable[index];
    }
    
    return xosd;
}


//-------------------------------------------------------------------------------------------------------------
//  Internal CXboxProcess Methods
//     Implemeneted in the same in logical order as in the class declaration.
//-------------------------------------------------------------------------------------------------------------

// CXboxProcess::CXboxProcess() implementation is in header file
CXboxProcess::~CXboxProcess()
/*++
  Routine Description:
    d'tor for a process.  Needs no synchronization, as the process has been removed
    from the process list, and noone else should have a reference to it.
--*/
{
    //Destroy our exception list,
    while(m_pExceptionList)
    {
        EXCEPTION_ITEM *pDoomedItem = m_pExceptionList;
        m_pExceptionList = pDoomedItem->NextExceptionItem;
        delete pDoomedItem;
    }
}

XOSD CXboxProcess::InitializeAndInsertIntoProcessList()
/*++
  Routine Description:
    Initialize a CXboxProcess and put it into the process list.
  Return Value:
    Error Status.
  
--*/
{
    int index;
    XOSD xosd = xosdNone;

    //  Initialize our exception list from the DefaultExceptionTable
    m_pExceptionList = NULL;
    for(index=0; index < ARRAYSIZE(g_DefaultExceptionTable); index++)
    {
        EXCEPTION_ITEM *pNewItem = new (EXCEPTION_ITEM);
        if(pNewItem)
        {
            pNewItem->Exception = g_DefaultExceptionTable[index];
            pNewItem->NextExceptionItem = m_pExceptionList;
            m_pExceptionList = pNewItem;
        } else
        {
            xosd = xosdOutOfMemory;
            break;
        }
    }
    
    
    //*** Do this only on success, and put all other initialization
    //*** first!!!!!!!
    if(xosdNone == xosd)
    {
        //Insert process into process list
        CHoldCriticalSection  manipulatingProcessList(&sm_CriticalSection);

        // If we are not multi-Xbox Debugging, then there better be only one process at a time.
        #ifndef MULTI_XBOX_DEBUGGING
        _ASSERTE(NULL == sm_pProcessList);
        #endif

        m_pNextProcess = sm_pProcessList;
        sm_pProcessList = this;
    }
    
    return  xosd;
}


HRESULT CXboxProcess::EnsurePendingExecState()
{
    HRESULT hr = S_OK;
    HANDLE hRebootEvent;
    if(DMN_EXEC_PENDING != m_dwExecState)
    {
        hr = EnsureOpenNotificationSession();
        if(SUCCEEDED(hr))
        {
            // There shouldn't be a reboot event yet.
            _ASSERTE(!m_hRebootEvent);
            
            // Create a reboot event (our standard handler will set this when reboot completes)
            hRebootEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            if(!hRebootEvent)
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
            {
                m_hRebootEvent = hRebootEvent;

                // Make sure EXEC state changes are being notified.
                hr = DmNotify(m_pDmNotificationSession, DM_EXEC, CXboxProcess::LaunchNotifications);
  
                if(SUCCEEDED(hr)) {
                    
                    // Tell the box to reboot and wait for the debugger to specify a title.
                    DmReboot(DMBOOT_WAIT | DMBOOT_WARM);
                    
                    // Wait For the Reboot (but not forever)
                    if(WaitForSingleObject(m_hRebootEvent, WAIT_FOR_REBOOT_TIMEOUT) == WAIT_TIMEOUT)
                    {
                        hr = XBDM_CONNECTIONLOST;
                    }
                    else
                    {
                        _ASSERTE(m_dwExecState == DMN_EXEC_PENDING);
                    }
                }
                m_hRebootEvent = NULL;
                // Done with the reboot event
                HANDLE hRebootEvent = m_hRebootEvent;
                m_hRebootEvent = NULL;
                CloseHandle(hRebootEvent);
            }
        }
    }
    return hr;
}

HRESULT CXboxProcess::SetTitle(LPPROGLOAD pProgramLoadInfo)
/*++
  Routine Description:
    Reads and parse the arguments from LPPROGLOAD and calls DmSetTitle
--*/
{
    LPSTR  pszDir;
    LPSTR  pszTitle;
    LPSTR  pszCommandLine;
    
    _ASSERTE(pProgramLoadInfo->szDir);
    _ASSERTE(pProgramLoadInfo->szExe);
    
    // The Dir is usually the working directory.  Xbox doesn't have such a concept.  However, we will use this
    // as the directory on Xbox.
    pszDir = pProgramLoadInfo->szDir;
    
    //Strip a leading 'x' off the directory.
    if( ('x' == pszDir[0] || 'X' == pszDir[0]) && pszDir[1] && pszDir[2] == ':')
    {
        pszDir++;
    }
    
    // Command line has full path to the xbe, but it is the local path on the development system.
    // We clip the title name off the szCmdLine and tack it on the working directory to get the
    // path on the Xbox.
    pszTitle = strrchr(pProgramLoadInfo->szExe,'\\');
    if(pszTitle)
    {
        pszTitle++;
    }
    else
    {
        pszTitle = pProgramLoadInfo->szCmdLine;
    }

    //BUGBUG - As a temporary measure (to help out with symbols), we copy the title
    //         to a buffer, chop off the .exe and replace with .xbe.  In the future,
    //         we actually force the user to put in .xbe, but only after we modify the
    //         EE to suck symbols information from an XBE.
    char szHackedTitle[MAX_PATH];
    strcpy(szHackedTitle, pszTitle);
    pszTitle = strrchr(szHackedTitle, '.');
    if( pszTitle && ('e' == pszTitle[1]) && ('x' == pszTitle[2]) && ('e' == pszTitle[3]))
    {
        pszTitle[1] = 'x';
        pszTitle[2] = 'b';
    }
    
    // Command line args to pass to the caller
    pszCommandLine = pProgramLoadInfo->szCmdLine;
    if(pszCommandLine)
    {
        while( ' ' == *pszCommandLine|| '\t' == *pszCommandLine)
        {
            pszCommandLine++;
        }
    }
    
    return DmSetTitle(pszDir, szHackedTitle, *pszCommandLine ? pszCommandLine : NULL);
}



XOSD CXboxProcess::SynchronizeConnection(int dwReason)
/*++
  Routine Description:
   Does all the things to synchronize the debugger with process being debugged.

  Arguments:   
    dwReason
        SYNC_LAUNCH  - synchronize the debugger upon launching a process.
        SYNC_ATTACH  - synchronize the debugger upon attaching to a process.
    
        BUGBUG - for now, we only handle SYNC_LAUNCH, this needs to be fixed.
  
  Return Value:
    xosdNone - on success.

  Abstract:
    In the Windows world, once you attach to the debugger you start gettting debug
    events for things like process creation, module load, thread attach, etc.   Even
    if the process is already loaded (which it always is actually), you get all of
    these things to catch you up to the current state.  xbdm.dll (on Xbox) doesn't
    work this way, and XboxDbg.dll doesn't fake it for us.  So we have to.  In the VC6
    plug-in, we spun up a thread just to do that.  Here we are going to try a more
    elegant solution.  We will post events for each of these things in our CDebugEventPump
    (a.k.a. prime the pump), before we start our polling thread that start pumping them
    out to the EM.   This way we don't need to spin up a separate thread just to get
    things synchronized.

    Here is an outline of what we do:

    0) The process should be stopped before entering this routine.

    1) Disable KD

    2) Walk the modules, and find the XBE.  There may not be one, in which case, we refuse to attach.

    3) Build and post a CREATE_PROCESS_DEBUG_EVENT.

    4) Build and post a CREATE_THREAD_DEBUG_EVENT for each thread found excepting the main thread.  If
       we are attaching to a previously started process, we won't know which is the main thread, we
       just choose one.

    5) Build and post a LOAD_DLL_DEBUG_EVENT for every module, but the XBE's module.

    6) If we are attaching to a stopped process, walk the threads, find out which ones are stopped, building
       and posting an appropriate debug event for each one.

    At this point, are queue is primed with all the events to synchronize the EM with the current state.  Now
    just finish things up to keep it that way.
       
    6) Start the CDebugEventPump, so XboxDbg.DLL will start sending it nofications.

    7) Tell the Xbox to "go", except if we are attaching to a stopped process that is not stopped for an ASSERT
       (if it is stopped for an assert, we still tell it to go, don't worry it will hit the assert again
        immediately, this way we can get the assert string).

    8) Spin up the polling thread, which will convey all of this work up to the EM.

    We should now be running!!!  At least until we hit the initial break point, but that will just be
    handled through "normal" channels now.

--*/
{

#if 0 
//Under Construction
//Won't compile


    HRESULT            hr = S_OK;
    DEBUG_EVENT        debugEvent;

    //
    //  We don't want to compete with kd.
    //
    DmSendCommand(NULL, "kd disable", NULL, 0);


    //  Find the XBE, while we are at it get all the
    //  module information.
    const DMN_MODLOAD& LoadModuleInformation(DMN_MODULE_DEQUE& dmnModuleDeque

    BOOL               fFoundXBE = FALSE;
    BOOL               fFoundTLS = FALSE;
    PDM_WALK_MODULES   pDmWalkModules = NULL;
    DMN_MODULE_DEQUE   moduleDeque;
    DMN_MODLOAD&       dmLastModuleWithTls;
    DMN_MODLOAD        dmModule;
    while(SUCCEEDED(DmWalkLoadedModules(&pDmWalkModules, &dmModule))
    {
        // Insert the module
        modules.insert(modules.begin(), dmModule);
        if(dmModule.Flags & DMN_MODFLAG_XBE)
        {
            dmModule.BaseAddress 
            fFoundXBE = TRUE;
            break;
        }
    }

    //
    //  Generate a CREATE_PROCESS_DEBUG_EVENT and
    //  stuff it in the queue.
    ZeroStructure(debugEvent);


typedef struct _CREATE_PROCESS_DEBUG_INFO {
  HANDLE hFile; 
  HANDLE hProcess; 
  HANDLE hThread; 
  LPVOID lpBaseOfImage; 
  DWORD dwDebugInfoFileOffset; 
  DWORD nDebugInfoSize; 
  LPVOID lpThreadLocalBase; 
  LPTHREAD_START_ROUTINE lpStartAddress; 
  LPVOID lpImageName; 
  WORD fUnicode; 
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO; 

    debugEvent
/* Send the create process message.  If we're launching, we have the ID
     * of the first thread, and if we're connecting, we'll just pick the first
     * one in the thread list */
    ctid = sizeof(rgtid) / sizeof(DWORD);
    if(FAILED(DmGetThreadList(rgtid, &ctid)))
        ctid = rgtid[0] = 0;
    de.dwDebugEventCode = CREATE_PROCESS_DEBUG_EVENT;
    de.dwProcessId = 1;
    if(mdConnect == CONNECT_LAUNCH) {
        de.dwThreadId = g_tidBreak;
        de.u.CreateProcessInfo.lpStartAddress = g_pvThreadStart;
    } else 
        de.dwThreadId = rgtid[0];
    de.u.CreateProcessInfo.hFile = &conn.dmmlXbe;
    de.u.CreateProcessInfo.lpImageName = (PVOID)0x00010000;
    de.u.CreateProcessInfo.lpBaseOfImage = conn.dmmlXbe.BaseAddress;

    if(SUCCEEDED(DmGetThreadInfo(de.dwThreadId, &dmti)))
        de.u.CreateProcessInfo.lpThreadLocalBase = dmti.TlsBase;
    else
        de.u.CreateProcessInfo.lpThreadLocalBase = NULL;
    ResetEvent(hEventContinue);
    ProcessDebugEvent(&de);
    WaitForSingleObject(hEventCreateProcess, INFINITE);
    WaitForSingleObject(hEventContinue, INFINITE);
    hprc = HPRCFromPID(1);
    _ASSERTE(hprc);
    _ASSERTE(hprc->pstate & ps_connect);


    
    
    



    // Start the polling thread, now we will get debug notifications, and start handling them.
    if(!StartPollingThread())
    {
        return xosdOutOfMemory;
    }
    
    /* We need to make sure we can find the XBE module.  We may be running on
     * an old build that doesn't report the XBE, so we'll key off of the last
     * module in the list that has TLS if that's the case */
    pdmwm = NULL;
    fSawXBE = FALSE;
    dmmlTls.Flags = 0;
    while(SUCCEEDED(DmWalkLoadedModules(&pdmwm, &conn.dmmlXbe))) {
        if(conn.dmmlXbe.Flags & DMN_MODFLAG_XBE) {
            fSawXBE = TRUE;
            break;
        } else if(conn.dmmlXbe.Flags & DMN_MODFLAG_TLS)
            memcpy(&dmmlTls, &conn.dmmlXbe, sizeof dmmlTls);
    }
    DmCloseLoadedModules(pdmwm);
    if(!fSawXBE) {
        if(dmmlTls.Flags)
            /* Didn't see the XBE, but we did find a module with TLS.  Pretend
             * it's the XBE */
            memcpy(&conn.dmmlXbe, &dmmlTls, sizeof dmmlTls);
        else
            return xosdBadProcess;
    }

    /* Now that our state is set up, we spin off a thread to send all of the
     * notifications through and we'll continue with startup */
    conn.hevtLoaded = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(!conn.hevtLoaded)
        return xosdOutOfMemory;
    conn.mdConnect = mdConnect;
    hthr = CreateThread(NULL, 0, ConnectThread, &conn, 0, NULL);
    if(!hthr) {
        CloseHandle(conn.hevtLoaded);
        return xosdOutOfMemory;
    }
    CloseHandle(hthr);

    /* We're going to connect to a running process.  We do so by synthesizing
     * all of the events the debugger would normally expect to see during
     * the course of process launch */
    int mdConnect;
    DWORD rgtid[128];
    DWORD ctid;
    DWORD itid;
    DWORD dwNotify;
    DEBUG_EVENT de;
    DMN_MODLOAD dmml;
    DMN_BREAK dmbr;
    DM_THREADSTOP dmts;
    DM_THREADINFO dmti;
    CONTEXT cr;
    HPRCX hprc;
    PDM_WALK_MODULES pdmwm;
    CONN conn;

    /* Grab our parameters */
    memcpy(&conn, pvParam, sizeof conn);
    SetEvent(conn.hevtLoaded);
    mdConnect = conn.mdConnect;

    /* Set up our notifications */
    DmStopOn(DMSTOP_CREATETHREAD | DMSTOP_FCE, TRUE);
    for(dwNotify = 1; dwNotify <= DM_NOTIFYMAX; ++dwNotify)
        DmNotify(psessNotify, dwNotify, XboxNotification);

    memset(&de, 0, sizeof de);
    /* Send the create process message.  If we're launching, we have the ID
     * of the first thread, and if we're connecting, we'll just pick the first
     * one in the thread list */
    ctid = sizeof(rgtid) / sizeof(DWORD);
    if(FAILED(DmGetThreadList(rgtid, &ctid)))
        ctid = rgtid[0] = 0;
    de.dwDebugEventCode = CREATE_PROCESS_DEBUG_EVENT;
    de.dwProcessId = 1;
    if(mdConnect == CONNECT_LAUNCH) {
        de.dwThreadId = g_tidBreak;
        de.u.CreateProcessInfo.lpStartAddress = g_pvThreadStart;
    } else 
        de.dwThreadId = rgtid[0];
    de.u.CreateProcessInfo.hFile = &conn.dmmlXbe;
    de.u.CreateProcessInfo.lpImageName = (PVOID)0x00010000;
    de.u.CreateProcessInfo.lpBaseOfImage = conn.dmmlXbe.BaseAddress;

    if(SUCCEEDED(DmGetThreadInfo(de.dwThreadId, &dmti)))
        de.u.CreateProcessInfo.lpThreadLocalBase = dmti.TlsBase;
    else
        de.u.CreateProcessInfo.lpThreadLocalBase = NULL;
    ResetEvent(hEventContinue);
    ProcessDebugEvent(&de);
    WaitForSingleObject(hEventCreateProcess, INFINITE);
    WaitForSingleObject(hEventContinue, INFINITE);
    hprc = HPRCFromPID(1);
    _ASSERTE(hprc);
    _ASSERTE(hprc->pstate & ps_connect);

    /* Notify of the created threads */
    memset(&de.u, 0, sizeof de.u);
    de.dwDebugEventCode = CREATE_THREAD_DEBUG_EVENT;
    /* Loop over all the threads to notify of their creation.  If we're
     * launching, we hit all of them and skip the one we already sent -- which
     * hopefully should total zero notifications (why would any other threads
     * exist if we've only created the first one?).  If we're not launching,
     * we skip the first thread since we already sent that one with the
     * process */
    for(itid = mdConnect != CONNECT_LAUNCH; itid < ctid; ++itid)
        {
        if(mdConnect != CONNECT_LAUNCH || rgtid[itid] != g_tidBreak) {
            /* For each thread, we need to wait for the DM to acknowledge
             * creation and continuation of the thread, and only then can we
             * mark the thread as running */
            ResetEvent(hprc->hEventCreateThread);
            ResetEvent(hEventContinue);
            de.dwThreadId = rgtid[itid];
            if(SUCCEEDED(DmGetThreadInfo(de.dwThreadId, &dmti)))
                de.u.CreateThread.lpThreadLocalBase = dmti.TlsBase;
            else
                de.u.CreateThread.lpThreadLocalBase = NULL;
            ProcessDebugEvent(&de);
            WaitForSingleObject(hprc->hEventCreateThread, INFINITE);
            WaitForSingleObject(hEventContinue, INFINITE);
            SetDebugEventThreadState(hprc, ts_running);
        }
    }

    /* Enumerate the loaded DLLs and advise */
    pdmwm = NULL;
    while(SUCCEEDED(DmWalkLoadedModules(&pdmwm, &dmml))) {
        if(dmml.BaseAddress != conn.dmmlXbe.BaseAddress) {
            GetModLoadDebugEvent(&dmml, &de);
            ProcessDebugEvent(&de);
        }
    }
    DmCloseLoadedModules(pdmwm);

    /* At this point, we shouldn't have any deq's pending or in the works,
     * though we might have some continue events needing to be flushed */
    _ASSERTE(!dwTidStopped);
    _ASSERTE(!fDeqStopped);
    _ASSERTE(!pdeqFirst);
    DequeueAllEvents(TRUE, TRUE);

    switch(mdConnect) {
    case CONNECT_LAUNCH:
        /* We've sent all appropriate messages, and we're just waiting for
         * that breakpoint we're about to hit, so we'll continue the
         * initial thread and let the fireworks fly */
        hprc->pstate &= ~ps_connect;
        DmContinueThread(g_tidBreak, FALSE);
        DmGo();
        break;
    case CONNECT_ATTACH:
        /* this should have been converted to something else, but we'll just
         * treat it like connect to running */
        _ASSERTE(FALSE);
        // fall through
    case CONNECT_ATTACH_RUNNING:
        /* We forced this stop, which means we're connecting to a running
         * process.  We'll repost the breakpoint event and let it trigger
         * everything else */
        hprc->pstate &= ~ps_connect;
        cr.ContextFlags = CONTEXT_FULL;
        if(FAILED(DmGetThreadContext(g_tidBreak, (PCONTEXT)&cr)) ||
                !(cr.ContextFlags & CONTEXT_INTEGER))
            return xosdLineNotConnected;
        dmbr.ThreadId = g_tidBreak;
        dmbr.Address = (PVOID)cr.Eip;
        XboxNotification(DM_BREAK | DM_STOPTHREAD, (DWORD)&dmbr);
        break;
    case CONNECT_ATTACH_STOPPED:
        /* We didn't force this stop, so we'll say we've finished the load,
         * and then we'll go through every stopped thread and post a reason
         * for its stopped state */
        ConsumeAllProcessEvents (hprc, FALSE);
        ResetEvent(hEventContinue);
        de.dwDebugEventCode = LOAD_COMPLETE_DEBUG_EVENT;
        NotifyEM( &de, HTHDXFromPIDTID(1, rgtid[0]), 0, 0L);
        WaitForSingleObject( hEventContinue, INFINITE );

        /* We're connected now, so post those debug events */
        hprc->pstate &= ~(ps_connect | ps_preStart);
        mdConnect = CONNECT_ATTACH_RUNNING;
        for(itid = 0; itid < ctid; ++itid) {
            if(SUCCEEDED(DmIsThreadStopped(rgtid[itid], &dmts))) {
                if(dmts.NotifiedReason == DM_ASSERT) {
                    CONTEXT dmcr;
                    /* We missed the assert text, so we'll continue past the
                     * assert with an invalid continue and force the assert
                     * to repeat */
                    dmcr.ContextFlags = CONTEXT_INTEGER;
                    DmGetThreadContext(rgtid[itid], &dmcr);
                    dmcr.Eax = 0;
                    DmSetThreadContext(rgtid[itid], &dmcr);
                    DmContinueThread(rgtid[itid], FALSE);
                    if(mdConnect == CONNECT_ATTACH_RUNNING)
                        mdConnect = CONNECT_ATTACH_ASSERT;
                } else if(dmts.NotifiedReason != DM_NONE) {
                    mdConnect = CONNECT_ATTACH_STOPPED;
                    XboxNotification(dmts.NotifiedReason | DM_STOPTHREAD,
                        (DWORD)&dmts.u);
                    break;
                } else {
                    /* We should have continued these threads */
                    _ASSERTE(FALSE);
                }
            }
        }
        _ASSERTE(mdConnect != CONNECT_ATTACH_RUNNING);
        /* If our only stops are on asserts, we need to continue to force the
         * assert to reappear */
        if(mdConnect == CONNECT_ATTACH_ASSERT)
            DmGo();
        break;
    }
    #endif
    return xosdNone;
}

BOOL CXboxProcess::StartPollingThread()
/*++
  Routine Description:
    Kicks off a thread to begin polling for debug events.
--*/
{
    // Start only if it is not already running.
    if (!m_hPollThread)
    {
        m_hPollThread = (HANDLE)(LONG_PTR) _beginthreadex(
                                                0, 0, CXboxProcess::PollingLoopStub,
                                                reinterpret_cast<void *>(this), 0,
                                                reinterpret_cast<unsigned *>(&m_dwPollThreadId)
                                                );
    }
    _ASSERTE(m_hPollThread);
    return m_hPollThread ? TRUE : FALSE;
}

void CXboxProcess::StopPollingThread()
/*++
  Routine Description:
    Stops the polling thread and waits for it to stop.
--*/
{
    _ASSERTE(m_hPollThread);

    //  Killing the polling thread.
    //  
    //  1) Stopping notifications will tell XboxDbg.dll to stop sending notifications
    //     to m_DebugEventPump.
    //  2) It also causes m_DebugEventPump.GetDebugEvent to return FALSE immediately,
    //     when the debug event queue empties.
    //  3) The polling thread exists on its own when m_DebugEventPump.GetDebugEvent
    //     returns FALSE.
    m_DebugEventPump.StopNotifications();

    // Wait for the polling thread to exit.
    WaitForSingleObject(m_hPollThread, INFINITE);

    // The polling thread has exited, destroy all
    // memory of it.
    CloseHandle(m_hPollThread);
    m_hPollThread = NULL;
    m_dwPollThreadId = 0;
}

DWORD CXboxProcess::PollingLoop()
/*++
  Routine Description:
    The polling loop starts up a CDebugEventPump and then pumps on it
    dispatching debug events as necessary.

    The loop is terminated when another thread does SetEvent(m_hTerminatePollingEvent).
--*/
{
    DEBUG_EVENT debugEvent;
    while(m_DebugEventPump.GetDebugEvent(debugEvent));
    {
        // Write Code here to dispatch the debug Event. 

    }
    return 0;
}


//
// Notifications related methods.
//
// BUGBUG - this is one of the places that debugging multiple Xboxes simultaneously breaks down.  The notification
//          mechanism does not provide for a user context or a box ID.


HRESULT CXboxProcess::EnsureOpenNotificationSession()
/*++
  Routine Description:
    Makes sure that the process has an open notification session.
--*/
{
   HRESULT hr = XBDM_NOERR;
    if(!m_pDmNotificationSession)
    {
        hr = DmOpenNotificationSession(DM_PERSISTENT, &m_pDmNotificationSession);
    }
    return hr;
}

HRESULT CXboxProcess::CloseNotificationSession()
/*++
  Routine Description:
    Closes an open notification session
--*/
{
    HRESULT hr = XBDM_NOERR;
    if(m_pDmNotificationSession)
    {
        PDMN_SESSION pNotifySession = m_pDmNotificationSession;
        m_pDmNotificationSession = NULL;
        hr = DmCloseNotificationSession(pNotifySession);
    }
    return hr;
}
    
DWORD __stdcall CXboxProcess::LaunchNotifications(DWORD dwNotification, DWORD dwParam)
/*++
  Routine Description:
    Special notification handler during a process launch.
--*/
{
    DWORD dwTemp = 0;

    //BUGBUG - this really should be called in the context of a process.  It would
    //         be nice if the XboxDbg.dll would track our context and pass it in
    //         as dwContext.  The we could  do something like:
    // pThis = reinterpret_cast<CXboxProcess *>(dwContext);
    //         instead we are stuck with:
    CXboxProcess *pProcess = sm_pProcessList;
    _ASSERTE(pProcess);
    //         which of course this fails if there is more than one process in the list!
    
    switch(dwNotification & DM_NOTIFICATIONMASK)
    {
        case DM_EXEC:
           _ASSERTE(pProcess->m_hRebootEvent);
           dwTemp = pProcess->m_dwExecState;
           pProcess->m_dwExecState = dwParam;
           if((dwTemp == DMN_EXEC_REBOOT) && (pProcess->m_dwExecState != DMN_EXEC_REBOOT))
           {
                SetEvent(pProcess->m_hRebootEvent);
           }
           break;
        case DM_CREATETHREAD:
            pProcess->m_tidMainThread = reinterpret_cast<PDMN_CREATETHREAD>(dwParam)->ThreadId;
            pProcess->m_pvMainThreadStart = reinterpret_cast<PDMN_CREATETHREAD>(dwParam)->StartAddress;
            SetEvent(pProcess->m_hStartBreakPointEvent);
            break;

        case DM_EXCEPTION:
            // This was in the VC6 code.  Presumably, there might be some handled exception while
            // starting up that we just don't care about.  We are still XSS code when this happens,
            // presumably.
            if(
                (reinterpret_cast<PDMN_EXCEPTION>(dwParam)->Flags & DM_EXCEPT_FIRSTCHANCE) &&
                !(reinterpret_cast<PDMN_EXCEPTION>(dwParam)->Flags & DM_EXCEPT_NONCONTINUABLE)
                )
            {
                DmContinueThread(reinterpret_cast<PDMN_EXCEPTION>(dwParam)->ThreadId, TRUE);
                DmGo();
                //No event to set.
                return 0;
            }
            // Forward the error back on to kd
            _ASSERTE(!pProcess->m_tidMainThread);
            DmSendCommand(NULL, "kd exceptif", NULL, 0);
            break;
            
        case DM_BREAK:
            /* Uh oh, we failed to launch for some reason.  We need to inform the
            * shell that there is no process, which we will do by leaving
            * the start thread ID at zero */
            _ASSERTE(!pProcess->m_tidMainThread);
            DmReboot(DMBOOT_WAIT | DMBOOT_WARM);
            break;

        default:
            return 0;
    }
    
    SetEvent(pProcess->m_hStartBreakPointEvent);
    return 0;
}


/****
*****  Chopping Block
****/
#if 0

void ProcessSpawnOprhanCmd(LPDBB lpdbb)
/*++
  Routine Descrption:
    This routine used to be called to start a process without debugging it.  We have to figure out
    how to get called for this purpose again.
--*/
{
    XOSD        xosd;
    HRESULT     hr;
    DWORD       dwCreationFlags = 0;
    
    // Make sure the box is pending execution (waiting to launch a title) - reboot as necessary.
    hr = EnsurePendingExecState();
    if(SUCCEEDED(hr))
    {
        hr = ProcessSetLaunchTitle(reinterpret_cast<LPPROGLOAD>(lpdbb->rgbVar));
    }
    StopNotifications();    

    // If we managed to reboot and set a title, then
    // start running the title and report back
    if(SUCCEEDED(hr))
    {
        DmGo();
    }
    
    // Convert error code and reply
    if(hr == XBDM_NOSUCHFILE)
    {
        xosd = xosdFileNotFound;
    } else
    {
        xosd = xosdUnknown;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\makefile.inc ===
# Miscellaneous standard rules for VC project
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\tlxbox\main.cpp ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Implementation of the Xbox Debugger "Transport Layer" for VS7

    This is not really a transport layer in the same sense at tlloc, tlnet, tlgambit are for VC.  In those cases,
    the transport layer acts a bridge to a debug monitor layer that has the same implementation either running
    locally or across a wire.  There is more than one debugger monitor and they are interchangeable with the different
    transport layers.

    On Xbox the debugger monitor is xbdm.dll, which runs on the xbox.  xboxdbg.dll is a sort of transport layer which
    communicates over the wire to it.  This code is an adaptor module.  Firstly, it exposes the transport layer
    interface to connect to VS.  Secondly, it translates VS\VC debug monitor requests into calls xboxdbg.dll.
    
Author:
    mitchd

--*/

#include <precomp.h>

DMDBG_NO_RECURSION_DECLARE

// Declare DM globals
DM_GLOBALS g_DmGlobals = {0};


int
WINAPI
DllMain(
    HINSTANCE   hModule,
    DWORD       dwReason,
    DWORD       dwReserved
    )
/*++
  Routine Description:
    DllMain initializes the library.  Not much to do right now.
--*/
{
    if(DLL_PROCESS_ATTACH==dwReason)
    {
        DMDBG_NO_RECURSION_ALLOC
        DisableThreadLibraryCalls (hModule);
    } else if(DLL_PROCESS_DETACH==dwReason)     
    {
        DMDBG_NO_RECURSION_FREE
    }
    return TRUE;
}

XOSD
WINAPI
TLFunc(
    TLF     wCommand,
    HPID    hpid,
    WPARAM  wParam,
    LPARAM  lParam
    )
/*++

Routine Description:

    Main entry point.  All requests from the EM come in through here.

Arguments:

    wCommand    - Supplies the command to be executed.
    hpid        - Supplies the hpid for which the command is to be executed.
    wParam      - Supplies information about the command.
    lParam      - Supplies information about the command.

Return Value:

    XOSD error code.  xosdNone means that no errors occured.  Other error
    codes are defined in osdebug\include\od.h.

--*/

{
  XOSD xosd = xosdNone;

  switch (wCommand)
  {
    case tlfInit:
      //Init the DM
      xosd = DMInit(reinterpret_cast<TLCALLBACKTYPE>(lParam), reinterpret_cast<LPDBF>(wParam));
      break;
    case tlfLoadDM:
      // For Xbox the DM is already loaded, we are it.
      // Most of the state initialization will be done on dmfInit.
      break;
    case tlfDestroy:
      //TODO: Clean ourselves up
      break;
    case tlfConnect:

      break;
    case tlfDisconnect:

      break;

    case tlfSetEMBuffer:
      g_DmGlobals.pfnGetEmWBBuffer = reinterpret_cast<LPTLEMBUFFERMSG>(lParam)->pEmFunc;
      g_DmGlobals.cbEmWBBuffer     = reinterpret_cast<LPTLEMBUFFERMSG>(lParam)->cbBuffer;
      break;

    case tlfReply:
        // Place EM replies in the receive buffer.  This ought to get called in the
        // context of a thread that called the EM and is waiting for a reply.  Thus there
        // is no need to signal a reply.
        _ASSERTE(wParam <= INITIAL_DMSENDBUFFERSIZE);
        _fmemcpy (g_DmGlobals.bReceiveBuffer, (LPBYTE) lParam, wParam );
        break;
    
    case tlfDebugPacket:
    case tlfRequest:
        xosd = DispatchRequest(reinterpret_cast<LPDBB>(lParam),wParam);
        break;
 
    default:
        _ASSERTE ( FALSE );
        break;
    }
    return xosd;
}


//
//  A couple of macros to help us during development
//
#define DMF_NOT_YET_IMPLEMENTED(_dmfValue_)                 \
    case _dmfValue_:                                        \
      DPRINT(0, ("Not Yet Implemented: %s", #_dmfValue_));  \
      break

#if DBG
#define DMF_NOT_CALLED(_dmfValue_)                      \
    case _dmfValue_:                                    \
      DPRINT(0, ("Not Expecting: %s", #_dmfValue_));    \
      _ASSERTE(false);                                  \
      xosd = xosdUnsupported;                           \
      break
#else
    #define DMF_NOT_CALLED(_dmfValue_)
#endif



XOSD DispatchRequest(LPDBB lpdbb, DWORD cb)
/*++

Routine Description:

    This routine dispatch requests and debug packets.  This takes dmf
    message packets from the debugger and handles them, usually
    by dispatching to a worker function.

Arguments:

    cb      - supplies size of data packet

    lpdbb   - supplies pointer to packet

Return Value:

--*/
{
    
    //  The EM needs a reply.  Rather than pass in a pointer to an out-parameter (like a normal
    //  caller) it tells the TLFunc (using tlfSetEMBuffer) about a function to call to get a 
    //  "Reply Buffer".  (No doubt there is some history here.)  The reply buffer is per thread,
    //  but can be changed (resized even?) between calls.  We will just get it here.  Aside effect
    //  of this, is that we would be in trouble if we rentered this dispatch routine from the same
    //  thread (a.k.a. recursion).  The nice DMDBG_NO_RECURSION_XXX macros work in debug builds to
    //  detect and assert any coding errors we make in this respect.
    DMDBG_NO_RECURSION_ENTER
    EMBUFFERINFO *lpBufInfo = g_DmGlobals.pfnGetEmWBBuffer();
    LPDM_MSG lpDmMsg = reinterpret_cast<LPDM_MSG>(lpBufInfo->lpEmWBBuf);
    memset(lpBufInfo->lpEmWBBuf, 0, lpBufInfo->cbEmWBBuf);

    DMF   dmf = (DMF) (lpdbb->dmf & 0xffff);
    XOSD  xosd = xosdNone;
    CXboxProcess *pProcess = CXboxProcess::GetProcess(lpdbb->hpid);

    // The case statements are in the same order that they are declared in emdm.h, except
    // for commands that are nops on Xbox, in which case they are at the end.
    switch ( dmf ) {

      //dmfInit - NOP
      //dmfUnInit - NOP
      DMF_NOT_CALLED(dmfSelect);
      DMF_NOT_CALLED(dmfConnect);

      case dmfCreatePid:
        // Create a process to go along with the HPID
        _ASSERTE(NULL == pProcess);
        xosd = CXboxProcess::Create(lpdbb->hpid);
        break;

      case dmfDestroyPid:
        // Destroy the process.
        _ASSERTE(pProcess);
        xosd = pProcess->Destroy();
        break;

      DMF_NOT_YET_IMPLEMENTED(dmfSetPath);
      DMF_NOT_YET_IMPLEMENTED(dmfSpawnOrphan);  //ProcessSpawnOprhanCmd(lpdbb);
  
      case dmfProgLoad:
        xosd = pProcess->ProgramLoad(reinterpret_cast<LPPROGLOAD>(lpdbb->rgbVar));
        break;
      
      DMF_NOT_YET_IMPLEMENTED(dmfLoadCrashDump);
      DMF_NOT_YET_IMPLEMENTED(dmfProgFree);
      DMF_NOT_YET_IMPLEMENTED(dmfDebugActive);
      DMF_NOT_YET_IMPLEMENTED(dmfTerm);
      DMF_NOT_YET_IMPLEMENTED(dmfDetach);

      DMF_NOT_YET_IMPLEMENTED(dmfGo);
      DMF_NOT_YET_IMPLEMENTED(dmfStop);
      DMF_NOT_YET_IMPLEMENTED(dmfNextReadableMemory);
      DMF_NOT_YET_IMPLEMENTED(dmfThreadManipulate);
      DMF_NOT_YET_IMPLEMENTED(dmfLockUnLock);

      DMF_NOT_YET_IMPLEMENTED(dmfSingleStep);
      DMF_NOT_YET_IMPLEMENTED(dmfReturnStep);
      DMF_NOT_YET_IMPLEMENTED(dmfNonLocalGoto);
      DMF_NOT_YET_IMPLEMENTED(dmfRangeStep);
      DMF_NOT_YET_IMPLEMENTED(dmfGoToReturn);

      DMF_NOT_YET_IMPLEMENTED(dmfBreakpoint);
      case dmfGetExceptionState:
        if(pProcess)
            xosd = pProcess->GetExceptionInfo(reinterpret_cast<LPEXCMD>(lpdbb->rgbVar),
                                              reinterpret_cast<EXCEPTION_DESCRIPTION *>(lpDmMsg->rgb)
                                              );
        else
            xosd = CXboxProcess::GetDefaultExceptionInfo(reinterpret_cast<LPEXCMD>(lpdbb->rgbVar),
                                                         reinterpret_cast<EXCEPTION_DESCRIPTION *>(lpDmMsg->rgb)
                                                         );
        break;
      DMF_NOT_YET_IMPLEMENTED(dmfSetExceptionState);

      DMF_NOT_YET_IMPLEMENTED(dmfReadMem);
      DMF_NOT_YET_IMPLEMENTED(dmfReadReg);
      DMF_NOT_YET_IMPLEMENTED(dmfReadFrameReg);
      DMF_NOT_YET_IMPLEMENTED(dmfWriteMem);
      DMF_NOT_YET_IMPLEMENTED(dmfWriteReg);
      DMF_NOT_YET_IMPLEMENTED(dmfWriteFrameReg);
      DMF_NOT_YET_IMPLEMENTED(dmfVirtualAllocEx);
      DMF_NOT_YET_IMPLEMENTED(dmfGetFP);
      DMF_NOT_YET_IMPLEMENTED(dmfSetFP);
      DMF_NOT_YET_IMPLEMENTED(dmfThreadStatus);
      DMF_NOT_YET_IMPLEMENTED(dmfProcessStatus);
      DMF_NOT_YET_IMPLEMENTED(dmfQueryTlsBase);
      DMF_NOT_YET_IMPLEMENTED(dmfQuerySelector);
      DMF_NOT_YET_IMPLEMENTED(dmfVirtualQuery);
      DMF_NOT_YET_IMPLEMENTED(dmfReadRegEx);
      DMF_NOT_YET_IMPLEMENTED(dmfWriteRegEx);
      DMF_NOT_YET_IMPLEMENTED(dmfGetSections);

      DMF_NOT_YET_IMPLEMENTED(dmfInit32SegValues);

      case dmfSelLim:
        // OSD want to know the maximum legal address, Xbox uses
        // a flat memory model, so the answer is always 0xFFFFFFFF.
        reinterpret_cast<DWORD *>(lpDmMsg->rgb)[0] = 0xFFFFFFFF;
        break;

      case dmfSetMulti:

#ifndef MULTI_XBOX_DEBUGGING    //notice there is no else, MULTI_XBOX_DEBUGGING is
        xosd = xosdUnsupported; //not yet (perhaps never) supported.
#endif
        break;

      //NOP - dmfClearMulti
      //NOP - (dmfDebugger);
      DMF_NOT_YET_IMPLEMENTED(dmfSync);
      DMF_NOT_YET_IMPLEMENTED(dmfSystemService);
      DMF_NOT_YET_IMPLEMENTED(dmfGetPrompt);
      DMF_NOT_YET_IMPLEMENTED(dmfSendChar);
      
      case dmfGetDmInfo:
        GetDebuggerInfo(reinterpret_cast<DMINFO *>(lpDmMsg->rgb));
        break;

      DMF_NOT_YET_IMPLEMENTED(dmfSetupExecute);
      DMF_NOT_YET_IMPLEMENTED(dmfStartExecute);
      DMF_NOT_YET_IMPLEMENTED(dmfCleanUpExecute);

      DMF_NOT_YET_IMPLEMENTED(dmfRemoteUtility);       // for the mfile utility

      DMF_NOT_YET_IMPLEMENTED(dmfGetSpecialReg);
      DMF_NOT_YET_IMPLEMENTED(dmfSetSpecialReg);

      //
      // File I/O
      //
      DMF_NOT_YET_IMPLEMENTED(dmfGetImageInformation);
      DMF_NOT_YET_IMPLEMENTED(dmfFindFirstFile);
      DMF_NOT_YET_IMPLEMENTED(dmfFindNextFile);
      DMF_NOT_YET_IMPLEMENTED(dmfCloseFindFile);
      DMF_NOT_YET_IMPLEMENTED(dmfOpenFile);
      DMF_NOT_YET_IMPLEMENTED(dmfReadFile);
      DMF_NOT_YET_IMPLEMENTED(dmfSeekFile);
      DMF_NOT_YET_IMPLEMENTED(dmfCloseFile);
      DMF_NOT_YET_IMPLEMENTED(dmfWriteCrashDump);

      DMF_NOT_YET_IMPLEMENTED(dmfGetDebuggableTaskList);
    
      // Load Library
      DMF_NOT_YET_IMPLEMENTED(dmfLoadLibrary);

      // Engine is ready for interop
      DMF_NOT_YET_IMPLEMENTED(dmfEngineReady);
      
      //**
      //**  Everything below here is a NOP
      //**
      case dmfInit:
      case dmfUnInit:
      case dmfClearMulti:
      case dmfDebugger:
        break;
    default:
        DPRINT(5, (_T("Unknown\n")));
        _ASSERTE(FALSE);
        xosd = xosdUnsupported;
        break;
    }
    
    //Set the error code
    lpDmMsg->xosdRet = xosd;

    DMDBG_NO_RECURSION_LEAVE
    return xosd;
}

XOSD DMInit(TLCALLBACKTYPE pfnEntryPoint, LPDBF pdbf)
{
    XOSD xosd = xosdNone;

    // Save the debugger helper
    g_DmGlobals.pDebugFunctions = pdbf;
    // Save the EM's entry points for calling it from the DM.
    g_DmGlobals.pfnCallEm = pfnEntryPoint;
    
    // Initialize the process list
    xosd = CXboxProcess::InitializeCXboxProcessClass();

    /* Define a false single step event */
    /*
    falseSSEvent.dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
    falseSSEvent.u.Exception.ExceptionRecord.ExceptionCode
          = EXCEPTION_SINGLE_STEP;

    falseBPEvent.dwDebugEventCode = BREAKPOINT_DEBUG_EVENT;
    falseBPEvent.u.Exception.ExceptionRecord.ExceptionCode
          = EXCEPTION_BREAKPOINT;

    FuncExitEvent.dwDebugEventCode = FUNC_EXIT_EVENT;
    FuncExitEvent.u.Exception.ExceptionRecord.ExceptionCode
          = EXCEPTION_SINGLE_STEP;
    */
    /* Define the standard notification method */
    /*
    EMNotifyMethod.notifyFunction = ConsumeThreadEventsAndNotifyEM;
    EMNotifyMethod.lparam     = (LPVOID)0;
    */
/*  
    SearchPathString[0] = _T('\0');
    SearchPathSet       = FALSE;
    

    InitEventQueue();
    InitDEQ();

    //
    // initialize data breakpoint handler
    //
    ExprBPInitialize();

    // Xbox has known hardware
    g_ProcFlags = PROCESSOR_FLAGS_EXTENDED | PROCESSOR_FLAGS_I386_MMX | PROCESSOR_FLAGS_I386_MMX2 | PROCESSOR_FLAGS_I386_MMX3;

 */
    return xosd;
}

void GetDebuggerInfo(OUT DMINFO *pDebuggerInfo)
{
    pDebuggerInfo->Processor.Type = mptix86;
    pDebuggerInfo->Processor.Level = 6;
    pDebuggerInfo->Processor.Endian = endLittle;
    pDebuggerInfo->Processor.processorFlags = PROCESSOR_FLAGS_EXTENDED|PROCESSOR_FLAGS_I386_MMX|
                                            PROCESSOR_FLAGS_I386_MMX2|PROCESSOR_FLAGS_I386_MMX3;
    pDebuggerInfo->Processor.pageSize = 4096;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\debugger\tlxbox\xprocess.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    process.h

Abstract:
    
    Declarations related to a process


Notes:
    
    Xboxes are single process, so the term process is synonymous with Xbox.  Here you will find code that almost
    encapsulates a process so that multiple processes (Xboxes) maybe debugged at once.  VC7 now supports this type
    of thing for the purpose of interprocess\machine debugging.  This could be especially powerful when debugging
    two Xboxes attached via a system link, or multiple Xboxes along with a backend server.

    Alas, it doesn't work.  Currently, XboxDbg.dll will only handle one box at a time from a single process.  Yes, there
    is the IXboxConnection thing, but that currently doesn't support notifications.  So we are out of luck for the time being.
    Maybe next year.

    So while this code comes close, there are some thing missing, and there are some places where we specifically prohibit it.
    The absence of something is hard to document (hint, we never tell XboxDbg which Xbox to debug, it is just always the default one).
    The extra stuff is enclosed as much as possible in #ifndef MULTI_XBOX_DEBUGGING.  Of course the whole notification mechanism doesn't
    support multiprocess debugging, so good luck there.
    
--*/

#ifndef  __XBOX_PROCESS__
#define  __XBOX_PROCESS__


// The exception list is tracked per process.  It contains a list of exceptions
// and how we respond to them.  When the process is initialized this list is populated
// from a static table.  After that,
typedef struct EXCEPTION_ITEM *PEXCEPTION_ITEM;
struct EXCEPTION_ITEM
{
    EXCEPTION_ITEM        *NextExceptionItem;
    EXCEPTION_DESCRIPTION Exception;
};

typedef std::deque<DMN_MODLOAD> DMN_MODULE_DEQUE;
typedef DMN_MODULE_DEQUE *PDMN_MODULE_DEQUE;

class CXboxProcess
{
  public:
    // Initialization and destructions
    static XOSD InitializeCXboxProcessClass();  //Global Initializer for 
    static XOSD Create(HPID hPid);
    XOSD Destroy();
    
    // Find a process from an HPID
    static CXboxProcess *GetProcess(HPID hPid);
    
    // Loading and Unloading Processes
    XOSD ProgramLoad(LPPROGLOAD pProgamLoadInfo);

    // Exceptions
    XOSD GetExceptionInfo(LPEXCMD pExceptionCommand, OUT EXCEPTION_DESCRIPTION *pExceptionDescriptionRet);
    static XOSD GetDefaultExceptionInfo(LPEXCMD pExceptionCommand, OUT EXCEPTION_DESCRIPTION *pExceptionDescriptionRet);
    
  private:
    
    // Private c'tor and d'tor force clients to use public create and destroy.
    CXboxProcess(HPID hPid) : m_hPid(hPid), m_pNextProcess(NULL), m_dwExecState(0), m_hPollThread(NULL),
                              m_dwPollThreadId(0), m_hTerminatePollingEvent(NULL),
                              m_pExceptionList(NULL), m_pDmNotificationSession(NULL), m_hRebootEvent(NULL),
                              m_hStartBreakPointEvent(NULL), m_tidMainThread(0), m_pvMainThreadStart(NULL){}
    ~CXboxProcess();
    XOSD InitializeAndInsertIntoProcessList();

    // Title\State Management
    HRESULT EnsurePendingExecState();
    HRESULT SetTitle(LPPROGLOAD pProgramLoadInfo);
    XOSD SynchronizeConnection(int dwReason);

    // Debug Events
    BOOL StartPollingThread();
    void StopPollingThread();
    DWORD PollingLoop();
    static unsigned __stdcall PollingLoopStub(void *pvProcess)
        {return reinterpret_cast<CXboxProcess *>(pvProcess)->PollingLoop();}

    // Notifications
    HRESULT EnsureOpenNotificationSession();
    HRESULT CloseNotificationSession();
    static DWORD __stdcall LaunchNotifications(ULONG dwNotification, DWORD dwParam);

    //
    //  Data members
    //
    HPID             m_hPid;
    CXboxProcess     *m_pNextProcess;
    DWORD            m_dwExecState;

    // Debug Events
    CDebugEventPump m_DebugEventPump;
    HANDLE          m_hPollThread;
    DWORD           m_dwPollThreadId;
    HANDLE          m_hTerminatePollingEvent;
    
    // Exception handling - including single step, and breakpoints
    PEXCEPTION_ITEM  m_pExceptionList;

    // Notifications
    PDMN_SESSION    m_pDmNotificationSession; // Notification Session Handle    
    HANDLE          m_hRebootEvent;           // Event to signal that an Xbox has rebooted (and is now in exec pending state).
    HANDLE          m_hStartBreakPointEvent;  // Event to signal that an Xbox has just stated a new process (after reboot).
    

    //Info About the Main Thread
    DWORD   m_tidMainThread;
    PVOID   m_pvMainThreadStart;

    //
    //  Static data members
    //
    static CRITICAL_SECTION  sm_CriticalSection; // One critical section for all processes.
    static CXboxProcess     *sm_pProcessList;    // List of currently known processes.
};




#endif  //__XBOX_PROCESS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\doids.h ===
/////////////////////////////////////////////////////////////////////////////
//  DOIDS.H
//      Header files containing Designer Object IDs.

#pragma once

//  Contains:
//      Help IDs

// Helpstring IDs -- Used with MSDEVDO.HLP

#define HID_DO_NAME	0x28001
//#define HID_DO_NAME	0x28002
#define HID_DO_Projects 0x28003
#define HID_DO_FILEDOITEMS 0x28004
#define HID_DO_Attributes_DEATH 0x28005
#define HID_DO_TYPE 0x28006
#define HID_DO_ACCESS 0x28007
#define HID_DO_MODULENAME 0x28008
#define HID_DO_Functions 0x28009
#define HID_DO_Typedefs 0x28010
#define HID_DO_Bases 0x28011
#define HID_DO_Maps 0x28012
#define HID_DO_Classes 0x28013
#define HID_DO_Variables 0x28014
#define HID_DO_Enums 0x28015
#define HID_DO_Constants 0x28016
#define HID_DO_Unions 0x28017
#define HID_DO_Interfaces 0x28018
#define HID_DO_EnumItems 0x28019
#define HID_DO_IBASES 0x28020
#define HID_DO_IFUNCTIONS 0x28021
#define HID_DO_MapItems 0x28022
#define HID_DO_Items 0x28022
#define HID_DO_Parameters 0x28023
#define HID_DO_Namespaces 0x28024
#define HID_DO_Macros 0x28025
#define HID_DO_Arguments 0x28026
#define HID_DO_VALUE 0x28027
#define HID_DO_ENABLED 0x28028
#define HID_DO_COMMENT 0x28029
#define HID_DO_Structs 0x28030
#define HID_DO_ImplementedInterfaces_DEATH 0x28031
#define HID_DO_Derived 0xFFFFF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\sources.inc ===
# sources.inc

# First, define some root variables for intra project references.
# By default, these are:
#
# VCROOT            $(SRC_ROOT)\vc
# PKG_ROOT          $(VCROOT)\pkgs
# LANGAPI_ROOT      $(VCROOT)\langapi
# APPWIZ_ROOT       $(VCROOT)\wizards\appwiz
# VC7		    VC7
# VCADDCLASS	    VCAddClass
# VCPACKAGES        VCPackages
# VCPROJECTITEMS    VCProjectItems
# VCWIZARDS         VCWizards
# VCPROJECTS        VCProjects
# VCCONTEXTITEMS    VCContextItems
#VCSERVERTEMPLATES	DesignerTemplates

BUILD_USING_VC7PDBS=1

!include $(VSROOT)\sources.inc

!ifndef VC7
VC7=VC7
!endif

!ifndef VCPACKAGES
VCPACKAGES=VCPackages
!endif

!ifndef VCPROJECTITEMS
VCPROJECTITEMS=VCProjectItems
!endif

!ifndef VCADDCLASS
VCADDCLASS=VCAddClass
!endif

!ifndef VCSERVERTEMPLATES
VCSERVERTEMPLATES=DesignerTemplates
!endif

!ifndef VCWIZARDS
VCWIZARDS=VCWizards
!endif

!ifndef VCPROJECTS
VCPROJECTS=VCProjects
!endif

!ifndef VCCONTEXTITEMS
VCCONTEXTITEMS=VCContextItems
!endif

!ifndef VCROOT
VCROOT=$(SRC_ROOT)\vc\ide
!endif

!ifndef PKG_ROOT
PKG_ROOT=$(VCROOT)\pkgs
!endif

!ifndef LANGAPI_ROOT
! ifdef LANGAPI
LANGAPI_ROOT=$(LANGAPI)
! else
LANGAPI_ROOT=$(SRC_ROOT)\vc\langapi
! endif
!endif

!ifndef APPWIZ_ROOT
APPWIZ_ROOT=$(VCROOT)\wizards\appwiz
!endif

!ifndef OSDEBUG4
OSDEBUG4=1
!endif

# turn on 32-bit types everywhere with one swell foop.
386_CPPFLAGS = -DCC_CVTYPE32 -DCC_LAZYTYPES

!ifndef DEBUGGER_BUILD
DEBUGGER_BUILD=1
!endif

USE_PDB=1
NTLEGO=1
USE_MSVCRT=1
NO_NTDLL=0

# Call Conventions

386_STDCALL=0 

!ifndef VC_INCLUDES
VC_INCLUDES=$(VCROOT)\include
!endif

!ifndef VC_PKG_INCLUDES
VC_PKG_INCLUDES=$(PKG_ROOT)\include
!endif

VC_INCLUDES=$(VC_INCLUDES);$(VC_PKG_INCLUDES)

# Turn on use of synchronous exception handling:
!ifndef NO_EH
USE_SYNCHRONOUS_EH=1
!endif

# Temporary: our current version of rc does not handle the -z switch
RCNOFONTMAP=1

# add $(VCROOT)\inc first on the path so that the .tlb imports in .idl files
# can be found without having to specify a relative path
PATH=$(VCROOT)\inc;$(PATH)

# no synchrounous error handling
NO_EH=0

# VC specific stuff
NOT_LEAN_AND_MEAN=1

COMPILER_WARNINGS=/FIwarning.h
USER_C_DEFINES=-D_WINDOWS -D_DBCS=1 -D_NTWIN -D_SUSHI -DCC_MULTIPLE_STORES=1 -D_TEST -DADDR_MIXED \
	-DCODEVIEW -DCONDITION_HANDLING -DCROSS_PLATFORM -DHOST32 -DHOST_i386 -Dx86 -D_MBCS -D_WINDLL \
	-D_ATL_STATIC_REGISTRY

!if 0
USER_C_DEFINES=/D_AFX_ENABLE_INLINES -DWIN32 -D_WINDOWS -D_USRDLL \
	-D_DBCS=1 -D_DLL=1 -D_MFC25 -D_MT=1 -D_NT1X_=100 -D_NTWIN -D_SUSHI \
	-D_TEST -D_WIN32_WINNT=0x0400 -D_X86_=1 -DADDR_MIXED -DCODEVIEW -DCONDITION_HANDLING=1  \
	-DCROSS_PLATFORM -DDBG=1 -DDEVL=1 -DFPO=0 -DHOST32 -DHOST_i386 -Di386=1 \
	-DNT_BUILD -DNT_INST=0 -DNT_UP=1 -DPPC_PLATFORM -DWIN32=100 \
	-DWINNT=1 -Dx86 -D_MBCS -D_WINDLL -D_AFXDLL
!endif

USER_C_DEFINES=$(USER_C_DEFINES) -DNEW_PROJBLD_TURNED_ON

!IF ("$(D)" == "d")
USER_C_DEFINES=$(USER_C_DEFINES) -D_DEBUG -DDEBUG=1
!ENDIF


#
# Reduce build warnings
#
CONDITIONAL_INCLUDES=\
    $(CONDITIONAL_INCLUDES) \
	afxcoll.h \
	afxcview.h \
	afxdllx.h \
	afxstr.h \
	atlbase.h \
	atlcoll.h \
	atlcom.h \
	atlctl.h \
	atlctrls.h \
	atldbcli.h \
	atldbsch.h \
	atlfile.h \
	atlhost.h \
	atlimage.h \
	atlimage.h \
	atlimpl.cpp \
	atlsafe.h \
	atlsoap.h \
	atlstr.h \
	atlsync.h \
	atlsync.inl \
	atltime.h \
	atltypes.h \
	atlwin.h \
	cstringt.h \
	macos\types.h \
	statreg.cpp \
	statreg.h \
	afxctl.h \
	shell.h \
	about.h \
	shell.hid \
	toolexpt.h \
	afxplex_.h \
	imeutil.h \
	barglob.h \
	imeutil.h \
	autowind.h \
	bardockx.h \
	docobfrm.h \
	docobvw.h \
	toolexpt.h \
	shellrec.h \
	ipcmpvw.h \
	shldocs_.h \
	imeutil.h \
	find.h \
	remi.h \
	bardockx.h \
	toolexpt.h \
	vcver.h \
	pkg.h \
	afxdlgs.h \
	mfcappwz.rc_ \
	afxdlgs.h \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\lexclass.h ===
//Do not include this file. Include <cppsvc.h> instead
// lexclass.h
// These are the token types that the lexer can give back to us
// They're separated out here so that you don't have to bring all the baggage
// of the lexer classes along with you if you want to analyze tokens

#pragma once

enum TOKCLS { // token classes
	tokclsError = 0,

	// all standard language keywords //1-0x17f
	tokclsKeyWordMin = 1,

	// for block start/end that are keywords instead of operators...like
	// Pascal or BASIC for instance.
	tokclsKeyWordOpenBlock = 0x17e,
	tokclsKeyWordCloseBlock = tokclsKeyWordOpenBlock+1,

	tokclsKeyWordMax = tokclsKeyWordCloseBlock+1, //0x180,

	// all language operators  //0x180-0x200
	tokclsOpMin = tokclsKeyWordMax,
	tokclsOpSpecOpenBlock = 0x1fe,
	tokclsOpSpecCloseBlock = tokclsOpSpecOpenBlock+1,
	tokclsOpMax = tokclsOpSpecCloseBlock+1, //0x200,

	// special, hard coded operators that editor keys off of
	tokclsOpSpecMin = 0x200,
	tokclsOpSpecEOL = 0x200,
	tokclsOpSpecLineCmt = 0x201, // automatic skip to eol on this one
	tokclsOpSpecEOS = 0x202,
	tokclsOpSpecMax = 0x210,

	// all identifiers, give ~500 possibilities
	tokclsIdentMin = 0x210,
	tokclsIdentUser = 0x211,	// special idents (user keywords)
	tokclsIdentMax = 0x400,

	// all constants (numeric and string)
	tokclsConstMin = 0x400,
	tokclsConstInteger = 0x400,
	tokclsConstReal = 0x401,
	tokclsConstString = 0x402,
	tokclsStringPart = 0x402,		// partial string ("....)
	tokclsConstMax = 0x410,

	// comments
	tokclsCommentMin = 0x500,
	tokclsCommentPart = 0x500,	// partial comment (/* ...)
	tokclsCommentMax = 0x510,

	// language dependent token class(es) start at 0x800 to 0xfff
	tokclsUserMin = 0x800,
	tokclsUserLast = 0xfff,
	tokclsUserMax = 0x1000,

	// mask to ignore all the bits in a token[class] that the lexer can use
	// for private status.	they will be masked off and ignored by clients
	// of the lexer.  A good use of this feature is to encode the real token
	// type in the lexer private portion (area is ~tokclsMask) when including
	// meta-token types (such as MFC/Wizard user token types) so that other
	// clients of the lexer can keep that information.
	tokclsUserMask = ~(tokclsUserMin - 1),
	tokclsMask = tokclsUserLast,

};

typedef int 	TOKEN;

// Alternate way of looking at a token, editor will only look at tokUser.
// Other clients of the lexer (like the parser or the EE) may want to look
// at the actual token in tokAct.  If any of tokAct is set, then it is expected
// that the actual token is different than the meta token it passed back.
// The status bits are only used by the lexer for whatever it wants.

union TOK_ALT  {
	TOKEN 	tok;
	struct {
        unsigned        tokUser : 12;
        unsigned        tokUserStatus : 4;
		unsigned		tokAct : 12;
		unsigned		tokActStatus : 4;
    };
};

// A text token block indicates the token, and its starting and ending 
// indexes in the line of source just lexed.
// Note that for any N > 0, rgtxtb[N].ibTokMin >= rgtxtb[N-1].ibTokMac.
// if it is such that rgtxtb[N].ibTokMin > rgtxtb[N-1].ibTokMac, then 
// the intervening unclassified characters are treated as white space tokens.
struct TXTB { // Text token class block
	TOKEN 	tok;
	UINT	ibTokMin;		// token length given by ibTokMac - ibTokMin
	UINT	ibTokMac;		// given in bytes
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\shell.c ===
#include <objbase.h>
#include <initguid.h>

#include "vsshell.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\makefile.inc ===
!include ..\makefile.inc

$(PASS0_HEADERDIR)\VCCodeModels.h : VCCodeModels.idl $(PASS0_TLBDIR)\DTE.tlb

$(PASS0_HEADERDIR)\VCWiz.h : VCWiz.idl $(PASS0_TLBDIR)\DTE.tlb

$(PASS0_HEADERDIR)\ProjBld2.h : ProjBld2.idl $(PASS0_TLBDIR)\DTE.tlb

$(VSBUILT)\$(BUILT_FLAVOR)\Inc\$(TARGET_DIRECTORY)\VCCodeModelsHelpID.h $(VSBUILT)\$(BUILT_FLAVOR)\Inc\$(TARGET_DIRECTORY)\VCCodeModelsHelpBS.h : VCCodeModelsHelp.id $(COMMON_ROOT)\idl\vs\vsext.id 
	@type VCCodeModelsHelp.id $(COMMON_ROOT)\idl\vs\vsext.id > tempid.id
	$(IDHEADER) tempid.id $(VSBUILT)\$(BUILT_FLAVOR)\Inc\$(TARGET_DIRECTORY)\VCCodeModelsHelpID.h $(VSBUILT)\$(BUILT_FLAVOR)\Inc\$(TARGET_DIRECTORY)\VCCodeModelsHelpBS.h $(O)
	@del tempid.id
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\bined.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:05 2002
 */
/* Compiler settings for bined.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_BinedPKGLib,0x373D3FB0,0xCD7B,0x11d0,0x92,0xDF,0x00,0xA0,0xC9,0x13,0x8C,0x45);


MIDL_DEFINE_GUID(CLSID, CLSID_VsBinedPackage,0x5B98C2C0,0xCD7B,0x11d0,0x92,0xDF,0x00,0xA0,0xC9,0x13,0x8C,0x45);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\cxxwiz.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:08 2002
 */
/* Compiler settings for cxxwiz.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IProvideCXXFramework,0xA1F72920,0x8E60,0x11d2,0xAF,0xF9,0x00,0xC0,0x4F,0x8E,0xE2,0x0F);


MIDL_DEFINE_GUID(IID, IID_IDescribeFunctions,0xA77A99A9,0x736D,0x11d2,0xAF,0xEA,0x00,0xC0,0x4F,0x8E,0xE2,0x0F);


MIDL_DEFINE_GUID(IID, IID_IGetSelectedDispatches,0xA77A99AB,0x736D,0x11d2,0xAF,0xEA,0x00,0xC0,0x4F,0x8E,0xE2,0x0F);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\macropicker.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:15 2002
 */
/* Compiler settings for macropicker.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IVCMacroPicker,0x04A9645F,0xD651,0x4FB2,0xB6,0x14,0xD2,0x21,0xE0,0x4A,0xE6,0x11);


MIDL_DEFINE_GUID(IID, LIBID_MacroPickerLib,0x8EBB1B99,0x9F5A,0x4F7B,0xAA,0x2F,0xF4,0x25,0x0A,0x60,0xFF,0xFF);


MIDL_DEFINE_GUID(CLSID, CLSID_VCMacroPicker,0x3781071C,0x736B,0x4121,0xB7,0xCE,0xCE,0x7B,0x7E,0xED,0x64,0x9D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\exposed.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:13 2002
 */
/* Compiler settings for exposed.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IUtProjProp,0xA15B0D66,0x701C,0x11D1,0x82,0xE8,0x00,0xA0,0xC9,0x1B,0xC9,0x42);


MIDL_DEFINE_GUID(IID, LIBID_ExposedLib,0x9ED2C960,0x9A56,0x11D0,0xA4,0xE9,0x00,0xA0,0xC9,0x0A,0x63,0x33);


MIDL_DEFINE_GUID(CLSID, CLSID_UtProjProp,0xA15B0D66,0x701C,0x11D1,0x82,0xE8,0x00,0xA0,0xC9,0x1B,0xC9,0x43);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\cppsvc.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:09 2002
 */
/* Compiler settings for cppsvc.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IVCTextEdit,0x7861af6a,0x415a,0x11d3,0x8b,0x7e,0x00,0xc0,0x4f,0x79,0x84,0xea);


MIDL_DEFINE_GUID(IID, LIBID_CPPServicesLib,0x7861af6c,0x415a,0x11d3,0x8b,0x7e,0x00,0xc0,0x4f,0x79,0x84,0xea);


MIDL_DEFINE_GUID(CLSID, CLSID_CPPLangPackage,0x8c2ea640,0xabc1,0x11d0,0x9d,0x62,0x00,0xc0,0x4f,0xd9,0xdf,0xd9);


MIDL_DEFINE_GUID(CLSID, CLSID_CPPLangService,0xb2f072b2,0xabc1,0x11d0,0x9d,0x62,0x00,0xc0,0x4f,0xd9,0xdf,0xd9);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\dbsvc.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:11 2002
 */
/* Compiler settings for dbsvc.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDBCodeGenerator,0xCE593DD4,0xDE4D,0x11D2,0x92,0xFC,0x00,0xC0,0x4F,0xB9,0x86,0x64);


MIDL_DEFINE_GUID(IID, LIBID_DBServicesLib,0x76b2c9a8,0xe181,0x11d2,0x92,0xfc,0x00,0xc0,0x4f,0xb9,0x86,0x64);


MIDL_DEFINE_GUID(CLSID, CLSID_DBServicesPackage,0xda2110fe,0xdcad,0x11d2,0x92,0xfb,0x00,0xc0,0x4f,0xb9,0x86,0x64);


MIDL_DEFINE_GUID(CLSID, CLSID_ATL_ConsumerAttributesCG,0xbe9eb0a2,0xe162,0x11d2,0x92,0xfc,0x00,0xc0,0x4f,0xb9,0x86,0x64);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\ProjBld2.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:16 2002
 */
/* Compiler settings for ProjBld2.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IVCBuildOptionsPage,0x9F367026,0x33C6,0x11D3,0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB7);


MIDL_DEFINE_GUID(IID, IID_VCProjectConfigurationProperties,0x24DAA1C6,0x298A,0x4320,0xBC,0x4B,0xC3,0x6B,0x3F,0x25,0x9E,0x40);


MIDL_DEFINE_GUID(IID, IID_VCFileConfigurationProperties,0x24DAA1C7,0x298A,0x4320,0xBC,0x4B,0xC3,0x6B,0x3F,0x25,0x9E,0x40);


MIDL_DEFINE_GUID(IID, LIBID_VCProjectLibrary,0xF1C25856,0x3097,0x11D2,0xA5,0xC5,0x00,0xC0,0x4F,0x79,0x68,0xB4);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\projbldprivate.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:18 2002
 */
/* Compiler settings for projbldprivate.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IVCCfg,0x694C76BC,0x3EF4,0x11d3,0xB2,0x78,0x00,0x50,0x04,0x1D,0xB1,0x2A);


MIDL_DEFINE_GUID(IID, IID_File,0x2D5D650E,0x3E0D,0x11d3,0x94,0x15,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(IID, IID_Filter,0x2111B8B8,0x4150,0x11d3,0x94,0x16,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(IID, IID__VCProject,0x2111B8BA,0x4150,0x11d3,0x94,0x16,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(IID, LIBID_VCPrivateProjectLibrary,0xBD4E85FC,0xEC6B,0x4c87,0xA1,0x5D,0x8C,0xA3,0xAA,0x55,0x93,0xFF);


MIDL_DEFINE_GUID(CLSID, CLSID_FileNodeProps,0x2D5D650F,0x3E0D,0x11d3,0x94,0x15,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_FolderNodeProps,0x2111B8B9,0x4150,0x11d3,0x94,0x16,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_ProjectNodeProps,0x2111B8BB,0x4150,0x11d3,0x94,0x16,0x00,0xC0,0x4F,0x68,0xFB,0x62);


MIDL_DEFINE_GUID(CLSID, CLSID_BuildPackage,0xF1C25864,0x3097,0x11D2,0xA5,0xC5,0x00,0xC0,0x4F,0x79,0x68,0xB4);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\vc.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:34 2002
 */
/* Compiler settings for vc.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IVCPackage_DEATH,0x64BA8A6F,0xA7CC,0x11D0,0xA4,0xEE,0x00,0xA0,0xC9,0x0A,0x63,0x32);


MIDL_DEFINE_GUID(IID, IID_IVCNotificationEvents,0x95307AC1,0xDBAF,0x11d0,0x92,0xE2,0x00,0xA0,0xC9,0x13,0x8C,0x45);


MIDL_DEFINE_GUID(IID, IID_IVCNotificationSource,0x95307AC0,0xDBAF,0x11d0,0x92,0xE2,0x00,0xA0,0xC9,0x13,0x8C,0x45);


MIDL_DEFINE_GUID(IID, LIBID_VCLib,0x64BA8A62,0xA7CC,0x11D0,0xA4,0xEE,0x00,0xA0,0xC9,0x0A,0x63,0x32);


MIDL_DEFINE_GUID(CLSID, CLSID_VCPackage,0x1B027A40,0x8F43,0x11D0,0x8D,0x11,0x00,0xA0,0xC9,0x1B,0xC9,0x42);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\VCCodeModels.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:39 2002
 */
/* Compiler settings for VCCodeModels.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICompiler,0x64626784,0x83F5,0x11d2,0xB8,0xDA,0x00,0xC0,0x4F,0x79,0x9B,0xBB);


MIDL_DEFINE_GUID(IID, IID_IAttributeGrammar,0x64626787,0x83F5,0x11d2,0xB8,0xDA,0x00,0xC0,0x4F,0x79,0x9B,0xBB);


MIDL_DEFINE_GUID(IID, IID_IAttributeHandler,0x64626786,0x83F5,0x11d2,0xB8,0xDA,0x00,0xC0,0x4F,0x79,0x9B,0xBB);


MIDL_DEFINE_GUID(IID, IID_ICOMProvider,0x70F8DB53,0xED01,0x11D1,0xBF,0xB7,0x00,0x00,0xF8,0x07,0x61,0x52);


MIDL_DEFINE_GUID(CLSID, CLSID_COMProvider,0x70F8DB54,0xED01,0x11D1,0xBF,0xB7,0x00,0x00,0xF8,0x07,0x61,0x52);


MIDL_DEFINE_GUID(IID, IID_IAttrMerge,0xc7585aec,0x42d2,0x11d2,0xaa,0x76,0x00,0xc0,0x4f,0x99,0x01,0x80);


MIDL_DEFINE_GUID(CLSID, CLSID_AttrMerge,0xa2c9ed4a,0x42d1,0x11d2,0xaa,0x76,0x00,0xc0,0x4f,0x99,0x01,0x80);


MIDL_DEFINE_GUID(IID, LIBID_VCCodeModelLibrary,0x57D97102,0x7F20,0x11d1,0xB2,0x9E,0x00,0x40,0x05,0x30,0x89,0xAE);


MIDL_DEFINE_GUID(IID, IID_VCCodeModel,0x29BF7889,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeAttribute,0x29BF783D,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeBase,0x29BF7846,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeClass,0x29BF7849,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeEnum,0x29BF784C,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeInterface,0x29BF7852,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeMacro,0x29BF7855,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeMap,0x29BF7858,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeMapEntry,0x29BF785B,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeFunction,0x29BF785E,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeNamespace,0x29BF7861,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeParameter,0x29BF7864,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeStruct,0x29BF7867,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeTypedef,0x29BF786A,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeUnion,0x29BF786D,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeVariable,0x29BF7870,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeInclude,0x29BF788A,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeImport,0x29BF788D,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeUsing,0x29BF7890,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeIDLImport,0x29BF7893,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeIDLImportLib,0x29BF7896,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeIDLCoClass,0x29BF7899,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeIDLLibrary,0x29BF789C,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeDelegate,0x211F5FCD,0xB7FE,0x4983,0x86,0x16,0x8D,0xA6,0x98,0x88,0x18,0x79);


MIDL_DEFINE_GUID(IID, IID_VCCodeProperty,0x211F5FCE,0xB7FE,0x4983,0x86,0x16,0x8D,0xA6,0x98,0x88,0x18,0x79);


MIDL_DEFINE_GUID(IID, IID_VCCodeEvent,0x211F5FCF,0xB7FE,0x4983,0x86,0x16,0x8D,0xA6,0x98,0x88,0x18,0x79);


MIDL_DEFINE_GUID(IID, IID_VCLanguageManager,0x852E2929,0x8F57,0x41c1,0x8D,0x44,0x7A,0xDC,0xB6,0x22,0xF2,0x39);


MIDL_DEFINE_GUID(IID, IID_VCDesignElement,0xFEBEA835,0x1F65,0x4ff2,0x80,0x9A,0xF6,0x11,0x16,0x11,0x9A,0x81);


MIDL_DEFINE_GUID(IID, IID_VCDesignElements,0xFEBEA836,0x1F65,0x4ff2,0x80,0x9A,0xF6,0x11,0x16,0x11,0x9A,0x81);


MIDL_DEFINE_GUID(IID, IID_VCCodeElement,0x29BF7873,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCCodeElements,0x29BF7888,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x55);


MIDL_DEFINE_GUID(IID, IID_VCFileCodeModel,0x29BF7889,0xFE8C,0x11d2,0xAA,0xE9,0x00,0xC0,0x4F,0x72,0xDB,0x56);


MIDL_DEFINE_GUID(CLSID, CLSID_CodeModelEvents,0x0CFBC2D1,0x0D4E,0x11D3,0x89,0x97,0x00,0xC0,0x4F,0x68,0x8D,0xDE);


MIDL_DEFINE_GUID(IID, IID__CodeModelEvents,0x0CFBC2D3,0x0D4E,0x11D3,0x89,0x97,0x00,0xC0,0x4F,0x68,0x8D,0xDE);


MIDL_DEFINE_GUID(IID, IID_VCDialogExtender,0xBC691AF0,0x4C32,0x404B,0x8A,0x73,0xA7,0x5B,0x99,0xBD,0x1D,0x50);


MIDL_DEFINE_GUID(IID, IID_MFCDialogVariableExtender,0xBC691AF1,0x4C32,0x404B,0x8A,0x73,0xA7,0x5B,0x99,0xBD,0x1D,0x50);


MIDL_DEFINE_GUID(IID, IID_MFCDialogStringVariableExtender,0xBC691AF2,0x4C32,0x404B,0x8A,0x73,0xA7,0x5B,0x99,0xBD,0x1D,0x50);


MIDL_DEFINE_GUID(IID, IID_MFCDialogNumberVariableExtender,0xBC691AF3,0x4C32,0x404B,0x8A,0x73,0xA7,0x5B,0x99,0xBD,0x1D,0x50);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\idl\obj\i386\respkg.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon Apr 29 23:14:31 2002
 */
/* Compiler settings for respkg.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_ResEditPKGLib,0x74AAD8B0,0x3294,0x49CB,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_ICommon,0x3B494597,0x84EE,0x11D2,0x86,0x00,0x00,0xC0,0x4F,0x8E,0xCE,0xE1);


MIDL_DEFINE_GUID(IID, DIID__ICommonEvents,0x74AAD8B4,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_Common,0x3B494598,0x84EE,0x11D2,0x86,0x00,0x00,0xC0,0x4F,0x8E,0xCE,0xE1);


MIDL_DEFINE_GUID(IID, IID_VCResourceHelper,0x74AAD8B1,0x3294,0x49CB,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_VsResEditPackage,0x74AAD8B2,0x3294,0x49CB,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_ResPropPages,0x74AAD8B3,0x3294,0x49CB,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IDlgEditor,0x74AAD801,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IDlgEditorEvents,0x74AAD802,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IPictEditor,0x74AAD803,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_DlgEditor,0x74AAD804,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_DlgEdFont,0x74AAD805,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IPictEditorEvents,0x74AAD806,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_PictEditor,0x74AAD807,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IStatEditor,0x74AAD808,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, DIID__IStatEditorEvents,0x74AAD809,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(CLSID, CLSID_StatEditor,0x74AAD80A,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


MIDL_DEFINE_GUID(IID, IID_IEdBoxEditor,0x74AAD80B,0x3294,0x49cb,0xBB,0x5D,0xE9,0xBA,0xB1,0x32,0xBF,0xD5);


