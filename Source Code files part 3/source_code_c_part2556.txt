));
         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max *
            sizeof(png_text)));
         png_free(png_ptr, old_text);
      }
      else
      {
         info_ptr->max_text = num_text + 8;
         info_ptr->num_text = 0;
         info_ptr->text = (png_textp)png_malloc(png_ptr,
            (png_uint_32)(info_ptr->max_text * sizeof (png_text)));
      }
      png_debug1(3, "allocated %d entries for info_ptr->text\n",
         info_ptr->max_text);
   }

   for (i = 0; i < num_text; i++)
   {
      png_textp textp = &(info_ptr->text[info_ptr->num_text]);

      if (text_ptr[i].text == NULL)
         text_ptr[i].text = (png_charp)"";

      if (text_ptr[i].text[0] == '\0')
      {
         textp->text_length = 0;
         textp->compression = PNG_TEXT_COMPRESSION_NONE;
      }
      else
      {
         textp->text_length = png_strlen(text_ptr[i].text);
         textp->compression = text_ptr[i].compression;
      }
      textp->text = text_ptr[i].text;
      textp->key = text_ptr[i].key;
      info_ptr->num_text++;
      png_debug1(3, "transferred text chunk %d\n", info_ptr->num_text);
   }
}
#endif

#if defined(PNG_READ_tIME_SUPPORTED) || defined(PNG_WRITE_tIME_SUPPORTED)
void
png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep mod_time)
{
   png_debug1(1, "in %s storage function\n", "tIME");
   if (png_ptr == NULL || info_ptr == NULL ||
       (png_ptr->flags & PNG_FLAG_WROTE_tIME))
      return;

   png_memcpy(&(info_ptr->mod_time), mod_time, sizeof (png_time));
   info_ptr->valid |= PNG_INFO_tIME;
}
#endif

#if defined(PNG_READ_tRNS_SUPPORTED) || defined(PNG_WRITE_tRNS_SUPPORTED)
void
png_set_tRNS(png_structp png_ptr, png_infop info_ptr,
   png_bytep trans, int num_trans, png_color_16p trans_values)
{
   png_debug1(1, "in %s storage function\n", "tRNS");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if (trans != NULL)
   {
      info_ptr->trans = trans;
   }

   if (trans_values != NULL)
   {
      png_memcpy(&(info_ptr->trans_values), trans_values,
         sizeof(png_color_16));
      if (num_trans == 0)
        num_trans = 1;
   }
   info_ptr->num_trans = (png_uint_16)num_trans;
   info_ptr->valid |= PNG_INFO_tRNS;
}
#endif

#if defined(PNG_READ_EMPTY_PLTE_SUPPORTED)
void
png_permit_empty_plte (png_structp png_ptr, int empty_plte_permitted)
{
   png_debug1(1, "in png_permit_empty_plte\n", "");
   if (png_ptr == NULL)
      return;
   png_ptr->empty_plte_permitted=(png_byte)empty_plte_permitted;
}
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\pngrutil.cpp ===
/* pngrutil.c - utilities to read a PNG file
 *
 * libpng 1.0.5 - October 15, 1999
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
 * Copyright (c) 1996, 1997 Andreas Dilger
 * Copyright (c) 1998, 1999 Glenn Randers-Pehrson
 *
 * This file contains routines that are only called from within
 * libpng itself during the course of reading an image.
 */

#define PNG_INTERNAL
#include "png.h"

namespace D3DX
{


#ifdef PNG_ASSEMBLER_CODE_SUPPORTED
#include "pngasmrd.h"
#endif

#ifndef PNG_READ_BIG_ENDIAN_SUPPORTED
/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
png_uint_32
png_get_uint_32(png_bytep buf)
{
   png_uint_32 i = ((png_uint_32)(*buf) << 24) +
      ((png_uint_32)(*(buf + 1)) << 16) +
      ((png_uint_32)(*(buf + 2)) << 8) +
      (png_uint_32)(*(buf + 3));

   return (i);
}

#if defined(PNG_READ_pCAL_SUPPORTED)
/* Grab a signed 32-bit integer from a buffer in big-endian format.  The
 * data is stored in the PNG file in two's complement format, and it is
 * assumed that the machine format for signed integers is the same. */
png_int_32
png_get_int_32(png_bytep buf)
{
   png_int_32 i = ((png_int_32)(*buf) << 24) +
      ((png_int_32)(*(buf + 1)) << 16) +
      ((png_int_32)(*(buf + 2)) << 8) +
      (png_int_32)(*(buf + 3));

   return (i);
}
#endif /* PNG_READ_pCAL_SUPPORTED */

/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */
png_uint_16
png_get_uint_16(png_bytep buf)
{
   png_uint_16 i = (png_uint_16)(((png_uint_16)(*buf) << 8) +
      (png_uint_16)(*(buf + 1)));

   return (i);
}
#endif /* PNG_READ_BIG_ENDIAN_SUPPORTED */

/* Read data, and (optionally) run it through the CRC. */
void
png_crc_read(png_structp png_ptr, png_bytep buf, png_size_t length)
{
   png_read_data(png_ptr, buf, length);
   png_calculate_crc(png_ptr, buf, length);
}

/* Optionally skip data and then check the CRC.  Depending on whether we
   are reading a ancillary or critical chunk, and how the program has set
   things up, we may calculate the CRC on the data and print a message.
   Returns '1' if there was a CRC error, '0' otherwise. */
int
png_crc_finish(png_structp png_ptr, png_uint_32 skip)
{
   png_size_t i;
   png_size_t istop = png_ptr->zbuf_size;

   for (i = (png_size_t)skip; i > istop; i -= istop)
   {
      png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
   }
   if (i)
   {
      png_crc_read(png_ptr, png_ptr->zbuf, i);
   }

   if (png_crc_error(png_ptr))
   {
      if ((png_ptr->chunk_name[0] & 0x20 &&                /* Ancillary */
           !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)) ||
          (!(png_ptr->chunk_name[0] & 0x20) &&             /* Critical  */
           png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE))
      {
         png_chunk_warning(png_ptr, "CRC error");
      }
      else
      {
         png_chunk_error(png_ptr, "CRC error");
      }
      return (1);
   }

   return (0);
}

/* Compare the CRC stored in the PNG file with that calculated by libpng from
   the data it has read thus far. */
int
png_crc_error(png_structp png_ptr)
{
   png_byte crc_bytes[4];
   png_uint_32 crc;
   int need_crc = 1;

   if (png_ptr->chunk_name[0] & 0x20)                     /* ancillary */
   {
      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
         need_crc = 0;
   }
   else                                                    /* critical */
   {
      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
         need_crc = 0;
   }

   png_read_data(png_ptr, crc_bytes, 4);

   if (need_crc)
   {
      crc = png_get_uint_32(crc_bytes);
      return ((int)(crc != png_ptr->crc));
   }
   else
      return (0);
}


/* read and check the IDHR chunk */
void
png_handle_IHDR(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[13];
   png_uint_32 width, height;
   int bit_depth, color_type, compression_type, filter_type;
   int interlace_type;

   png_debug(1, "in png_handle_IHDR\n");

   if (png_ptr->mode != PNG_BEFORE_IHDR)
      png_error(png_ptr, "Out of place IHDR");

   /* check the length */
   if (length != 13)
      png_error(png_ptr, "Invalid IHDR chunk");

   png_ptr->mode |= PNG_HAVE_IHDR;

   png_crc_read(png_ptr, buf, 13);
   png_crc_finish(png_ptr, 0);

   width = png_get_uint_32(buf);
   height = png_get_uint_32(buf + 4);
   bit_depth = buf[8];
   color_type = buf[9];
   compression_type = buf[10];
   filter_type = buf[11];
   interlace_type = buf[12];

   /* check for width and height valid values */
   if (width == 0 || width > PNG_MAX_UINT || height == 0 ||
        height > PNG_MAX_UINT)
      png_error(png_ptr, "Invalid image size in IHDR");

   /* check other values */
   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&
      bit_depth != 8 && bit_depth != 16)
      png_error(png_ptr, "Invalid bit depth in IHDR");

   if (color_type < 0 || color_type == 1 ||
      color_type == 5 || color_type > 6)
      png_error(png_ptr, "Invalid color type in IHDR");

   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||
       ((color_type == PNG_COLOR_TYPE_RGB ||
         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))
      png_error(png_ptr, "Invalid color type/bit depth combination in IHDR");

   if (interlace_type >= PNG_INTERLACE_LAST)
      png_error(png_ptr, "Unknown interlace method in IHDR");

   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
      png_error(png_ptr, "Unknown compression method in IHDR");

   if (filter_type != PNG_FILTER_TYPE_BASE)
      png_error(png_ptr, "Unknown filter method in IHDR");

   /* set internal variables */
   png_ptr->width = width;
   png_ptr->height = height;
   png_ptr->bit_depth = (png_byte)bit_depth;
   png_ptr->interlaced = (png_byte)interlace_type;
   png_ptr->color_type = (png_byte)color_type;

   /* find number of channels */
   switch (png_ptr->color_type)
   {
      case PNG_COLOR_TYPE_GRAY:
      case PNG_COLOR_TYPE_PALETTE:
         png_ptr->channels = 1;
         break;
      case PNG_COLOR_TYPE_RGB:
         png_ptr->channels = 3;
         break;
      case PNG_COLOR_TYPE_GRAY_ALPHA:
         png_ptr->channels = 2;
         break;
      case PNG_COLOR_TYPE_RGB_ALPHA:
         png_ptr->channels = 4;
         break;
   }

   /* set up other useful info */
   png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth *
   png_ptr->channels);
   png_ptr->rowbytes = ((png_ptr->width *
      (png_uint_32)png_ptr->pixel_depth + 7) >> 3);
   png_debug1(3,"bit_depth = %d\n", png_ptr->bit_depth);
   png_debug1(3,"channels = %d\n", png_ptr->channels);
   png_debug1(3,"rowbytes = %d\n", png_ptr->rowbytes);
   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,
      color_type, interlace_type, compression_type, filter_type);
}

/* read and check the palette */
void
png_handle_PLTE(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_colorp palette;
   int num, i;

   png_debug(1, "in png_handle_PLTE\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before PLTE");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid PLTE after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      png_error(png_ptr, "Duplicate PLTE chunk");

   png_ptr->mode |= PNG_HAVE_PLTE;

#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
   if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
   {
      png_crc_finish(png_ptr, length);
      return;
   }
#endif

   if (length % 3)
   {
      if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
      {
         png_warning(png_ptr, "Invalid palette chunk");
         png_crc_finish(png_ptr, length);
         return;
      }
      else
      {
         png_error(png_ptr, "Invalid palette chunk");
      }
   }

   num = (int)length / 3;
   palette = (png_colorp)png_zalloc(png_ptr, (uInt)num, sizeof (png_color));
   png_ptr->flags |= PNG_FLAG_FREE_PALETTE;
   for (i = 0; i < num; i++)
   {
      png_byte buf[3];

      png_crc_read(png_ptr, buf, 3);
      /* don't depend upon png_color being any order */
      palette[i].red = buf[0];
      palette[i].green = buf[1];
      palette[i].blue = buf[2];
   }

   /* If we actually NEED the PLTE chunk (ie for a paletted image), we do
      whatever the normal CRC configuration tells us.  However, if we
      have an RGB image, the PLTE can be considered ancillary, so
      we will act as though it is. */
#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
#endif
   {
      png_crc_finish(png_ptr, 0);
   }
#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
   else if (png_crc_error(png_ptr))  /* Only if we have a CRC error */
   {
      /* If we don't want to use the data from an ancillary chunk,
         we have two options: an error abort, or a warning and we
         ignore the data in this chunk (which should be OK, since
         it's considered ancillary for a RGB or RGBA image). */
      if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE))
      {
         if (png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)
         {
            png_chunk_error(png_ptr, "CRC error");
         }
         else
         {
            png_chunk_warning(png_ptr, "CRC error");
            png_ptr->flags &= ~PNG_FLAG_FREE_PALETTE;
            png_zfree(png_ptr, palette);
            return;
         }
      }
      /* Otherwise, we (optionally) emit a warning and use the chunk. */
      else if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN))
      {
         png_chunk_warning(png_ptr, "CRC error");
      }
   }
#endif
   png_ptr->palette = palette;
   png_ptr->num_palette = (png_uint_16)num;
   png_set_PLTE(png_ptr, info_ptr, palette, num);

#if defined (PNG_READ_tRNS_SUPPORTED)
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (info_ptr != NULL && info_ptr->valid & PNG_INFO_tRNS)
      {
         if (png_ptr->num_trans > png_ptr->num_palette)
         {
            png_warning(png_ptr, "Truncating incorrect tRNS chunk length");
            png_ptr->num_trans = png_ptr->num_palette;
         }
      }
   }
#endif

}

void
png_handle_IEND(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_debug(1, "in png_handle_IEND\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR) || !(png_ptr->mode & PNG_HAVE_IDAT))
   {
      png_error(png_ptr, "No image in file");

      /* to quiet compiler warnings about unused info_ptr */
      if (info_ptr == NULL)
         return;
   }

   png_ptr->mode |= PNG_AFTER_IDAT | PNG_HAVE_IEND;

   if (length != 0)
   {
      png_warning(png_ptr, "Incorrect IEND chunk length");
   }
   png_crc_finish(png_ptr, length);
}

#if defined(PNG_READ_gAMA_SUPPORTED)
void
png_handle_gAMA(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_uint_32 igamma;
   float file_gamma;
   png_byte buf[4];

   png_debug(1, "in png_handle_gAMA\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before gAMA");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid gAMA after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Out of place gAMA chunk");

   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_gAMA
#if defined(PNG_READ_sRGB_SUPPORTED)
      && !(info_ptr->valid & PNG_INFO_sRGB)
#endif
      )
   {
      png_warning(png_ptr, "Duplicate gAMA chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 4)
   {
      png_warning(png_ptr, "Incorrect gAMA chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 4);
   if (png_crc_finish(png_ptr, 0))
      return;

   igamma = png_get_uint_32(buf);
   /* check for zero gamma */
   if (igamma == 0)
      return;

#if defined(PNG_READ_sRGB_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_sRGB)
      if(fabs((float)igamma - 45455.)>500.)
      {
         png_warning(png_ptr,
           "Ignoring incorrect gAMA value when sRGB is also present");
#ifndef PNG_NO_CONSOLE_IO
         fprintf(stderr, "igamma = %lu\n", igamma);
#endif
         return;
      }
#endif /* PNG_READ_sRGB_SUPPORTED */

   file_gamma = (float)igamma / (float)100000.0;
#ifdef PNG_READ_GAMMA_SUPPORTED
   png_ptr->gamma = file_gamma;
#endif
   png_set_gAMA(png_ptr, info_ptr, file_gamma);
}
#endif

#if defined(PNG_READ_sBIT_SUPPORTED)
void
png_handle_sBIT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_size_t truelen;
   png_byte buf[4];

   png_debug(1, "in png_handle_sBIT\n");

   buf[0] = buf[1] = buf[2] = buf[3] = 0;

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before sBIT");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid sBIT after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
   {
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Out of place sBIT chunk");
   }
   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_sBIT)
   {
      png_warning(png_ptr, "Duplicate sBIT chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      truelen = 3;
   else
      truelen = (png_size_t)png_ptr->channels;

   if (length != truelen)
   {
      png_warning(png_ptr, "Incorrect sBIT chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, truelen);
   if (png_crc_finish(png_ptr, 0))
      return;

   if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
   {
      png_ptr->sig_bit.red = buf[0];
      png_ptr->sig_bit.green = buf[1];
      png_ptr->sig_bit.blue = buf[2];
      png_ptr->sig_bit.alpha = buf[3];
   }
   else
   {
      png_ptr->sig_bit.gray = buf[0];
      png_ptr->sig_bit.red = buf[0];
      png_ptr->sig_bit.green = buf[0];
      png_ptr->sig_bit.blue = buf[0];
      png_ptr->sig_bit.alpha = buf[1];
   }
   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));
}
#endif

#if defined(PNG_READ_cHRM_SUPPORTED)
void
png_handle_cHRM(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[4];
   png_uint_32 val;
   float white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;

   png_debug(1, "in png_handle_cHRM\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before sBIT");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid cHRM after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Missing PLTE before cHRM");

   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_cHRM
#if defined(PNG_READ_sRGB_SUPPORTED)
      && !(info_ptr->valid & PNG_INFO_sRGB)
#endif
      )
   {
      png_warning(png_ptr, "Duplicate cHRM chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 32)
   {
      png_warning(png_ptr, "Incorrect cHRM chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 4);
   val = png_get_uint_32(buf);
   white_x = (float)val / (float)100000.0;

   png_crc_read(png_ptr, buf, 4);
   val = png_get_uint_32(buf);
   white_y = (float)val / (float)100000.0;

   if (white_x < 0 || white_x > 0.8 || white_y < 0 || white_y > 0.8 ||
       white_x + white_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM white point");
      png_crc_finish(png_ptr, 24);
      return;
   }

   png_crc_read(png_ptr, buf, 4);
   val = png_get_uint_32(buf);
   red_x = (float)val / (float)100000.0;

   png_crc_read(png_ptr, buf, 4);
   val = png_get_uint_32(buf);
   red_y = (float)val / (float)100000.0;

   if (red_x < 0 || red_x > 0.8 || red_y < 0 || red_y > 0.8 ||
       red_x + red_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM red point");
      png_crc_finish(png_ptr, 16);
      return;
   }

   png_crc_read(png_ptr, buf, 4);
   val = png_get_uint_32(buf);
   green_x = (float)val / (float)100000.0;

   png_crc_read(png_ptr, buf, 4);
   val = png_get_uint_32(buf);
   green_y = (float)val / (float)100000.0;

   if (green_x < 0 || green_x > 0.8 || green_y < 0 || green_y > 0.8 ||
       green_x + green_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM green point");
      png_crc_finish(png_ptr, 8);
      return;
   }

   png_crc_read(png_ptr, buf, 4);
   val = png_get_uint_32(buf);
   blue_x = (float)val / (float)100000.0;

   png_crc_read(png_ptr, buf, 4);
   val = png_get_uint_32(buf);
   blue_y = (float)val / (float)100000.0;

   if (blue_x < (float)0 || blue_x > (float)0.8 || blue_y < (float)0 ||
       blue_y > (float)0.8 || blue_x + blue_y > (float)1.0)
   {
      png_warning(png_ptr, "Invalid cHRM blue point");
      png_crc_finish(png_ptr, 0);
      return;
   }

   if (png_crc_finish(png_ptr, 0))
      return;

#if defined(PNG_READ_sRGB_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_sRGB)
      {
      if (fabs(white_x - (float).3127) > (float).001 ||
          fabs(white_y - (float).3290) > (float).001 ||
          fabs(  red_x - (float).6400) > (float).001 ||
          fabs(  red_y - (float).3300) > (float).001 ||
          fabs(green_x - (float).3000) > (float).001 ||
          fabs(green_y - (float).6000) > (float).001 ||
          fabs( blue_x - (float).1500) > (float).001 ||
          fabs( blue_y - (float).0600) > (float).001)
         {

            png_warning(png_ptr,
              "Ignoring incorrect cHRM value when sRGB is also present");
#ifndef PNG_NO_CONSOLE_IO
            fprintf(stderr,"wx=%f, wy=%f, rx=%f, ry=%f\n",
               white_x, white_y, red_x, red_y);
            fprintf(stderr,"gx=%f, gy=%f, bx=%f, by=%f\n",
               green_x, green_y, blue_x, blue_y);
#endif
         }
         return;
      }
#endif /* PNG_READ_sRGB_SUPPORTED */

   png_set_cHRM(png_ptr, info_ptr,
      white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
}
#endif

#if defined(PNG_READ_sRGB_SUPPORTED)
void
png_handle_sRGB(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   int intent;
   png_byte buf[1];

   png_debug(1, "in png_handle_sRGB\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before sRGB");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid sRGB after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Out of place sRGB chunk");

   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_sRGB)
   {
      png_warning(png_ptr, "Duplicate sRGB chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 1)
   {
      png_warning(png_ptr, "Incorrect sRGB chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 1);
   if (png_crc_finish(png_ptr, 0))
      return;

   intent = buf[0];
   /* check for bad intent */
   if (intent >= PNG_sRGB_INTENT_LAST)
   {
      png_warning(png_ptr, "Unknown sRGB intent");
      return;
   }

#if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_READ_GAMMA_SUPPORTED)
   if ((info_ptr->valid & PNG_INFO_gAMA))
      if(fabs((png_ptr->gamma*(float)100000.+.5)-45455.) > 500.)
      {
         png_warning(png_ptr,
           "Ignoring incorrect gAMA value when sRGB is also present");
#ifndef PNG_NO_CONSOLE_IO
           fprintf(stderr,"gamma=%f\n",png_ptr->gamma);
#endif
      }
#endif /* PNG_READ_gAMA_SUPPORTED */

#ifdef PNG_READ_cHRM_SUPPORTED
   if (info_ptr->valid & PNG_INFO_cHRM)
      if (fabs(info_ptr->x_white - (float).3127) > (float).001 ||
          fabs(info_ptr->y_white - (float).3290) > (float).001 ||
          fabs(  info_ptr->x_red - (float).6400) > (float).001 ||
          fabs(  info_ptr->y_red - (float).3300) > (float).001 ||
          fabs(info_ptr->x_green - (float).3000) > (float).001 ||
          fabs(info_ptr->y_green - (float).6000) > (float).001 ||
          fabs( info_ptr->x_blue - (float).1500) > (float).001 ||
          fabs( info_ptr->y_blue - (float).0600) > (float).001)
         {
            png_warning(png_ptr,
              "Ignoring incorrect cHRM value when sRGB is also present");
         }
#endif /* PNG_READ_cHRM_SUPPORTED */

   png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr, intent);
}
#endif /* PNG_READ_sRGB_SUPPORTED */

#if defined(PNG_READ_tRNS_SUPPORTED)
void
png_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_debug(1, "in png_handle_tRNS\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before tRNS");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid tRNS after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_tRNS)
   {
      png_warning(png_ptr, "Duplicate tRNS chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (!(png_ptr->mode & PNG_HAVE_PLTE))
      {
         /* Should be an error, but we can cope with it */
         png_warning(png_ptr, "Missing PLTE before tRNS");
      }
      else if (length > png_ptr->num_palette)
      {
         png_warning(png_ptr, "Incorrect tRNS chunk length");
         png_crc_finish(png_ptr, length);
         return;
      }
      if (length == 0)
      {
         png_warning(png_ptr, "Zero length tRNS chunk");
         png_crc_finish(png_ptr, length);
         return;
      }

      png_ptr->trans = (png_bytep)png_malloc(png_ptr, length);
      png_ptr->flags |= PNG_FLAG_FREE_TRANS;
      png_crc_read(png_ptr, png_ptr->trans, (png_size_t)length);
      png_ptr->num_trans = (png_uint_16)length;
   }
   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
   {
      png_byte buf[6];

      if (length != 6)
      {
         png_warning(png_ptr, "Incorrect tRNS chunk length");
         png_crc_finish(png_ptr, length);
         return;
      }

      png_crc_read(png_ptr, buf, (png_size_t)length);
      png_ptr->num_trans = 1;
      png_ptr->trans_values.red = png_get_uint_16(buf);
      png_ptr->trans_values.green = png_get_uint_16(buf + 2);
      png_ptr->trans_values.blue = png_get_uint_16(buf + 4);
   }
   else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
   {
      png_byte buf[6];

      if (length != 2)
      {
         png_warning(png_ptr, "Incorrect tRNS chunk length");
         png_crc_finish(png_ptr, length);
         return;
      }

      png_crc_read(png_ptr, buf, 2);
      png_ptr->num_trans = 1;
      png_ptr->trans_values.gray = png_get_uint_16(buf);
   }
   else
   {
      png_warning(png_ptr, "tRNS chunk not allowed with alpha channel");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_crc_finish(png_ptr, 0))
      return;

   png_set_tRNS(png_ptr, info_ptr, png_ptr->trans, png_ptr->num_trans,
      &(png_ptr->trans_values));
}
#endif

#if defined(PNG_READ_bKGD_SUPPORTED)
void
png_handle_bKGD(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_size_t truelen;
   png_byte buf[6];

   png_debug(1, "in png_handle_bKGD\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before bKGD");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid bKGD after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
            !(png_ptr->mode & PNG_HAVE_PLTE))
   {
      png_warning(png_ptr, "Missing PLTE before bKGD");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_bKGD)
   {
      png_warning(png_ptr, "Duplicate bKGD chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      truelen = 1;
   else if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
      truelen = 6;
   else
      truelen = 2;

   if (length != truelen)
   {
      png_warning(png_ptr, "Incorrect bKGD chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, truelen);
   if (png_crc_finish(png_ptr, 0))
      return;

   /* We convert the index value into RGB components so that we can allow
    * arbitrary RGB values for background when we have transparency, and
    * so it is easy to determine the RGB values of the background color
    * from the info_ptr struct. */
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      png_ptr->background.index = buf[0];
      if(info_ptr->num_palette)
      {
          if(buf[0] > info_ptr->num_palette)
          {
             png_warning(png_ptr, "Incorrect bKGD chunk index value");
             png_crc_finish(png_ptr, length);
             return;
          }
          png_ptr->background.red =
             (png_uint_16)png_ptr->palette[buf[0]].red;
          png_ptr->background.green =
             (png_uint_16)png_ptr->palette[buf[0]].green;
          png_ptr->background.blue =
             (png_uint_16)png_ptr->palette[buf[0]].blue;
      }
   }
   else if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) /* GRAY */
   {
      png_ptr->background.red =
      png_ptr->background.green =
      png_ptr->background.blue =
      png_ptr->background.gray = png_get_uint_16(buf);
   }
   else
   {
      png_ptr->background.red = png_get_uint_16(buf);
      png_ptr->background.green = png_get_uint_16(buf + 2);
      png_ptr->background.blue = png_get_uint_16(buf + 4);
   }

   png_set_bKGD(png_ptr, info_ptr, &(png_ptr->background));
}
#endif

#if defined(PNG_READ_hIST_SUPPORTED)
void
png_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   int num, i;

   png_debug(1, "in png_handle_hIST\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before hIST");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid hIST after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (!(png_ptr->mode & PNG_HAVE_PLTE))
   {
      png_warning(png_ptr, "Missing PLTE before hIST");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_hIST)
   {
      png_warning(png_ptr, "Duplicate hIST chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != (png_uint_32)(2 * png_ptr->num_palette))
   {
      png_warning(png_ptr, "Incorrect hIST chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   num = (int)length / 2 ;
   png_ptr->hist = (png_uint_16p)png_malloc(png_ptr,
      (png_uint_32)(num * sizeof (png_uint_16)));
   png_ptr->flags |= PNG_FLAG_FREE_HIST;
   for (i = 0; i < num; i++)
   {
      png_byte buf[2];

      png_crc_read(png_ptr, buf, 2);
      png_ptr->hist[i] = png_get_uint_16(buf);
   }

   if (png_crc_finish(png_ptr, 0))
      return;

   png_set_hIST(png_ptr, info_ptr, png_ptr->hist);
}
#endif

#if defined(PNG_READ_pHYs_SUPPORTED)
void
png_handle_pHYs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[9];
   png_uint_32 res_x, res_y;
   int unit_type;

   png_debug(1, "in png_handle_pHYs\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before pHYS");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid pHYS after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_pHYs)
   {
      png_warning(png_ptr, "Duplicate pHYS chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 9)
   {
      png_warning(png_ptr, "Incorrect pHYs chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 9);
   if (png_crc_finish(png_ptr, 0))
      return;

   res_x = png_get_uint_32(buf);
   res_y = png_get_uint_32(buf + 4);
   unit_type = buf[8];
   png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);
}
#endif

#if defined(PNG_READ_oFFs_SUPPORTED)
void
png_handle_oFFs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[9];
   png_uint_32 offset_x, offset_y;
   int unit_type;

   png_debug(1, "in png_handle_oFFs\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before oFFs");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid oFFs after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_oFFs)
   {
      png_warning(png_ptr, "Duplicate oFFs chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 9)
   {
      png_warning(png_ptr, "Incorrect oFFs chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 9);
   if (png_crc_finish(png_ptr, 0))
      return;

   offset_x = png_get_uint_32(buf);
   offset_y = png_get_uint_32(buf + 4);
   unit_type = buf[8];
   png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);
}
#endif

#if defined(PNG_READ_pCAL_SUPPORTED)
/* read the pCAL chunk (png-scivis-19970203) */
void
png_handle_pCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_charp purpose;
   png_int_32 X0, X1;
   png_byte type, nparams;
   png_charp buf, units, endptr;
   png_charpp params;
   png_size_t slength;
   int i;

   png_debug(1, "in png_handle_pCAL\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before pCAL");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid pCAL after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_pCAL)
   {
      png_warning(png_ptr, "Duplicate pCAL chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_debug1(2, "Allocating and reading pCAL chunk data (%d bytes)\n",
      length + 1);
   purpose = (png_charp)png_malloc(png_ptr, length + 1);
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)purpose, slength);

   if (png_crc_finish(png_ptr, 0))
   {
      png_free(png_ptr, purpose);
      return;
   }

   purpose[slength] = 0x00; /* null terminate the last string */

   png_debug(3, "Finding end of pCAL purpose string\n");
   for (buf = purpose; *buf; buf++)
      /* empty loop */ ;

   endptr = purpose + slength;

   /* We need to have at least 12 bytes after the purpose string
      in order to get the parameter information. */
   if (endptr <= buf + 12)
   {
      png_warning(png_ptr, "Invalid pCAL data");
      png_free(png_ptr, purpose);
      return;
   }

   png_debug(3, "Reading pCAL X0, X1, type, nparams, and units\n");
   X0 = png_get_int_32((png_bytep)buf+1);
   X1 = png_get_int_32((png_bytep)buf+5);
   type = buf[9];
   nparams = buf[10];
   units = buf + 11;

   png_debug(3, "Checking pCAL equation type and number of parameters\n");
   /* Check that we have the right number of parameters for known
      equation types. */
   if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||
       (type == PNG_EQUATION_BASE_E && nparams != 3) ||
       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||
       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))
   {
      png_warning(png_ptr, "Invalid pCAL parameters for equation type");
      png_free(png_ptr, purpose);
      return;
   }
   else if (type >= PNG_EQUATION_LAST)
   {
      png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");
   }

   for (buf = units; *buf; buf++)
      /* Empty loop to move past the units string. */ ;

   png_debug(3, "Allocating pCAL parameters array\n");
   params = (png_charpp)png_malloc(png_ptr, (png_uint_32)(nparams
      *sizeof(png_charp))) ;

   /* Get pointers to the start of each parameter string. */
   for (i = 0; i < (int)nparams; i++)
   {
      buf++; /* Skip the null string terminator from previous parameter. */

      png_debug1(3, "Reading pCAL parameter %d\n", i);
      for (params[i] = buf; *buf != 0x00 && buf <= endptr; buf++)
         /* Empty loop to move past each parameter string */ ;

      /* Make sure we haven't run out of data yet */
      if (buf > endptr)
      {
         png_warning(png_ptr, "Invalid pCAL data");
         png_free(png_ptr, purpose);
         png_free(png_ptr, params);
         return;
      }
   }

   png_set_pCAL(png_ptr, info_ptr, purpose, X0, X1, type, nparams,
      units, params);

   png_free(png_ptr, purpose);
   png_free(png_ptr, params);
}
#endif

#if defined(PNG_READ_tIME_SUPPORTED)
void
png_handle_tIME(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[7];
   png_time mod_time;

   png_debug(1, "in png_handle_tIME\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Out of place tIME chunk");
   else if (info_ptr != NULL && info_ptr->valid & PNG_INFO_tIME)
   {
      png_warning(png_ptr, "Duplicate tIME chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_ptr->mode & PNG_HAVE_IDAT)
      png_ptr->mode |= PNG_AFTER_IDAT;

   if (length != 7)
   {
      png_warning(png_ptr, "Incorrect tIME chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 7);
   if (png_crc_finish(png_ptr, 0))
      return;

   mod_time.second = buf[6];
   mod_time.minute = buf[5];
   mod_time.hour = buf[4];
   mod_time.day = buf[3];
   mod_time.month = buf[2];
   mod_time.year = png_get_uint_16(buf);

   png_set_tIME(png_ptr, info_ptr, &mod_time);
}
#endif

#if defined(PNG_READ_tEXt_SUPPORTED)
/* Note: this does not properly handle chunks that are > 64K under DOS */
void
png_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_textp text_ptr;
   png_charp key;
   png_charp text;
   png_uint_32 skip = 0;
   png_size_t slength;

   png_debug(1, "in png_handle_tEXt\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before tEXt");

   if (png_ptr->mode & PNG_HAVE_IDAT)
      png_ptr->mode |= PNG_AFTER_IDAT;

#ifdef PNG_MAX_MALLOC_64K
   if (length > (png_uint_32)65535L)
   {
      png_warning(png_ptr, "tEXt chunk too large to fit in memory");
      skip = length - (png_uint_32)65535L;
      length = (png_uint_32)65535L;
   }
#endif

   key = (png_charp)png_malloc(png_ptr, length + 1);
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)key, slength);

   if (png_crc_finish(png_ptr, skip))
   {
      png_free(png_ptr, key);
      return;
   }

   key[slength] = 0x00;

   for (text = key; *text; text++)
      /* empty loop to find end of key */ ;

   if (text != key + slength)
      text++;

   text_ptr = (png_textp)png_malloc(png_ptr, (png_uint_32)sizeof(png_text));
   text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;
   text_ptr->key = key;
   text_ptr->text = text;

   png_set_text(png_ptr, info_ptr, text_ptr, 1);

   png_free(png_ptr, text_ptr);
}
#endif

#if defined(PNG_READ_zTXt_SUPPORTED)
/* note: this does not correctly handle chunks that are > 64K under DOS */
void
png_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   static char msg[] = "Error decoding zTXt chunk";
   png_textp text_ptr;
   png_charp key;
   png_charp text;
   int comp_type = PNG_TEXT_COMPRESSION_NONE;
   png_size_t slength;

   png_debug(1, "in png_handle_zTXt\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before zTXt");

   if (png_ptr->mode & PNG_HAVE_IDAT)
      png_ptr->mode |= PNG_AFTER_IDAT;

#ifdef PNG_MAX_MALLOC_64K
   /* We will no doubt have problems with chunks even half this size, but
      there is no hard and fast rule to tell us where to stop. */
   if (length > (png_uint_32)65535L)
   {
     png_warning(png_ptr,"zTXt chunk too large to fit in memory");
     png_crc_finish(png_ptr, length);
     return;
   }
#endif

   key = (png_charp)png_malloc(png_ptr, length + 1);
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)key, slength);
   if (png_crc_finish(png_ptr, 0))
   {
      png_free(png_ptr, key);
      return;
   }

   key[slength] = 0x00;

   for (text = key; *text; text++)
      /* empty loop */ ;

   /* zTXt must have some text after the keyword */
   if (text == key + slength)
   {
      png_warning(png_ptr, "Zero length zTXt chunk");
   }
   else if ((comp_type = *(++text)) == PNG_TEXT_COMPRESSION_zTXt)
   {
      png_size_t text_size, key_size;
      text++;

      png_ptr->zstream.next_in = (png_bytep)text;
      png_ptr->zstream.avail_in = (uInt)(length - (text - key));
      png_ptr->zstream.next_out = png_ptr->zbuf;
      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;

      key_size = (png_size_t)(text - key);
      text_size = 0;
      text = NULL;

      while (png_ptr->zstream.avail_in)
      {
         int ret;

         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
         if (ret != Z_OK && ret != Z_STREAM_END)
         {
            if (png_ptr->zstream.msg != NULL)
               png_warning(png_ptr, png_ptr->zstream.msg);
            else
               png_warning(png_ptr, msg);
            inflateReset(&png_ptr->zstream);
            png_ptr->zstream.avail_in = 0;

            if (text ==  NULL)
            {
               text_size = key_size + sizeof(msg) + 1;
               text = (png_charp)png_malloc(png_ptr, (png_uint_32)text_size);
               png_memcpy(text, key, key_size);
            }

            text[text_size - 1] = 0x00;

            /* Copy what we can of the error message into the text chunk */
            text_size = (png_size_t)(slength - (text - key) - 1);
            text_size = sizeof(msg) > text_size ? text_size : sizeof(msg);
            png_memcpy(text + key_size, msg, text_size + 1);
            break;
         }
         if (!png_ptr->zstream.avail_out || ret == Z_STREAM_END)
         {
            if (text == NULL)
            {
               text = (png_charp)png_malloc(png_ptr,
                  (png_uint_32)(png_ptr->zbuf_size - png_ptr->zstream.avail_out
                     + key_size + 1));
               png_memcpy(text + key_size, png_ptr->zbuf,
                  png_ptr->zbuf_size - png_ptr->zstream.avail_out);
               png_memcpy(text, key, key_size);
               text_size = key_size + png_ptr->zbuf_size -
                  png_ptr->zstream.avail_out;
               *(text + text_size) = 0x00;
            }
            else
            {
               png_charp tmp;

               tmp = text;
               text = (png_charp)png_malloc(png_ptr, (png_uint_32)(text_size +
                  png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1));
               png_memcpy(text, tmp, text_size);
               png_free(png_ptr, tmp);
               png_memcpy(text + text_size, png_ptr->zbuf,
                  (png_ptr->zbuf_size - png_ptr->zstream.avail_out));
               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;
               *(text + text_size) = 0x00;
            }
            if (ret != Z_STREAM_END)
            {
               png_ptr->zstream.next_out = png_ptr->zbuf;
               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
            }
            else
            {
               break;
            }
         }
      }

      inflateReset(&png_ptr->zstream);
      png_ptr->zstream.avail_in = 0;

      png_free(png_ptr, key);
      key = text;
      text += key_size;
   }
   else /* if (comp_type >= PNG_TEXT_COMPRESSION_LAST) */
   {
      png_size_t text_size;
#if !defined(PNG_NO_STDIO)
      char umsg[50];

      sprintf(umsg, "Unknown zTXt compression type %d", comp_type);
      png_warning(png_ptr, umsg);
#else
      png_warning(png_ptr, "Unknown zTXt compression type");
#endif

      /* Copy what we can of the error message into the text chunk */
      text_size = (png_size_t)(slength - (text - key) - 1);
      text_size = sizeof(msg) > text_size ? text_size : sizeof(msg);
      png_memcpy(text, msg, text_size + 1);
   }

   text_ptr = (png_textp)png_malloc(png_ptr, (png_uint_32)sizeof(png_text));
   text_ptr->compression = comp_type;
   text_ptr->key = key;
   text_ptr->text = text;

   png_set_text(png_ptr, info_ptr, text_ptr, 1);

   png_free(png_ptr, text_ptr);
}
#endif

/* This function is called when we haven't found a handler for a
   chunk.  If there isn't a problem with the chunk itself (ie bad
   chunk name, CRC, or a critical chunk), the chunk is silently ignored. */
void
png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_debug(1, "in png_handle_unknown\n");

   /* In the future we can have code here that calls user-supplied
    * callback functions for unknown chunks before they are ignored or
    * cause an error.
    */
   png_check_chunk_name(png_ptr, png_ptr->chunk_name);

   if (!(png_ptr->chunk_name[0] & 0x20))
   {
      png_chunk_error(png_ptr, "unknown critical chunk");

      /* to quiet compiler warnings about unused info_ptr */
      if (info_ptr == NULL)
         return;
   }

   if (png_ptr->mode & PNG_HAVE_IDAT)
      png_ptr->mode |= PNG_AFTER_IDAT;

   png_crc_finish(png_ptr, length);

}

/* This function is called to verify that a chunk name is valid.
   This function can't have the "critical chunk check" incorporated
   into it, since in the future we will need to be able to call user
   functions to handle unknown critical chunks after we check that
   the chunk name itself is valid. */

#define isnonalpha(c) ((c) < 41 || (c) > 122 || ((c) > 90 && (c) < 97))

void
png_check_chunk_name(png_structp png_ptr, png_bytep chunk_name)
{
   png_debug(1, "in png_check_chunk_name\n");
   if (isnonalpha(chunk_name[0]) || isnonalpha(chunk_name[1]) ||
       isnonalpha(chunk_name[2]) || isnonalpha(chunk_name[3]))
   {
      png_chunk_error(png_ptr, "invalid chunk type");
   }
}

/* Combines the row recently read in with the existing pixels in the
   row.  This routine takes care of alpha and transparency if requested.
   This routine also handles the two methods of progressive display
   of interlaced images, depending on the mask value.
   The mask value describes which pixels are to be combined with
   the row.  The pattern always repeats every 8 pixels, so just 8
   bits are needed.  A one indicates the pixel is to be combined,
   a zero indicates the pixel is to be skipped.  This is in addition
   to any alpha or transparency value associated with the pixel.  If
   you want all pixels to be combined, pass 0xff (255) in mask.  */
void
#ifdef PNG_HAVE_ASSEMBLER_COMBINE_ROW
png_combine_row_c
#else
png_combine_row
#endif /* PNG_HAVE_ASSEMBLER_COMBINE_ROW */
   (png_structp png_ptr, png_bytep row, int mask)
{
   png_debug(1,"in png_combine_row\n");
   if (mask == 0xff)
   {
      png_memcpy(row, png_ptr->row_buf + 1,
         (png_size_t)((png_ptr->width *
         png_ptr->row_info.pixel_depth + 7) >> 3));
   }
   else
   {
      switch (png_ptr->row_info.pixel_depth)
      {
         case 1:
         {
            png_bytep sp = png_ptr->row_buf + 1;
            png_bytep dp = row;
            int s_inc, s_start, s_end;
            int m = 0x80;
            int shift;
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
                s_start = 0;
                s_end = 7;
                s_inc = 1;
            }
            else
#endif
            {
                s_start = 7;
                s_end = 0;
                s_inc = -1;
            }

            shift = s_start;

            for (i = 0; i < row_width; i++)
            {
               if (m & mask)
               {
                  int value;

                  value = (*sp >> shift) & 0x1;
                  *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;

               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }
         case 2:
         {
            png_bytep sp = png_ptr->row_buf + 1;
            png_bytep dp = row;
            int s_start, s_end, s_inc;
            int m = 0x80;
            int shift;
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;
            int value;

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
               s_start = 0;
               s_end = 6;
               s_inc = 2;
            }
            else
#endif
            {
               s_start = 6;
               s_end = 0;
               s_inc = -2;
            }

            shift = s_start;

            for (i = 0; i < row_width; i++)
            {
               if (m & mask)
               {
                  value = (*sp >> shift) & 0x3;
                  *dp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;
               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }
         case 4:
         {
            png_bytep sp = png_ptr->row_buf + 1;
            png_bytep dp = row;
            int s_start, s_end, s_inc;
            int m = 0x80;
            int shift;
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;
            int value;

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
               s_start = 0;
               s_end = 4;
               s_inc = 4;
            }
            else
#endif
            {
               s_start = 4;
               s_end = 0;
               s_inc = -4;
            }
            shift = s_start;

            for (i = 0; i < row_width; i++)
            {
               if (m & mask)
               {
                  value = (*sp >> shift) & 0xf;
                  *dp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;
               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }
         default:
         {
            png_bytep sp = png_ptr->row_buf + 1;
            png_bytep dp = row;
            png_size_t pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;
            png_byte m = 0x80;


            for (i = 0; i < row_width; i++)
            {
               if (m & mask)
               {
                  png_memcpy(dp, sp, pixel_bytes);
               }

               sp += pixel_bytes;
               dp += pixel_bytes;

               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }
      }
   }
}

#if defined(PNG_READ_INTERLACING_SUPPORTED)
void
#ifdef PNG_HAVE_ASSEMBLER_READ_INTERLACE
png_do_read_interlace_c
#else
png_do_read_interlace
#endif /* PNG_HAVE_ASSEMBLER_READ_INTERLACE */
   (png_row_infop row_info, png_bytep row, int pass,
   png_uint_32 transformations)
{
   png_debug(1,"in png_do_read_interlace\n");
   if (row != NULL && row_info != NULL)
   {
      png_uint_32 final_width;

      final_width = row_info->width * png_pass_inc[pass];

      switch (row_info->pixel_depth)
      {
         case 1:
         {
            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 3);
            png_bytep dp = row + (png_size_t)((final_width - 1) >> 3);
            int sshift, dshift;
            int s_start, s_end, s_inc;
            int jstop = png_pass_inc[pass];
            png_byte v;
            png_uint_32 i;
            int j;

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
                sshift = (int)((row_info->width + 7) & 7);
                dshift = (int)((final_width + 7) & 7);
                s_start = 7;
                s_end = 0;
                s_inc = -1;
            }
            else
#endif
            {
                sshift = 7 - (int)((row_info->width + 7) & 7);
                dshift = 7 - (int)((final_width + 7) & 7);
                s_start = 0;
                s_end = 7;
                s_inc = 1;
            }

            for (i = 0; i < row_info->width; i++)
            {
               v = (png_byte)((*sp >> sshift) & 0x1);
               for (j = 0; j < jstop; j++)
               {
                  *dp &= (png_byte)((0x7f7f >> (7 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }
         case 2:
         {
            png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);
            png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);
            int sshift, dshift;
            int s_start, s_end, s_inc;
            int jstop = png_pass_inc[pass];
            png_uint_32 i;

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (int)(((row_info->width + 3) & 3) << 1);
               dshift = (int)(((final_width + 3) & 3) << 1);
               s_start = 6;
               s_end = 0;
               s_inc = -2;
            }
            else
#endif
            {
               sshift = (int)((3 - ((row_info->width + 3) & 3)) << 1);
               dshift = (int)((3 - ((final_width + 3) & 3)) << 1);
               s_start = 0;
               s_end = 6;
               s_inc = 2;
            }

            for (i = 0; i < row_info->width; i++)
            {
               png_byte v;
               int j;

               v = (png_byte)((*sp >> sshift) & 0x3);
               for (j = 0; j < jstop; j++)
               {
                  *dp &= (png_byte)((0x3f3f >> (6 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }
         case 4:
         {
            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 1);
            png_bytep dp = row + (png_size_t)((final_width - 1) >> 1);
            int sshift, dshift;
            int s_start, s_end, s_inc;
            png_uint_32 i;
            int jstop = png_pass_inc[pass];

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (int)(((row_info->width + 1) & 1) << 2);
               dshift = (int)(((final_width + 1) & 1) << 2);
               s_start = 4;
               s_end = 0;
               s_inc = -4;
            }
            else
#endif
            {
               sshift = (int)((1 - ((row_info->width + 1) & 1)) << 2);
               dshift = (int)((1 - ((final_width + 1) & 1)) << 2);
               s_start = 0;
               s_end = 4;
               s_inc = 4;
            }

            for (i = 0; i < row_info->width; i++)
            {
               png_byte v = (png_byte)((*sp >> sshift) & 0xf);
               int j;

               for (j = 0; j < jstop; j++)
               {
                  *dp &= (png_byte)((0xf0f >> (4 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }
         default:
         {
            png_size_t pixel_bytes = (row_info->pixel_depth >> 3);
            png_bytep sp = row + (png_size_t)(row_info->width - 1) * pixel_bytes;
            png_bytep dp = row + (png_size_t)(final_width - 1) * pixel_bytes;

            int jstop = png_pass_inc[pass];
            png_uint_32 i;

            for (i = 0; i < row_info->width; i++)
            {
               png_byte v[8];
               int j;

               png_memcpy(v, sp, pixel_bytes);
               for (j = 0; j < jstop; j++)
               {
                  png_memcpy(dp, v, pixel_bytes);
                  dp -= pixel_bytes;
               }
               sp -= pixel_bytes;
            }
            break;
         }
      }
      row_info->width = final_width;
      row_info->rowbytes = ((final_width *
         (png_uint_32)row_info->pixel_depth + 7) >> 3);
   }
}
#endif

void
#ifdef PNG_HAVE_ASSEMBLER_READ_FILTER_ROW
png_read_filter_row_c
#else
png_read_filter_row
#endif /* PNG_HAVE_ASSEMBLER_READ_FILTER_ROW */
   (png_structp png_ptr, png_row_infop row_info, png_bytep row,
   png_bytep prev_row, int filter)
{
   png_debug(1, "in png_read_filter_row\n");
   png_debug2(2,"row = %d, filter = %d\n", png_ptr->row_number, filter);
   switch (filter)
   {
      case PNG_FILTER_VALUE_NONE:
         break;
      case PNG_FILTER_VALUE_SUB:
      {
         png_uint_32 i;
         png_uint_32 istop = row_info->rowbytes;
         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
         png_bytep rp = row + bpp;
         png_bytep lp = row;

         for (i = bpp; i < istop; i++)
         {
            *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);
            rp++;
         }
         break;
      }
      case PNG_FILTER_VALUE_UP:
      {
         png_uint_32 i;
         png_uint_32 istop = row_info->rowbytes;
         png_bytep rp = row;
         png_bytep pp = prev_row;

         for (i = 0; i < istop; i++)
         {
            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
            rp++;
         }
         break;
      }
      case PNG_FILTER_VALUE_AVG:
      {
         png_uint_32 i;
         png_bytep rp = row;
         png_bytep pp = prev_row;
         png_bytep lp = row;
         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
         png_uint_32 istop = row_info->rowbytes - bpp;

         for (i = 0; i < bpp; i++)
         {
            *rp = (png_byte)(((int)(*rp) +
               ((int)(*pp++) / 2 )) & 0xff);
            rp++;
         }

         for (i = 0; i < istop; i++)
         {
            *rp = (png_byte)(((int)(*rp) +
               (int)(*pp++ + *lp++) / 2 ) & 0xff);
            rp++;
         }
         break;
      }
      case PNG_FILTER_VALUE_PAETH:
      {
         png_uint_32 i;
         png_bytep rp = row;
         png_bytep pp = prev_row;
         png_bytep lp = row;
         png_bytep cp = prev_row;
         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
         png_uint_32 istop=row_info->rowbytes - bpp;

         for (i = 0; i < bpp; i++)
         {
            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
            rp++;
         }

         for (i = 0; i < istop; i++)   /* use leftover rp,pp */
         {
            int a, b, c, pa, pb, pc, p;

            a = *lp++;
            b = *pp++;
            c = *cp++;

            p = b - c;
            pc = a - c;

#ifdef PNG_USE_ABS
            pa = abs(p);
            pb = abs(pc);
            pc = abs(p + pc);
#else
            pa = p < 0 ? -p : p;
            pb = pc < 0 ? -pc : pc;
            pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif

            /*
               if (pa <= pb && pa <= pc)
                  p = a;
               else if (pb <= pc)
                  p = b;
               else
                  p = c;
             */

            p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;

            *rp = (png_byte)(((int)(*rp) + p) & 0xff);
            rp++;
         }
         break;
      }
      default:
         png_warning(png_ptr, "Ignoring bad adaptive filter type");
         *row=0;
         break;
   }
}

void
png_read_finish_row(png_structp png_ptr)
{
   png_debug(1, "in png_read_finish_row\n");
   png_ptr->row_number++;
   if (png_ptr->row_number < png_ptr->num_rows)
      return;

   if (png_ptr->interlaced)
   {
      png_ptr->row_number = 0;
      png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
      do
      {
         png_ptr->pass++;
         if (png_ptr->pass >= 7)
            break;
         png_ptr->iwidth = (png_ptr->width +
            png_pass_inc[png_ptr->pass] - 1 -
            png_pass_start[png_ptr->pass]) /
            png_pass_inc[png_ptr->pass];
            png_ptr->irowbytes = ((png_ptr->iwidth *
               (png_uint_32)png_ptr->pixel_depth + 7) >> 3) +1;

         if (!(png_ptr->transformations & PNG_INTERLACE))
         {
            png_ptr->num_rows = (png_ptr->height +
               png_pass_yinc[png_ptr->pass] - 1 -
               png_pass_ystart[png_ptr->pass]) /
               png_pass_yinc[png_ptr->pass];
            if (!(png_ptr->num_rows))
               continue;
         }
         else  /* if (png_ptr->transformations & PNG_INTERLACE) */
            break;
      } while (png_ptr->iwidth == 0);

      if (png_ptr->pass < 7)
         return;
   }

   if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
   {
      char extra;
      int ret;

      png_ptr->zstream.next_out = (Byte *)&extra;
      png_ptr->zstream.avail_out = (uInt)1;
      for(;;)
      {
         if (!(png_ptr->zstream.avail_in))
         {
            while (!png_ptr->idat_size)
            {
               png_byte chunk_length[4];

               png_crc_finish(png_ptr, 0);

               png_read_data(png_ptr, chunk_length, 4);
               png_ptr->idat_size = png_get_uint_32(chunk_length);

               png_reset_crc(png_ptr);
               png_crc_read(png_ptr, png_ptr->chunk_name, 4);
               if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))
                  png_error(png_ptr, "Not enough image data");

            }
            png_ptr->zstream.avail_in = (uInt)png_ptr->zbuf_size;
            png_ptr->zstream.next_in = png_ptr->zbuf;
            if (png_ptr->zbuf_size > png_ptr->idat_size)
               png_ptr->zstream.avail_in = (uInt)png_ptr->idat_size;
            png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zstream.avail_in);
            png_ptr->idat_size -= png_ptr->zstream.avail_in;
         }
         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
         if (ret == Z_STREAM_END)
         {
            if (!(png_ptr->zstream.avail_out) || png_ptr->zstream.avail_in ||
               png_ptr->idat_size)
               png_error(png_ptr, "Extra compressed data");
            png_ptr->mode |= PNG_AFTER_IDAT;
            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
            break;
         }
         if (ret != Z_OK)
            png_error(png_ptr, png_ptr->zstream.msg ? png_ptr->zstream.msg :
                      "Decompression Error");

         if (!(png_ptr->zstream.avail_out))
            png_error(png_ptr, "Extra compressed data");

      }
      png_ptr->zstream.avail_out = 0;
   }

   if (png_ptr->idat_size || png_ptr->zstream.avail_in)
      png_error(png_ptr, "Extra compression data");

   inflateReset(&png_ptr->zstream);

   png_ptr->mode |= PNG_AFTER_IDAT;
}

void
png_read_start_row(png_structp png_ptr)
{
   int max_pixel_depth;
   png_uint_32 row_bytes;

   png_debug(1, "in png_read_start_row\n");
   png_ptr->zstream.avail_in = 0;
   png_init_read_transformations(png_ptr);
   if (png_ptr->interlaced)
   {
      if (!(png_ptr->transformations & PNG_INTERLACE))
         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
            png_pass_ystart[0]) / png_pass_yinc[0];
      else
         png_ptr->num_rows = png_ptr->height;

      png_ptr->iwidth = (png_ptr->width +
         png_pass_inc[png_ptr->pass] - 1 -
         png_pass_start[png_ptr->pass]) /
         png_pass_inc[png_ptr->pass];

         row_bytes = ((png_ptr->iwidth *
            (png_uint_32)png_ptr->pixel_depth + 7) >> 3) +1;
         png_ptr->irowbytes = row_bytes;
         if((png_uint_32)png_ptr->irowbytes != row_bytes)
            png_error(png_ptr, "Rowbytes overflow in png_read_start_row");
   }
   else
   {
      png_ptr->num_rows = png_ptr->height;
      png_ptr->iwidth = png_ptr->width;
      png_ptr->irowbytes = png_ptr->rowbytes + 1;
   }
   max_pixel_depth = png_ptr->pixel_depth;

#if defined(PNG_READ_PACK_SUPPORTED)
   if ((png_ptr->transformations & PNG_PACK) && png_ptr->bit_depth < 8)
      max_pixel_depth = 8;
#endif

#if defined(PNG_READ_EXPAND_SUPPORTED)
   if (png_ptr->transformations & PNG_EXPAND)
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         if (png_ptr->num_trans)
            max_pixel_depth = 32;
         else
            max_pixel_depth = 24;
      }
      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
      {
         if (max_pixel_depth < 8)
            max_pixel_depth = 8;
         if (png_ptr->num_trans)
            max_pixel_depth *= 2;
      }
      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
      {
         if (png_ptr->num_trans)
         {
            max_pixel_depth *= 4;
            max_pixel_depth /= 3;
         }
      }
   }
#endif

#if defined(PNG_READ_FILLER_SUPPORTED)
   if (png_ptr->transformations & (PNG_FILLER))
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
         max_pixel_depth = 32;
      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
      {
         if (max_pixel_depth <= 8)
            max_pixel_depth = 16;
         else
            max_pixel_depth = 32;
      }
      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
      {
         if (max_pixel_depth <= 32)
            max_pixel_depth = 32;
         else
            max_pixel_depth = 64;
      }
   }
#endif

#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
   if (png_ptr->transformations & PNG_GRAY_TO_RGB)
   {
      if (
#if defined(PNG_READ_EXPAND_SUPPORTED)
        (png_ptr->num_trans && (png_ptr->transformations & PNG_EXPAND)) ||
#endif
#if defined(PNG_READ_FILLER_SUPPORTED)
        (png_ptr->transformations & (PNG_FILLER)) ||
#endif
        png_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         if (max_pixel_depth <= 16)
            max_pixel_depth = 32;
         else
            max_pixel_depth = 64;
      }
      else
      {
         if (max_pixel_depth <= 8)
            max_pixel_depth = 24;
         else
            max_pixel_depth = 48;
      }
   }
#endif

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
   if(png_ptr->transformations & PNG_USER_TRANSFORM)
     {
       int user_pixel_depth=png_ptr->user_transform_depth*
         png_ptr->user_transform_channels;
       if(user_pixel_depth > max_pixel_depth)
         max_pixel_depth=user_pixel_depth;
     }
#endif

   /* align the width on the next larger 8 pixels.  Mainly used
      for interlacing */
   row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));
   /* calculate the maximum bytes needed, adding a byte and a pixel
      for safety's sake */
   row_bytes = ((row_bytes * (png_uint_32)max_pixel_depth + 7) >> 3) +
      1 + ((max_pixel_depth + 7) >> 3);
#ifdef PNG_MAX_MALLOC_64K
   if (row_bytes > (png_uint_32)65536L)
      png_error(png_ptr, "This image requires a row greater than 64KB");
#endif
   png_ptr->row_buf = (png_bytep)png_malloc(png_ptr, row_bytes);

#ifdef PNG_MAX_MALLOC_64K
   if ((png_uint_32)png_ptr->rowbytes + 1 > (png_uint_32)65536L)
      png_error(png_ptr, "This image requires a row greater than 64KB");
#endif
   png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
      png_ptr->rowbytes + 1));

   png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);

   png_debug1(3, "width = %d,\n", png_ptr->width);
   png_debug1(3, "height = %d,\n", png_ptr->height);
   png_debug1(3, "iwidth = %d,\n", png_ptr->iwidth);
   png_debug1(3, "num_rows = %d\n", png_ptr->num_rows);
   png_debug1(3, "rowbytes = %d,\n", png_ptr->rowbytes);
   png_debug1(3, "irowbytes = %d,\n", png_ptr->irowbytes);

   png_ptr->flags |= PNG_FLAG_ROW_INIT;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\pngtrans.cpp ===
/* pngtrans.c - transforms the data in a row (used by both readers and writers)
 *
 * libpng 1.0.5 - October 15, 1999
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
 * Copyright (c) 1996, 1997 Andreas Dilger
 * Copyright (c) 1998, 1999 Glenn Randers-Pehrson
 */

#define PNG_INTERNAL
#include "png.h"

namespace D3DX
{


#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
/* turn on BGR-to-RGB mapping */
void
png_set_bgr(png_structp png_ptr)
{
   png_debug(1, "in png_set_bgr\n");
   png_ptr->transformations |= PNG_BGR;
}
#endif

#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
/* turn on 16 bit byte swapping */
void
png_set_swap(png_structp png_ptr)
{
   png_debug(1, "in png_set_swap\n");
   if (png_ptr->bit_depth == 16)
      png_ptr->transformations |= PNG_SWAP_BYTES;
}
#endif

#if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
/* turn on pixel packing */
void
png_set_packing(png_structp png_ptr)
{
   png_debug(1, "in png_set_packing\n");
   if (png_ptr->bit_depth < 8)
   {
      png_ptr->transformations |= PNG_PACK;
      png_ptr->usr_bit_depth = 8;
   }
}
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
/* turn on packed pixel swapping */
void
png_set_packswap(png_structp png_ptr)
{
   png_debug(1, "in png_set_packswap\n");
   if (png_ptr->bit_depth < 8)
      png_ptr->transformations |= PNG_PACKSWAP;
}
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
void
png_set_shift(png_structp png_ptr, png_color_8p true_bits)
{
   png_debug(1, "in png_set_shift\n");
   png_ptr->transformations |= PNG_SHIFT;
   png_ptr->shift = *true_bits;
}
#endif

#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
    defined(PNG_WRITE_INTERLACING_SUPPORTED)
int
png_set_interlace_handling(png_structp png_ptr)
{
   png_debug(1, "in png_set_interlace handling\n");
   if (png_ptr->interlaced)
   {
      png_ptr->transformations |= PNG_INTERLACE;
      return (7);
   }

   return (1);
}
#endif

#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
/* Add a filler byte on read, or remove a filler or alpha byte on write.
 * The filler type has changed in v0.95 to allow future 2-byte fillers
 * for 48-bit input data, as well as to avoid problems with some compilers
 * that don't like bytes as parameters.
 */
void
png_set_filler(png_structp png_ptr, png_uint_32 filler, int filler_loc)
{
   png_debug(1, "in png_set_filler\n");
   png_ptr->transformations |= PNG_FILLER;
   png_ptr->filler = (png_byte)filler;
   if (filler_loc == PNG_FILLER_AFTER)
      png_ptr->flags |= PNG_FLAG_FILLER_AFTER;
   else
      png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;

   /* This should probably go in the "do_filler" routine.
    * I attempted to do that in libpng-1.0.1a but that caused problems
    * so I restored it in libpng-1.0.2a
   */

   if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
   {
      png_ptr->usr_channels = 4;
   }

   /* Also I added this in libpng-1.0.2a (what happens when we expand
    * a less-than-8-bit grayscale to GA? */

   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY && png_ptr->bit_depth >= 8)
   {
      png_ptr->usr_channels = 2;
   }
}
#endif

#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
void
png_set_swap_alpha(png_structp png_ptr)
{
   png_debug(1, "in png_set_swap_alpha\n");
   png_ptr->transformations |= PNG_SWAP_ALPHA;
}
#endif

#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
void
png_set_invert_alpha(png_structp png_ptr)
{
   png_debug(1, "in png_set_invert_alpha\n");
   png_ptr->transformations |= PNG_INVERT_ALPHA;
}
#endif

#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
void
png_set_invert_mono(png_structp png_ptr)
{
   png_debug(1, "in png_set_invert_mono\n");
   png_ptr->transformations |= PNG_INVERT_MONO;
}

/* invert monochrome grayscale data */
void
png_do_invert(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_invert\n");
   if (row_info->bit_depth == 1 &&
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
       row_info->color_type == PNG_COLOR_TYPE_GRAY)
   {
      png_bytep rp = row;
      png_uint_32 i;
      png_uint_32 istop = row_info->rowbytes;

      for (i = 0; i < istop; i++)
      {
         *rp = (png_byte)(~(*rp));
         rp++;
      }
   }
}
#endif

#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
/* swaps byte order on 16 bit depth images */
void
png_do_swap(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_swap\n");
   if (
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
       row_info->bit_depth == 16)
   {
      png_bytep rp = row;
      png_uint_32 i;
      png_uint_32 istop= row_info->width * row_info->channels;

      for (i = 0; i < istop; i++, rp += 2)
      {
         png_byte t = *rp;
         *rp = *(rp + 1);
         *(rp + 1) = t;
      }
   }
}
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
static png_byte onebppswaptable[256] = {
   0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
   0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
   0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
   0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
   0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
   0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
   0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
   0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
   0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
   0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
   0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
   0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
   0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
   0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
   0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
   0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
   0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
   0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
   0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
   0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
   0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
   0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
   0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
   0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
   0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};

static png_byte twobppswaptable[256] = {
   0x00, 0x40, 0x80, 0xC0, 0x10, 0x50, 0x90, 0xD0,
   0x20, 0x60, 0xA0, 0xE0, 0x30, 0x70, 0xB0, 0xF0,
   0x04, 0x44, 0x84, 0xC4, 0x14, 0x54, 0x94, 0xD4,
   0x24, 0x64, 0xA4, 0xE4, 0x34, 0x74, 0xB4, 0xF4,
   0x08, 0x48, 0x88, 0xC8, 0x18, 0x58, 0x98, 0xD8,
   0x28, 0x68, 0xA8, 0xE8, 0x38, 0x78, 0xB8, 0xF8,
   0x0C, 0x4C, 0x8C, 0xCC, 0x1C, 0x5C, 0x9C, 0xDC,
   0x2C, 0x6C, 0xAC, 0xEC, 0x3C, 0x7C, 0xBC, 0xFC,
   0x01, 0x41, 0x81, 0xC1, 0x11, 0x51, 0x91, 0xD1,
   0x21, 0x61, 0xA1, 0xE1, 0x31, 0x71, 0xB1, 0xF1,
   0x05, 0x45, 0x85, 0xC5, 0x15, 0x55, 0x95, 0xD5,
   0x25, 0x65, 0xA5, 0xE5, 0x35, 0x75, 0xB5, 0xF5,
   0x09, 0x49, 0x89, 0xC9, 0x19, 0x59, 0x99, 0xD9,
   0x29, 0x69, 0xA9, 0xE9, 0x39, 0x79, 0xB9, 0xF9,
   0x0D, 0x4D, 0x8D, 0xCD, 0x1D, 0x5D, 0x9D, 0xDD,
   0x2D, 0x6D, 0xAD, 0xED, 0x3D, 0x7D, 0xBD, 0xFD,
   0x02, 0x42, 0x82, 0xC2, 0x12, 0x52, 0x92, 0xD2,
   0x22, 0x62, 0xA2, 0xE2, 0x32, 0x72, 0xB2, 0xF2,
   0x06, 0x46, 0x86, 0xC6, 0x16, 0x56, 0x96, 0xD6,
   0x26, 0x66, 0xA6, 0xE6, 0x36, 0x76, 0xB6, 0xF6,
   0x0A, 0x4A, 0x8A, 0xCA, 0x1A, 0x5A, 0x9A, 0xDA,
   0x2A, 0x6A, 0xAA, 0xEA, 0x3A, 0x7A, 0xBA, 0xFA,
   0x0E, 0x4E, 0x8E, 0xCE, 0x1E, 0x5E, 0x9E, 0xDE,
   0x2E, 0x6E, 0xAE, 0xEE, 0x3E, 0x7E, 0xBE, 0xFE,
   0x03, 0x43, 0x83, 0xC3, 0x13, 0x53, 0x93, 0xD3,
   0x23, 0x63, 0xA3, 0xE3, 0x33, 0x73, 0xB3, 0xF3,
   0x07, 0x47, 0x87, 0xC7, 0x17, 0x57, 0x97, 0xD7,
   0x27, 0x67, 0xA7, 0xE7, 0x37, 0x77, 0xB7, 0xF7,
   0x0B, 0x4B, 0x8B, 0xCB, 0x1B, 0x5B, 0x9B, 0xDB,
   0x2B, 0x6B, 0xAB, 0xEB, 0x3B, 0x7B, 0xBB, 0xFB,
   0x0F, 0x4F, 0x8F, 0xCF, 0x1F, 0x5F, 0x9F, 0xDF,
   0x2F, 0x6F, 0xAF, 0xEF, 0x3F, 0x7F, 0xBF, 0xFF
};

static png_byte fourbppswaptable[256] = {
   0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
   0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,
   0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71,
   0x81, 0x91, 0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1,
   0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72,
   0x82, 0x92, 0xA2, 0xB2, 0xC2, 0xD2, 0xE2, 0xF2,
   0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73,
   0x83, 0x93, 0xA3, 0xB3, 0xC3, 0xD3, 0xE3, 0xF3,
   0x04, 0x14, 0x24, 0x34, 0x44, 0x54, 0x64, 0x74,
   0x84, 0x94, 0xA4, 0xB4, 0xC4, 0xD4, 0xE4, 0xF4,
   0x05, 0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75,
   0x85, 0x95, 0xA5, 0xB5, 0xC5, 0xD5, 0xE5, 0xF5,
   0x06, 0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76,
   0x86, 0x96, 0xA6, 0xB6, 0xC6, 0xD6, 0xE6, 0xF6,
   0x07, 0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77,
   0x87, 0x97, 0xA7, 0xB7, 0xC7, 0xD7, 0xE7, 0xF7,
   0x08, 0x18, 0x28, 0x38, 0x48, 0x58, 0x68, 0x78,
   0x88, 0x98, 0xA8, 0xB8, 0xC8, 0xD8, 0xE8, 0xF8,
   0x09, 0x19, 0x29, 0x39, 0x49, 0x59, 0x69, 0x79,
   0x89, 0x99, 0xA9, 0xB9, 0xC9, 0xD9, 0xE9, 0xF9,
   0x0A, 0x1A, 0x2A, 0x3A, 0x4A, 0x5A, 0x6A, 0x7A,
   0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0xFA,
   0x0B, 0x1B, 0x2B, 0x3B, 0x4B, 0x5B, 0x6B, 0x7B,
   0x8B, 0x9B, 0xAB, 0xBB, 0xCB, 0xDB, 0xEB, 0xFB,
   0x0C, 0x1C, 0x2C, 0x3C, 0x4C, 0x5C, 0x6C, 0x7C,
   0x8C, 0x9C, 0xAC, 0xBC, 0xCC, 0xDC, 0xEC, 0xFC,
   0x0D, 0x1D, 0x2D, 0x3D, 0x4D, 0x5D, 0x6D, 0x7D,
   0x8D, 0x9D, 0xAD, 0xBD, 0xCD, 0xDD, 0xED, 0xFD,
   0x0E, 0x1E, 0x2E, 0x3E, 0x4E, 0x5E, 0x6E, 0x7E,
   0x8E, 0x9E, 0xAE, 0xBE, 0xCE, 0xDE, 0xEE, 0xFE,
   0x0F, 0x1F, 0x2F, 0x3F, 0x4F, 0x5F, 0x6F, 0x7F,
   0x8F, 0x9F, 0xAF, 0xBF, 0xCF, 0xDF, 0xEF, 0xFF
};

/* swaps pixel packing order within bytes */
void
png_do_packswap(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_packswap\n");
   if (
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
       row_info->bit_depth < 8)
   {
      png_bytep rp, end, table;

      end = row + row_info->rowbytes;

      if (row_info->bit_depth == 1)
         table = onebppswaptable;
      else if (row_info->bit_depth == 2)
         table = twobppswaptable;
      else if (row_info->bit_depth == 4)
         table = fourbppswaptable;
      else
         return;

      for (rp = row; rp < end; rp++)
         *rp = table[*rp];
   }
}
#endif /* PNG_READ_PACKSWAP_SUPPORTED or PNG_WRITE_PACKSWAP_SUPPORTED */

#if defined(PNG_WRITE_FILLER_SUPPORTED) || \
    defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
/* remove filler or alpha byte(s) */
void
png_do_strip_filler(png_row_infop row_info, png_bytep row, png_uint_32 flags)
{
   png_debug(1, "in png_do_strip_filler\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL)
#endif
   {
/*
      if (row_info->color_type == PNG_COLOR_TYPE_RGB ||
          row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
*/
      png_bytep sp=row;
      png_bytep dp=row;
      png_uint_32 row_width=row_info->width;
      png_uint_32 i;

      if (row_info->channels == 4)
      {
         if (row_info->bit_depth == 8)
         {
            /* This converts from RGBX or RGBA to RGB */
            if (flags & PNG_FLAG_FILLER_AFTER)
            {
               dp+=3; sp+=4;
               for (i = 1; i < row_width; i++)
               {
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  sp++;
               }
            }
            /* This converts from XRGB or ARGB to RGB */
            else
            {
               for (i = 0; i < row_width; i++)
               {
                  sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
               }
            }
            row_info->pixel_depth = 24;
            row_info->rowbytes = row_width * 3;
         }
         else /* if (row_info->bit_depth == 16) */
         {
            if (flags & PNG_FLAG_FILLER_AFTER)
            {
               /* This converts from RRGGBBXX or RRGGBBAA to RRGGBB */
               sp += 8; dp += 6;
               for (i = 1; i < row_width; i++)
               {
                  /* This could be (although memcpy is probably slower):
                  png_memcpy(dp, sp, 6);
                  sp += 8;
                  dp += 6;
                  */
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  sp += 2;
               }
            }
            else
            {
               /* This converts from XXRRGGBB or AARRGGBB to RRGGBB */
               for (i = 0; i < row_width; i++)
               {
                  /* This could be (although memcpy is probably slower):
                  png_memcpy(dp, sp, 6);
                  sp += 8;
                  dp += 6;
                  */
                  sp+=2;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
               }
            }
            row_info->pixel_depth = 48;
            row_info->rowbytes = row_width * 6;
         }
         row_info->channels = 3;
         row_info->color_type &= ~PNG_COLOR_MASK_ALPHA;
      }
/*
      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY ||
               row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
*/
      else if (row_info->channels == 2)
      {
         if (row_info->bit_depth == 8)
         {
            /* This converts from GX or GA to G */
            if (flags & PNG_FLAG_FILLER_AFTER)
            {
               for (i = 0; i < row_width; i++)
               {
                  *dp++ = *sp++;
                  sp++;
               }
            }
            /* This converts from XG or AG to G */
            else
            {
               for (i = 0; i < row_width; i++)
               {
                  sp++;
                  *dp++ = *sp++;
               }
            }
            row_info->pixel_depth = 8;
            row_info->rowbytes = row_width;
         }
         else /* if (row_info->bit_depth == 16) */
         {
            if (flags & PNG_FLAG_FILLER_AFTER)
            {
               /* This converts from GGXX or GGAA to GG */
               sp += 4; dp += 2;
               for (i = 1; i < row_width; i++)
               {
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  sp += 2;
               }
            }
            else
            {
               /* This converts from XXGG or AAGG to GG */
               for (i = 0; i < row_width; i++)
               {
                  sp += 2;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
               }
            }
            row_info->pixel_depth = 16;
            row_info->rowbytes = row_width * 2;
         }
         row_info->channels = 1;
         row_info->color_type &= ~PNG_COLOR_MASK_ALPHA;
      }
   }
}
#endif

#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
/* swaps red and blue bytes within a pixel */
void
png_do_bgr(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_bgr\n");
   if (
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
       (row_info->color_type & PNG_COLOR_MASK_COLOR))
   {
      png_uint_32 row_width = row_info->width;
      if (row_info->bit_depth == 8)
      {
         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
         {
            png_bytep rp;
            png_uint_32 i;

            for (i = 0, rp = row; i < row_width; i++, rp += 3)
            {
               png_byte save = *rp;
               *rp = *(rp + 2);
               *(rp + 2) = save;
            }
         }
         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
         {
            png_bytep rp;
            png_uint_32 i;

            for (i = 0, rp = row; i < row_width; i++, rp += 4)
            {
               png_byte save = *rp;
               *rp = *(rp + 2);
               *(rp + 2) = save;
            }
         }
      }
      else if (row_info->bit_depth == 16)
      {
         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
         {
            png_bytep rp;
            png_uint_32 i;

            for (i = 0, rp = row; i < row_width; i++, rp += 6)
            {
               png_byte save = *rp;
               *rp = *(rp + 4);
               *(rp + 4) = save;
               save = *(rp + 1);
               *(rp + 1) = *(rp + 5);
               *(rp + 5) = save;
            }
         }
         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
         {
            png_bytep rp;
            png_uint_32 i;

            for (i = 0, rp = row; i < row_width; i++, rp += 8)
            {
               png_byte save = *rp;
               *rp = *(rp + 4);
               *(rp + 4) = save;
               save = *(rp + 1);
               *(rp + 1) = *(rp + 5);
               *(rp + 5) = save;
            }
         }
      }
   }
}
#endif /* PNG_READ_BGR_SUPPORTED or PNG_WRITE_BGR_SUPPORTED */

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
void
png_set_user_transform_info(png_structp png_ptr, png_voidp
   user_transform_ptr, int user_transform_depth, int user_transform_channels)
{
   png_debug(1, "in png_set_user_transform_info\n");
   png_ptr->user_transform_ptr = user_transform_ptr;
   png_ptr->user_transform_depth = (png_byte)user_transform_depth;
   png_ptr->user_transform_channels = (png_byte)user_transform_channels;
}

/* This function returns a pointer to the user_transform_ptr associated with
 * the user transform functions.  The application should free any memory
 * associated with this pointer before png_write_destroy and png_read_destroy
 * are called.
 */
png_voidp
png_get_user_transform_ptr(png_structp png_ptr)
{
   return ((png_voidp)png_ptr->user_transform_ptr);
}
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\pngtest.cpp ===
/* pngtest.c - a simple test program to test libpng
 *
 * libpng 1.0.5 - October 15, 1999
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
 * Copyright (c) 1996, 1997 Andreas Dilger
 * Copyright (c) 1998, 1999 Glenn Randers-Pehrson
 *
 * This program reads in a PNG image, writes it out again, and then
 * compares the two files.  If the files are identical, this shows that
 * the basic chunk handling, filtering, and (de)compression code is working
 * properly.  It does not currently test all of the transforms, although
 * it probably should.
 *
 * The program will report "FAIL" in certain legitimate cases:
 * 1) when the compression level or filter selection method is changed.
 * 2) when the chunk size is not 8K.
 * 3) unknown ancillary chunks exist in the input file.
 * 4) others not listed here...
 * In these cases, it is best to check with another tool such as "pngcheck"
 * to see what the differences between the two images are.
 *
 * If a filename is given on the command-line, then this file is used
 * for the input, rather than the default "pngtest.png".  This allows
 * testing a wide variety of files easily.  You can also test a number
 * of files at once by typing "pngtest -m file1.png file2.png ..."
 */

#include <stdio.h>
#include <stdlib.h>

/* Makes pngtest verbose so we can find problems (needs to be before png.h) */
#ifndef PNG_DEBUG
#define PNG_DEBUG 0
#endif

/* Turn on CPU timing
#define PNGTEST_TIMING
*/

#ifdef PNGTEST_TIMING
static float t_start, t_stop, t_decode, t_encode, t_misc;
#include <time.h>
#endif

#include "png.h"

#ifdef PNGTEST_TIMING
static float t_start, t_stop, t_decode, t_encode, t_misc;
#if !defined(PNG_READ_tIME_SUPPORTED) && !defined(PNG_WRITE_tIME_SUPPORTED)
#include <time.h>
#endif
#endif

#if defined(PNG_TIME_RFC1123_SUPPORTED)
static int tIME_chunk_present=0;
static char tIME_string[30] = "no tIME chunk present in file";
#endif /* PNG_TIME_RFC1123_SUPPORTED */

static int verbose = 0;

int test_one_file PNGARG((PNG_CONST char *inname, PNG_CONST char *outname));

#ifdef __TURBOC__
#include <mem.h>
#endif

/* defined so I can write to a file on gui/windowing platforms */
/*  #define STDERR stderr  */
#define STDERR stdout   /* for DOS */

/* example of using row callbacks to make a simple progress meter */
static int status_pass=1;
static int status_dots_requested=0;
static int status_dots=1;

void
read_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)
{
    if(png_ptr == NULL || row_number > PNG_MAX_UINT) return;
    if(status_pass != pass)
    {
       fprintf(stdout,"\n Pass %d: ",pass);
       status_pass = pass;
       status_dots = 31;
    }
    status_dots--;
    if(status_dots == 0)
    {
       fprintf(stdout, "\n         ");
       status_dots=30;
    }
    fprintf(stdout, "r");
}

void
write_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)
{
    if(png_ptr == NULL || row_number > PNG_MAX_UINT || pass > 7) return;
    fprintf(stdout, "w");
}


#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
/* Example of using user transform callback (we don't transform anything,
   but merely examine the row filters.  We set this to 256 rather than
   5 in case illegal filter values are present.) */
static png_uint_32 filters_used[256];
void
count_filters(png_structp png_ptr, png_row_infop row_info, png_bytep data)
{
    if(png_ptr != NULL && row_info != NULL)
      ++filters_used[*(data-1)];
}
#endif

#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
/* example of using user transform callback (we don't transform anything,
   but merely count the zero samples) */

static png_uint_32 zero_samples;

void
count_zero_samples(png_structp png_ptr, png_row_infop row_info, png_bytep data)
{
   png_bytep dp = data;
   if(png_ptr == NULL)return;

   /* contents of row_info:
    *  png_uint_32 width      width of row
    *  png_uint_32 rowbytes   number of bytes in row
    *  png_byte color_type    color type of pixels
    *  png_byte bit_depth     bit depth of samples
    *  png_byte channels      number of channels (1-4)
    *  png_byte pixel_depth   bits per pixel (depth*channels)
    */


    /* counts the number of zero samples (or zero pixels if color_type is 3 */

    if(row_info->color_type == 0 || row_info->color_type == 3)
    {
       int pos=0;
       png_uint_32 n, nstop;
       for (n=0, nstop=row_info->width; n<nstop; n++)
       {
          if(row_info->bit_depth == 1)
          {
             if(((*dp << pos++ )& 0x80) == 0) zero_samples++;
             if(pos == 8)
             {
                pos = 0;
                dp++;
             }
          }
          if(row_info->bit_depth == 2)
          {
             if(((*dp << (pos+=2))& 0xc0) == 0) zero_samples++;
             if(pos == 8)
             {
                pos = 0;
                dp++;
             }
          }
          if(row_info->bit_depth == 4)
          {
             if(((*dp << (pos+=4))& 0xf0) == 0) zero_samples++;
             if(pos == 8)
             {
                pos = 0;
                dp++;
             }
          }
          if(row_info->bit_depth == 8)
             if(*dp++ == 0) zero_samples++;
          if(row_info->bit_depth == 16)
          {
             if((*dp | *(dp+1)) == 0) zero_samples++;
             dp+=2;
          }
       }
    }
    else /* other color types */
    {
       png_uint_32 n, nstop;
       int channel;
       int color_channels = row_info->channels;
       if(row_info->color_type > 3)color_channels--;

       for (n=0, nstop=row_info->width; n<nstop; n++)
       {
          for (channel = 0; channel < color_channels; channel++)
          {
             if(row_info->bit_depth == 8)
                if(*dp++ == 0) zero_samples++;
             if(row_info->bit_depth == 16)
             {
                if((*dp | *(dp+1)) == 0) zero_samples++;
                dp+=2;
             }
          }
          if(row_info->color_type > 3)
          {
             dp++;
             if(row_info->bit_depth == 16)dp++;
          }
       }
    }
}
#endif /* PNG_WRITE_USER_TRANSFORM_SUPPORTED */

static int wrote_question = 0;

#if defined(PNG_NO_STDIO)
/* START of code to validate stdio-free compilation */
/* These copies of the default read/write functions come from pngrio.c and */
/* pngwio.c.  They allow "don't include stdio" testing of the library. */
/* This is the function that does the actual reading of data.  If you are
   not reading from a standard C stream, you should create a replacement
   read_data function and use it at run time with png_set_read_fn(), rather
   than changing the library. */
#ifndef USE_FAR_KEYWORD
static void
png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_size_t check;

   /* fread() returns 0 on error, so it is OK to store this in a png_size_t
    * instead of an int, which is what fread() actually returns.
    */
   check = (png_size_t)fread(data, (png_size_t)1, length,
      (FILE *)png_ptr->io_ptr);

   if (check != length)
   {
      png_error(png_ptr, "Read Error");
   }
}
#else
/* this is the model-independent version. Since the standard I/O library
   can't handle far buffers in the medium and small models, we have to copy
   the data.
*/

#define NEAR_BUF_SIZE 1024
#define MIN(a,b) (a <= b ? a : b)

static void
png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   int check;
   png_byte *n_data;
   FILE *io_ptr;

   /* Check if data really is near. If so, use usual code. */
   n_data = (png_byte *)CVT_PTR_NOCHECK(data);
   io_ptr = (FILE *)CVT_PTR(png_ptr->io_ptr);
   if ((png_bytep)n_data == data)
   {
      check = fread(n_data, 1, length, io_ptr);
   }
   else
   {
      png_byte buf[NEAR_BUF_SIZE];
      png_size_t read, remaining, err;
      check = 0;
      remaining = length;
      do
      {
         read = MIN(NEAR_BUF_SIZE, remaining);
         err = fread(buf, (png_size_t)1, read, io_ptr);
         png_memcpy(data, buf, read); /* copy far buffer to near buffer */
         if(err != read)
            break;
         else
            check += err;
         data += read;
         remaining -= read;
      }
      while (remaining != 0);
   }
   if (check != length)
   {
      png_error(png_ptr, "read Error");
   }
}
#endif /* USE_FAR_KEYWORD */

#if defined(PNG_WRITE_FLUSH_SUPPORTED)
static void
png_default_flush(png_structp png_ptr)
{
   FILE *io_ptr;
   io_ptr = (FILE *)CVT_PTR((png_ptr->io_ptr));
   if (io_ptr != NULL)
      fflush(io_ptr);
}
#endif

/* This is the function that does the actual writing of data.  If you are
   not writing to a standard C stream, you should create a replacement
   write_data function and use it at run time with png_set_write_fn(), rather
   than changing the library. */
#ifndef USE_FAR_KEYWORD
static void
png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_uint_32 check;

   check = fwrite(data, 1, length, (FILE *)(png_ptr->io_ptr));
   if (check != length)
   {
      png_error(png_ptr, "Write Error");
   }
}
#else
/* this is the model-independent version. Since the standard I/O library
   can't handle far buffers in the medium and small models, we have to copy
   the data.
*/

#define NEAR_BUF_SIZE 1024
#define MIN(a,b) (a <= b ? a : b)

static void
png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_uint_32 check;
   png_byte *near_data;  /* Needs to be "png_byte *" instead of "png_bytep" */
   FILE *io_ptr;

   /* Check if data really is near. If so, use usual code. */
   near_data = (png_byte *)CVT_PTR_NOCHECK(data);
   io_ptr = (FILE *)CVT_PTR(png_ptr->io_ptr);
   if ((png_bytep)near_data == data)
   {
      check = fwrite(near_data, 1, length, io_ptr);
   }
   else
   {
      png_byte buf[NEAR_BUF_SIZE];
      png_size_t written, remaining, err;
      check = 0;
      remaining = length;
      do
      {
         written = MIN(NEAR_BUF_SIZE, remaining);
         png_memcpy(buf, data, written); /* copy far buffer to near buffer */
         err = fwrite(buf, 1, written, io_ptr);
         if (err != written)
            break;
         else
            check += err;
         data += written;
         remaining -= written;
      }
      while (remaining != 0);
   }
   if (check != length)
   {
      png_error(png_ptr, "Write Error");
   }
}

#endif /* USE_FAR_KEYWORD */

/* This function is called when there is a warning, but the library thinks
 * it can continue anyway.  Replacement functions don't have to do anything
 * here if you don't want to.  In the default configuration, png_ptr is
 * not used, but it is passed in case it may be useful.
 */
static void
png_default_warning(png_structp png_ptr, png_const_charp message)
{
   PNG_CONST char *name = "UNKNOWN (ERROR!)";
   if (png_ptr != NULL && png_ptr->error_ptr != NULL)
      name = png_ptr->error_ptr;
   fprintf(STDERR, "%s: libpng warning: %s\n", name, message);
}

/* This is the default error handling function.  Note that replacements for
 * this function MUST NOT RETURN, or the program will likely crash.  This
 * function is used by default, or if the program supplies NULL for the
 * error function pointer in png_set_error_fn().
 */
static void
png_default_error(png_structp png_ptr, png_const_charp message)
{
   png_default_warning(png_ptr, message);
   /* We can return because png_error calls the default handler, which is
    * actually OK in this case. */
}
#endif /* PNG_NO_STDIO */
/* END of code to validate stdio-free compilation */

/* START of code to validate memory allocation and deallocation */
#ifdef PNG_USER_MEM_SUPPORTED

/* Allocate memory.  For reasonable files, size should never exceed
   64K.  However, zlib may allocate more then 64K if you don't tell
   it not to.  See zconf.h and png.h for more information.  zlib does
   need to allocate exactly 64K, so whatever you call here must
   have the ability to do that.

   This piece of code can be compiled to validate max 64K allocations
   by setting MAXSEG_64K in zlib zconf.h *or* PNG_MAX_MALLOC_64K. */
typedef struct memory_information {
   png_uint_32                    size;
   png_voidp                 pointer;
   struct memory_information FAR *next;
} memory_information;
typedef memory_information FAR *memory_infop;

static memory_infop pinformation = NULL;
static int current_allocation = 0;
static int maximum_allocation = 0;

extern PNG_EXPORT(png_voidp,png_debug_malloc) PNGARG((png_structp png_ptr,
   png_uint_32 size));
extern PNG_EXPORT(void,png_debug_free) PNGARG((png_structp png_ptr,
   png_voidp ptr));

png_voidp
png_debug_malloc(png_structp png_ptr, png_uint_32 size) {

   /* png_malloc has already tested for NULL; png_create_struct calls
      png_debug_malloc directly, with png_ptr == NULL which is OK */

   if (size == 0)
      return (png_voidp)(NULL);

   /* This calls the library allocator twice, once to get the requested
      buffer and once to get a new free list entry. */
   {
      memory_infop pinfo = png_malloc_default(png_ptr, sizeof *pinfo);
      pinfo->size = size;
      current_allocation += size;
      if (current_allocation > maximum_allocation)
         maximum_allocation = current_allocation;
      pinfo->pointer = png_malloc_default(png_ptr, size);
      pinfo->next = pinformation;
      pinformation = pinfo;
      /* Make sure the caller isn't assuming zeroed memory. */
      png_memset(pinfo->pointer, 0xdd, pinfo->size);
      return (png_voidp)(pinfo->pointer);
   }
}

/* Free a pointer.  It is removed from the list at the same time. */
void
png_debug_free(png_structp png_ptr, png_voidp ptr)
{
   if (png_ptr == NULL)
      fprintf(STDERR, "NULL pointer to png_debug_free.\n");
   if (ptr == 0) {
#if 0 /* This happens all the time. */
      fprintf(STDERR, "WARNING: freeing NULL pointer\n");
#endif
      return;
   }

   /* Unlink the element from the list. */
   {
      memory_infop FAR *ppinfo = &pinformation;
      for (;;) {
         memory_infop pinfo = *ppinfo;
         if (pinfo->pointer == ptr) {
            *ppinfo = pinfo->next;
            current_allocation -= pinfo->size;
            if (current_allocation < 0)
               fprintf(STDERR, "Duplicate free of memory\n");
            /* We must free the list element too, but first kill
               the memory that is to be freed. */
            memset(ptr, 0x55, pinfo->size);
            png_free_default(png_ptr, pinfo);
            break;
         }
         if (pinfo->next == NULL) {
            fprintf(STDERR, "Pointer %x not found\n", ptr);
            break;
         }
         ppinfo = &pinfo->next;
      }
   }

   /* Finally free the data. */
   png_free_default(png_ptr, ptr);
}
#endif /* PNG_USER_MEM_SUPPORTED */
/* END of code to test memory allocation/deallocation */

/* Test one file */
int
test_one_file(PNG_CONST char *inname, PNG_CONST char *outname)
{
   static FILE *fpin, *fpout;  /* "static" prevents setjmp corruption */
   png_structp read_ptr, write_ptr;
   png_infop read_info_ptr, write_info_ptr, end_info_ptr;
   png_bytep row_buf;
   png_uint_32 y;
   png_uint_32 width, height;
   int num_pass, pass;
   int bit_depth, color_type;
#ifdef USE_FAR_KEYWORD
   jmp_buf jmpbuf;
#endif   

   char inbuf[256], outbuf[256];

   row_buf = (png_bytep)NULL;

   if ((fpin = fopen(inname, "rb")) == NULL)
   {
      fprintf(STDERR, "Could not find input file %s\n", inname);
      return (1);
   }

   if ((fpout = fopen(outname, "wb")) == NULL)
   {
      fprintf(STDERR, "Could not open output file %s\n", outname);
      fclose(fpin);
      return (1);
   }

   png_debug(0, "Allocating read and write structures\n");
#ifdef PNG_USER_MEM_SUPPORTED
   read_ptr = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, (png_voidp)NULL,
      (png_error_ptr)NULL, (png_error_ptr)NULL, (png_voidp)NULL,
      (png_malloc_ptr)png_debug_malloc, (png_free_ptr)png_debug_free);
#else
   read_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, (png_voidp)NULL,
      (png_error_ptr)NULL, (png_error_ptr)NULL);
#endif
#if defined(PNG_NO_STDIO)
   png_set_error_fn(read_ptr, (png_voidp)inname, png_default_error,
       png_default_warning);
#endif
#ifdef PNG_USER_MEM_SUPPORTED
   write_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, (png_voidp)NULL,
      (png_error_ptr)NULL, (png_error_ptr)NULL, (png_voidp)NULL,
      (png_malloc_ptr)png_debug_malloc, (png_free_ptr)png_debug_free);
#else
   write_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, (png_voidp)NULL,
      (png_error_ptr)NULL, (png_error_ptr)NULL);
#endif
#if defined(PNG_NO_STDIO)
   png_set_error_fn(write_ptr, (png_voidp)inname, png_default_error,
       png_default_warning);
#endif
   png_debug(0, "Allocating read_info, write_info and end_info structures\n");
   read_info_ptr = png_create_info_struct(read_ptr);
   write_info_ptr = png_create_info_struct(write_ptr);
   end_info_ptr = png_create_info_struct(read_ptr);
#ifdef PNG_USER_MEM_SUPPORTED
#endif

   png_debug(0, "Setting jmpbuf for read struct\n");
#ifdef USE_FAR_KEYWORD
   if (setjmp(jmpbuf))
#else
   if (setjmp(read_ptr->jmpbuf))
#endif
   {
      fprintf(STDERR, "%s -> %s: libpng read error\n", inname, outname);
      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
      png_destroy_write_struct(&write_ptr, &write_info_ptr);
      fclose(fpin);
      fclose(fpout);
      return (1);
   }
#ifdef USE_FAR_KEYWORD
   png_memcpy(read_ptr->jmpbuf,jmpbuf,sizeof(jmp_buf));
#endif

   png_debug(0, "Setting jmpbuf for write struct\n");
#ifdef USE_FAR_KEYWORD
   if (setjmp(jmpbuf))
#else
   if (setjmp(write_ptr->jmpbuf))
#endif
   {
      fprintf(STDERR, "%s -> %s: libpng write error\n", inname, outname);
      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
      png_destroy_write_struct(&write_ptr, &write_info_ptr);
      fclose(fpin);
      fclose(fpout);
      return (1);
   }
#ifdef USE_FAR_KEYWORD
   png_memcpy(write_ptr->jmpbuf,jmpbuf,sizeof(jmp_buf));
#endif

   png_debug(0, "Initializing input and output streams\n");
#if !defined(PNG_NO_STDIO)
   png_init_io(read_ptr, fpin);
   png_init_io(write_ptr, fpout);
#else
   png_set_read_fn(read_ptr, (png_voidp)fpin, png_default_read_data);
   png_set_write_fn(write_ptr, (png_voidp)fpout,  png_default_write_data,
#if defined(PNG_WRITE_FLUSH_SUPPORTED)
      png_default_flush);
#else
      NULL);
#endif
#endif
   if(status_dots_requested == 1)
   {
      png_set_write_status_fn(write_ptr, write_row_callback);
      png_set_read_status_fn(read_ptr, read_row_callback);
   }
   else
   {
      png_set_write_status_fn(write_ptr, NULL);
      png_set_read_status_fn(read_ptr, NULL);
   }

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
   {
     int i;
     for(i=0; i<256; i++)
        filters_used[i]=0;
     png_set_read_user_transform_fn(read_ptr, count_filters);
   }
#endif
#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
   zero_samples=0;
   png_set_write_user_transform_fn(write_ptr, count_zero_samples);
#endif

   png_debug(0, "Reading info struct\n");
   png_read_info(read_ptr, read_info_ptr);

   png_debug(0, "Transferring info struct\n");
   {
      int interlace_type, compression_type, filter_type;

      if (png_get_IHDR(read_ptr, read_info_ptr, &width, &height, &bit_depth,
          &color_type, &interlace_type, &compression_type, &filter_type))
      {
         png_set_IHDR(write_ptr, write_info_ptr, width, height, bit_depth,
#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
            color_type, interlace_type, compression_type, filter_type);
#else
            color_type, PNG_INTERLACE_NONE, compression_type, filter_type);
#endif
      }
   }
#if defined(PNG_READ_bKGD_SUPPORTED) && defined(PNG_WRITE_bKGD_SUPPORTED)
   {
      png_color_16p background;

      if (png_get_bKGD(read_ptr, read_info_ptr, &background))
      {
         png_set_bKGD(write_ptr, write_info_ptr, background);
      }
   }
#endif
#if defined(PNG_READ_cHRM_SUPPORTED) && defined(PNG_WRITE_cHRM_SUPPORTED)
   {
      double white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;

      if (png_get_cHRM(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,
         &red_y, &green_x, &green_y, &blue_x, &blue_y))
      {
         png_set_cHRM(write_ptr, write_info_ptr, white_x, white_y, red_x,
            red_y, green_x, green_y, blue_x, blue_y);
      }
   }
#endif
#if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_WRITE_gAMA_SUPPORTED)
   {
      double gamma;

      if (png_get_gAMA(read_ptr, read_info_ptr, &gamma))
      {
         png_set_gAMA(write_ptr, write_info_ptr, gamma);
      }
   }
#endif
#if defined(PNG_READ_sRGB_SUPPORTED) && defined(PNG_WRITE_sRGB_SUPPORTED)
   {
      int intent;

      if (png_get_sRGB(read_ptr, read_info_ptr, &intent))
      {
         png_set_sRGB(write_ptr, write_info_ptr, intent);
      }
   }
#endif
#if defined(PNG_READ_hIST_SUPPORTED) && defined(PNG_WRITE_hIST_SUPPORTED)
   {
      png_uint_16p hist;

      if (png_get_hIST(read_ptr, read_info_ptr, &hist))
      {
         png_set_hIST(write_ptr, write_info_ptr, hist);
      }
   }
#endif
#if defined(PNG_READ_oFFs_SUPPORTED) && defined(PNG_WRITE_oFFs_SUPPORTED)
   {
      png_uint_32 offset_x, offset_y;
      int unit_type;

      if (png_get_oFFs(read_ptr, read_info_ptr,&offset_x,&offset_y,&unit_type))
      {
         png_set_oFFs(write_ptr, write_info_ptr, offset_x, offset_y, unit_type);
      }
   }
#endif
#if defined(PNG_READ_pCAL_SUPPORTED) && defined(PNG_WRITE_pCAL_SUPPORTED)
   {
      png_charp purpose, units;
      png_charpp params;
      png_int_32 X0, X1;
      int type, nparams;

      if (png_get_pCAL(read_ptr, read_info_ptr, &purpose, &X0, &X1, &type,
         &nparams, &units, &params))
      {
         png_set_pCAL(write_ptr, write_info_ptr, purpose, X0, X1, type,
            nparams, units, params);
      }
   }
#endif
#if defined(PNG_READ_pHYs_SUPPORTED) && defined(PNG_WRITE_pHYs_SUPPORTED)
   {
      png_uint_32 res_x, res_y;
      int unit_type;

      if (png_get_pHYs(read_ptr, read_info_ptr, &res_x, &res_y, &unit_type))
      {
         png_set_pHYs(write_ptr, write_info_ptr, res_x, res_y, unit_type);
      }
   }
#endif
   {
      png_colorp palette;
      int num_palette;

      if (png_get_PLTE(read_ptr, read_info_ptr, &palette, &num_palette))
      {
         png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);
      }
   }
#if defined(PNG_READ_sBIT_SUPPORTED) && defined(PNG_WRITE_sBIT_SUPPORTED)
   {
      png_color_8p sig_bit;

      if (png_get_sBIT(read_ptr, read_info_ptr, &sig_bit))
      {
         png_set_sBIT(write_ptr, write_info_ptr, sig_bit);
      }
   }
#endif
#if (defined(PNG_READ_tEXt_SUPPORTED) && defined(PNG_WRITE_tEXt_SUPPORTED)) || \
    (defined(PNG_READ_zTXt_SUPPORTED) && defined(PNG_WRITE_zTXt_SUPPORTED))
   {
      png_textp text_ptr;
      int num_text;

      if (png_get_text(read_ptr, read_info_ptr, &text_ptr, &num_text) > 0)
      {
         png_debug1(0, "Handling %d tEXt/zTXt chunks\n", num_text);
         png_set_text(write_ptr, write_info_ptr, text_ptr, num_text);
      }
   }
#endif
#if defined(PNG_READ_tIME_SUPPORTED) && defined(PNG_WRITE_tIME_SUPPORTED)
   {
      png_timep mod_time;

      if (png_get_tIME(read_ptr, read_info_ptr, &mod_time))
      {
         png_set_tIME(write_ptr, write_info_ptr, mod_time);
#if defined(PNG_TIME_RFC1123_SUPPORTED)
         /* we have to use png_strcpy instead of "=" because the string
            pointed to by png_convert_to_rfc1123() gets free'ed before
            we use it */
         png_strcpy(tIME_string,png_convert_to_rfc1123(read_ptr, mod_time));
         tIME_chunk_present++;
#endif /* PNG_TIME_RFC1123_SUPPORTED */
      }
   }
#endif
#if defined(PNG_READ_tRNS_SUPPORTED) && defined(PNG_WRITE_tRNS_SUPPORTED)
   {
      png_bytep trans;
      int num_trans;
      png_color_16p trans_values;

      if (png_get_tRNS(read_ptr, read_info_ptr, &trans, &num_trans,
         &trans_values))
      {
         png_set_tRNS(write_ptr, write_info_ptr, trans, num_trans,
            trans_values);
      }
   }
#endif

   png_debug(0, "\nWriting info struct\n");
   png_write_info(write_ptr, write_info_ptr);

   png_debug(0, "\nAllocating row buffer \n");
   row_buf = (png_bytep)png_malloc(read_ptr,
      png_get_rowbytes(read_ptr, read_info_ptr));
   if (row_buf == NULL)
   {
      fprintf(STDERR, "No memory to allocate row buffer\n");
      png_destroy_read_struct(&read_ptr, &read_info_ptr, (png_infopp)NULL);
      png_destroy_write_struct(&write_ptr, &write_info_ptr);
      fclose(fpin);
      fclose(fpout);
      return (1);
   }
   png_debug(0, "Writing row data\n");

#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
  defined(PNG_WRITE_INTERLACING_SUPPORTED)
   num_pass = png_set_interlace_handling(read_ptr);
   png_set_interlace_handling(write_ptr);
#else
   num_pass=1;
#endif

#ifdef PNGTEST_TIMING
   t_stop = (float)clock();
   t_misc += (t_stop - t_start);
   t_start = t_stop;
#endif
   for (pass = 0; pass < num_pass; pass++)
   {
      png_debug1(0, "Writing row data for pass %d\n",pass);
      for (y = 0; y < height; y++)
      {
         png_read_rows(read_ptr, (png_bytepp)&row_buf, (png_bytepp)NULL, 1);
#ifdef PNGTEST_TIMING
         t_stop = (float)clock();
         t_decode += (t_stop - t_start);
         t_start = t_stop;
#endif
         png_write_rows(write_ptr, (png_bytepp)&row_buf, 1);
#ifdef PNGTEST_TIMING
         t_stop = (float)clock();
         t_encode += (t_stop - t_start);
         t_start = t_stop;
#endif
      }
   }

   png_debug(0, "Reading and writing end_info data\n");
   png_read_end(read_ptr, end_info_ptr);
   png_write_end(write_ptr, end_info_ptr);

#ifdef PNG_EASY_ACCESS_SUPPORTED
   if(verbose)
   {
      png_uint_32 iwidth, iheight;
      iwidth = png_get_image_width(write_ptr, write_info_ptr);
      iheight = png_get_image_height(write_ptr, write_info_ptr);
      fprintf(STDERR, "Image width = %lu, height = %lu\n",
         iwidth, iheight);
   }
#endif

   png_debug(0, "Destroying data structs\n");
   png_free(read_ptr, row_buf);
   png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
   png_destroy_write_struct(&write_ptr, &write_info_ptr);

   fclose(fpin);
   fclose(fpout);

   png_debug(0, "Opening files for comparison\n");
   if ((fpin = fopen(inname, "rb")) == NULL)
   {
      fprintf(STDERR, "Could not find file %s\n", inname);
      return (1);
   }

   if ((fpout = fopen(outname, "rb")) == NULL)
   {
      fprintf(STDERR, "Could not find file %s\n", outname);
      fclose(fpin);
      return (1);
   }

   for(;;)
   {
      png_size_t num_in, num_out;

      num_in = fread(inbuf, 1, 1, fpin);
      num_out = fread(outbuf, 1, 1, fpout);

      if (num_in != num_out)
      {
         fprintf(STDERR, "Files %s and %s are of a different size\n",
                 inname, outname);
         if(wrote_question == 0)
         {
            fprintf(STDERR,
              "   Was %s written with the same chunk size (8k),",inname);
            fprintf(STDERR,
              " filtering\n   heuristic (libpng default), compression");
            fprintf(STDERR,
              " level (zlib default)\n   and zlib version (%s)?\n\n",
              ZLIB_VERSION);
            wrote_question=1;
         }
         fclose(fpin);
         fclose(fpout);
         return (0);
      }

      if (!num_in)
         break;

      if (png_memcmp(inbuf, outbuf, num_in))
      {
         fprintf(STDERR, "\nFiles %s and %s are different\n", inname, outname);
         if(wrote_question == 0)
         {
            fprintf(STDERR,
              "   Was %s written with the same chunk size (8k),",inname);
            fprintf(STDERR,
              " filtering\n   heuristic (libpng default), compression");
            fprintf(STDERR,
              " level (zlib default)\n   and zlib version (%s)?\n\n",
              ZLIB_VERSION);
            wrote_question=1;
         }
         fclose(fpin);
         fclose(fpout);
         return (0);
      }
   }

   fclose(fpin);
   fclose(fpout);

   return (0);
}

/* input and output filenames */
#ifdef RISCOS
static PNG_CONST char *inname = "pngtest/png";
static PNG_CONST char *outname = "pngout/png";
#else
static PNG_CONST char *inname = "pngtest.png";
static PNG_CONST char *outname = "pngout.png";
#endif

int
main(int argc, char *argv[])
{
   int multiple = 0;
   int ierror = 0;

   fprintf(STDERR, "Testing libpng version %s\n", PNG_LIBPNG_VER_STRING);
   fprintf(STDERR, "   with zlib   version %s\n", ZLIB_VERSION);
   fprintf(STDERR,"%s",png_get_copyright(NULL));

   /* Do some consistency checking on the memory allocation settings, I'm
      not sure this matters, but it is nice to know, the first of these
      tests should be impossible because of the way the macros are set
      in pngconf.h */
#if defined(MAXSEG_64K) && !defined(PNG_MAX_MALLOC_64K)
      fprintf(STDERR, " NOTE: Zlib compiled for max 64k, libpng not\n");
#endif
   /* I think the following can happen. */
#if !defined(MAXSEG_64K) && defined(PNG_MAX_MALLOC_64K)
      fprintf(STDERR, " NOTE: libpng compiled for max 64k, zlib not\n");
#endif

   if (strcmp(png_libpng_ver, PNG_LIBPNG_VER_STRING))
   {
      fprintf(STDERR,
         "Warning: versions are different between png.h and png.c\n");
      fprintf(STDERR, "  png.h version: %s\n", PNG_LIBPNG_VER_STRING);
      fprintf(STDERR, "  png.c version: %s\n\n", png_libpng_ver);
      ++ierror;
   }

   if (argc > 1)
   {
      if (strcmp(argv[1], "-m") == 0)
      {
         multiple = 1;
         status_dots_requested = 0;
      }
      else if (strcmp(argv[1], "-mv") == 0 ||
               strcmp(argv[1], "-vm") == 0 )
      {
         multiple = 1;
         verbose = 1;
         status_dots_requested = 1;
      }
      else if (strcmp(argv[1], "-v") == 0)
      {
         verbose = 1;
         status_dots_requested = 1;
         inname = argv[2];
      }
      else
      {
         inname = argv[1];
         status_dots_requested = 0;
      }
   }

   if (!multiple && argc == 3+verbose)
     outname = argv[2+verbose];

   if ((!multiple && argc > 3+verbose) || (multiple && argc < 2))
   {
     fprintf(STDERR,
       "usage: %s [infile.png] [outfile.png]\n\t%s -m {infile.png}\n",
        argv[0], argv[0]);
     fprintf(STDERR,
       "  reads/writes one PNG file (without -m) or multiple files (-m)\n");
     fprintf(STDERR,
       "  with -m %s is used as a temporary file\n", outname);
     exit(1);
   }

   if (multiple)
   {
      int i;
#ifdef PNG_USER_MEM_SUPPORTED
      int allocation_now = current_allocation;
#endif
      for (i=2; i<argc; ++i)
      {
         int k, kerror;
         fprintf(STDERR, "Testing %s:",argv[i]);
         kerror = test_one_file(argv[i], outname);
         if (kerror == 0)
         {
#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
            fprintf(STDERR, " PASS (%lu zero samples)\n",zero_samples);
#else
            fprintf(STDERR, " PASS\n");
#endif
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
            for (k=0; k<256; k++)
               if(filters_used[k])
                  fprintf(STDERR, " Filter %d was used %lu times\n",
                     k,filters_used[k]);
#endif
#if defined(PNG_TIME_RFC1123_SUPPORTED)
         if(tIME_chunk_present != 0)
            fprintf(STDERR, " tIME = %s\n",tIME_string);
         tIME_chunk_present = 0;
#endif /* PNG_TIME_RFC1123_SUPPORTED */
         }
         else
         {
            fprintf(STDERR, " FAIL\n");
            ierror += kerror;
         }
#ifdef PNG_USER_MEM_SUPPORTED
         if (allocation_now != current_allocation)
            fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n",
               current_allocation-allocation_now);
         if (current_allocation != 0) {
            memory_infop pinfo = pinformation;

            fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n",
               current_allocation);
            while (pinfo != NULL) {
               fprintf(STDERR, " %d bytes at %x\n", pinfo->size, pinfo->pointer);
               pinfo = pinfo->next;
               }
         }
#endif
      }
#ifdef PNG_USER_MEM_SUPPORTED
         fprintf(STDERR, " Current memory allocation: %d bytes\n",
            current_allocation);
         fprintf(STDERR, " Maximum memory allocation: %d bytes\n",
            maximum_allocation);
#endif
   }
   else
   {
      int i;
      for (i=0; i<3; ++i) {
         int kerror;
#ifdef PNG_USER_MEM_SUPPORTED
         int allocation_now = current_allocation;
#endif
         if (i == 1) status_dots_requested = 1;
         else if(verbose == 0)status_dots_requested = 0;
         if (i == 0 || verbose == 1 || ierror != 0)
            fprintf(STDERR, "Testing %s:",inname);
         kerror = test_one_file(inname, outname);
         if(kerror == 0)
         {
            if(verbose == 1 || i == 2)
            {
                int k;
#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
                fprintf(STDERR, " PASS (%lu zero samples)\n",zero_samples);
#else
                fprintf(STDERR, " PASS\n");
#endif
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
                for (k=0; k<256; k++)
                   if(filters_used[k])
                      fprintf(STDERR, " Filter %d was used %lu times\n",
                         k,filters_used[k]);
#endif
#if defined(PNG_TIME_RFC1123_SUPPORTED)
             if(tIME_chunk_present != 0)
                fprintf(STDERR, " tIME = %s\n",tIME_string);
#endif /* PNG_TIME_RFC1123_SUPPORTED */
            }
         }
         else
         {
            if(verbose == 0 && i != 2)
               fprintf(STDERR, "Testing %s:",inname);
            fprintf(STDERR, " FAIL\n");
            ierror += kerror;
         }
#ifdef PNG_USER_MEM_SUPPORTED
         if (allocation_now != current_allocation)
             fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n",
               current_allocation-allocation_now);
         if (current_allocation != 0) {
             memory_infop pinfo = pinformation;

             fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n",
                current_allocation);
             while (pinfo != NULL) {
                fprintf(STDERR, " %d bytes at %x\n", pinfo->size, pinfo->pointer);
                pinfo = pinfo->next;
             }
          }
#endif
       }
#ifdef PNG_USER_MEM_SUPPORTED
       fprintf(STDERR, " Current memory allocation: %d bytes\n",
          current_allocation);
       fprintf(STDERR, " Maximum memory allocation: %d bytes\n",
          maximum_allocation);
#endif
   }

#ifdef PNGTEST_TIMING
   t_stop = (float)clock();
   t_misc += (t_stop - t_start);
   t_start = t_stop;
   fprintf(STDERR," CPU time used = %.3f seconds",
      (t_misc+t_decode+t_encode)/(float)CLOCKS_PER_SEC);
   fprintf(STDERR," (decoding %.3f,\n",
      t_decode/(float)CLOCKS_PER_SEC);
   fprintf(STDERR,"        encoding %.3f ,",
      t_encode/(float)CLOCKS_PER_SEC);
   fprintf(STDERR," other %.3f seconds)\n\n",
      t_misc/(float)CLOCKS_PER_SEC);
#endif

   if (ierror == 0)
      fprintf(STDERR, "libpng passes test\n");
   else
      fprintf(STDERR, "libpng FAILS test\n");
   return (int)(ierror != 0);
}

/* Generate a compiler error if there is an old png.h in the search path. */
void
png_check_pngtest_version
   (version_1_0_5 png_h_is_not_version_1_0_5)
{
   if(png_h_is_not_version_1_0_5 == NULL) return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\pngvcrd.cpp ===
/* pngvcrd.c - mixed C/assembler version of utilities to read a PNG file
 *
 * For Intel x86 CPU and Microsoft Visual C++ compiler
 *
 * libpng 1.0.5 - October 15, 1999
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998, Intel Corporation
 * Copyright (c) 1998, 1999 Glenn Randers-Pehrson
 *
 * Contributed by Nirav Chhatrapati, Intel Corporation, 1998
 * Interface to libpng contributed by Gilles Vollant, 1999
 *
 */

#define PNG_INTERNAL
#include "png.h"

namespace D3DX
{

#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_USE_PNGVCRD)

static int mmx_supported=2;

void
png_read_filter_row_c(png_structp png_ptr, png_row_infop row_info,
   png_bytep row, png_bytep prev_row, int filter);

static int mmxsupport()
{
  int mmx_supported_local = 0;
  _asm {
    pushfd            //Save Eflag to stack
    pop eax           //Get Eflag from stack into eax
    mov ecx, eax      //Make another copy of Eflag in ecx
    xor eax, 0x200000 //Toggle ID bit in Eflag [i.e. bit(21)]
    push eax          //Save modified Eflag back to stack

    popfd             //Restored modified value back to Eflag reg
    pushfd            //Save Eflag to stack
    pop eax           //Get Eflag from stack
    xor eax, ecx      //Compare the new Eflag with the original Eflag
    jz NOT_SUPPORTED  //If the same, CPUID instruction is not supported,
                      //skip following instructions and jump to
                      //NOT_SUPPORTED label

    xor eax, eax      //Set eax to zero

    _asm _emit 0x0f   //CPUID instruction  (two bytes opcode)
    _asm _emit 0xa2

    cmp eax, 1        //make sure eax return non-zero value
    jl NOT_SUPPORTED  //If eax is zero, mmx not supported

    xor eax, eax      //set eax to zero
    inc eax           //Now increment eax to 1.  This instruction is
                      //faster than the instruction "mov eax, 1"

    _asm _emit 0x0f   //CPUID instruction
    _asm _emit 0xa2

    and edx, 0x00800000  //mask out all bits but mmx bit(24)
    cmp edx, 0        // 0 = mmx not supported
    jz  NOT_SUPPORTED // non-zero = Yes, mmx IS supported

    mov  mmx_supported_local, 1  //set return value to 1

NOT_SUPPORTED:
    mov  eax, mmx_supported_local  //move return value to eax

  }

  //mmx_supported_local=0; // test code for force don't support MMX
  //printf("MMX : %u (1=MMX supported)\n",mmx_supported_local);

  return mmx_supported_local;
}

/* Combines the row recently read in with the previous row.
   This routine takes care of alpha and transparency if requested.
   This routine also handles the two methods of progressive display
   of interlaced images, depending on the mask value.
   The mask value describes which pixels are to be combined with
   the row.  The pattern always repeats every 8 pixels, so just 8
   bits are needed.  A one indicates the pixel is to be combined; a
   zero indicates the pixel is to be skipped.  This is in addition
   to any alpha or transparency value associated with the pixel.  If
   you want all pixels to be combined, pass 0xff (255) in mask.  */

/* Use this routine for x86 platform - uses faster MMX routine if machine
   supports MMX */

void
png_combine_row(png_structp png_ptr, png_bytep row, int mask)
{
#ifdef DISABLE_PNGVCRD_COMBINE
   int save_mmx_supported = mmx_supported;
#endif

   png_debug(1,"in png_combine_row_asm\n");

#ifdef DISABLE_PNGVCRD_COMBINE
   if ((png_ptr->transformations & PNG_INTERLACE) && png_ptr->pass != 6)
       mmx_supported = 0;
   else
#endif
       if (mmx_supported == 2)
           mmx_supported = mmxsupport();

   if (mask == 0xff)
   {
      png_memcpy(row, png_ptr->row_buf + 1,
       (png_size_t)((png_ptr->width * png_ptr->row_info.pixel_depth + 7) >> 3));
   }
   /* GRR:  add "else if (mask == 0)" case?
    *       or does png_combine_row() not even get called in that case? */
   else
   {
      switch (png_ptr->row_info.pixel_depth)
      {
         case 1:
         {
            png_bytep sp;
            png_bytep dp;
            int s_inc, s_start, s_end;
            int m;
            int shift;
            png_uint_32 i;

            sp = png_ptr->row_buf + 1;
            dp = row;
            m = 0x80;
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
                s_start = 0;
                s_end = 7;
                s_inc = 1;
            }
            else
#endif
            {
                s_start = 7;
                s_end = 0;
                s_inc = -1;
            }

            shift = s_start;

            for (i = 0; i < png_ptr->width; i++)
            {
               if (m & mask)
               {
                  int value;

                  value = (*sp >> shift) & 0x1;
                  *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;

               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }

         case 2:
         {
            png_bytep sp;
            png_bytep dp;
            int s_start, s_end, s_inc;
            int m;
            int shift;
            png_uint_32 i;
            int value;

            sp = png_ptr->row_buf + 1;
            dp = row;
            m = 0x80;
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
               s_start = 0;
               s_end = 6;
               s_inc = 2;
            }
            else
#endif
            {
               s_start = 6;
               s_end = 0;
               s_inc = -2;
            }

            shift = s_start;

            for (i = 0; i < png_ptr->width; i++)
            {
               if (m & mask)
               {
                  value = (*sp >> shift) & 0x3;
                  *dp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;
               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }

         case 4:
         {
            png_bytep sp;
            png_bytep dp;
            int s_start, s_end, s_inc;
            int m;
            int shift;
            png_uint_32 i;
            int value;

            sp = png_ptr->row_buf + 1;
            dp = row;
            m = 0x80;
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
               s_start = 0;
               s_end = 4;
               s_inc = 4;
            }
            else
#endif
            {
               s_start = 4;
               s_end = 0;
               s_inc = -4;
            }
            shift = s_start;

            for (i = 0; i < png_ptr->width; i++)
            {
               if (m & mask)
               {
                  value = (*sp >> shift) & 0xf;
                  *dp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;
               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }

         case 8:
         {
            png_bytep srcptr;
            png_bytep dstptr;
            png_uint_32 len;
            int m;
            int diff, unmask;

            __int64 mask0=0x0102040810204080;

            if (mmx_supported)
            {
               srcptr = png_ptr->row_buf + 1;
               dstptr = row;
               m = 0x80;
               unmask = ~mask;
               len  = png_ptr->width &~7;  //reduce to multiple of 8
               diff = png_ptr->width & 7;  //amount lost

               _asm
               {
                  movd       mm7, unmask   //load bit pattern
                  psubb      mm6,mm6       //zero mm6
                  punpcklbw  mm7,mm7
                  punpcklwd  mm7,mm7
                  punpckldq  mm7,mm7       //fill register with 8 masks

                  movq       mm0,mask0

                  pand       mm0,mm7       //nonzero if keep byte
                  pcmpeqb    mm0,mm6       //zeros->1s, v versa

                  mov        ecx,len       //load length of line (pixels)
                  mov        esi,srcptr    //load source
                  mov        ebx,dstptr    //load dest
                  cmp        ecx,0         //lcr
                  je         mainloop8end

mainloop8:
                  movq       mm4,[esi]
                  pand       mm4,mm0
                  movq       mm6,mm0
                  pandn      mm6,[ebx]
                  por        mm4,mm6
                  movq       [ebx],mm4

                  add        esi,8         //inc by 8 bytes processed
                  add        ebx,8
                  sub        ecx,8         //dec by 8 pixels processed

                  ja         mainloop8
mainloop8end:

                  mov        ecx,diff
                  cmp        ecx,0
                  jz         end8

                  mov        edx,mask
                  sal        edx,24        //make low byte the high byte

secondloop8:
                  sal        edx,1         //move high bit to CF
                  jnc        skip8         //if CF = 0
                  mov        al,[esi]
                  mov        [ebx],al
skip8:
                  inc        esi
                  inc        ebx

                  dec        ecx
                  jnz        secondloop8
end8:
                  emms
               }
            }
            else /* mmx not supported - use modified C routine */
            {
               register unsigned int incr1, initial_val, final_val;
               png_size_t pixel_bytes;
               png_uint_32 i;
               register int disp = png_pass_inc[png_ptr->pass];
               int offset_table[7] = {0, 4, 0, 2, 0, 1, 0};

               pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
               srcptr = png_ptr->row_buf + 1 + offset_table[png_ptr->pass]*
                  pixel_bytes;
               dstptr = row + offset_table[png_ptr->pass]*pixel_bytes;
               initial_val = offset_table[png_ptr->pass]*pixel_bytes;
               final_val = png_ptr->width*pixel_bytes;
               incr1 = (disp)*pixel_bytes;
               for (i = initial_val; i < final_val; i += incr1)
               {
                  png_memcpy(dstptr, srcptr, pixel_bytes);
                  srcptr += incr1;
                  dstptr += incr1;
               }
            } /* end of else */

            break;
         }       // end 8 bpp

         case 16:
         {
            png_bytep srcptr;
            png_bytep dstptr;
            png_uint_32 len;
            int unmask, diff;
            __int64 mask1=0x0101020204040808,
                    mask0=0x1010202040408080;

            if (mmx_supported)
            {
               srcptr = png_ptr->row_buf + 1;
               dstptr = row;

               unmask = ~mask;
               len     = (png_ptr->width)&~7;
               diff = (png_ptr->width)&7;
               _asm
               {
                  movd       mm7, unmask       //load bit pattern
                  psubb      mm6,mm6           //zero mm6
                  punpcklbw  mm7,mm7
                  punpcklwd  mm7,mm7
                  punpckldq  mm7,mm7           //fill register with 8 masks

                  movq       mm0,mask0
                  movq       mm1,mask1

                  pand       mm0,mm7
                  pand       mm1,mm7

                  pcmpeqb    mm0,mm6
                  pcmpeqb    mm1,mm6

                  mov        ecx,len           //load length of line
                  mov        esi,srcptr        //load source
                  mov        ebx,dstptr        //load dest
                  cmp        ecx,0             //lcr
                  jz         mainloop16end

mainloop16:
                  movq       mm4,[esi]
                  pand       mm4,mm0
                  movq       mm6,mm0
                  movq       mm7,[ebx]
                  pandn      mm6,mm7
                  por        mm4,mm6
                  movq       [ebx],mm4

                  movq       mm5,[esi+8]
                  pand       mm5,mm1
                  movq       mm7,mm1
                  movq       mm6,[ebx+8]
                  pandn      mm7,mm6
                  por        mm5,mm7
                  movq       [ebx+8],mm5

                  add        esi,16            //inc by 16 bytes processed
                  add        ebx,16
                  sub        ecx,8             //dec by 8 pixels processed

                  ja         mainloop16

mainloop16end:
                  mov        ecx,diff
                  cmp        ecx,0
                  jz         end16

                  mov        edx,mask
                  sal        edx,24            //make low byte the high byte
secondloop16:
                  sal        edx,1             //move high bit to CF
                  jnc        skip16            //if CF = 0
                  mov        ax,[esi]
                  mov        [ebx],ax
skip16:
                  add        esi,2
                  add        ebx,2

                  dec        ecx
                  jnz        secondloop16
end16:
                  emms
               }
            }
            else /* mmx not supported - use modified C routine */
            {
               register unsigned int incr1, initial_val, final_val;
               png_size_t pixel_bytes;
               png_uint_32 i;
               register int disp = png_pass_inc[png_ptr->pass];
               int offset_table[7] = {0, 4, 0, 2, 0, 1, 0};

               pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
               srcptr = png_ptr->row_buf + 1 + offset_table[png_ptr->pass]*
                  pixel_bytes;
               dstptr = row + offset_table[png_ptr->pass]*pixel_bytes;
               initial_val = offset_table[png_ptr->pass]*pixel_bytes;
               final_val = png_ptr->width*pixel_bytes;
               incr1 = (disp)*pixel_bytes;
               for (i = initial_val; i < final_val; i += incr1)
               {
                  png_memcpy(dstptr, srcptr, pixel_bytes);
                  srcptr += incr1;
                  dstptr += incr1;
               }
            } /* end of else */

            break;
         }       // end 16 bpp

         case 24:
         {
            png_bytep srcptr;
            png_bytep dstptr;
            png_uint_32 len;
            int unmask, diff;

            __int64 mask2=0x0101010202020404,  //24bpp
                    mask1=0x0408080810101020,
                    mask0=0x2020404040808080;

            srcptr = png_ptr->row_buf + 1;
            dstptr = row;

            unmask = ~mask;
            len     = (png_ptr->width)&~7;
            diff = (png_ptr->width)&7;

            if (mmx_supported)
            {
               _asm
               {
                  movd       mm7, unmask       //load bit pattern
                  psubb      mm6,mm6           //zero mm6
                  punpcklbw  mm7,mm7
                  punpcklwd  mm7,mm7
                  punpckldq  mm7,mm7           //fill register with 8 masks

                  movq       mm0,mask0
                  movq       mm1,mask1
                  movq       mm2,mask2

                  pand       mm0,mm7
                  pand       mm1,mm7
                  pand       mm2,mm7

                  pcmpeqb    mm0,mm6
                  pcmpeqb    mm1,mm6
                  pcmpeqb    mm2,mm6

                  mov        ecx,len           //load length of line
                  mov        esi,srcptr        //load source
                  mov        ebx,dstptr        //load dest
                  cmp        ecx,0
                  jz         mainloop24end

mainloop24:
                  movq       mm4,[esi]
                  pand       mm4,mm0
                  movq       mm6,mm0
                  movq       mm7,[ebx]
                  pandn      mm6,mm7
                  por        mm4,mm6
                  movq       [ebx],mm4


                  movq       mm5,[esi+8]
                  pand       mm5,mm1
                  movq       mm7,mm1
                  movq       mm6,[ebx+8]
                  pandn      mm7,mm6
                  por        mm5,mm7
                  movq       [ebx+8],mm5

                  movq       mm6,[esi+16]
                  pand       mm6,mm2
                  movq       mm4,mm2
                  movq       mm7,[ebx+16]
                  pandn      mm4,mm7
                  por        mm6,mm4
                  movq       [ebx+16],mm6

                  add        esi,24            //inc by 24 bytes processed
                  add        ebx,24
                  sub        ecx,8             //dec by 8 pixels processed

                  ja         mainloop24

mainloop24end:
                  mov        ecx,diff
                  cmp        ecx,0
                  jz         end24

                  mov        edx,mask
                  sal        edx,24            //make low byte the high byte
secondloop24:
                  sal        edx,1             //move high bit to CF
                  jnc        skip24            //if CF = 0
                  mov        ax,[esi]
                  mov        [ebx],ax
                  xor        eax,eax
                  mov        al,[esi+2]
                  mov        [ebx+2],al
skip24:
                  add        esi,3
                  add        ebx,3

                  dec        ecx
                  jnz        secondloop24

end24:
                  emms
               }
            }
            else /* mmx not supported - use modified C routine */
            {
               register unsigned int incr1, initial_val, final_val;
               png_size_t pixel_bytes;
               png_uint_32 i;
               register int disp = png_pass_inc[png_ptr->pass];
               int offset_table[7] = {0, 4, 0, 2, 0, 1, 0};

               pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
               srcptr = png_ptr->row_buf + 1 + offset_table[png_ptr->pass]*
                  pixel_bytes;
               dstptr = row + offset_table[png_ptr->pass]*pixel_bytes;
               initial_val = offset_table[png_ptr->pass]*pixel_bytes;
               final_val = png_ptr->width*pixel_bytes;
               incr1 = (disp)*pixel_bytes;
               for (i = initial_val; i < final_val; i += incr1)
               {
                  png_memcpy(dstptr, srcptr, pixel_bytes);
                  srcptr += incr1;
                  dstptr += incr1;
               }
            } /* end of else */

            break;
         }       // end 24 bpp

         case 32:
         {
            png_bytep srcptr;
            png_bytep dstptr;
            png_uint_32 len;
            int unmask, diff;

            __int64 mask3=0x0101010102020202,  //32bpp
                    mask2=0x0404040408080808,
                    mask1=0x1010101020202020,
                    mask0=0x4040404080808080;

            srcptr = png_ptr->row_buf + 1;
            dstptr = row;

            unmask = ~mask;
            len     = (png_ptr->width)&~7;
            diff = (png_ptr->width)&7;

            if (mmx_supported)
            {
               _asm
               {
                  movd       mm7, unmask       //load bit pattern
                  psubb      mm6,mm6           //zero mm6
                  punpcklbw  mm7,mm7
                  punpcklwd  mm7,mm7
                  punpckldq  mm7,mm7           //fill register with 8 masks

                  movq       mm0,mask0
                  movq       mm1,mask1
                  movq       mm2,mask2
                  movq       mm3,mask3

                  pand       mm0,mm7
                  pand       mm1,mm7
                  pand       mm2,mm7
                  pand       mm3,mm7

                  pcmpeqb    mm0,mm6
                  pcmpeqb    mm1,mm6
                  pcmpeqb    mm2,mm6
                  pcmpeqb    mm3,mm6

                  mov        ecx,len           //load length of line
                  mov        esi,srcptr        //load source
                  mov        ebx,dstptr        //load dest

                  cmp        ecx,0             //lcr
                  jz         mainloop32end

mainloop32:
                  movq       mm4,[esi]
                  pand       mm4,mm0
                  movq       mm6,mm0
                  movq       mm7,[ebx]
                  pandn      mm6,mm7
                  por        mm4,mm6
                  movq       [ebx],mm4

                  movq       mm5,[esi+8]
                  pand       mm5,mm1
                  movq       mm7,mm1
                  movq       mm6,[ebx+8]
                  pandn      mm7,mm6
                  por        mm5,mm7
                  movq       [ebx+8],mm5

                  movq       mm6,[esi+16]
                  pand       mm6,mm2
                  movq       mm4,mm2
                  movq       mm7,[ebx+16]
                  pandn      mm4,mm7
                  por        mm6,mm4
                  movq       [ebx+16],mm6

                  movq       mm7,[esi+24]
                  pand       mm7,mm3
                  movq       mm5,mm3
                  movq       mm4,[ebx+24]
                  pandn      mm5,mm4
                  por        mm7,mm5
                  movq       [ebx+24],mm7

                  add        esi,32            //inc by 32 bytes processed
                  add        ebx,32
                  sub        ecx,8             //dec by 8 pixels processed

                  ja         mainloop32

mainloop32end:
                  mov        ecx,diff
                  cmp        ecx,0
                  jz         end32

                  mov        edx,mask
                  sal        edx,24            //make low byte the high byte
secondloop32:
                  sal        edx,1             //move high bit to CF
                  jnc        skip32            //if CF = 0
                  mov        eax,[esi]
                  mov        [ebx],eax
skip32:
                  add        esi,4
                  add        ebx,4

                  dec        ecx
                  jnz        secondloop32

end32:
                  emms
               }
            }
            else /* mmx _not supported - Use modified C routine */
            {
               register unsigned int incr1, initial_val, final_val;
               png_size_t pixel_bytes;
               png_uint_32 i;
               register int disp = png_pass_inc[png_ptr->pass];
               int offset_table[7] = {0, 4, 0, 2, 0, 1, 0};

               pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
               srcptr = png_ptr->row_buf + 1 + offset_table[png_ptr->pass]*
                  pixel_bytes;
               dstptr = row + offset_table[png_ptr->pass]*pixel_bytes;
               initial_val = offset_table[png_ptr->pass]*pixel_bytes;
               final_val = png_ptr->width*pixel_bytes;
               incr1 = (disp)*pixel_bytes;
               for (i = initial_val; i < final_val; i += incr1)
               {
                  png_memcpy(dstptr, srcptr, pixel_bytes);
                  srcptr += incr1;
                  dstptr += incr1;
               }
            } /* end of else */

            break;
         }       // end 32 bpp

         case 48:
         {
            png_bytep srcptr;
            png_bytep dstptr;
            png_uint_32 len;
            int unmask, diff;

            __int64 mask5=0x0101010101010202,
                    mask4=0x0202020204040404,
                    mask3=0x0404080808080808,
                    mask2=0x1010101010102020,
                    mask1=0x2020202040404040,
                    mask0=0x4040808080808080;

            if (mmx_supported)
            {
               srcptr = png_ptr->row_buf + 1;
               dstptr = row;

               unmask = ~mask;
               len     = (png_ptr->width)&~7;
               diff = (png_ptr->width)&7;
               _asm
               {
                  movd       mm7, unmask       //load bit pattern
                  psubb      mm6,mm6           //zero mm6
                  punpcklbw  mm7,mm7
                  punpcklwd  mm7,mm7
                  punpckldq  mm7,mm7           //fill register with 8 masks

                  movq       mm0,mask0
                  movq       mm1,mask1
                  movq       mm2,mask2
                  movq       mm3,mask3
                  movq       mm4,mask4
                  movq       mm5,mask5

                  pand       mm0,mm7
                  pand       mm1,mm7
                  pand       mm2,mm7
                  pand       mm3,mm7
                  pand       mm4,mm7
                  pand       mm5,mm7

                  pcmpeqb    mm0,mm6
                  pcmpeqb    mm1,mm6
                  pcmpeqb    mm2,mm6
                  pcmpeqb    mm3,mm6
                  pcmpeqb    mm4,mm6
                  pcmpeqb    mm5,mm6

                  mov        ecx,len           //load length of line
                  mov        esi,srcptr        //load source
                  mov        ebx,dstptr        //load dest

                  cmp        ecx,0
                  jz         mainloop48end

mainloop48:
                  movq       mm7,[esi]
                  pand       mm7,mm0
                  movq       mm6,mm0
                  pandn      mm6,[ebx]
                  por        mm7,mm6
                  movq       [ebx],mm7

                  movq       mm6,[esi+8]
                  pand       mm6,mm1
                  movq       mm7,mm1
                  pandn      mm7,[ebx+8]
                  por        mm6,mm7
                  movq       [ebx+8],mm6

                  movq       mm6,[esi+16]
                  pand       mm6,mm2
                  movq       mm7,mm2
                  pandn      mm7,[ebx+16]
                  por        mm6,mm7
                  movq       [ebx+16],mm6

                  movq       mm7,[esi+24]
                  pand       mm7,mm3
                  movq       mm6,mm3
                  pandn      mm6,[ebx+24]
                  por        mm7,mm6
                  movq       [ebx+24],mm7

                  movq       mm6,[esi+32]
                  pand       mm6,mm4
                  movq       mm7,mm4
                  pandn      mm7,[ebx+32]
                  por        mm6,mm7
                  movq       [ebx+32],mm6

                  movq       mm7,[esi+40]
                  pand       mm7,mm5
                  movq       mm6,mm5
                  pandn      mm6,[ebx+40]
                  por        mm7,mm6
                  movq       [ebx+40],mm7

                  add        esi,48            //inc by 32 bytes processed
                  add        ebx,48
                  sub        ecx,8             //dec by 8 pixels processed

                  ja         mainloop48
mainloop48end:

                  mov        ecx,diff
                  cmp        ecx,0
                  jz         end48

                  mov        edx,mask
                  sal        edx,24            //make low byte the high byte

secondloop48:
                  sal        edx,1             //move high bit to CF
                  jnc        skip48            //if CF = 0
                  mov        eax,[esi]
                  mov        [ebx],eax
skip48:
                  add        esi,4
                  add        ebx,4

                  dec        ecx
                  jnz        secondloop48

end48:
                  emms
               }
            }
            else /* mmx _not supported - Use modified C routine */
            {
               register unsigned int incr1, initial_val, final_val;
               png_size_t pixel_bytes;
               png_uint_32 i;
               register int disp = png_pass_inc[png_ptr->pass];
               int offset_table[7] = {0, 4, 0, 2, 0, 1, 0};

               pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
               srcptr = png_ptr->row_buf + 1 + offset_table[png_ptr->pass]*
                  pixel_bytes;
               dstptr = row + offset_table[png_ptr->pass]*pixel_bytes;
               initial_val = offset_table[png_ptr->pass]*pixel_bytes;
               final_val = png_ptr->width*pixel_bytes;
               incr1 = (disp)*pixel_bytes;
               for (i = initial_val; i < final_val; i += incr1)
               {
                  png_memcpy(dstptr, srcptr, pixel_bytes);
                  srcptr += incr1;
                  dstptr += incr1;
               }
            } /* end of else */

            break;
         }       // end 48 bpp

         default:
         {
            png_bytep sptr;
            png_bytep dp;
            png_size_t pixel_bytes;
            int offset_table[7] = {0, 4, 0, 2, 0, 1, 0};
            unsigned int i;
            register int disp = png_pass_inc[png_ptr->pass];  // get the offset
            register unsigned int incr1, initial_val, final_val;

            pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
            sptr = png_ptr->row_buf + 1 + offset_table[png_ptr->pass]*
               pixel_bytes;
            dp = row + offset_table[png_ptr->pass]*pixel_bytes;
            initial_val = offset_table[png_ptr->pass]*pixel_bytes;
            final_val = png_ptr->width*pixel_bytes;
            incr1 = (disp)*pixel_bytes;
            for (i = initial_val; i < final_val; i += incr1)
            {
               png_memcpy(dp, sptr, pixel_bytes);
               sptr += incr1;
               dp += incr1;
            }
            break;
         }
      } /* end switch (png_ptr->row_info.pixel_depth) */
   } /* end if (non-trivial mask) */

#ifdef DISABLE_PNGVCRD_COMBINE
   mmx_supported = save_mmx_supported;
#endif

} /* end png_combine_row() */


#if defined(PNG_READ_INTERLACING_SUPPORTED)

void
png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
   png_uint_32 transformations)
{
#ifdef DISABLE_PNGVCRD_INTERLACE
   int save_mmx_supported = mmx_supported;
#endif

   png_debug(1,"in png_do_read_interlace\n");

#ifdef DISABLE_PNGVCRD_INTERLACE
   /* In libpng versions 1.0.3a through 1.0.4d,
    * a sign error in the post-MMX cleanup code for each pixel_depth resulted
    * in bad pixels at the beginning of some rows of some images, and also
    * (due to out-of-range memory reads and writes) caused heap corruption
    * when compiled with MSVC 6.0.  The error was fixed in version 1.0.4e,
    * and the code appears to work completely correctly, so it is enabled
    * by default.
    */
   if (1)  /* all passes caused a heap problem in the old code */
      mmx_supported = 0;
   else
#endif
       if (mmx_supported == 2)
           mmx_supported = mmxsupport();

   if (row != NULL && row_info != NULL)
   {
      png_uint_32 final_width;

      final_width = row_info->width * png_pass_inc[pass];

      switch (row_info->pixel_depth)
      {
         case 1:
         {
            png_bytep sp, dp;
            int sshift, dshift;
            int s_start, s_end, s_inc;
            png_byte v;
            png_uint_32 i;
            int j;

            sp = row + (png_size_t)((row_info->width - 1) >> 3);
            dp = row + (png_size_t)((final_width - 1) >> 3);
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (int)((row_info->width + 7) & 7);
               dshift = (int)((final_width + 7) & 7);
               s_start = 7;
               s_end = 0;
               s_inc = -1;
            }
            else
#endif
            {
               sshift = 7 - (int)((row_info->width + 7) & 7);
               dshift = 7 - (int)((final_width + 7) & 7);
               s_start = 0;
               s_end = 7;
               s_inc = 1;
            }

            for (i = row_info->width; i; i--)
            {
               v = (png_byte)((*sp >> sshift) & 0x1);
               for (j = 0; j < png_pass_inc[pass]; j++)
               {
                  *dp &= (png_byte)((0x7f7f >> (7 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }

         case 2:
         {
            png_bytep sp, dp;
            int sshift, dshift;
            int s_start, s_end, s_inc;
            png_uint_32 i;

            sp = row + (png_size_t)((row_info->width - 1) >> 2);
            dp = row + (png_size_t)((final_width - 1) >> 2);
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (png_size_t)(((row_info->width + 3) & 3) << 1);
               dshift = (png_size_t)(((final_width + 3) & 3) << 1);
               s_start = 6;
               s_end = 0;
               s_inc = -2;
            }
            else
#endif
            {
               sshift = (png_size_t)((3 - ((row_info->width + 3) & 3)) << 1);
               dshift = (png_size_t)((3 - ((final_width + 3) & 3)) << 1);
               s_start = 0;
               s_end = 6;
               s_inc = 2;
            }

            for (i = row_info->width; i; i--)
            {
               png_byte v;
               int j;

               v = (png_byte)((*sp >> sshift) & 0x3);
               for (j = 0; j < png_pass_inc[pass]; j++)
               {
                  *dp &= (png_byte)((0x3f3f >> (6 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }

         case 4:
         {
            png_bytep sp, dp;
            int sshift, dshift;
            int s_start, s_end, s_inc;
            png_uint_32 i;

            sp = row + (png_size_t)((row_info->width - 1) >> 1);
            dp = row + (png_size_t)((final_width - 1) >> 1);
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (png_size_t)(((row_info->width + 1) & 1) << 2);
               dshift = (png_size_t)(((final_width + 1) & 1) << 2);
               s_start = 4;
               s_end = 0;
               s_inc = -4;
            }
            else
#endif
            {
               sshift = (png_size_t)((1 - ((row_info->width + 1) & 1)) << 2);
               dshift = (png_size_t)((1 - ((final_width + 1) & 1)) << 2);
               s_start = 0;
               s_end = 4;
               s_inc = 4;
            }

            for (i = row_info->width; i; i--)
            {
               png_byte v;
               int j;

               v = (png_byte)((*sp >> sshift) & 0xf);
               for (j = 0; j < png_pass_inc[pass]; j++)
               {
                  *dp &= (png_byte)((0xf0f >> (4 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }

         default:         // This is the place where the routine is modified
         {
            __int64 const4 = 0x0000000000FFFFFF;
            // __int64 const5 = 0x000000FFFFFF0000;  // unused...
            __int64 const6 = 0x00000000000000FF;
            png_bytep sptr, dp;
            png_uint_32 i;
            png_size_t pixel_bytes;
            int width = row_info->width;

            pixel_bytes = (row_info->pixel_depth >> 3);

            sptr = row + (width - 1) * pixel_bytes;
            dp = row + (final_width - 1) * pixel_bytes;
            // New code by Nirav Chhatrapati - Intel Corporation
            // sign fix by GRR
            // NOTE:  there is NO MMX code for 48-bit and 64-bit images

            if (mmx_supported) // use MMX routine if machine supports it
            {
               if (pixel_bytes == 3)
               {
                  if ((pass == 0) || (pass == 1))
                  {
                     _asm
                     {
                        mov esi, sptr
                        mov edi, dp
                        mov ecx, width
                        sub edi, 21   // (png_pass_inc[pass] - 1)*pixel_bytes
loop_pass0:
                        movd mm0, [esi]     ; X X X X X v2 v1 v0
                        pand mm0, const4    ; 0 0 0 0 0 v2 v1 v0
                        movq mm1, mm0       ; 0 0 0 0 0 v2 v1 v0
                        psllq mm0, 16       ; 0 0 0 v2 v1 v0 0 0
                        movq mm2, mm0       ; 0 0 0 v2 v1 v0 0 0
                        psllq mm0, 24       ; v2 v1 v0 0 0 0 0 0
                        psrlq mm1, 8        ; 0 0 0 0 0 0 v2 v1
                        por mm0, mm2        ; v2 v1 v0 v2 v1 v0 0 0
                        por mm0, mm1        ; v2 v1 v0 v2 v1 v0 v2 v1
                        movq mm3, mm0       ; v2 v1 v0 v2 v1 v0 v2 v1
                        psllq mm0, 16       ; v0 v2 v1 v0 v2 v1 0 0
                        movq mm4, mm3       ; v2 v1 v0 v2 v1 v0 v2 v1
                        punpckhdq mm3, mm0  ; v0 v2 v1 v0 v2 v1 v0 v2
                        movq [edi+16] , mm4
                        psrlq mm0, 32       ; 0 0 0 0 v0 v2 v1 v0
                        movq [edi+8] , mm3
                        punpckldq mm0, mm4  ; v1 v0 v2 v1 v0 v2 v1 v0
                        sub esi, 3
                        movq [edi], mm0
                        sub edi, 24
                        //sub esi, 3
                        dec ecx
                        jnz loop_pass0
                        EMMS
                     }
                  }
                  else if ((pass == 2) || (pass == 3))
                  {
                     _asm
                     {
                        mov esi, sptr
                        mov edi, dp
                        mov ecx, width
                        sub edi, 9   // (png_pass_inc[pass] - 1)*pixel_bytes
loop_pass2:
                        movd mm0, [esi]     ; X X X X X v2 v1 v0
                        pand mm0, const4    ; 0 0 0 0 0 v2 v1 v0
                        movq mm1, mm0       ; 0 0 0 0 0 v2 v1 v0
                        psllq mm0, 16       ; 0 0 0 v2 v1 v0 0 0
                        movq mm2, mm0       ; 0 0 0 v2 v1 v0 0 0
                        psllq mm0, 24       ; v2 v1 v0 0 0 0 0 0
                        psrlq mm1, 8        ; 0 0 0 0 0 0 v2 v1
                        por mm0, mm2        ; v2 v1 v0 v2 v1 v0 0 0
                        por mm0, mm1        ; v2 v1 v0 v2 v1 v0 v2 v1
                        movq [edi+4], mm0   ; move to memory
                        psrlq mm0, 16       ; 0 0 v2 v1 v0 v2 v1 v0
                        movd [edi], mm0     ; move to memory
                        sub esi, 3
                        sub edi, 12
                        dec ecx
                        jnz loop_pass2
                        EMMS
                     }
                  }
                  else /* if ((pass == 4) || (pass == 5)) */
                  {
                     int width_mmx = ((width >> 1) << 1) - 8;
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 3
                           sub edi, 9
loop_pass4:
                           movq mm0, [esi]     ; X X v2 v1 v0 v5 v4 v3
                           movq mm7, mm0       ; X X v2 v1 v0 v5 v4 v3
                           movq mm6, mm0       ; X X v2 v1 v0 v5 v4 v3
                           psllq mm0, 24       ; v1 v0 v5 v4 v3 0 0 0
                           pand mm7, const4    ; 0 0 0 0 0 v5 v4 v3
                           psrlq mm6, 24       ; 0 0 0 X X v2 v1 v0
                           por mm0, mm7        ; v1 v0 v5 v4 v3 v5 v4 v3
                           movq mm5, mm6       ; 0 0 0 X X v2 v1 v0
                           psllq mm6, 8        ; 0 0 X X v2 v1 v0 0
                           movq [edi], mm0     ; move quad to memory
                           psrlq mm5, 16       ; 0 0 0 0 0 X X v2
                           pand mm5, const6    ; 0 0 0 0 0 0 0 v2
                           por mm6, mm5        ; 0 0 X X v2 v1 v0 v2
                           movd [edi+8], mm6   ; move double to memory
                           sub esi, 6
                           sub edi, 12
                           sub ecx, 2
                           jnz loop_pass4
                           EMMS
                        }
                     }

                     sptr -= width_mmx*3;
                     dp -= width_mmx*6;
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;

                        png_memcpy(v, sptr, pixel_bytes);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           png_memcpy(dp, v, pixel_bytes);
                           dp -= pixel_bytes;
                        }
                        sptr -= pixel_bytes;
                     }
                  }
               } /* end of pixel_bytes == 3 */

               else if (pixel_bytes == 1)
               {
                  if ((pass == 0) || (pass == 1))
                  {
                     int width_mmx = ((width >> 2) << 2);
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub edi, 31
                           sub esi, 3
loop1_pass0:
                           movd mm0, [esi]     ; X X X X v0 v1 v2 v3
                           movq mm1, mm0       ; X X X X v0 v1 v2 v3
                           punpcklbw mm0, mm0  ; v0 v0 v1 v1 v2 v2 v3 v3
                           movq mm2, mm0       ; v0 v0 v1 v1 v2 v2 v3 v3
                           punpcklwd mm0, mm0  ; v2 v2 v2 v2 v3 v3 v3 v3
                           movq mm3, mm0       ; v2 v2 v2 v2 v3 v3 v3 v3
                           punpckldq mm0, mm0  ; v3 v3 v3 v3 v3 v3 v3 v3
                           punpckhdq mm3, mm3  ; v2 v2 v2 v2 v2 v2 v2 v2
                           movq [edi], mm0     ; move to memory v3
                           punpckhwd mm2, mm2  ; v0 v0 v0 v0 v1 v1 v1 v1
                           movq [edi+8], mm3   ; move to memory v2
                           movq mm4, mm2       ; v0 v0 v0 v0 v1 v1 v1 v1
                           punpckldq mm2, mm2  ; v1 v1 v1 v1 v1 v1 v1 v1
                           punpckhdq mm4, mm4  ; v0 v0 v0 v0 v0 v0 v0 v0
                           movq [edi+16], mm2  ; move to memory v1
                           movq [edi+24], mm4  ; move to memory v0
                           sub esi, 4
                           sub edi, 32
                           sub ecx, 4
                           jnz loop1_pass0
                           EMMS
                        }
                     }

                     sptr -= width_mmx;
                     dp -= width_mmx*8;
                     for (i = width; i; i--)
                     {
                        int j;

                       /* I simplified this part in version 1.0.4e
                        * here and in several other instances where
                        * pixel_bytes == 1  -- GR-P
                        *
                        * Original code:
                        *
                        * png_byte v[8];
                        * png_memcpy(v, sptr, pixel_bytes);
                        * for (j = 0; j < png_pass_inc[pass]; j++)
                        * {
                        *    png_memcpy(dp, v, pixel_bytes);
                        *    dp -= pixel_bytes;
                        * }
                        * sptr -= pixel_bytes;
                        *
                        * Replacement code is in the next three lines:
                        */

                        for (j = 0; j < png_pass_inc[pass]; j++)
                           *dp-- = *sptr;
                        sptr--;
                     }
                  }
                  else if ((pass == 2) || (pass == 3))
                  {
                     int width_mmx = ((width >> 2) << 2);
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub edi, 15
                           sub esi, 3
loop1_pass2:
                           movd mm0, [esi]     ; X X X X v0 v1 v2 v3
                           punpcklbw mm0, mm0  ; v0 v0 v1 v1 v2 v2 v3 v3
                           movq mm1, mm0       ; v0 v0 v1 v1 v2 v2 v3 v3
                           punpcklwd mm0, mm0  ; v2 v2 v2 v2 v3 v3 v3 v3
                           punpckhwd mm1, mm1  ; v0 v0 v0 v0 v1 v1 v1 v1
                           movq [edi], mm0     ; move to memory v2 and v3
                           sub esi, 4
                           movq [edi+8], mm1   ; move to memory v1     and v0
                           sub edi, 16
                           sub ecx, 4
                           jnz loop1_pass2
                           EMMS
                        }
                     }

                     sptr -= width_mmx;
                     dp -= width_mmx*4;
                     for (i = width; i; i--)
                     {
                        int j;

                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           *dp-- = *sptr;
                        }
                        sptr --;
                     }
                  }
                  else //if ((pass == 4) || (pass == 5))
                  {
                     int width_mmx = ((width >> 3) << 3);
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub edi, 15
                           sub esi, 7
loop1_pass4:
                           movq mm0, [esi]     ; v0 v1 v2 v3 v4 v5 v6 v7
                           movq mm1, mm0       ; v0 v1 v2 v3 v4 v5 v6 v7
                           punpcklbw mm0, mm0  ; v4 v4 v5 v5 v6 v6 v7 v7
                           //movq mm1, mm0     ; v0 v0 v1 v1 v2 v2 v3 v3
                           punpckhbw mm1, mm1  ;v0 v0 v1 v1 v2 v2 v3 v3
                           movq [edi+8], mm1   ; move to memory v0 v1 v2 and v3
                           sub esi, 8
                           movq [edi], mm0     ; move to memory v4 v5 v6 and v7
                           //sub esi, 4
                           sub edi, 16
                           sub ecx, 8
                           jnz loop1_pass4
                           EMMS
                        }
                     }

                     sptr -= width_mmx;
                     dp -= width_mmx*2;
                     for (i = width; i; i--)
                     {
                        int j;

                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           *dp-- = *sptr;
                        }
                        sptr --;
                     }
                  }
               } /* end of pixel_bytes == 1 */

               else if (pixel_bytes == 2)
               {
                  if ((pass == 0) || (pass == 1))
                  {
                     int width_mmx = ((width >> 1) << 1);
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 2
                           sub edi, 30
loop2_pass0:
                           movd mm0, [esi]        ; X X X X v1 v0 v3 v2
                           punpcklwd mm0, mm0     ; v1 v0 v1 v0 v3 v2 v3 v2
                           movq mm1, mm0          ; v1 v0 v1 v0 v3 v2 v3 v2
                           punpckldq mm0, mm0     ; v3 v2 v3 v2 v3 v2 v3 v2
                           punpckhdq mm1, mm1     ; v1 v0 v1 v0 v1 v0 v1 v0
                           movq [edi], mm0
                           movq [edi + 8], mm0
                           movq [edi + 16], mm1
                           movq [edi + 24], mm1
                           sub esi, 4
                           sub edi, 32
                           sub ecx, 2
                           jnz loop2_pass0
                           EMMS
                        }
                     }

                     sptr -= (width_mmx*2 - 2);	// sign fixed
                     dp -= (width_mmx*16 - 2);	// sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= pixel_bytes;
                        png_memcpy(v, sptr, pixel_bytes);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= pixel_bytes;
                           png_memcpy(dp, v, pixel_bytes);
                        }
                     }
                  }

                  else if ((pass == 2) || (pass == 3))
                  {
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 2
                           sub edi, 14
loop2_pass2:
                           movd mm0, [esi]        ; X X X X v1 v0 v3 v2
                           punpcklwd mm0, mm0     ; v1 v0 v1 v0 v3 v2 v3 v2
                           movq mm1, mm0          ; v1 v0 v1 v0 v3 v2 v3 v2
                           punpckldq mm0, mm0     ; v3 v2 v3 v2 v3 v2 v3 v2
                           punpckhdq mm1, mm1     ; v1 v0 v1 v0 v1 v0 v1 v0
                           movq [edi], mm0
                           sub esi, 4
                           movq [edi + 8], mm1
                           //sub esi, 4
                           sub edi, 16
                           sub ecx, 2
                           jnz loop2_pass2
                           EMMS
                        }
                     }

                     sptr -= (width_mmx*2 - 2);	// sign fixed
                     dp -= (width_mmx*8 - 2);	// sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= pixel_bytes;
                        png_memcpy(v, sptr, pixel_bytes);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= pixel_bytes;
                           png_memcpy(dp, v, pixel_bytes);
                        }
                     }
                  }

                  else // pass == 4 or 5
                  {
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 2
                           sub edi, 6
loop2_pass4:
                           movd mm0, [esi]        ; X X X X v1 v0 v3 v2
                           punpcklwd mm0, mm0     ; v1 v0 v1 v0 v3 v2 v3 v2
                           sub esi, 4
                           movq [edi], mm0
                           sub edi, 8
                           sub ecx, 2
                           jnz loop2_pass4
                           EMMS
                        }
                     }

                     sptr -= (width_mmx*2 - 2);	// sign fixed
                     dp -= (width_mmx*4 - 2);	// sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= pixel_bytes;
                        png_memcpy(v, sptr, pixel_bytes);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= pixel_bytes;
                           png_memcpy(dp, v, pixel_bytes);
                        }
                     }
                  }
               } /* end of pixel_bytes == 2 */

               else if (pixel_bytes == 4)
               {
                  if ((pass == 0) || (pass == 1))
                  {
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 4
                           sub edi, 60
loop4_pass0:
                           movq mm0, [esi]        ; v3 v2 v1 v0 v7 v6 v5 v4
                           movq mm1, mm0          ; v3 v2 v1 v0 v7 v6 v5 v4
                           punpckldq mm0, mm0     ; v7 v6 v5 v4 v7 v6 v5 v4
                           punpckhdq mm1, mm1     ; v3 v2 v1 v0 v3 v2 v1 v0
                           movq [edi], mm0
                           movq [edi + 8], mm0
                           movq [edi + 16], mm0
                           movq [edi + 24], mm0
                           movq [edi+32], mm1
                           movq [edi + 40], mm1
                           movq [edi+ 48], mm1
                           sub esi, 8
                           movq [edi + 56], mm1
                           sub edi, 64
                           sub ecx, 2
                           jnz loop4_pass0
                           EMMS
                        }
                     }

                     sptr -= (width_mmx*4 - 4);	// sign fixed
                     dp -= (width_mmx*32 - 4);	// sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= pixel_bytes;
                        png_memcpy(v, sptr, pixel_bytes);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= pixel_bytes;
                           png_memcpy(dp, v, pixel_bytes);
                        }
                     }
                  }

                  else if ((pass == 2) || (pass == 3))
                  {
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 4
                           sub edi, 28
loop4_pass2:
                           movq mm0, [esi]      ; v3 v2 v1 v0 v7 v6 v5 v4
                           movq mm1, mm0        ; v3 v2 v1 v0 v7 v6 v5 v4
                           punpckldq mm0, mm0   ; v7 v6 v5 v4 v7 v6 v5 v4
                           punpckhdq mm1, mm1   ; v3 v2 v1 v0 v3 v2 v1 v0
                           movq [edi], mm0
                           movq [edi + 8], mm0
                           movq [edi+16], mm1
                           movq [edi + 24], mm1
                           sub esi, 8
                           sub edi, 32
                           sub ecx, 2
                           jnz loop4_pass2
                           EMMS
                        }
                     }

                     sptr -= (width_mmx*4 - 4);	// sign fixed
                     dp -= (width_mmx*16 - 4);	// sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= pixel_bytes;
                        png_memcpy(v, sptr, pixel_bytes);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= pixel_bytes;
                           png_memcpy(dp, v, pixel_bytes);
                        }
                     }
                  }

                  else // pass == 4 or 5
                  {
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 4
                           sub edi, 12
loop4_pass4:
                           movq mm0, [esi]      ; v3 v2 v1 v0 v7 v6 v5 v4
                           movq mm1, mm0        ; v3 v2 v1 v0 v7 v6 v5 v4
                           punpckldq mm0, mm0   ; v7 v6 v5 v4 v7 v6 v5 v4
                           punpckhdq mm1, mm1   ; v3 v2 v1 v0 v3 v2 v1 v0
                           movq [edi], mm0
                           sub esi, 8
                           movq [edi + 8], mm1
                           sub edi, 16
                           sub ecx, 2
                           jnz loop4_pass4
                           EMMS
                        }
                     }

                     sptr -= (width_mmx*4 - 4);	// sign fixed
                     dp -= (width_mmx*8 - 4);	// sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= pixel_bytes;
                        png_memcpy(v, sptr, pixel_bytes);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= pixel_bytes;
                           png_memcpy(dp, v, pixel_bytes);
                        }
                     }
                  }

               } /* end of pixel_bytes == 4 */

               else if (pixel_bytes == 6)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr -= pixel_bytes;
                  }
               } /* end of pixel_bytes == 6 */

               else
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr-= pixel_bytes;
                  }
               }
            } /* end of mmx_supported */

            else /* MMX not supported:  use modified C code - takes advantage
                  * of inlining of memcpy for a constant */
            {
               if (pixel_bytes == 1)
               {
                  for (i = width; i; i--)
                  {
                     int j;
                     for (j = 0; j < png_pass_inc[pass]; j++)
                        *dp-- = *sptr;
                     sptr--;
                  }
               }
               else if (pixel_bytes == 3)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr -= pixel_bytes;
                  }
               }
               else if (pixel_bytes == 2)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr -= pixel_bytes;
                  }
               }
               else if (pixel_bytes == 4)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr -= pixel_bytes;
                  }
               }
               else if (pixel_bytes == 6)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr -= pixel_bytes;
                  }
               }
               else
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr -= pixel_bytes;
                  }
               }

            } /* end of MMX not supported */
            break;
         }
      } /* end switch (row_info->pixel_depth) */

      row_info->width = final_width;
      row_info->rowbytes = ((final_width *
         (png_uint_32)row_info->pixel_depth + 7) >> 3);
   }

#ifdef DISABLE_PNGVCRD_INTERLACE
   mmx_supported = save_mmx_supported;
#endif
}

#endif /* PNG_READ_INTERLACING_SUPPORTED */


// These variables are utilized in the functions below.  They are declared
// globally here to ensure alignment on 8-byte boundaries.

union uAll {
   __int64 use;
   double  align;
} LBCarryMask = {0x0101010101010101},
  HBClearMask = {0x7f7f7f7f7f7f7f7f},
  ActiveMask, ActiveMask2, ActiveMaskEnd, ShiftBpp, ShiftRem;


// Optimized code for PNG Average filter decoder
void
png_read_filter_row_mmx_avg(png_row_infop row_info, png_bytep row
                            , png_bytep prev_row)
{
   int bpp;
   png_uint_32 FullLength;
   png_uint_32 MMXLength;
   //png_uint_32 len;
   int diff;

   bpp = (row_info->pixel_depth + 7) >> 3; // Get # bytes per pixel
   FullLength  = row_info->rowbytes; // # of bytes to filter
   _asm {
         // Init address pointers and offset
         mov edi, row          // edi ==> Avg(x)
         xor ebx, ebx          // ebx ==> x
         mov edx, edi
         mov esi, prev_row           // esi ==> Prior(x)
         sub edx, bpp          // edx ==> Raw(x-bpp)

         xor eax, eax
         // Compute the Raw value for the first bpp bytes
         //    Raw(x) = Avg(x) + (Prior(x)/2)
davgrlp:
         mov al, [esi + ebx]   // Load al with Prior(x)
         inc ebx
         shr al, 1             // divide by 2
         add al, [edi+ebx-1]   // Add Avg(x); -1 to offset inc ebx
         cmp ebx, bpp
         mov [edi+ebx-1], al    // Write back Raw(x);
                            // mov does not affect flags; -1 to offset inc ebx
         jb davgrlp
         // get # of bytes to alignment
         mov diff, edi         // take start of row
         add diff, ebx         // add bpp
         add diff, 0xf         // add 7 + 8 to incr past alignment boundary
         and diff, 0xfffffff8  // mask to alignment boundary
         sub diff, edi         // subtract from start ==> value ebx at alignment
         jz davggo
         // fix alignment
         // Compute the Raw value for the bytes upto the alignment boundary
         //    Raw(x) = Avg(x) + ((Raw(x-bpp) + Prior(x))/2)
         xor ecx, ecx
davglp1:
         xor eax, eax
         mov cl, [esi + ebx]        // load cl with Prior(x)
         mov al, [edx + ebx]  // load al with Raw(x-bpp)
         add ax, cx
         inc ebx
         shr ax, 1            // divide by 2
         add al, [edi+ebx-1]  // Add Avg(x); -1 to offset inc ebx
         cmp ebx, diff              // Check if at alignment boundary
         mov [edi+ebx-1], al        // Write back Raw(x);
                            // mov does not affect flags; -1 to offset inc ebx
         jb davglp1               // Repeat until at alignment boundary
davggo:
         mov eax, FullLength
         mov ecx, eax
         sub eax, ebx          // subtract alignment fix
         and eax, 0x00000007   // calc bytes over mult of 8
         sub ecx, eax          // drop over bytes from original length
         mov MMXLength, ecx
   } // end _asm block
   // Now do the math for the rest of the row
   switch ( bpp )
   {
      case 3:
      {
         ActiveMask.use  = 0x0000000000ffffff;
         ShiftBpp.use = 24;    // == 3 * 8
         ShiftRem.use = 40;    // == 64 - 24
         _asm {
            // Re-init address pointers and offset
            movq mm7, ActiveMask
            mov ebx, diff      // ebx ==> x = offset to alignment boundary
            movq mm5, LBCarryMask
            mov edi, row       // edi ==> Avg(x)
            movq mm4, HBClearMask
            mov esi, prev_row        // esi ==> Prior(x)
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm2, [edi + ebx - 8]  // Load previous aligned 8 bytes
                               // (we correct position in loop below)
davg3lp:
            movq mm0, [edi + ebx]      // Load mm0 with Avg(x)
            // Add (Prev_row/2) to Average
            movq mm3, mm5
            psrlq mm2, ShiftRem      // Correct position Raw(x-bpp) data
            movq mm1, [esi + ebx]    // Load mm1 with Prior(x)
            movq mm6, mm7
            pand mm3, mm1      // get lsb for each prev_row byte
            psrlq mm1, 1       // divide prev_row bytes by 2
            pand  mm1, mm4     // clear invalid bit 7 of each byte
            paddb mm0, mm1     // add (Prev_row/2) to Avg for each byte
            // Add 1st active group (Raw(x-bpp)/2) to Average with LBCarry
            movq mm1, mm3      // now use mm1 for getting LBCarrys
            pand mm1, mm2      // get LBCarrys for each byte where both
                               // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1       // divide raw bytes by 2
            pand  mm2, mm4     // clear invalid bit 7 of each byte
            paddb mm2, mm1     // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6      // Leave only Active Group 1 bytes to add to Avg
            paddb mm0, mm2     // add (Raw/2) + LBCarrys to Avg for each Active
                               //  byte
            // Add 2nd active group (Raw(x-bpp)/2) to Average with LBCarry
            psllq mm6, ShiftBpp  // shift the mm6 mask to cover bytes 3-5
            movq mm2, mm0        // mov updated Raws to mm2
            psllq mm2, ShiftBpp  // shift data to position correctly
            movq mm1, mm3        // now use mm1 for getting LBCarrys
            pand mm1, mm2      // get LBCarrys for each byte where both
                               // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1       // divide raw bytes by 2
            pand  mm2, mm4     // clear invalid bit 7 of each byte
            paddb mm2, mm1     // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6      // Leave only Active Group 2 bytes to add to Avg
            paddb mm0, mm2     // add (Raw/2) + LBCarrys to Avg for each Active
                               //  byte

            // Add 3rd active group (Raw(x-bpp)/2) to Average with LBCarry
            psllq mm6, ShiftBpp  // shift the mm6 mask to cover the last two
                                 // bytes
            movq mm2, mm0        // mov updated Raws to mm2
            psllq mm2, ShiftBpp  // shift data to position correctly
                              // Data only needs to be shifted once here to
                              // get the correct x-bpp offset.
            movq mm1, mm3     // now use mm1 for getting LBCarrys
            pand mm1, mm2     // get LBCarrys for each byte where both
                              // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1      // divide raw bytes by 2
            pand  mm2, mm4    // clear invalid bit 7 of each byte
            paddb mm2, mm1    // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6     // Leave only Active Group 2 bytes to add to Avg
            add ebx, 8
            paddb mm0, mm2    // add (Raw/2) + LBCarrys to Avg for each Active
                              // byte

            // Now ready to write back to memory
            movq [edi + ebx - 8], mm0
            // Move updated Raw(x) to use as Raw(x-bpp) for next loop
            cmp ebx, MMXLength
            movq mm2, mm0     // mov updated Raw(x) to mm2
            jb davg3lp
         } // end _asm block
      }
      break;

      case 6:
      case 4:
      case 7:
      case 5:
      {
         ActiveMask.use  = 0xffffffffffffffff;  // use shift below to clear
                                                // appropriate inactive bytes
         ShiftBpp.use = bpp << 3;
         ShiftRem.use = 64 - ShiftBpp.use;
         _asm {
            movq mm4, HBClearMask
            // Re-init address pointers and offset
            mov ebx, diff       // ebx ==> x = offset to alignment boundary
            // Load ActiveMask and clear all bytes except for 1st active group
            movq mm7, ActiveMask
            mov edi, row         // edi ==> Avg(x)
            psrlq mm7, ShiftRem
            mov esi, prev_row    // esi ==> Prior(x)
            movq mm6, mm7
            movq mm5, LBCarryMask
            psllq mm6, ShiftBpp  // Create mask for 2nd active group
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm2, [edi + ebx - 8]  // Load previous aligned 8 bytes
                                 // (we correct position in loop below)
davg4lp:
            movq mm0, [edi + ebx]
            psrlq mm2, ShiftRem  // shift data to position correctly
            movq mm1, [esi + ebx]
            // Add (Prev_row/2) to Average
            movq mm3, mm5
            pand mm3, mm1     // get lsb for each prev_row byte
            psrlq mm1, 1      // divide prev_row bytes by 2
            pand  mm1, mm4    // clear invalid bit 7 of each byte
            paddb mm0, mm1    // add (Prev_row/2) to Avg for each byte
            // Add 1st active group (Raw(x-bpp)/2) to Average with LBCarry
            movq mm1, mm3     // now use mm1 for getting LBCarrys
            pand mm1, mm2     // get LBCarrys for each byte where both
                              // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1      // divide raw bytes by 2
            pand  mm2, mm4    // clear invalid bit 7 of each byte
            paddb mm2, mm1    // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm7     // Leave only Active Group 1 bytes to add to Avg
            paddb mm0, mm2    // add (Raw/2) + LBCarrys to Avg for each Active
                              // byte
            // Add 2nd active group (Raw(x-bpp)/2) to Average with LBCarry
            movq mm2, mm0     // mov updated Raws to mm2
            psllq mm2, ShiftBpp // shift data to position correctly
            add ebx, 8
            movq mm1, mm3     // now use mm1 for getting LBCarrys
            pand mm1, mm2     // get LBCarrys for each byte where both
                              // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1      // divide raw bytes by 2
            pand  mm2, mm4    // clear invalid bit 7 of each byte
            paddb mm2, mm1    // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6     // Leave only Active Group 2 bytes to add to Avg
            paddb mm0, mm2    // add (Raw/2) + LBCarrys to Avg for each Active
                              // byte
            cmp ebx, MMXLength
            // Now ready to write back to memory
            movq [edi + ebx - 8], mm0
            // Prep Raw(x-bpp) for next loop
            movq mm2, mm0     // mov updated Raws to mm2
            jb davg4lp
         } // end _asm block
      }
      break;
      case 2:
      {
         ActiveMask.use  = 0x000000000000ffff;
         ShiftBpp.use = 24;   // == 3 * 8
         ShiftRem.use = 40;   // == 64 - 24
         _asm {
            // Load ActiveMask
            movq mm7, ActiveMask
            // Re-init address pointers and offset
            mov ebx, diff     // ebx ==> x = offset to alignment boundary
            movq mm5, LBCarryMask
            mov edi, row      // edi ==> Avg(x)
            movq mm4, HBClearMask
            mov esi, prev_row  // esi ==> Prior(x)
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm2, [edi + ebx - 8]  // Load previous aligned 8 bytes
                              // (we correct position in loop below)
davg2lp:
            movq mm0, [edi + ebx]
            psllq mm2, ShiftRem  // shift data to position correctly
            movq mm1, [esi + ebx]
            // Add (Prev_row/2) to Average
            movq mm3, mm5
            pand mm3, mm1     // get lsb for each prev_row byte
            psrlq mm1, 1      // divide prev_row bytes by 2
            pand  mm1, mm4    // clear invalid bit 7 of each byte
            movq mm6, mm7
            paddb mm0, mm1    // add (Prev_row/2) to Avg for each byte
            // Add 1st active group (Raw(x-bpp)/2) to Average with LBCarry
            movq mm1, mm3     // now use mm1 for getting LBCarrys
            pand mm1, mm2     // get LBCarrys for each byte where both
                              // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1      // divide raw bytes by 2
            pand  mm2, mm4    // clear invalid bit 7 of each byte
            paddb mm2, mm1    // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6     // Leave only Active Group 1 bytes to add to Avg
            paddb mm0, mm2 // add (Raw/2) + LBCarrys to Avg for each Active byte
            // Add 2nd active group (Raw(x-bpp)/2) to Average with LBCarry
            psllq mm6, ShiftBpp // shift the mm6 mask to cover bytes 2 & 3
            movq mm2, mm0       // mov updated Raws to mm2
            psllq mm2, ShiftBpp // shift data to position correctly
            movq mm1, mm3       // now use mm1 for getting LBCarrys
            pand mm1, mm2       // get LBCarrys for each byte where both
                                // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1        // divide raw bytes by 2
            pand  mm2, mm4      // clear invalid bit 7 of each byte
            paddb mm2, mm1      // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6       // Leave only Active Group 2 bytes to add to Avg
            paddb mm0, mm2 // add (Raw/2) + LBCarrys to Avg for each Active byte

            // Add rdd active group (Raw(x-bpp)/2) to Average with LBCarry
            psllq mm6, ShiftBpp // shift the mm6 mask to cover bytes 4 & 5
            movq mm2, mm0       // mov updated Raws to mm2
            psllq mm2, ShiftBpp // shift data to position correctly
                                // Data only needs to be shifted once here to
                                // get the correct x-bpp offset.
            movq mm1, mm3       // now use mm1 for getting LBCarrys
            pand mm1, mm2       // get LBCarrys for each byte where both
                                // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1        // divide raw bytes by 2
            pand  mm2, mm4      // clear invalid bit 7 of each byte
            paddb mm2, mm1      // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6       // Leave only Active Group 2 bytes to add to Avg
            paddb mm0, mm2 // add (Raw/2) + LBCarrys to Avg for each Active byte

            // Add 4th active group (Raw(x-bpp)/2) to Average with LBCarry
            psllq mm6, ShiftBpp  // shift the mm6 mask to cover bytes 6 & 7
            movq mm2, mm0        // mov updated Raws to mm2
            psllq mm2, ShiftBpp  // shift data to position correctly
                                 // Data only needs to be shifted once here to
                                 // get the correct x-bpp offset.
            add ebx, 8
            movq mm1, mm3    // now use mm1 for getting LBCarrys
            pand mm1, mm2    // get LBCarrys for each byte where both
                             // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1     // divide raw bytes by 2
            pand  mm2, mm4   // clear invalid bit 7 of each byte
            paddb mm2, mm1   // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6    // Leave only Active Group 2 bytes to add to Avg
            paddb mm0, mm2 // add (Raw/2) + LBCarrys to Avg for each Active byte

            cmp ebx, MMXLength
            // Now ready to write back to memory
            movq [edi + ebx - 8], mm0
            // Prep Raw(x-bpp) for next loop
            movq mm2, mm0    // mov updated Raws to mm2
            jb davg2lp
        } // end _asm block
      }
      break;

      case 1:                 // bpp == 1
      {
         _asm {
            // Re-init address pointers and offset
            mov ebx, diff     // ebx ==> x = offset to alignment boundary
            mov edi, row      // edi ==> Avg(x)
            cmp ebx, FullLength  // Test if offset at end of array
            jnb davg1end
            // Do Paeth decode for remaining bytes
            mov esi, prev_row    // esi ==> Prior(x)
            mov edx, edi
            xor ecx, ecx         // zero ecx before using cl & cx in loop below
            sub edx, bpp         // edx ==> Raw(x-bpp)
davg1lp:
            // Raw(x) = Avg(x) + ((Raw(x-bpp) + Prior(x))/2)
            xor eax, eax
            mov cl, [esi + ebx]  // load cl with Prior(x)
            mov al, [edx + ebx]  // load al with Raw(x-bpp)
            add ax, cx
            inc ebx
            shr ax, 1            // divide by 2
            add al, [edi+ebx-1]  // Add Avg(x); -1 to offset inc ebx
            cmp ebx, FullLength  // Check if at end of array
            mov [edi+ebx-1], al  // Write back Raw(x);
                         // mov does not affect flags; -1 to offset inc ebx
            jb davg1lp
davg1end:
         } // end _asm block
      }
      return;

      case 8:             // bpp == 8
      {
         _asm {
            // Re-init address pointers and offset
            mov ebx, diff           // ebx ==> x = offset to alignment boundary
            movq mm5, LBCarryMask
            mov edi, row            // edi ==> Avg(x)
            movq mm4, HBClearMask
            mov esi, prev_row       // esi ==> Prior(x)
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm2, [edi + ebx - 8]  // Load previous aligned 8 bytes
                                // (NO NEED to correct position in loop below)
davg8lp:
            movq mm0, [edi + ebx]
            movq mm3, mm5
            movq mm1, [esi + ebx]
            add ebx, 8
            pand mm3, mm1       // get lsb for each prev_row byte
            psrlq mm1, 1        // divide prev_row bytes by 2
            pand mm3, mm2       // get LBCarrys for each byte where both
                                // lsb's were == 1
            psrlq mm2, 1        // divide raw bytes by 2
            pand  mm1, mm4      // clear invalid bit 7 of each byte
            paddb mm0, mm3      // add LBCarrys to Avg for each byte
            pand  mm2, mm4      // clear invalid bit 7 of each byte
            paddb mm0, mm1      // add (Prev_row/2) to Avg for each byte
            paddb mm0, mm2      // add (Raw/2) to Avg for each byte
            cmp ebx, MMXLength
            movq [edi + ebx - 8], mm0
            movq mm2, mm0       // reuse as Raw(x-bpp)
            jb davg8lp
        } // end _asm block
      }
      break;
      default:                  // bpp greater than 8
      {
        _asm {
            movq mm5, LBCarryMask
            // Re-init address pointers and offset
            mov ebx, diff       // ebx ==> x = offset to alignment boundary
            mov edi, row        // edi ==> Avg(x)
            movq mm4, HBClearMask
            mov edx, edi
            mov esi, prev_row   // esi ==> Prior(x)
            sub edx, bpp        // edx ==> Raw(x-bpp)
davgAlp:
            movq mm0, [edi + ebx]
            movq mm3, mm5
            movq mm1, [esi + ebx]
            pand mm3, mm1       // get lsb for each prev_row byte
            movq mm2, [edx + ebx]
            psrlq mm1, 1        // divide prev_row bytes by 2
            pand mm3, mm2       // get LBCarrys for each byte where both
                                // lsb's were == 1
            psrlq mm2, 1        // divide raw bytes by 2
            pand  mm1, mm4      // clear invalid bit 7 of each byte
            paddb mm0, mm3      // add LBCarrys to Avg for each byte
            pand  mm2, mm4      // clear invalid bit 7 of each byte
            paddb mm0, mm1      // add (Prev_row/2) to Avg for each byte
            add ebx, 8
            paddb mm0, mm2      // add (Raw/2) to Avg for each byte
            cmp ebx, MMXLength
            movq [edi + ebx - 8], mm0
            jb davgAlp
        } // end _asm block
      }
      break;
   }                         // end switch ( bpp )

   _asm {
         // MMX acceleration complete now do clean-up
         // Check if any remaining bytes left to decode
         mov ebx, MMXLength    // ebx ==> x = offset bytes remaining after MMX
         mov edi, row          // edi ==> Avg(x)
         cmp ebx, FullLength   // Test if offset at end of array
         jnb davgend
         // Do Paeth decode for remaining bytes
         mov esi, prev_row     // esi ==> Prior(x)
         mov edx, edi
         xor ecx, ecx          // zero ecx before using cl & cx in loop below
         sub edx, bpp          // edx ==> Raw(x-bpp)
davglp2:
         // Raw(x) = Avg(x) + ((Raw(x-bpp) + Prior(x))/2)
         xor eax, eax
         mov cl, [esi + ebx]   // load cl with Prior(x)
         mov al, [edx + ebx]   // load al with Raw(x-bpp)
         add ax, cx
         inc ebx
         shr ax, 1              // divide by 2
         add al, [edi+ebx-1]    // Add Avg(x); -1 to offset inc ebx
         cmp ebx, FullLength    // Check if at end of array
         mov [edi+ebx-1], al    // Write back Raw(x);
                          // mov does not affect flags; -1 to offset inc ebx
         jb davglp2
davgend:
         emms             // End MMX instructions; prep for possible FP instrs.
   } // end _asm block
}

// Optimized code for PNG Paeth filter decoder
void
png_read_filter_row_mmx_paeth(png_row_infop row_info, png_bytep row,
                              png_bytep prev_row)
{
   png_uint_32 FullLength;
   png_uint_32 MMXLength;
   //png_uint_32 len;
   int bpp;
   int diff;
   //int ptemp;
   int patemp, pbtemp, pctemp;

   bpp = (row_info->pixel_depth + 7) >> 3; // Get # bytes per pixel
   FullLength  = row_info->rowbytes; // # of bytes to filter
   _asm
   {
         xor ebx, ebx        // ebx ==> x offset
         mov edi, row
         xor edx, edx        // edx ==> x-bpp offset
         mov esi, prev_row
         xor eax, eax

         // Compute the Raw value for the first bpp bytes
         // Note: the formula works out to be always
         //   Paeth(x) = Raw(x) + Prior(x)      where x < bpp
dpthrlp:
         mov al, [edi + ebx]
         add al, [esi + ebx]
         inc ebx
         cmp ebx, bpp
         mov [edi + ebx - 1], al
         jb dpthrlp
         // get # of bytes to alignment
         mov diff, edi         // take start of row
         add diff, ebx         // add bpp
         xor ecx, ecx
         add diff, 0xf         // add 7 + 8 to incr past alignment boundary
         and diff, 0xfffffff8  // mask to alignment boundary
         sub diff, edi         // subtract from start ==> value ebx at alignment
         jz dpthgo
         // fix alignment
dpthlp1:
         xor eax, eax
         // pav = p - a = (a + b - c) - a = b - c
         mov al, [esi + ebx]   // load Prior(x) into al
         mov cl, [esi + edx]   // load Prior(x-bpp) into cl
         sub eax, ecx          // subtract Prior(x-bpp)
         mov patemp, eax       // Save pav for later use
         xor eax, eax
         // pbv = p - b = (a + b - c) - b = a - c
         mov al, [edi + edx]   // load Raw(x-bpp) into al
         sub eax, ecx          // subtract Prior(x-bpp)
         mov ecx, eax
         // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
         add eax, patemp       // pcv = pav + pbv
         // pc = abs(pcv)
         test eax, 0x80000000
         jz dpthpca
         neg eax               // reverse sign of neg values
dpthpca:
         mov pctemp, eax       // save pc for later use
         // pb = abs(pbv)
         test ecx, 0x80000000
         jz dpthpba
         neg ecx               // reverse sign of neg values
dpthpba:
         mov pbtemp, ecx       // save pb for later use
         // pa = abs(pav)
         mov eax, patemp
         test eax, 0x80000000
         jz dpthpaa
         neg eax               // reverse sign of neg values
dpthpaa:
         mov patemp, eax       // save pa for later use
         // test if pa <= pb
         cmp eax, ecx
         jna dpthabb
         // pa > pb; now test if pb <= pc
         cmp ecx, pctemp
         jna dpthbbc
         // pb > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         jmp dpthpaeth
dpthbbc:
         // pb <= pc; Raw(x) = Paeth(x) + Prior(x)
         mov cl, [esi + ebx]   // load Prior(x) into cl
         jmp dpthpaeth
dpthabb:
         // pa <= pb; now test if pa <= pc
         cmp eax, pctemp
         jna dpthabc
         // pa > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         jmp dpthpaeth
dpthabc:
         // pa <= pc; Raw(x) = Paeth(x) + Raw(x-bpp)
         mov cl, [edi + edx]  // load Raw(x-bpp) into cl
dpthpaeth:
         inc ebx
         inc edx
         // Raw(x) = (Paeth(x) + Paeth_Predictor( a, b, c )) mod 256
         add [edi + ebx - 1], cl
         cmp ebx, diff
         jb dpthlp1
dpthgo:
         mov ecx, FullLength
         mov eax, ecx
         sub eax, ebx          // subtract alignment fix
         and eax, 0x00000007   // calc bytes over mult of 8
         sub ecx, eax          // drop over bytes from original length
         mov MMXLength, ecx
   } // end _asm block
   // Now do the math for the rest of the row
   switch ( bpp )
   {
      case 3:
      {
         ActiveMask.use = 0x0000000000ffffff;
         ActiveMaskEnd.use = 0xffff000000000000;
         ShiftBpp.use = 24;    // == bpp(3) * 8
         ShiftRem.use = 40;    // == 64 - 24
         _asm
         {
            mov ebx, diff
            mov edi, row
            mov esi, prev_row
            pxor mm0, mm0
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]
dpth3lp:
            psrlq mm1, ShiftRem     // shift last 3 bytes to 1st 3 bytes
            movq mm2, [esi + ebx]   // load b=Prior(x)
            punpcklbw mm1, mm0      // Unpack High bytes of a
            movq mm3, [esi+ebx-8]   // Prep c=Prior(x-bpp) bytes
            punpcklbw mm2, mm0      // Unpack High bytes of b
            psrlq mm3, ShiftRem     // shift last 3 bytes to 1st 3 bytes
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            punpcklbw mm3, mm0      // Unpack High bytes of c
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4    // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4       // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5    // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5       // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6    // Create mask pcv bytes < 0
            pand mm0, mm6       // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5    // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6       // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3
            pxor mm0, mm0
            packuswb mm7, mm1
            movq mm3, [esi + ebx]   // load c=Prior(x-bpp)
            pand mm7, ActiveMask
            movq mm2, mm3           // load b=Prior(x) step 1
            paddb mm7, [edi + ebx]  // add Paeth predictor with Raw(x)
            punpcklbw mm3, mm0      // Unpack High bytes of c
            movq [edi + ebx], mm7   // write back updated value
            movq mm1, mm7           // Now mm1 will be used as Raw(x-bpp)
            // Now do Paeth for 2nd set of bytes (3-5)
            psrlq mm2, ShiftBpp     // load b=Prior(x) step 2
            punpcklbw mm1, mm0      // Unpack High bytes of a
            pxor mm7, mm7
            punpcklbw mm2, mm0      // Unpack High bytes of b
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            psubw mm5, mm3
            psubw mm4, mm3
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) =
            //       pav + pbv = pbv + pav
            movq mm6, mm5
            paddw mm6, mm4

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm5       // Create mask pbv bytes < 0
            pcmpgtw mm7, mm4       // Create mask pav bytes < 0
            pand mm0, mm5          // Only pbv bytes < 0 in mm0
            pand mm7, mm4          // Only pav bytes < 0 in mm7
            psubw mm5, mm0
            psubw mm4, mm7
            psubw mm5, mm0
            psubw mm4, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6       // Create mask pcv bytes < 0
            pand mm0, mm6          // Only pav bytes < 0 in mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5       // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6       // pab > pc?
            movq mm2, [esi + ebx]  // load b=Prior(x)
            pand mm3, mm7
            pandn mm7, mm0
            pxor mm1, mm1
            paddw mm7, mm3
            pxor mm0, mm0
            packuswb mm7, mm1
            movq mm3, mm2           // load c=Prior(x-bpp) step 1
            pand mm7, ActiveMask
            punpckhbw mm2, mm0      // Unpack High bytes of b
            psllq mm7, ShiftBpp     // Shift bytes to 2nd group of 3 bytes
             // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            paddb mm7, [edi + ebx]  // add Paeth predictor with Raw(x)
            psllq mm3, ShiftBpp     // load c=Prior(x-bpp) step 2
            movq [edi + ebx], mm7   // write back updated value
            movq mm1, mm7
            punpckhbw mm3, mm0      // Unpack High bytes of c
            psllq mm1, ShiftBpp     // Shift bytes
                                    // Now mm1 will be used as Raw(x-bpp)
            // Now do Paeth for 3rd, and final, set of bytes (6-7)
            pxor mm7, mm7
            punpckhbw mm1, mm0      // Unpack High bytes of a
            psubw mm4, mm3
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            pxor mm0, mm0
            paddw mm6, mm5

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4    // Create mask pav bytes < 0
            pcmpgtw mm7, mm5    // Create mask pbv bytes < 0
            pand mm0, mm4       // Only pav bytes < 0 in mm7
            pand mm7, mm5       // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6    // Create mask pcv bytes < 0
            pand mm0, mm6       // Only pav bytes < 0 in mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5    // pa > pb?
            movq mm0, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            pandn mm0, mm1
            pandn mm7, mm4
            paddw mm0, mm2
            paddw mm7, mm5
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6    // pab > pc?
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3
            pxor mm1, mm1
            packuswb mm1, mm7
            // Step ebx to next set of 8 bytes and repeat loop til done
            add ebx, 8
            pand mm1, ActiveMaskEnd
            paddb mm1, [edi + ebx - 8] // add Paeth predictor with Raw(x)

            cmp ebx, MMXLength
            pxor mm0, mm0              // pxor does not affect flags
            movq [edi + ebx - 8], mm1  // write back updated value
                                 // mm1 will be used as Raw(x-bpp) next loop
                           // mm3 ready to be used as Prior(x-bpp) next loop
            jb dpth3lp
         } // end _asm block
      }
      break;

      case 6:
      case 7:
      case 5:
      {
         ActiveMask.use  = 0x00000000ffffffff;
         ActiveMask2.use = 0xffffffff00000000;
         ShiftBpp.use = bpp << 3;    // == bpp * 8
         ShiftRem.use = 64 - ShiftBpp.use;
         _asm
         {
            mov ebx, diff
            mov edi, row
            mov esi, prev_row
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]
            pxor mm0, mm0
dpth6lp:
            // Must shift to position Raw(x-bpp) data
            psrlq mm1, ShiftRem
            // Do first set of 4 bytes
            movq mm3, [esi+ebx-8]      // read c=Prior(x-bpp) bytes
            punpcklbw mm1, mm0      // Unpack Low bytes of a
            movq mm2, [esi + ebx]   // load b=Prior(x)
            punpcklbw mm2, mm0      // Unpack Low bytes of b
            // Must shift to position Prior(x-bpp) data
            psrlq mm3, ShiftRem
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            punpcklbw mm3, mm0      // Unpack Low bytes of c
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4    // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4       // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5    // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5       // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6    // Create mask pcv bytes < 0
            pand mm0, mm6       // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5    // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6    // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3
            pxor mm0, mm0
            packuswb mm7, mm1
            movq mm3, [esi + ebx - 8]  // load c=Prior(x-bpp)
            pand mm7, ActiveMask
            psrlq mm3, ShiftRem
            movq mm2, [esi + ebx]      // load b=Prior(x) step 1
            paddb mm7, [edi + ebx]     // add Paeth predictor with Raw(x)
            movq mm6, mm2
            movq [edi + ebx], mm7      // write back updated value
            movq mm1, [edi+ebx-8]
            psllq mm6, ShiftBpp
            movq mm5, mm7
            psrlq mm1, ShiftRem
            por mm3, mm6
            psllq mm5, ShiftBpp
            punpckhbw mm3, mm0         // Unpack High bytes of c
            por mm1, mm5
            // Do second set of 4 bytes
            punpckhbw mm2, mm0         // Unpack High bytes of b
            punpckhbw mm1, mm0         // Unpack High bytes of a
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4       // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4          // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5       // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5          // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6       // Create mask pcv bytes < 0
            pand mm0, mm6          // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5       // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6           // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            pxor mm1, mm1
            paddw mm7, mm3
            pxor mm0, mm0
            // Step ex to next set of 8 bytes and repeat loop til done
            add ebx, 8
            packuswb mm1, mm7
            paddb mm1, [edi + ebx - 8]     // add Paeth predictor with Raw(x)
            cmp ebx, MMXLength
            movq [edi + ebx - 8], mm1      // write back updated value
                                // mm1 will be used as Raw(x-bpp) next loop
            jb dpth6lp
         } // end _asm block
      }
      break;

      case 4:
      {
         ActiveMask.use  = 0x00000000ffffffff;
         _asm {
            mov ebx, diff
            mov edi, row
            mov esi, prev_row
            pxor mm0, mm0
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]    // Only time should need to read
                                     //  a=Raw(x-bpp) bytes
dpth4lp:
            // Do first set of 4 bytes
            movq mm3, [esi+ebx-8]    // read c=Prior(x-bpp) bytes
            punpckhbw mm1, mm0       // Unpack Low bytes of a
            movq mm2, [esi + ebx]    // load b=Prior(x)
            punpcklbw mm2, mm0       // Unpack High bytes of b
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            punpckhbw mm3, mm0       // Unpack High bytes of c
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4       // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4          // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5       // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5          // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6       // Create mask pcv bytes < 0
            pand mm0, mm6          // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5       // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6       // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3
            pxor mm0, mm0
            packuswb mm7, mm1
            movq mm3, [esi + ebx]      // load c=Prior(x-bpp)
            pand mm7, ActiveMask
            movq mm2, mm3              // load b=Prior(x) step 1
            paddb mm7, [edi + ebx]     // add Paeth predictor with Raw(x)
            punpcklbw mm3, mm0         // Unpack High bytes of c
            movq [edi + ebx], mm7      // write back updated value
            movq mm1, mm7              // Now mm1 will be used as Raw(x-bpp)
            // Do second set of 4 bytes
            punpckhbw mm2, mm0         // Unpack Low bytes of b
            punpcklbw mm1, mm0         // Unpack Low bytes of a
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4       // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4          // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5       // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5          // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6       // Create mask pcv bytes < 0
            pand mm0, mm6          // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5       // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6       // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            pxor mm1, mm1
            paddw mm7, mm3
            pxor mm0, mm0
            // Step ex to next set of 8 bytes and repeat loop til done
            add ebx, 8
            packuswb mm1, mm7
            paddb mm1, [edi + ebx - 8]     // add Paeth predictor with Raw(x)
            cmp ebx, MMXLength
            movq [edi + ebx - 8], mm1      // write back updated value
                                // mm1 will be used as Raw(x-bpp) next loop
            jb dpth4lp
         } // end _asm block
      }
      break;
      case 8:                          // bpp == 8
      {
         ActiveMask.use  = 0x00000000ffffffff;
         _asm {
            mov ebx, diff
            mov edi, row
            mov esi, prev_row
            pxor mm0, mm0
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]      // Only time should need to read
                                       //  a=Raw(x-bpp) bytes
dpth8lp:
            // Do first set of 4 bytes
            movq mm3, [esi+ebx-8]      // read c=Prior(x-bpp) bytes
            punpcklbw mm1, mm0         // Unpack Low bytes of a
            movq mm2, [esi + ebx]      // load b=Prior(x)
            punpcklbw mm2, mm0         // Unpack Low bytes of b
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            punpcklbw mm3, mm0         // Unpack Low bytes of c
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4       // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4          // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5       // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5          // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6       // Create mask pcv bytes < 0
            pand mm0, mm6          // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5       // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6       // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3
            pxor mm0, mm0
            packuswb mm7, mm1
            movq mm3, [esi+ebx-8]    // read c=Prior(x-bpp) bytes
            pand mm7, ActiveMask
            movq mm2, [esi + ebx]    // load b=Prior(x)
            paddb mm7, [edi + ebx]   // add Paeth predictor with Raw(x)
            punpckhbw mm3, mm0       // Unpack High bytes of c
            movq [edi + ebx], mm7    // write back updated value
            movq mm1, [edi+ebx-8]    // read a=Raw(x-bpp) bytes

            // Do second set of 4 bytes
            punpckhbw mm2, mm0       // Unpack High bytes of b
            punpckhbw mm1, mm0       // Unpack High bytes of a
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4       // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4          // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5       // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5          // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6       // Create mask pcv bytes < 0
            pand mm0, mm6          // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5       // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6       // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            pxor mm1, mm1
            paddw mm7, mm3
            pxor mm0, mm0
            // Step ex to next set of 8 bytes and repeat loop til done
            add ebx, 8
            packuswb mm1, mm7
            paddb mm1, [edi + ebx - 8]     // add Paeth predictor with Raw(x)
            cmp ebx, MMXLength
            movq [edi + ebx - 8], mm1      // write back updated value
                            // mm1 will be used as Raw(x-bpp) next loop
            jb dpth8lp
         } // end _asm block
      }
      break;

      case 1:                // bpp = 1
      case 2:                // bpp = 2
      default:               // bpp > 8
      {
         _asm {
            mov ebx, diff
            cmp ebx, FullLength
            jnb dpthdend
            mov edi, row
            mov esi, prev_row
            // Do Paeth decode for remaining bytes
            mov edx, ebx
            xor ecx, ecx        // zero ecx before using cl & cx in loop below
            sub edx, bpp        // Set edx = ebx - bpp
dpthdlp:
            xor eax, eax
            // pav = p - a = (a + b - c) - a = b - c
            mov al, [esi + ebx]        // load Prior(x) into al
            mov cl, [esi + edx]        // load Prior(x-bpp) into cl
            sub eax, ecx                 // subtract Prior(x-bpp)
            mov patemp, eax                 // Save pav for later use
            xor eax, eax
            // pbv = p - b = (a + b - c) - b = a - c
            mov al, [edi + edx]        // load Raw(x-bpp) into al
            sub eax, ecx                 // subtract Prior(x-bpp)
            mov ecx, eax
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            add eax, patemp                 // pcv = pav + pbv
            // pc = abs(pcv)
            test eax, 0x80000000
            jz dpthdpca
            neg eax                     // reverse sign of neg values
dpthdpca:
            mov pctemp, eax             // save pc for later use
            // pb = abs(pbv)
            test ecx, 0x80000000
            jz dpthdpba
            neg ecx                     // reverse sign of neg values
dpthdpba:
            mov pbtemp, ecx             // save pb for later use
            // pa = abs(pav)
            mov eax, patemp
            test eax, 0x80000000
            jz dpthdpaa
            neg eax                     // reverse sign of neg values
dpthdpaa:
            mov patemp, eax             // save pa for later use
            // test if pa <= pb
            cmp eax, ecx
            jna dpthdabb
            // pa > pb; now test if pb <= pc
            cmp ecx, pctemp
            jna dpthdbbc
            // pb > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
            mov cl, [esi + edx]  // load Prior(x-bpp) into cl
            jmp dpthdpaeth
dpthdbbc:
            // pb <= pc; Raw(x) = Paeth(x) + Prior(x)
            mov cl, [esi + ebx]        // load Prior(x) into cl
            jmp dpthdpaeth
dpthdabb:
            // pa <= pb; now test if pa <= pc
            cmp eax, pctemp
            jna dpthdabc
            // pa > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
            mov cl, [esi + edx]  // load Prior(x-bpp) into cl
            jmp dpthdpaeth
dpthdabc:
            // pa <= pc; Raw(x) = Paeth(x) + Raw(x-bpp)
            mov cl, [edi + edx]  // load Raw(x-bpp) into cl
dpthdpaeth:
            inc ebx
            inc edx
            // Raw(x) = (Paeth(x) + Paeth_Predictor( a, b, c )) mod 256
            add [edi + ebx - 1], cl
            cmp ebx, FullLength
            jb dpthdlp
dpthdend:
         } // end _asm block
      }
      return;                   // No need to go further with this one
   }                         // end switch ( bpp )
   _asm
   {
         // MMX acceleration complete now do clean-up
         // Check if any remaining bytes left to decode
         mov ebx, MMXLength
         cmp ebx, FullLength
         jnb dpthend
         mov edi, row
         mov esi, prev_row
         // Do Paeth decode for remaining bytes
         mov edx, ebx
         xor ecx, ecx         // zero ecx before using cl & cx in loop below
         sub edx, bpp         // Set edx = ebx - bpp
dpthlp2:
         xor eax, eax
         // pav = p - a = (a + b - c) - a = b - c
         mov al, [esi + ebx]  // load Prior(x) into al
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         sub eax, ecx         // subtract Prior(x-bpp)
         mov patemp, eax      // Save pav for later use
         xor eax, eax
         // pbv = p - b = (a + b - c) - b = a - c
         mov al, [edi + edx]  // load Raw(x-bpp) into al
         sub eax, ecx         // subtract Prior(x-bpp)
         mov ecx, eax
         // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
         add eax, patemp      // pcv = pav + pbv
         // pc = abs(pcv)
         test eax, 0x80000000
         jz dpthpca2
         neg eax              // reverse sign of neg values
dpthpca2:
         mov pctemp, eax      // save pc for later use
         // pb = abs(pbv)
         test ecx, 0x80000000
         jz dpthpba2
         neg ecx              // reverse sign of neg values
dpthpba2:
         mov pbtemp, ecx      // save pb for later use
         // pa = abs(pav)
         mov eax, patemp
         test eax, 0x80000000
         jz dpthpaa2
         neg eax              // reverse sign of neg values
dpthpaa2:
         mov patemp, eax      // save pa for later use
         // test if pa <= pb
         cmp eax, ecx
         jna dpthabb2
         // pa > pb; now test if pb <= pc
         cmp ecx, pctemp
         jna dpthbbc2
         // pb > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         jmp dpthpaeth2
dpthbbc2:
         // pb <= pc; Raw(x) = Paeth(x) + Prior(x)
         mov cl, [esi + ebx]        // load Prior(x) into cl
         jmp dpthpaeth2
dpthabb2:
         // pa <= pb; now test if pa <= pc
         cmp eax, pctemp
         jna dpthabc2
         // pa > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         jmp dpthpaeth2
dpthabc2:
         // pa <= pc; Raw(x) = Paeth(x) + Raw(x-bpp)
         mov cl, [edi + edx]  // load Raw(x-bpp) into cl
dpthpaeth2:
         inc ebx
         inc edx
         // Raw(x) = (Paeth(x) + Paeth_Predictor( a, b, c )) mod 256
         add [edi + ebx - 1], cl
         cmp ebx, FullLength
         jb dpthlp2
dpthend:
         emms             // End MMX instructions; prep for possible FP instrs.
   } // end _asm block
}

// Optimized code for PNG Sub filter decoder
void
png_read_filter_row_mmx_sub(png_row_infop row_info, png_bytep row)
{
   //int test;
   int bpp;
   png_uint_32 FullLength;
   png_uint_32 MMXLength;
   int diff;

   bpp = (row_info->pixel_depth + 7) >> 3; // Get # bytes per pixel
   FullLength  = row_info->rowbytes - bpp; // # of bytes to filter
   _asm {
        mov edi, row
        mov esi, edi               // lp = row
        add edi, bpp               // rp = row + bpp
        xor eax, eax
        // get # of bytes to alignment
        mov diff, edi               // take start of row
        add diff, 0xf               // add 7 + 8 to incr past
                                        // alignment boundary
        xor ebx, ebx
        and diff, 0xfffffff8        // mask to alignment boundary
        sub diff, edi               // subtract from start ==> value
                                        //  ebx at alignment
        jz dsubgo
        // fix alignment
dsublp1:
        mov al, [esi+ebx]
        add [edi+ebx], al
        inc ebx
        cmp ebx, diff
        jb dsublp1
dsubgo:
        mov ecx, FullLength
        mov edx, ecx
        sub edx, ebx                  // subtract alignment fix
        and edx, 0x00000007           // calc bytes over mult of 8
        sub ecx, edx                  // drop over bytes from length
        mov MMXLength, ecx
   } // end _asm block

   // Now do the math for the rest of the row
   switch ( bpp )
   {
        case 3:
        {
         ActiveMask.use  = 0x0000ffffff000000;
         ShiftBpp.use = 24;       // == 3 * 8
         ShiftRem.use  = 40;      // == 64 - 24
         _asm {
            mov edi, row
            movq mm7, ActiveMask  // Load ActiveMask for 2nd active byte group
            mov esi, edi              // lp = row
            add edi, bpp          // rp = row + bpp
            movq mm6, mm7
            mov ebx, diff
            psllq mm6, ShiftBpp   // Move mask in mm6 to cover 3rd active
                                  // byte group
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]
dsub3lp:
            psrlq mm1, ShiftRem   // Shift data for adding 1st bpp bytes
                          // no need for mask; shift clears inactive bytes
            // Add 1st active group
            movq mm0, [edi+ebx]
            paddb mm0, mm1
            // Add 2nd active group
            movq mm1, mm0         // mov updated Raws to mm1
            psllq mm1, ShiftBpp   // shift data to position correctly
            pand mm1, mm7         // mask to use only 2nd active group
            paddb mm0, mm1
            // Add 3rd active group
            movq mm1, mm0         // mov updated Raws to mm1
            psllq mm1, ShiftBpp   // shift data to position correctly
            pand mm1, mm6         // mask to use only 3rd active group
            add ebx, 8
            paddb mm0, mm1
            cmp ebx, MMXLength
            movq [edi+ebx-8], mm0     // Write updated Raws back to array
            // Prep for doing 1st add at top of loop
            movq mm1, mm0
            jb dsub3lp
         } // end _asm block
      }
      break;

      case 1:
      {
         // Placed here just in case this is a duplicate of the
         // non-MMX code for the SUB filter in png_read_filter_row above
         //
         //         png_bytep rp;
         //         png_bytep lp;
         //         png_uint_32 i;
         //         bpp = (row_info->pixel_depth + 7) >> 3;
         //         for (i = (png_uint_32)bpp, rp = row + bpp, lp = row;
         //            i < row_info->rowbytes; i++, rp++, lp++)
         //      {
         //            *rp = (png_byte)(((int)(*rp) + (int)(*lp)) & 0xff);
         //      }
         _asm {
            mov ebx, diff
            mov edi, row
            cmp ebx, FullLength
            jnb dsub1end
            mov esi, edi          // lp = row
            xor eax, eax
            add edi, bpp      // rp = row + bpp
dsub1lp:
            mov al, [esi+ebx]
            add [edi+ebx], al
            inc ebx
            cmp ebx, FullLength
            jb dsub1lp
dsub1end:
         } // end _asm block
      }
      return;

      case 6:
      case 7:
      case 4:
      case 5:
      {
         ShiftBpp.use = bpp << 3;
         ShiftRem.use = 64 - ShiftBpp.use;
         _asm {
            mov edi, row
            mov ebx, diff
            mov esi, edi               // lp = row
            add edi, bpp           // rp = row + bpp
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]
dsub4lp:
            psrlq mm1, ShiftRem // Shift data for adding 1st bpp bytes
                          // no need for mask; shift clears inactive bytes
            movq mm0, [edi+ebx]
            paddb mm0, mm1
            // Add 2nd active group
            movq mm1, mm0          // mov updated Raws to mm1
            psllq mm1, ShiftBpp    // shift data to position correctly
                                   // there is no need for any mask
                                   // since shift clears inactive bits/bytes
            add ebx, 8
            paddb mm0, mm1
            cmp ebx, MMXLength
            movq [edi+ebx-8], mm0
            movq mm1, mm0          // Prep for doing 1st add at top of loop
            jb dsub4lp
         } // end _asm block
      }
      break;

      case 2:
      {
         ActiveMask.use  = 0x00000000ffff0000;
         ShiftBpp.use = 16;       // == 2 * 8
         ShiftRem.use = 48;       // == 64 - 16
         _asm {
            movq mm7, ActiveMask  // Load ActiveMask for 2nd active byte group
            mov ebx, diff
            movq mm6, mm7
            mov edi, row
            psllq mm6, ShiftBpp     // Move mask in mm6 to cover 3rd active
                                    //  byte group
            mov esi, edi            // lp = row
            movq mm5, mm6
            add edi, bpp            // rp = row + bpp
            psllq mm5, ShiftBpp     // Move mask in mm5 to cover 4th active
                                    //  byte group
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]
dsub2lp:
            // Add 1st active group
            psrlq mm1, ShiftRem     // Shift data for adding 1st bpp bytes
                                    // no need for mask; shift clears inactive
                                    //  bytes
            movq mm0, [edi+ebx]
            paddb mm0, mm1
            // Add 2nd active group
            movq mm1, mm0           // mov updated Raws to mm1
            psllq mm1, ShiftBpp     // shift data to position correctly
            pand mm1, mm7           // mask to use only 2nd active group
            paddb mm0, mm1
            // Add 3rd active group
            movq mm1, mm0           // mov updated Raws to mm1
            psllq mm1, ShiftBpp     // shift data to position correctly
            pand mm1, mm6           // mask to use only 3rd active group
            paddb mm0, mm1
            // Add 4th active group
            movq mm1, mm0           // mov updated Raws to mm1
            psllq mm1, ShiftBpp     // shift data to position correctly
            pand mm1, mm5           // mask to use only 4th active group
            add ebx, 8
            paddb mm0, mm1
            cmp ebx, MMXLength
            movq [edi+ebx-8], mm0   // Write updated Raws back to array
            movq mm1, mm0           // Prep for doing 1st add at top of loop
            jb dsub2lp
         } // end _asm block
      }
      break;
      case 8:
      {
         _asm {
            mov edi, row
            mov ebx, diff
            mov esi, edi            // lp = row
            add edi, bpp            // rp = row + bpp
            mov ecx, MMXLength
            movq mm7, [edi+ebx-8]   // PRIME the pump (load the first
                                    // Raw(x-bpp) data set
            and ecx, 0x0000003f     // calc bytes over mult of 64
dsub8lp:
            movq mm0, [edi+ebx]     // Load Sub(x) for 1st 8 bytes
            paddb mm0, mm7
            movq mm1, [edi+ebx+8]   // Load Sub(x) for 2nd 8 bytes
            movq [edi+ebx], mm0    // Write Raw(x) for 1st 8 bytes
                                   // Now mm0 will be used as Raw(x-bpp) for
                                   // the 2nd group of 8 bytes.  This will be
                                   // repeated for each group of 8 bytes with
                                   // the 8th group being used as the Raw(x-bpp)
                                   // for the 1st group of the next loop.
            paddb mm1, mm0
            movq mm2, [edi+ebx+16]  // Load Sub(x) for 3rd 8 bytes
            movq [edi+ebx+8], mm1   // Write Raw(x) for 2nd 8 bytes
            paddb mm2, mm1
            movq mm3, [edi+ebx+24]  // Load Sub(x) for 4th 8 bytes
            movq [edi+ebx+16], mm2  // Write Raw(x) for 3rd 8 bytes
            paddb mm3, mm2
            movq mm4, [edi+ebx+32]  // Load Sub(x) for 5th 8 bytes
            movq [edi+ebx+24], mm3  // Write Raw(x) for 4th 8 bytes
            paddb mm4, mm3
            movq mm5, [edi+ebx+40]  // Load Sub(x) for 6th 8 bytes
            movq [edi+ebx+32], mm4  // Write Raw(x) for 5th 8 bytes
            paddb mm5, mm4
            movq mm6, [edi+ebx+48]  // Load Sub(x) for 7th 8 bytes
            movq [edi+ebx+40], mm5  // Write Raw(x) for 6th 8 bytes
            paddb mm6, mm5
            movq mm7, [edi+ebx+56]  // Load Sub(x) for 8th 8 bytes
            movq [edi+ebx+48], mm6  // Write Raw(x) for 7th 8 bytes
            add ebx, 64
            paddb mm7, mm6
            cmp ebx, ecx
            movq [edi+ebx-8], mm7   // Write Raw(x) for 8th 8 bytes
            jb dsub8lp
            cmp ebx, MMXLength
            jnb dsub8lt8
dsub8lpA:
            movq mm0, [edi+ebx]
            add ebx, 8
            paddb mm0, mm7
            cmp ebx, MMXLength
            movq [edi+ebx-8], mm0   // use -8 to offset early add to ebx
            movq mm7, mm0           // Move calculated Raw(x) data to mm1 to
                                    // be the new Raw(x-bpp) for the next loop
            jb dsub8lpA
dsub8lt8:
         } // end _asm block
      }
      break;

      default:                // bpp greater than 8 bytes
      {
         _asm {
            mov ebx, diff
            mov edi, row
            mov esi, edi           // lp = row
            add edi, bpp           // rp = row + bpp
dsubAlp:
            movq mm0, [edi+ebx]
            movq mm1, [esi+ebx]
            add ebx, 8
            paddb mm0, mm1
            cmp ebx, MMXLength
            movq [edi+ebx-8], mm0  // mov does not affect flags; -8 to offset
                                   //  add ebx
            jb dsubAlp
         } // end _asm block
      }
      break;

   } // end switch ( bpp )

   _asm {
        mov ebx, MMXLength
        mov edi, row
        cmp ebx, FullLength
        jnb dsubend
        mov esi, edi               // lp = row
        xor eax, eax
        add edi, bpp               // rp = row + bpp
dsublp2:
        mov al, [esi+ebx]
        add [edi+ebx], al
        inc ebx
        cmp ebx, FullLength
        jb dsublp2
dsubend:
        emms             // End MMX instructions; prep for possible FP instrs.
   } // end _asm block
}

// Optimized code for PNG Up filter decoder
void
png_read_filter_row_mmx_up(png_row_infop row_info, png_bytep row,
   png_bytep prev_row)
{
   png_uint_32 len;
   len  = row_info->rowbytes;       // # of bytes to filter
   _asm {
      mov edi, row
      // get # of bytes to alignment
      mov ecx, edi
      xor ebx, ebx
      add ecx, 0x7
      xor eax, eax
      and ecx, 0xfffffff8
      mov esi, prev_row
      sub ecx, edi
      jz dupgo
      // fix alignment
duplp1:
      mov al, [edi+ebx]
      add al, [esi+ebx]
      inc ebx
      cmp ebx, ecx
      mov [edi + ebx-1], al  // mov does not affect flags; -1 to offset inc ebx
      jb duplp1
dupgo:
      mov ecx, len
      mov edx, ecx
      sub edx, ebx                  // subtract alignment fix
      and edx, 0x0000003f           // calc bytes over mult of 64
      sub ecx, edx                  // drop over bytes from length
      // Unrolled loop - use all MMX registers and interleave to reduce
      // number of branch instructions (loops) and reduce partial stalls
duploop:
      movq mm1, [esi+ebx]
      movq mm0, [edi+ebx]
      movq mm3, [esi+ebx+8]
      paddb mm0, mm1
      movq mm2, [edi+ebx+8]
      movq [edi+ebx], mm0
      paddb mm2, mm3
      movq mm5, [esi+ebx+16]
      movq [edi+ebx+8], mm2
      movq mm4, [edi+ebx+16]
      movq mm7, [esi+ebx+24]
      paddb mm4, mm5
      movq mm6, [edi+ebx+24]
      movq [edi+ebx+16], mm4
      paddb mm6, mm7
      movq mm1, [esi+ebx+32]
      movq [edi+ebx+24], mm6
      movq mm0, [edi+ebx+32]
      movq mm3, [esi+ebx+40]
      paddb mm0, mm1
      movq mm2, [edi+ebx+40]
      movq [edi+ebx+32], mm0
      paddb mm2, mm3
      movq mm5, [esi+ebx+48]
      movq [edi+ebx+40], mm2
      movq mm4, [edi+ebx+48]
      movq mm7, [esi+ebx+56]
      paddb mm4, mm5
      movq mm6, [edi+ebx+56]
      movq [edi+ebx+48], mm4
      add ebx, 64
      paddb mm6, mm7
      cmp ebx, ecx
      movq [edi+ebx-8], mm6 // (+56)movq does not affect flags;
                                     // -8 to offset add ebx
      jb duploop

      cmp edx, 0                     // Test for bytes over mult of 64
      jz dupend


      // 2 lines added by lcreeve@netins.net
      // (mail 11 Jul 98 in png-implement list)
      cmp edx, 8 //test for less than 8 bytes
      jb duplt8


      add ecx, edx
      and edx, 0x00000007           // calc bytes over mult of 8
      sub ecx, edx                  // drop over bytes from length
      jz duplt8
      // Loop using MMX registers mm0 & mm1 to update 8 bytes simultaneously
duplpA:
      movq mm1, [esi+ebx]
      movq mm0, [edi+ebx]
      add ebx, 8
      paddb mm0, mm1
      cmp ebx, ecx
      movq [edi+ebx-8], mm0 // movq does not affect flags; -8 to offset add ebx
      jb duplpA
      cmp edx, 0            // Test for bytes over mult of 8
      jz dupend
duplt8:
      xor eax, eax
      add ecx, edx          // move over byte count into counter
      // Loop using x86 registers to update remaining bytes
duplp2:
      mov al, [edi + ebx]
      add al, [esi + ebx]
      inc ebx
      cmp ebx, ecx
      mov [edi + ebx-1], al // mov does not affect flags; -1 to offset inc ebx
      jb duplp2
dupend:
      // Conversion of filtered row completed
      emms          // End MMX instructions; prep for possible FP instrs.
   } // end _asm block
}


// Optimized png_read_filter_row routines
void
png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep
   row, png_bytep prev_row, int filter)
{
#ifdef PNG_DEBUG
   char filnm[6];
#endif
   #define UseMMX 1

   if (mmx_supported == 2)
       mmx_supported = mmxsupport();

   if (!mmx_supported)
   {
       png_read_filter_row_c(png_ptr, row_info, row, prev_row, filter);
       return ;
   }

#ifdef PNG_DEBUG
   png_debug(1, "in png_read_filter_row\n");
#if (UseMMX == 1)
   png_debug1(0,"%s, ", "MMX");
#else
   png_debug1(0,"%s, ", "x86");
#endif
   switch (filter)
   {
      case 0: sprintf(filnm, "None ");
         break;
      case 1: sprintf(filnm, "Sub  ");
         break;
      case 2: sprintf(filnm, "Up   ");
         break;
      case 3: sprintf(filnm, "Avg  ");
         break;
      case 4: sprintf(filnm, "Paeth");
         break;
      default: sprintf(filnm, "Unknw");
         break;
   }
   png_debug2(0,"row=%5d, %s, ", png_ptr->row_number, filnm);
   png_debug2(0, "pd=%2d, b=%d, ", (int)row_info->pixel_depth,
      (int)((row_info->pixel_depth + 7) >> 3));
   png_debug1(0,"len=%8d, ", row_info->rowbytes);
#endif

   switch (filter)
   {
      case PNG_FILTER_VALUE_NONE:
         break;
      case PNG_FILTER_VALUE_SUB:
      {
#if (UseMMX == 1)
         if ((row_info->pixel_depth > 8) &&
            (row_info->rowbytes >= 128) )
         {
            png_read_filter_row_mmx_sub(row_info, row);
         }
         else
#endif
         {
            png_uint_32 i;
            png_uint_32 istop = row_info->rowbytes;
            png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
            png_bytep rp = row + bpp;
            png_bytep lp = row;

            for (i = bpp; i < istop; i++)
            {
               *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);
               rp++;
            }
         }  //end !UseMMX
         break;
      }
      case PNG_FILTER_VALUE_UP:
      {
#if (UseMMX == 1)
         if ((row_info->pixel_depth > 8) &&
             (row_info->rowbytes >= 128) )
         {
            png_read_filter_row_mmx_up(row_info, row, prev_row);
         }  //end if UseMMX
         else
#endif
         {
            png_bytep rp;
            png_bytep pp;
            png_uint_32 i;
            for (i = 0, rp = row, pp = prev_row;
               i < row_info->rowbytes; i++, rp++, pp++)
            {
                  *rp = (png_byte)(((int)(*rp) + (int)(*pp)) & 0xff);
            }
         }  //end !UseMMX
         break;
      }
      case PNG_FILTER_VALUE_AVG:
      {
#if (UseMMX == 1)
         if ((row_info->pixel_depth > 8) &&
             (row_info->rowbytes >= 128) )
         {
            png_read_filter_row_mmx_avg(row_info, row, prev_row);
         }  //end if UseMMX
         else
#endif
         {
            png_uint_32 i;
            png_bytep rp = row;
            png_bytep pp = prev_row;
            png_bytep lp = row;
            png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
            png_uint_32 istop = row_info->rowbytes - bpp;

            for (i = 0; i < bpp; i++)
            {
               *rp = (png_byte)(((int)(*rp) +
                  ((int)(*pp++) >> 1)) & 0xff);
               rp++;
            }

            for (i = 0; i < istop; i++)
            {
               *rp = (png_byte)(((int)(*rp) +
                  ((int)(*pp++ + *lp++) >> 1)) & 0xff);
               rp++;
            }
         }  //end !UseMMX
         break;
      }
      case PNG_FILTER_VALUE_PAETH:
      {
#if (UseMMX == 1)
         if ((row_info->pixel_depth > 8) &&
             (row_info->rowbytes >= 128) )
         {
            png_read_filter_row_mmx_paeth(row_info, row, prev_row);
         }  //end if UseMMX
         else
#endif
         {
            png_uint_32 i;
            png_bytep rp = row;
            png_bytep pp = prev_row;
            png_bytep lp = row;
            png_bytep cp = prev_row;
            png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
            png_uint_32 istop=row_info->rowbytes - bpp;

            for (i = 0; i < bpp; i++)
            {
               *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
               rp++;
            }

            for (i = 0; i < istop; i++)   // use leftover rp,pp
            {
               int a, b, c, pa, pb, pc, p;

               a = *lp++;
               b = *pp++;
               c = *cp++;

               p = b - c;
               pc = a - c;

#ifdef PNG_USE_ABS
               pa = abs(p);
               pb = abs(pc);
               pc = abs(p + pc);
#else
               pa = p < 0 ? -p : p;
               pb = pc < 0 ? -pc : pc;
               pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif

               /*
                  if (pa <= pb && pa <= pc)
                     p = a;
                  else if (pb <= pc)
                     p = b;
                  else
                     p = c;
                */

               p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;

               *rp = (png_byte)(((int)(*rp) + p) & 0xff);
               rp++;
            }
         }  //end !UseMMX
         break;
      }
      default:
         png_error(png_ptr, "Bad adaptive filter type");
         break;
   }
}
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\pngwrite.cpp ===
/* pngwrite.c - general routines to write a PNG file
 *
 * libpng 1.0.5 - October 15, 1999
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
 * Copyright (c) 1996, 1997 Andreas Dilger
 * Copyright (c) 1998, 1999 Glenn Randers-Pehrson
 */

/* get internal access to png.h */
#define PNG_INTERNAL
#include "png.h"

namespace D3DX
{

/* Writes all the PNG information.  This is the suggested way to use the
 * library.  If you have a new chunk to add, make a function to write it,
 * and put it in the correct location here.  If you want the chunk written
 * after the image data, put it in png_write_end().  I strongly encourage
 * you to supply a PNG_INFO_ flag, and check info_ptr->valid before writing
 * the chunk, as that will keep the code from breaking if you want to just
 * write a plain PNG file.  If you have long comments, I suggest writing
 * them in png_write_end(), and compressing them.
 */
void
png_write_info(png_structp png_ptr, png_infop info_ptr)
{
#if defined(PNG_WRITE_tEXt_SUPPORTED) || defined(PNG_WRITE_zTXt_SUPPORTED)
   int i;
#endif

   png_debug(1, "in png_write_info\n");
   png_write_sig(png_ptr); /* write PNG signature */
   /* write IHDR information. */
   png_write_IHDR(png_ptr, info_ptr->width, info_ptr->height,
      info_ptr->bit_depth, info_ptr->color_type, info_ptr->compression_type,
      info_ptr->filter_type,
#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
      info_ptr->interlace_type);
#else
      0);
#endif
   /* the rest of these check to see if the valid field has the appropriate
      flag set, and if it does, writes the chunk. */
#if defined(PNG_WRITE_gAMA_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_gAMA)
      png_write_gAMA(png_ptr, info_ptr->gamma);
#endif
#if defined(PNG_WRITE_sRGB_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_sRGB)
      png_write_sRGB(png_ptr, (int)info_ptr->srgb_intent);
#endif
#if defined(PNG_WRITE_sBIT_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_sBIT)
      png_write_sBIT(png_ptr, &(info_ptr->sig_bit), info_ptr->color_type);
#endif
#if defined(PNG_WRITE_cHRM_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_cHRM)
      png_write_cHRM(png_ptr,
         info_ptr->x_white, info_ptr->y_white,
         info_ptr->x_red, info_ptr->y_red,
         info_ptr->x_green, info_ptr->y_green,
         info_ptr->x_blue, info_ptr->y_blue);
#endif
   if (info_ptr->valid & PNG_INFO_PLTE)
      png_write_PLTE(png_ptr, info_ptr->palette,
         (png_uint_32)info_ptr->num_palette);
   else if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      png_error(png_ptr, "Valid palette required for paletted images\n");

#if defined(PNG_WRITE_tRNS_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_tRNS)
      {
#if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
         /* invert the alpha channel (in tRNS) */
         if (png_ptr->transformations & PNG_INVERT_ALPHA &&
            info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
         {
            int j;
            for (j=0; j<(int)info_ptr->num_trans; j++)
               info_ptr->trans[j] = (png_byte)(255 - info_ptr->trans[j]);
         }
#endif
      png_write_tRNS(png_ptr, info_ptr->trans, &(info_ptr->trans_values),
         info_ptr->num_trans, info_ptr->color_type);
      }
#endif
#if defined(PNG_WRITE_bKGD_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_bKGD)
      png_write_bKGD(png_ptr, &(info_ptr->background), info_ptr->color_type);
#endif
#if defined(PNG_WRITE_hIST_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_hIST)
      png_write_hIST(png_ptr, info_ptr->hist, info_ptr->num_palette);
#endif
#if defined(PNG_WRITE_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
      png_write_oFFs(png_ptr, info_ptr->x_offset, info_ptr->y_offset,
         info_ptr->offset_unit_type);
#endif
#if defined(PNG_WRITE_pCAL_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pCAL)
      png_write_pCAL(png_ptr, info_ptr->pcal_purpose, info_ptr->pcal_X0,
         info_ptr->pcal_X1, info_ptr->pcal_type, info_ptr->pcal_nparams,
         info_ptr->pcal_units, info_ptr->pcal_params);
#endif
#if defined(PNG_WRITE_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
      png_write_pHYs(png_ptr, info_ptr->x_pixels_per_unit,
         info_ptr->y_pixels_per_unit, info_ptr->phys_unit_type);
#endif
#if defined(PNG_WRITE_tIME_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_tIME)
   {
      png_write_tIME(png_ptr, &(info_ptr->mod_time));
      png_ptr->flags |= PNG_FLAG_WROTE_tIME;
   }
#endif
#if defined(PNG_WRITE_tEXt_SUPPORTED) || defined(PNG_WRITE_zTXt_SUPPORTED)
   /* Check to see if we need to write text chunks */
   for (i = 0; i < info_ptr->num_text; i++)
   {
      png_debug2(2, "Writing header text chunk %d, type %d\n", i,
         info_ptr->text[i].compression);
      /* If we want a compressed text chunk */
      if (info_ptr->text[i].compression >= PNG_TEXT_COMPRESSION_zTXt)
      {
#if defined(PNG_WRITE_zTXt_SUPPORTED)
         /* write compressed chunk */
         png_write_zTXt(png_ptr, info_ptr->text[i].key,
            info_ptr->text[i].text, info_ptr->text[i].text_length,
            info_ptr->text[i].compression);
#else
         png_warning(png_ptr, "Unable to write compressed text\n");
#endif
         /* Mark this chunk as written */
         info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
      }
      else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
      {
#if defined(PNG_WRITE_tEXt_SUPPORTED)
         /* write uncompressed chunk */
         png_write_tEXt(png_ptr, info_ptr->text[i].key,
            info_ptr->text[i].text, info_ptr->text[i].text_length);
#else
         png_warning(png_ptr, "Unable to write uncompressed text\n");
#endif
         /* Mark this chunk as written */
         info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
      }
   }
#endif
}

/* Writes the end of the PNG file.  If you don't want to write comments or
 * time information, you can pass NULL for info.  If you already wrote these
 * in png_write_info(), do not write them again here.  If you have long
 * comments, I suggest writing them here, and compressing them.
 */
void
png_write_end(png_structp png_ptr, png_infop info_ptr)
{
   png_debug(1, "in png_write_end\n");
   if (!(png_ptr->mode & PNG_HAVE_IDAT))
      png_error(png_ptr, "No IDATs written into file");

   /* see if user wants us to write information chunks */
   if (info_ptr != NULL)
   {
#if defined(PNG_WRITE_tEXt_SUPPORTED) || defined(PNG_WRITE_zTXt_SUPPORTED)
      int i; /* local index variable */
#endif
#if defined(PNG_WRITE_tIME_SUPPORTED)
      /* check to see if user has supplied a time chunk */
      if (info_ptr->valid & PNG_INFO_tIME &&
         !(png_ptr->flags & PNG_FLAG_WROTE_tIME))
         png_write_tIME(png_ptr, &(info_ptr->mod_time));
#endif
#if defined(PNG_WRITE_tEXt_SUPPORTED) || defined(PNG_WRITE_zTXt_SUPPORTED)
      /* loop through comment chunks */
      for (i = 0; i < info_ptr->num_text; i++)
      {
         png_debug2(2, "Writing trailer text chunk %d, type %d\n", i,
            info_ptr->text[i].compression);
         if (info_ptr->text[i].compression >= PNG_TEXT_COMPRESSION_zTXt)
         {
#if defined(PNG_WRITE_zTXt_SUPPORTED)
            /* write compressed chunk */
            png_write_zTXt(png_ptr, info_ptr->text[i].key,
               info_ptr->text[i].text, info_ptr->text[i].text_length,
               info_ptr->text[i].compression);
#else
            png_warning(png_ptr, "Unable to write compressed text\n");
#endif
            /* Mark this chunk as written */
            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
         }
         else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
         {
#if defined(PNG_WRITE_tEXt_SUPPORTED)
            /* write uncompressed chunk */
            png_write_tEXt(png_ptr, info_ptr->text[i].key,
               info_ptr->text[i].text, info_ptr->text[i].text_length);
#else
            png_warning(png_ptr, "Unable to write uncompressed text\n");
#endif

            /* Mark this chunk as written */
            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
         }
      }
#endif
   }

   png_ptr->mode |= PNG_AFTER_IDAT;

   /* write end of PNG file */
   png_write_IEND(png_ptr);
}

#if defined(PNG_WRITE_tIME_SUPPORTED)
void
png_convert_from_struct_tm(png_timep ptime, struct tm FAR * ttime)
{
   png_debug(1, "in png_convert_from_struct_tm\n");
   ptime->year = (png_uint_16)(1900 + ttime->tm_year);
   ptime->month = (png_byte)(ttime->tm_mon + 1);
   ptime->day = (png_byte)ttime->tm_mday;
   ptime->hour = (png_byte)ttime->tm_hour;
   ptime->minute = (png_byte)ttime->tm_min;
   ptime->second = (png_byte)ttime->tm_sec;
}

void
png_convert_from_time_t(png_timep ptime, time_t ttime)
{
   struct tm *tbuf;

   png_debug(1, "in png_convert_from_time_t\n");
   tbuf = gmtime(&ttime);
   png_convert_from_struct_tm(ptime, tbuf);
}
#endif

/* Initialize png_ptr structure, and allocate any memory needed */
png_structp
png_create_write_struct(png_const_charp user_png_ver, png_voidp error_ptr,
   png_error_ptr error_fn, png_error_ptr warn_fn)
{
#ifdef PNG_USER_MEM_SUPPORTED
   return (png_create_write_struct_2(user_png_ver, error_ptr, error_fn,
      warn_fn, NULL, NULL, NULL));
}

/* Alternate initialize png_ptr structure, and allocate any memory needed */
png_structp
png_create_write_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,
   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
   png_malloc_ptr malloc_fn, png_free_ptr free_fn)
{
#endif /* PNG_USER_MEM_SUPPORTED */
   png_structp png_ptr;
#ifdef USE_FAR_KEYWORD
   jmp_buf jmpbuf;
#endif
   png_debug(1, "in png_create_write_struct\n");
#ifdef PNG_USER_MEM_SUPPORTED
   if ((png_ptr = (png_structp)png_create_struct_2(PNG_STRUCT_PNG,
      (png_malloc_ptr)malloc_fn)) == NULL)
#else
   if ((png_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG)) == NULL)
#endif /* PNG_USER_MEM_SUPPORTED */
   {
      return ((png_structp)NULL);
   }
#ifdef USE_FAR_KEYWORD
   if (setjmp(jmpbuf))
#else
   if (setjmp(png_ptr->jmpbuf))
#endif
   {
      png_free(png_ptr, png_ptr->zbuf);
      png_destroy_struct(png_ptr);
      return ((png_structp)NULL);
   }
#ifdef USE_FAR_KEYWORD
   png_memcpy(png_ptr->jmpbuf,jmpbuf,sizeof(jmp_buf));
#endif
#ifdef PNG_USER_MEM_SUPPORTED
   png_set_mem_fn(png_ptr, mem_ptr, malloc_fn, free_fn);
#endif /* PNG_USER_MEM_SUPPORTED */
   png_set_error_fn(png_ptr, error_ptr, error_fn, warn_fn);

   /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so
    * we must recompile any applications that use any older library version.
    * For versions after libpng 1.0, we will be compatible, so we need
    * only check the first digit.
    */
   if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||
       (png_libpng_ver[0] == '0' && user_png_ver[2] < '9'))
   {
      png_error(png_ptr,
         "Incompatible libpng version in application and library");
   }

   /* initialize zbuf - compression buffer */
   png_ptr->zbuf_size = PNG_ZBUF_SIZE;
   png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
      (png_uint_32)png_ptr->zbuf_size);

   png_set_write_fn(png_ptr, NULL, NULL, NULL);

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   png_set_filter_heuristics(png_ptr, PNG_FILTER_HEURISTIC_DEFAULT,
      1, NULL, NULL);
#endif

   return ((png_structp)png_ptr);
}

/* Initialize png_ptr structure, and allocate any memory needed */
void
png_write_init(png_structp png_ptr)
{
   jmp_buf tmp_jmp; /* to save current jump buffer */

   png_debug(1, "in png_write_init\n");
   /* save jump buffer and error functions */
   png_memcpy(tmp_jmp, png_ptr->jmpbuf, sizeof (jmp_buf));

   /* reset all variables to 0 */
   png_memset(png_ptr, 0, sizeof (png_struct));

   /* restore jump buffer */
   png_memcpy(png_ptr->jmpbuf, tmp_jmp, sizeof (jmp_buf));

   /* initialize zbuf - compression buffer */
   png_ptr->zbuf_size = PNG_ZBUF_SIZE;
   png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
      (png_uint_32)png_ptr->zbuf_size);
   png_set_write_fn(png_ptr, NULL, NULL, NULL);

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   png_set_filter_heuristics(png_ptr, PNG_FILTER_HEURISTIC_DEFAULT,
      1, NULL, NULL);
#endif
}

/* Write a few rows of image data.  If the image is interlaced,
 * either you will have to write the 7 sub images, or, if you
 * have called png_set_interlace_handling(), you will have to
 * "write" the image seven times.
 */
void
png_write_rows(png_structp png_ptr, png_bytepp row,
   png_uint_32 num_rows)
{
   png_uint_32 i; /* row counter */
   png_bytepp rp; /* row pointer */

   png_debug(1, "in png_write_rows\n");
   /* loop through the rows */
   for (i = 0, rp = row; i < num_rows; i++, rp++)
   {
      png_write_row(png_ptr, *rp);
   }
}

/* Write the image.  You only need to call this function once, even
 * if you are writing an interlaced image.
 */
void
png_write_image(png_structp png_ptr, png_bytepp image)
{
   png_uint_32 i; /* row index */
   int pass, num_pass; /* pass variables */
   png_bytepp rp; /* points to current row */

   png_debug(1, "in png_write_image\n");
#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
   /* intialize interlace handling.  If image is not interlaced,
      this will set pass to 1 */
   num_pass = png_set_interlace_handling(png_ptr);
#else
   num_pass = 1;
#endif
   /* loop through passes */
   for (pass = 0; pass < num_pass; pass++)
   {
      /* loop through image */
      for (i = 0, rp = image; i < png_ptr->height; i++, rp++)
      {
         png_write_row(png_ptr, *rp);
      }
   }
}

/* called by user to write a row of image data */
void
png_write_row(png_structp png_ptr, png_bytep row)
{
   png_debug2(1, "in png_write_row (row %ld, pass %d)\n",
      png_ptr->row_number, png_ptr->pass);
   /* initialize transformations and other stuff if first time */
   if (png_ptr->row_number == 0 && png_ptr->pass == 0)
   {
   /* check for transforms that have been set but were defined out */
#if !defined(PNG_WRITE_INVERT_SUPPORTED) && defined(PNG_READ_INVERT_SUPPORTED)
   if (png_ptr->transformations & PNG_INVERT_MONO)
      png_warning(png_ptr, "PNG_WRITE_INVERT_SUPPORTED is not defined.");
#endif
#if !defined(PNG_WRITE_FILLER_SUPPORTED) && defined(PNG_READ_FILLER_SUPPORTED)
   if (png_ptr->transformations & PNG_FILLER)
      png_warning(png_ptr, "PNG_WRITE_FILLER_SUPPORTED is not defined.");
#endif
#if !defined(PNG_WRITE_PACKSWAP_SUPPORTED) && defined(PNG_READ_PACKSWAP_SUPPORTED)
   if (png_ptr->transformations & PNG_PACKSWAP)
      png_warning(png_ptr, "PNG_WRITE_PACKSWAP_SUPPORTED is not defined.");
#endif
#if !defined(PNG_WRITE_PACK_SUPPORTED) && defined(PNG_READ_PACK_SUPPORTED)
   if (png_ptr->transformations & PNG_PACK)
      png_warning(png_ptr, "PNG_WRITE_PACK_SUPPORTED is not defined.");
#endif
#if !defined(PNG_WRITE_SHIFT_SUPPORTED) && defined(PNG_READ_SHIFT_SUPPORTED)
   if (png_ptr->transformations & PNG_SHIFT)
      png_warning(png_ptr, "PNG_WRITE_SHIFT_SUPPORTED is not defined.");
#endif
#if !defined(PNG_WRITE_BGR_SUPPORTED) && defined(PNG_READ_BGR_SUPPORTED)
   if (png_ptr->transformations & PNG_BGR)
      png_warning(png_ptr, "PNG_WRITE_BGR_SUPPORTED is not defined.");
#endif
#if !defined(PNG_WRITE_SWAP_SUPPORTED) && defined(PNG_READ_SWAP_SUPPORTED)
   if (png_ptr->transformations & PNG_SWAP_BYTES)
      png_warning(png_ptr, "PNG_WRITE_SWAP_SUPPORTED is not defined.");
#endif

      png_write_start_row(png_ptr);
   }

#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
   /* if interlaced and not interested in row, return */
   if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))
   {
      switch (png_ptr->pass)
      {
         case 0:
            if (png_ptr->row_number & 7)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
         case 1:
            if ((png_ptr->row_number & 7) || png_ptr->width < 5)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
         case 2:
            if ((png_ptr->row_number & 7) != 4)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
         case 3:
            if ((png_ptr->row_number & 3) || png_ptr->width < 3)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
         case 4:
            if ((png_ptr->row_number & 3) != 2)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
         case 5:
            if ((png_ptr->row_number & 1) || png_ptr->width < 2)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
         case 6:
            if (!(png_ptr->row_number & 1))
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
      }
   }
#endif

   /* set up row info for transformations */
   png_ptr->row_info.color_type = png_ptr->color_type;
   png_ptr->row_info.width = png_ptr->usr_width;
   png_ptr->row_info.channels = png_ptr->usr_channels;
   png_ptr->row_info.bit_depth = png_ptr->usr_bit_depth;
   png_ptr->row_info.pixel_depth = (png_byte)(png_ptr->row_info.bit_depth *
      png_ptr->row_info.channels);

   png_ptr->row_info.rowbytes = ((png_ptr->row_info.width *
      (png_uint_32)png_ptr->row_info.pixel_depth + 7) >> 3);

   png_debug1(3, "row_info->color_type = %d\n", png_ptr->row_info.color_type);
   png_debug1(3, "row_info->width = %d\n", png_ptr->row_info.width);
   png_debug1(3, "row_info->channels = %d\n", png_ptr->row_info.channels);
   png_debug1(3, "row_info->bit_depth = %d\n", png_ptr->row_info.bit_depth);
   png_debug1(3, "row_info->pixel_depth = %d\n", png_ptr->row_info.pixel_depth);
   png_debug1(3, "row_info->rowbytes = %d\n", png_ptr->row_info.rowbytes);

   /* Copy user's row into buffer, leaving room for filter byte. */
   png_memcpy_check(png_ptr, png_ptr->row_buf + 1, row,
      png_ptr->row_info.rowbytes);

#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
   /* handle interlacing */
   if (png_ptr->interlaced && png_ptr->pass < 6 &&
      (png_ptr->transformations & PNG_INTERLACE))
   {
      png_do_write_interlace(&(png_ptr->row_info),
         png_ptr->row_buf + 1, png_ptr->pass);
      /* this should always get caught above, but still ... */
      if (!(png_ptr->row_info.width))
      {
         png_write_finish_row(png_ptr);
         return;
      }
   }
#endif

   /* handle other transformations */
   if (png_ptr->transformations)
      png_do_write_transformations(png_ptr);

   /* Find a filter if necessary, filter the row and write it out. */
   png_write_find_filter(png_ptr, &(png_ptr->row_info));

   if (png_ptr->write_row_fn != NULL)
      (*(png_ptr->write_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);
}

#if defined(PNG_WRITE_FLUSH_SUPPORTED)
/* Set the automatic flush interval or 0 to turn flushing off */
void
png_set_flush(png_structp png_ptr, int nrows)
{
   png_debug(1, "in png_set_flush\n");
   png_ptr->flush_dist = (nrows < 0 ? 0 : nrows);
}

/* flush the current output buffers now */
void
png_write_flush(png_structp png_ptr)
{
   int wrote_IDAT;

   png_debug(1, "in png_write_flush\n");
   /* We have already written out all of the data */
   if (png_ptr->row_number >= png_ptr->num_rows)
     return;

   do
   {
      int ret;

      /* compress the data */
      ret = deflate(&png_ptr->zstream, Z_SYNC_FLUSH);
      wrote_IDAT = 0;

      /* check for compression errors */
      if (ret != Z_OK)
      {
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }

      if (!(png_ptr->zstream.avail_out))
      {
         /* write the IDAT and reset the zlib output buffer */
         png_write_IDAT(png_ptr, png_ptr->zbuf,
                        png_ptr->zbuf_size);
         png_ptr->zstream.next_out = png_ptr->zbuf;
         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
         wrote_IDAT = 1;
      }
   } while(wrote_IDAT == 1);

   /* If there is any data left to be output, write it into a new IDAT */
   if (png_ptr->zbuf_size != png_ptr->zstream.avail_out)
   {
      /* write the IDAT and reset the zlib output buffer */
      png_write_IDAT(png_ptr, png_ptr->zbuf,
                     png_ptr->zbuf_size - png_ptr->zstream.avail_out);
      png_ptr->zstream.next_out = png_ptr->zbuf;
      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   }
   png_ptr->flush_rows = 0;
   png_flush(png_ptr);
}
#endif /* PNG_WRITE_FLUSH_SUPPORTED */

/* free all memory used by the write */
void
png_destroy_write_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr)
{
   png_structp png_ptr = NULL;
   png_infop info_ptr = NULL;
#ifdef PNG_USER_MEM_SUPPORTED
   png_free_ptr free_fn = NULL;
#endif

   png_debug(1, "in png_destroy_write_struct\n");
   if (png_ptr_ptr != NULL)
   {
      png_ptr = *png_ptr_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
      free_fn = png_ptr->free_fn;
#endif
   }

   if (info_ptr_ptr != NULL)
      info_ptr = *info_ptr_ptr;

   if (info_ptr != NULL)
   {
#ifdef PNG_WRITE_tEXt_SUPPORTED
      png_free(png_ptr, info_ptr->text);
#endif
#if defined(PNG_READ_pCAL_SUPPORTED)
      png_free(png_ptr, info_ptr->pcal_purpose);
      png_free(png_ptr, info_ptr->pcal_units);
      if (info_ptr->pcal_params != NULL)
      {
         int i;
         for (i = 0; i < (int)info_ptr->pcal_nparams; i++)
         {
            png_free(png_ptr, info_ptr->pcal_params[i]);
         }
         png_free(png_ptr, info_ptr->pcal_params);
      }
#endif
#ifdef PNG_USER_MEM_SUPPORTED
      png_destroy_struct_2((png_voidp)info_ptr, free_fn);
#else
      png_destroy_struct((png_voidp)info_ptr);
#endif
      *info_ptr_ptr = (png_infop)NULL;
   }

   if (png_ptr != NULL)
   {
      png_write_destroy(png_ptr);
#ifdef PNG_USER_MEM_SUPPORTED
      png_destroy_struct_2((png_voidp)png_ptr, free_fn);
#else
      png_destroy_struct((png_voidp)png_ptr);
#endif
      *png_ptr_ptr = (png_structp)NULL;
   }
}


/* Free any memory used in png_ptr struct (old method) */
void
png_write_destroy(png_structp png_ptr)
{
   jmp_buf tmp_jmp; /* save jump buffer */
   png_error_ptr error_fn;
   png_error_ptr warning_fn;
   png_voidp error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   png_free_ptr free_fn;
#endif

   png_debug(1, "in png_write_destroy\n");
   /* free any memory zlib uses */
   deflateEnd(&png_ptr->zstream);

   /* free our memory.  png_free checks NULL for us. */
   png_free(png_ptr, png_ptr->zbuf);
   png_free(png_ptr, png_ptr->row_buf);
   png_free(png_ptr, png_ptr->prev_row);
   png_free(png_ptr, png_ptr->sub_row);
   png_free(png_ptr, png_ptr->up_row);
   png_free(png_ptr, png_ptr->avg_row);
   png_free(png_ptr, png_ptr->paeth_row);
#if defined(PNG_TIME_RFC1123_SUPPORTED)
   png_free(png_ptr, png_ptr->time_buffer);
#endif /* PNG_TIME_RFC1123_SUPPORTED */
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   png_free(png_ptr, png_ptr->prev_filters);
   png_free(png_ptr, png_ptr->filter_weights);
   png_free(png_ptr, png_ptr->inv_filter_weights);
   png_free(png_ptr, png_ptr->filter_costs);
   png_free(png_ptr, png_ptr->inv_filter_costs);
#endif /* PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */

   /* reset structure */
   png_memcpy(tmp_jmp, png_ptr->jmpbuf, sizeof (jmp_buf));

   error_fn = png_ptr->error_fn;
   warning_fn = png_ptr->warning_fn;
   error_ptr = png_ptr->error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   free_fn = png_ptr->free_fn;
#endif

   png_memset(png_ptr, 0, sizeof (png_struct));

   png_ptr->error_fn = error_fn;
   png_ptr->warning_fn = warning_fn;
   png_ptr->error_ptr = error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   png_ptr->free_fn = free_fn;
#endif

   png_memcpy(png_ptr->jmpbuf, tmp_jmp, sizeof (jmp_buf));
}

/* Allow the application to select one or more row filters to use. */
void
png_set_filter(png_structp png_ptr, int method, int filters)
{
   png_debug(1, "in png_set_filter\n");
   /* We allow 'method' only for future expansion of the base filter method. */
   if (method == PNG_FILTER_TYPE_BASE)
   {
      switch (filters & (PNG_ALL_FILTERS | 0x07))
      {
         case 5:
         case 6:
         case 7: png_warning(png_ptr, "Unknown row filter for method 0");
         case PNG_FILTER_VALUE_NONE:  png_ptr->do_filter=PNG_FILTER_NONE; break;
         case PNG_FILTER_VALUE_SUB:   png_ptr->do_filter=PNG_FILTER_SUB;  break;
         case PNG_FILTER_VALUE_UP:    png_ptr->do_filter=PNG_FILTER_UP;   break;
         case PNG_FILTER_VALUE_AVG:   png_ptr->do_filter=PNG_FILTER_AVG;  break;
         case PNG_FILTER_VALUE_PAETH: png_ptr->do_filter=PNG_FILTER_PAETH;break;
         default: png_ptr->do_filter = (png_byte)filters; break;
      }

      /* If we have allocated the row_buf, this means we have already started
       * with the image and we should have allocated all of the filter buffers
       * that have been selected.  If prev_row isn't already allocated, then
       * it is too late to start using the filters that need it, since we
       * will be missing the data in the previous row.  If an application
       * wants to start and stop using particular filters during compression,
       * it should start out with all of the filters, and then add and
       * remove them after the start of compression.
       */
      if (png_ptr->row_buf != NULL)
      {
         if (png_ptr->do_filter & PNG_FILTER_SUB && png_ptr->sub_row == NULL)
         {
            png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,
              (png_ptr->rowbytes + 1));
            png_ptr->sub_row[0] = PNG_FILTER_VALUE_SUB;
         }

         if (png_ptr->do_filter & PNG_FILTER_UP && png_ptr->up_row == NULL)
         {
            if (png_ptr->prev_row == NULL)
            {
               png_warning(png_ptr, "Can't add Up filter after starting");
               png_ptr->do_filter &= ~PNG_FILTER_UP;
            }
            else
            {
               png_ptr->up_row = (png_bytep)png_malloc(png_ptr,
                  (png_ptr->rowbytes + 1));
               png_ptr->up_row[0] = PNG_FILTER_VALUE_UP;
            }
         }

         if (png_ptr->do_filter & PNG_FILTER_AVG && png_ptr->avg_row == NULL)
         {
            if (png_ptr->prev_row == NULL)
            {
               png_warning(png_ptr, "Can't add Average filter after starting");
               png_ptr->do_filter &= ~PNG_FILTER_AVG;
            }
            else
            {
               png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,
                  (png_ptr->rowbytes + 1));
               png_ptr->avg_row[0] = PNG_FILTER_VALUE_AVG;
            }
         }

         if (png_ptr->do_filter & PNG_FILTER_PAETH &&
             png_ptr->paeth_row == NULL)
         {
            if (png_ptr->prev_row == NULL)
            {
               png_warning(png_ptr, "Can't add Paeth filter after starting");
               png_ptr->do_filter &= (png_byte)(~PNG_FILTER_PAETH);
            }
            else
            {
               png_ptr->paeth_row = (png_bytep)png_malloc(png_ptr,
                  (png_ptr->rowbytes + 1));
               png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;
            }
         }

         if (png_ptr->do_filter == PNG_NO_FILTERS)
            png_ptr->do_filter = PNG_FILTER_NONE;
      }
   }
   else
      png_error(png_ptr, "Unknown custom filter method");
}

/* This allows us to influence the way in which libpng chooses the "best"
 * filter for the current scanline.  While the "minimum-sum-of-absolute-
 * differences metric is relatively fast and effective, there is some
 * question as to whether it can be improved upon by trying to keep the
 * filtered data going to zlib more consistent, hopefully resulting in
 * better compression.
 */
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)      /* GRR 970116 */
void
png_set_filter_heuristics(png_structp png_ptr, int heuristic_method,
   int num_weights, png_doublep filter_weights,
   png_doublep filter_costs)
{
   int i;

   png_debug(1, "in png_set_filter_heuristics\n");
   if (heuristic_method >= PNG_FILTER_HEURISTIC_LAST)
   {
      png_warning(png_ptr, "Unknown filter heuristic method");
      return;
   }

   if (heuristic_method == PNG_FILTER_HEURISTIC_DEFAULT)
   {
      heuristic_method = PNG_FILTER_HEURISTIC_UNWEIGHTED;
   }

   if (num_weights < 0 || filter_weights == NULL ||
      heuristic_method == PNG_FILTER_HEURISTIC_UNWEIGHTED)
   {
      num_weights = 0;
   }

   png_ptr->num_prev_filters = (png_byte)num_weights;
   png_ptr->heuristic_method = (png_byte)heuristic_method;

   if (num_weights > 0)
   {
      if (png_ptr->prev_filters == NULL)
      {
         png_ptr->prev_filters = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)(sizeof(png_byte) * num_weights));

         /* To make sure that the weighting starts out fairly */
         for (i = 0; i < num_weights; i++)
         {
            png_ptr->prev_filters[i] = 255;
         }
      }

      if (png_ptr->filter_weights == NULL)
      {
         png_ptr->filter_weights = (png_uint_16p) png_malloc(png_ptr,
            (png_uint_32)(sizeof(png_uint_16) * num_weights));

         png_ptr->inv_filter_weights = (png_uint_16p) png_malloc(png_ptr,
            (png_uint_32)(sizeof(png_uint_16) * num_weights));

         for (i = 0; i < num_weights; i++)
         {
            png_ptr->inv_filter_weights[i] =
            png_ptr->filter_weights[i] = PNG_WEIGHT_FACTOR;
         }
      }

      for (i = 0; i < num_weights; i++)
      {
         if (filter_weights[i] < 0.0)
         {
            png_ptr->inv_filter_weights[i] =
            png_ptr->filter_weights[i] = PNG_WEIGHT_FACTOR;
         }
         else
         {
            png_ptr->inv_filter_weights[i] =
               (png_uint_16)((double)PNG_WEIGHT_FACTOR*filter_weights[i]+0.5);
            png_ptr->filter_weights[i] =
               (png_uint_16)((double)PNG_WEIGHT_FACTOR/filter_weights[i]+0.5);
         }
      }
   }

   /* If, in the future, there are other filter methods, this would
    * need to be based on png_ptr->filter.
    */
   if (png_ptr->filter_costs == NULL)
   {
      png_ptr->filter_costs = (png_uint_16p) png_malloc(png_ptr,
         (png_uint_32)(sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));

      png_ptr->inv_filter_costs = (png_uint_16p) png_malloc(png_ptr,
         (png_uint_32)(sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));

      for (i = 0; i < PNG_FILTER_VALUE_LAST; i++)
      {
         png_ptr->inv_filter_costs[i] =
         png_ptr->filter_costs[i] = PNG_COST_FACTOR;
      }
   }

   /* Here is where we set the relative costs of the different filters.  We
    * should take the desired compression level into account when setting
    * the costs, so that Paeth, for instance, has a high relative cost at low
    * compression levels, while it has a lower relative cost at higher
    * compression settings.  The filter types are in order of increasing
    * relative cost, so it would be possible to do this with an algorithm.
    */
   for (i = 0; i < PNG_FILTER_VALUE_LAST; i++)
   {
      if (filter_costs == NULL || filter_costs[i] < 0.0)
      {
         png_ptr->inv_filter_costs[i] =
         png_ptr->filter_costs[i] = PNG_COST_FACTOR;
      }
      else if (filter_costs[i] >= 1.0)
      {
         png_ptr->inv_filter_costs[i] =
            (png_uint_16)((double)PNG_COST_FACTOR / filter_costs[i] + 0.5);
         png_ptr->filter_costs[i] =
            (png_uint_16)((double)PNG_COST_FACTOR * filter_costs[i] + 0.5);
      }
   }
}
#endif /* PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */

void
png_set_compression_level(png_structp png_ptr, int level)
{
   png_debug(1, "in png_set_compression_level\n");
   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_LEVEL;
   png_ptr->zlib_level = level;
}

void
png_set_compression_mem_level(png_structp png_ptr, int mem_level)
{
   png_debug(1, "in png_set_compression_mem_level\n");
   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL;
   png_ptr->zlib_mem_level = mem_level;
}

void
png_set_compression_strategy(png_structp png_ptr, int strategy)
{
   png_debug(1, "in png_set_compression_strategy\n");
   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_STRATEGY;
   png_ptr->zlib_strategy = strategy;
}

void
png_set_compression_window_bits(png_structp png_ptr, int window_bits)
{
   if (window_bits > 15)
      png_warning(png_ptr, "Only compression windows <= 32k supported by PNG");
   else if (window_bits < 8)
      png_warning(png_ptr, "Only compression windows >= 256 supported by PNG");
   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_WINDOW_BITS;
   png_ptr->zlib_window_bits = window_bits;
}

void
png_set_compression_method(png_structp png_ptr, int method)
{
   png_debug(1, "in png_set_compression_method\n");
   if (method != 8)
      png_warning(png_ptr, "Only compression method 8 is supported by PNG");
   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_METHOD;
   png_ptr->zlib_method = method;
}

void
png_set_write_status_fn(png_structp png_ptr, png_write_status_ptr write_row_fn)
{
   png_ptr->write_row_fn = write_row_fn;
}

#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
void
png_set_write_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
   write_user_transform_fn)
{
   png_debug(1, "in png_set_write_user_transform_fn\n");
   png_ptr->transformations |= PNG_USER_TRANSFORM;
   png_ptr->write_user_transform_fn = write_user_transform_fn;
}
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\pngwtran.cpp ===
/* pngwtran.c - transforms the data in a row for PNG writers
 *
 * libpng 1.0.5 - October 15, 1999
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
 * Copyright (c) 1996, 1997 Andreas Dilger
 * Copyright (c) 1998, 1999 Glenn Randers-Pehrson
 */

#define PNG_INTERNAL
#include "png.h"

namespace D3DX
{

/* Transform the data according to the user's wishes.  The order of
 * transformations is significant.
 */
void
png_do_write_transformations(png_structp png_ptr)
{
   png_debug(1, "in png_do_write_transformations\n");

#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
   if (png_ptr->transformations & PNG_USER_TRANSFORM)
      if(png_ptr->write_user_transform_fn != NULL)
        (*(png_ptr->write_user_transform_fn)) /* user write transform function */
          (png_ptr,                    /* png_ptr */
           &(png_ptr->row_info),       /* row_info:     */
             /*  png_uint_32 width;          width of row */
             /*  png_uint_32 rowbytes;       number of bytes in row */
             /*  png_byte color_type;        color type of pixels */
             /*  png_byte bit_depth;         bit depth of samples */
             /*  png_byte channels;          number of channels (1-4) */
             /*  png_byte pixel_depth;       bits per pixel (depth*channels) */
           png_ptr->row_buf + 1);      /* start of pixel data for row */
#endif
#if defined(PNG_WRITE_FILLER_SUPPORTED)
   if (png_ptr->transformations & PNG_FILLER)
      png_do_strip_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
         png_ptr->flags);
#endif
#if defined(PNG_WRITE_PACKSWAP_SUPPORTED)
   if (png_ptr->transformations & PNG_PACKSWAP)
      png_do_packswap(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif
#if defined(PNG_WRITE_PACK_SUPPORTED)
   if (png_ptr->transformations & PNG_PACK)
      png_do_pack(&(png_ptr->row_info), png_ptr->row_buf + 1,
         (png_uint_32)png_ptr->bit_depth);
#endif
#if defined(PNG_WRITE_SWAP_SUPPORTED)
   if (png_ptr->transformations & PNG_SWAP_BYTES)
      png_do_swap(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif
#if defined(PNG_WRITE_SHIFT_SUPPORTED)
   if (png_ptr->transformations & PNG_SHIFT)
      png_do_shift(&(png_ptr->row_info), png_ptr->row_buf + 1,
         &(png_ptr->shift));
#endif
#if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
   if (png_ptr->transformations & PNG_INVERT_ALPHA)
      png_do_write_invert_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif
#if defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
   if (png_ptr->transformations & PNG_SWAP_ALPHA)
      png_do_write_swap_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif
#if defined(PNG_WRITE_BGR_SUPPORTED)
   if (png_ptr->transformations & PNG_BGR)
      png_do_bgr(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif
#if defined(PNG_WRITE_INVERT_SUPPORTED)
   if (png_ptr->transformations & PNG_INVERT_MONO)
      png_do_invert(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif
}

#if defined(PNG_WRITE_PACK_SUPPORTED)
/* Pack pixels into bytes.  Pass the true bit depth in bit_depth.  The
 * row_info bit depth should be 8 (one pixel per byte).  The channels
 * should be 1 (this only happens on grayscale and paletted images).
 */
void
png_do_pack(png_row_infop row_info, png_bytep row, png_uint_32 bit_depth)
{
   png_debug(1, "in png_do_pack\n");
   if (row_info->bit_depth == 8 &&
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
      row_info->channels == 1)
   {
      switch ((int)bit_depth)
      {
         case 1:
         {
            png_bytep sp, dp;
            int mask, v;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            sp = row;
            dp = row;
            mask = 0x80;
            v = 0;

            for (i = 0; i < row_width; i++)
            {
               if (*sp != 0)
                  v |= mask;
               sp++;
               if (mask > 1)
                  mask >>= 1;
               else
               {
                  mask = 0x80;
                  *dp = (png_byte)v;
                  dp++;
                  v = 0;
               }
            }
            if (mask != 0x80)
               *dp = (png_byte)v;
            break;
         }
         case 2:
         {
            png_bytep sp, dp;
            int shift, v;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            sp = row;
            dp = row;
            shift = 6;
            v = 0;
            for (i = 0; i < row_width; i++)
            {
               png_byte value;

               value = (png_byte)(*sp & 0x3);
               v |= (value << shift);
               if (shift == 0)
               {
                  shift = 6;
                  *dp = (png_byte)v;
                  dp++;
                  v = 0;
               }
               else
                  shift -= 2;
               sp++;
            }
            if (shift != 6)
               *dp = (png_byte)v;
            break;
         }
         case 4:
         {
            png_bytep sp, dp;
            int shift, v;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            sp = row;
            dp = row;
            shift = 4;
            v = 0;
            for (i = 0; i < row_width; i++)
            {
               png_byte value;

               value = (png_byte)(*sp & 0xf);
               v |= (value << shift);

               if (shift == 0)
               {
                  shift = 4;
                  *dp = (png_byte)v;
                  dp++;
                  v = 0;
               }
               else
                  shift -= 4;

               sp++;
            }
            if (shift != 4)
               *dp = (png_byte)v;
            break;
         }
      }
      row_info->bit_depth = (png_byte)bit_depth;
      row_info->pixel_depth = (png_byte)(bit_depth * row_info->channels);
      row_info->rowbytes =
         ((row_info->width * row_info->pixel_depth + 7) >> 3);
   }
}
#endif

#if defined(PNG_WRITE_SHIFT_SUPPORTED)
/* Shift pixel values to take advantage of whole range.  Pass the
 * true number of bits in bit_depth.  The row should be packed
 * according to row_info->bit_depth.  Thus, if you had a row of
 * bit depth 4, but the pixels only had values from 0 to 7, you
 * would pass 3 as bit_depth, and this routine would translate the
 * data to 0 to 15.
 */
void
png_do_shift(png_row_infop row_info, png_bytep row, png_color_8p bit_depth)
{
   png_debug(1, "in png_do_shift\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL &&
#else
   if (
#endif
      row_info->color_type != PNG_COLOR_TYPE_PALETTE)
   {
      int shift_start[4], shift_dec[4];
      int channels = 0;

      if (row_info->color_type & PNG_COLOR_MASK_COLOR)
      {
         shift_start[channels] = row_info->bit_depth - bit_depth->red;
         shift_dec[channels] = bit_depth->red;
         channels++;
         shift_start[channels] = row_info->bit_depth - bit_depth->green;
         shift_dec[channels] = bit_depth->green;
         channels++;
         shift_start[channels] = row_info->bit_depth - bit_depth->blue;
         shift_dec[channels] = bit_depth->blue;
         channels++;
      }
      else
      {
         shift_start[channels] = row_info->bit_depth - bit_depth->gray;
         shift_dec[channels] = bit_depth->gray;
         channels++;
      }
      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
      {
         shift_start[channels] = row_info->bit_depth - bit_depth->alpha;
         shift_dec[channels] = bit_depth->alpha;
         channels++;
      }

      /* with low row depths, could only be grayscale, so one channel */
      if (row_info->bit_depth < 8)
      {
         png_bytep bp = row;
         png_uint_32 i;
         png_byte mask;
         png_uint_32 row_bytes = row_info->rowbytes;

         if (bit_depth->gray == 1 && row_info->bit_depth == 2)
            mask = 0x55;
         else if (row_info->bit_depth == 4 && bit_depth->gray == 3)
            mask = 0x11;
         else
            mask = 0xff;

         for (i = 0; i < row_bytes; i++, bp++)
         {
            png_uint_16 v;
            int j;

            v = *bp;
            *bp = 0;
            for (j = shift_start[0]; j > -shift_dec[0]; j -= shift_dec[0])
            {
               if (j > 0)
                  *bp |= (png_byte)((v << j) & 0xff);
               else
                  *bp |= (png_byte)((v >> (-j)) & mask);
            }
         }
      }
      else if (row_info->bit_depth == 8)
      {
         png_bytep bp = row;
         png_uint_32 i;
         png_uint_32 istop = channels * row_info->width;

         for (i = 0; i < istop; i++, bp++)
         {

            png_uint_16 v;
            int j;
            int c = (int)(i%channels);

            v = *bp;
            *bp = 0;
            for (j = shift_start[c]; j > -shift_dec[c]; j -= shift_dec[c])
            {
               if (j > 0)
                  *bp |= (png_byte)((v << j) & 0xff);
               else
                  *bp |= (png_byte)((v >> (-j)) & 0xff);
            }
         }
      }
      else
      {
         png_bytep bp;
         png_uint_32 i;
         png_uint_32 istop = channels * row_info->width;

         for (bp = row, i = 0; i < istop; i++)
         {
            int c = (int)(i%channels);
            png_uint_16 value, v;
            int j;

            v = (png_uint_16)(((png_uint_16)(*bp) << 8) + *(bp + 1));
            value = 0;
            for (j = shift_start[c]; j > -shift_dec[c]; j -= shift_dec[c])
            {
               if (j > 0)
                  value |= (png_uint_16)((v << j) & (png_uint_16)0xffff);
               else
                  value |= (png_uint_16)((v >> (-j)) & (png_uint_16)0xffff);
            }
            *bp++ = (png_byte)(value >> 8);
            *bp++ = (png_byte)(value & 0xff);
         }
      }
   }
}
#endif

#if defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
void
png_do_write_swap_alpha(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_write_swap_alpha\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL)
#endif
   {
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         /* This converts from ARGB to RGBA */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;
            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_byte save = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = save;
            }
         }
         /* This converts from AARRGGBB to RRGGBBAA */
         else
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_byte save[2];
               save[0] = *(sp++);
               save[1] = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = save[0];
               *(dp++) = save[1];
            }
         }
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         /* This converts from AG to GA */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_byte save = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = save;
            }
         }
         /* This converts from AAGG to GGAA */
         else
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_byte save[2];
               save[0] = *(sp++);
               save[1] = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = save[0];
               *(dp++) = save[1];
            }
         }
      }
   }
}
#endif

#if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
void
png_do_write_invert_alpha(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_write_invert_alpha\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL)
#endif
   {
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         /* This inverts the alpha channel in RGBA */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;
            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = (png_byte)(255 - *(sp++));
            }
         }
         /* This inverts the alpha channel in RRGGBBAA */
         else
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = (png_byte)(255 - *(sp++));
               *(dp++) = (png_byte)(255 - *(sp++));
            }
         }
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         /* This inverts the alpha channel in GA */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               *(dp++) = *(sp++);
               *(dp++) = (png_byte)(255 - *(sp++));
            }
         }
         /* This inverts the alpha channel in GGAA */
         else
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = (png_byte)(255 - *(sp++));
               *(dp++) = (png_byte)(255 - *(sp++));
            }
         }
      }
   }
}
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\pngwutil.cpp ===
/* pngwutil.c - utilities to write a PNG file
 *
 * libpng 1.0.5 - October 15, 1999
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
 * Copyright (c) 1996, 1997 Andreas Dilger
 * Copyright (c) 1998, 1999 Glenn Randers-Pehrson
 */

#define PNG_INTERNAL
#include "png.h"

namespace D3DX
{


/* Place a 32-bit number into a buffer in PNG byte order.  We work
 * with unsigned numbers for convenience, although one supported
 * ancillary chunk uses signed (two's complement) numbers.
 */
void
png_save_uint_32(png_bytep buf, png_uint_32 i)
{
   buf[0] = (png_byte)((i >> 24) & 0xff);
   buf[1] = (png_byte)((i >> 16) & 0xff);
   buf[2] = (png_byte)((i >> 8) & 0xff);
   buf[3] = (png_byte)(i & 0xff);
}

#if defined(PNG_WRITE_pCAL_SUPPORTED)
/* The png_save_int_32 function assumes integers are stored in two's
 * complement format.  If this isn't the case, then this routine needs to
 * be modified to write data in two's complement format.
 */
void
png_save_int_32(png_bytep buf, png_int_32 i)
{
   buf[0] = (png_byte)((i >> 24) & 0xff);
   buf[1] = (png_byte)((i >> 16) & 0xff);
   buf[2] = (png_byte)((i >> 8) & 0xff);
   buf[3] = (png_byte)(i & 0xff);
}
#endif

/* Place a 16-bit number into a buffer in PNG byte order.
 * The parameter is declared unsigned int, not png_uint_16,
 * just to avoid potential problems on pre-ANSI C compilers.
 */
void
png_save_uint_16(png_bytep buf, unsigned int i)
{
   buf[0] = (png_byte)((i >> 8) & 0xff);
   buf[1] = (png_byte)(i & 0xff);
}

/* Write a PNG chunk all at once.  The type is an array of ASCII characters
 * representing the chunk name.  The array must be at least 4 bytes in
 * length, and does not need to be null terminated.  To be safe, pass the
 * pre-defined chunk names here, and if you need a new one, define it
 * where the others are defined.  The length is the length of the data.
 * All the data must be present.  If that is not possible, use the
 * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()
 * functions instead.
 */
void
png_write_chunk(png_structp png_ptr, png_bytep chunk_name,
   png_bytep data, png_size_t length)
{
   png_write_chunk_start(png_ptr, chunk_name, (png_uint_32)length);
   png_write_chunk_data(png_ptr, data, length);
   png_write_chunk_end(png_ptr);
}

/* Write the start of a PNG chunk.  The type is the chunk type.
 * The total_length is the sum of the lengths of all the data you will be
 * passing in png_write_chunk_data().
 */
void
png_write_chunk_start(png_structp png_ptr, png_bytep chunk_name,
   png_uint_32 length)
{
   png_byte buf[4];
   png_debug2(0, "Writing %s chunk (%d bytes)\n", chunk_name, length);

   /* write the length */
   png_save_uint_32(buf, length);
   png_write_data(png_ptr, buf, (png_size_t)4);

   /* write the chunk name */
   png_write_data(png_ptr, chunk_name, (png_size_t)4);
   /* reset the crc and run it over the chunk name */
   png_reset_crc(png_ptr);
   png_calculate_crc(png_ptr, chunk_name, (png_size_t)4);
}

/* Write the data of a PNG chunk started with png_write_chunk_start().
 * Note that multiple calls to this function are allowed, and that the
 * sum of the lengths from these calls *must* add up to the total_length
 * given to png_write_chunk_start().
 */
void
png_write_chunk_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   /* write the data, and run the CRC over it */
   if (data != NULL && length > 0)
   {
      png_calculate_crc(png_ptr, data, length);
      png_write_data(png_ptr, data, length);
   }
}

/* Finish a chunk started with png_write_chunk_start(). */
void
png_write_chunk_end(png_structp png_ptr)
{
   png_byte buf[4];

   /* write the crc */
   png_save_uint_32(buf, png_ptr->crc);

   png_write_data(png_ptr, buf, (png_size_t)4);
}

/* Simple function to write the signature.  If we have already written
 * the magic bytes of the signature, or more likely, the PNG stream is
 * being embedded into another stream and doesn't need its own signature,
 * we should call png_set_sig_bytes() to tell libpng how many of the
 * bytes have already been written.
 */
void
png_write_sig(png_structp png_ptr)
{
   /* write the rest of the 8 byte signature */
   png_write_data(png_ptr, (png_bytep) &png_sig[png_ptr->sig_bytes],
      (png_size_t)8 - png_ptr->sig_bytes);
}

/* Write the IHDR chunk, and update the png_struct with the necessary
 * information.  Note that the rest of this code depends upon this
 * information being correct.
 */
void
png_write_IHDR(png_structp png_ptr, png_uint_32 width, png_uint_32 height,
   int bit_depth, int color_type, int compression_type, int filter_type,
   int interlace_type)
{
   png_byte buf[13]; /* buffer to store the IHDR info */

   png_debug(1, "in png_write_IHDR\n");
   /* Check that we have valid input data from the application info */
   switch (color_type)
   {
      case PNG_COLOR_TYPE_GRAY:
         switch (bit_depth)
         {
            case 1:
            case 2:
            case 4:
            case 8:
            case 16: png_ptr->channels = 1; break;
            default: png_error(png_ptr,"Invalid bit depth for grayscale image");
         }
         break;
      case PNG_COLOR_TYPE_RGB:
         if (bit_depth != 8 && bit_depth != 16)
            png_error(png_ptr, "Invalid bit depth for RGB image");
         png_ptr->channels = 3;
         break;
      case PNG_COLOR_TYPE_PALETTE:
         switch (bit_depth)
         {
            case 1:
            case 2:
            case 4:
            case 8: png_ptr->channels = 1; break;
            default: png_error(png_ptr, "Invalid bit depth for paletted image");
         }
         break;
      case PNG_COLOR_TYPE_GRAY_ALPHA:
         if (bit_depth != 8 && bit_depth != 16)
            png_error(png_ptr, "Invalid bit depth for grayscale+alpha image");
         png_ptr->channels = 2;
         break;
      case PNG_COLOR_TYPE_RGB_ALPHA:
         if (bit_depth != 8 && bit_depth != 16)
            png_error(png_ptr, "Invalid bit depth for RGBA image");
         png_ptr->channels = 4;
         break;
      default:
         png_error(png_ptr, "Invalid image color type specified");
   }

   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
   {
      png_warning(png_ptr, "Invalid compression type specified");
      compression_type = PNG_COMPRESSION_TYPE_BASE;
   }

   if (filter_type != PNG_FILTER_TYPE_BASE)
   {
      png_warning(png_ptr, "Invalid filter type specified");
      filter_type = PNG_FILTER_TYPE_BASE;
   }

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   if (interlace_type != PNG_INTERLACE_NONE &&
      interlace_type != PNG_INTERLACE_ADAM7)
   {
      png_warning(png_ptr, "Invalid interlace type specified");
      interlace_type = PNG_INTERLACE_ADAM7;
   }
#else
   interlace_type=PNG_INTERLACE_NONE;
#endif

   /* save off the relevent information */
   png_ptr->bit_depth = (png_byte)bit_depth;
   png_ptr->color_type = (png_byte)color_type;
   png_ptr->interlaced = (png_byte)interlace_type;
   png_ptr->width = width;
   png_ptr->height = height;

   png_ptr->pixel_depth = (png_byte)(bit_depth * png_ptr->channels);
   png_ptr->rowbytes = ((width * (png_uint_32)(png_ptr->pixel_depth + 7)) >> 3);
   /* set the usr info, so any transformations can modify it */
   png_ptr->usr_width = png_ptr->width;
   png_ptr->usr_bit_depth = png_ptr->bit_depth;
   png_ptr->usr_channels = png_ptr->channels;

   /* pack the header information into the buffer */
   png_save_uint_32(buf, width);
   png_save_uint_32(buf + 4, height);
   buf[8] = (png_byte)bit_depth;
   buf[9] = (png_byte)color_type;
   buf[10] = (png_byte)compression_type;
   buf[11] = (png_byte)filter_type;
   buf[12] = (png_byte)interlace_type;

   /* write the chunk */
   png_write_chunk(png_ptr, (png_bytep) png_IHDR, buf, (png_size_t)13);

   /* initialize zlib with PNG info */
   png_ptr->zstream.zalloc = png_zalloc;
   png_ptr->zstream.zfree = png_zfree;
   png_ptr->zstream.opaque = (voidpf)png_ptr;
   if (!(png_ptr->do_filter))
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
         png_ptr->bit_depth < 8)
         png_ptr->do_filter = PNG_FILTER_NONE;
      else
         png_ptr->do_filter = PNG_ALL_FILTERS;
   }
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_STRATEGY))
   {
      if (png_ptr->do_filter != PNG_FILTER_NONE)
         png_ptr->zlib_strategy = Z_FILTERED;
      else
         png_ptr->zlib_strategy = Z_DEFAULT_STRATEGY;
   }
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_LEVEL))
      png_ptr->zlib_level = Z_DEFAULT_COMPRESSION;
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL))
      png_ptr->zlib_mem_level = 8;
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_WINDOW_BITS))
      png_ptr->zlib_window_bits = 15;
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_METHOD))
      png_ptr->zlib_method = 8;
   deflateInit2(&png_ptr->zstream, png_ptr->zlib_level,
      png_ptr->zlib_method, png_ptr->zlib_window_bits,
      png_ptr->zlib_mem_level, png_ptr->zlib_strategy);
   png_ptr->zstream.next_out = png_ptr->zbuf;
   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;

   png_ptr->mode = PNG_HAVE_IHDR;
}

/* write the palette.  We are careful not to trust png_color to be in the
 * correct order for PNG, so people can redefine it to any convenient
 * structure.
 */
void
png_write_PLTE(png_structp png_ptr, png_colorp palette, png_uint_32 num_pal)
{
   png_uint_32 i;
   png_colorp pal_ptr;
   png_byte buf[3];

   png_debug(1, "in png_write_PLTE\n");
   if ((
#ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED
        !png_ptr->empty_plte_permitted &&
#endif
        num_pal == 0) || num_pal > 256)
     {
       if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
         {
           png_error(png_ptr, "Invalid number of colors in palette");
         }
       else
         {
           png_warning(png_ptr, "Invalid number of colors in palette");
           return;
         }
   }

   png_ptr->num_palette = (png_uint_16)num_pal;
   png_debug1(3, "num_palette = %d\n", png_ptr->num_palette);

   png_write_chunk_start(png_ptr, (png_bytep) png_PLTE, num_pal * 3);
   for (i = 0, pal_ptr = palette; i < num_pal; i++, pal_ptr++)
   {
      buf[0] = pal_ptr->red;
      buf[1] = pal_ptr->green;
      buf[2] = pal_ptr->blue;
      png_write_chunk_data(png_ptr, buf, (png_size_t)3);
   }
   png_write_chunk_end(png_ptr);
   png_ptr->mode |= PNG_HAVE_PLTE;
}

/* write an IDAT chunk */
void
png_write_IDAT(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_debug(1, "in png_write_IDAT\n");
   png_write_chunk(png_ptr, (png_bytep) png_IDAT, data, length);
   png_ptr->mode |= PNG_HAVE_IDAT;
}

/* write an IEND chunk */
void
png_write_IEND(png_structp png_ptr)
{
   png_debug(1, "in png_write_IEND\n");
   png_write_chunk(png_ptr, (png_bytep) png_IEND, NULL, (png_size_t)0);
   png_ptr->mode |= PNG_HAVE_IEND;
}

#if defined(PNG_WRITE_gAMA_SUPPORTED)
/* write a gAMA chunk */
void
png_write_gAMA(png_structp png_ptr, double file_gamma)
{
   png_uint_32 igamma;
   png_byte buf[4];

   png_debug(1, "in png_write_gAMA\n");
   /* file_gamma is saved in 1/1000000ths */
   igamma = (png_uint_32)(file_gamma * 100000.0 + 0.5);
   png_save_uint_32(buf, igamma);
   png_write_chunk(png_ptr, (png_bytep) png_gAMA, buf, (png_size_t)4);
}
#endif

#if defined(PNG_WRITE_sRGB_SUPPORTED)
/* write a sRGB chunk */
void
png_write_sRGB(png_structp png_ptr, int srgb_intent)
{
   png_byte buf[1];

   png_debug(1, "in png_write_sRGB\n");
   if(srgb_intent >= PNG_sRGB_INTENT_LAST)
         png_warning(png_ptr,
            "Invalid sRGB rendering intent specified");
   buf[0]=(png_byte)srgb_intent;
   png_write_chunk(png_ptr, (png_bytep) png_sRGB, buf, (png_size_t)1);
}
#endif

#if defined(PNG_WRITE_sBIT_SUPPORTED)
/* write the sBIT chunk */
void
png_write_sBIT(png_structp png_ptr, png_color_8p sbit, int color_type)
{
   png_byte buf[4];
   png_size_t size;

   png_debug(1, "in png_write_sBIT\n");
   /* make sure we don't depend upon the order of PNG_COLOR_8 */
   if (color_type & PNG_COLOR_MASK_COLOR)
   {
      png_byte maxbits;

      maxbits = (png_byte)(color_type==PNG_COLOR_TYPE_PALETTE ? 8 :
                png_ptr->usr_bit_depth);
      if (sbit->red == 0 || sbit->red > maxbits ||
          sbit->green == 0 || sbit->green > maxbits ||
          sbit->blue == 0 || sbit->blue > maxbits)
      {
         png_warning(png_ptr, "Invalid sBIT depth specified");
         return;
      }
      buf[0] = sbit->red;
      buf[1] = sbit->green;
      buf[2] = sbit->blue;
      size = 3;
   }
   else
   {
      if (sbit->gray == 0 || sbit->gray > png_ptr->usr_bit_depth)
      {
         png_warning(png_ptr, "Invalid sBIT depth specified");
         return;
      }
      buf[0] = sbit->gray;
      size = 1;
   }

   if (color_type & PNG_COLOR_MASK_ALPHA)
   {
      if (sbit->alpha == 0 || sbit->alpha > png_ptr->usr_bit_depth)
      {
         png_warning(png_ptr, "Invalid sBIT depth specified");
         return;
      }
      buf[size++] = sbit->alpha;
   }

   png_write_chunk(png_ptr, (png_bytep) png_sBIT, buf, size);
}
#endif

#if defined(PNG_WRITE_cHRM_SUPPORTED)
/* write the cHRM chunk */
void
png_write_cHRM(png_structp png_ptr, double white_x, double white_y,
   double red_x, double red_y, double green_x, double green_y,
   double blue_x, double blue_y)
{
   png_uint_32 itemp;
   png_byte buf[32];

   png_debug(1, "in png_write_cHRM\n");
   /* each value is saved int 1/1000000ths */
   if (white_x < 0 || white_x > 0.8 || white_y < 0 || white_y > 0.8 ||
       white_x + white_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM white point specified");
      return;
   }
   itemp = (png_uint_32)(white_x * 100000.0 + 0.5);
   png_save_uint_32(buf, itemp);
   itemp = (png_uint_32)(white_y * 100000.0 + 0.5);
   png_save_uint_32(buf + 4, itemp);

   if (red_x < 0 || red_x > 0.8 || red_y < 0 || red_y > 0.8 ||
       red_x + red_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM red point specified");
      return;
   }
   itemp = (png_uint_32)(red_x * 100000.0 + 0.5);
   png_save_uint_32(buf + 8, itemp);
   itemp = (png_uint_32)(red_y * 100000.0 + 0.5);
   png_save_uint_32(buf + 12, itemp);

   if (green_x < 0 || green_x > 0.8 || green_y < 0 || green_y > 0.8 ||
       green_x + green_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM green point specified");
      return;
   }
   itemp = (png_uint_32)(green_x * 100000.0 + 0.5);
   png_save_uint_32(buf + 16, itemp);
   itemp = (png_uint_32)(green_y * 100000.0 + 0.5);
   png_save_uint_32(buf + 20, itemp);

   if (blue_x < 0 || blue_x > 0.8 || blue_y < 0 || blue_y > 0.8 ||
       blue_x + blue_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM blue point specified");
      return;
   }
   itemp = (png_uint_32)(blue_x * 100000.0 + 0.5);
   png_save_uint_32(buf + 24, itemp);
   itemp = (png_uint_32)(blue_y * 100000.0 + 0.5);
   png_save_uint_32(buf + 28, itemp);

   png_write_chunk(png_ptr, (png_bytep) png_cHRM, buf, (png_size_t)32);
}
#endif

#if defined(PNG_WRITE_tRNS_SUPPORTED)
/* write the tRNS chunk */
void
png_write_tRNS(png_structp png_ptr, png_bytep trans, png_color_16p tran,
   int num_trans, int color_type)
{
   png_byte buf[6];

   png_debug(1, "in png_write_tRNS\n");
   if (color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (num_trans <= 0 || num_trans > (int)png_ptr->num_palette)
      {
         png_warning(png_ptr,"Invalid number of transparent colors specified");
         return;
      }
      /* write the chunk out as it is */
      png_write_chunk(png_ptr, (png_bytep) png_tRNS, trans, (png_size_t)num_trans);
   }
   else if (color_type == PNG_COLOR_TYPE_GRAY)
   {
      /* one 16 bit value */
      png_save_uint_16(buf, tran->gray);
      png_write_chunk(png_ptr, (png_bytep) png_tRNS, buf, (png_size_t)2);
   }
   else if (color_type == PNG_COLOR_TYPE_RGB)
   {
      /* three 16 bit values */
      png_save_uint_16(buf, tran->red);
      png_save_uint_16(buf + 2, tran->green);
      png_save_uint_16(buf + 4, tran->blue);
      png_write_chunk(png_ptr, (png_bytep) png_tRNS, buf, (png_size_t)6);
   }
   else
   {
      png_warning(png_ptr, "Can't write tRNS with an alpha channel");
   }
}
#endif

#if defined(PNG_WRITE_bKGD_SUPPORTED)
/* write the background chunk */
void
png_write_bKGD(png_structp png_ptr, png_color_16p back, int color_type)
{
   png_byte buf[6];

   png_debug(1, "in png_write_bKGD\n");
   if (color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (
#ifdef PNG_WRITE_EMPTY_PLTE_SUPPORTED
          (!png_ptr->empty_plte_permitted ||
          (png_ptr->empty_plte_permitted && png_ptr->num_palette)) &&
#endif
         back->index > png_ptr->num_palette)
      {
         png_warning(png_ptr, "Invalid background palette index");
         return;
      }
      buf[0] = back->index;
      png_write_chunk(png_ptr, (png_bytep) png_bKGD, buf, (png_size_t)1);
   }
   else if (color_type & PNG_COLOR_MASK_COLOR)
   {
      png_save_uint_16(buf, back->red);
      png_save_uint_16(buf + 2, back->green);
      png_save_uint_16(buf + 4, back->blue);
      png_write_chunk(png_ptr, (png_bytep) png_bKGD, buf, (png_size_t)6);
   }
   else
   {
      png_save_uint_16(buf, back->gray);
      png_write_chunk(png_ptr, (png_bytep) png_bKGD, buf, (png_size_t)2);
   }
}
#endif

#if defined(PNG_WRITE_hIST_SUPPORTED)
/* write the histogram */
void
png_write_hIST(png_structp png_ptr, png_uint_16p hist, int num_hist)
{
   int i;
   png_byte buf[3];

   png_debug(1, "in png_write_hIST\n");
   if (num_hist > (int)png_ptr->num_palette)
   {
      png_debug2(3, "num_hist = %d, num_palette = %d\n", num_hist,
         png_ptr->num_palette);
      png_warning(png_ptr, "Invalid number of histogram entries specified");
      return;
   }

   png_write_chunk_start(png_ptr, (png_bytep) png_hIST, (png_uint_32)(num_hist * 2));
   for (i = 0; i < num_hist; i++)
   {
      png_save_uint_16(buf, hist[i]);
      png_write_chunk_data(png_ptr, buf, (png_size_t)2);
   }
   png_write_chunk_end(png_ptr);
}
#endif

#if defined(PNG_WRITE_tEXt_SUPPORTED) || defined(PNG_WRITE_zTXt_SUPPORTED) || \
    defined(PNG_WRITE_pCAL_SUPPORTED)
/* Check that the tEXt or zTXt keyword is valid per PNG 1.0 specification,
 * and if invalid, correct the keyword rather than discarding the entire
 * chunk.  The PNG 1.0 specification requires keywords 1-79 characters in
 * length, forbids leading or trailing whitespace, multiple internal spaces,
 * and the non-break space (0x80) from ISO 8859-1.  Returns keyword length.
 *
 * The new_key is allocated to hold the corrected keyword and must be freed
 * by the calling routine.  This avoids problems with trying to write to
 * static keywords without having to have duplicate copies of the strings.
 */
png_size_t
png_check_keyword(png_structp png_ptr, png_charp key, png_charpp new_key)
{
   png_size_t key_len;
   png_charp kp, dp;
   int kflag;

   png_debug(1, "in png_check_keyword\n");
   *new_key = NULL;

   if (key == NULL || (key_len = png_strlen(key)) == 0)
   {
      png_chunk_warning(png_ptr, "zero length keyword");
      return ((png_size_t)0);
   }

   png_debug1(2, "Keyword to be checked is '%s'\n", key);

   *new_key = (png_charp)png_malloc(png_ptr, (png_uint_32)(key_len + 1));

   /* Replace non-printing characters with a blank and print a warning */
   for (kp = key, dp = *new_key; *kp != '\0'; kp++, dp++)
   {
      if (*kp < 0x20 || (*kp > 0x7E && (png_byte)*kp < 0xA1))
      {
#if !defined(PNG_NO_STDIO)
         char msg[40];

         sprintf(msg, "invalid keyword character 0x%02X", *kp);
         png_chunk_warning(png_ptr, msg);
#else
         png_chunk_warning(png_ptr, "invalid character in keyword");
#endif
         *dp = ' ';
      }
      else
      {
         *dp = *kp;
      }
   }
   *dp = '\0';

   /* Remove any trailing white space. */
   kp = *new_key + key_len - 1;
   if (*kp == ' ')
   {
      png_chunk_warning(png_ptr, "trailing spaces removed from keyword");

      while (*kp == ' ')
      {
        *(kp--) = '\0';
        key_len--;
      }
   }

   /* Remove any leading white space. */
   kp = *new_key;
   if (*kp == ' ')
   {
      png_chunk_warning(png_ptr, "leading spaces removed from keyword");

      while (*kp == ' ')
      {
        kp++;
        key_len--;
      }
   }

   png_debug1(2, "Checking for multiple internal spaces in '%s'\n", kp);

   /* Remove multiple internal spaces. */
   for (kflag = 0, dp = *new_key; *kp != '\0'; kp++)
   {
      if (*kp == ' ' && kflag == 0)
      {
         *(dp++) = *kp;
         kflag = 1;
      }
      else if (*kp == ' ')
      {
         key_len--;
      }
      else
      {
         *(dp++) = *kp;
         kflag = 0;
      }
   }
   *dp = '\0';

   if (key_len == 0)
   {
      png_chunk_warning(png_ptr, "zero length keyword");
   }

   if (key_len > 79)
   {
      png_chunk_warning(png_ptr, "keyword length must be 1 - 79 characters");
      new_key[79] = '\0';
      key_len = 79;
   }

   return (key_len);
}
#endif

#if defined(PNG_WRITE_tEXt_SUPPORTED)
/* write a tEXt chunk */
void
png_write_tEXt(png_structp png_ptr, png_charp key, png_charp text,
   png_size_t text_len)
{
   png_size_t key_len;
   png_charp new_key;

   png_debug(1, "in png_write_tEXt\n");
   if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
   {
      png_warning(png_ptr, "Empty keyword in tEXt chunk");
      return;
   }

   if (text == NULL || *text == '\0')
      text_len = 0;

   /* make sure we include the 0 after the key */
   png_write_chunk_start(png_ptr, png_tEXt, (png_uint_32)key_len+text_len+1);
   /*
    * We leave it to the application to meet PNG-1.0 requirements on the
    * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
    * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.
    */
   png_write_chunk_data(png_ptr, (png_bytep)new_key, key_len + 1);
   if (text_len)
      png_write_chunk_data(png_ptr, (png_bytep)text, text_len);

   png_write_chunk_end(png_ptr);
   png_free(png_ptr, new_key);
}
#endif

#if defined(PNG_WRITE_zTXt_SUPPORTED)
/* write a compressed text chunk */
void
png_write_zTXt(png_structp png_ptr, png_charp key, png_charp text,
   png_size_t text_len, int compression)
{
   png_size_t key_len;
   char buf[1];
   png_charp new_key;
   int i, ret;
   png_charpp output_ptr = NULL; /* array of pointers to output */
   int num_output_ptr = 0; /* number of output pointers used */
   int max_output_ptr = 0; /* size of output_ptr */

   png_debug(1, "in png_write_zTXt\n");

   if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
   {
      png_warning(png_ptr, "Empty keyword in zTXt chunk");
      return;
   }

   if (text == NULL || *text == '\0' || compression==PNG_TEXT_COMPRESSION_NONE)
   {
      png_write_tEXt(png_ptr, new_key, text, (png_size_t)0);
      png_free(png_ptr, new_key);
      return;
   }

   png_free(png_ptr, new_key);

   if (compression >= PNG_TEXT_COMPRESSION_LAST)
   {
#if !defined(PNG_NO_STDIO)
      char msg[50];
      sprintf(msg, "Unknown zTXt compression type %d", compression);
      png_warning(png_ptr, msg);
#else
      png_warning(png_ptr, "Unknown zTXt compression type");
#endif
      compression = PNG_TEXT_COMPRESSION_zTXt;
   }

   /* We can't write the chunk until we find out how much data we have,
    * which means we need to run the compressor first and save the
    * output.  This shouldn't be a problem, as the vast majority of
    * comments should be reasonable, but we will set up an array of
    * malloc'd pointers to be sure.
    *
    * If we knew the application was well behaved, we could simplify this
    * greatly by assuming we can always malloc an output buffer large
    * enough to hold the compressed text ((1001 * text_len / 1000) + 12)
    * and malloc this directly.  The only time this would be a bad idea is
    * if we can't malloc more than 64K and we have 64K of random input
    * data, or if the input string is incredibly large (although this
    * wouldn't cause a failure, just a slowdown due to swapping).
    */

   /* set up the compression buffers */
   png_ptr->zstream.avail_in = (uInt)text_len;
   png_ptr->zstream.next_in = (Bytef *)text;
   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   png_ptr->zstream.next_out = (Bytef *)png_ptr->zbuf;

   /* this is the same compression loop as in png_write_row() */
   do
   {
      /* compress the data */
      ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);
      if (ret != Z_OK)
      {
         /* error */
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }
      /* check to see if we need more room */
      if (!png_ptr->zstream.avail_out && png_ptr->zstream.avail_in)
      {
         /* make sure the output array has room */
         if (num_output_ptr >= max_output_ptr)
         {
            int old_max;

            old_max = max_output_ptr;
            max_output_ptr = num_output_ptr + 4;
            if (output_ptr != NULL)
            {
               png_charpp old_ptr;

               old_ptr = output_ptr;
               output_ptr = (png_charpp)png_malloc(png_ptr,
                  (png_uint_32)(max_output_ptr * sizeof (png_charpp)));
               png_memcpy(output_ptr, old_ptr, old_max * sizeof (png_charp));
               png_free(png_ptr, old_ptr);
            }
            else
               output_ptr = (png_charpp)png_malloc(png_ptr,
                  (png_uint_32)(max_output_ptr * sizeof (png_charp)));
         }

         /* save the data */
         output_ptr[num_output_ptr] = (png_charp)png_malloc(png_ptr,
            (png_uint_32)png_ptr->zbuf_size);
         png_memcpy(output_ptr[num_output_ptr], png_ptr->zbuf,
            png_ptr->zbuf_size);
         num_output_ptr++;

         /* and reset the buffer */
         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
         png_ptr->zstream.next_out = png_ptr->zbuf;
      }
   /* continue until we don't have any more to compress */
   } while (png_ptr->zstream.avail_in);

   /* finish the compression */
   do
   {
      /* tell zlib we are finished */
      ret = deflate(&png_ptr->zstream, Z_FINISH);
      if (ret != Z_OK && ret != Z_STREAM_END)
      {
         /* we got an error */
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }

      /* check to see if we need more room */
      if (!(png_ptr->zstream.avail_out) && ret == Z_OK)
      {
         /* check to make sure our output array has room */
         if (num_output_ptr >= max_output_ptr)
         {
            int old_max;

            old_max = max_output_ptr;
            max_output_ptr = num_output_ptr + 4;
            if (output_ptr != NULL)
            {
               png_charpp old_ptr;

               old_ptr = output_ptr;
               /* This could be optimized to realloc() */
               output_ptr = (png_charpp)png_malloc(png_ptr,
                  (png_uint_32)(max_output_ptr * sizeof (png_charpp)));
               png_memcpy(output_ptr, old_ptr, old_max * sizeof (png_charp));
               png_free(png_ptr, old_ptr);
            }
            else
               output_ptr = (png_charpp)png_malloc(png_ptr,
                  (png_uint_32)(max_output_ptr * sizeof (png_charp)));
         }

         /* save off the data */
         output_ptr[num_output_ptr] = (png_charp)png_malloc(png_ptr,
            (png_uint_32)png_ptr->zbuf_size);
         png_memcpy(output_ptr[num_output_ptr], png_ptr->zbuf,
            png_ptr->zbuf_size);
         num_output_ptr++;

         /* and reset the buffer pointers */
         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
         png_ptr->zstream.next_out = png_ptr->zbuf;
      }
   } while (ret != Z_STREAM_END);

   /* text length is number of buffers plus last buffer */
   text_len = png_ptr->zbuf_size * num_output_ptr;
   if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)
      text_len += png_ptr->zbuf_size - (png_size_t)png_ptr->zstream.avail_out;

   /* write start of chunk */
   png_write_chunk_start(png_ptr, (png_bytep) png_zTXt, (png_uint_32)(key_len+text_len+2));
   /* write key */
   png_write_chunk_data(png_ptr, (png_bytep)key, key_len + 1);
   buf[0] = (png_byte)compression;
   /* write compression */
   png_write_chunk_data(png_ptr, (png_bytep)buf, (png_size_t)1);

   /* write saved output buffers, if any */
   for (i = 0; i < num_output_ptr; i++)
   {
      png_write_chunk_data(png_ptr,(png_bytep)output_ptr[i],png_ptr->zbuf_size);
      png_free(png_ptr, output_ptr[i]);
   }
   if (max_output_ptr != 0)
      png_free(png_ptr, output_ptr);
   /* write anything left in zbuf */
   if (png_ptr->zstream.avail_out < (png_uint_32)png_ptr->zbuf_size)
      png_write_chunk_data(png_ptr, png_ptr->zbuf,
         png_ptr->zbuf_size - png_ptr->zstream.avail_out);
   /* close the chunk */
   png_write_chunk_end(png_ptr);

   /* reset zlib for another zTXt or the image data */
   deflateReset(&png_ptr->zstream);
}
#endif


#if defined(PNG_WRITE_oFFs_SUPPORTED)
/* write the oFFs chunk */
void
png_write_oFFs(png_structp png_ptr, png_uint_32 x_offset,
   png_uint_32 y_offset,
   int unit_type)
{
   png_byte buf[9];

   png_debug(1, "in png_write_oFFs\n");
   if (unit_type >= PNG_OFFSET_LAST)
      png_warning(png_ptr, "Unrecognized unit type for oFFs chunk");

   png_save_uint_32(buf, x_offset);
   png_save_uint_32(buf + 4, y_offset);
   buf[8] = (png_byte)unit_type;

   png_write_chunk(png_ptr, (png_bytep) png_oFFs, buf, (png_size_t)9);
}
#endif

#if defined(PNG_WRITE_pCAL_SUPPORTED)
/* write the pCAL chunk (png-scivis-19970203) */
void
png_write_pCAL(png_structp png_ptr, png_charp purpose, png_int_32 X0,
   png_int_32 X1, int type, int nparams, png_charp units, png_charpp params)
{
   png_size_t purpose_len, units_len, total_len;
   png_uint_32p params_len;
   png_byte buf[10];
   png_charp new_purpose;
   int i;

   png_debug1(1, "in png_write_pCAL (%d parameters)\n", nparams);
   if (type >= PNG_EQUATION_LAST)
      png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");

   purpose_len = png_check_keyword(png_ptr, purpose, &new_purpose) + 1;
   png_debug1(3, "pCAL purpose length = %d\n", purpose_len);
   units_len = png_strlen(units) + (nparams == 0 ? 0 : 1);
   png_debug1(3, "pCAL units length = %d\n", units_len);
   total_len = purpose_len + units_len + 10;

   params_len = (png_uint_32p)png_malloc(png_ptr, (png_uint_32)(nparams
      *sizeof(png_uint_32)));

   /* Find the length of each parameter, making sure we don't count the
      null terminator for the last parameter. */
   for (i = 0; i < nparams; i++)
   {
      params_len[i] = png_strlen(params[i]) + (i == nparams - 1 ? 0 : 1);
      png_debug2(3, "pCAL parameter %d length = %d\n", i, params_len[i]);
      total_len += (png_size_t)params_len[i];
   }

   png_debug1(3, "pCAL total length = %d\n", total_len);
   png_write_chunk_start(png_ptr, (png_bytep) png_pCAL, (png_uint_32)total_len);
   png_write_chunk_data(png_ptr, (png_bytep)new_purpose, purpose_len);
   png_save_int_32(buf, X0);
   png_save_int_32(buf + 4, X1);
   buf[8] = (png_byte)type;
   buf[9] = (png_byte)nparams;
   png_write_chunk_data(png_ptr, buf, (png_size_t)10);
   png_write_chunk_data(png_ptr, (png_bytep)units, (png_size_t)units_len);

   png_free(png_ptr, new_purpose);

   for (i = 0; i < nparams; i++)
   {
      png_write_chunk_data(png_ptr, (png_bytep)params[i],
         (png_size_t)params_len[i]);
   }

   png_free(png_ptr, params_len);
   png_write_chunk_end(png_ptr);
}
#endif

#if defined(PNG_WRITE_pHYs_SUPPORTED)
/* write the pHYs chunk */
void
png_write_pHYs(png_structp png_ptr, png_uint_32 x_pixels_per_unit,
   png_uint_32 y_pixels_per_unit,
   int unit_type)
{
   png_byte buf[9];

   png_debug(1, "in png_write_pHYs\n");
   if (unit_type >= PNG_RESOLUTION_LAST)
      png_warning(png_ptr, "Unrecognized unit type for pHYs chunk");

   png_save_uint_32(buf, x_pixels_per_unit);
   png_save_uint_32(buf + 4, y_pixels_per_unit);
   buf[8] = (png_byte)unit_type;

   png_write_chunk(png_ptr, png_pHYs, buf, (png_size_t)9);
}
#endif

#if defined(PNG_WRITE_tIME_SUPPORTED)
/* Write the tIME chunk.  Use either png_convert_from_struct_tm()
 * or png_convert_from_time_t(), or fill in the structure yourself.
 */
void
png_write_tIME(png_structp png_ptr, png_timep mod_time)
{
   png_byte buf[7];

   png_debug(1, "in png_write_tIME\n");
   if (mod_time->month  > 12 || mod_time->month  < 1 ||
       mod_time->day    > 31 || mod_time->day    < 1 ||
       mod_time->hour   > 23 || mod_time->second > 60)
   {
      png_warning(png_ptr, "Invalid time specified for tIME chunk");
      return;
   }

   png_save_uint_16(buf, mod_time->year);
   buf[2] = mod_time->month;
   buf[3] = mod_time->day;
   buf[4] = mod_time->hour;
   buf[5] = mod_time->minute;
   buf[6] = mod_time->second;

   png_write_chunk(png_ptr, png_tIME, buf, (png_size_t)7);
}
#endif

/* initializes the row writing capability of libpng */
void
png_write_start_row(png_structp png_ptr)
{
   png_size_t buf_size;

   png_debug(1, "in png_write_start_row\n");
   buf_size = (png_size_t)(((png_ptr->width * png_ptr->usr_channels *
                            png_ptr->usr_bit_depth + 7) >> 3) + 1);

   /* set up row buffer */
   png_ptr->row_buf = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
   png_ptr->row_buf[0] = PNG_FILTER_VALUE_NONE;

   /* set up filtering buffer, if using this filter */
   if (png_ptr->do_filter & PNG_FILTER_SUB)
   {
      png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,
         (png_ptr->rowbytes + 1));
      png_ptr->sub_row[0] = PNG_FILTER_VALUE_SUB;
   }

   /* We only need to keep the previous row if we are using one of these. */
   if (png_ptr->do_filter & (PNG_FILTER_AVG | PNG_FILTER_UP | PNG_FILTER_PAETH))
   {
     /* set up previous row buffer */
      png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
      png_memset(png_ptr->prev_row, 0, buf_size);

      if (png_ptr->do_filter & PNG_FILTER_UP)
      {
         png_ptr->up_row = (png_bytep )png_malloc(png_ptr,
            (png_ptr->rowbytes + 1));
         png_ptr->up_row[0] = PNG_FILTER_VALUE_UP;
      }

      if (png_ptr->do_filter & PNG_FILTER_AVG)
      {
         png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,
            (png_ptr->rowbytes + 1));
         png_ptr->avg_row[0] = PNG_FILTER_VALUE_AVG;
      }

      if (png_ptr->do_filter & PNG_FILTER_PAETH)
      {
         png_ptr->paeth_row = (png_bytep )png_malloc(png_ptr,
            (png_ptr->rowbytes + 1));
         png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;
      }
   }

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* if interlaced, we need to set up width and height of pass */
   if (png_ptr->interlaced)
   {
      if (!(png_ptr->transformations & PNG_INTERLACE))
      {
         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
            png_pass_ystart[0]) / png_pass_yinc[0];
         png_ptr->usr_width = (png_ptr->width + png_pass_inc[0] - 1 -
            png_pass_start[0]) / png_pass_inc[0];
      }
      else
      {
         png_ptr->num_rows = png_ptr->height;
         png_ptr->usr_width = png_ptr->width;
      }
   }
   else
#endif
   {
      png_ptr->num_rows = png_ptr->height;
      png_ptr->usr_width = png_ptr->width;
   }
   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   png_ptr->zstream.next_out = png_ptr->zbuf;
}

/* Internal use only.  Called when finished processing a row of data. */
void
png_write_finish_row(png_structp png_ptr)
{
   int ret;

   png_debug(1, "in png_write_finish_row\n");
   /* next row */
   png_ptr->row_number++;

   /* see if we are done */
   if (png_ptr->row_number < png_ptr->num_rows)
      return;

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* if interlaced, go to next pass */
   if (png_ptr->interlaced)
   {
      png_ptr->row_number = 0;
      if (png_ptr->transformations & PNG_INTERLACE)
      {
         png_ptr->pass++;
      }
      else
      {
         /* loop until we find a non-zero width or height pass */
         do
         {
            png_ptr->pass++;
            if (png_ptr->pass >= 7)
               break;
            png_ptr->usr_width = (png_ptr->width +
               png_pass_inc[png_ptr->pass] - 1 -
               png_pass_start[png_ptr->pass]) /
               png_pass_inc[png_ptr->pass];
            png_ptr->num_rows = (png_ptr->height +
               png_pass_yinc[png_ptr->pass] - 1 -
               png_pass_ystart[png_ptr->pass]) /
               png_pass_yinc[png_ptr->pass];
            if (png_ptr->transformations & PNG_INTERLACE)
               break;
         } while (png_ptr->usr_width == 0 || png_ptr->num_rows == 0);

      }

      /* reset the row above the image for the next pass */
      if (png_ptr->pass < 7)
      {
         if (png_ptr->prev_row != NULL)
            png_memset(png_ptr->prev_row, 0,
               (png_size_t) (((png_uint_32)png_ptr->usr_channels *
               (png_uint_32)png_ptr->usr_bit_depth *
               png_ptr->width + 7) >> 3) + 1);
         return;
      }
   }
#endif

   /* if we get here, we've just written the last row, so we need
      to flush the compressor */
   do
   {
      /* tell the compressor we are done */
      ret = deflate(&png_ptr->zstream, Z_FINISH);
      /* check for an error */
      if (ret != Z_OK && ret != Z_STREAM_END)
      {
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }
      /* check to see if we need more room */
      if (!(png_ptr->zstream.avail_out) && ret == Z_OK)
      {
         png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
         png_ptr->zstream.next_out = png_ptr->zbuf;
         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
      }
   } while (ret != Z_STREAM_END);

   /* write any extra space */
   if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)
   {
      png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size -
         png_ptr->zstream.avail_out);
   }

   deflateReset(&png_ptr->zstream);
}

#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
/* Pick out the correct pixels for the interlace pass.
 * The basic idea here is to go through the row with a source
 * pointer and a destination pointer (sp and dp), and copy the
 * correct pixels for the pass.  As the row gets compacted,
 * sp will always be >= dp, so we should never overwrite anything.
 * See the default: case for the easiest code to understand.
 */
void
png_do_write_interlace(png_row_infop row_info, png_bytep row, int pass)
{
   png_debug(1, "in png_do_write_interlace\n");
   /* we don't have to do anything on the last pass (6) */
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL && pass < 6)
#else
   if (pass < 6)
#endif
   {
      /* each pixel depth is handled separately */
      switch (row_info->pixel_depth)
      {
         case 1:
         {
            png_bytep sp;
            png_bytep dp;
            int shift;
            int d;
            int value;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            dp = row;
            d = 0;
            shift = 7;
            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               sp = row + (png_size_t)(i >> 3);
               value = (int)(*sp >> (7 - (int)(i & 7))) & 0x1;
               d |= (value << shift);

               if (shift == 0)
               {
                  shift = 7;
                  *dp++ = (png_byte)d;
                  d = 0;
               }
               else
                  shift--;

            }
            if (shift != 7)
               *dp = (png_byte)d;
            break;
         }
         case 2:
         {
            png_bytep sp;
            png_bytep dp;
            int shift;
            int d;
            int value;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            dp = row;
            shift = 6;
            d = 0;
            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               sp = row + (png_size_t)(i >> 2);
               value = (*sp >> ((3 - (int)(i & 3)) << 1)) & 0x3;
               d |= (value << shift);

               if (shift == 0)
               {
                  shift = 6;
                  *dp++ = (png_byte)d;
                  d = 0;
               }
               else
                  shift -= 2;
            }
            if (shift != 6)
                   *dp = (png_byte)d;
            break;
         }
         case 4:
         {
            png_bytep sp;
            png_bytep dp;
            int shift;
            int d;
            int value;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            dp = row;
            shift = 4;
            d = 0;
            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               sp = row + (png_size_t)(i >> 1);
               value = (*sp >> ((1 - (int)(i & 1)) << 2)) & 0xf;
               d |= (value << shift);

               if (shift == 0)
               {
                  shift = 4;
                  *dp++ = (png_byte)d;
                  d = 0;
               }
               else
                  shift -= 4;
            }
            if (shift != 4)
               *dp = (png_byte)d;
            break;
         }
         default:
         {
            png_bytep sp;
            png_bytep dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;
            png_size_t pixel_bytes;

            /* start at the beginning */
            dp = row;
            /* find out how many bytes each pixel takes up */
            pixel_bytes = (row_info->pixel_depth >> 3);
            /* loop through the row, only looking at the pixels that
               matter */
            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               /* find out where the original pixel is */
               sp = row + (png_size_t)i * pixel_bytes;
               /* move the pixel */
               if (dp != sp)
                  png_memcpy(dp, sp, pixel_bytes);
               /* next pixel */
               dp += pixel_bytes;
            }
            break;
         }
      }
      /* set new row width */
      row_info->width = (row_info->width +
         png_pass_inc[pass] - 1 -
         png_pass_start[pass]) /
         png_pass_inc[pass];
         row_info->rowbytes = ((row_info->width *
            row_info->pixel_depth + 7) >> 3);
   }
}
#endif

/* This filters the row, chooses which filter to use, if it has not already
 * been specified by the application, and then writes the row out with the
 * chosen filter.
 */
#define PNG_MAXSUM (~((png_uint_32)0) >> 1)
#define PNG_HISHIFT 10
#define PNG_LOMASK ((png_uint_32)0xffffL)
#define PNG_HIMASK ((png_uint_32)(~PNG_LOMASK >> PNG_HISHIFT))
void
png_write_find_filter(png_structp png_ptr, png_row_infop row_info)
{
   png_bytep prev_row, best_row, row_buf;
   png_uint_32 mins, bpp;
   png_byte filter_to_do = png_ptr->do_filter;
   png_uint_32 row_bytes = row_info->rowbytes;
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   int num_p_filters = (int)png_ptr->num_prev_filters;
#endif

   png_debug(1, "in png_write_find_filter\n");
   /* find out how many bytes offset each pixel is */
   bpp = (row_info->pixel_depth + 7) / 8;

   prev_row = png_ptr->prev_row;
   best_row = row_buf = png_ptr->row_buf;
   mins = PNG_MAXSUM;

   /* The prediction method we use is to find which method provides the
    * smallest value when summing the absolute values of the distances
    * from zero, using anything >= 128 as negative numbers.  This is known
    * as the "minimum sum of absolute differences" heuristic.  Other
    * heuristics are the "weighted minimum sum of absolute differences"
    * (experimental and can in theory improve compression), and the "zlib
    * predictive" method (not implemented yet), which does test compressions
    * of lines using different filter methods, and then chooses the
    * (series of) filter(s) that give minimum compressed data size (VERY
    * computationally expensive).
    *
    * GRR 980525:  consider also
    *   (1) minimum sum of absolute differences from running average (i.e.,
    *       keep running sum of non-absolute differences & count of bytes)
    *       [track dispersion, too?  restart average if dispersion too large?]
    *  (1b) minimum sum of absolute differences from sliding average, probably
    *       with window size <= deflate window (usually 32K)
    *   (2) minimum sum of squared differences from zero or running average
    *       (i.e., ~ root-mean-square approach)
    */


   /* We don't need to test the 'no filter' case if this is the only filter
    * that has been chosen, as it doesn't actually do anything to the data.
    */
   if (filter_to_do & PNG_FILTER_NONE &&
       filter_to_do != PNG_FILTER_NONE)
   {
      png_bytep rp;
      png_uint_32 sum = 0;
      png_uint_32 i;
      int v;

      for (i = 0, rp = row_buf + 1; i < row_bytes; i++, rp++)
      {
         v = *rp;
         sum += (v < 128) ? v : 256 - v;
      }

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         png_uint_32 sumhi, sumlo;
         int j;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK; /* Gives us some footroom */

         /* Reduce the sum if we match any of the previous rows */
         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         /* Factor in the cost of this filter (this is here for completeness,
          * but it makes no sense to have a "cost" for the NONE filter, as
          * it has the minimum possible computational cost - none).
          */
         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif
      mins = sum;
   }

   /* sub filter */
   if (filter_to_do == PNG_FILTER_SUB)
   /* it's the only filter so no testing is needed */
   {
      png_bytep rp, lp, dp;
      png_uint_32 i;
      for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
           i++, rp++, dp++)
      {
         *dp = *rp;
      }
      for (lp = row_buf + 1; i < row_bytes;
         i++, rp++, lp++, dp++)
      {
         *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
      }
      best_row = png_ptr->sub_row;
   }

   else if (filter_to_do & PNG_FILTER_SUB)
   {
      png_bytep rp, dp, lp;
      png_uint_32 sum = 0, lmins = mins;
      png_uint_32 i;
      int v;

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      /* We temporarily increase the "minimum sum" by the factor we
       * would reduce the sum of this filter, so that we can do the
       * early exit comparison without scaling the sum each time.
       */
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;

         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif

      for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
           i++, rp++, dp++)
      {
         v = *dp = *rp;

         sum += (v < 128) ? v : 256 - v;
      }
      for (lp = row_buf + 1; i < row_info->rowbytes;
         i++, rp++, lp++, dp++)
      {
         v = *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);

         sum += (v < 128) ? v : 256 - v;

         if (sum > lmins)  /* We are already worse, don't continue. */
            break;
      }

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
            {
               sumlo = (sumlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         sumlo = (sumlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif

      if (sum < mins)
      {
         mins = sum;
         best_row = png_ptr->sub_row;
      }
   }

   /* up filter */
   if (filter_to_do == PNG_FILTER_UP)
   {
      png_bytep rp, dp, pp;
      png_uint_32 i;

      for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
           pp = prev_row + 1; i < row_bytes;
           i++, rp++, pp++, dp++)
      {
         *dp = (png_byte)(((int)*rp - (int)*pp) & 0xff);
      }
      best_row = png_ptr->up_row;
   }

   else if (filter_to_do & PNG_FILTER_UP)
   {
      png_bytep rp, dp, pp;
      png_uint_32 sum = 0, lmins = mins;
      png_uint_32 i;
      int v;


#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;

         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif

      for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
           pp = prev_row + 1; i < row_bytes; i++)
      {
         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);

         sum += (v < 128) ? v : 256 - v;

         if (sum > lmins)  /* We are already worse, don't continue. */
            break;
      }

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif

      if (sum < mins)
      {
         mins = sum;
         best_row = png_ptr->up_row;
      }
   }

   /* avg filter */
   if (filter_to_do == PNG_FILTER_AVG)
   {
      png_bytep rp, dp, pp, lp;
      png_uint_32 i;
      for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
           pp = prev_row + 1; i < bpp; i++)
      {
         *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
      }
      for (lp = row_buf + 1; i < row_bytes; i++)
      {
         *dp++ = (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2))
                 & 0xff);
      }
      best_row = png_ptr->avg_row;
   }

   else if (filter_to_do & PNG_FILTER_AVG)
   {
      png_bytep rp, dp, pp, lp;
      png_uint_32 sum = 0, lmins = mins;
      png_uint_32 i;
      int v;

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_AVG)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;

         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif

      for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
           pp = prev_row + 1; i < bpp; i++)
      {
         v = *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);

         sum += (v < 128) ? v : 256 - v;
      }
      for (lp = row_buf + 1; i < row_bytes; i++)
      {
         v = *dp++ =
          (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2)) & 0xff);

         sum += (v < 128) ? v : 256 - v;

         if (sum > lmins)  /* We are already worse, don't continue. */
            break;
      }

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif

      if (sum < mins)
      {
         mins = sum;
         best_row = png_ptr->avg_row;
      }
   }

   /* Paeth filter */
   if (filter_to_do == PNG_FILTER_PAETH)
   {
      png_bytep rp, dp, pp, cp, lp;
      png_uint_32 i;
      for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
           pp = prev_row + 1; i < bpp; i++)
      {
         *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
      }

      for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
      {
         int a, b, c, pa, pb, pc, p;

         b = *pp++;
         c = *cp++;
         a = *lp++;

         p = b - c;
         pc = a - c;

#ifdef PNG_USE_ABS
         pa = abs(p);
         pb = abs(pc);
         pc = abs(p + pc);
#else
         pa = p < 0 ? -p : p;
         pb = pc < 0 ? -pc : pc;
         pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif

         p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;

         *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
      }
      best_row = png_ptr->paeth_row;
   }

   else if (filter_to_do & PNG_FILTER_PAETH)
   {
      png_bytep rp, dp, pp, cp, lp;
      png_uint_32 sum = 0, lmins = mins;
      png_uint_32 i;
      int v;

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;

         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif

      for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
           pp = prev_row + 1; i < bpp; i++)
      {
         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);

         sum += (v < 128) ? v : 256 - v;
      }

      for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
      {
         int a, b, c, pa, pb, pc, p;

         b = *pp++;
         c = *cp++;
         a = *lp++;

#ifndef PNG_SLOW_PAETH
         p = b - c;
         pc = a - c;
#ifdef PNG_USE_ABS
         pa = abs(p);
         pb = abs(pc);
         pc = abs(p + pc);
#else
         pa = p < 0 ? -p : p;
         pb = pc < 0 ? -pc : pc;
         pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif
         p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
#else /* PNG_SLOW_PAETH */
         p = a + b - c;
         pa = abs(p - a);
         pb = abs(p - b);
         pc = abs(p - c);
         if (pa <= pb && pa <= pc)
            p = a;
         else if (pb <= pc)
            p = b;
         else
            p = c;
#endif /* PNG_SLOW_PAETH */

         v = *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);

         sum += (v < 128) ? v : 256 - v;

         if (sum > lmins)  /* We are already worse, don't continue. */
            break;
      }

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif

      if (sum < mins)
      {
         best_row = png_ptr->paeth_row;
      }
   }

   /* Do the actual writing of the filtered row data from the chosen filter. */

   png_write_filtered_row(png_ptr, best_row);

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   /* Save the type of filter we picked this time for future calculations */
   if (png_ptr->num_prev_filters > 0)
   {
      int j;
      for (j = 1; j < num_p_filters; j++)
      {
         png_ptr->prev_filters[j] = png_ptr->prev_filters[j - 1];
      }
      png_ptr->prev_filters[j] = best_row[0];
   }
#endif
}


/* Do the actual writing of a previously filtered row. */
void
png_write_filtered_row(png_structp png_ptr, png_bytep filtered_row)
{
   png_debug(1, "in png_write_filtered_row\n");
   png_debug1(2, "filter = %d\n", filtered_row[0]);
   /* set up the zlib input buffer */
   png_ptr->zstream.next_in = filtered_row;
   png_ptr->zstream.avail_in = (uInt)png_ptr->row_info.rowbytes + 1;
   /* repeat until we have compressed all the data */
   do
   {
      int ret; /* return of zlib */

      /* compress the data */
      ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);
      /* check for compression errors */
      if (ret != Z_OK)
      {
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }

      /* see if it is time to write another IDAT */
      if (!(png_ptr->zstream.avail_out))
      {
         /* write the IDAT and reset the zlib output buffer */
         png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
         png_ptr->zstream.next_out = png_ptr->zbuf;
         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
      }
   /* repeat until all data has been compressed */
   } while (png_ptr->zstream.avail_in);

   /* swap the current and previous rows */
   if (png_ptr->prev_row != NULL)
   {
      png_bytep tptr;

      tptr = png_ptr->prev_row;
      png_ptr->prev_row = png_ptr->row_buf;
      png_ptr->row_buf = tptr;
   }

   /* finish row - updates counters and flushes zlib if last row */
   png_write_finish_row(png_ptr);

#if defined(PNG_WRITE_FLUSH_SUPPORTED)
   png_ptr->flush_rows++;

   if (png_ptr->flush_dist > 0 &&
       png_ptr->flush_rows >= png_ptr->flush_dist)
   {
      png_write_flush(png_ptr);
   }
#endif /* PNG_WRITE_FLUSH_SUPPORTED */
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\pngwio.cpp ===
/* pngwio.c - functions for data output
 *
 * libpng 1.0.5 - October 15, 1999
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.
 * Copyright (c) 1996, 1997 Andreas Dilger
 * Copyright (c) 1998, 1999 Glenn Randers-Pehrson
 *
 * This file provides a location for all output.  Users who need
 * special handling are expected to write functions that have the same
 * arguments as these and perform similar functions, but that possibly
 * use different output methods.  Note that you shouldn't change these
 * functions, but rather write replacement functions and then change
 * them at run time with png_set_write_fn(...).
 */

#define PNG_INTERNAL
#include "png.h"

namespace D3DX
{


/* Write the data to whatever output you are using.  The default routine
   writes to a file pointer.  Note that this routine sometimes gets called
   with very small lengths, so you should implement some kind of simple
   buffering if you are using unbuffered writes.  This should never be asked
   to write more than 64K on a 16 bit machine.  */

void
png_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   if (png_ptr->write_data_fn != NULL )
      (*(png_ptr->write_data_fn))(png_ptr, data, length);
   else
      png_error(png_ptr, "Call to NULL write function");
}

#if !defined(PNG_NO_STDIO)
/* This is the function that does the actual writing of data.  If you are
   not writing to a standard C stream, you should create a replacement
   write_data function and use it at run time with png_set_write_fn(), rather
   than changing the library. */
#ifndef USE_FAR_KEYWORD
static void
png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_uint_32 check;

   check = fwrite(data, 1, length, (FILE *)(png_ptr->io_ptr));
   if (check != length)
   {
      png_error(png_ptr, "Write Error");
   }
}
#else
/* this is the model-independent version. Since the standard I/O library
   can't handle far buffers in the medium and small models, we have to copy
   the data.
*/

#define NEAR_BUF_SIZE 1024
#define MIN(a,b) (a <= b ? a : b)

static void
png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_uint_32 check;
   png_byte *near_data;  /* Needs to be "png_byte *" instead of "png_bytep" */
   FILE *io_ptr;

   /* Check if data really is near. If so, use usual code. */
   near_data = (png_byte *)CVT_PTR_NOCHECK(data);
   io_ptr = (FILE *)CVT_PTR(png_ptr->io_ptr);
   if ((png_bytep)near_data == data)
   {
      check = fwrite(near_data, 1, length, io_ptr);
   }
   else
   {
      png_byte buf[NEAR_BUF_SIZE];
      png_size_t written, remaining, err;
      check = 0;
      remaining = length;
      do
      {
         written = MIN(NEAR_BUF_SIZE, remaining);
         png_memcpy(buf, data, written); /* copy far buffer to near buffer */
         err = fwrite(buf, 1, written, io_ptr);
         if (err != written)
            break;
         else
            check += err;
         data += written;
         remaining -= written;
      }
      while (remaining != 0);
   }
   if (check != length)
   {
      png_error(png_ptr, "Write Error");
   }
}

#endif
#endif

/* This function is called to output any data pending writing (normally
   to disk).  After png_flush is called, there should be no data pending
   writing in any buffers. */
#if defined(PNG_WRITE_FLUSH_SUPPORTED)
void
png_flush(png_structp png_ptr)
{
   if (png_ptr->output_flush_fn != NULL)
      (*(png_ptr->output_flush_fn))(png_ptr);
}

#if !defined(PNG_NO_STDIO)
static void
png_default_flush(png_structp png_ptr)
{
   FILE *io_ptr;
   io_ptr = (FILE *)CVT_PTR((png_ptr->io_ptr));
   if (io_ptr != NULL)
      fflush(io_ptr);
}
#endif
#endif

/* This function allows the application to supply new output functions for
   libpng if standard C streams aren't being used.

   This function takes as its arguments:
   png_ptr       - pointer to a png output data structure
   io_ptr        - pointer to user supplied structure containing info about
                   the output functions.  May be NULL.
   write_data_fn - pointer to a new output function that takes as its
                   arguments a pointer to a png_struct, a pointer to
                   data to be written, and a 32-bit unsigned int that is
                   the number of bytes to be written.  The new write
                   function should call png_error(png_ptr, "Error msg")
                   to exit and output any fatal error messages.
   flush_data_fn - pointer to a new flush function that takes as its
                   arguments a pointer to a png_struct.  After a call to
                   the flush function, there should be no data in any buffers
                   or pending transmission.  If the output method doesn't do
                   any buffering of ouput, a function prototype must still be
                   supplied although it doesn't have to do anything.  If
                   PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
                   time, output_flush_fn will be ignored, although it must be
                   supplied for compatibility. */
void
png_set_write_fn(png_structp png_ptr, png_voidp io_ptr,
   png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn)
{
   png_ptr->io_ptr = io_ptr;

#if !defined(PNG_NO_STDIO)
   if (write_data_fn != NULL)
      png_ptr->write_data_fn = write_data_fn;
   else
      png_ptr->write_data_fn = png_default_write_data;
#else
   png_ptr->write_data_fn = write_data_fn;
#endif

#if defined(PNG_WRITE_FLUSH_SUPPORTED)
#if !defined(PNG_NO_STDIO)
   if (output_flush_fn != NULL)
      png_ptr->output_flush_fn = output_flush_fn;
   else
      png_ptr->output_flush_fn = png_default_flush;
#else
   png_ptr->output_flush_fn = output_flush_fn;
#endif
#endif /* PNG_WRITE_FLUSH_SUPPORTED */

   /* It is an error to read while writing a png file */
   if (png_ptr->read_data_fn != NULL)
   {
      png_ptr->read_data_fn = NULL;
      png_warning(png_ptr,
         "Attempted to set both read_data_fn and write_data_fn in");
      png_warning(png_ptr,
         "the same structure.  Resetting read_data_fn to NULL.");
   }
}

#if defined(USE_FAR_KEYWORD)
#if defined(_MSC_VER)
void *png_far_to_near(png_structp png_ptr,png_voidp ptr, int check)
{
   void *near_ptr;
   void FAR *far_ptr;
   FP_OFF(near_ptr) = FP_OFF(ptr);
   far_ptr = (void FAR *)near_ptr;
   if(check != 0)
      if(FP_SEG(ptr) != FP_SEG(far_ptr))
         png_error(png_ptr,"segment lost in conversion");
   return(near_ptr);
}
#  else
void *png_far_to_near(png_structp png_ptr,png_voidp ptr, int check)
{
   void *near_ptr;
   void FAR *far_ptr;
   near_ptr = (void FAR *)ptr;
   far_ptr = (void FAR *)near_ptr;
   if(check != 0)
      if(far_ptr != ptr)
         png_error(png_ptr,"segment lost in conversion");
   return(near_ptr);
}
#   endif
#   endif

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\contrib\gregbook\readpng2.h ===
/*---------------------------------------------------------------------------

   rpng2 - progressive-model PNG display program                 readpng2.h

  ---------------------------------------------------------------------------

      Copyright (c) 1998-1999 Greg Roelofs.  All rights reserved.

      This software is provided "as is," without warranty of any kind,
      express or implied.  In no event shall the author or contributors
      be held liable for any damages arising in any way from the use of
      this software.

      Permission is granted to anyone to use this software for any purpose,
      including commercial applications, and to alter it and redistribute
      it freely, subject to the following restrictions:

      1. Redistributions of source code must retain the above copyright
         notice, disclaimer, and this list of conditions.
      2. Redistributions in binary form must reproduce the above copyright
         notice, disclaimer, and this list of conditions in the documenta-
         tion and/or other materials provided with the distribution.
      3. All advertising materials mentioning features or use of this
         software must display the following acknowledgment:

            This product includes software developed by Greg Roelofs
            and contributors for the book, "PNG: The Definitive Guide,"
            published by O'Reilly and Associates.

  ---------------------------------------------------------------------------*/

#ifndef TRUE
#  define TRUE 1
#  define FALSE 0
#endif

#ifndef MAX
#  define MAX(a,b)  ((a) > (b)? (a) : (b))
#  define MIN(a,b)  ((a) < (b)? (a) : (b))
#endif

#ifdef DEBUG
#  define Trace(x)  {fprintf x ; fflush(stderr); fflush(stdout);}
#else
#  define Trace(x)  ;
#endif

typedef unsigned char   uch;
typedef unsigned short  ush;
typedef unsigned long   ulg;

typedef struct _mainprog_info {
    double display_exponent;
    ulg width;
    ulg height;
    void *png_ptr;
    void *info_ptr;
    void (*mainprog_init)(void);
    void (*mainprog_display_row)(ulg row_num);
    void (*mainprog_finish_display)(void);
    uch *image_data;
    uch **row_pointers;
    jmp_buf jmpbuf;
    int passes;			/* not used */
    int rowbytes;
    int channels;
    int need_bgcolor;
    int done;
    uch bg_red;
    uch bg_green;
    uch bg_blue;
} mainprog_info;


/* prototypes for public functions in readpng2.c */

void readpng2_version_info(void);

int readpng2_check_sig(uch *sig, int num);

int readpng2_init(mainprog_info *mainprog_ptr);

int readpng2_decode_data(mainprog_info *mainprog_ptr, uch *rawbuf, ulg length);

void readpng2_cleanup(mainprog_info *mainprog_ptr);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\contrib\gregbook\readpng2.c ===
/*---------------------------------------------------------------------------

   rpng2 - progressive-model PNG display program                 readpng2.c

  ---------------------------------------------------------------------------

      Copyright (c) 1998-1999 Greg Roelofs.  All rights reserved.

      This software is provided "as is," without warranty of any kind,
      express or implied.  In no event shall the author or contributors
      be held liable for any damages arising in any way from the use of
      this software.

      Permission is granted to anyone to use this software for any purpose,
      including commercial applications, and to alter it and redistribute
      it freely, subject to the following restrictions:

      1. Redistributions of source code must retain the above copyright
         notice, disclaimer, and this list of conditions.
      2. Redistributions in binary form must reproduce the above copyright
         notice, disclaimer, and this list of conditions in the documenta-
         tion and/or other materials provided with the distribution.
      3. All advertising materials mentioning features or use of this
         software must display the following acknowledgment:

            This product includes software developed by Greg Roelofs
            and contributors for the book, "PNG: The Definitive Guide,"
            published by O'Reilly and Associates.

  ---------------------------------------------------------------------------*/


#include <stdlib.h>	/* for exit() prototype */

#include "png.h"	/* libpng header; includes zlib.h and setjmp.h */
#include "readpng2.h"	/* typedefs, common macros, public prototypes */


/* local prototypes */

static void readpng2_info_callback(png_structp png_ptr, png_infop info_ptr);
static void readpng2_row_callback(png_structp png_ptr, png_bytep new_row,
                                 png_uint_32 row_num, int pass);
static void readpng2_end_callback(png_structp png_ptr, png_infop info_ptr);
static void readpng2_error_handler(png_structp png_ptr, png_const_charp msg);




void readpng2_version_info()
{
    fprintf(stderr, "   Compiled with libpng %s; using libpng %s.\n",
      PNG_LIBPNG_VER_STRING, png_libpng_ver);
    fprintf(stderr, "   Compiled with zlib %s; using zlib %s.\n",
      ZLIB_VERSION, zlib_version);
} 




int readpng2_check_sig(uch *sig, int num)
{
    return png_check_sig(sig, num);
}




/* returns 0 for success, 2 for libpng problem, 4 for out of memory */

int readpng2_init(mainprog_info *mainprog_ptr)
{
    png_structp  png_ptr;	/* note:  temporary variables! */
    png_infop  info_ptr;


    /* could also replace libpng warning-handler (final NULL), but no need: */

    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,
      readpng2_error_handler, NULL);
    if (!png_ptr)
        return 4;   /* out of memory */

    info_ptr = png_create_info_struct(png_ptr);
    if (!info_ptr) {
        png_destroy_read_struct(&png_ptr, NULL, NULL);
        return 4;   /* out of memory */
    }


    /* we could create a second info struct here (end_info), but it's only
     * useful if we want to keep pre- and post-IDAT chunk info separated
     * (mainly for PNG-aware image editors and converters) */


    /* setjmp() must be called in every function that calls a PNG-reading
     * libpng function, unless an alternate error handler was installed--
     * but compatible error handlers must either use longjmp() themselves
     * (as in this program) or exit immediately, so here we are: */

    if (setjmp(mainprog_ptr->jmpbuf)) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
        return 2;
    }


    /* instead of doing png_init_io() here, now we set up our callback
     * functions for progressive decoding */

    png_set_progressive_read_fn(png_ptr, mainprog_ptr,
      readpng2_info_callback, readpng2_row_callback, readpng2_end_callback);


    /* make sure we save our pointers for use in readpng2_decode_data() */

    mainprog_ptr->png_ptr = png_ptr;
    mainprog_ptr->info_ptr = info_ptr;


    /* and that's all there is to initialization */

    return 0;
}




/* returns 0 for success, 2 for libpng (longjmp) problem */

int readpng2_decode_data(mainprog_info *mainprog_ptr, uch *rawbuf, ulg length)
{
    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;
    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;


    /* setjmp() must be called in every function that calls a PNG-reading
     * libpng function */

    if (setjmp(mainprog_ptr->jmpbuf)) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
        mainprog_ptr->png_ptr = NULL;
        mainprog_ptr->info_ptr = NULL;
        return 2;
    }


    /* hand off the next chunk of input data to libpng for decoding */

    png_process_data(png_ptr, info_ptr, rawbuf, length);

    return 0;
}




static void readpng2_info_callback(png_structp png_ptr, png_infop info_ptr)
{
    mainprog_info  *mainprog_ptr;
    int  color_type, bit_depth;
    double  gamma;


    /* setjmp() doesn't make sense here, because we'd either have to exit(),
     * longjmp() ourselves, or return control to libpng, which doesn't want
     * to see us again.  By not doing anything here, libpng will instead jump
     * to readpng2_decode_data(), which can return an error value to the main
     * program. */


    /* retrieve the pointer to our special-purpose struct, using the png_ptr
     * that libpng passed back to us (i.e., not a global this time--there's
     * no real difference for a single image, but for a multithreaded browser
     * decoding several PNG images at the same time, one needs to avoid mixing
     * up different images' structs) */

    mainprog_ptr = png_get_progressive_ptr(png_ptr);

    if (mainprog_ptr == NULL) {		/* we be hosed */
        fprintf(stderr,
          "readpng2 error:  main struct not recoverable in info_callback.\n");
        fflush(stderr);
        return;
        /*
         * Alternatively, we could call our error-handler just like libpng
         * does, which would effectively terminate the program.  Since this
         * can only happen if png_ptr gets redirected somewhere odd or the
         * main PNG struct gets wiped, we're probably toast anyway.  (If
         * png_ptr itself is NULL, we would not have been called.)
         */
    }


    /* this is just like in the non-progressive case */

    png_get_IHDR(png_ptr, info_ptr, &mainprog_ptr->width,
      &mainprog_ptr->height, &bit_depth, &color_type, NULL, NULL, NULL);


    /* since we know we've read all of the PNG file's "header" (i.e., up
     * to IDAT), we can check for a background color here */

    if (mainprog_ptr->need_bgcolor &&
        png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD))
    {
        png_color_16p pBackground;

        /* it is not obvious from the libpng documentation, but this function
         * takes a pointer to a pointer, and it always returns valid red,
         * green and blue values, regardless of color_type: */
        png_get_bKGD(png_ptr, info_ptr, &pBackground);

        /* however, it always returns the raw bKGD data, regardless of any
         * bit-depth transformations, so check depth and adjust if necessary */
        if (bit_depth == 16) {
            mainprog_ptr->bg_red   = pBackground->red   >> 8;
            mainprog_ptr->bg_green = pBackground->green >> 8;
            mainprog_ptr->bg_blue  = pBackground->blue  >> 8;
        } else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) {
            if (bit_depth == 1)
                mainprog_ptr->bg_red = mainprog_ptr->bg_green =
                  mainprog_ptr->bg_blue = pBackground->gray? 255 : 0;
            else if (bit_depth == 2)
                mainprog_ptr->bg_red = mainprog_ptr->bg_green =
                  mainprog_ptr->bg_blue = (255/3) * pBackground->gray;
            else /* bit_depth == 4 */
                mainprog_ptr->bg_red = mainprog_ptr->bg_green =
                  mainprog_ptr->bg_blue = (255/15) * pBackground->gray;
        } else {
            mainprog_ptr->bg_red   = (uch)pBackground->red;
            mainprog_ptr->bg_green = (uch)pBackground->green;
            mainprog_ptr->bg_blue  = (uch)pBackground->blue;
        }
    }


    /* as before, let libpng expand palette images to RGB, low-bit-depth
     * grayscale images to 8 bits, transparency chunks to full alpha channel;
     * strip 16-bit-per-sample images to 8 bits per sample; and convert
     * grayscale to RGB[A] */

    if (color_type == PNG_COLOR_TYPE_PALETTE)
        png_set_expand(png_ptr);
    if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
        png_set_expand(png_ptr);
    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
        png_set_expand(png_ptr);
    if (bit_depth == 16)
        png_set_strip_16(png_ptr);
    if (color_type == PNG_COLOR_TYPE_GRAY ||
        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        png_set_gray_to_rgb(png_ptr);


    /* Unlike the basic viewer, which was designed to operate on local files,
     * this program is intended to simulate a web browser--even though we
     * actually read from a local file, too.  But because we are pretending
     * that most of the images originate on the Internet, we follow the recom-
     * mendation of the sRGB proposal and treat unlabelled images (no gAMA
     * chunk) as existing in the sRGB color space.  That is, we assume that
     * such images have a file gamma of 0.45455, which corresponds to a PC-like
     * display system.  This change in assumptions will have no effect on a
     * PC-like system, but on a Mac, SGI, NeXT or other system with a non-
     * identity lookup table, it will darken unlabelled images, which effec-
     * tively favors images from PC-like systems over those originating on
     * the local platform.  Note that mainprog_ptr->display_exponent is the
     * "gamma" value for the entire display system, i.e., the product of
     * LUT_exponent and CRT_exponent. */

    if (png_get_gAMA(png_ptr, info_ptr, &gamma))
        png_set_gamma(png_ptr, mainprog_ptr->display_exponent, gamma);
    else
        png_set_gamma(png_ptr, mainprog_ptr->display_exponent, 0.45455);


    /* we'll let libpng expand interlaced images, too */

    mainprog_ptr->passes = png_set_interlace_handling(png_ptr);


    /* all transformations have been registered; now update info_ptr data and
     * then get rowbytes and channels */

    png_read_update_info(png_ptr, info_ptr);

    mainprog_ptr->rowbytes = png_get_rowbytes(png_ptr, info_ptr);
    mainprog_ptr->channels = png_get_channels(png_ptr, info_ptr);


    /* Call the main program to allocate memory for the image buffer and
     * initialize windows and whatnot.  (The old-style function-pointer
     * invocation is used for compatibility with a few supposedly ANSI
     * compilers that nevertheless barf on "fn_ptr()"-style syntax.) */

    (*mainprog_ptr->mainprog_init)();


    /* and that takes care of initialization */

    return;
}





static void readpng2_row_callback(png_structp png_ptr, png_bytep new_row,
                                  png_uint_32 row_num, int pass)
{
    mainprog_info  *mainprog_ptr;


    /* first check whether the row differs from the previous pass; if not,
     * nothing to combine or display */

    if (!new_row)
        return;


    /* retrieve the pointer to our special-purpose struct so we can access
     * the old rows and image-display callback function */

    mainprog_ptr = png_get_progressive_ptr(png_ptr);


    /* have libpng either combine the new row data with the existing row data
     * from previous passes (if interlaced) or else just copy the new row
     * into the main program's image buffer */

    png_progressive_combine_row(png_ptr, mainprog_ptr->row_pointers[row_num],
      new_row);


    /* finally, call the display routine in the main program with the number
     * of the row we just updated */

    (*mainprog_ptr->mainprog_display_row)(row_num);


    /* and we're ready for more */

    return;
}





static void readpng2_end_callback(png_structp png_ptr, png_infop info_ptr)
{
    mainprog_info  *mainprog_ptr;


    /* retrieve the pointer to our special-purpose struct */

    mainprog_ptr = png_get_progressive_ptr(png_ptr);


    /* let the main program know that it should flush any buffered image
     * data to the display now and set a "done" flag or whatever, but note
     * that it SHOULD NOT DESTROY THE PNG STRUCTS YET--in other words, do
     * NOT call readpng2_cleanup() either here or in the finish_display()
     * routine; wait until control returns to the main program via
     * readpng2_decode_data() */

    (*mainprog_ptr->mainprog_finish_display)();


    /* all done */

    return;
}





void readpng2_cleanup(mainprog_info *mainprog_ptr)
{
    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;
    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;

    if (png_ptr && info_ptr)
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);

    mainprog_ptr->png_ptr = NULL;
    mainprog_ptr->info_ptr = NULL;
}





static void readpng2_error_handler(png_structp png_ptr, png_const_charp msg)
{
    mainprog_info  *mainprog_ptr;

    /* This function, aside from the extra step of retrieving the "error
     * pointer" (below) and the fact that it exists within the application
     * rather than within libpng, is essentially identical to libpng's
     * default error handler.  The second point is critical:  since both
     * setjmp() and longjmp() are called from the same code, they are
     * guaranteed to have compatible notions of how big a jmp_buf is,
     * regardless of whether _BSD_SOURCE or anything else has (or has not)
     * been defined. */

    fprintf(stderr, "readpng2 libpng error: %s\n", msg);
    fflush(stderr);

    mainprog_ptr = png_get_error_ptr(png_ptr);
    if (mainprog_ptr == NULL) {		/* we are completely hosed now */
        fprintf(stderr,
          "readpng2 severe error:  jmpbuf not recoverable; terminating.\n");
        fflush(stderr);
        exit(99);
    }

    longjmp(mainprog_ptr->jmpbuf, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\contrib\gregbook\readpng.c ===
/*---------------------------------------------------------------------------

   rpng - simple PNG display program                              readpng.c

  ---------------------------------------------------------------------------

      Copyright (c) 1998-1999 Greg Roelofs.  All rights reserved.

      This software is provided "as is," without warranty of any kind,
      express or implied.  In no event shall the author or contributors
      be held liable for any damages arising in any way from the use of
      this software.

      Permission is granted to anyone to use this software for any purpose,
      including commercial applications, and to alter it and redistribute
      it freely, subject to the following restrictions:

      1. Redistributions of source code must retain the above copyright
         notice, disclaimer, and this list of conditions.
      2. Redistributions in binary form must reproduce the above copyright
         notice, disclaimer, and this list of conditions in the documenta-
         tion and/or other materials provided with the distribution.
      3. All advertising materials mentioning features or use of this
         software must display the following acknowledgment:

            This product includes software developed by Greg Roelofs
            and contributors for the book, "PNG: The Definitive Guide,"
            published by O'Reilly and Associates.

  ---------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

#include "png.h"	/* libpng header; includes zlib.h */
#include "readpng.h"	/* typedefs, common macros, public prototypes */


static png_structp png_ptr = NULL;
static png_infop info_ptr = NULL;

png_uint_32  width, height;
int  bit_depth, color_type;
uch  *image_data = NULL;


void readpng_version_info()
{
    fprintf(stderr, "   Compiled with libpng %s; using libpng %s.\n",
      PNG_LIBPNG_VER_STRING, png_libpng_ver);
    fprintf(stderr, "   Compiled with zlib %s; using zlib %s.\n",
      ZLIB_VERSION, zlib_version);
} 


/* return value = 0 for success, 1 for bad sig, 2 for bad IHDR, 4 for no mem */

int readpng_init(FILE *infile, long *pWidth, long *pHeight)
{
    uch sig[8];


    /* first do a quick check that the file really is a PNG image; could
     * have used slightly more general png_sig_cmp() function instead */

    fread(sig, 1, 8, infile);
    if (!png_check_sig(sig, 8))
        return 1;   /* bad signature */


    /* could pass pointers to user-defined error handlers instead of NULLs: */

    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if (!png_ptr)
        return 4;   /* out of memory */

    info_ptr = png_create_info_struct(png_ptr);
    if (!info_ptr) {
        png_destroy_read_struct(&png_ptr, NULL, NULL);
        return 4;   /* out of memory */
    }


    /* we could create a second info struct here (end_info), but it's only
     * useful if we want to keep pre- and post-IDAT chunk info separated
     * (mainly for PNG-aware image editors and converters) */


    /* setjmp() must be called in every function that calls a PNG-reading
     * libpng function */

    if (setjmp(png_ptr->jmpbuf)) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
        return 2;
    }


    png_init_io(png_ptr, infile);
    png_set_sig_bytes(png_ptr, 8);  /* we already read the 8 signature bytes */

    png_read_info(png_ptr, info_ptr);  /* read all PNG info up to image data */


    /* alternatively, could make separate calls to png_get_image_width(),
     * etc., but want bit_depth and color_type for later [don't care about
     * compression_type and filter_type => NULLs] */

    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,
      NULL, NULL, NULL);
    *pWidth = width;
    *pHeight = height;


    /* OK, that's all we need for now; return happy */

    return 0;
}




/* returns 0 if succeeds, 1 if fails due to no bKGD chunk, 2 if libpng error;
 * scales values to 8-bit if necessary */

int readpng_get_bgcolor(uch *red, uch *green, uch *blue)
{
    png_color_16p pBackground;


    /* setjmp() must be called in every function that calls a PNG-reading
     * libpng function */

    if (setjmp(png_ptr->jmpbuf)) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
        return 2;
    }


    if (!png_get_valid(png_ptr, info_ptr, PNG_INFO_bKGD))
        return 1;

    /* it is not obvious from the libpng documentation, but this function
     * takes a pointer to a pointer, and it always returns valid red, green
     * and blue values, regardless of color_type: */

    png_get_bKGD(png_ptr, info_ptr, &pBackground);


    /* however, it always returns the raw bKGD data, regardless of any
     * bit-depth transformations, so check depth and adjust if necessary */

    if (bit_depth == 16) {
        *red   = pBackground->red   >> 8;
        *green = pBackground->green >> 8;
        *blue  = pBackground->blue  >> 8;
    } else if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8) {
        if (bit_depth == 1)
            *red = *green = *blue = pBackground->gray? 255 : 0;
        else if (bit_depth == 2)
            *red = *green = *blue = (255/3) * pBackground->gray;
        else /* bit_depth == 4 */
            *red = *green = *blue = (255/15) * pBackground->gray;
    } else {
        *red   = (uch)pBackground->red;
        *green = (uch)pBackground->green;
        *blue  = (uch)pBackground->blue;
    }

    return 0;
}




/* display_exponent == LUT_exponent * CRT_exponent */

uch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes)
{
    double  gamma;
    png_uint_32  i, rowbytes;
    png_bytepp  row_pointers = NULL;


    /* setjmp() must be called in every function that calls a PNG-reading
     * libpng function */

    if (setjmp(png_ptr->jmpbuf)) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
        return NULL;
    }


    /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,
     * transparency chunks to full alpha channel; strip 16-bit-per-sample
     * images to 8 bits per sample; and convert grayscale to RGB[A] */

    if (color_type == PNG_COLOR_TYPE_PALETTE)
        png_set_expand(png_ptr);
    if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
        png_set_expand(png_ptr);
    if (png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
        png_set_expand(png_ptr);
    if (bit_depth == 16)
        png_set_strip_16(png_ptr);
    if (color_type == PNG_COLOR_TYPE_GRAY ||
        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
        png_set_gray_to_rgb(png_ptr);


    /* unlike the example in the libpng documentation, we have *no* idea where
     * this file may have come from--so if it doesn't have a file gamma, don't
     * do any correction ("do no harm") */

    if (png_get_gAMA(png_ptr, info_ptr, &gamma))
        png_set_gamma(png_ptr, display_exponent, gamma);


    /* all transformations have been registered; now update info_ptr data,
     * get rowbytes and channels, and allocate image memory */

    png_read_update_info(png_ptr, info_ptr);

    *pRowbytes = rowbytes = png_get_rowbytes(png_ptr, info_ptr);
    *pChannels = (int)png_get_channels(png_ptr, info_ptr);

    if ((image_data = (uch *)malloc(rowbytes*height)) == NULL) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
        return NULL;
    }
    if ((row_pointers = (png_bytepp)malloc(height*sizeof(png_bytep))) == NULL) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
        free(image_data);
        image_data = NULL;
        return NULL;
    }

    Trace((stderr, "readpng_get_image:  rowbytes = %ld, height = %ld\n", rowbytes, height));


    /* set the individual row_pointers to point at the correct offsets */

    for (i = 0;  i < height;  ++i)
        row_pointers[i] = image_data + i*rowbytes;


    /* now we can go ahead and just read the whole image */

    png_read_image(png_ptr, row_pointers);


    /* and we're done!  (png_read_end() can be omitted if no processing of
     * post-IDAT text/time/etc. is desired) */

    free(row_pointers);
    row_pointers = NULL;

    png_read_end(png_ptr, NULL);

    return image_data;
}


void readpng_cleanup(int free_image_data)
{
    if (free_image_data && image_data) {
        free(image_data);
        image_data = NULL;
    }

    if (png_ptr && info_ptr) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
        png_ptr = NULL;
        info_ptr = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\contrib\gregbook\readpng.h ===
/*---------------------------------------------------------------------------

   rpng - simple PNG display program                              readpng.h

  ---------------------------------------------------------------------------

      Copyright (c) 1998-1999 Greg Roelofs.  All rights reserved.

      This software is provided "as is," without warranty of any kind,
      express or implied.  In no event shall the author or contributors
      be held liable for any damages arising in any way from the use of
      this software.

      Permission is granted to anyone to use this software for any purpose,
      including commercial applications, and to alter it and redistribute
      it freely, subject to the following restrictions:

      1. Redistributions of source code must retain the above copyright
         notice, disclaimer, and this list of conditions.
      2. Redistributions in binary form must reproduce the above copyright
         notice, disclaimer, and this list of conditions in the documenta-
         tion and/or other materials provided with the distribution.
      3. All advertising materials mentioning features or use of this
         software must display the following acknowledgment:

            This product includes software developed by Greg Roelofs
            and contributors for the book, "PNG: The Definitive Guide,"
            published by O'Reilly and Associates.

  ---------------------------------------------------------------------------*/

#ifndef TRUE
#  define TRUE 1
#  define FALSE 0
#endif

#ifndef MAX
#  define MAX(a,b)  ((a) > (b)? (a) : (b))
#  define MIN(a,b)  ((a) < (b)? (a) : (b))
#endif

#ifdef DEBUG
#  define Trace(x)  {fprintf x ; fflush(stderr); fflush(stdout);}
#else
#  define Trace(x)  ;
#endif

typedef unsigned char   uch;
typedef unsigned short  ush;
typedef unsigned long   ulg;


/* prototypes for public functions in readpng.c */

void readpng_version_info(void);

int readpng_init(FILE *infile, long *pWidth, long *pHeight);

int readpng_get_bgcolor(uch *bg_red, uch *bg_green, uch *bg_blue);

uch *readpng_get_image(double display_exponent, int *pChannels,
                       ulg *pRowbytes);

void readpng_cleanup(int free_image_data);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\contrib\gregbook\rpng-x.c ===
/*---------------------------------------------------------------------------

   rpng - simple PNG display program                               rpng-x.c

   This program decodes and displays PNG images, with gamma correction and
   optionally with a user-specified background color (in case the image has
   transparency).  It is very nearly the most basic PNG viewer possible.
   This version is for the X Window System (tested under Unix, but may work
   under VMS or OS/2 with a little tweaking).

   to do:
    - 8-bit support
    - use %.1023s to simplify truncation of title-bar string?

  ---------------------------------------------------------------------------

      Copyright (c) 1998-1999 Greg Roelofs.  All rights reserved.

      This software is provided "as is," without warranty of any kind,
      express or implied.  In no event shall the author or contributors
      be held liable for any damages arising in any way from the use of
      this software.

      Permission is granted to anyone to use this software for any purpose,
      including commercial applications, and to alter it and redistribute
      it freely, subject to the following restrictions:

      1. Redistributions of source code must retain the above copyright
         notice, disclaimer, and this list of conditions.
      2. Redistributions in binary form must reproduce the above copyright
         notice, disclaimer, and this list of conditions in the documenta-
         tion and/or other materials provided with the distribution.
      3. All advertising materials mentioning features or use of this
         software must display the following acknowledgment:

            This product includes software developed by Greg Roelofs
            and contributors for the book, "PNG: The Definitive Guide,"
            published by O'Reilly and Associates.

  ---------------------------------------------------------------------------*/

#define PROGNAME  "rpng-x"
#define LONGNAME  "Simple PNG Viewer for X"
#define VERSION   "1.01 of 31 March 1999"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xos.h>
#include <X11/keysym.h>

/* #define DEBUG  :  this enables the Trace() macros */

#include "readpng.h"	/* typedefs, common macros, readpng prototypes */


/* could just include png.h, but this macro is the only thing we need
 * (name and typedefs changed to local versions); note that side effects 
 * only happen with alpha (which could easily be avoided with 
 * "ush acopy = (alpha);") */

#define alpha_composite(composite, fg, alpha, bg) {			\
    ush temp = ((ush)(fg)*(ush)(alpha) +				\
                (ush)(bg)*(ush)(255 - (ush)(alpha)) + (ush)128);	\
    (composite) = (uch)((temp + (temp >> 8)) >> 8);			\
}


/* local prototypes */
static int  rpng_x_create_window(void);
static int  rpng_x_display_image(void);
static void rpng_x_cleanup(void);
static int  rpng_x_msb(ulg u32val);


static char titlebar[1024], *window_name = titlebar;
static char *appname = LONGNAME;
static char *icon_name = PROGNAME;
static char *filename;
static FILE *infile;

static char *bgstr;
static uch bg_red=0, bg_green=0, bg_blue=0;

static double display_exponent;

static ulg image_width, image_height, image_rowbytes;
static int image_channels;
static uch *image_data;

/* X-specific variables */
static char *displayname;
static XImage *ximage;
static Display *display;
static int bitmap_order;
static int depth;
static Visual *visual;
static int RPixelShift, GPixelShift, BPixelShift;
static ulg RedMask, GreenMask, BlueMask;
static Window window;
static GC gc;
static Colormap colormap;

static int have_colormap = FALSE;
static int have_window = FALSE;
/*
ulg numcolors=0, pixels[256];
ush reds[256], greens[256], blues[256];
 */




int main(int argc, char **argv)
{
#ifdef sgi
    char tmpline[80];
#endif
    char *p;
    int rc, alen, flen;
    int error = 0;
    int have_bg = FALSE;
    double LUT_exponent;		/* just the lookup table */
    double CRT_exponent = 2.2;		/* just the monitor */
    double default_display_exponent;	/* whole display system */
    XEvent e;
    KeySym k;


    displayname = (char *)NULL;
    filename = (char *)NULL;


    /* First set the default value for our display-system exponent, i.e.,
     * the product of the CRT exponent and the exponent corresponding to
     * the frame-buffer's lookup table (LUT), if any.  This is not an
     * exhaustive list of LUT values (e.g., OpenStep has a lot of weird
     * ones), but it should cover 99% of the current possibilities. */

#if defined(NeXT)
    LUT_exponent = 1.0 / 2.2;
    /*
    if (some_next_function_that_returns_gamma(&next_gamma))
        LUT_exponent = 1.0 / next_gamma;
     */
#elif defined(sgi)
    LUT_exponent = 1.0 / 1.7;
    /* there doesn't seem to be any documented function to get the
     * "gamma" value, so we do it the hard way */
    infile = fopen("/etc/config/system.glGammaVal", "r");
    if (infile) {
        double sgi_gamma;

        fgets(tmpline, 80, infile);
        fclose(infile);
        sgi_gamma = atof(tmpline);
        if (sgi_gamma > 0.0)
            LUT_exponent = 1.0 / sgi_gamma;
    }
#elif defined(Macintosh)
    LUT_exponent = 1.8 / 2.61;
    /*
    if (some_mac_function_that_returns_gamma(&mac_gamma))
        LUT_exponent = mac_gamma / 2.61;
     */
#else
    LUT_exponent = 1.0;   /* assume no LUT:  most PCs */
#endif

    /* the defaults above give 1.0, 1.3, 1.5 and 2.2, respectively: */
    default_display_exponent = LUT_exponent * CRT_exponent;


    /* If the user has set the SCREEN_GAMMA environment variable as suggested
     * (somewhat imprecisely) in the libpng documentation, use that; otherwise
     * use the default value we just calculated.  Either way, the user may
     * override this via a command-line option. */

    if ((p = getenv("SCREEN_GAMMA")) != NULL)
        display_exponent = atof(p);
    else
        display_exponent = default_display_exponent;


    /* Now parse the command line for options and the PNG filename. */

    while (*++argv && !error) {
        if (!strcmp(*argv, "-display")) {
            if (!*++argv)
                ++error;
            displayname = *argv;
        } else if (!strcmp(*argv, "-gamma")) {
            if (!*++argv)
                ++error;
            display_exponent = atof(*argv);
            if (display_exponent <= 0.0)
                ++error;
        } else if (!strcmp(*argv, "-bgcolor")) {
            if (!*++argv)
                ++error;
            bgstr = *argv;
            if (strlen(bgstr) != 7 || bgstr[0] != '#')
                ++error;
            else
                have_bg = TRUE;
        } else {
            if (**argv != '-') {
                filename = *argv;
                if (argv[1])   /* shouldn't be any more args after filename */
                    ++error;
            } else
                ++error;   /* not expecting any other options */
        }
    }

    if (!filename) {
        ++error;
    } else if (!(infile = fopen(filename, "rb"))) {
        fprintf(stderr, PROGNAME ":  can't open PNG file [%s]\n", filename);
        ++error;
    } else {
        if ((rc = readpng_init(infile, &image_width, &image_height)) != 0) {
            switch (rc) {
                case 1:
                    fprintf(stderr, PROGNAME
                      ":  [%s] is not a PNG file: incorrect signature\n",
                      filename);
                    break;
                case 2:
                    fprintf(stderr, PROGNAME
                      ":  [%s] has bad IHDR (libpng longjmp)\n",
                      filename);
                    break;
                case 4:
                    fprintf(stderr, PROGNAME ":  insufficient memory\n");
                    break;
                default:
                    fprintf(stderr, PROGNAME
                      ":  unknown readpng_init() error\n");
                    break;
            }
            ++error;
        } else {
            display = XOpenDisplay(displayname);
            if (!display) {
                readpng_cleanup(TRUE);
                fprintf(stderr, PROGNAME ":  can't open X display [%s]\n",
                  displayname? displayname : "default");
                ++error;
            }
        }
        if (error)
            fclose(infile);
    }

    if (error) {
        fprintf(stderr, "\n%s %s:  %s\n", PROGNAME, VERSION, appname);
        readpng_version_info();
        fprintf(stderr, "\n"
         "Usage:  %s [-display xdpy] [-gamma exp] [-bgcolor bg] file.png\n"
         "    xdpy\tname of the target X display (e.g., ``hostname:0'')\n"
         "    exp \ttransfer-function exponent (``gamma'') of the display\n"
         "\t\t  system in floating-point format (e.g., ``%.1f''); equal\n"
         "\t\t  to the product of the lookup-table exponent (varies)\n"
         "\t\t  and the CRT exponent (usually 2.2); must be positive\n"
         "    bg  \tdesired background color in 7-character hex RGB format\n"
         "\t\t  (e.g., ``#ff7f00'' for orange:  same as HTML colors);\n"
         "\t\t  used with transparent images\n"
         "\nPress Q, Esc or mouse button 1 after image is displayed to quit.\n"
         "\n", PROGNAME, default_display_exponent);
        exit(1);
    }


    /* set the title-bar string, but make sure buffer doesn't overflow */

    alen = strlen(appname);
    flen = strlen(filename);
    if (alen + flen + 3 > 1023)
        sprintf(titlebar, "%s:  ...%s", appname, filename+(alen+flen+6-1023));
    else
        sprintf(titlebar, "%s:  %s", appname, filename);


    /* if the user didn't specify a background color on the command line,
     * check for one in the PNG file--if not, the initialized values of 0
     * (black) will be used */

    if (have_bg) {
        unsigned r, g, b;   /* this approach quiets compiler warnings */

        sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b);
        bg_red   = (uch)r;
        bg_green = (uch)g;
        bg_blue  = (uch)b;
    } else if (readpng_get_bgcolor(&bg_red, &bg_green, &bg_blue) > 1) {
        readpng_cleanup(TRUE);
        fprintf(stderr, PROGNAME
          ":  libpng error while checking for background color\n");
        exit(2);
    }


    /* do the basic X initialization stuff, make the window and fill it
     * with the background color */

    if (rpng_x_create_window())
        exit(2);


    /* decode the image, all at once */

    Trace((stderr, "calling readpng_get_image()\n"))
    image_data = readpng_get_image(display_exponent, &image_channels,
      &image_rowbytes);
    Trace((stderr, "done with readpng_get_image()\n"))


    /* done with PNG file, so clean up to minimize memory usage (but do NOT
     * nuke image_data!) */

    readpng_cleanup(FALSE);
    fclose(infile);

    if (!image_data) {
        fprintf(stderr, PROGNAME ":  unable to decode PNG image\n");
        exit(3);
    }


    /* display image (composite with background if requested) */

    Trace((stderr, "calling rpng_x_display_image()\n"))
    if (rpng_x_display_image()) {
        free(image_data);
        exit(4);
    }
    Trace((stderr, "done with rpng_x_display_image()\n"))


    /* wait for the user to tell us when to quit */

    do
        XNextEvent(display, &e);
    while (!(e.type == ButtonPress && e.xbutton.button == Button1) &&
           !(e.type == KeyPress &&    /*  v--- or 1 for shifted keys */
             ((k = XLookupKeysym(&e.xkey, 0)) == XK_q || k == XK_Escape) ));


    /* OK, we're done:  clean up all image and X resources and go away */

    rpng_x_cleanup();

    return 0;
}





static int rpng_x_create_window()
{
    uch *xdata;
    int screen, pad;
    ulg bg_pixel = 0L;
    Window root;
    XEvent e;
    XGCValues gcvalues;
    XSetWindowAttributes attr;
    XSizeHints *size_hints;
    XTextProperty windowName, *pWindowName = &windowName;
    XTextProperty iconName, *pIconName = &iconName;
    XVisualInfo visual_info;
    XWMHints *wm_hints;


    bitmap_order = BitmapBitOrder(display);
    screen = DefaultScreen(display);
    depth = DisplayPlanes(display, screen);
    root = RootWindow(display, screen);

/* GRR:  add 8-bit support */
    if (/* depth != 8 && */ depth != 16 && depth != 24 && depth != 32) {
        fprintf(stderr,
          "screen depth %d not supported (only 16-, 24- or 32-bit TrueColor)\n",
          depth);
        return 2;
    }

    XMatchVisualInfo(display, screen, depth,
      (depth == 8)? PseudoColor : TrueColor, &visual_info);
    visual = visual_info.visual;

    RedMask   = visual->red_mask;
    GreenMask = visual->green_mask;
    BlueMask  = visual->blue_mask;

/* GRR:  add/check 8-bit support */
    if (depth == 8) {
        colormap = XCreateColormap(display, root, visual, AllocNone);
        if (!colormap) {
            fprintf(stderr, "XCreateColormap() failed\n");
            return 2;
        }
        have_colormap = TRUE;
    } else if (depth == 16) {
        RPixelShift = 15 - rpng_x_msb(RedMask);	/* these are right-shifts */
        GPixelShift = 15 - rpng_x_msb(GreenMask);
        BPixelShift = 15 - rpng_x_msb(BlueMask);
    } else /* if (depth > 16) */ {
        RPixelShift = rpng_x_msb(RedMask) - 7;	/* these are left-shifts */
        GPixelShift = rpng_x_msb(GreenMask) - 7;
        BPixelShift = rpng_x_msb(BlueMask) - 7;
    }

/*---------------------------------------------------------------------------
    Finally, create the window.
  ---------------------------------------------------------------------------*/

    attr.backing_store = Always;
    attr.event_mask = ExposureMask | KeyPressMask | ButtonPressMask;

    window = XCreateWindow(display, root, 0, 0, image_width, image_height,
      0, depth, InputOutput, visual, CWBackingStore | CWEventMask, &attr);

    if (window == None) {
        fprintf(stderr, "XCreateWindow() failed\n");
        return 2;
    } else
        have_window = TRUE;

    if (depth == 8)
        XSetWindowColormap(display, window, colormap);

    if (!XStringListToTextProperty(&window_name, 1, pWindowName))
        pWindowName = NULL;
    if (!XStringListToTextProperty(&icon_name, 1, pIconName))
        pIconName = NULL;

    /* OK if either hints allocation fails; XSetWMProperties() allows NULLs */

    if ((size_hints = XAllocSizeHints()) != NULL) {
        /* window will not be resizable */
        size_hints->flags = PMinSize | PMaxSize;
        size_hints->min_width = size_hints->max_width = image_width;
        size_hints->min_height = size_hints->max_height = image_height;
    }

    if ((wm_hints = XAllocWMHints()) != NULL) {
        wm_hints->initial_state = NormalState;
        wm_hints->input = True;
     /* wm_hints->icon_pixmap = icon_pixmap; */
        wm_hints->flags = StateHint | InputHint  /* | IconPixmapHint */ ;
    }

    XSetWMProperties(display, window, pWindowName, pIconName, NULL, 0,
      size_hints, wm_hints, NULL);

    XMapWindow(display, window);

    gc = XCreateGC(display, window, 0, &gcvalues);

/*---------------------------------------------------------------------------
    Fill window with the specified background color.
  ---------------------------------------------------------------------------*/

    if (depth == 24 || depth == 32) {
        bg_pixel = ((ulg)bg_red   << RPixelShift) |
                   ((ulg)bg_green << GPixelShift) |
                   ((ulg)bg_blue  << BPixelShift);
    } else if (depth == 16) {
        bg_pixel = ((((ulg)bg_red   << 8) >> RPixelShift) & RedMask)   |
                   ((((ulg)bg_green << 8) >> GPixelShift) & GreenMask) |
                   ((((ulg)bg_blue  << 8) >> BPixelShift) & BlueMask);
    } else /* depth == 8 */ {

        /* GRR:  add 8-bit support */

    }

    XSetForeground(display, gc, bg_pixel);
    XFillRectangle(display, window, gc, 0, 0, image_width, image_height);

/*---------------------------------------------------------------------------
    Wait for first Expose event to do any drawing, then flush.
  ---------------------------------------------------------------------------*/

    do
        XNextEvent(display, &e);
    while (e.type != Expose || e.xexpose.count);

    XFlush(display);

/*---------------------------------------------------------------------------
    Allocate memory for the X- and display-specific version of the image.
  ---------------------------------------------------------------------------*/

    if (depth == 24 || depth == 32) {
        xdata = (uch *)malloc(4*image_width*image_height);
        pad = 32;
    } else if (depth == 16) {
        xdata = (uch *)malloc(2*image_width*image_height);
        pad = 16;
    } else /* depth == 8 */ {
        xdata = (uch *)malloc(image_width*image_height);
        pad = 8;
    }

    if (!xdata) {
        fprintf(stderr, PROGNAME ":  unable to allocate image memory\n");
        return 4;
    }

    ximage = XCreateImage(display, visual, depth, ZPixmap, 0,
      (char *)xdata, image_width, image_height, pad, 0);

    if (!ximage) {
        fprintf(stderr, PROGNAME ":  XCreateImage() failed\n");
        free(xdata);
        return 3;
    }

    /* to avoid testing the bitmap_order every pixel (or doubling the size of
     * the drawing routine with a giant if-test), we arbitrarily set the byte
     * order to MSBFirst and let Xlib worry about inverting things on little-
     * endian machines (like Linux/x86, old VAXen, etc.)--this is not the most
     * efficient approach (the giant if-test would be better), but in the
     * interest of clarity, we take the easy way out... */

    ximage->byte_order = MSBFirst;

    return 0;

} /* end function rpng_x_create_window() */





static int rpng_x_display_image()
{
    uch *src, *dest;
    uch r, g, b, a;
    int ximage_rowbytes = ximage->bytes_per_line;
    ulg i, row, lastrow = 0;
    ulg pixel;


    Trace((stderr, "beginning display loop (image_channels == %d)\n",
      image_channels))
    Trace((stderr, "(width = %ld, rowbytes = %ld, ximage_rowbytes = %d)\n",
      image_width, image_rowbytes, ximage_rowbytes))

    if (depth == 24 || depth == 32) {
        ulg red, green, blue;

        for (lastrow = row = 0;  row < image_height;  ++row) {
            src = image_data + row*image_rowbytes;
            dest = ximage->data + row*ximage_rowbytes;
            if (image_channels == 3) {
                for (i = image_width;  i > 0;  --i) {
                    red   = *src++;
                    green = *src++;
                    blue  = *src++;
                    pixel = (red   << RPixelShift) |
                            (green << GPixelShift) |
                            (blue  << BPixelShift);
                    /* recall that we set ximage->byte_order = MSBFirst above */
                    *dest++ = ((uch *)&pixel)[3];
                    *dest++ = ((uch *)&pixel)[2];
                    *dest++ = ((uch *)&pixel)[1];
                    *dest++ = ((uch *)&pixel)[0];
                }
            } else /* if (image_channels == 4) */ {
                for (i = image_width;  i > 0;  --i) {
                    r = *src++;
                    g = *src++;
                    b = *src++;
                    a = *src++;
                    if (a == 255) {
                        red   = r;
                        green = g;
                        blue  = b;
                    } else if (a == 0) {
                        red   = bg_red;
                        green = bg_green;
                        blue  = bg_blue;
                    } else {
                        /* this macro (from png.h) composites the foreground
                         * and background values and puts the result into the
                         * first argument */
                        alpha_composite(red,   r, a, bg_red);
                        alpha_composite(green, g, a, bg_green);
                        alpha_composite(blue,  b, a, bg_blue);
                    }
                    pixel = (red   << RPixelShift) |
                            (green << GPixelShift) |
                            (blue  << BPixelShift);
                    /* recall that we set ximage->byte_order = MSBFirst above */
                    *dest++ = ((uch *)&pixel)[3];
                    *dest++ = ((uch *)&pixel)[2];
                    *dest++ = ((uch *)&pixel)[1];
                    *dest++ = ((uch *)&pixel)[0];
                }
            }
            /* display after every 16 lines */
            if (((row+1) & 0xf) == 0) {
                XPutImage(display, window, gc, ximage, 0, lastrow, 0, lastrow,
                  image_width, 16);
                XFlush(display);
                lastrow = row + 1;
            }
        }

    } else if (depth == 16) {
        ush red, green, blue;

        for (lastrow = row = 0;  row < image_height;  ++row) {
            src = image_data + row*image_rowbytes;
            dest = ximage->data + row*ximage_rowbytes;
            if (image_channels == 3) {
                for (i = image_width;  i > 0;  --i) {
                    red   = ((ush)(*src) << 8);
                    ++src;
                    green = ((ush)(*src) << 8);
                    ++src;
                    blue  = ((ush)(*src) << 8);
                    ++src;
                    pixel = ((red   >> RPixelShift) & RedMask)   |
                            ((green >> GPixelShift) & GreenMask) |
                            ((blue  >> BPixelShift) & BlueMask);
                    /* recall that we set ximage->byte_order = MSBFirst above */
                    *dest++ = ((uch *)&pixel)[1];
                    *dest++ = ((uch *)&pixel)[0];
                }
            } else /* if (image_channels == 4) */ {
                for (i = image_width;  i > 0;  --i) {
                    r = *src++;
                    g = *src++;
                    b = *src++;
                    a = *src++;
                    if (a == 255) {
                        red   = ((ush)r << 8);
                        green = ((ush)g << 8);
                        blue  = ((ush)b << 8);
                    } else if (a == 0) {
                        red   = ((ush)bg_red   << 8);
                        green = ((ush)bg_green << 8);
                        blue  = ((ush)bg_blue  << 8);
                    } else {
                        /* this macro (from png.h) composites the foreground
                         * and background values and puts the result back into
                         * the first argument (== fg byte here:  safe) */
                        alpha_composite(r, r, a, bg_red);
                        alpha_composite(g, g, a, bg_green);
                        alpha_composite(b, b, a, bg_blue);
                        red   = ((ush)r << 8);
                        green = ((ush)g << 8);
                        blue  = ((ush)b << 8);
                    }
                    pixel = ((red   >> RPixelShift) & RedMask)   |
                            ((green >> GPixelShift) & GreenMask) |
                            ((blue  >> BPixelShift) & BlueMask);
                    /* recall that we set ximage->byte_order = MSBFirst above */
                    *dest++ = ((uch *)&pixel)[1];
                    *dest++ = ((uch *)&pixel)[0];
                }
            }
            /* display after every 16 lines */
            if (((row+1) & 0xf) == 0) {
                XPutImage(display, window, gc, ximage, 0, lastrow, 0, lastrow,
                  image_width, 16);
                XFlush(display);
                lastrow = row + 1;
            }
        }

    } else /* depth == 8 */ {

        /* GRR:  add 8-bit support */

    }

    Trace((stderr, "calling final XPutImage()\n"))
    if (lastrow < image_height) {
        XPutImage(display, window, gc, ximage, 0, lastrow, 0, lastrow,
          image_width, image_height-lastrow);
        XFlush(display);
    }

    return 0;
}




static void rpng_x_cleanup()
{
    if (image_data) {
        free(image_data);
        image_data = NULL;
    }

    if (ximage) {
        if (ximage->data) {
            free(ximage->data);           /* we allocated it, so we free it */
            ximage->data = (char *)NULL;  /*  instead of XDestroyImage() */
        }
        XDestroyImage(ximage);
        ximage = NULL;
    }

    XFreeGC(display, gc);

    if (have_window)
        XDestroyWindow(display, window);

    if (have_colormap)
        XFreeColormap(display, colormap);
}





static int rpng_x_msb(ulg u32val)
{
    int i;

    for (i = 31;  i >= 0;  --i) {
        if (u32val & 0x80000000L)
            break;
        u32val <<= 1;
    }
    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\contrib\gregbook\rpng-win.c ===
/*---------------------------------------------------------------------------

   rpng - simple PNG display program                             rpng-win.c

   This program decodes and displays PNG images, with gamma correction and
   optionally with a user-specified background color (in case the image has
   transparency).  It is very nearly the most basic PNG viewer possible.
   This version is for 32-bit Windows; it may compile under 16-bit Windows
   with a little tweaking (or maybe not).

   to do:
    - stdout/stderr don't work!  need message window (maybe scrollable?)
    - handle quoted command-line args (especially filenames with spaces)
    - have minimum window width:  oh well
    - use %.1023s to simplify truncation of title-bar string?

  ---------------------------------------------------------------------------

      Copyright (c) 1998-1999 Greg Roelofs.  All rights reserved.

      This software is provided "as is," without warranty of any kind,
      express or implied.  In no event shall the author or contributors
      be held liable for any damages arising in any way from the use of
      this software.

      Permission is granted to anyone to use this software for any purpose,
      including commercial applications, and to alter it and redistribute
      it freely, subject to the following restrictions:

      1. Redistributions of source code must retain the above copyright
         notice, disclaimer, and this list of conditions.
      2. Redistributions in binary form must reproduce the above copyright
         notice, disclaimer, and this list of conditions in the documenta-
         tion and/or other materials provided with the distribution.
      3. All advertising materials mentioning features or use of this
         software must display the following acknowledgment:

            This product includes software developed by Greg Roelofs
            and contributors for the book, "PNG: The Definitive Guide,"
            published by O'Reilly and Associates.

  ---------------------------------------------------------------------------*/

#define PROGNAME  "rpng-win"
#define LONGNAME  "Simple PNG Viewer for Windows"
#define VERSION   "1.0 of 20 February 1999"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <windows.h>

/* #define DEBUG  :  this enables the Trace() macros */

#include "readpng.h"	/* typedefs, common macros, readpng prototypes */


/* could just include png.h, but this macro is the only thing we need
 * (name and typedefs changed to local versions); note that side effects
 * only happen with alpha (which could easily be avoided with
 * "ush acopy = (alpha);") */

#define alpha_composite(composite, fg, alpha, bg) {			\
    ush temp = ((ush)(fg)*(ush)(alpha) +				\
                (ush)(bg)*(ush)(255 - (ush)(alpha)) + (ush)128);	\
    (composite) = (uch)((temp + (temp >> 8)) >> 8);			\
}


/* local prototypes */
static int        rpng_win_create_window(HINSTANCE hInst, int showmode);
static int        rpng_win_display_image(void);
static void       rpng_win_cleanup(void);
LRESULT CALLBACK  rpng_win_wndproc(HWND, UINT, WPARAM, LPARAM);


static char titlebar[1024], *window_name = titlebar;
static char *progname = PROGNAME;
static char *appname = LONGNAME;
static char *icon_name = PROGNAME;	/* GRR:  not (yet) used */
static char *filename;
static FILE *infile;

static char *bgstr;
static uch bg_red=0, bg_green=0, bg_blue=0;

static double display_exponent;

static ulg image_width, image_height, image_rowbytes;
static int image_channels;
static uch *image_data;

/* Windows-specific variables */
static ulg wimage_rowbytes;
static uch *dib;
static uch *wimage_data;
static BITMAPINFOHEADER *bmih;

static HWND global_hwnd;




int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, PSTR cmd, int showmode)
{
    char *args[1024];		/* arbitrary limit, but should suffice */
    char *p, *q, **argv = args;
    int argc = 0;
    int rc, alen, flen;
    int error = 0;
    int have_bg = FALSE;
    double LUT_exponent;		/* just the lookup table */
    double CRT_exponent = 2.2;		/* just the monitor */
    double default_display_exponent;	/* whole display system */
    MSG msg;


    filename = (char *)NULL;


    /* First set the default value for our display-system exponent, i.e.,
     * the product of the CRT exponent and the exponent corresponding to
     * the frame-buffer's lookup table (LUT), if any.  This is not an
     * exhaustive list of LUT values (e.g., OpenStep has a lot of weird
     * ones), but it should cover 99% of the current possibilities.  And
     * yes, these ifdefs are completely wasted in a Windows program... */

#if defined(NeXT)
    LUT_exponent = 1.0 / 2.2;
    /*
    if (some_next_function_that_returns_gamma(&next_gamma))
        LUT_exponent = 1.0 / next_gamma;
     */
#elif defined(sgi)
    LUT_exponent = 1.0 / 1.7;
    /* there doesn't seem to be any documented function to get the
     * "gamma" value, so we do it the hard way */
    infile = fopen("/etc/config/system.glGammaVal", "r");
    if (infile) {
        double sgi_gamma;

        fgets(tmpline, 80, infile);
        fclose(infile);
        sgi_gamma = atof(tmpline);
        if (sgi_gamma > 0.0)
            LUT_exponent = 1.0 / sgi_gamma;
    }
#elif defined(Macintosh)
    LUT_exponent = 1.8 / 2.61;
    /*
    if (some_mac_function_that_returns_gamma(&mac_gamma))
        LUT_exponent = mac_gamma / 2.61;                 
     */
#else
    LUT_exponent = 1.0;   /* assume no LUT:  most PCs */
#endif

    /* the defaults above give 1.0, 1.3, 1.5 and 2.2, respectively: */
    default_display_exponent = LUT_exponent * CRT_exponent;


    /* If the user has set the SCREEN_GAMMA environment variable as suggested
     * (somewhat imprecisely) in the libpng documentation, use that; otherwise
     * use the default value we just calculated.  Either way, the user may
     * override this via a command-line option. */

    if ((p = getenv("SCREEN_GAMMA")) != NULL)
        display_exponent = atof(p);
    else
        display_exponent = default_display_exponent;


    /* Windows really hates command lines, so we have to set up our own argv.
     * Note that we do NOT bother with quoted arguments here, so don't use
     * filenames with spaces in 'em! */

    argv[argc++] = PROGNAME;
    p = cmd;
    for (;;) {
        if (*p == ' ')
            while (*++p == ' ')
                ;
        /* now p points at the first non-space after some spaces */
        if (*p == '\0')
            break;    /* nothing after the spaces:  done */
        argv[argc++] = q = p;
        while (*q && *q != ' ')
            ++q;
        /* now q points at a space or the end of the string */
        if (*q == '\0')
            break;    /* last argv already terminated; quit */
        *q = '\0';    /* change space to terminator */
        p = q + 1;
    }
    argv[argc] = NULL;   /* terminate the argv array itself */


    /* Now parse the command line for options and the PNG filename. */

    while (*++argv && !error) {
        if (!strcmp(*argv, "-gamma")) {
            if (!*++argv)
                ++error;
            display_exponent = atof(*argv);
            if (display_exponent <= 0.0)
                ++error;
        } else if (!strcmp(*argv, "-bgcolor")) {
            if (!*++argv)
                ++error;
            bgstr = *argv;
            if (strlen(bgstr) != 7 || bgstr[0] != '#')
                ++error;
            else
                have_bg = TRUE;
        } else {
            if (**argv != '-') {
                filename = *argv;
                if (argv[1])   /* shouldn't be any more args after filename */
                    ++error;
            } else
                ++error;   /* not expecting any other options */
        }
    }

    if (!filename) {
        ++error;
    } else if (!(infile = fopen(filename, "rb"))) {
        fprintf(stderr, PROGNAME ":  can't open PNG file [%s]\n", filename);
        ++error;
    } else {
        if ((rc = readpng_init(infile, &image_width, &image_height)) != 0) {
            switch (rc) {
                case 1:
                    fprintf(stderr, PROGNAME
                      ":  [%s] is not a PNG file: incorrect signature\n",
                      filename);
                    break;
                case 2:
                    fprintf(stderr, PROGNAME
                      ":  [%s] has bad IHDR (libpng longjmp)\n",
                      filename);
                    break;
                case 4:
                    fprintf(stderr, PROGNAME ":  insufficient memory\n");
                    break;
                default:
                    fprintf(stderr, PROGNAME
                      ":  unknown readpng_init() error\n");
                    break;
            }
            ++error;
        }
        if (error)
            fclose(infile);
    }

    if (error) {
        fprintf(stderr, "\n%s %s:  %s\n", PROGNAME, VERSION, appname);
        readpng_version_info();
        fprintf(stderr, "\n"
         "Usage:  %s [-gamma exp] [-bgcolor bg] file.png\n"
         "    exp \ttransfer-function exponent (``gamma'') of the display\n"
         "\t\t  system in floating-point format (e.g., ``%.1f''); equal\n"
         "\t\t  to the product of the lookup-table exponent (varies)\n"
         "\t\t  and the CRT exponent (usually 2.2); must be positive\n"
         "    bg  \tdesired background color in 7-character hex RGB format\n"
         "\t\t  (e.g., ``#ff7f00'' for orange:  same as HTML colors);\n"
         "\t\t  used with transparent images\n"
         "\nPress Q, Esc or mouse button 1 after image is displayed to quit.\n"
         "\n", PROGNAME, default_display_exponent);
        exit(1);
    }


    /* set the title-bar string, but make sure buffer doesn't overflow */

    alen = strlen(appname);
    flen = strlen(filename);
    if (alen + flen + 3 > 1023)
        sprintf(titlebar, "%s:  ...%s", appname, filename+(alen+flen+6-1023));
    else
        sprintf(titlebar, "%s:  %s", appname, filename);


    /* if the user didn't specify a background color on the command line,
     * check for one in the PNG file--if not, the initialized values of 0
     * (black) will be used */

    if (have_bg)
        sscanf(bgstr+1, "%2x%2x%2x", &bg_red, &bg_green, &bg_blue);
    else if (readpng_get_bgcolor(&bg_red, &bg_green, &bg_blue) > 1) {
        readpng_cleanup(TRUE);
        fprintf(stderr, PROGNAME
          ":  libpng error while checking for background color\n");
        exit(2);
    }


    /* do the basic Windows initialization stuff, make the window and fill it
     * with the background color */

    if (rpng_win_create_window(hInst, showmode))
        exit(2);


    /* decode the image, all at once */

    Trace((stderr, "calling readpng_get_image()\n"))
    image_data = readpng_get_image(display_exponent, &image_channels,
      &image_rowbytes);
    Trace((stderr, "done with readpng_get_image()\n"))


    /* done with PNG file, so clean up to minimize memory usage (but do NOT
     * nuke image_data!) */

    readpng_cleanup(FALSE);
    fclose(infile);

    if (!image_data) {
        fprintf(stderr, PROGNAME ":  unable to decode PNG image\n");
        exit(3);
    }


    /* display image (composite with background if requested) */

    Trace((stderr, "calling rpng_win_display_image()\n"))
    if (rpng_win_display_image()) {
        free(image_data);
        exit(4);
    }
    Trace((stderr, "done with rpng_win_display_image()\n"))


    /* wait for the user to tell us when to quit */

    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }


    /* OK, we're done:  clean up all image and Windows resources and go away */

    rpng_win_cleanup();

    return msg.wParam;
}





static int rpng_win_create_window(HINSTANCE hInst, int showmode)
{
    uch *dest;
    int extra_width, extra_height;
    ulg i, j;
    WNDCLASSEX wndclass;


/*---------------------------------------------------------------------------
    Allocate memory for the display-specific version of the image (round up
    to multiple of 4 for Windows DIB).
  ---------------------------------------------------------------------------*/

    wimage_rowbytes = ((3*image_width + 3L) >> 2) << 2;

    if (!(dib = (uch *)malloc(sizeof(BITMAPINFOHEADER) +
                              wimage_rowbytes*image_height)))
    {
        return 4;	/* fail */
    }

/*---------------------------------------------------------------------------
    Initialize the DIB.  Negative height means to use top-down BMP ordering
    (must be uncompressed, but that's what we want).  Bit count of 1, 4 or 8
    implies a colormap of RGBX quads, but 24-bit BMPs just use B,G,R values
    directly => wimage_data begins immediately after BMP header.
  ---------------------------------------------------------------------------*/

    memset(dib, 0, sizeof(BITMAPINFOHEADER));
    bmih = (BITMAPINFOHEADER *)dib;
    bmih->biSize = sizeof(BITMAPINFOHEADER);
    bmih->biWidth = image_width;
    bmih->biHeight = -((long)image_height);
    bmih->biPlanes = 1;
    bmih->biBitCount = 24;
    bmih->biCompression = 0;
    wimage_data = dib + sizeof(BITMAPINFOHEADER);

/*---------------------------------------------------------------------------
    Fill in background color (black by default); data are in BGR order.
  ---------------------------------------------------------------------------*/

    for (j = 0;  j < image_height;  ++j) {
        dest = wimage_data + j*wimage_rowbytes;
        for (i = image_width;  i > 0;  --i) {
            *dest++ = bg_blue;
            *dest++ = bg_green;
            *dest++ = bg_red;
        }
    }

/*---------------------------------------------------------------------------
    Set the window parameters.
  ---------------------------------------------------------------------------*/

    memset(&wndclass, 0, sizeof(wndclass));

    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = rpng_win_wndproc;
    wndclass.hInstance = hInst;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(DKGRAY_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = progname;
    wndclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

    RegisterClassEx(&wndclass);

/*---------------------------------------------------------------------------
    Finally, create the window.
  ---------------------------------------------------------------------------*/

    extra_width  = 2*(GetSystemMetrics(SM_CXBORDER) +
                      GetSystemMetrics(SM_CXDLGFRAME));
    extra_height = 2*(GetSystemMetrics(SM_CYBORDER) +
                      GetSystemMetrics(SM_CYDLGFRAME)) +
                      GetSystemMetrics(SM_CYCAPTION);

    global_hwnd = CreateWindow(progname, titlebar, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, CW_USEDEFAULT, image_width+extra_width,
      image_height+extra_height, NULL, NULL, hInst, NULL);

    ShowWindow(global_hwnd, showmode);
    UpdateWindow(global_hwnd);

    return 0;

} /* end function rpng_win_create_window() */





static int rpng_win_display_image()
{
    uch *src, *dest;
    uch r, g, b, a;
    ulg i, row, lastrow;
    RECT rect;


    Trace((stderr, "beginning display loop (image_channels == %d)\n",
      image_channels))
    Trace((stderr, "(width = %ld, rowbytes = %ld, wimage_rowbytes = %d)\n",
      image_width, image_rowbytes, wimage_rowbytes))


/*---------------------------------------------------------------------------
    Blast image data to buffer.  This whole routine takes place before the
    message loop begins, so there's no real point in any pseudo-progressive
    display...
  ---------------------------------------------------------------------------*/

    for (lastrow = row = 0;  row < image_height;  ++row) {
        src = image_data + row*image_rowbytes;
        dest = wimage_data + row*wimage_rowbytes;
        if (image_channels == 3) {
            for (i = image_width;  i > 0;  --i) {
                r = *src++;
                g = *src++;
                b = *src++;
                *dest++ = b;
                *dest++ = g;	/* note reverse order */
                *dest++ = r;
            }
        } else /* if (image_channels == 4) */ {
            for (i = image_width;  i > 0;  --i) {
                r = *src++;
                g = *src++;
                b = *src++;
                a = *src++;
                if (a == 255) {
                    *dest++ = b;
                    *dest++ = g;
                    *dest++ = r;
                } else if (a == 0) {
                    *dest++ = bg_blue;
                    *dest++ = bg_green;
                    *dest++ = bg_red;
                } else {
                    /* this macro (copied from png.h) composites the
                     * foreground and background values and puts the
                     * result into the first argument; there are no
                     * side effects with the first argument */
                    alpha_composite(*dest++, b, a, bg_blue);
                    alpha_composite(*dest++, g, a, bg_green);
                    alpha_composite(*dest++, r, a, bg_red);
                }
            }
        }
        /* display after every 16 lines */
        if (((row+1) & 0xf) == 0) {
            rect.left = 0L;
            rect.top = (LONG)lastrow;
            rect.right = (LONG)image_width;      /* possibly off by one? */
            rect.bottom = (LONG)lastrow + 16L;   /* possibly off by one? */
            InvalidateRect(global_hwnd, &rect, FALSE);
            UpdateWindow(global_hwnd);     /* similar to XFlush() */
            lastrow = row + 1;
        }
    }

    Trace((stderr, "calling final image-flush routine\n"))
    if (lastrow < image_height) {
        rect.left = 0L;
        rect.top = (LONG)lastrow;
        rect.right = (LONG)image_width;      /* possibly off by one? */
        rect.bottom = (LONG)image_height;    /* possibly off by one? */
        InvalidateRect(global_hwnd, &rect, FALSE);
        UpdateWindow(global_hwnd);     /* similar to XFlush() */
    }

/*
    last param determines whether or not background is wiped before paint
    InvalidateRect(global_hwnd, NULL, TRUE);
    UpdateWindow(global_hwnd);
 */

    return 0;
}





static void rpng_win_cleanup()
{
    if (image_data) {
        free(image_data);
        image_data = NULL;
    }

    if (dib) {
        free(dib);
        dib = NULL;
    }
}





LRESULT CALLBACK rpng_win_wndproc(HWND hwnd, UINT iMsg, WPARAM wP, LPARAM lP)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    int rc;

    switch (iMsg) {
        case WM_CREATE:
            /* one-time processing here, if any */
            return 0;

        case WM_PAINT:
            hdc = BeginPaint(hwnd, &ps);
                    /*                    dest                          */
            rc = StretchDIBits(hdc, 0, 0, image_width, image_height,
                    /*                    source                        */
                                    0, 0, image_width, image_height,
                                    wimage_data, (BITMAPINFO *)bmih,
                    /*              iUsage: no clue                     */
                                    0, SRCCOPY);
            EndPaint(hwnd, &ps);
            return 0;

        /* wait for the user to tell us when to quit */
        case WM_CHAR:
            switch (wP) {	/* only need one, so ignore repeat count */
                case 'q':
                case 'Q':
                case 0x1B:	/* Esc key */
                    PostQuitMessage(0);
            }
            return 0;

        case WM_LBUTTONDOWN:	/* another way of quitting */
        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProc(hwnd, iMsg, wP, lP);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\contrib\gregbook\rpng2-win.c ===
/*---------------------------------------------------------------------------

   rpng2 - progressive-model PNG display program                rpng2-win.c 

   This program decodes and displays PNG files progressively, as if it were
   a web browser (though the front end is only set up to read from files).
   It supports gamma correction, user-specified background colors, and user-
   specified background patterns (for transparent images).  This version is
   for 32-bit Windows; it may compile under 16-bit Windows with a little
   tweaking (or maybe not).  Thanks to Adam Costello and Pieter S. van der
   Meulen for the "diamond" and "radial waves" patterns, respectively.

   to do:
    - stdout/stderr don't work!  need message window (maybe scrollable?)
    - handle quoted command-line args (especially filenames with spaces)
    - finish resizable checkerboard-gradient (sizes 4-128?)
    - use %.1023s to simplify truncation of title-bar string?
    - have minimum window width:  oh well

  ---------------------------------------------------------------------------

   Changelog:
    - 1.01:  initial public release
    - 1.02:  fixed cut-and-paste error in usage screen (oops...)

  ---------------------------------------------------------------------------

      Copyright (c) 1998-1999 Greg Roelofs.  All rights reserved.

      This software is provided "as is," without warranty of any kind,
      express or implied.  In no event shall the author or contributors
      be held liable for any damages arising in any way from the use of
      this software.

      Permission is granted to anyone to use this software for any purpose,
      including commercial applications, and to alter it and redistribute
      it freely, subject to the following restrictions:

      1. Redistributions of source code must retain the above copyright
         notice, disclaimer, and this list of conditions.
      2. Redistributions in binary form must reproduce the above copyright
         notice, disclaimer, and this list of conditions in the documenta-
         tion and/or other materials provided with the distribution.
      3. All advertising materials mentioning features or use of this
         software must display the following acknowledgment:

            This product includes software developed by Greg Roelofs
            and contributors for the book, "PNG: The Definitive Guide,"
            published by O'Reilly and Associates.

  ---------------------------------------------------------------------------*/

#define PROGNAME  "rpng2-win"
#define LONGNAME  "Progressive PNG Viewer for Windows"
#define VERSION   "1.02 of 22 September 1999"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>	/* for jmpbuf declaration in readpng2.h */
#include <time.h>
#include <math.h>	/* only for PvdM background code */
#include <windows.h>

/* all for PvdM background code: */
#ifndef PI
#  define PI             3.141592653589793238
#endif
#define PI_2             (PI*0.5)
#define INV_PI_360       (360.0 / PI)
#define MAX(a,b)         (a>b?a:b)
#define MIN(a,b)         (a<b?a:b)
#define CLIP(a,min,max)  MAX(min,MIN((a),max))
#define ABS(a)           ((a)<0?-(a):(a))
#define CLIP8P(c)        MAX(0,(MIN((c),255)))   /* 8-bit pos. integer (uch) */
#define ROUNDF(f)        ((int)(f + 0.5))

#define rgb1_max   bg_freq
#define rgb1_min   bg_gray
#define rgb2_max   bg_bsat
#define rgb2_min   bg_brot

/* #define DEBUG */	/* this enables the Trace() macros */

#include "readpng2.h"	/* typedefs, common macros, readpng2 prototypes */


/* could just include png.h, but this macro is the only thing we need
 * (name and typedefs changed to local versions); note that side effects
 * only happen with alpha (which could easily be avoided with
 * "ush acopy = (alpha);") */

#define alpha_composite(composite, fg, alpha, bg) {			\
    ush temp = ((ush)(fg)*(ush)(alpha) +				\
                (ush)(bg)*(ush)(255 - (ush)(alpha)) + (ush)128);	\
    (composite) = (uch)((temp + (temp >> 8)) >> 8);			\
}


#define INBUFSIZE 4096	/* with pseudo-timing on (1 sec delay/block), this
			 *  block size corresponds roughly to a download
			 *  speed 10% faster than theoretical 33.6K maximum
			 *  (assuming 8 data bits, 1 stop bit and no other
			 *  overhead) */

/* local prototypes */
static void       rpng2_win_init(void);
static int        rpng2_win_create_window(void);
static int        rpng2_win_load_bg_image(void);
static void       rpng2_win_display_row(ulg row);
static void       rpng2_win_finish_display(void);
static void       rpng2_win_cleanup(void);
LRESULT CALLBACK  rpng2_win_wndproc(HWND, UINT, WPARAM, LPARAM);


static char titlebar[1024], *window_name = titlebar;
static char *progname = PROGNAME;
static char *appname = LONGNAME;
static char *icon_name = PROGNAME;	/* GRR:  not (yet) used */
static char *filename;
static FILE *infile;

static mainprog_info rpng2_info;

static uch inbuf[INBUFSIZE];
static int incount;

static int pat = 6;		/* must be less than num_bgpat */
static int bg_image = 0;
static int bgscale = 16;
static ulg bg_rowbytes;
static uch *bg_data;

static struct rgb_color {
    uch r, g, b;
} rgb[] = {
    {  0,   0,   0},	/*  0:  black */
    {255, 255, 255},	/*  1:  white */
    {173, 132,  57},	/*  2:  tan */
    { 64, 132,   0},	/*  3:  medium green */
    {189, 117,   1},	/*  4:  gold */
    {253, 249,   1},	/*  5:  yellow */
    {  0,   0, 255},	/*  6:  blue */
    {  0,   0, 120},	/*  7:  medium blue */
    {255,   0, 255},	/*  8:  magenta */
    { 64,   0,  64},	/*  9:  dark magenta */
    {255,   0,   0},	/* 10:  red */
    { 64,   0,   0},	/* 11:  dark red */
    {255, 127,   0},	/* 12:  orange */
    {192,  96,   0},	/* 13:  darker orange */
    { 24,  60,   0},	/* 14:  dark green-yellow */
    { 85, 125, 200} 	/* 15:  ice blue */
};
/* not used for now, but should be for error-checking:
static int num_rgb = sizeof(rgb) / sizeof(struct rgb_color);
 */

/*
    This whole struct is a fairly cheesy way to keep the number of
    command-line options to a minimum.  The radial-waves background
    type is a particularly poor fit to the integer elements of the
    struct...but a few macros and a little fixed-point math will do
    wonders for ya.

    type bits:
       F E D C B A 9 8 7 6 5 4 3 2 1 0
                             | | | | |
                             | | +-+-+-- 0 = sharp-edged checkerboard
                             | |         1 = soft diamonds
                             | |         2 = radial waves
                             | |       3-7 = undefined
                             | +-- gradient #2 inverted?
                             +-- alternating columns inverted?
 */
static struct background_pattern {
    ush type;
    int rgb1_max, rgb1_min;	/* or bg_freq, bg_gray */
    int rgb2_max, rgb2_min;	/* or bg_bsat, bg_brot (both scaled by 10)*/
} bg[] = {
    {0+8,   2,0,  1,15},  	/* checkered:  tan/black vs. white/ice blue */
    {0+24,  2,0,  1,0},  	/* checkered:  tan/black vs. white/black */
    {0+8,   4,5,  0,2},  	/* checkered:  gold/yellow vs. black/tan */
    {0+8,   4,5,  0,6},  	/* checkered:  gold/yellow vs. black/blue */
    {0,     7,0,  8,9},  	/* checkered:  deep blue/black vs. magenta */
    {0+8,  13,0,  5,14},  	/* checkered:  orange/black vs. yellow */
    {0+8,  12,0, 10,11},  	/* checkered:  orange/black vs. red */
    {1,     7,0,  8,0},  	/* diamonds:  deep blue/black vs. magenta */
    {1,    12,0, 11,0},  	/* diamonds:  orange vs. dark red */
    {1,    10,0,  7,0},  	/* diamonds:  red vs. medium blue */
    {1,     4,0,  5,0},  	/* diamonds:  gold vs. yellow */
    {1,     3,0,  0,0},  	/* diamonds:  medium green vs. black */
    {2,    16, 100,  20,   0},  /* radial:  ~hard radial color-beams */
    {2,    18, 100,  10,   2},  /* radial:  soft, curved radial color-beams */
    {2,    16, 256, 100, 250},  /* radial:  very tight spiral */
    {2, 10000, 256,  11,   0}   /* radial:  dipole-moire' (almost fractal) */
};
static int num_bgpat = sizeof(bg) / sizeof(struct background_pattern);


/* Windows-specific global variables (could go in struct, but messy...) */
static ulg wimage_rowbytes;
static uch *dib;
static uch *wimage_data;
static BITMAPINFOHEADER *bmih;

static HWND global_hwnd;
static HINSTANCE global_hInst;
static int global_showmode;




int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, PSTR cmd, int showmode)
{
    char *args[1024];		/* arbitrary limit, but should suffice */
    char *p, *q, *bgstr = NULL, **argv = args;
    int argc = 0;
    int rc, alen, flen;
    int error = 0;
    int timing = FALSE;
    int have_bg = FALSE;
    double LUT_exponent;		/* just the lookup table */
    double CRT_exponent = 2.2;		/* just the monitor */
    double default_display_exponent;	/* whole display system */
    MSG msg;


    /* First initialize a few things, just to be sure--memset takes care of
     * default background color (black), booleans (FALSE), pointers (NULL),
     * etc. */

    global_hInst = hInst;
    global_showmode = showmode;
    filename = (char *)NULL;
    memset(&rpng2_info, 0, sizeof(mainprog_info));


    /* Set the default value for our display-system exponent, i.e., the
     * product of the CRT exponent and the exponent corresponding to
     * the frame-buffer's lookup table (LUT), if any.  This is not an
     * exhaustive list of LUT values (e.g., OpenStep has a lot of weird
     * ones), but it should cover 99% of the current possibilities.  And
     * yes, these ifdefs are completely wasted in a Windows program... */

#if defined(NeXT)
    /* third-party utilities can modify the default LUT exponent */
    LUT_exponent = 1.0 / 2.2;
    /*
    if (some_next_function_that_returns_gamma(&next_gamma))
        LUT_exponent = 1.0 / next_gamma;
     */
#elif defined(sgi)
    LUT_exponent = 1.0 / 1.7;
    /* there doesn't seem to be any documented function to
     * get the "gamma" value, so we do it the hard way */
    infile = fopen("/etc/config/system.glGammaVal", "r");
    if (infile) {
        double sgi_gamma;

        fgets(tmpline, 80, infile);
        fclose(infile);
        sgi_gamma = atof(tmpline);
        if (sgi_gamma > 0.0)
            LUT_exponent = 1.0 / sgi_gamma;
    }
#elif defined(Macintosh)
    LUT_exponent = 1.8 / 2.61;
    /*
    if (some_mac_function_that_returns_gamma(&mac_gamma))
        LUT_exponent = mac_gamma / 2.61;                 
     */
#else
    LUT_exponent = 1.0;   /* assume no LUT:  most PCs */
#endif

    /* the defaults above give 1.0, 1.3, 1.5 and 2.2, respectively: */
    default_display_exponent = LUT_exponent * CRT_exponent;


    /* If the user has set the SCREEN_GAMMA environment variable as suggested
     * (somewhat imprecisely) in the libpng documentation, use that; otherwise
     * use the default value we just calculated.  Either way, the user may
     * override this via a command-line option. */

    if ((p = getenv("SCREEN_GAMMA")) != NULL)
        rpng2_info.display_exponent = atof(p);
    else
        rpng2_info.display_exponent = default_display_exponent;


    /* Windows really hates command lines, so we have to set up our own argv.
     * Note that we do NOT bother with quoted arguments here, so don't use
     * filenames with spaces in 'em! */

    argv[argc++] = PROGNAME;
    p = cmd;
    for (;;) {
        if (*p == ' ')
            while (*++p == ' ')
                ;
        /* now p points at the first non-space after some spaces */
        if (*p == '\0')
            break;    /* nothing after the spaces:  done */
        argv[argc++] = q = p;
        while (*q && *q != ' ')
            ++q;
        /* now q points at a space or the end of the string */
        if (*q == '\0')
            break;    /* last argv already terminated; quit */
        *q = '\0';    /* change space to terminator */
        p = q + 1;
    }
    argv[argc] = NULL;   /* terminate the argv array itself */


    /* Now parse the command line for options and the PNG filename. */

    while (*++argv && !error) {
        if (!strcmp(*argv, "-gamma")) {
            if (!*++argv)
                ++error;
            rpng2_info.display_exponent = atof(*argv);
            if (rpng2_info.display_exponent <= 0.0)
                ++error;
        } else if (!strcmp(*argv, "-bgcolor")) {
            if (!*++argv)
                ++error;
            bgstr = *argv;
            if (strlen(bgstr) != 7 || bgstr[0] != '#')
                ++error;
            else {
                have_bg = TRUE;
                bg_image = FALSE;
            }
        } else if (!strcmp(*argv, "-bgpat")) {
            if (!*++argv)
                ++error;
            pat = atoi(*argv) - 1;
            if (pat < 0 || pat >= num_bgpat)
                ++error;
            else {
                bg_image = TRUE;
                have_bg = FALSE;
            }
        } else if (!strcmp(*argv, "-timing")) {
            timing = TRUE;
        } else {
            if (**argv != '-') {
                filename = *argv;
                if (argv[1])   /* shouldn't be any more args after filename */
                    ++error;
            } else
                ++error;   /* not expecting any other options */
        }
    }

    if (!filename) {
        ++error;
    } else if (!(infile = fopen(filename, "rb"))) {
        fprintf(stderr, PROGNAME ":  can't open PNG file [%s]\n", filename);
        ++error;
    } else {
        incount = fread(inbuf, 1, INBUFSIZE, infile);
        if (incount < 8 || !readpng2_check_sig(inbuf, 8)) {
            fprintf(stderr, PROGNAME
              ":  [%s] is not a PNG file: incorrect signature\n",
              filename);
            ++error;
        } else if ((rc = readpng2_init(&rpng2_info)) != 0) {
            switch (rc) {
                case 2:
                    fprintf(stderr, PROGNAME
                      ":  [%s] has bad IHDR (libpng longjmp)\n",
                      filename);
                    break;
                case 4:
                    fprintf(stderr, PROGNAME ":  insufficient memory\n");
                    break;
                default:
                    fprintf(stderr, PROGNAME
                      ":  unknown readpng2_init() error\n");
                    break;
            }
            ++error;
        }
        if (error)
            fclose(infile);
    }

    if (error) {
        fprintf(stderr, "\n%s %s:  %s\n", PROGNAME, VERSION, appname);
        readpng2_version_info();
        fprintf(stderr, "\n"
          "Usage:  %s [-gamma exp] [-bgcolor bg | -bgpat pat] [-timing]"
          " file.png\n\n"
          "    exp \ttransfer-function exponent (``gamma'') of the display\n"
          "\t\t  system in floating-point format (e.g., ``%.1f''); equal\n"
          "\t\t  to the product of the lookup-table exponent (varies)\n"
          "\t\t  and the CRT exponent (usually 2.2); must be positive\n"
          "    bg  \tdesired background color in 7-character hex RGB format\n"
          "\t\t  (e.g., ``#ff7f00'' for orange:  same as HTML colors);\n"
          "\t\t  used with transparent images; overrides -bgpat\n"
          "    pat \tdesired background pattern number (1-%d); used with\n"
          "\t\t  transparent images; overrides -bgcolor\n"
          "    -timing\tenables delay for every block read, to simulate modem\n"
          "\t\t  download of image (~36 Kbps)\n"
          "\nPress Q, Esc or mouse button 1 after image is displayed to quit.\n"
          "\n", PROGNAME, " ", default_display_exponent, num_bgpat);
        exit(1);
    }


    /* set the title-bar string, but make sure buffer doesn't overflow */

    alen = strlen(appname);
    flen = strlen(filename);
    if (alen + flen + 3 > 1023)
        sprintf(titlebar, "%s:  ...%s", appname, filename+(alen+flen+6-1023));
    else
        sprintf(titlebar, "%s:  %s", appname, filename);


    /* set some final rpng2_info variables before entering main data loop */

    if (have_bg) {
        unsigned r, g, b;   /* this approach quiets compiler warnings */

        sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b);
        rpng2_info.bg_red   = (uch)r;
        rpng2_info.bg_green = (uch)g;
        rpng2_info.bg_blue  = (uch)b;
    } else
        rpng2_info.need_bgcolor = TRUE;

    rpng2_info.done = FALSE;
    rpng2_info.mainprog_init = rpng2_win_init;
    rpng2_info.mainprog_display_row = rpng2_win_display_row;
    rpng2_info.mainprog_finish_display = rpng2_win_finish_display;


    /* OK, this is the fun part:  call readpng2_decode_data() at the start of
     * the loop to deal with our first buffer of data (read in above to verify
     * that the file is a PNG image), then loop through the file and continue
     * calling the same routine to handle each chunk of data.  It in turn
     * passes the data to libpng, which will invoke one or more of our call-
     * backs as decoded data become available.  We optionally call Sleep() for
     * one second per iteration to simulate downloading the image via an analog
     * modem. */

    for (;;) {
        Trace((stderr, "about to call readpng2_decode_data()\n"))
        if (readpng2_decode_data(&rpng2_info, inbuf, incount))
            ++error;
        Trace((stderr, "done with readpng2_decode_data()\n"))
        if (error || feof(infile) || rpng2_info.done)
            break;
        if (timing)
            Sleep(1000L);
        incount = fread(inbuf, 1, INBUFSIZE, infile);
    }


    /* clean up PNG stuff and report any decoding errors */

    fclose(infile);
    Trace((stderr, "about to call readpng2_cleanup()\n"))
    readpng2_cleanup(&rpng2_info);

    if (error) {
        fprintf(stderr, PROGNAME ":  libpng error while decoding PNG image\n");
        exit(3);
    }


    /* wait for the user to tell us when to quit */

    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }


    /* we're done:  clean up all image and Windows resources and go away */

    Trace((stderr, "about to call rpng2_win_cleanup()\n"))
    rpng2_win_cleanup();

    return msg.wParam;
}





/* this function is called by readpng2_info_callback() in readpng2.c, which
 * in turn is called by libpng after all of the pre-IDAT chunks have been
 * read and processed--i.e., we now have enough info to finish initializing */

static void rpng2_win_init()
{
    ulg i;
    ulg rowbytes = rpng2_info.rowbytes;

    Trace((stderr, "beginning rpng2_win_init()\n"))
    Trace((stderr, "  rowbytes = %ld\n", rpng2_info.rowbytes))
    Trace((stderr, "  width  = %ld\n", rpng2_info.width))
    Trace((stderr, "  height = %ld\n", rpng2_info.height))

    rpng2_info.image_data = (uch *)malloc(rowbytes * rpng2_info.height);
    if (!rpng2_info.image_data) {
        readpng2_cleanup(&rpng2_info);
        return;
    }

    rpng2_info.row_pointers = (uch **)malloc(rpng2_info.height * sizeof(uch *));
    if (!rpng2_info.row_pointers) {
        free(rpng2_info.image_data);
        rpng2_info.image_data = NULL;
        readpng2_cleanup(&rpng2_info);
        return;
    }

    for (i = 0;  i < rpng2_info.height;  ++i)
        rpng2_info.row_pointers[i] = rpng2_info.image_data + i*rowbytes;

/*---------------------------------------------------------------------------
    Do the basic Windows initialization stuff, make the window, and fill it
    with the user-specified, file-specified or default background color.
  ---------------------------------------------------------------------------*/

    if (rpng2_win_create_window()) {
        readpng2_cleanup(&rpng2_info);
        return;
    }
}





static int rpng2_win_create_window()
{
    uch bg_red   = rpng2_info.bg_red;
    uch bg_green = rpng2_info.bg_green;
    uch bg_blue  = rpng2_info.bg_blue;
    uch *dest;
    int extra_width, extra_height;
    ulg i, j;
    WNDCLASSEX wndclass;
    RECT rect;


/*---------------------------------------------------------------------------
    Allocate memory for the display-specific version of the image (round up
    to multiple of 4 for Windows DIB).
  ---------------------------------------------------------------------------*/

    wimage_rowbytes = ((3*rpng2_info.width + 3L) >> 2) << 2;

    if (!(dib = (uch *)malloc(sizeof(BITMAPINFOHEADER) +
                              wimage_rowbytes*rpng2_info.height)))
    {
        return 4;	/* fail */
    }

/*---------------------------------------------------------------------------
    Initialize the DIB.  Negative height means to use top-down BMP ordering
    (must be uncompressed, but that's what we want).  Bit count of 1, 4 or 8
    implies a colormap of RGBX quads, but 24-bit BMPs just use B,G,R values
    directly => wimage_data begins immediately after BMP header.
  ---------------------------------------------------------------------------*/

    memset(dib, 0, sizeof(BITMAPINFOHEADER));
    bmih = (BITMAPINFOHEADER *)dib;
    bmih->biSize = sizeof(BITMAPINFOHEADER);
    bmih->biWidth = rpng2_info.width;
    bmih->biHeight = -((long)rpng2_info.height);
    bmih->biPlanes = 1;
    bmih->biBitCount = 24;
    bmih->biCompression = 0;
    wimage_data = dib + sizeof(BITMAPINFOHEADER);

/*---------------------------------------------------------------------------
    Fill window with the specified background color (default is black), but
    defer loading faked "background image" until window is displayed (may be
    slow to compute).  Data are in BGR order.
  ---------------------------------------------------------------------------*/

    if (bg_image) {   /* just fill with black for now */
        memset(wimage_data, 0, wimage_rowbytes*rpng2_info.height);
    } else {
        for (j = 0;  j < rpng2_info.height;  ++j) {
            dest = wimage_data + j*wimage_rowbytes;
            for (i = rpng2_info.width;  i > 0;  --i) {
                *dest++ = bg_blue;
                *dest++ = bg_green;
                *dest++ = bg_red;
            }
        }
    }

/*---------------------------------------------------------------------------
    Set the window parameters.
  ---------------------------------------------------------------------------*/

    memset(&wndclass, 0, sizeof(wndclass));

    wndclass.cbSize = sizeof(wndclass);
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = rpng2_win_wndproc;
    wndclass.hInstance = global_hInst;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(DKGRAY_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = progname;
    wndclass.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

    RegisterClassEx(&wndclass);

/*---------------------------------------------------------------------------
    Finally, create the window.
  ---------------------------------------------------------------------------*/

    extra_width  = 2*(GetSystemMetrics(SM_CXBORDER) +
                      GetSystemMetrics(SM_CXDLGFRAME));
    extra_height = 2*(GetSystemMetrics(SM_CYBORDER) +
                      GetSystemMetrics(SM_CYDLGFRAME)) +
                      GetSystemMetrics(SM_CYCAPTION);

    global_hwnd = CreateWindow(progname, titlebar, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, CW_USEDEFAULT, rpng2_info.width+extra_width,
      rpng2_info.height+extra_height, NULL, NULL, global_hInst, NULL);

    ShowWindow(global_hwnd, global_showmode);
    UpdateWindow(global_hwnd);

/*---------------------------------------------------------------------------
    Now compute the background image and display it.  If it fails (memory
    allocation), revert to a plain background color.
  ---------------------------------------------------------------------------*/

    if (bg_image) {
        static const char *msg = "Computing background image...";
        int x, y, len = strlen(msg);
        HDC hdc = GetDC(global_hwnd);
        TEXTMETRIC tm;

        GetTextMetrics(hdc, &tm);
        x = (rpng2_info.width - len*tm.tmAveCharWidth)/2;
        y = (rpng2_info.height - tm.tmHeight)/2;
        SetBkMode(hdc, TRANSPARENT);
        SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
        /* this can still begin out of bounds even if x is positive (???): */
        TextOut(hdc, ((x < 0)? 0 : x), ((y < 0)? 0 : y), msg, len);
        ReleaseDC(global_hwnd, hdc);

        rpng2_win_load_bg_image();	/* resets bg_image if fails */
    }

    if (!bg_image) {
        for (j = 0;  j < rpng2_info.height;  ++j) {
            dest = wimage_data + j*wimage_rowbytes;
            for (i = rpng2_info.width;  i > 0;  --i) {
                *dest++ = bg_blue;
                *dest++ = bg_green;
                *dest++ = bg_red;
            }
        }
    }

    rect.left = 0L;
    rect.top = 0L;
    rect.right = (LONG)rpng2_info.width;       /* possibly off by one? */
    rect.bottom = (LONG)rpng2_info.height;     /* possibly off by one? */
    InvalidateRect(global_hwnd, &rect, FALSE);
    UpdateWindow(global_hwnd);                 /* similar to XFlush() */

    return 0;

} /* end function rpng2_win_create_window() */





static int rpng2_win_load_bg_image()
{
    uch *src, *dest;
    uch r1, r2, g1, g2, b1, b2;
    uch r1_inv, r2_inv, g1_inv, g2_inv, b1_inv, b2_inv;
    int k, hmax, max;
    int xidx, yidx, yidx_max = (bgscale-1);
    int even_odd_vert, even_odd_horiz, even_odd;
    int invert_gradient2 = (bg[pat].type & 0x08);
    int invert_column;
    ulg i, row;

/*---------------------------------------------------------------------------
    Allocate buffer for fake background image to be used with transparent
    images; if this fails, revert to plain background color.
  ---------------------------------------------------------------------------*/

    bg_rowbytes = 3 * rpng2_info.width;
    bg_data = (uch *)malloc(bg_rowbytes * rpng2_info.height);
    if (!bg_data) {
        fprintf(stderr, PROGNAME
          ":  unable to allocate memory for background image\n");
        bg_image = 0;
        return 1;
    }

/*---------------------------------------------------------------------------
    Vertical gradients (ramps) in NxN squares, alternating direction and
    colors (N == bgscale).
  ---------------------------------------------------------------------------*/

    if ((bg[pat].type & 0x07) == 0) {
        uch r1_min  = rgb[bg[pat].rgb1_min].r;
        uch g1_min  = rgb[bg[pat].rgb1_min].g;
        uch b1_min  = rgb[bg[pat].rgb1_min].b;
        uch r2_min  = rgb[bg[pat].rgb2_min].r;
        uch g2_min  = rgb[bg[pat].rgb2_min].g;
        uch b2_min  = rgb[bg[pat].rgb2_min].b;
        int r1_diff = rgb[bg[pat].rgb1_max].r - r1_min;
        int g1_diff = rgb[bg[pat].rgb1_max].g - g1_min;
        int b1_diff = rgb[bg[pat].rgb1_max].b - b1_min;
        int r2_diff = rgb[bg[pat].rgb2_max].r - r2_min;
        int g2_diff = rgb[bg[pat].rgb2_max].g - g2_min;
        int b2_diff = rgb[bg[pat].rgb2_max].b - b2_min;

        for (row = 0;  row < rpng2_info.height;  ++row) {
            yidx = row % bgscale;
            even_odd_vert = (row / bgscale) & 1;

            r1 = r1_min + (r1_diff * yidx) / yidx_max;
            g1 = g1_min + (g1_diff * yidx) / yidx_max;
            b1 = b1_min + (b1_diff * yidx) / yidx_max;
            r1_inv = r1_min + (r1_diff * (yidx_max-yidx)) / yidx_max;
            g1_inv = g1_min + (g1_diff * (yidx_max-yidx)) / yidx_max;
            b1_inv = b1_min + (b1_diff * (yidx_max-yidx)) / yidx_max;

            r2 = r2_min + (r2_diff * yidx) / yidx_max;
            g2 = g2_min + (g2_diff * yidx) / yidx_max;
            b2 = b2_min + (b2_diff * yidx) / yidx_max;
            r2_inv = r2_min + (r2_diff * (yidx_max-yidx)) / yidx_max;
            g2_inv = g2_min + (g2_diff * (yidx_max-yidx)) / yidx_max;
            b2_inv = b2_min + (b2_diff * (yidx_max-yidx)) / yidx_max;

            dest = bg_data + row*bg_rowbytes;
            for (i = 0;  i < rpng2_info.width;  ++i) {
                even_odd_horiz = (i / bgscale) & 1;
                even_odd = even_odd_vert ^ even_odd_horiz;
                invert_column =
                  (even_odd_horiz && (bg[pat].type & 0x10));
                if (even_odd == 0) {		/* gradient #1 */
                    if (invert_column) {
                        *dest++ = r1_inv;
                        *dest++ = g1_inv;
                        *dest++ = b1_inv;
                    } else {
                        *dest++ = r1;
                        *dest++ = g1;
                        *dest++ = b1;
                    }
                } else {			/* gradient #2 */
                    if ((invert_column && invert_gradient2) ||
                        (!invert_column && !invert_gradient2))
                    {
                        *dest++ = r2;      /* not inverted or */
                        *dest++ = g2;      /*  doubly inverted */
                        *dest++ = b2;
                    } else {
                        *dest++ = r2_inv;
                        *dest++ = g2_inv;  /* singly inverted */
                        *dest++ = b2_inv;
                    }
                }
            }
        }

/*---------------------------------------------------------------------------
    Soft gradient-diamonds with scale = bgscale.  Code contributed by Adam
    M. Costello.
  ---------------------------------------------------------------------------*/

    } else if ((bg[pat].type & 0x07) == 1) {

        hmax = (bgscale-1)/2;	/* half the max weight of a color */
        max = 2*hmax;		/* the max weight of a color */

        r1 = rgb[bg[pat].rgb1_max].r;
        g1 = rgb[bg[pat].rgb1_max].g;
        b1 = rgb[bg[pat].rgb1_max].b;
        r2 = rgb[bg[pat].rgb2_max].r;
        g2 = rgb[bg[pat].rgb2_max].g;
        b2 = rgb[bg[pat].rgb2_max].b;

        for (row = 0;  row < rpng2_info.height;  ++row) {
            yidx = row % bgscale;
            if (yidx > hmax)
                yidx = bgscale-1 - yidx;
            dest = bg_data + row*bg_rowbytes;
            for (i = 0;  i < rpng2_info.width;  ++i) {
                xidx = i % bgscale;
                if (xidx > hmax)
                    xidx = bgscale-1 - xidx;
                k = xidx + yidx;
                *dest++ = (k*r1 + (max-k)*r2) / max;
                *dest++ = (k*g1 + (max-k)*g2) / max;
                *dest++ = (k*b1 + (max-k)*b2) / max;
            }
        }

/*---------------------------------------------------------------------------
    Radial "starburst" with azimuthal sinusoids; [eventually number of sinu-
    soids will equal bgscale?].  This one is slow but very cool.  Code con-
    tributed by Pieter S. van der Meulen (originally in Smalltalk).
  ---------------------------------------------------------------------------*/

    } else if ((bg[pat].type & 0x07) == 2) {
        uch ch;
        int ii, x, y, hw, hh, grayspot;
        double freq, rotate, saturate, gray, intensity;
        double angle=0.0, aoffset=0.0, maxDist, dist;
        double red=0.0, green=0.0, blue=0.0, hue, s, v, f, p, q, t;

        fprintf(stderr, "%s:  computing radial background...",
          PROGNAME);
        fflush(stderr);

        hh = rpng2_info.height / 2;
        hw = rpng2_info.width / 2;

        /* variables for radial waves:
         *   aoffset:  number of degrees to rotate hue [CURRENTLY NOT USED]
         *   freq:  number of color beams originating from the center
         *   grayspot:  size of the graying center area (anti-alias)
         *   rotate:  rotation of the beams as a function of radius
         *   saturate:  saturation of beams' shape azimuthally
         */
        angle = CLIP(angle, 0.0, 360.0);
        grayspot = CLIP(bg[pat].bg_gray, 1, (hh + hw));
        freq = MAX((double)bg[pat].bg_freq, 0.0);
        saturate = (double)bg[pat].bg_bsat * 0.1;
        rotate = (double)bg[pat].bg_brot * 0.1;
        gray = 0.0;
        intensity = 0.0;
        maxDist = (double)((hw*hw) + (hh*hh));

        for (row = 0;  row < rpng2_info.height;  ++row) {
            y = row - hh;
            dest = bg_data + row*bg_rowbytes;
            for (i = 0;  i < rpng2_info.width;  ++i) {
                x = i - hw;
                angle = (x == 0)? PI_2 : atan((double)y / (double)x);
                gray = (double)MAX(ABS(y), ABS(x)) / grayspot;
                gray = MIN(1.0, gray);
                dist = (double)((x*x) + (y*y)) / maxDist;
                intensity = cos((angle+(rotate*dist*PI)) * freq) *
                  gray * saturate;
                intensity = (MAX(MIN(intensity,1.0),-1.0) + 1.0) * 0.5;
                hue = (angle + PI) * INV_PI_360 + aoffset;
                s = gray * ((double)(ABS(x)+ABS(y)) / (double)(hw + hh));
                s = MIN(MAX(s,0.0), 1.0);
                v = MIN(MAX(intensity,0.0), 1.0);

                if (s == 0.0) {
                    ch = (uch)(v * 255.0);
                    *dest++ = ch;
                    *dest++ = ch;
                    *dest++ = ch;
                } else {
                    if ((hue < 0.0) || (hue >= 360.0))
                        hue -= (((int)(hue / 360.0)) * 360.0);
                    hue /= 60.0;
                    ii = (int)hue;
                    f = hue - (double)ii;
                    p = (1.0 - s) * v;
                    q = (1.0 - (s * f)) * v;
                    t = (1.0 - (s * (1.0 - f))) * v;
                    if      (ii == 0) { red = v; green = t; blue = p; }
                    else if (ii == 1) { red = q; green = v; blue = p; }
                    else if (ii == 2) { red = p; green = v; blue = t; }
                    else if (ii == 3) { red = p; green = q; blue = v; }
                    else if (ii == 4) { red = t; green = p; blue = v; }
                    else if (ii == 5) { red = v; green = p; blue = q; }
                    *dest++ = (uch)(red * 255.0);
                    *dest++ = (uch)(green * 255.0);
                    *dest++ = (uch)(blue * 255.0);
                }
            }
        }
        fprintf(stderr, "done.\n");
        fflush(stderr);
    }

/*---------------------------------------------------------------------------
    Blast background image to display buffer before beginning PNG decode;
    calling function will handle invalidation and UpdateWindow() call.
  ---------------------------------------------------------------------------*/

    for (row = 0;  row < rpng2_info.height;  ++row) {
        src = bg_data + row*bg_rowbytes;
        dest = wimage_data + row*wimage_rowbytes;
        for (i = rpng2_info.width;  i > 0;  --i) {
            r1 = *src++;
            g1 = *src++;
            b1 = *src++;
            *dest++ = b1;
            *dest++ = g1;	/* note reverse order */
            *dest++ = r1;
        }
    }

    return 0;

} /* end function rpng2_win_load_bg_image() */





static void rpng2_win_display_row(ulg row)
{
    uch bg_red   = rpng2_info.bg_red;
    uch bg_green = rpng2_info.bg_green;
    uch bg_blue  = rpng2_info.bg_blue;
    uch *src, *src2=NULL, *dest;
    uch r, g, b, a;
    ulg i;
    static int rows=0;
    static ulg firstrow;

/*---------------------------------------------------------------------------
    rows and firstrow simply track how many rows (and which ones) have not
    yet been displayed; alternatively, we could call InvalidateRect() for
    every row and not bother with the records-keeping.
  ---------------------------------------------------------------------------*/

    Trace((stderr, "beginning rpng2_win_display_row()\n"))

    if (rows == 0)
        firstrow = row;   /* first row not yet displayed */

    ++rows;   /* count of rows received but not yet displayed */

/*---------------------------------------------------------------------------
    Aside from the use of the rpng2_info struct and the lack of an outer
    loop (over rows), this routine is identical to rpng_win_display_image()
    in the non-progressive version of the program.
  ---------------------------------------------------------------------------*/

    src = rpng2_info.image_data + row*rpng2_info.rowbytes;
    if (bg_image)
        src2 = bg_data + row*bg_rowbytes;
    dest = wimage_data + row*wimage_rowbytes;

    if (rpng2_info.channels == 3) {
        for (i = rpng2_info.width;  i > 0;  --i) {
            r = *src++;
            g = *src++;
            b = *src++;
            *dest++ = b;
            *dest++ = g;	/* note reverse order */
            *dest++ = r;
        }
    } else /* if (rpng2_info.channels == 4) */ {
        for (i = rpng2_info.width;  i > 0;  --i) {
            r = *src++;
            g = *src++;
            b = *src++;
            a = *src++;
            if (bg_image) {
                bg_red   = *src2++;
                bg_green = *src2++;
                bg_blue  = *src2++;
            }
            if (a == 255) {
                *dest++ = b;
                *dest++ = g;
                *dest++ = r;
            } else if (a == 0) {
                *dest++ = bg_blue;
                *dest++ = bg_green;
                *dest++ = bg_red;
            } else {
                /* this macro (copied from png.h) composites the
                 * foreground and background values and puts the
                 * result into the first argument; there are no
                 * side effects with the first argument */
                alpha_composite(*dest++, b, a, bg_blue);
                alpha_composite(*dest++, g, a, bg_green);
                alpha_composite(*dest++, r, a, bg_red);
            }
        }
    }

/*---------------------------------------------------------------------------
    Display after every 16 rows or when on last row.  (Region may include
    previously displayed lines due to interlacing--i.e., not contiguous.)
  ---------------------------------------------------------------------------*/

    if ((rows & 0xf) == 0 || row == rpng2_info.height-1) {
        RECT rect;

        rect.left = 0L;
        rect.top = (LONG)firstrow;
        rect.right = (LONG)rpng2_info.width;       /* possibly off by one? */
        rect.bottom = (LONG)row + 1L;              /* possibly off by one? */
        InvalidateRect(global_hwnd, &rect, FALSE);
        UpdateWindow(global_hwnd);                 /* similar to XFlush() */
        rows = 0;
    }

} /* end function rpng2_win_display_row() */





static void rpng2_win_finish_display()
{
    Trace((stderr, "beginning rpng2_win_finish_display()\n"))

    /* last row has already been displayed by rpng2_win_display_row(), so
     * we have nothing to do here except set a flag and let the user know
     * that the image is done */

    rpng2_info.done = TRUE;
    printf("Done.  Press Q, Esc or mouse button 1 to quit.\n");
}





static void rpng2_win_cleanup()
{
    if (bg_image && bg_data) {
        free(bg_data);
        bg_data = NULL;
    }

    if (rpng2_info.image_data) {
        free(rpng2_info.image_data);
        rpng2_info.image_data = NULL;
    }

    if (rpng2_info.row_pointers) {
        free(rpng2_info.row_pointers);
        rpng2_info.row_pointers = NULL;
    }

    if (dib) {
        free(dib);
        dib = NULL;
    }
}





LRESULT CALLBACK rpng2_win_wndproc(HWND hwnd, UINT iMsg, WPARAM wP, LPARAM lP)
{
    HDC         hdc;
    PAINTSTRUCT ps;
    int rc;

    switch (iMsg) {
        case WM_CREATE:
            /* one-time processing here, if any */
            return 0;

        case WM_PAINT:
            hdc = BeginPaint(hwnd, &ps);
            rc = StretchDIBits(hdc, 0, 0, rpng2_info.width, rpng2_info.height,
                                    0, 0, rpng2_info.width, rpng2_info.height,
                                    wimage_data, (BITMAPINFO *)bmih,
                                    0, SRCCOPY);
            EndPaint(hwnd, &ps);
            return 0;

        /* wait for the user to tell us when to quit */
        case WM_CHAR:
            switch (wP) {	/* only need one, so ignore repeat count */
                case 'q':
                case 'Q':
                case 0x1B:	/* Esc key */
                    PostQuitMessage(0);
            }
            return 0;

        case WM_LBUTTONDOWN:	/* another way of quitting */
        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;
    }

    return DefWindowProc(hwnd, iMsg, wP, lP);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\contrib\gregbook\wpng.c ===
/*---------------------------------------------------------------------------

   wpng - simple PNG-writing program                                 wpng.c

   This program converts certain NetPBM binary files (grayscale and RGB,
   maxval = 255) to PNG.  Non-interlaced PNGs are written progressively;
   interlaced PNGs are read and written in one memory-intensive blast.
   Thanks to Jean-loup Gailly for providing the necessary trick to read
   interactive text from the keyboard while stdin is redirected.

   NOTE:  includes provisional support for PNM type "8" (portable alphamap)
          images, presumed to be a 32-bit interleaved RGBA format; no pro-
          vision for possible interleaved grayscale+alpha (16-bit) format.
          THIS IS UNLIKELY TO BECOME AN OFFICIAL NETPBM ALPHA FORMAT!

   to do:
    - delete output file if quit before calling any writepng routines
    - process backspace with -text option under DOS/Win? (currently get ^H)

  ---------------------------------------------------------------------------

      Copyright (c) 1998-1999 Greg Roelofs.  All rights reserved.

      This software is provided "as is," without warranty of any kind,
      express or implied.  In no event shall the author or contributors
      be held liable for any damages arising in any way from the use of
      this software.

      Permission is granted to anyone to use this software for any purpose,
      including commercial applications, and to alter it and redistribute
      it freely, subject to the following restrictions:

      1. Redistributions of source code must retain the above copyright
         notice, disclaimer, and this list of conditions.
      2. Redistributions in binary form must reproduce the above copyright
         notice, disclaimer, and this list of conditions in the documenta-
         tion and/or other materials provided with the distribution.
      3. All advertising materials mentioning features or use of this
         software must display the following acknowledgment:

            This product includes software developed by Greg Roelofs
            and contributors for the book, "PNG: The Definitive Guide,"
            published by O'Reilly and Associates.

  ---------------------------------------------------------------------------*/

#define PROGNAME  "wpng"
#define VERSION   "1.01 of 31 March 1999"
#define APPNAME   "Simple PGM/PPM/PAM to PNG Converter"

#if defined(__MSDOS__) || defined(__OS2__)
#  define DOS_OS2_W32
#elif defined(_WIN32) || defined(__WIN32__)
#  define DOS_OS2_W32
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>	/* for jmpbuf declaration in writepng.h */
#include <time.h>

#ifdef DOS_OS2_W32
#  include <io.h>	/* for isatty(), setmode() prototypes */
#  include <fcntl.h>	/* O_BINARY for fdopen() without text translation */
#  ifdef __EMX__
#    ifndef getch
#      define getch() _read_kbd(0, 1, 0)	/* need getche() */
#    endif
#  else /* !__EMX__ */
#    ifdef __GO32__
#      include <pc.h>
#      define getch() getkey()	/* GRR:  need getche() */
#    else
#      include <conio.h>	/* for getche() console input */
#    endif
#  endif /* ?__EMX__ */
#  define FGETS(buf,len,stream)  dos_kbd_gets(buf,len)
#else
#  include <unistd.h>		/* for isatty() prototype */
#  define FGETS fgets
#endif

/* #define DEBUG  :  this enables the Trace() macros */

/* #define FORBID_LATIN1_CTRL  :  this requires the user to re-enter any
   text that includes control characters discouraged by the PNG spec; text
   that includes an escape character (27) must be re-entered regardless */

#include "writepng.h"	/* typedefs, common macros, writepng prototypes */



/* local prototypes */

static int  wpng_isvalid_latin1(uch *p, int len);
static void wpng_cleanup(void);

#ifdef DOS_OS2_W32
   static char *dos_kbd_gets(char *buf, int len);
#endif



static mainprog_info wpng_info;   /* lone global */



int main(int argc, char **argv)
{
#ifndef DOS_OS2_W32
    FILE *keybd;
#endif
#ifdef sgi
    FILE *tmpfile;	/* or we could just use keybd, since no overlap */
    char tmpline[80];
#endif
    char *inname = NULL, outname[256];
    char *p, pnmchar, pnmline[256];
    char *bgstr, *textbuf = NULL;
    ulg rowbytes;
    int rc, len = 0;
    int error = 0;
    int text = FALSE;
    int maxval;
    double LUT_exponent;                /* just the lookup table */
    double CRT_exponent = 2.2;          /* just the monitor */
    double default_display_exponent;    /* whole display system */
    double default_gamma = 0.0;


    wpng_info.infile = NULL;
    wpng_info.outfile = NULL;
    wpng_info.image_data = NULL;
    wpng_info.row_pointers = NULL;
    wpng_info.filter = FALSE;
    wpng_info.interlaced = FALSE;
    wpng_info.have_bg = FALSE;
    wpng_info.have_time = FALSE;
    wpng_info.have_text = 0;
    wpng_info.gamma = 0.0;


    /* First get the default value for our display-system exponent, i.e.,
     * the product of the CRT exponent and the exponent corresponding to
     * the frame-buffer's lookup table (LUT), if any.  If the PNM image
     * looks correct on the user's display system, its file gamma is the
     * inverse of this value.  (Note that this is not an exhaustive list
     * of LUT values--e.g., OpenStep has a lot of weird ones--but it should
     * cover 99% of the current possibilities.  This section must ensure
     * that default_display_exponent is positive.) */

#if defined(NeXT)
    /* third-party utilities can modify the default LUT exponent */
    LUT_exponent = 1.0 / 2.2;
    /*
    if (some_next_function_that_returns_gamma(&next_gamma))
        LUT_exponent = 1.0 / next_gamma;
     */
#elif defined(sgi)
    LUT_exponent = 1.0 / 1.7;
    /* there doesn't seem to be any documented function to
     * get the "gamma" value, so we do it the hard way */
    tmpfile = fopen("/etc/config/system.glGammaVal", "r");
    if (tmpfile) {
        double sgi_gamma;

        fgets(tmpline, 80, tmpfile);
        fclose(tmpfile);
        sgi_gamma = atof(tmpline);
        if (sgi_gamma > 0.0)
            LUT_exponent = 1.0 / sgi_gamma;
    }
#elif defined(Macintosh)
    LUT_exponent = 1.8 / 2.61;
    /*
    if (some_mac_function_that_returns_gamma(&mac_gamma))
        LUT_exponent = mac_gamma / 2.61;
     */
#else
    LUT_exponent = 1.0;   /* assume no LUT:  most PCs */
#endif

    /* the defaults above give 1.0, 1.3, 1.5 and 2.2, respectively: */
    default_display_exponent = LUT_exponent * CRT_exponent;


    /* If the user has set the SCREEN_GAMMA environment variable as suggested
     * (somewhat imprecisely) in the libpng documentation, use that; otherwise
     * use the default value we just calculated.  Either way, the user may
     * override this via a command-line option. */

    if ((p = getenv("SCREEN_GAMMA")) != NULL) {
        double exponent = atof(p);

        if (exponent > 0.0)
            default_gamma = 1.0 / exponent;
    }

    if (default_gamma == 0.0)
        default_gamma = 1.0 / default_display_exponent;


    /* Now parse the command line for options and the PNM filename. */

    while (*++argv && !error) {
        if (!strcmp(*argv, "-interlaced")) {
            wpng_info.interlaced = TRUE;
        } else if (!strcmp(*argv, "-time")) {
            wpng_info.modtime = time(NULL);
            wpng_info.have_time = TRUE;
        } else if (!strcmp(*argv, "-text")) {
            text = TRUE;
        } else if (!strcmp(*argv, "-gamma")) {
            if (!*++argv)
                ++error;
            wpng_info.gamma = atof(*argv);
            if (wpng_info.gamma <= 0.0)
                ++error;
            else if (wpng_info.gamma > 1.01)
                fprintf(stderr, PROGNAME
                  " warning:  file gammas are usually less than 1.0\n");
        } else if (!strcmp(*argv, "-bgcolor")) {
            if (!*++argv)
                ++error;
            bgstr = *argv;
            if (strlen(bgstr) != 7 || bgstr[0] != '#')
                ++error;
            else {
                unsigned r, g, b;  /* this approach quiets compiler warnings */

                sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b);
                wpng_info.bg_red   = (uch)r;
                wpng_info.bg_green = (uch)g;
                wpng_info.bg_blue  = (uch)b;
                wpng_info.have_bg = TRUE;
            }
        } else {
            if (**argv != '-') {
                inname = *argv;
                if (argv[1])   /* shouldn't be any more args after filename */
                    ++error;
            } else
                ++error;   /* not expecting any other options */
        }
    }


    /* open the input and output files, or register an error and abort */

    if (!inname) {
        if (isatty(0)) {
            fprintf(stderr, PROGNAME
              ":  must give input filename or provide image data via stdin\n");
            ++error;
        } else {
#ifdef DOS_OS2_W32
            /* some buggy C libraries require BOTH setmode() and fdopen(bin) */
            setmode(fileno(stdin), O_BINARY);
            setmode(fileno(stdout), O_BINARY);
#endif
            if ((wpng_info.infile = fdopen(fileno(stdin), "rb")) == NULL) {
                fprintf(stderr, PROGNAME
                  ":  unable to reopen stdin in binary mode\n");
                ++error;
            } else
            if ((wpng_info.outfile = fdopen(fileno(stdout), "wb")) == NULL) {
                fprintf(stderr, PROGNAME
                  ":  unable to reopen stdout in binary mode\n");
                fclose(wpng_info.infile);
                ++error;
            } else 
                wpng_info.filter = TRUE;
        }
    } else if ((len = strlen(inname)) > 250) {
        fprintf(stderr, PROGNAME ":  input filename is too long [%d chars]\n",
          len);
        ++error;
    } else if (!(wpng_info.infile = fopen(inname, "rb"))) {
        fprintf(stderr, PROGNAME ":  can't open input file [%s]\n", inname);
        ++error;
    }

    if (!error) {
        fgets(pnmline, 256, wpng_info.infile);
        if (pnmline[0] != 'P' || ((pnmchar = pnmline[1]) != '5' &&
            pnmchar != '6' && pnmchar != '8'))
        {
            fprintf(stderr, PROGNAME
              ":  input file [%s] is not a binary PGM, PPM or PAM file\n",
              inname);
            ++error;
        } else {
            wpng_info.pnmtype = (int)(pnmchar - '0');
            if (wpng_info.pnmtype != 8)
                wpng_info.have_bg = FALSE;  /* no need for bg if opaque */
            do {
                fgets(pnmline, 256, wpng_info.infile);  /* lose any comments */
            } while (pnmline[0] == '#');
            sscanf(pnmline, "%ld %ld", &wpng_info.width, &wpng_info.height);
            do {
                fgets(pnmline, 256, wpng_info.infile);  /* more comment lines */
            } while (pnmline[0] == '#');
            sscanf(pnmline, "%d", &maxval);
            if (wpng_info.width <= 0L || wpng_info.height <= 0L ||
                maxval != 255)
            {
                fprintf(stderr, PROGNAME
                  ":  only positive width/height, maxval == 255 allowed \n");
                ++error;
            }
            wpng_info.sample_depth = 8;  /* <==> maxval 255 */

            if (!wpng_info.filter) {
                /* make outname from inname */
                if ((p = strrchr(inname, '.')) == NULL ||
                    (p - inname) != (len - 4))
                {
                    strcpy(outname, inname);
                    strcpy(outname+len, ".png");
                } else {
                    len -= 4;
                    strncpy(outname, inname, len);
                    strcpy(outname+len, ".png");
                }
                /* check if outname already exists; if not, open */
                if ((wpng_info.outfile = fopen(outname, "rb")) != NULL) {
                    fprintf(stderr, PROGNAME ":  output file exists [%s]\n",
                      outname);
                    fclose(wpng_info.outfile);
                    ++error;
                } else if (!(wpng_info.outfile = fopen(outname, "wb"))) {
                    fprintf(stderr, PROGNAME ":  can't open output file [%s]\n",
                      outname);
                    ++error;
                }
            }
        }
        if (error) {
            fclose(wpng_info.infile);
            wpng_info.infile = NULL;
            if (wpng_info.filter) {
                fclose(wpng_info.outfile);
                wpng_info.outfile = NULL;
            }
        }
    }


    /* if we had any errors, print usage and die horrible death...arrr! */

    if (error) {
        fprintf(stderr, "\n%s %s:  %s\n", PROGNAME, VERSION, APPNAME);
        writepng_version_info();
        fprintf(stderr, "\n"
"Usage:  %s [-gamma exp] [-bgcolor bg] [-text] [-time] [-interlace] pnmfile\n"
"or: ... | %s [-gamma exp] [-bgcolor bg] [-text] [-time] [-interlace] | ...\n"
         "    exp \ttransfer-function exponent (``gamma'') of the image in\n"
         "\t\t  floating-point format (e.g., ``%.5f''); if image looks\n"
         "\t\t  correct on given display system, image gamma is equal to\n"
         "\t\t  inverse of display-system exponent, i.e., 1 / (LUT * CRT)\n"
         "\t\t  (where LUT = lookup-table exponent and CRT = CRT exponent;\n"
         "\t\t  first varies, second is usually 2.2, all are positive)\n"
         "    bg  \tdesired background color for alpha-channel images, in\n"
         "\t\t  7-character hex RGB format (e.g., ``#ff7f00'' for orange:\n"
         "\t\t  same as HTML colors)\n"
         "    -text\tprompt interactively for text info (tEXt chunks)\n"
         "    -time\tinclude a tIME chunk (last modification time)\n"
         "    -interlace\twrite interlaced PNG image\n"
         "\n"
"pnmfile or stdin must be a binary PGM (`P5'), PPM (`P6') or (extremely\n"
"unofficial and unsupported!) PAM (`P8') file.  Currently it is required\n"
"to have maxval == 255 (i.e., no scaling).  If pnmfile is specified, it\n"
"is converted to the corresponding PNG file with the same base name but a\n"
"``.png'' extension; files read from stdin are converted and sent to stdout.\n"
"The conversion is progressive (low memory usage) unless interlacing is\n"
"requested; in that case the whole image will be buffered in memory and\n"
"written in one call.\n"
         "\n", PROGNAME, PROGNAME, default_gamma);
        exit(1);
    }


    /* prepare the text buffers for libpng's use; note that even though
     * PNG's png_text struct includes a length field, we don't have to fill
     * it out */

    if (text &&
#ifndef DOS_OS2_W32
        (keybd = fdopen(fileno(stderr), "r")) != NULL &&
#endif
        (textbuf = (char *)malloc((5 + 9)*75)) != NULL)
    {
        int i, valid, result;

        fprintf(stderr,
          "Enter text info (no more than 72 characters per line);\n");
        fprintf(stderr, "to skip a field, hit the <Enter> key.\n");
        /* note:  just <Enter> leaves len == 1 */

        do {
            valid = TRUE;
            p = textbuf + TEXT_TITLE_OFFSET;
            fprintf(stderr, "  Title: ");
            fflush(stderr);
            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {
                if (p[len-1] == '\n')
                    p[--len] = '\0';
                wpng_info.title = p;
                wpng_info.have_text |= TEXT_TITLE;
                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {
                    fprintf(stderr, "    " PROGNAME " warning:  character code"
                      " %u is %sdiscouraged by the PNG\n    specification "
                      "[first occurrence was at character position #%d]\n",
                      (unsigned)p[result], (p[result] == 27)? "strongly " : "",
                      result+1);
                    fflush(stderr);
#ifdef FORBID_LATIN1_CTRL
                    wpng_info.have_text &= ~TEXT_TITLE;
                    valid = FALSE;
#else
                    if (p[result] == 27) {	/* escape character */
                        wpng_info.have_text &= ~TEXT_TITLE;
                        valid = FALSE;
                    }
#endif
                }
            }
        } while (!valid);

        do {
            valid = TRUE;
            p = textbuf + TEXT_AUTHOR_OFFSET;
            fprintf(stderr, "  Author: ");
            fflush(stderr);
            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {
                if (p[len-1] == '\n')
                    p[--len] = '\0';
                wpng_info.author = p;
                wpng_info.have_text |= TEXT_AUTHOR;
                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {
                    fprintf(stderr, "    " PROGNAME " warning:  character code"
                      " %u is %sdiscouraged by the PNG\n    specification "
                      "[first occurrence was at character position #%d]\n",
                      (unsigned)p[result], (p[result] == 27)? "strongly " : "",
                      result+1);
                    fflush(stderr);
#ifdef FORBID_LATIN1_CTRL
                    wpng_info.have_text &= ~TEXT_AUTHOR;
                    valid = FALSE;
#else
                    if (p[result] == 27) {	/* escape character */
                        wpng_info.have_text &= ~TEXT_AUTHOR;
                        valid = FALSE;
                    }
#endif
                }
            }
        } while (!valid);

        do {
            valid = TRUE;
            p = textbuf + TEXT_DESC_OFFSET;
            fprintf(stderr, "  Description (up to 9 lines):\n");
            for (i = 1;  i < 10;  ++i) {
                fprintf(stderr, "    [%d] ", i);
                fflush(stderr);
                if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1)
                    p += len;   /* now points at NULL; char before is newline */
                else
                    break;
            }
            if ((len = p - (textbuf + TEXT_DESC_OFFSET)) > 1) {
                if (p[-1] == '\n') {
                    p[-1] = '\0';
                    --len;
                }
                wpng_info.desc = textbuf + TEXT_DESC_OFFSET;
                wpng_info.have_text |= TEXT_DESC;
                p = textbuf + TEXT_DESC_OFFSET;
                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {
                    fprintf(stderr, "    " PROGNAME " warning:  character code"
                      " %u is %sdiscouraged by the PNG\n    specification "
                      "[first occurrence was at character position #%d]\n",
                      (unsigned)p[result], (p[result] == 27)? "strongly " : "",
                      result+1);
                    fflush(stderr);
#ifdef FORBID_LATIN1_CTRL
                    wpng_info.have_text &= ~TEXT_DESC;
                    valid = FALSE;
#else
                    if (p[result] == 27) {	/* escape character */
                        wpng_info.have_text &= ~TEXT_DESC;
                        valid = FALSE;
                    }
#endif
                }
            }
        } while (!valid);

        do {
            valid = TRUE;
            p = textbuf + TEXT_COPY_OFFSET;
            fprintf(stderr, "  Copyright: ");
            fflush(stderr);
            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {
                if (p[len-1] == '\n')
                    p[--len] = '\0';
                wpng_info.copyright = p;
                wpng_info.have_text |= TEXT_COPY;
                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {
                    fprintf(stderr, "    " PROGNAME " warning:  character code"
                      " %u is %sdiscouraged by the PNG\n    specification "
                      "[first occurrence was at character position #%d]\n",
                      (unsigned)p[result], (p[result] == 27)? "strongly " : "",
                      result+1);
                    fflush(stderr);
#ifdef FORBID_LATIN1_CTRL
                    wpng_info.have_text &= ~TEXT_COPY;
                    valid = FALSE;
#else
                    if (p[result] == 27) {	/* escape character */
                        wpng_info.have_text &= ~TEXT_COPY;
                        valid = FALSE;
                    }
#endif
                }
            }
        } while (!valid);

        do {
            valid = TRUE;
            p = textbuf + TEXT_EMAIL_OFFSET;
            fprintf(stderr, "  E-mail: ");
            fflush(stderr);
            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {
                if (p[len-1] == '\n')
                    p[--len] = '\0';
                wpng_info.email = p;
                wpng_info.have_text |= TEXT_EMAIL;
                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {
                    fprintf(stderr, "    " PROGNAME " warning:  character code"
                      " %u is %sdiscouraged by the PNG\n    specification "
                      "[first occurrence was at character position #%d]\n",
                      (unsigned)p[result], (p[result] == 27)? "strongly " : "",
                      result+1);
                    fflush(stderr);
#ifdef FORBID_LATIN1_CTRL
                    wpng_info.have_text &= ~TEXT_EMAIL;
                    valid = FALSE;
#else
                    if (p[result] == 27) {	/* escape character */
                        wpng_info.have_text &= ~TEXT_EMAIL;
                        valid = FALSE;
                    }
#endif
                }
            }
        } while (!valid);

        do {
            valid = TRUE;
            p = textbuf + TEXT_URL_OFFSET;
            fprintf(stderr, "  URL: ");
            fflush(stderr);
            if (FGETS(p, 74, keybd) && (len = strlen(p)) > 1) {
                if (p[len-1] == '\n')
                    p[--len] = '\0';
                wpng_info.url = p;
                wpng_info.have_text |= TEXT_URL;
                if ((result = wpng_isvalid_latin1((uch *)p, len)) >= 0) {
                    fprintf(stderr, "    " PROGNAME " warning:  character code"
                      " %u is %sdiscouraged by the PNG\n    specification "
                      "[first occurrence was at character position #%d]\n",
                      (unsigned)p[result], (p[result] == 27)? "strongly " : "",
                      result+1);
                    fflush(stderr);
#ifdef FORBID_LATIN1_CTRL
                    wpng_info.have_text &= ~TEXT_URL;
                    valid = FALSE;
#else
                    if (p[result] == 27) {	/* escape character */
                        wpng_info.have_text &= ~TEXT_URL;
                        valid = FALSE;
                    }
#endif
                }
            }
        } while (!valid);

#ifndef DOS_OS2_W32
        fclose(keybd);
#endif

    } else if (text) {
        fprintf(stderr, PROGNAME ":  unable to allocate memory for text\n");
        text = FALSE;
        wpng_info.have_text = 0;
    }


    /* allocate libpng stuff, initialize transformations, write pre-IDAT data */

    if ((rc = writepng_init(&wpng_info)) != 0) {
        switch (rc) {
            case 2:
                fprintf(stderr, PROGNAME
                  ":  libpng initialization problem (longjmp)\n");
                break;
            case 4:
                fprintf(stderr, PROGNAME ":  insufficient memory\n");
                break;
            case 11:
                fprintf(stderr, PROGNAME
                  ":  internal logic error (unexpected PNM type)\n");
                break;
            default:
                fprintf(stderr, PROGNAME
                  ":  unknown writepng_init() error\n");
                break;
        }
        exit(rc);
    }


    /* free textbuf, since it's a completely local variable and all text info
     * has just been written to the PNG file */

    if (text && textbuf) {
        free(textbuf);
        textbuf = NULL;
    }


    /* calculate rowbytes on basis of image type; note that this becomes much
     * more complicated if we choose to support PBM type, ASCII PNM types, or
     * 16-bit-per-sample binary data [currently not an official NetPBM type] */

    if (wpng_info.pnmtype == 5)
        rowbytes = wpng_info.width;
    else if (wpng_info.pnmtype == 6)
        rowbytes = wpng_info.width * 3;
    else /* if (wpng_info.pnmtype == 8) */
        rowbytes = wpng_info.width * 4;


    /* read and write the image, either in its entirety (if writing interlaced
     * PNG) or row by row (if non-interlaced) */

    fprintf(stderr, "Encoding image data...\n");
    fflush(stderr);

    if (wpng_info.interlaced) {
        long i;
        ulg bytes;
        ulg image_bytes = rowbytes * wpng_info.height;   /* overflow? */

        wpng_info.image_data = (uch *)malloc(image_bytes);
        wpng_info.row_pointers = (uch **)malloc(wpng_info.height*sizeof(uch *));
        if (wpng_info.image_data == NULL || wpng_info.row_pointers == NULL) {
            fprintf(stderr, PROGNAME ":  insufficient memory for image data\n");
            writepng_cleanup(&wpng_info);
            wpng_cleanup();
            exit(5);
        }
        for (i = 0;  i < wpng_info.height;  ++i)
            wpng_info.row_pointers[i] = wpng_info.image_data + i*rowbytes;
        bytes = fread(wpng_info.image_data, 1, image_bytes, wpng_info.infile);
        if (bytes != image_bytes) {
            fprintf(stderr, PROGNAME ":  expected %lu bytes, got %lu bytes\n",
              image_bytes, bytes);
            fprintf(stderr, "  (continuing anyway)\n");
        }
        if (writepng_encode_image(&wpng_info) != 0) {
            fprintf(stderr, PROGNAME
              ":  libpng problem (longjmp) while writing image data\n");
            writepng_cleanup(&wpng_info);
            wpng_cleanup();
            exit(2);
        }

    } else /* not interlaced:  write progressively (row by row) */ {
        long j;
        ulg bytes;

        wpng_info.image_data = (uch *)malloc(rowbytes);
        if (wpng_info.image_data == NULL) {
            fprintf(stderr, PROGNAME ":  insufficient memory for row data\n");
            writepng_cleanup(&wpng_info);
            wpng_cleanup();
            exit(5);
        }
        error = 0;
        for (j = wpng_info.height;  j > 0L;  --j) {
            bytes = fread(wpng_info.image_data, 1, rowbytes, wpng_info.infile);
            if (bytes != rowbytes) {
                fprintf(stderr, PROGNAME
                  ":  expected %lu bytes, got %lu bytes (row %ld)\n", rowbytes,
                  bytes, wpng_info.height-j);
                ++error;
                break;
            }
            if (writepng_encode_row(&wpng_info) != 0) {
                fprintf(stderr, PROGNAME
                  ":  libpng problem (longjmp) while writing row %ld\n",
                  wpng_info.height-j);
                ++error;
                break;
            }
        }
        if (error) {
            writepng_cleanup(&wpng_info);
            wpng_cleanup();
            exit(2);
        }
        if (writepng_encode_finish(&wpng_info) != 0) {
            fprintf(stderr, PROGNAME ":  error on final libpng call\n");
            writepng_cleanup(&wpng_info);
            wpng_cleanup();
            exit(2);
        }
    }


    /* OK, we're done (successfully):  clean up all resources and quit */

    fprintf(stderr, "Done.\n");
    fflush(stderr);

    writepng_cleanup(&wpng_info);
    wpng_cleanup();

    return 0;
}





static int wpng_isvalid_latin1(uch *p, int len)
{
    int i, result = -1;

    for (i = 0;  i < len;  ++i) {
        if (p[i] == 10 || (p[i] > 31 && p[i] < 127) || p[i] > 160)
            continue;		/* character is completely OK */
        if (result < 0 || (p[result] != 27 && p[i] == 27))
            result = i;		/* mark location of first questionable one */
    }                  		/*  or of first escape character (bad) */

    return result;
}





static void wpng_cleanup()
{
    if (wpng_info.outfile) {
        fclose(wpng_info.outfile);
        wpng_info.outfile = NULL;
    }

    if (wpng_info.infile) {
        fclose(wpng_info.infile);
        wpng_info.infile = NULL;
    }

    if (wpng_info.image_data) {
        free(wpng_info.image_data);
        wpng_info.image_data = NULL;
    }

    if (wpng_info.row_pointers) {
        free(wpng_info.row_pointers);
        wpng_info.row_pointers = NULL;
    }
}




#ifdef DOS_OS2_W32

static char *dos_kbd_gets(char *buf, int len)
{
    int ch, count=0;

    do {
        buf[count++] = ch = getche();
    } while (ch != '\r' && count < len-1);

    buf[count--] = '\0';	/* terminate string */
    if (buf[count] == '\r')	/* Enter key makes CR, so change to newline */
        buf[count] = '\n';

    fprintf(stderr, "\n");	/* Enter key does *not* cause a newline */
    fflush(stderr);

    return buf;
}

#endif /* DOS_OS2_W32 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\compress.cpp ===
/* compress.c -- compress a memory buffer
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

namespace D3DX
{

/* ===========================================================================
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/
int ZEXPORT compress2(
    Bytef *dest,
    uLongf *destLen,
    const Bytef *source,
    uLong sourceLen,
    int level)
{
    z_stream stream;
    int err;

    stream.next_in = (Bytef*)source;
    stream.avail_in = (uInt)sourceLen;
#ifdef MAXSEG_64K
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
#endif
    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;
    stream.opaque = (voidpf)0;

    err = deflateInit(&stream, level);
    if (err != Z_OK) return err;

    err = deflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        deflateEnd(&stream);
        return err == Z_OK ? Z_BUF_ERROR : err;
    }
    *destLen = stream.total_out;

    err = deflateEnd(&stream);
    return err;
}

/* ===========================================================================
 */
int ZEXPORT compress(
    Bytef *dest,
    uLongf *destLen,
    const Bytef *source,
    uLong sourceLen)
{
    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\contrib\gregbook\writepng.c ===
/*---------------------------------------------------------------------------

   wpng - simple PNG-writing program                             writepng.c

  ---------------------------------------------------------------------------

      Copyright (c) 1998-1999 Greg Roelofs.  All rights reserved.

      This software is provided "as is," without warranty of any kind,
      express or implied.  In no event shall the author or contributors
      be held liable for any damages arising in any way from the use of
      this software.

      Permission is granted to anyone to use this software for any purpose,
      including commercial applications, and to alter it and redistribute
      it freely, subject to the following restrictions:

      1. Redistributions of source code must retain the above copyright
         notice, disclaimer, and this list of conditions.
      2. Redistributions in binary form must reproduce the above copyright
         notice, disclaimer, and this list of conditions in the documenta-
         tion and/or other materials provided with the distribution.
      3. All advertising materials mentioning features or use of this
         software must display the following acknowledgment:

            This product includes software developed by Greg Roelofs
            and contributors for the book, "PNG: The Definitive Guide,"
            published by O'Reilly and Associates.

  ---------------------------------------------------------------------------*/


#include <stdlib.h>	/* for exit() prototype */

#include "png.h"	/* libpng header; includes zlib.h and setjmp.h */
#include "writepng.h"	/* typedefs, common macros, public prototypes */


/* local prototype */

static void writepng_error_handler(png_structp png_ptr, png_const_charp msg);



void writepng_version_info()
{
  fprintf(stderr, "   Compiled with libpng %s; using libpng %s.\n",
    PNG_LIBPNG_VER_STRING, png_libpng_ver);
  fprintf(stderr, "   Compiled with zlib %s; using zlib %s.\n",
    ZLIB_VERSION, zlib_version);
} 




/* returns 0 for success, 2 for libpng problem, 4 for out of memory, 11 for
 *  unexpected pnmtype; note that outfile might be stdout */

int writepng_init(mainprog_info *mainprog_ptr)
{
    png_structp  png_ptr;       /* note:  temporary variables! */
    png_infop  info_ptr;
    int color_type, interlace_type;


    /* could also replace libpng warning-handler (final NULL), but no need: */

    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, mainprog_ptr,
      writepng_error_handler, NULL);
    if (!png_ptr)
        return 4;   /* out of memory */

    info_ptr = png_create_info_struct(png_ptr);
    if (!info_ptr) {
        png_destroy_write_struct(&png_ptr, NULL);
        return 4;   /* out of memory */
    }


    /* setjmp() must be called in every function that calls a PNG-writing
     * libpng function, unless an alternate error handler was installed--
     * but compatible error handlers must either use longjmp() themselves
     * (as in this program) or exit immediately, so here we go: */

    if (setjmp(mainprog_ptr->jmpbuf)) {
        png_destroy_write_struct(&png_ptr, &info_ptr);
        return 2;
    }


    /* make sure outfile is (re)opened in BINARY mode */

    png_init_io(png_ptr, mainprog_ptr->outfile);


    /* set the compression levels--in general, always want to leave filtering
     * turned on (except for palette images) and allow all of the filters,
     * which is the default; want 32K zlib window, unless entire image buffer
     * is 16K or smaller (unknown here)--also the default; usually want max
     * compression (NOT the default); and remaining compression flags should
     * be left alone */

    png_set_compression_level(png_ptr, Z_BEST_COMPRESSION);
/*
    >> this is default for no filtering; Z_FILTERED is default otherwise:
    png_set_compression_strategy(png_ptr, Z_DEFAULT_STRATEGY);
    >> these are all defaults:
    png_set_compression_mem_level(png_ptr, 8);
    png_set_compression_window_bits(png_ptr, 15);
    png_set_compression_method(png_ptr, 8);
 */


    /* set the image parameters appropriately */

    if (mainprog_ptr->pnmtype == 5)
        color_type = PNG_COLOR_TYPE_GRAY;
    else if (mainprog_ptr->pnmtype == 6)
        color_type = PNG_COLOR_TYPE_RGB;
    else if (mainprog_ptr->pnmtype == 8)
        color_type = PNG_COLOR_TYPE_RGB_ALPHA;
    else {
        png_destroy_write_struct(&png_ptr, &info_ptr);
        return 11;
    }

    interlace_type = mainprog_ptr->interlaced? PNG_INTERLACE_ADAM7 :
                                               PNG_INTERLACE_NONE;

    png_set_IHDR(png_ptr, info_ptr, mainprog_ptr->width, mainprog_ptr->height,
      mainprog_ptr->sample_depth, color_type, interlace_type,
      PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);

    if (mainprog_ptr->gamma > 0.0)
        png_set_gAMA(png_ptr, info_ptr, mainprog_ptr->gamma);

    if (mainprog_ptr->have_bg) {   /* we know it's RGBA, not gray+alpha */
        png_color_16  background;

        background.red = mainprog_ptr->bg_red;
        background.green = mainprog_ptr->bg_green;
        background.blue = mainprog_ptr->bg_blue;
        png_set_bKGD(png_ptr, info_ptr, &background);
    }

    if (mainprog_ptr->have_time) {
        png_time  modtime;

        png_convert_from_time_t(&modtime, mainprog_ptr->modtime);
        png_set_tIME(png_ptr, info_ptr, &modtime);
    }

    if (mainprog_ptr->have_text) {
        png_text  text[6];
        int  num_text = 0;

        if (mainprog_ptr->have_text & TEXT_TITLE) {
            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
            text[num_text].key = "Title";
            text[num_text].text = mainprog_ptr->title;
            ++num_text;
        }
        if (mainprog_ptr->have_text & TEXT_AUTHOR) {
            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
            text[num_text].key = "Author";
            text[num_text].text = mainprog_ptr->author;
            ++num_text;
        }
        if (mainprog_ptr->have_text & TEXT_DESC) {
            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
            text[num_text].key = "Description";
            text[num_text].text = mainprog_ptr->desc;
            ++num_text;
        }
        if (mainprog_ptr->have_text & TEXT_COPY) {
            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
            text[num_text].key = "Copyright";
            text[num_text].text = mainprog_ptr->copyright;
            ++num_text;
        }
        if (mainprog_ptr->have_text & TEXT_EMAIL) {
            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
            text[num_text].key = "E-mail";
            text[num_text].text = mainprog_ptr->email;
            ++num_text;
        }
        if (mainprog_ptr->have_text & TEXT_URL) {
            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
            text[num_text].key = "URL";
            text[num_text].text = mainprog_ptr->url;
            ++num_text;
        }
        png_set_text(png_ptr, info_ptr, text, num_text);
    }


    /* write all chunks up to (but not including) first IDAT */

    png_write_info(png_ptr, info_ptr);


    /* if we wanted to write any more text info *after* the image data, we
     * would set up text struct(s) here and call png_set_text() again, with
     * just the new data; png_set_tIME() could also go here, but it would
     * have no effect since we already called it above (only one tIME chunk
     * allowed) */


    /* set up the transformations:  for now, just pack low-bit-depth pixels
     * into bytes (one, two or four pixels per byte) */

    png_set_packing(png_ptr);
/*  png_set_shift(png_ptr, &sig_bit);  to scale low-bit-depth values */


    /* make sure we save our pointers for use in writepng_encode_image() */

    mainprog_ptr->png_ptr = png_ptr;
    mainprog_ptr->info_ptr = info_ptr;


    /* OK, that's all we need to do for now; return happy */

    return 0;
}





/* returns 0 for success, 2 for libpng (longjmp) problem */

int writepng_encode_image(mainprog_info *mainprog_ptr)
{
    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;
    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;


    /* as always, setjmp() must be called in every function that calls a
     * PNG-writing libpng function */

    if (setjmp(mainprog_ptr->jmpbuf)) {
        png_destroy_write_struct(&png_ptr, &info_ptr);
        mainprog_ptr->png_ptr = NULL;
        mainprog_ptr->info_ptr = NULL;
        return 2;
    }


    /* and now we just write the whole image; libpng takes care of interlacing
     * for us */

    png_write_image(png_ptr, mainprog_ptr->row_pointers);


    /* since that's it, we also close out the end of the PNG file now--if we
     * had any text or time info to write after the IDATs, second argument
     * would be info_ptr, but we optimize slightly by sending NULL pointer: */

    png_write_end(png_ptr, NULL);

    return 0;
}





/* returns 0 if succeeds, 2 if libpng problem */

int writepng_encode_row(mainprog_info *mainprog_ptr)  /* NON-interlaced only! */
{
    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;
    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;


    /* as always, setjmp() must be called in every function that calls a
     * PNG-writing libpng function */

    if (setjmp(mainprog_ptr->jmpbuf)) {
        png_destroy_write_struct(&png_ptr, &info_ptr);
        mainprog_ptr->png_ptr = NULL;
        mainprog_ptr->info_ptr = NULL;
        return 2;
    }


    /* image_data points at our one row of image data */

    png_write_row(png_ptr, mainprog_ptr->image_data);

    return 0;
}





/* returns 0 if succeeds, 2 if libpng problem */

int writepng_encode_finish(mainprog_info *mainprog_ptr)   /* NON-interlaced! */
{
    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;
    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;


    /* as always, setjmp() must be called in every function that calls a
     * PNG-writing libpng function */

    if (setjmp(mainprog_ptr->jmpbuf)) {
        png_destroy_write_struct(&png_ptr, &info_ptr);
        mainprog_ptr->png_ptr = NULL;
        mainprog_ptr->info_ptr = NULL;
        return 2;
    }


    /* close out PNG file; if we had any text or time info to write after
     * the IDATs, second argument would be info_ptr: */

    png_write_end(png_ptr, NULL);

    return 0;
}





void writepng_cleanup(mainprog_info *mainprog_ptr)
{
    png_structp png_ptr = (png_structp)mainprog_ptr->png_ptr;
    png_infop info_ptr = (png_infop)mainprog_ptr->info_ptr;

    if (png_ptr && info_ptr)
        png_destroy_write_struct(&png_ptr, &info_ptr);
}





static void writepng_error_handler(png_structp png_ptr, png_const_charp msg)
{
    mainprog_info  *mainprog_ptr;

    /* This function, aside from the extra step of retrieving the "error
     * pointer" (below) and the fact that it exists within the application
     * rather than within libpng, is essentially identical to libpng's
     * default error handler.  The second point is critical:  since both
     * setjmp() and longjmp() are called from the same code, they are
     * guaranteed to have compatible notions of how big a jmp_buf is,
     * regardless of whether _BSD_SOURCE or anything else has (or has not)
     * been defined. */

    fprintf(stderr, "writepng libpng error: %s\n", msg);
    fflush(stderr);

    mainprog_ptr = png_get_error_ptr(png_ptr);
    if (mainprog_ptr == NULL) {         /* we are completely hosed now */
        fprintf(stderr,
          "writepng severe error:  jmpbuf not recoverable; terminating.\n");
        fflush(stderr);
        exit(99);
    }

    longjmp(mainprog_ptr->jmpbuf, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\adler32.cpp ===
/* adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

namespace D3DX
{

#define BASE 65521L /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
#define DO16(buf)   DO8(buf,0); DO8(buf,8);

/* ========================================================================= */
uLong ZEXPORT adler32(uLong adler, const Bytef *buf, uInt len)
{
    unsigned long s1 = adler & 0xffff;
    unsigned long s2 = (adler >> 16) & 0xffff;
    int k;

    if (buf == Z_NULL) return 1L;

    while (len > 0) {
        k = len < NMAX ? len : NMAX;
        len -= k;
        while (k >= 16) {
            DO16(buf);
	    buf += 16;
            k -= 16;
        }
        if (k != 0) do {
            s1 += *buf++;
	    s2 += s1;
        } while (--k);
        s1 %= BASE;
        s2 %= BASE;
    }
    return (s2 << 16) | s1;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\contrib\gregbook\rpng2-x.c ===
/*---------------------------------------------------------------------------

   rpng2 - progressive-model PNG display program                  rpng2-x.c 

   This program decodes and displays PNG files progressively, as if it were
   a web browser (though the front end is only set up to read from files).
   It supports gamma correction, user-specified background colors, and user-
   specified background patterns (for transparent images).  This version is
   for the X Window System (tested under Unix, but may work under VMS or OS/2
   with a little tweaking).  Thanks to Adam Costello and Pieter S. van der
   Meulen for the "diamond" and "radial waves" patterns, respectively.

   to do:
    - 8-bit support
    - finish resizable checkerboard-gradient (sizes 4-128?)
    - use %.1023s to simplify truncation of title-bar string?

  ---------------------------------------------------------------------------

      Copyright (c) 1998-1999 Greg Roelofs.  All rights reserved.

      This software is provided "as is," without warranty of any kind,
      express or implied.  In no event shall the author or contributors
      be held liable for any damages arising in any way from the use of
      this software.

      Permission is granted to anyone to use this software for any purpose,
      including commercial applications, and to alter it and redistribute
      it freely, subject to the following restrictions:

      1. Redistributions of source code must retain the above copyright
         notice, disclaimer, and this list of conditions.
      2. Redistributions in binary form must reproduce the above copyright
         notice, disclaimer, and this list of conditions in the documenta-
         tion and/or other materials provided with the distribution.
      3. All advertising materials mentioning features or use of this
         software must display the following acknowledgment:

            This product includes software developed by Greg Roelofs
            and contributors for the book, "PNG: The Definitive Guide,"
            published by O'Reilly and Associates.

  ---------------------------------------------------------------------------*/

#define PROGNAME  "rpng2-x"
#define LONGNAME  "Progressive PNG Viewer for X"
#define VERSION   "1.01 of 31 March 1999"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>	/* for jmpbuf declaration in readpng2.h */
#include <time.h>
#include <math.h>	/* only for PvdM background code */
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xos.h>
#include <X11/keysym.h>	/* defines XK_* macros */

/* all for PvdM background code: */
#ifndef PI
#  define PI             3.141592653589793238
#endif
#define PI_2             (PI*0.5)
#define INV_PI_360       (360.0 / PI)
#define MAX(a,b)         (a>b?a:b)
#define MIN(a,b)         (a<b?a:b)
#define CLIP(a,min,max)  MAX(min,MIN((a),max))
#define ABS(a)           ((a)<0?-(a):(a))
#define CLIP8P(c)        MAX(0,(MIN((c),255)))   /* 8-bit pos. integer (uch) */
#define ROUNDF(f)        ((int)(f + 0.5))

#define rgb1_max   bg_freq
#define rgb1_min   bg_gray
#define rgb2_max   bg_bsat
#define rgb2_min   bg_brot

/* #define DEBUG */	/* this enables the Trace() macros */

#include "readpng2.h"	/* typedefs, common macros, readpng2 prototypes */


/* could just include png.h, but this macro is the only thing we need
 * (name and typedefs changed to local versions); note that side effects
 * only happen with alpha (which could easily be avoided with
 * "ush acopy = (alpha);") */

#define alpha_composite(composite, fg, alpha, bg) {			\
    ush temp = ((ush)(fg)*(ush)(alpha) +				\
                (ush)(bg)*(ush)(255 - (ush)(alpha)) + (ush)128);	\
    (composite) = (uch)((temp + (temp >> 8)) >> 8);			\
}


#define INBUFSIZE 4096	/* with pseudo-timing on (1 sec delay/block), this
			 *  block size corresponds roughly to a download
			 *  speed 10% faster than theoretical 33.6K maximum
			 *  (assuming 8 data bits, 1 stop bit and no other
			 *  overhead) */

/* local prototypes */
static void rpng2_x_init(void);
static int  rpng2_x_create_window(void);
static int  rpng2_x_load_bg_image(void);
static void rpng2_x_display_row(ulg row);
static void rpng2_x_finish_display(void);
static void rpng2_x_cleanup(void);
static int  rpng2_x_msb(ulg u32val);


static char titlebar[1024], *window_name = titlebar;
static char *appname = LONGNAME;
static char *icon_name = PROGNAME;
static char *filename;
static FILE *infile;

static mainprog_info rpng2_info;

static uch inbuf[INBUFSIZE];
static int incount;

static int pat = 6;		/* must be less than num_bgpat */
static int bg_image = 0;
static int bgscale = 16;
static ulg bg_rowbytes;
static uch *bg_data;

static struct rgb_color {
    uch r, g, b;
} rgb[] = {
    {  0,   0,   0},	/*  0:  black */
    {255, 255, 255},	/*  1:  white */
    {173, 132,  57},	/*  2:  tan */
    { 64, 132,   0},	/*  3:  medium green */
    {189, 117,   1},	/*  4:  gold */
    {253, 249,   1},	/*  5:  yellow */
    {  0,   0, 255},	/*  6:  blue */
    {  0,   0, 120},	/*  7:  medium blue */
    {255,   0, 255},	/*  8:  magenta */
    { 64,   0,  64},	/*  9:  dark magenta */
    {255,   0,   0},	/* 10:  red */
    { 64,   0,   0},	/* 11:  dark red */
    {255, 127,   0},	/* 12:  orange */
    {192,  96,   0},	/* 13:  darker orange */
    { 24,  60,   0},	/* 14:  dark green-yellow */
    { 85, 125, 200} 	/* 15:  ice blue */
};
/* not used for now, but should be for error-checking:
static int num_rgb = sizeof(rgb) / sizeof(struct rgb_color);
 */

/*
    This whole struct is a fairly cheesy way to keep the number of
    command-line options to a minimum.  The radial-waves background
    type is a particularly poor fit to the integer elements of the
    struct...but a few macros and a little fixed-point math will do
    wonders for ya.

    type bits:
       F E D C B A 9 8 7 6 5 4 3 2 1 0
                             | | | | |
                             | | +-+-+-- 0 = sharp-edged checkerboard
                             | |         1 = soft diamonds
                             | |         2 = radial waves
                             | |       3-7 = undefined
                             | +-- gradient #2 inverted?
                             +-- alternating columns inverted?
 */
static struct background_pattern {
    ush type;
    int rgb1_max, rgb1_min;	/* or bg_freq, bg_gray */
    int rgb2_max, rgb2_min;	/* or bg_bsat, bg_brot (both scaled by 10)*/
} bg[] = {
    {0+8,   2,0,  1,15},  	/* checkered:  tan/black vs. white/ice blue */
    {0+24,  2,0,  1,0},  	/* checkered:  tan/black vs. white/black */
    {0+8,   4,5,  0,2},  	/* checkered:  gold/yellow vs. black/tan */
    {0+8,   4,5,  0,6},  	/* checkered:  gold/yellow vs. black/blue */
    {0,     7,0,  8,9},  	/* checkered:  deep blue/black vs. magenta */
    {0+8,  13,0,  5,14},  	/* checkered:  orange/black vs. yellow */
    {0+8,  12,0, 10,11},  	/* checkered:  orange/black vs. red */
    {1,     7,0,  8,0},  	/* diamonds:  deep blue/black vs. magenta */
    {1,    12,0, 11,0},  	/* diamonds:  orange vs. dark red */
    {1,    10,0,  7,0},  	/* diamonds:  red vs. medium blue */
    {1,     4,0,  5,0},  	/* diamonds:  gold vs. yellow */
    {1,     3,0,  0,0},  	/* diamonds:  medium green vs. black */
    {2,    16, 100,  20,   0},  /* radial:  ~hard radial color-beams */
    {2,    18, 100,  10,   2},  /* radial:  soft, curved radial color-beams */
    {2,    16, 256, 100, 250},  /* radial:  very tight spiral */
    {2, 10000, 256,  11,   0}   /* radial:  dipole-moire' (almost fractal) */
};
static int num_bgpat = sizeof(bg) / sizeof(struct background_pattern);


/* X-specific variables */
static char *displayname;
static XImage *ximage;
static Display *display;
static int depth;
static Visual *visual;
static int RPixelShift, GPixelShift, BPixelShift;
static ulg RedMask, GreenMask, BlueMask;
static Window window;
static GC gc;
static Colormap colormap;

static int have_colormap = FALSE;
static int have_window = FALSE;




int main(int argc, char **argv)
{
#ifdef sgi
    char tmpline[80];
#endif
    char *p, *bgstr = NULL;
    int rc, alen, flen;
    int error = 0;
    int timing = FALSE;
    int have_bg = FALSE;
    double LUT_exponent;                /* just the lookup table */
    double CRT_exponent = 2.2;          /* just the monitor */
    double default_display_exponent;    /* whole display system */
    XEvent e;
    KeySym k;


    /* First initialize a few things, just to be sure--memset takes care of
     * default background color (black), booleans (FALSE), pointers (NULL),
     * etc. */

    displayname = (char *)NULL;
    filename = (char *)NULL;
    memset(&rpng2_info, 0, sizeof(mainprog_info));


    /* Set the default value for our display-system exponent, i.e., the
     * product of the CRT exponent and the exponent corresponding to
     * the frame-buffer's lookup table (LUT), if any.  This is not an
     * exhaustive list of LUT values (e.g., OpenStep has a lot of weird
     * ones), but it should cover 99% of the current possibilities. */

#if defined(NeXT)
    /* third-party utilities can modify the default LUT exponent */
    LUT_exponent = 1.0 / 2.2;
    /*
    if (some_next_function_that_returns_gamma(&next_gamma))
        LUT_exponent = 1.0 / next_gamma;
     */
#elif defined(sgi)
    LUT_exponent = 1.0 / 1.7;
    /* there doesn't seem to be any documented function to
     * get the "gamma" value, so we do it the hard way */
    infile = fopen("/etc/config/system.glGammaVal", "r");
    if (infile) {
        double sgi_gamma;

        fgets(tmpline, 80, infile);
        fclose(infile);
        sgi_gamma = atof(tmpline);
        if (sgi_gamma > 0.0)
            LUT_exponent = 1.0 / sgi_gamma;
    }
#elif defined(Macintosh)
    LUT_exponent = 1.8 / 2.61;
    /*
    if (some_mac_function_that_returns_gamma(&mac_gamma))
        LUT_exponent = mac_gamma / 2.61;
     */
#else
    LUT_exponent = 1.0;   /* assume no LUT:  most PCs */
#endif

    /* the defaults above give 1.0, 1.3, 1.5 and 2.2, respectively: */
    default_display_exponent = LUT_exponent * CRT_exponent;


    /* If the user has set the SCREEN_GAMMA environment variable as suggested
     * (somewhat imprecisely) in the libpng documentation, use that; otherwise
     * use the default value we just calculated.  Either way, the user may
     * override this via a command-line option. */

    if ((p = getenv("SCREEN_GAMMA")) != NULL)
        rpng2_info.display_exponent = atof(p);
    else
        rpng2_info.display_exponent = default_display_exponent;


    /* Now parse the command line for options and the PNG filename. */

    while (*++argv && !error) {
        if (!strcmp(*argv, "-display")) {
            if (!*++argv)
                ++error;
            displayname = *argv;
        } else if (!strcmp(*argv, "-gamma")) {
            if (!*++argv)
                ++error;
            rpng2_info.display_exponent = atof(*argv);
            if (rpng2_info.display_exponent <= 0.0)
                ++error;
        } else if (!strcmp(*argv, "-bgcolor")) {
            if (!*++argv)
                ++error;
            bgstr = *argv;
            if (strlen(bgstr) != 7 || bgstr[0] != '#')
                ++error;
            else {
                have_bg = TRUE;
                bg_image = FALSE;
            }
        } else if (!strcmp(*argv, "-bgpat")) {
            if (!*++argv)
                ++error;
            pat = atoi(*argv) - 1;
            if (pat < 0 || pat >= num_bgpat)
                ++error;
            else {
                bg_image = TRUE;
                have_bg = FALSE;
            }
        } else if (!strcmp(*argv, "-timing")) {
            timing = TRUE;
        } else {
            if (**argv != '-') {
                filename = *argv;
                if (argv[1])   /* shouldn't be any more args after filename */
                    ++error;
            } else
                ++error;   /* not expecting any other options */
        }
    }

    if (!filename) {
        ++error;
    } else if (!(infile = fopen(filename, "rb"))) {
        fprintf(stderr, PROGNAME ":  can't open PNG file [%s]\n", filename);
        ++error;
    } else {
        incount = fread(inbuf, 1, INBUFSIZE, infile);
        if (incount < 8 || !readpng2_check_sig(inbuf, 8)) {
            fprintf(stderr, PROGNAME
              ":  [%s] is not a PNG file: incorrect signature\n",
              filename);
            ++error;
        } else if ((rc = readpng2_init(&rpng2_info)) != 0) {
            switch (rc) {
                case 2:
                    fprintf(stderr, PROGNAME
                      ":  [%s] has bad IHDR (libpng longjmp)\n",
                      filename);
                    break;
                case 4:
                    fprintf(stderr, PROGNAME ":  insufficient memory\n");
                    break;
                default:
                    fprintf(stderr, PROGNAME
                      ":  unknown readpng2_init() error\n");
                    break;
            }
            ++error;
        } else {
            display = XOpenDisplay(displayname);
            if (!display) {
                readpng2_cleanup(&rpng2_info);
                fprintf(stderr, PROGNAME ":  can't open X display [%s]\n",
                  displayname? displayname : "default");
                ++error;
            }
        }
        if (error)
            fclose(infile);
    }

    if (error) {
        fprintf(stderr, "\n%s %s:  %s\n", PROGNAME, VERSION, appname);
        readpng2_version_info();
        fprintf(stderr, "\n"
          "Usage:  %s [-display xdpy] [-gamma exp] [-bgcolor bg | -bgpat pat]\n"
          "        %*s [-timing] file.png\n\n"
          "    xdpy\tname of the target X display (e.g., ``hostname:0'')\n"
          "    exp \ttransfer-function exponent (``gamma'') of the display\n"
          "\t\t  system in floating-point format (e.g., ``%.1f''); equal\n"
          "\t\t  to the product of the lookup-table exponent (varies)\n"
          "\t\t  and the CRT exponent (usually 2.2); must be positive\n"
          "    bg  \tdesired background color in 7-character hex RGB format\n"
          "\t\t  (e.g., ``#ff7f00'' for orange:  same as HTML colors);\n"
          "\t\t  used with transparent images; overrides -bgpat\n"
          "    pat \tdesired background pattern number (1-%d); used with\n"
          "\t\t  transparent images; overrides -bgcolor\n"
          "    -timing\tenables delay for every block read, to simulate modem\n"
          "\t\t  download of image (~36 Kbps)\n"
          "\nPress Q, Esc or mouse button 1 after image is displayed to quit.\n"
          "\n", PROGNAME, strlen(PROGNAME), " ", default_display_exponent,
          num_bgpat);
        exit(1);
    }


    /* set the title-bar string, but make sure buffer doesn't overflow */

    alen = strlen(appname);
    flen = strlen(filename);
    if (alen + flen + 3 > 1023)
        sprintf(titlebar, "%s:  ...%s", appname, filename+(alen+flen+6-1023));
    else
        sprintf(titlebar, "%s:  %s", appname, filename);


    /* set some final rpng2_info variables before entering main data loop */

    if (have_bg) {
        unsigned r, g, b;   /* this approach quiets compiler warnings */

        sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b);
        rpng2_info.bg_red   = (uch)r;
        rpng2_info.bg_green = (uch)g;
        rpng2_info.bg_blue  = (uch)b;
    } else
        rpng2_info.need_bgcolor = TRUE;

    rpng2_info.done = FALSE;
    rpng2_info.mainprog_init = rpng2_x_init;
    rpng2_info.mainprog_display_row = rpng2_x_display_row;
    rpng2_info.mainprog_finish_display = rpng2_x_finish_display;


    /* OK, this is the fun part:  call readpng2_decode_data() at the start of
     * the loop to deal with our first buffer of data (read in above to verify
     * that the file is a PNG image), then loop through the file and continue
     * calling the same routine to handle each chunk of data.  It in turn
     * passes the data to libpng, which will invoke one or more of our call-
     * backs as decoded data become available.  We optionally call sleep() for
     * one second per iteration to simulate downloading the image via an analog
     * modem. */

    for (;;) {
        Trace((stderr, "about to call readpng2_decode_data()\n"))
        if (readpng2_decode_data(&rpng2_info, inbuf, incount))
            ++error;
        Trace((stderr, "done with readpng2_decode_data()\n"))
        if (error || feof(infile) || rpng2_info.done)
            break;
        if (timing)
            sleep(1);
        incount = fread(inbuf, 1, INBUFSIZE, infile);
    }


    /* clean up PNG stuff and report any decoding errors */

    fclose(infile);
    Trace((stderr, "about to call readpng2_cleanup()\n"))
    readpng2_cleanup(&rpng2_info);

    if (error) {
        fprintf(stderr, PROGNAME ":  libpng error while decoding PNG image\n");
        exit(3);
    }


    /* wait for the user to tell us when to quit */

    do
        XNextEvent(display, &e);
    while (!(e.type == ButtonPress && e.xbutton.button == Button1) &&
           !(e.type == KeyPress &&    /*  v--- or 1 for shifted keys */
             ((k = XLookupKeysym(&e.xkey, 0)) == XK_q || k == XK_Escape) ));


    /* we're done:  clean up all image and X resources and go away */

    Trace((stderr, "about to call rpng2_x_cleanup()\n"))
    rpng2_x_cleanup();

    return 0;
}





/* this function is called by readpng2_info_callback() in readpng2.c, which
 * in turn is called by libpng after all of the pre-IDAT chunks have been
 * read and processed--i.e., we now have enough info to finish initializing */

static void rpng2_x_init()
{
    ulg i;
    ulg rowbytes = rpng2_info.rowbytes;

    Trace((stderr, "beginning rpng2_x_init()\n"))
    Trace((stderr, "  rowbytes = %ld\n", rpng2_info.rowbytes))
    Trace((stderr, "  width  = %ld\n", rpng2_info.width))
    Trace((stderr, "  height = %ld\n", rpng2_info.height))

    rpng2_info.image_data = (uch *)malloc(rowbytes * rpng2_info.height);
    if (!rpng2_info.image_data) {
        readpng2_cleanup(&rpng2_info);
        return;
    }

    rpng2_info.row_pointers = (uch **)malloc(rpng2_info.height * sizeof(uch *));
    if (!rpng2_info.row_pointers) {
        free(rpng2_info.image_data);
        rpng2_info.image_data = NULL;
        readpng2_cleanup(&rpng2_info);
        return;
    }

    for (i = 0;  i < rpng2_info.height;  ++i)
        rpng2_info.row_pointers[i] = rpng2_info.image_data + i*rowbytes;


    /* do the basic X initialization stuff, make the window, and fill it with
     * the user-specified, file-specified or default background color or
     * pattern */

    if (rpng2_x_create_window()) {
        readpng2_cleanup(&rpng2_info);
        return;
    }
}





static int rpng2_x_create_window()
{
    ulg bg_red   = rpng2_info.bg_red;
    ulg bg_green = rpng2_info.bg_green;
    ulg bg_blue  = rpng2_info.bg_blue;
    ulg bg_pixel = 0L;
    int screen, pad;
    uch *xdata;
    Window root;
    XEvent e;
    XGCValues gcvalues;
    XSetWindowAttributes attr;
    XSizeHints *size_hints;
    XTextProperty windowName, *pWindowName = &windowName;
    XTextProperty iconName, *pIconName = &iconName;
    XVisualInfo visual_info;
    XWMHints *wm_hints;


    Trace((stderr, "beginning rpng2_x_create_window()\n"))

    screen = DefaultScreen(display);
    depth = DisplayPlanes(display, screen);
    root = RootWindow(display, screen);

/* GRR:  add 8-bit support */
    if (/* depth != 8 && */ depth != 16 && depth != 24 && depth != 32) {
        fprintf(stderr,
          "screen depth %d not supported (only 16-, 24- or 32-bit TrueColor)\n",
          depth);
        return 2;
    }

    XMatchVisualInfo(display, screen, depth,
      (depth == 8)? PseudoColor : TrueColor, &visual_info);
    visual = visual_info.visual;

    RedMask   = visual->red_mask;
    GreenMask = visual->green_mask;
    BlueMask  = visual->blue_mask;

/* GRR:  add/check 8-bit support */
    if (depth == 8) {
        colormap = XCreateColormap(display, root, visual, AllocNone);
        if (!colormap) {
            fprintf(stderr, "XCreateColormap() failed\n");
            return 2;
        }
        have_colormap = TRUE;
        bg_image = FALSE;	/* gradient just wastes palette entries */
    } else if (depth == 16) {
        RPixelShift = 15 - rpng2_x_msb(RedMask);   /* these are right-shifts */
        GPixelShift = 15 - rpng2_x_msb(GreenMask);
        BPixelShift = 15 - rpng2_x_msb(BlueMask);
    } else /* if (depth > 16) */ {
        RPixelShift = rpng2_x_msb(RedMask) - 7;    /* these are left-shifts */
        GPixelShift = rpng2_x_msb(GreenMask) - 7;
        BPixelShift = rpng2_x_msb(BlueMask) - 7;
    }

/*---------------------------------------------------------------------------
    Finally, create the window.
  ---------------------------------------------------------------------------*/

    attr.backing_store = Always;
    attr.event_mask = ExposureMask | KeyPressMask | ButtonPressMask;

    window = XCreateWindow(display, root, 0, 0, rpng2_info.width,
      rpng2_info.height, 0, depth, InputOutput, visual,
      CWBackingStore | CWEventMask, &attr);

    if (window == None) {
        fprintf(stderr, "XCreateWindow() failed\n");
        return 2;
    } else
        have_window = TRUE;

    if (depth == 8)
        XSetWindowColormap(display, window, colormap);

    if (!XStringListToTextProperty(&window_name, 1, pWindowName))
        pWindowName = NULL;
    if (!XStringListToTextProperty(&icon_name, 1, pIconName))
        pIconName = NULL;

    /* OK if either hints allocation fails; XSetWMProperties() allows NULLs */

    if ((size_hints = XAllocSizeHints()) != NULL) {
        /* window will not be resizable */
        size_hints->flags = PMinSize | PMaxSize;
        size_hints->min_width = size_hints->max_width = rpng2_info.width;
        size_hints->min_height = size_hints->max_height = rpng2_info.height;
    }

    if ((wm_hints = XAllocWMHints()) != NULL) {
        wm_hints->initial_state = NormalState;
        wm_hints->input = True;
     /* wm_hints->icon_pixmap = icon_pixmap; */
        wm_hints->flags = StateHint | InputHint  /* | IconPixmapHint */ ;
    }

    XSetWMProperties(display, window, pWindowName, pIconName, NULL, 0,
      size_hints, wm_hints, NULL);

    XMapWindow(display, window);

    gc = XCreateGC(display, window, 0, &gcvalues);

/*---------------------------------------------------------------------------
    Allocate memory for the X- and display-specific version of the image.
  ---------------------------------------------------------------------------*/

    if (depth == 24 || depth == 32) {
        xdata = (uch *)malloc(4*rpng2_info.width*rpng2_info.height);
        pad = 32;
    } else if (depth == 16) {
        xdata = (uch *)malloc(2*rpng2_info.width*rpng2_info.height);
        pad = 16;
    } else /* depth == 8 */ {
        xdata = (uch *)malloc(rpng2_info.width*rpng2_info.height);
        pad = 8;
    }

    if (!xdata) {
        fprintf(stderr, PROGNAME ":  unable to allocate image memory\n");
        return 4;
    }

    ximage = XCreateImage(display, visual, depth, ZPixmap, 0,
      (char *)xdata, rpng2_info.width, rpng2_info.height, pad, 0);

    if (!ximage) {
        fprintf(stderr, PROGNAME ":  XCreateImage() failed\n");
        free(xdata);
        return 3;
    }

    /* to avoid testing the bitmap order every pixel (or doubling the size of
     * the drawing routine with a giant if-test), we arbitrarily set the byte
     * order to MSBFirst and let Xlib worry about inverting things on little-
     * endian machines (e.g., Linux/x86, old VAXen, etc.)--this is not the
     * most efficient approach (the giant if-test would be better), but in
     * the interest of clarity, we'll take the easy way out... */

    ximage->byte_order = MSBFirst;

/*---------------------------------------------------------------------------
    Fill window with the specified background color (default is black) or
    faked "background image" (but latter is disabled if 8-bit; gradients
    just waste palette entries).
  ---------------------------------------------------------------------------*/

    if (bg_image)
        rpng2_x_load_bg_image();	/* resets bg_image if fails */

    if (!bg_image) {
        if (depth == 24 || depth == 32) {
            bg_pixel = (bg_red   << RPixelShift) |
                       (bg_green << GPixelShift) |
                       (bg_blue  << BPixelShift);
        } else if (depth == 16) {
            bg_pixel = (((bg_red   << 8) >> RPixelShift) & RedMask)   |
                       (((bg_green << 8) >> GPixelShift) & GreenMask) |
                       (((bg_blue  << 8) >> BPixelShift) & BlueMask);
        } else /* depth == 8 */ {

            /* GRR:  add 8-bit support */

        }
        XSetForeground(display, gc, bg_pixel);
        XFillRectangle(display, window, gc, 0, 0, rpng2_info.width,
          rpng2_info.height);
    }

/*---------------------------------------------------------------------------
    Wait for first Expose event to do any drawing, then flush and return.
  ---------------------------------------------------------------------------*/

    do
        XNextEvent(display, &e);
    while (e.type != Expose || e.xexpose.count);

    XFlush(display);

    return 0;

} /* end function rpng2_x_create_window() */





static int rpng2_x_load_bg_image()
{
    uch *src, *dest;
    uch r1, r2, g1, g2, b1, b2;
    uch r1_inv, r2_inv, g1_inv, g2_inv, b1_inv, b2_inv;
    int k, hmax, max;
    int xidx, yidx, yidx_max = (bgscale-1);
    int even_odd_vert, even_odd_horiz, even_odd;
    int invert_gradient2 = (bg[pat].type & 0x08);
    int invert_column;
    int ximage_rowbytes = ximage->bytes_per_line;
    ulg i, row;
    ulg pixel;

/*---------------------------------------------------------------------------
    Allocate buffer for fake background image to be used with transparent
    images; if this fails, revert to plain background color.
  ---------------------------------------------------------------------------*/

    bg_rowbytes = 3 * rpng2_info.width;
    bg_data = (uch *)malloc(bg_rowbytes * rpng2_info.height);
    if (!bg_data) {
        fprintf(stderr, PROGNAME
          ":  unable to allocate memory for background image\n");
        bg_image = 0;
        return 1;
    }

/*---------------------------------------------------------------------------
    Vertical gradients (ramps) in NxN squares, alternating direction and
    colors (N == bgscale).
  ---------------------------------------------------------------------------*/

    if ((bg[pat].type & 0x07) == 0) {
        uch r1_min  = rgb[bg[pat].rgb1_min].r;
        uch g1_min  = rgb[bg[pat].rgb1_min].g;
        uch b1_min  = rgb[bg[pat].rgb1_min].b;
        uch r2_min  = rgb[bg[pat].rgb2_min].r;
        uch g2_min  = rgb[bg[pat].rgb2_min].g;
        uch b2_min  = rgb[bg[pat].rgb2_min].b;
        int r1_diff = rgb[bg[pat].rgb1_max].r - r1_min;
        int g1_diff = rgb[bg[pat].rgb1_max].g - g1_min;
        int b1_diff = rgb[bg[pat].rgb1_max].b - b1_min;
        int r2_diff = rgb[bg[pat].rgb2_max].r - r2_min;
        int g2_diff = rgb[bg[pat].rgb2_max].g - g2_min;
        int b2_diff = rgb[bg[pat].rgb2_max].b - b2_min;

        for (row = 0;  row < rpng2_info.height;  ++row) {
            yidx = row % bgscale;
            even_odd_vert = (row / bgscale) & 1;

            r1 = r1_min + (r1_diff * yidx) / yidx_max;
            g1 = g1_min + (g1_diff * yidx) / yidx_max;
            b1 = b1_min + (b1_diff * yidx) / yidx_max;
            r1_inv = r1_min + (r1_diff * (yidx_max-yidx)) / yidx_max;
            g1_inv = g1_min + (g1_diff * (yidx_max-yidx)) / yidx_max;
            b1_inv = b1_min + (b1_diff * (yidx_max-yidx)) / yidx_max;

            r2 = r2_min + (r2_diff * yidx) / yidx_max;
            g2 = g2_min + (g2_diff * yidx) / yidx_max;
            b2 = b2_min + (b2_diff * yidx) / yidx_max;
            r2_inv = r2_min + (r2_diff * (yidx_max-yidx)) / yidx_max;
            g2_inv = g2_min + (g2_diff * (yidx_max-yidx)) / yidx_max;
            b2_inv = b2_min + (b2_diff * (yidx_max-yidx)) / yidx_max;

            dest = bg_data + row*bg_rowbytes;
            for (i = 0;  i < rpng2_info.width;  ++i) {
                even_odd_horiz = (i / bgscale) & 1;
                even_odd = even_odd_vert ^ even_odd_horiz;
                invert_column =
                  (even_odd_horiz && (bg[pat].type & 0x10));
                if (even_odd == 0) {		/* gradient #1 */
                    if (invert_column) {
                        *dest++ = r1_inv;
                        *dest++ = g1_inv;
                        *dest++ = b1_inv;
                    } else {
                        *dest++ = r1;
                        *dest++ = g1;
                        *dest++ = b1;
                    }
                } else {			/* gradient #2 */
                    if ((invert_column && invert_gradient2) ||
                        (!invert_column && !invert_gradient2))
                    {
                        *dest++ = r2;      /* not inverted or */
                        *dest++ = g2;      /*  doubly inverted */
                        *dest++ = b2;
                    } else {
                        *dest++ = r2_inv;
                        *dest++ = g2_inv;  /* singly inverted */
                        *dest++ = b2_inv;
                    }
                }
            }
        }

/*---------------------------------------------------------------------------
    Soft gradient-diamonds with scale = bgscale.  Code contributed by Adam
    M. Costello.
  ---------------------------------------------------------------------------*/

    } else if ((bg[pat].type & 0x07) == 1) {

        hmax = (bgscale-1)/2;	/* half the max weight of a color */
        max = 2*hmax;		/* the max weight of a color */

        r1 = rgb[bg[pat].rgb1_max].r;
        g1 = rgb[bg[pat].rgb1_max].g;
        b1 = rgb[bg[pat].rgb1_max].b;
        r2 = rgb[bg[pat].rgb2_max].r;
        g2 = rgb[bg[pat].rgb2_max].g;
        b2 = rgb[bg[pat].rgb2_max].b;

        for (row = 0;  row < rpng2_info.height;  ++row) {
            yidx = row % bgscale;
            if (yidx > hmax)
                yidx = bgscale-1 - yidx;
            dest = bg_data + row*bg_rowbytes;
            for (i = 0;  i < rpng2_info.width;  ++i) {
                xidx = i % bgscale;
                if (xidx > hmax)
                    xidx = bgscale-1 - xidx;
                k = xidx + yidx;
                *dest++ = (k*r1 + (max-k)*r2) / max;
                *dest++ = (k*g1 + (max-k)*g2) / max;
                *dest++ = (k*b1 + (max-k)*b2) / max;
            }
        }

/*---------------------------------------------------------------------------
    Radial "starburst" with azimuthal sinusoids; [eventually number of sinu-
    soids will equal bgscale?].  This one is slow but very cool.  Code con-
    tributed by Pieter S. van der Meulen (originally in Smalltalk).
  ---------------------------------------------------------------------------*/

    } else if ((bg[pat].type & 0x07) == 2) {
        uch ch;
        int ii, x, y, hw, hh, grayspot;
        double freq, rotate, saturate, gray, intensity;
        double angle=0.0, aoffset=0.0, maxDist, dist;
        double red=0.0, green=0.0, blue=0.0, hue, s, v, f, p, q, t;

        fprintf(stderr, "%s:  computing radial background...",
          PROGNAME);
        fflush(stderr);

        hh = rpng2_info.height / 2;
        hw = rpng2_info.width / 2;

        /* variables for radial waves:
         *   aoffset:  number of degrees to rotate hue [CURRENTLY NOT USED]
         *   freq:  number of color beams originating from the center
         *   grayspot:  size of the graying center area (anti-alias)
         *   rotate:  rotation of the beams as a function of radius
         *   saturate:  saturation of beams' shape azimuthally
         */
        angle = CLIP(angle, 0.0, 360.0);
        grayspot = CLIP(bg[pat].bg_gray, 1, (hh + hw));
        freq = MAX((double)bg[pat].bg_freq, 0.0);
        saturate = (double)bg[pat].bg_bsat * 0.1;
        rotate = (double)bg[pat].bg_brot * 0.1;
        gray = 0.0;
        intensity = 0.0;
        maxDist = (double)((hw*hw) + (hh*hh));

        for (row = 0;  row < rpng2_info.height;  ++row) {
            y = row - hh;
            dest = bg_data + row*bg_rowbytes;
            for (i = 0;  i < rpng2_info.width;  ++i) {
                x = i - hw;
                angle = (x == 0)? PI_2 : atan((double)y / (double)x);
                gray = (double)MAX(ABS(y), ABS(x)) / grayspot;
                gray = MIN(1.0, gray);
                dist = (double)((x*x) + (y*y)) / maxDist;
                intensity = cos((angle+(rotate*dist*PI)) * freq) *
                  gray * saturate;
                intensity = (MAX(MIN(intensity,1.0),-1.0) + 1.0) * 0.5;
                hue = (angle + PI) * INV_PI_360 + aoffset;
                s = gray * ((double)(ABS(x)+ABS(y)) / (double)(hw + hh));
                s = MIN(MAX(s,0.0), 1.0);
                v = MIN(MAX(intensity,0.0), 1.0);

                if (s == 0.0) {
                    ch = (uch)(v * 255.0);
                    *dest++ = ch;
                    *dest++ = ch;
                    *dest++ = ch;
                } else {
                    if ((hue < 0.0) || (hue >= 360.0))
                        hue -= (((int)(hue / 360.0)) * 360.0);
                    hue /= 60.0;
                    ii = (int)hue;
                    f = hue - (double)ii;
                    p = (1.0 - s) * v;
                    q = (1.0 - (s * f)) * v;
                    t = (1.0 - (s * (1.0 - f))) * v;
                    if      (ii == 0) { red = v; green = t; blue = p; }
                    else if (ii == 1) { red = q; green = v; blue = p; }
                    else if (ii == 2) { red = p; green = v; blue = t; }
                    else if (ii == 3) { red = p; green = q; blue = v; }
                    else if (ii == 4) { red = t; green = p; blue = v; }
                    else if (ii == 5) { red = v; green = p; blue = q; }
                    *dest++ = (uch)(red * 255.0);
                    *dest++ = (uch)(green * 255.0);
                    *dest++ = (uch)(blue * 255.0);
                }
            }
        }
        fprintf(stderr, "done.\n");
        fflush(stderr);
    }

/*---------------------------------------------------------------------------
    Blast background image to display buffer before beginning PNG decode.
  ---------------------------------------------------------------------------*/

    if (depth == 24 || depth == 32) {
        ulg red, green, blue;

        for (row = 0;  row < rpng2_info.height;  ++row) {
            src = bg_data + row*bg_rowbytes;
            dest = ximage->data + row*ximage_rowbytes;
            for (i = rpng2_info.width;  i > 0;  --i) {
                red   = *src++;
                green = *src++;
                blue  = *src++;
                pixel = (red   << RPixelShift) |
                        (green << GPixelShift) |
                        (blue  << BPixelShift);
                /* recall that we set ximage->byte_order = MSBFirst above */
                *dest++ = ((uch *)&pixel)[3];
                *dest++ = ((uch *)&pixel)[2];
                *dest++ = ((uch *)&pixel)[1];
                *dest++ = ((uch *)&pixel)[0];
            }
        }

    } else if (depth == 16) {
        ush red, green, blue;

        for (row = 0;  row < rpng2_info.height;  ++row) {
            src = bg_data + row*bg_rowbytes;
            dest = ximage->data + row*ximage_rowbytes;
            for (i = rpng2_info.width;  i > 0;  --i) {
                red   = ((ush)(*src) << 8);
                ++src;
                green = ((ush)(*src) << 8);
                ++src;
                blue  = ((ush)(*src) << 8);
                ++src;
                pixel = ((red   >> RPixelShift) & RedMask)   |
                        ((green >> GPixelShift) & GreenMask) |
                        ((blue  >> BPixelShift) & BlueMask);
                /* recall that we set ximage->byte_order = MSBFirst above */
                *dest++ = ((uch *)&pixel)[1];
                *dest++ = ((uch *)&pixel)[0];
            }
        }

    } else /* depth == 8 */ {

        /* GRR:  add 8-bit support */

    }

    XPutImage(display, window, gc, ximage, 0, 0, 0, 0, rpng2_info.width,
      rpng2_info.height);

    return 0;

} /* end function rpng2_x_load_bg_image() */





static void rpng2_x_display_row(ulg row)
{
    uch bg_red   = rpng2_info.bg_red;
    uch bg_green = rpng2_info.bg_green;
    uch bg_blue  = rpng2_info.bg_blue;
    uch *src, *src2=NULL, *dest;
    uch r, g, b, a;
    int ximage_rowbytes = ximage->bytes_per_line;
    ulg i, pixel;
    static int rows=0;
    static ulg firstrow;

/*---------------------------------------------------------------------------
    rows and firstrow simply track how many rows (and which ones) have not
    yet been displayed; alternatively, we could call XPutImage() for every
    row and not bother with the records-keeping.
  ---------------------------------------------------------------------------*/

    Trace((stderr, "beginning rpng2_x_display_row()\n"))

    if (rows == 0)
        firstrow = row;   /* first row not yet displayed */

    ++rows;   /* count of rows received but not yet displayed */

/*---------------------------------------------------------------------------
    Aside from the use of the rpng2_info struct, the lack of an outer loop
    (over rows) and moving the XPutImage() call outside the "if (depth)"
    tests, this routine is identical to rpng_x_display_image() in the non-
    progressive version of the program.
  ---------------------------------------------------------------------------*/

    if (depth == 24 || depth == 32) {
        ulg red, green, blue;

        src = rpng2_info.image_data + row*rpng2_info.rowbytes;
        if (bg_image)
            src2 = bg_data + row*bg_rowbytes;
        dest = ximage->data + row*ximage_rowbytes;
        if (rpng2_info.channels == 3) {
            for (i = rpng2_info.width;  i > 0;  --i) {
                red   = *src++;
                green = *src++;
                blue  = *src++;
                pixel = (red   << RPixelShift) |
                        (green << GPixelShift) |
                        (blue  << BPixelShift);
                /* recall that we set ximage->byte_order = MSBFirst */
                *dest++ = ((uch *)&pixel)[3];
                *dest++ = ((uch *)&pixel)[2];
                *dest++ = ((uch *)&pixel)[1];
                *dest++ = ((uch *)&pixel)[0];
            }
        } else /* if (rpng2_info.channels == 4) */ {
            for (i = rpng2_info.width;  i > 0;  --i) {
                r = *src++;
                g = *src++;
                b = *src++;
                a = *src++;
                if (bg_image) {
                    bg_red   = *src2++;
                    bg_green = *src2++;
                    bg_blue  = *src2++;
                }
                if (a == 255) {
                    red   = r;
                    green = g;
                    blue  = b;
                } else if (a == 0) {
                    red   = bg_red;
                    green = bg_green;
                    blue  = bg_blue;
                } else {
                    /* this macro (from png.h) composites the foreground
                     * and background values and puts the result into the
                     * first argument */
                    alpha_composite(red,   r, a, bg_red);
                    alpha_composite(green, g, a, bg_green);
                    alpha_composite(blue,  b, a, bg_blue);
                }
                pixel = (red   << RPixelShift) |
                        (green << GPixelShift) |
                        (blue  << BPixelShift);
                /* recall that we set ximage->byte_order = MSBFirst */
                *dest++ = ((uch *)&pixel)[3];
                *dest++ = ((uch *)&pixel)[2];
                *dest++ = ((uch *)&pixel)[1];
                *dest++ = ((uch *)&pixel)[0];
            }
        }

    } else if (depth == 16) {
        ush red, green, blue;

        src = rpng2_info.row_pointers[row];
        if (bg_image)
            src2 = bg_data + row*bg_rowbytes;
        dest = ximage->data + row*ximage_rowbytes;
        if (rpng2_info.channels == 3) {
            for (i = rpng2_info.width;  i > 0;  --i) {
                red   = ((ush)(*src) << 8);
                ++src;
                green = ((ush)(*src) << 8);
                ++src;
                blue  = ((ush)(*src) << 8);
                ++src;
                pixel = ((red   >> RPixelShift) & RedMask)   |
                        ((green >> GPixelShift) & GreenMask) |
                        ((blue  >> BPixelShift) & BlueMask);
                /* recall that we set ximage->byte_order = MSBFirst */
                *dest++ = ((uch *)&pixel)[1];
                *dest++ = ((uch *)&pixel)[0];
            }
        } else /* if (rpng2_info.channels == 4) */ {
            for (i = rpng2_info.width;  i > 0;  --i) {
                r = *src++;
                g = *src++;
                b = *src++;
                a = *src++;
                if (bg_image) {
                    bg_red   = *src2++;
                    bg_green = *src2++;
                    bg_blue  = *src2++;
                }
                if (a == 255) {
                    red   = ((ush)r << 8);
                    green = ((ush)g << 8);
                    blue  = ((ush)b << 8);
                } else if (a == 0) {
                    red   = ((ush)bg_red   << 8);
                    green = ((ush)bg_green << 8);
                    blue  = ((ush)bg_blue  << 8);
                } else {
                    /* this macro (from png.h) composites the foreground
                     * and background values and puts the result back into
                     * the first argument (== fg byte here:  safe) */
                    alpha_composite(r, r, a, bg_red);
                    alpha_composite(g, g, a, bg_green);
                    alpha_composite(b, b, a, bg_blue);
                    red   = ((ush)r << 8);
                    green = ((ush)g << 8);
                    blue  = ((ush)b << 8);
                }
                pixel = ((red   >> RPixelShift) & RedMask)   |
                        ((green >> GPixelShift) & GreenMask) |
                        ((blue  >> BPixelShift) & BlueMask);
                /* recall that we set ximage->byte_order = MSBFirst */
                *dest++ = ((uch *)&pixel)[1];
                *dest++ = ((uch *)&pixel)[0];
            }
        }

    } else /* depth == 8 */ {

        /* GRR:  add 8-bit support */

    }


/*---------------------------------------------------------------------------
    Display after every 16 rows or when on last row.  (Region may include
    previously displayed lines due to interlacing--i.e., not contiguous.)
  ---------------------------------------------------------------------------*/

    if ((rows & 0xf) == 0 || row == rpng2_info.height-1) {
        XPutImage(display, window, gc, ximage, 0, firstrow, 0, firstrow,
          rpng2_info.width, row - firstrow + 1);
        XFlush(display);
        rows = 0;
    }

}





static void rpng2_x_finish_display()
{
    Trace((stderr, "beginning rpng2_x_finish_display()\n"))

    /* last row has already been displayed by rpng2_x_display_row(), so we
     * have nothing to do here except set a flag and let the user know that
     * the image is done */

    rpng2_info.done = TRUE;
    printf("Done.  Press Q, Esc or mouse button 1 to quit.\n");
}





static void rpng2_x_cleanup()
{
    if (bg_image && bg_data) {
        free(bg_data);
        bg_data = NULL;
    }

    if (rpng2_info.image_data) {
        free(rpng2_info.image_data);
        rpng2_info.image_data = NULL;
    }

    if (rpng2_info.row_pointers) {
        free(rpng2_info.row_pointers);
        rpng2_info.row_pointers = NULL;
    }

    if (ximage) {
        if (ximage->data) {
            free(ximage->data);           /* we allocated it, so we free it */
            ximage->data = (char *)NULL;  /*  instead of XDestroyImage() */
        }
        XDestroyImage(ximage);
        ximage = NULL;
    }

    XFreeGC(display, gc);

    if (have_window)
        XDestroyWindow(display, window);

    if (have_colormap)
        XFreeColormap(display, colormap);
}





static int rpng2_x_msb(ulg u32val)
{
    int i;

    for (i = 31;  i >= 0;  --i) {
        if (u32val & 0x80000000L)
            break;
        u32val <<= 1;
    }
    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\lpng105\contrib\gregbook\writepng.h ===
/*---------------------------------------------------------------------------

   wpng - simple PNG-writing program                             writepng.h

  ---------------------------------------------------------------------------

      Copyright (c) 1998-1999 Greg Roelofs.  All rights reserved.

      This software is provided "as is," without warranty of any kind,
      express or implied.  In no event shall the author or contributors
      be held liable for any damages arising in any way from the use of
      this software.

      Permission is granted to anyone to use this software for any purpose,
      including commercial applications, and to alter it and redistribute
      it freely, subject to the following restrictions:

      1. Redistributions of source code must retain the above copyright
         notice, disclaimer, and this list of conditions.
      2. Redistributions in binary form must reproduce the above copyright
         notice, disclaimer, and this list of conditions in the documenta-
         tion and/or other materials provided with the distribution.
      3. All advertising materials mentioning features or use of this
         software must display the following acknowledgment:

            This product includes software developed by Greg Roelofs
            and contributors for the book, "PNG: The Definitive Guide,"
            published by O'Reilly and Associates.

  ---------------------------------------------------------------------------*/

#ifndef TRUE
#  define TRUE 1
#  define FALSE 0
#endif

#ifndef MAX
#  define MAX(a,b)  ((a) > (b)? (a) : (b))
#  define MIN(a,b)  ((a) < (b)? (a) : (b))
#endif

#ifdef DEBUG
#  define Trace(x)  {fprintf x ; fflush(stderr); fflush(stdout);}
#else
#  define Trace(x)  ;
#endif

#define TEXT_TITLE    0x01
#define TEXT_AUTHOR   0x02
#define TEXT_DESC     0x04
#define TEXT_COPY     0x08
#define TEXT_EMAIL    0x10
#define TEXT_URL      0x20

#define TEXT_TITLE_OFFSET        0
#define TEXT_AUTHOR_OFFSET      72
#define TEXT_COPY_OFFSET     (2*72)
#define TEXT_EMAIL_OFFSET    (3*72)
#define TEXT_URL_OFFSET      (4*72)
#define TEXT_DESC_OFFSET     (5*72)

typedef unsigned char   uch;
typedef unsigned short  ush;
typedef unsigned long   ulg;

typedef struct _mainprog_info {
    double gamma;
    long width;
    long height;
    time_t modtime;
    FILE *infile;
    FILE *outfile;
    void *png_ptr;
    void *info_ptr;
    uch *image_data;
    uch **row_pointers;
    char *title;
    char *author;
    char *desc;
    char *copyright;
    char *email;
    char *url;
    int filter;    /* command-line-filter flag, not PNG row filter! */
    int pnmtype;
    int sample_depth;
    int interlaced;
    int have_bg;
    int have_time;
    int have_text;
    jmp_buf jmpbuf;
    uch bg_red;
    uch bg_green;
    uch bg_blue;
} mainprog_info;


/* prototypes for public functions in writepng.c */

void writepng_version_info(void);

int writepng_init(mainprog_info *mainprog_ptr);

int writepng_encode_image(mainprog_info *mainprog_ptr);

int writepng_encode_row(mainprog_info *mainprog_ptr);

int writepng_encode_finish(mainprog_info *mainprog_ptr);

void writepng_cleanup(mainprog_info *mainprog_ptr);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\crc32.cpp ===
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

namespace D3DX
{

#define local static

#ifdef DYNAMIC_CRC_TABLE

local int crc_table_empty = 1;
local uLongf crc_table[256];
local void make_crc_table OF((void));

/*
  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The table is simply the CRC of all possible eight bit values.  This is all
  the information needed to generate CRC's on data a byte at a time for all
  combinations of CRC register values and incoming bytes.
*/
local void make_crc_table()
{
  uLong c;
  int n, k;
  uLong poly;            /* polynomial exclusive-or pattern */
  /* terms of polynomial defining this crc (except x^32): */
  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

  /* make exclusive-or pattern from polynomial (0xedb88320L) */
  poly = 0L;
  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
    poly |= 1L << (31 - p[n]);
 
  for (n = 0; n < 256; n++)
  {
    c = (uLong)n;
    for (k = 0; k < 8; k++)
      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
    crc_table[n] = c;
  }
  crc_table_empty = 0;
}
#else
/* ========================================================================
 * Table of CRC-32's of all single-byte values (made by make_crc_table)
 */
local const uLongf crc_table[256] = {
  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
  0x2d02ef8dL
};
#endif

/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const uLongf * ZEXPORT get_crc_table()
{
#ifdef DYNAMIC_CRC_TABLE
  if (crc_table_empty) make_crc_table();
#endif
  return (const uLongf *)crc_table;
}

/* ========================================================================= */
#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

/* ========================================================================= */
uLong ZEXPORT crc32(
    uLong crc,
    const Bytef *buf,
    uInt len)
{
    if (buf == Z_NULL) return 0L;
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = crc ^ 0xffffffffL;
    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
    }
    if (len) do {
      DO1(buf);
    } while (--len);
    return crc ^ 0xffffffffL;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\infblock.h ===
/* infblock.h -- header to use infblock.c
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

namespace D3DX
{

struct inflate_blocks_state;
typedef struct inflate_blocks_state FAR inflate_blocks_statef;

extern inflate_blocks_statef * inflate_blocks_new OF((
    z_streamp z,
    check_func c,               /* check function */
    uInt w));                   /* window size */

extern int inflate_blocks OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));                      /* initial return code */

extern void inflate_blocks_reset OF((
    inflate_blocks_statef *,
    z_streamp ,
    uLongf *));                  /* check value on output */

extern int inflate_blocks_free OF((
    inflate_blocks_statef *,
    z_streamp));

extern void inflate_set_dictionary OF((
    inflate_blocks_statef *s,
    const Bytef *d,  /* dictionary */
    uInt  n));       /* dictionary length */

extern int inflate_blocks_sync_point OF((
    inflate_blocks_statef *s));

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\deflate.h ===
/* deflate.h -- internal compression state
 * Copyright (C) 1995-1998 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef _DEFLATE_H
#define _DEFLATE_H

#include "zutil.h"

namespace D3DX 
{

/* ===========================================================================
 * Internal compression state.
 */

#define LENGTH_CODES 29
/* number of length codes, not counting the special END_BLOCK code */

#define LITERALS  256
/* number of literal bytes 0..255 */

#define L_CODES (LITERALS+1+LENGTH_CODES)
/* number of Literal or Length codes, including the END_BLOCK code */

#define D_CODES   30
/* number of distance codes */

#define BL_CODES  19
/* number of codes used to transfer the bit lengths */

#define HEAP_SIZE (2*L_CODES+1)
/* maximum heap size */

#define MAX_BITS 15
/* All codes must not exceed MAX_BITS bits */

#define INIT_STATE    42
#define BUSY_STATE   113
#define FINISH_STATE 666
/* Stream status */


/* Data structure describing a single value and its code string. */
typedef struct ct_data_s {
    union {
        ush  freq;       /* frequency count */
        ush  code;       /* bit string */
    } fc;
    union {
        ush  dad;        /* father node in Huffman tree */
        ush  len;        /* length of bit string */
    } dl;
} FAR ct_data;

#define Freq fc.freq
#define Code fc.code
#define Dad  dl.dad
#define Len  dl.len

typedef struct static_tree_desc_s  static_tree_desc;

typedef struct tree_desc_s {
    ct_data *dyn_tree;           /* the dynamic tree */
    int     max_code;            /* largest code with non zero frequency */
    static_tree_desc *stat_desc; /* the corresponding static tree */
} FAR tree_desc;

typedef ush Pos;
typedef Pos FAR Posf;
typedef unsigned IPos;

/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */

typedef struct internal_state {
    z_streamp strm;      /* pointer back to this zlib stream */
    int   status;        /* as the name implies */
    Bytef *pending_buf;  /* output still pending */
    ulg   pending_buf_size; /* size of pending_buf */
    Bytef *pending_out;  /* next pending byte to output to the stream */
    int   pending;       /* nb of bytes in the pending buffer */
    int   noheader;      /* suppress zlib header and adler32 */
    Byte  data_type;     /* UNKNOWN, BINARY or ASCII */
    Byte  method;        /* STORED (for zip only) or DEFLATED */
    int   last_flush;    /* value of flush param for previous deflate call */

                /* used by deflate.c: */

    uInt  w_size;        /* LZ77 window size (32K by default) */
    uInt  w_bits;        /* log2(w_size)  (8..16) */
    uInt  w_mask;        /* w_size - 1 */

    Bytef *window;
    /* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size. Also, it limits
     * the window size to 64K, which is quite useful on MSDOS.
     * To do: use the user input buffer as sliding window.
     */

    ulg window_size;
    /* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */

    Posf *prev;
    /* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */

    Posf *head; /* Heads of the hash chains or NIL. */

    uInt  ins_h;          /* hash index of string to be inserted */
    uInt  hash_size;      /* number of elements in hash table */
    uInt  hash_bits;      /* log2(hash_size) */
    uInt  hash_mask;      /* hash_size-1 */

    uInt  hash_shift;
    /* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH >= hash_bits
     */

    long block_start;
    /* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */

    uInt match_length;           /* length of best match */
    IPos prev_match;             /* previous match */
    int match_available;         /* set if previous match exists */
    uInt strstart;               /* start of string to insert */
    uInt match_start;            /* start of matching string */
    uInt lookahead;              /* number of valid bytes ahead in window */

    uInt prev_length;
    /* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */

    uInt max_chain_length;
    /* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */

    uInt max_lazy_match;
    /* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels >= 4.
     */
#   define max_insert_length  max_lazy_match
    /* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels <= 3.
     */

    int level;    /* compression level (1..9) */
    int strategy; /* favor or force Huffman coding*/

    uInt good_match;
    /* Use a faster search when the previous match is longer than this */

    int nice_match; /* Stop searching when current match exceeds this */

                /* used by trees.c: */
    /* Didn't use ct_data typedef below to supress compiler warning */
    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

    struct tree_desc_s l_desc;               /* desc. for literal tree */
    struct tree_desc_s d_desc;               /* desc. for distance tree */
    struct tree_desc_s bl_desc;              /* desc. for bit length tree */

    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
    int heap_len;               /* number of elements in the heap */
    int heap_max;               /* element of largest frequency */
    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */

    uch depth[2*L_CODES+1];
    /* Depth of each subtree used as tie breaker for trees of equal frequency
     */

    uchf *l_buf;          /* buffer for literals or lengths */

    uInt  lit_bufsize;
    /* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */

    uInt last_lit;      /* running index in l_buf */

    ushf *d_buf;
    /* Buffer for distances. To simplify the code, d_buf and l_buf have
     * the same number of elements. To use different lengths, an extra flag
     * array would be necessary.
     */

    ulg opt_len;        /* bit length of current block with optimal trees */
    ulg static_len;     /* bit length of current block with static trees */
    uInt matches;       /* number of string matches in current block */
    int last_eob_len;   /* bit length of EOB code for last block */

#ifdef DEBUG
    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
#endif

    ush bi_buf;
    /* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */
    int bi_valid;
    /* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */

} FAR deflate_state;

/* Output a byte on the stream.
 * IN assertion: there is enough room in pending_buf.
 */
#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}


#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */

        /* in trees.c */
void _tr_init         OF((deflate_state *s));
int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
			  int eof));
void _tr_align        OF((deflate_state *s));
void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
                          int eof));

#define d_code(dist) \
   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. _dist_code[256] and _dist_code[257] are never
 * used.
 */

#ifndef DEBUG
/* Inline versions of _tr_tally for speed: */

#if defined(GEN_TREES_H) || !defined(STDC)
  extern uch _length_code[];
  extern uch _dist_code[];
#else
  extern const uch _length_code[];
  extern const uch _dist_code[];
#endif

# define _tr_tally_lit(s, c, flush) \
  { uch cc = (c); \
    s->d_buf[s->last_lit] = 0; \
    s->l_buf[s->last_lit++] = cc; \
    s->dyn_ltree[cc].Freq++; \
    flush = (s->last_lit == s->lit_bufsize-1); \
   }
# define _tr_tally_dist(s, distance, length, flush) \
  { uch len = (length); \
    ush dist = (distance); \
    s->d_buf[s->last_lit] = dist; \
    s->l_buf[s->last_lit++] = len; \
    dist--; \
    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
    s->dyn_dtree[d_code(dist)].Freq++; \
    flush = (s->last_lit == s->lit_bufsize-1); \
  }
#else
# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
# define _tr_tally_dist(s, distance, length, flush) \
              flush = _tr_tally(s, distance, length) 
#endif

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\deflate.cpp ===
/* deflate.c -- compress data using the deflation algorithm
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process depends on being able to identify portions
 *      of the input text which are identical to earlier input (within a
 *      sliding window trailing behind the input currently being processed).
 *
 *      The most straightforward technique turns out to be the fastest for
 *      most input files: try all possible matches and select the longest.
 *      The key feature of this algorithm is that insertions into the string
 *      dictionary are very simple and thus fast, and deletions are avoided
 *      completely. Insertions are performed at each input character, whereas
 *      string matches are performed only when the previous match ends. So it
 *      is preferable to spend more time in matches to allow very fast string
 *      insertions and avoid deletions. The matching algorithm for small
 *      strings is inspired from that of Rabin & Karp. A brute force approach
 *      is used to find longer strings when a small match has been found.
 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
 *      (by Leonid Broukhis).
 *         A previous version of this file used a more sophisticated algorithm
 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
 *      time, but has a larger average cost, uses more memory and is patented.
 *      However the F&G algorithm may be faster for some highly redundant
 *      files if the parameter max_chain_length (described below) is too large.
 *
 *  ACKNOWLEDGEMENTS
 *
 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
 *      I found it in 'freeze' written by Leonid Broukhis.
 *      Thanks to many people for bug reports and testing.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
 *      Available in ftp://ds.internic.net/rfc/rfc1951.txt
 *
 *      A description of the Rabin and Karp algorithm is given in the book
 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
 *
 *      Fiala,E.R., and Greene,D.H.
 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
 *
 */

/* @(#) $Id$ */

#include "deflate.h"

namespace D3DX
{

const char deflate_copyright[] =
   " deflate 1.1.3 Copyright 1995-1998 Jean-loup Gailly ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */

/* ===========================================================================
 *  Function prototypes.
 */
typedef enum {
    need_more,      /* block not completed, need more input or more output */
    block_done,     /* block flush performed */
    finish_started, /* finish started, need only more output at next deflate */
    finish_done     /* finish done, accept no more input or output */
} block_state;

typedef block_state (*compress_func) OF((deflate_state *s, int flush));
/* Compression function. Returns the block state after the call. */

local void fill_window    OF((deflate_state *s));
local block_state deflate_stored OF((deflate_state *s, int flush));
local block_state deflate_fast   OF((deflate_state *s, int flush));
local block_state deflate_slow   OF((deflate_state *s, int flush));
local void lm_init        OF((deflate_state *s));
local void putShortMSB    OF((deflate_state *s, uInt b));
local void flush_pending  OF((z_streamp strm));
local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
#ifdef ASMV
      void match_init OF((void)); /* asm code initialization */
      uInt longest_match  OF((deflate_state *s, IPos cur_match));
#else
local uInt longest_match  OF((deflate_state *s, IPos cur_match));
#endif

#ifdef DEBUG
local  void check_match OF((deflate_state *s, IPos start, IPos match,
                            int length));
#endif

/* ===========================================================================
 * Local data
 */

#define NIL 0
/* Tail of hash chains */

#ifndef TOO_FAR
#  define TOO_FAR 4096
#endif
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */

#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
typedef struct config_s {
   ush good_length; /* reduce lazy search above this match length */
   ush max_lazy;    /* do not perform lazy search above this match length */
   ush nice_length; /* quit search above this match length */
   ush max_chain;
   compress_func func;
} config;

local const config configuration_table[10] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},

/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */

/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
 * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
 * meaning.
 */

#define EQUAL 0
/* result of memcmp for equal strings */

struct static_tree_desc_s {int dummy;}; /* for buggy compilers */

/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */
#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)


/* ===========================================================================
 * Insert string str in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * If this file is compiled with -DFASTEST, the compression level is forced
 * to 1, and no hash chains are maintained.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of str are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */
#ifdef FASTEST
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    match_head = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#else
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#endif

/* ===========================================================================
 * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
 * prev[] will be initialized on the fly.
 */
#define CLEAR_HASH(s) \
    s->head[s->hash_size-1] = NIL; \
    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));

/* ========================================================================= */
int ZEXPORT deflateInit_(
    z_streamp strm,
    int level,
    const char *version,
    int stream_size)
{
    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
			 Z_DEFAULT_STRATEGY, version, stream_size);
    /* To do: ignore strm->next_in if we use it as window */
}

/* ========================================================================= */
int ZEXPORT deflateInit2_(
    z_streamp strm,
    int  level,
    int  method,
    int  windowBits,
    int  memLevel,
    int  strategy,
    const char *version,
    int stream_size)
{
    deflate_state *s;
    int noheader = 0;
    static const char* my_version = ZLIB_VERSION;

    ushf *overlay;
    /* We overlay pending_buf and d_buf+l_buf. This works since the average
     * output size for (length,distance) codes is <= 24 bits.
     */

    if (version == Z_NULL || version[0] != my_version[0] ||
        stream_size != sizeof(z_stream)) {
	return Z_VERSION_ERROR;
    }
    if (strm == Z_NULL) return Z_STREAM_ERROR;

    strm->msg = Z_NULL;
    if (strm->zalloc == Z_NULL) {
	strm->zalloc = zcalloc;
	strm->opaque = (voidpf)0;
    }
    if (strm->zfree == Z_NULL) strm->zfree = zcfree;

    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#ifdef FASTEST
    level = 1;
#endif

    if (windowBits < 0) { /* undocumented feature: suppress zlib header */
        noheader = 1;
        windowBits = -windowBits;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
	strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
        return Z_STREAM_ERROR;
    }
    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
    if (s == Z_NULL) return Z_MEM_ERROR;
    strm->state = (struct internal_state FAR *)s;
    s->strm = strm;

    s->noheader = noheader;
    s->w_bits = windowBits;
    s->w_size = 1 << s->w_bits;
    s->w_mask = s->w_size - 1;

    s->hash_bits = memLevel + 7;
    s->hash_size = 1 << s->hash_bits;
    s->hash_mask = s->hash_size - 1;
    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
    s->pending_buf = (uchf *) overlay;
    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
        s->pending_buf == Z_NULL) {
        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
        deflateEnd (strm);
        return Z_MEM_ERROR;
    }
    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

    s->level = level;
    s->strategy = strategy;
    s->method = (Byte)method;

    return deflateReset(strm);
}

/* ========================================================================= */
int ZEXPORT deflateSetDictionary (
    z_streamp strm,
    const Bytef *dictionary,
    uInt  dictLength)
{
    deflate_state *s;
    uInt length = dictLength;
    uInt n;
    IPos hash_head = 0;

    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
        strm->state->status != INIT_STATE) return Z_STREAM_ERROR;

    s = strm->state;
    strm->adler = adler32(strm->adler, dictionary, dictLength);

    if (length < MIN_MATCH) return Z_OK;
    if (length > MAX_DIST(s)) {
	length = MAX_DIST(s);
#ifndef USE_DICT_HEAD
	dictionary += dictLength - length; /* use the tail of the dictionary */
#endif
    }
    zmemcpy(s->window, dictionary, length);
    s->strstart = length;
    s->block_start = (long)length;

    /* Insert all strings in the hash table (except for the last two bytes).
     * s->lookahead stays null, so s->ins_h will be recomputed at the next
     * call of fill_window.
     */
    s->ins_h = s->window[0];
    UPDATE_HASH(s, s->ins_h, s->window[1]);
    for (n = 0; n <= length - MIN_MATCH; n++) {
	INSERT_STRING(s, n, hash_head);
    }
    if (hash_head) hash_head = 0;  /* to make compiler happy */
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateReset (
    z_streamp strm)
{
    deflate_state *s;
    
    if (strm == Z_NULL || strm->state == Z_NULL ||
        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;

    strm->total_in = strm->total_out = 0;
    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
    strm->data_type = Z_UNKNOWN;

    s = (deflate_state *)strm->state;
    s->pending = 0;
    s->pending_out = s->pending_buf;

    if (s->noheader < 0) {
        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */
    }
    s->status = s->noheader ? BUSY_STATE : INIT_STATE;
    strm->adler = 1;
    s->last_flush = Z_NO_FLUSH;

    _tr_init(s);
    lm_init(s);

    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateParams(
    z_streamp strm,
    int level,
    int strategy)
{
    deflate_state *s;
    compress_func func;
    int err = Z_OK;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;

    if (level == Z_DEFAULT_COMPRESSION) {
	level = 6;
    }
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
	return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;

    if (func != configuration_table[level].func && strm->total_in != 0) {
	/* Flush the last buffer: */
	err = deflate(strm, Z_PARTIAL_FLUSH);
    }
    if (s->level != level) {
	s->level = level;
	s->max_lazy_match   = configuration_table[level].max_lazy;
	s->good_match       = configuration_table[level].good_length;
	s->nice_match       = configuration_table[level].nice_length;
	s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return err;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
local void putShortMSB (
    deflate_state *s,
    uInt b)
{
    put_byte(s, (Byte)(b >> 8));
    put_byte(s, (Byte)(b & 0xff));
}   

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->next_out buffer and copying into it.
 * (See also read_buf()).
 */
local void flush_pending(
    z_streamp strm)
{
    unsigned len = strm->state->pending;

    if (len > strm->avail_out) len = strm->avail_out;
    if (len == 0) return;

    zmemcpy(strm->next_out, strm->state->pending_out, len);
    strm->next_out  += len;
    strm->state->pending_out  += len;
    strm->total_out += len;
    strm->avail_out  -= len;
    strm->state->pending -= len;
    if (strm->state->pending == 0) {
        strm->state->pending_out = strm->state->pending_buf;
    }
}

/* ========================================================================= */
int ZEXPORT deflate (
    z_streamp strm,
    int flush)
{
    int old_flush; /* value of flush param for previous deflate call */
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL ||
	flush > Z_FINISH || flush < 0) {
        return Z_STREAM_ERROR;
    }
    s = strm->state;

    if (strm->next_out == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
	(s->status == FINISH_STATE && flush != Z_FINISH)) {
        ERR_RETURN(strm, Z_STREAM_ERROR);
    }
    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

    s->strm = strm; /* just in case */
    old_flush = s->last_flush;
    s->last_flush = flush;

    /* Write the zlib header */
    if (s->status == INIT_STATE) {

        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
        uInt level_flags = (s->level-1) >> 1;

        if (level_flags > 3) level_flags = 3;
        header |= (level_flags << 6);
	if (s->strstart != 0) header |= PRESET_DICT;
        header += 31 - (header % 31);

        s->status = BUSY_STATE;
        putShortMSB(s, header);

	/* Save the adler32 of the preset dictionary: */
	if (s->strstart != 0) {
	    putShortMSB(s, (uInt)(strm->adler >> 16));
	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
	}
	strm->adler = 1L;
    }

    /* Flush as much pending output as possible */
    if (s->pending != 0) {
        flush_pending(strm);
        if (strm->avail_out == 0) {
	    /* Since avail_out is 0, deflate will be called again with
	     * more output space, but possibly with both pending and
	     * avail_in equal to zero. There won't be anything to do,
	     * but this is not an error situation so make sure we
	     * return OK instead of BUF_ERROR at next call of deflate:
             */
	    s->last_flush = -1;
	    return Z_OK;
	}

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUFF_ERROR.
     */
    } else if (strm->avail_in == 0 && flush <= old_flush &&
	       flush != Z_FINISH) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* User must not provide more input after the first FINISH: */
    if (s->status == FINISH_STATE && strm->avail_in != 0) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* Start a new block or continue the current one.
     */
    if (strm->avail_in != 0 || s->lookahead != 0 ||
        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
        block_state bstate;

	bstate = (*(configuration_table[s->level].func))(s, flush);

        if (bstate == finish_started || bstate == finish_done) {
            s->status = FINISH_STATE;
        }
        if (bstate == need_more || bstate == finish_started) {
	    if (strm->avail_out == 0) {
	        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
	    }
	    return Z_OK;
	    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	     * of deflate should use the same flush parameter to make sure
	     * that the flush is complete. So we don't have to output an
	     * empty block here, this will be done at next call. This also
	     * ensures that for a very small output buffer, we emit at most
	     * one empty block.
	     */
	}
        if (bstate == block_done) {
            if (flush == Z_PARTIAL_FLUSH) {
                _tr_align(s);
            } else { /* FULL_FLUSH or SYNC_FLUSH */
                _tr_stored_block(s, (char*)0, 0L, 0);
                /* For a full flush, this empty block will be recognized
                 * as a special marker by inflate_sync().
                 */
                if (flush == Z_FULL_FLUSH) {
                    CLEAR_HASH(s);             /* forget history */
                }
            }
            flush_pending(strm);
	    if (strm->avail_out == 0) {
	      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	      return Z_OK;
	    }
        }
    }
    Assert(strm->avail_out > 0, "bug2");

    if (flush != Z_FINISH) return Z_OK;
    if (s->noheader) return Z_STREAM_END;

    /* Write the zlib trailer (adler32) */
    putShortMSB(s, (uInt)(strm->adler >> 16));
    putShortMSB(s, (uInt)(strm->adler & 0xffff));
    flush_pending(strm);
    /* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */
    s->noheader = -1; /* write the trailer only once! */
    return s->pending != 0 ? Z_OK : Z_STREAM_END;
}

/* ========================================================================= */
int ZEXPORT deflateEnd (
    z_streamp strm)
{
    int status;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

    status = strm->state->status;
    if (status != INIT_STATE && status != BUSY_STATE &&
	status != FINISH_STATE) {
      return Z_STREAM_ERROR;
    }

    /* Deallocate in reverse order of allocations: */
    TRY_FREE(strm, strm->state->pending_buf);
    TRY_FREE(strm, strm->state->head);
    TRY_FREE(strm, strm->state->prev);
    TRY_FREE(strm, strm->state->window);

    ZFREE(strm, strm->state);
    strm->state = Z_NULL;

    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
}

/* =========================================================================
 * Copy the source state to the destination state.
 * To simplify the source, this is not supported for 16-bit MSDOS (which
 * doesn't have enough memory anyway to duplicate compression states).
 */
int ZEXPORT deflateCopy (
    z_streamp dest,
    z_streamp source)
{
#ifdef MAXSEG_64K
    return Z_STREAM_ERROR;
#else
    deflate_state *ds;
    deflate_state *ss;
    ushf *overlay;


    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
        return Z_STREAM_ERROR;
    }

    ss = source->state;

    *dest = *source;

    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
    if (ds == Z_NULL) return Z_MEM_ERROR;
    dest->state = (struct internal_state FAR *) ds;
    *ds = *ss;
    ds->strm = dest;

    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
    ds->pending_buf = (uchf *) overlay;

    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
        ds->pending_buf == Z_NULL) {
        deflateEnd (dest);
        return Z_MEM_ERROR;
    }
    /* following zmemcpy do not work for 16-bit MSDOS */
    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

    ds->l_desc.dyn_tree = ds->dyn_ltree;
    ds->d_desc.dyn_tree = ds->dyn_dtree;
    ds->bl_desc.dyn_tree = ds->bl_tree;

    return Z_OK;
#endif
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->next_in buffer and copying from it.
 * (See also flush_pending()).
 */
local int read_buf(
    z_streamp strm,
    Bytef *buf,
    unsigned size)
{
    unsigned len = strm->avail_in;

    if (len > size) len = size;
    if (len == 0) return 0;

    strm->avail_in  -= len;

    if (!strm->state->noheader) {
        strm->adler = adler32(strm->adler, strm->next_in, len);
    }
    zmemcpy(buf, strm->next_in, len);
    strm->next_in  += len;
    strm->total_in += len;

    return (int)len;
}

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
local void lm_init (
    deflate_state *s)
{
    s->window_size = (ulg)2L*s->w_size;

    CLEAR_HASH(s);

    /* Set the default configuration parameters:
     */
    s->max_lazy_match   = configuration_table[s->level].max_lazy;
    s->good_match       = configuration_table[s->level].good_length;
    s->nice_match       = configuration_table[s->level].nice_length;
    s->max_chain_length = configuration_table[s->level].max_chain;

    s->strstart = 0;
    s->block_start = 0L;
    s->lookahead = 0;
    s->match_length = s->prev_length = MIN_MATCH-1;
    s->match_available = 0;
    s->ins_h = 0;
#ifdef ASMV
    match_init(); /* initialize the asm code */
#endif
}

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
#ifndef ASMV
/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
 * match.S. The code will be functionally equivalent.
 */
#ifndef FASTEST
local uInt longest_match(
    deflate_state *s,
    IPos cur_match)                            /* current match */
{
    unsigned chain_length = s->max_chain_length;/* max hash chain length */
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    int best_len = s->prev_length;              /* best match length so far */
    int nice_match = s->nice_match;             /* stop if match long enough */
    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
        s->strstart - (IPos)MAX_DIST(s) : NIL;
    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */
    Posf *prev = s->prev;
    uInt wmask = s->w_mask;

#ifdef UNALIGNED_OK
    /* Compare two bytes at a time. Note: this is not always beneficial.
     * Try with and without -DUNALIGNED_OK to check.
     */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
    register ush scan_start = *(ushf*)scan;
    register ush scan_end   = *(ushf*)(scan+best_len-1);
#else
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
    register Byte scan_end1  = scan[best_len-1];
    register Byte scan_end   = scan[best_len];
#endif

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    /* Do not waste too much time if we already have a good match: */
    if (s->prev_length >= s->good_match) {
        chain_length >>= 2;
    }
    /* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */
    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    do {
        Assert(cur_match < s->strstart, "no future");
        match = s->window + cur_match;

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2:
         */
#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
        /* This code assumes sizeof(unsigned short) == 2. Do not use
         * UNALIGNED_OK if your compiler uses a different size.
         */
        if (*(ushf*)(match+best_len-1) != scan_end ||
            *(ushf*)match != scan_start) continue;

        /* It is not necessary to compare scan[2] and match[2] since they are
         * always equal when the other bytes match, given that the hash keys
         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
         * strstart+3, +5, ... up to strstart+257. We check for insufficient
         * lookahead only every 4th comparison; the 128th check will be made
         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
         * necessary to put more guard bytes at the end of the window, or
         * to check more often for insufficient lookahead.
         */
        Assert(scan[2] == match[2], "scan[2]?");
        scan++, match++;
        do {
        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 scan < strend);
        /* The funny "do {}" generates better code on most compilers */

        /* Here, scan <= window+strstart+257 */
        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
        if (*scan == *match) scan++;

        len = (MAX_MATCH - 1) - (int)(strend-scan);
        scan = strend - (MAX_MATCH-1);

#else /* UNALIGNED_OK */

        if (match[best_len]   != scan_end  ||
            match[best_len-1] != scan_end1 ||
            *match            != *scan     ||
            *++match          != scan[1])      continue;

        /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
        scan += 2, match++;
        Assert(*scan == *match, "match[2]?");

        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
        do {
        } while (*++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 scan < strend);

        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

        len = MAX_MATCH - (int)(strend - scan);
        scan = strend - MAX_MATCH;

#endif /* UNALIGNED_OK */

        if (len > best_len) {
            s->match_start = cur_match;
            best_len = len;
            if (len >= nice_match) break;
#ifdef UNALIGNED_OK
            scan_end = *(ushf*)(scan+best_len-1);
#else
            scan_end1  = scan[best_len-1];
            scan_end   = scan[best_len];
#endif
        }
    } while ((cur_match = prev[cur_match & wmask]) > limit
             && --chain_length != 0);

    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
    return s->lookahead;
}

#else /* FASTEST */
/* ---------------------------------------------------------------------------
 * Optimized version for level == 1 only
 */
local uInt longest_match(
    deflate_state *s,
    IPos cur_match)                           /* current match */
{
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    Assert(cur_match < s->strstart, "no future");

    match = s->window + cur_match;

    /* Return failure if the match length is less than 2:
     */
    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2, match += 2;
    Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
    } while (*++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     scan < strend);

    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (int)(strend - scan);

    if (len < MIN_MATCH) return MIN_MATCH - 1;

    s->match_start = cur_match;
    return len <= s->lookahead ? len : s->lookahead;
}
#endif /* FASTEST */
#endif /* ASMV */

#ifdef DEBUG
/* ===========================================================================
 * Check that the match at match_start is indeed a match.
 */
local void check_match(
    deflate_state *s,
    IPos start, match,
    int length)
{
    /* check that the match is indeed a match */
    if (zmemcmp(s->window + match,
                s->window + start, length) != EQUAL) {
        fprintf(stderr, " start %u, match %u, length %d\n",
		start, match, length);
        do {
	    fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
	} while (--length != 0);
        z_error("invalid match");
    }
    if (z_verbose > 1) {
        fprintf(stderr,"\\[%d,%d]", start-match, length);
        do { putc(s->window[start++], stderr); } while (--length != 0);
    }
}
#else
#  define check_match(s, start, match, length)
#endif

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
local void fill_window(
    deflate_state *s)
{
    register unsigned n, m;
    register Posf *p;
    unsigned more;    /* Amount of free space at the end of the window. */
    uInt wsize = s->w_size;

    do {
        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

        /* Deal with !@#$% 64K limit: */
        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
            more = wsize;

        } else if (more == (unsigned)(-1)) {
            /* Very unlikely, but possible on 16 bit machine if strstart == 0
             * and lookahead == 1 (input done one byte at time)
             */
            more--;

        /* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */
        } else if (s->strstart >= wsize+MAX_DIST(s)) {

            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
            s->match_start -= wsize;
            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
            s->block_start -= (long) wsize;

            /* Slide the hash table (could be avoided with 32 bit values
               at the expense of memory usage). We slide even when level == 0
               to keep the hash table consistent if we switch back to level > 0
               later. (Using level 0 permanently is not an optimal usage of
               zlib, so we don't care about this pathological case.)
             */
	    n = s->hash_size;
	    p = &s->head[n];
	    do {
		m = *--p;
		*p = (Pos)(m >= wsize ? m-wsize : NIL);
	    } while (--n);

	    n = wsize;
#ifndef FASTEST
	    p = &s->prev[n];
	    do {
		m = *--p;
		*p = (Pos)(m >= wsize ? m-wsize : NIL);
		/* If n is not on any hash chain, prev[n] is garbage but
		 * its value will never be used.
		 */
	    } while (--n);
#endif
            more += wsize;
        }
        if (s->strm->avail_in == 0) return;

        /* If there was no sliding:
         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
         *    more == window_size - lookahead - strstart
         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * => more >= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &&
         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more >= 2.
         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
         */
        Assert(more >= 2, "more < 2");

        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
        s->lookahead += n;

        /* Initialize the hash value now that we have some input: */
        if (s->lookahead >= MIN_MATCH) {
            s->ins_h = s->window[s->strstart];
            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
            Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
        }
        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */

    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
}

/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */
#define FLUSH_BLOCK_ONLY(s, eof) { \
   _tr_flush_block(s, (s->block_start >= 0L ? \
                   (charf *)&s->window[(unsigned)s->block_start] : \
                   (charf *)Z_NULL), \
		(ulg)((long)s->strstart - s->block_start), \
		(eof)); \
   s->block_start = s->strstart; \
   flush_pending(s->strm); \
   Tracev((stderr,"[FLUSH]")); \
}

/* Same but force premature exit if necessary. */
#define FLUSH_BLOCK(s, eof) { \
   FLUSH_BLOCK_ONLY(s, eof); \
   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
local block_state deflate_stored(
    deflate_state *s,
    int flush)
{
    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
     * to pending_buf_size, and each stored block has a 5 byte header:
     */
    ulg max_block_size = 0xffff;
    ulg max_start;

    if (max_block_size > s->pending_buf_size - 5) {
        max_block_size = s->pending_buf_size - 5;
    }

    /* Copy as much as possible from input to output: */
    for (;;) {
        /* Fill the window as much as possible: */
        if (s->lookahead <= 1) {

            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
		   s->block_start >= (long)s->w_size, "slide too late");

            fill_window(s);
            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

            if (s->lookahead == 0) break; /* flush the current block */
        }
	Assert(s->block_start >= 0L, "block gone");

	s->strstart += s->lookahead;
	s->lookahead = 0;

	/* Emit a stored block if pending_buf will be full: */
 	max_start = s->block_start + max_block_size;
        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
	    /* strstart == 0 is possible when wraparound on 16-bit machine */
	    s->lookahead = (uInt)(s->strstart - max_start);
	    s->strstart = (uInt)max_start;
            FLUSH_BLOCK(s, 0);
	}
	/* Flush if we may have to slide, otherwise block_start may become
         * negative and the data will be gone:
         */
        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
            FLUSH_BLOCK(s, 0);
	}
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
local block_state deflate_fast(
    deflate_state *s,
    int flush)
{
    IPos hash_head = NIL; /* head of the hash chain */
    int bflush;           /* set if current block must be flushed */

    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
	        return need_more;
	    }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         * At this point we have always match_length < MIN_MATCH
         */
        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            if (s->strategy != Z_HUFFMAN_ONLY) {
                s->match_length = longest_match (s, hash_head);
            }
            /* longest_match() sets match_start */
        }
        if (s->match_length >= MIN_MATCH) {
            check_match(s, s->strstart, s->match_start, s->match_length);

            _tr_tally_dist(s, s->strstart - s->match_start,
                           s->match_length - MIN_MATCH, bflush);

            s->lookahead -= s->match_length;

            /* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */
#ifndef FASTEST
            if (s->match_length <= s->max_insert_length &&
                s->lookahead >= MIN_MATCH) {
                s->match_length--; /* string at strstart already in hash table */
                do {
                    s->strstart++;
                    INSERT_STRING(s, s->strstart, hash_head);
                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */
                } while (--s->match_length != 0);
                s->strstart++; 
            } else
#endif
	    {
                s->strstart += s->match_length;
                s->match_length = 0;
                s->ins_h = s->window[s->strstart];
                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
                Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                 * matter since it will be recomputed at next deflate call.
                 */
            }
        } else {
            /* No match, output a literal byte */
            Tracevv((stderr,"%c", s->window[s->strstart]));
            _tr_tally_lit (s, s->window[s->strstart], bflush);
            s->lookahead--;
            s->strstart++; 
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
local block_state deflate_slow(
    deflate_state *s,
    int flush)
{
    IPos hash_head = NIL;    /* head of hash chain */
    int bflush;              /* set if current block must be flushed */

    /* Process the input block. */
    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
	        return need_more;
	    }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         */
        s->prev_length = s->match_length, s->prev_match = s->match_start;
        s->match_length = MIN_MATCH-1;

        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
            s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            if (s->strategy != Z_HUFFMAN_ONLY) {
                s->match_length = longest_match (s, hash_head);
            }
            /* longest_match() sets match_start */

            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||
                 (s->match_length == MIN_MATCH &&
                  s->strstart - s->match_start > TOO_FAR))) {

                /* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */
                s->match_length = MIN_MATCH-1;
            }
        }
        /* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */
        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
            /* Do not insert strings in hash table beyond this. */

            check_match(s, s->strstart-1, s->prev_match, s->prev_length);

            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
			   s->prev_length - MIN_MATCH, bflush);

            /* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */
            s->lookahead -= s->prev_length-1;
            s->prev_length -= 2;
            do {
                if (++s->strstart <= max_insert) {
                    INSERT_STRING(s, s->strstart, hash_head);
                }
            } while (--s->prev_length != 0);
            s->match_available = 0;
            s->match_length = MIN_MATCH-1;
            s->strstart++;

            if (bflush) FLUSH_BLOCK(s, 0);

        } else if (s->match_available) {
            /* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */
            Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    _tr_tally_lit(s, s->window[s->strstart-1], bflush);
	    if (bflush) {
                FLUSH_BLOCK_ONLY(s, 0);
            }
            s->strstart++;
            s->lookahead--;
            if (s->strm->avail_out == 0) return need_more;
        } else {
            /* There is no previous match to compare with, wait for
             * the next step to decide.
             */
            s->match_available = 1;
            s->strstart++;
            s->lookahead--;
        }
    }
    Assert (flush != Z_NO_FLUSH, "no flush?");
    if (s->match_available) {
        Tracevv((stderr,"%c", s->window[s->strstart-1]));
        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
        s->match_available = 0;
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\example.cpp ===
/* example.c -- usage example of the zlib compression library
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include <stdio.h>
#include "zlib.h"

#ifdef STDC
#  include <string.h>
#  include <stdlib.h>
#else
   extern void exit  OF((int));
#endif

namespace D3DX
{

#if defined(VMS) || defined(RISCOS)
#  define TESTFILE "foo-gz"
#else
#  define TESTFILE "foo.gz"
#endif

#define CHECK_ERR(err, msg) { \
    if (err != Z_OK) { \
        fprintf(stderr, "%s error: %d\n", msg, err); \
        exit(1); \
    } \
}

const char hello[] = "hello, hello!";
/* "hello world" would be more standard, but the repeated "hello"
 * stresses the compression code better, sorry...
 */

const char dictionary[] = "hello";
uLong dictId; /* Adler32 value of the dictionary */

void test_compress      OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_gzio          OF((const char *out, const char *in, 
		            Byte *uncompr, int uncomprLen));
void test_deflate       OF((Byte *compr, uLong comprLen));
void test_inflate       OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_large_deflate OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_large_inflate OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_flush         OF((Byte *compr, uLong *comprLen));
void test_sync          OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_dict_deflate  OF((Byte *compr, uLong comprLen));
void test_dict_inflate  OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
int  main               OF((int argc, char *argv[]));

/* ===========================================================================
 * Test compress() and uncompress()
 */
void test_compress(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    uLong len = strlen(hello)+1;

    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, "compress");

    strcpy((char*)uncompr, "garbage");

    err = uncompress(uncompr, &uncomprLen, compr, comprLen);
    CHECK_ERR(err, "uncompress");

    if (strcmp((char*)uncompr, hello)) {
        fprintf(stderr, "bad uncompress\n");
	exit(1);
    } else {
        printf("uncompress(): %s\n", (char *)uncompr);
    }
}

/* ===========================================================================
 * Test read/write of .gz files
 */
void test_gzio(out, in, uncompr, uncomprLen)
    const char *out; /* compressed output file */
    const char *in;  /* compressed input file */
    Byte *uncompr;
    int  uncomprLen;
{
    int err;
    int len = strlen(hello)+1;
    gzFile file;
    z_off_t pos;

    file = gzopen(out, "wb");
    if (file == NULL) {
        fprintf(stderr, "gzopen error\n");
        exit(1);
    }
    gzputc(file, 'h');
    if (gzputs(file, "ello") != 4) {
        fprintf(stderr, "gzputs err: %s\n", gzerror(file, &err));
	exit(1);
    }
    if (gzprintf(file, ", %s!", "hello") != 8) {
        fprintf(stderr, "gzprintf err: %s\n", gzerror(file, &err));
	exit(1);
    }
    gzseek(file, 1L, SEEK_CUR); /* add one zero byte */
    gzclose(file);

    file = gzopen(in, "rb");
    if (file == NULL) {
        fprintf(stderr, "gzopen error\n");
    }
    strcpy((char*)uncompr, "garbage");

    uncomprLen = gzread(file, uncompr, (unsigned)uncomprLen);
    if (uncomprLen != len) {
        fprintf(stderr, "gzread err: %s\n", gzerror(file, &err));
	exit(1);
    }
    if (strcmp((char*)uncompr, hello)) {
        fprintf(stderr, "bad gzread: %s\n", (char*)uncompr);
	exit(1);
    } else {
        printf("gzread(): %s\n", (char *)uncompr);
    }

    pos = gzseek(file, -8L, SEEK_CUR);
    if (pos != 6 || gztell(file) != pos) {
	fprintf(stderr, "gzseek error, pos=%ld, gztell=%ld\n",
		(long)pos, (long)gztell(file));
	exit(1);
    }

    if (gzgetc(file) != ' ') {
	fprintf(stderr, "gzgetc error\n");
	exit(1);
    }

    gzgets(file, (char*)uncompr, uncomprLen);
    uncomprLen = strlen((char*)uncompr);
    if (uncomprLen != 6) { /* "hello!" */
        fprintf(stderr, "gzgets err after gzseek: %s\n", gzerror(file, &err));
	exit(1);
    }
    if (strcmp((char*)uncompr, hello+7)) {
        fprintf(stderr, "bad gzgets after gzseek\n");
	exit(1);
    } else {
        printf("gzgets() after gzseek: %s\n", (char *)uncompr);
    }

    gzclose(file);
}

/* ===========================================================================
 * Test deflate() with small buffers
 */
void test_deflate(compr, comprLen)
    Byte *compr;
    uLong comprLen;
{
    z_stream c_stream; /* compression stream */
    int err;
    int len = strlen(hello)+1;

    c_stream.zalloc = (alloc_func)0;
    c_stream.zfree = (free_func)0;
    c_stream.opaque = (voidpf)0;

    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
    CHECK_ERR(err, "deflateInit");

    c_stream.next_in  = (Bytef*)hello;
    c_stream.next_out = compr;

    while (c_stream.total_in != (uLong)len && c_stream.total_out < comprLen) {
        c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */
        err = deflate(&c_stream, Z_NO_FLUSH);
        CHECK_ERR(err, "deflate");
    }
    /* Finish the stream, still forcing small buffers: */
    for (;;) {
        c_stream.avail_out = 1;
        err = deflate(&c_stream, Z_FINISH);
        if (err == Z_STREAM_END) break;
        CHECK_ERR(err, "deflate");
    }

    err = deflateEnd(&c_stream);
    CHECK_ERR(err, "deflateEnd");
}

/* ===========================================================================
 * Test inflate() with small buffers
 */
void test_inflate(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, "garbage");

    d_stream.zalloc = (alloc_func)0;
    d_stream.zfree = (free_func)0;
    d_stream.opaque = (voidpf)0;

    d_stream.next_in  = compr;
    d_stream.avail_in = 0;
    d_stream.next_out = uncompr;

    err = inflateInit(&d_stream);
    CHECK_ERR(err, "inflateInit");

    while (d_stream.total_out < uncomprLen && d_stream.total_in < comprLen) {
        d_stream.avail_in = d_stream.avail_out = 1; /* force small buffers */
        err = inflate(&d_stream, Z_NO_FLUSH);
        if (err == Z_STREAM_END) break;
        CHECK_ERR(err, "inflate");
    }

    err = inflateEnd(&d_stream);
    CHECK_ERR(err, "inflateEnd");

    if (strcmp((char*)uncompr, hello)) {
        fprintf(stderr, "bad inflate\n");
	exit(1);
    } else {
        printf("inflate(): %s\n", (char *)uncompr);
    }
}

/* ===========================================================================
 * Test deflate() with large buffers and dynamic change of compression level
 */
void test_large_deflate(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    z_stream c_stream; /* compression stream */
    int err;

    c_stream.zalloc = (alloc_func)0;
    c_stream.zfree = (free_func)0;
    c_stream.opaque = (voidpf)0;

    err = deflateInit(&c_stream, Z_BEST_SPEED);
    CHECK_ERR(err, "deflateInit");

    c_stream.next_out = compr;
    c_stream.avail_out = (uInt)comprLen;

    /* At this point, uncompr is still mostly zeroes, so it should compress
     * very well:
     */
    c_stream.next_in = uncompr;
    c_stream.avail_in = (uInt)uncomprLen;
    err = deflate(&c_stream, Z_NO_FLUSH);
    CHECK_ERR(err, "deflate");
    if (c_stream.avail_in != 0) {
        fprintf(stderr, "deflate not greedy\n");
	exit(1);
    }

    /* Feed in already compressed data and switch to no compression: */
    deflateParams(&c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
    c_stream.next_in = compr;
    c_stream.avail_in = (uInt)comprLen/2;
    err = deflate(&c_stream, Z_NO_FLUSH);
    CHECK_ERR(err, "deflate");

    /* Switch back to compressing mode: */
    deflateParams(&c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
    c_stream.next_in = uncompr;
    c_stream.avail_in = (uInt)uncomprLen;
    err = deflate(&c_stream, Z_NO_FLUSH);
    CHECK_ERR(err, "deflate");

    err = deflate(&c_stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        fprintf(stderr, "deflate should report Z_STREAM_END\n");
	exit(1);
    }
    err = deflateEnd(&c_stream);
    CHECK_ERR(err, "deflateEnd");
}

/* ===========================================================================
 * Test inflate() with large buffers
 */
void test_large_inflate(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, "garbage");

    d_stream.zalloc = (alloc_func)0;
    d_stream.zfree = (free_func)0;
    d_stream.opaque = (voidpf)0;

    d_stream.next_in  = compr;
    d_stream.avail_in = (uInt)comprLen;

    err = inflateInit(&d_stream);
    CHECK_ERR(err, "inflateInit");

    for (;;) {
        d_stream.next_out = uncompr;            /* discard the output */
	d_stream.avail_out = (uInt)uncomprLen;
        err = inflate(&d_stream, Z_NO_FLUSH);
        if (err == Z_STREAM_END) break;
        CHECK_ERR(err, "large inflate");
    }

    err = inflateEnd(&d_stream);
    CHECK_ERR(err, "inflateEnd");

    if (d_stream.total_out != 2*uncomprLen + comprLen/2) {
        fprintf(stderr, "bad large inflate: %ld\n", d_stream.total_out);
	exit(1);
    } else {
        printf("large_inflate(): OK\n");
    }
}

/* ===========================================================================
 * Test deflate() with full flush
 */
void test_flush(compr, comprLen)
    Byte *compr;
    uLong *comprLen;
{
    z_stream c_stream; /* compression stream */
    int err;
    int len = strlen(hello)+1;

    c_stream.zalloc = (alloc_func)0;
    c_stream.zfree = (free_func)0;
    c_stream.opaque = (voidpf)0;

    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
    CHECK_ERR(err, "deflateInit");

    c_stream.next_in  = (Bytef*)hello;
    c_stream.next_out = compr;
    c_stream.avail_in = 3;
    c_stream.avail_out = (uInt)*comprLen;
    err = deflate(&c_stream, Z_FULL_FLUSH);
    CHECK_ERR(err, "deflate");

    compr[3]++; /* force an error in first compressed block */
    c_stream.avail_in = len - 3;

    err = deflate(&c_stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        CHECK_ERR(err, "deflate");
    }
    err = deflateEnd(&c_stream);
    CHECK_ERR(err, "deflateEnd");

    *comprLen = c_stream.total_out;
}

/* ===========================================================================
 * Test inflateSync()
 */
void test_sync(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, "garbage");

    d_stream.zalloc = (alloc_func)0;
    d_stream.zfree = (free_func)0;
    d_stream.opaque = (voidpf)0;

    d_stream.next_in  = compr;
    d_stream.avail_in = 2; /* just read the zlib header */

    err = inflateInit(&d_stream);
    CHECK_ERR(err, "inflateInit");

    d_stream.next_out = uncompr;
    d_stream.avail_out = (uInt)uncomprLen;

    inflate(&d_stream, Z_NO_FLUSH);
    CHECK_ERR(err, "inflate");

    d_stream.avail_in = (uInt)comprLen-2;   /* read all compressed data */
    err = inflateSync(&d_stream);           /* but skip the damaged part */
    CHECK_ERR(err, "inflateSync");

    err = inflate(&d_stream, Z_FINISH);
    if (err != Z_DATA_ERROR) {
        fprintf(stderr, "inflate should report DATA_ERROR\n");
        /* Because of incorrect adler32 */
	exit(1);
    }
    err = inflateEnd(&d_stream);
    CHECK_ERR(err, "inflateEnd");

    printf("after inflateSync(): hel%s\n", (char *)uncompr);
}

/* ===========================================================================
 * Test deflate() with preset dictionary
 */
void test_dict_deflate(compr, comprLen)
    Byte *compr;
    uLong comprLen;
{
    z_stream c_stream; /* compression stream */
    int err;

    c_stream.zalloc = (alloc_func)0;
    c_stream.zfree = (free_func)0;
    c_stream.opaque = (voidpf)0;

    err = deflateInit(&c_stream, Z_BEST_COMPRESSION);
    CHECK_ERR(err, "deflateInit");

    err = deflateSetDictionary(&c_stream,
			       (const Bytef*)dictionary, sizeof(dictionary));
    CHECK_ERR(err, "deflateSetDictionary");

    dictId = c_stream.adler;
    c_stream.next_out = compr;
    c_stream.avail_out = (uInt)comprLen;

    c_stream.next_in = (Bytef*)hello;
    c_stream.avail_in = (uInt)strlen(hello)+1;

    err = deflate(&c_stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        fprintf(stderr, "deflate should report Z_STREAM_END\n");
	exit(1);
    }
    err = deflateEnd(&c_stream);
    CHECK_ERR(err, "deflateEnd");
}

/* ===========================================================================
 * Test inflate() with a preset dictionary
 */
void test_dict_inflate(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, "garbage");

    d_stream.zalloc = (alloc_func)0;
    d_stream.zfree = (free_func)0;
    d_stream.opaque = (voidpf)0;

    d_stream.next_in  = compr;
    d_stream.avail_in = (uInt)comprLen;

    err = inflateInit(&d_stream);
    CHECK_ERR(err, "inflateInit");

    d_stream.next_out = uncompr;
    d_stream.avail_out = (uInt)uncomprLen;

    for (;;) {
        err = inflate(&d_stream, Z_NO_FLUSH);
        if (err == Z_STREAM_END) break;
	if (err == Z_NEED_DICT) {
	    if (d_stream.adler != dictId) {
		fprintf(stderr, "unexpected dictionary");
		exit(1);
	    }
	    err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,
				       sizeof(dictionary));
	}
        CHECK_ERR(err, "inflate with dict");
    }

    err = inflateEnd(&d_stream);
    CHECK_ERR(err, "inflateEnd");

    if (strcmp((char*)uncompr, hello)) {
        fprintf(stderr, "bad inflate with dict\n");
	exit(1);
    } else {
        printf("inflate with dictionary: %s\n", (char *)uncompr);
    }
}

/* ===========================================================================
 * Usage:  example [output.gz  [input.gz]]
 */

int main(argc, argv)
    int argc;
    char *argv[];
{
    Byte *compr, *uncompr;
    uLong comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */
    uLong uncomprLen = comprLen;
    static const char* myVersion = ZLIB_VERSION;

    if (zlibVersion()[0] != myVersion[0]) {
        fprintf(stderr, "incompatible zlib version\n");
        exit(1);

    } else if (strcmp(zlibVersion(), ZLIB_VERSION) != 0) {
        fprintf(stderr, "warning: different zlib version\n");
    }

    compr    = (Byte*)calloc((uInt)comprLen, 1);
    uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);
    /* compr and uncompr are cleared to avoid reading uninitialized
     * data and to ensure that uncompr compresses well.
     */
    if (compr == Z_NULL || uncompr == Z_NULL) {
        printf("out of memory\n");
	exit(1);
    }
    test_compress(compr, comprLen, uncompr, uncomprLen);

    test_gzio((argc > 1 ? argv[1] : TESTFILE),
              (argc > 2 ? argv[2] : TESTFILE),
	      uncompr, (int)uncomprLen);

    test_deflate(compr, comprLen);
    test_inflate(compr, comprLen, uncompr, uncomprLen);

    test_large_deflate(compr, comprLen, uncompr, uncomprLen);
    test_large_inflate(compr, comprLen, uncompr, uncomprLen);

    test_flush(compr, &comprLen);
    test_sync(compr, comprLen, uncompr, uncomprLen);
    comprLen = uncomprLen;

    test_dict_deflate(compr, comprLen);
    test_dict_inflate(compr, comprLen, uncompr, uncomprLen);

    exit(0);
    return 0; /* to avoid warning */
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\infcodes.cpp ===
/* infcodes.c -- process literals and length/distance pairs
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"
#include "infblock.h"
#include "infcodes.h"
#include "infutil.h"
#include "inffast.h"

namespace D3DX
{

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

typedef enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
      START,    /* x: set up for LEN */
      LEN,      /* i: get length/literal/eob next */
      LENEXT,   /* i: getting length extra (have base) */
      DIST,     /* i: get distance next */
      DISTEXT,  /* i: getting distance extra */
      COPY,     /* o: copying bytes in window, waiting for space */
      LIT,      /* o: got literal, waiting for output space */
      WASH,     /* o: got eob, possibly still output waiting */
      END,      /* x: got eob and all data flushed */
      BADCODE}  /* x: got error */
inflate_codes_mode;

/* inflate codes private state */
struct inflate_codes_state {

  /* mode */
  inflate_codes_mode mode;      /* current inflate_codes mode */

  /* mode dependent information */
  uInt len;
  union {
    struct {
      inflate_huft *tree;       /* pointer into tree */
      uInt need;                /* bits needed */
    } code;             /* if LEN or DIST, where in tree */
    uInt lit;           /* if LIT, literal */
    struct {
      uInt get;                 /* bits to get for extra */
      uInt dist;                /* distance back to copy from */
    } copy;             /* if EXT or COPY, where and how much */
  } sub;                /* submode */

  /* mode independent information */
  Byte lbits;           /* ltree bits decoded per branch */
  Byte dbits;           /* dtree bits decoder per branch */
  inflate_huft *ltree;          /* literal/length/eob tree */
  inflate_huft *dtree;          /* distance tree */

};


inflate_codes_statef *inflate_codes_new(
    uInt bl, 
    uInt bd,
    inflate_huft *tl,
    inflate_huft *td, /* need separate declaration for Borland C++ */
    z_streamp z)
{
  inflate_codes_statef *c;

  if ((c = (inflate_codes_statef *)
       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
  {
    c->mode = START;
    c->lbits = (Byte)bl;
    c->dbits = (Byte)bd;
    c->ltree = tl;
    c->dtree = td;
    Tracev((stderr, "inflate:       codes new\n"));
  }
  return c;
}


int inflate_codes(
    inflate_blocks_statef *s,
    z_streamp z,
    int r)
{
  uInt j;               /* temporary storage */
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  Bytef *f;             /* pointer to copy strings from */
  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD

  /* process input and output based on current state */
  while (1) switch (c->mode)
  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
    case START:         /* x: set up for LEN */
#ifndef SLOW
      if (m >= 258 && n >= 10)
      {
        UPDATE
        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
        LOAD
        if (r != Z_OK)
        {
          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
          break;
        }
      }
#endif /* !SLOW */
      c->sub.code.need = c->lbits;
      c->sub.code.tree = c->ltree;
      c->mode = LEN;
    case LEN:           /* i: get length/literal/eob next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
      if (e == 0)               /* literal */
      {
        c->sub.lit = t->base;
        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                 "inflate:         literal '%c'\n" :
                 "inflate:         literal 0x%02x\n", t->base));
        c->mode = LIT;
        break;
      }
      if (e & 16)               /* length */
      {
        c->sub.copy.get = e & 15;
        c->len = t->base;
        c->mode = LENEXT;
        break;
      }
      if ((e & 64) == 0)        /* next table */
      {
        c->sub.code.need = e;
        c->sub.code.tree = t + t->base;
        break;
      }
      if (e & 32)               /* end of block */
      {
        Tracevv((stderr, "inflate:         end of block\n"));
        c->mode = WASH;
        break;
      }
      c->mode = BADCODE;        /* invalid code */
      z->msg = (char*)"invalid literal/length code";
      r = Z_DATA_ERROR;
      LEAVE
    case LENEXT:        /* i: getting length extra (have base) */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->len += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
      c->sub.code.need = c->dbits;
      c->sub.code.tree = c->dtree;
      Tracevv((stderr, "inflate:         length %u\n", c->len));
      c->mode = DIST;
    case DIST:          /* i: get distance next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
      if (e & 16)               /* distance */
      {
        c->sub.copy.get = e & 15;
        c->sub.copy.dist = t->base;
        c->mode = DISTEXT;
        break;
      }
      if ((e & 64) == 0)        /* next table */
      {
        c->sub.code.need = e;
        c->sub.code.tree = t + t->base;
        break;
      }
      c->mode = BADCODE;        /* invalid code */
      z->msg = (char*)"invalid distance code";
      r = Z_DATA_ERROR;
      LEAVE
    case DISTEXT:       /* i: getting distance extra */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->sub.copy.dist += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
      c->mode = COPY;
    case COPY:          /* o: copying bytes in window, waiting for space */
#ifndef __TURBOC__ /* Turbo C bug for following expression */
      f = (uInt)(q - s->window) < c->sub.copy.dist ?
          s->end - (c->sub.copy.dist - (q - s->window)) :
          q - c->sub.copy.dist;
#else
      f = q - c->sub.copy.dist;
      if ((uInt)(q - s->window) < c->sub.copy.dist)
        f = s->end - (c->sub.copy.dist - (uInt)(q - s->window));
#endif
      while (c->len)
      {
        NEEDOUT
        OUTBYTE(*f++)
        if (f == s->end)
          f = s->window;
        c->len--;
      }
      c->mode = START;
      break;
    case LIT:           /* o: got literal, waiting for output space */
      NEEDOUT
      OUTBYTE(c->sub.lit)
      c->mode = START;
      break;
    case WASH:          /* o: got eob, possibly more output */
      if (k > 7)        /* return unused byte, if any */
      {
        Assert(k < 16, "inflate_codes grabbed too many bytes")
        k -= 8;
        n++;
        p--;            /* can always return one */
      }
      FLUSH
      if (s->read != s->write)
        LEAVE
      c->mode = END;
    case END:
      r = Z_STREAM_END;
      LEAVE
    case BADCODE:       /* x: got error */
      r = Z_DATA_ERROR;
      LEAVE
    default:
      r = Z_STREAM_ERROR;
      LEAVE
  }
#ifdef NEED_DUMMY_RETURN
  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
#endif
}


void inflate_codes_free(
    inflate_codes_statef *c,
    z_streamp z)
{
  ZFREE(z, c);
  Tracev((stderr, "inflate:       codes free\n"));
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\gzio.cpp ===
/* gzio.c -- IO on .gz files
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 *
 * Compile this file with -DNO_DEFLATE to avoid the compression code.
 */

/* @(#) $Id$ */

#include <stdio.h>
#include <stdarg.h>

#include "zutil.h"

namespace D3DX
{

struct internal_state {int dummy;}; /* for buggy compilers */

#ifndef Z_BUFSIZE
#  ifdef MAXSEG_64K
#    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */
#  else
#    define Z_BUFSIZE 16384
#  endif
#endif
#ifndef Z_PRINTF_BUFSIZE
#  define Z_PRINTF_BUFSIZE 4096
#endif

#define ALLOC(size) malloc(size)
#define TRYFREE(p) {if (p) free(p);}

static int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */

/* gzip flag byte */
#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
#define COMMENT      0x10 /* bit 4 set: file comment present */
#define RESERVED     0xE0 /* bits 5..7: reserved */

typedef struct gz_stream {
    z_stream stream;
    int      z_err;   /* error code for last stream operation */
    int      z_eof;   /* set if end of input file */
    FILE     *file;   /* .gz file */
    Byte     *inbuf;  /* input buffer */
    Byte     *outbuf; /* output buffer */
    uLong    crc;     /* crc32 of uncompressed data */
    char     *msg;    /* error message */
    char     *path;   /* path name for debugging only */
    int      transparent; /* 1 if input file is not a .gz file */
    char     mode;    /* 'w' or 'r' */
    long     startpos; /* start of compressed data in file (header skipped) */
} gz_stream;


local gzFile gz_open      OF((const char *path, const char *mode, int  fd));
local int do_flush        OF((gzFile file, int flush));
local int    get_byte     OF((gz_stream *s));
local void   check_header OF((gz_stream *s));
local int    destroy      OF((gz_stream *s));
local void   putLong      OF((FILE *file, uLong x));
local uLong  getLong      OF((gz_stream *s));

/* ===========================================================================
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb"). The file is given either by file descriptor
   or path name (if fd == -1).
     gz_open return NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).
*/
local gzFile gz_open (
    const char *path,
    const char *mode,
    int  fd)
{
    int err;
    int level = Z_DEFAULT_COMPRESSION; /* compression level */
    int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */
    char *p = (char*)mode;
    gz_stream *s;
    char fmode[80]; /* copy of mode, without the compression level */
    char *m = fmode;

    if (!path || !mode) return Z_NULL;

    s = (gz_stream *)ALLOC(sizeof(gz_stream));
    if (!s) return Z_NULL;

    s->stream.zalloc = (alloc_func)0;
    s->stream.zfree = (free_func)0;
    s->stream.opaque = (voidpf)0;
    s->stream.next_in = s->inbuf = Z_NULL;
    s->stream.next_out = s->outbuf = Z_NULL;
    s->stream.avail_in = s->stream.avail_out = 0;
    s->file = NULL;
    s->z_err = Z_OK;
    s->z_eof = 0;
    s->crc = crc32(0L, Z_NULL, 0);
    s->msg = NULL;
    s->transparent = 0;

    s->path = (char*)ALLOC(strlen(path)+1);
    if (s->path == NULL) {
        return destroy(s), (gzFile)Z_NULL;
    }
    strcpy(s->path, path); /* do this early for debugging */

    s->mode = '\0';
    do {
        if (*p == 'r') s->mode = 'r';
        if (*p == 'w' || *p == 'a') s->mode = 'w';
        if (*p >= '0' && *p <= '9') {
	    level = *p - '0';
	} else if (*p == 'f') {
	  strategy = Z_FILTERED;
	} else if (*p == 'h') {
	  strategy = Z_HUFFMAN_ONLY;
	} else {
	    *m++ = *p; /* copy the mode */
	}
    } while (*p++ && m != fmode + sizeof(fmode));
    if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;
    
    if (s->mode == 'w') {
#ifdef NO_DEFLATE
        err = Z_STREAM_ERROR;
#else
        err = deflateInit2(&(s->stream), level,
                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);
        /* windowBits is passed < 0 to suppress zlib header */

        s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
#endif
        if (err != Z_OK || s->outbuf == Z_NULL) {
            return destroy(s), (gzFile)Z_NULL;
        }
    } else {
        s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);

        err = inflateInit2(&(s->stream), -MAX_WBITS);
        /* windowBits is passed < 0 to tell that there is no zlib header.
         * Note that in this case inflate *requires* an extra "dummy" byte
         * after the compressed stream in order to complete decompression and
         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
         * present after the compressed stream.
         */
        if (err != Z_OK || s->inbuf == Z_NULL) {
            return destroy(s), (gzFile)Z_NULL;
        }
    }
    s->stream.avail_out = Z_BUFSIZE;

    errno = 0;
    s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);

    if (s->file == NULL) {
        return destroy(s), (gzFile)Z_NULL;
    }
    if (s->mode == 'w') {
        /* Write a very simple .gz header:
         */
        fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],
             Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);
	s->startpos = 10L;
	/* We use 10L instead of ftell(s->file) to because ftell causes an
         * fflush on some systems. This version of the library doesn't use
         * startpos anyway in write mode, so this initialization is not
         * necessary.
         */
    } else {
	check_header(s); /* skip the .gz header */
	s->startpos = (ftell(s->file) - s->stream.avail_in);
    }
    
    return (gzFile)s;
}

/* ===========================================================================
     Opens a gzip (.gz) file for reading or writing.
*/
gzFile ZEXPORT gzopen (
    const char *path,
    const char *mode)
{
    return gz_open (path, mode, -1);
}

/* ===========================================================================
     Associate a gzFile with the file descriptor fd. fd is not dup'ed here
   to mimic the behavio(u)r of fdopen.
*/
gzFile ZEXPORT gzdopen (
    int fd,
    const char *mode)
{
    char name[20];

    if (fd < 0) return (gzFile)Z_NULL;
    sprintf(name, "<fd:%d>", fd); /* for debugging */

    return gz_open (name, mode, fd);
}

/* ===========================================================================
 * Update the compression level and strategy
 */
int ZEXPORT gzsetparams (
    gzFile file,
    int level,
    int strategy)
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    /* Make room to allow flushing */
    if (s->stream.avail_out == 0) {

	s->stream.next_out = s->outbuf;
	if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
	    s->z_err = Z_ERRNO;
	}
	s->stream.avail_out = Z_BUFSIZE;
    }

    return deflateParams (&(s->stream), level, strategy);
}

/* ===========================================================================
     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
   for end of file.
   IN assertion: the stream s has been sucessfully opened for reading.
*/
local int get_byte(
    gz_stream *s)
{
    if (s->z_eof) return EOF;
    if (s->stream.avail_in == 0) {
	errno = 0;
	s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
	if (s->stream.avail_in == 0) {
	    s->z_eof = 1;
	    if (ferror(s->file)) s->z_err = Z_ERRNO;
	    return EOF;
	}
	s->stream.next_in = s->inbuf;
    }
    s->stream.avail_in--;
    return *(s->stream.next_in)++;
}

/* ===========================================================================
      Check the gzip header of a gz_stream opened for reading. Set the stream
    mode to transparent if the gzip magic header is not present; set s->err
    to Z_DATA_ERROR if the magic header is present but the rest of the header
    is incorrect.
    IN assertion: the stream s has already been created sucessfully;
       s->stream.avail_in is zero for the first time, but may be non-zero
       for concatenated .gz files.
*/
local void check_header(
    gz_stream *s)
{
    int method; /* method byte */
    int flags;  /* flags byte */
    uInt len;
    int c;

    /* Check the gzip magic header */
    for (len = 0; len < 2; len++) {
	c = get_byte(s);
	if (c != gz_magic[len]) {
	    if (len != 0) s->stream.avail_in++, s->stream.next_in--;
	    if (c != EOF) {
		s->stream.avail_in++, s->stream.next_in--;
		s->transparent = 1;
	    }
	    s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;
	    return;
	}
    }
    method = get_byte(s);
    flags = get_byte(s);
    if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
	s->z_err = Z_DATA_ERROR;
	return;
    }

    /* Discard time, xflags and OS code: */
    for (len = 0; len < 6; len++) (void)get_byte(s);

    if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
	len  =  (uInt)get_byte(s);
	len += ((uInt)get_byte(s))<<8;
	/* len is garbage if EOF but the loop below will quit anyway */
	while (len-- != 0 && get_byte(s) != EOF) ;
    }
    if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
	while ((c = get_byte(s)) != 0 && c != EOF) ;
    }
    if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
	while ((c = get_byte(s)) != 0 && c != EOF) ;
    }
    if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
	for (len = 0; len < 2; len++) (void)get_byte(s);
    }
    s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
}

 /* ===========================================================================
 * Cleanup then free the given gz_stream. Return a zlib error code.
   Try freeing in the reverse order of allocations.
 */
local int destroy (
    gz_stream *s)
{
    int err = Z_OK;

    if (!s) return Z_STREAM_ERROR;

    TRYFREE(s->msg);

    if (s->stream.state != NULL) {
	if (s->mode == 'w') {
#ifdef NO_DEFLATE
	    err = Z_STREAM_ERROR;
#else
	    err = deflateEnd(&(s->stream));
#endif
	} else if (s->mode == 'r') {
	    err = inflateEnd(&(s->stream));
	}
    }
    if (s->file != NULL && fclose(s->file)) {
#ifdef ESPIPE
	if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */
#endif
	    err = Z_ERRNO;
    }
    if (s->z_err < 0) err = s->z_err;

    TRYFREE(s->inbuf);
    TRYFREE(s->outbuf);
    TRYFREE(s->path);
    TRYFREE(s);
    return err;
}

/* ===========================================================================
     Reads the given number of uncompressed bytes from the compressed file.
   gzread returns the number of bytes actually read (0 for end of file).
*/
int ZEXPORT gzread (
    gzFile file,
    voidp buf,
    unsigned len)
{
    gz_stream *s = (gz_stream*)file;
    Bytef *start = (Bytef*)buf; /* starting point for crc computation */
    Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */

    if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;

    if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;
    if (s->z_err == Z_STREAM_END) return 0;  /* EOF */

    next_out = (Byte*)buf;
    s->stream.next_out = (Bytef*)buf;
    s->stream.avail_out = len;

    while (s->stream.avail_out != 0) {

	if (s->transparent) {
	    /* Copy first the lookahead bytes: */
	    uInt n = s->stream.avail_in;
	    if (n > s->stream.avail_out) n = s->stream.avail_out;
	    if (n > 0) {
		zmemcpy(s->stream.next_out, s->stream.next_in, n);
		next_out += n;
		s->stream.next_out = next_out;
		s->stream.next_in   += n;
		s->stream.avail_out -= n;
		s->stream.avail_in  -= n;
	    }
	    if (s->stream.avail_out > 0) {
		s->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,
					     s->file);
	    }
	    len -= s->stream.avail_out;
	    s->stream.total_in  += (uLong)len;
	    s->stream.total_out += (uLong)len;
            if (len == 0) s->z_eof = 1;
	    return (int)len;
	}
        if (s->stream.avail_in == 0 && !s->z_eof) {

            errno = 0;
            s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
            if (s->stream.avail_in == 0) {
                s->z_eof = 1;
		if (ferror(s->file)) {
		    s->z_err = Z_ERRNO;
		    break;
		}
            }
            s->stream.next_in = s->inbuf;
        }
        s->z_err = inflate(&(s->stream), Z_NO_FLUSH);

	if (s->z_err == Z_STREAM_END) {
	    /* Check CRC and original size */
	    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
	    start = s->stream.next_out;

	    if (getLong(s) != s->crc) {
		s->z_err = Z_DATA_ERROR;
	    } else {
	        (void)getLong(s);
                /* The uncompressed length returned by above getlong() may
                 * be different from s->stream.total_out) in case of
		 * concatenated .gz files. Check for such files:
		 */
		check_header(s);
		if (s->z_err == Z_OK) {
		    uLong total_in = s->stream.total_in;
		    uLong total_out = s->stream.total_out;

		    inflateReset(&(s->stream));
		    s->stream.total_in = total_in;
		    s->stream.total_out = total_out;
		    s->crc = crc32(0L, Z_NULL, 0);
		}
	    }
	}
	if (s->z_err != Z_OK || s->z_eof) break;
    }
    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));

    return (int)(len - s->stream.avail_out);
}


/* ===========================================================================
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/
int ZEXPORT gzgetc(
    gzFile file)
{
    unsigned char c;

    return gzread(file, &c, 1) == 1 ? c : -1;
}


/* ===========================================================================
      Reads bytes from the compressed file until len-1 characters are
   read, or a newline character is read and transferred to buf, or an
   end-of-file condition is encountered.  The string is then terminated
   with a null character.
      gzgets returns buf, or Z_NULL in case of error.

      The current implementation is not optimized at all.
*/
char * ZEXPORT gzgets(
    gzFile file,
    char *buf,
    int len)
{
    char *b = buf;
    if (buf == Z_NULL || len <= 0) return Z_NULL;

    while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;
    *buf = '\0';
    return b == buf && len > 0 ? Z_NULL : b;
}


#ifndef NO_DEFLATE
/* ===========================================================================
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of bytes actually written (0 in case of error).
*/
int ZEXPORT gzwrite (
    gzFile file,
    const voidp buf,
    unsigned len)
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    s->stream.next_in = (Bytef*)buf;
    s->stream.avail_in = len;

    while (s->stream.avail_in != 0) {

        if (s->stream.avail_out == 0) {

            s->stream.next_out = s->outbuf;
            if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
                s->z_err = Z_ERRNO;
                break;
            }
            s->stream.avail_out = Z_BUFSIZE;
        }
        s->z_err = deflate(&(s->stream), Z_NO_FLUSH);
        if (s->z_err != Z_OK) break;
    }
    s->crc = crc32(s->crc, (const Bytef *)buf, len);

    return (int)(len - s->stream.avail_in);
}

/* ===========================================================================
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/
#ifdef STDC

int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)
{
    char buf[Z_PRINTF_BUFSIZE];
    va_list va;
    int len;

    va_start(va, format);
#ifdef HAS_vsnprintf
    (void)vsnprintf(buf, sizeof(buf), format, va);
#else
    (void)vsprintf(buf, format, va);
#endif
    va_end(va);
    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */
    if (len <= 0) return 0;

    return gzwrite(file, buf, (unsigned)len);
}
#else /* not ANSI C */

int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
	               a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
    gzFile file;
    const char *format;
    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
	a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
{
    char buf[Z_PRINTF_BUFSIZE];
    int len;

#ifdef HAS_snprintf
    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
	     a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#else
    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
	    a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#endif
    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */
    if (len <= 0) return 0;

    return gzwrite(file, buf, len);
}
#endif

/* ===========================================================================
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/
int ZEXPORT gzputc(
    gzFile file,
    int c)
{
    unsigned char cc = (unsigned char) c; /* required for big endian systems */

    return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;
}


/* ===========================================================================
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/
int ZEXPORT gzputs(
    gzFile file,
    const char *s)
{
    return gzwrite(file, (char*)s, (unsigned)strlen(s));
}


/* ===========================================================================
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function.
*/
local int do_flush (
    gzFile file,
    int flush)
{
    uInt len;
    int done = 0;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    s->stream.avail_in = 0; /* should be zero already anyway */

    for (;;) {
        len = Z_BUFSIZE - s->stream.avail_out;

        if (len != 0) {
            if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {
                s->z_err = Z_ERRNO;
                return Z_ERRNO;
            }
            s->stream.next_out = s->outbuf;
            s->stream.avail_out = Z_BUFSIZE;
        }
        if (done) break;
        s->z_err = deflate(&(s->stream), flush);

	/* Ignore the second of two consecutive flushes: */
	if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;

        /* deflate has finished flushing only when it hasn't used up
         * all the available space in the output buffer: 
         */
        done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);
 
        if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;
    }
    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
}

int ZEXPORT gzflush (
     gzFile file,
     int flush)
{
    gz_stream *s = (gz_stream*)file;
    int err = do_flush (file, flush);

    if (err) return err;
    fflush(s->file);
    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
}
#endif /* NO_DEFLATE */

/* ===========================================================================
      Sets the starting position for the next gzread or gzwrite on the given
   compressed file. The offset represents a number of bytes in the
      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error.
      SEEK_END is not implemented, returns error.
      In this version of the library, gzseek can be extremely slow.
*/
z_off_t ZEXPORT gzseek (
    gzFile file,
    z_off_t offset,
    int whence)
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || whence == SEEK_END ||
	s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {
	return -1L;
    }
    
    if (s->mode == 'w') {
#ifdef NO_DEFLATE
	return -1L;
#else
	if (whence == SEEK_SET) {
	    offset -= s->stream.total_in;
	}
	if (offset < 0) return -1L;

	/* At this point, offset is the number of zero bytes to write. */
	if (s->inbuf == Z_NULL) {
	    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */
	    zmemzero(s->inbuf, Z_BUFSIZE);
	}
	while (offset > 0)  {
	    uInt size = Z_BUFSIZE;
	    if (offset < Z_BUFSIZE) size = (uInt)offset;

	    size = gzwrite(file, s->inbuf, size);
	    if (size == 0) return -1L;

	    offset -= size;
	}
	return (z_off_t)s->stream.total_in;
#endif
    }
    /* Rest of function is for reading only */

    /* compute absolute position */
    if (whence == SEEK_CUR) {
	offset += s->stream.total_out;
    }
    if (offset < 0) return -1L;

    if (s->transparent) {
	/* map to fseek */
	s->stream.avail_in = 0;
	s->stream.next_in = s->inbuf;
        if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;

	s->stream.total_in = s->stream.total_out = (uLong)offset;
	return offset;
    }

    /* For a negative seek, rewind and use positive seek */
    if ((uLong)offset >= s->stream.total_out) {
	offset -= s->stream.total_out;
    } else if (gzrewind(file) < 0) {
	return -1L;
    }
    /* offset is now the number of bytes to skip. */

    if (offset != 0 && s->outbuf == Z_NULL) {
	s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
    }
    while (offset > 0)  {
	int size = Z_BUFSIZE;
	if (offset < Z_BUFSIZE) size = (int)offset;

	size = gzread(file, s->outbuf, (uInt)size);
	if (size <= 0) return -1L;
	offset -= size;
    }
    return (z_off_t)s->stream.total_out;
}

/* ===========================================================================
     Rewinds input file. 
*/
int ZEXPORT gzrewind (
    gzFile file)
{
    gz_stream *s = (gz_stream*)file;
    
    if (s == NULL || s->mode != 'r') return -1;

    s->z_err = Z_OK;
    s->z_eof = 0;
    s->stream.avail_in = 0;
    s->stream.next_in = s->inbuf;
    s->crc = crc32(0L, Z_NULL, 0);
	
    if (s->startpos == 0) { /* not a compressed file */
	rewind(s->file);
	return 0;
    }

    (void) inflateReset(&s->stream);
    return fseek(s->file, s->startpos, SEEK_SET);
}

/* ===========================================================================
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.
*/
z_off_t ZEXPORT gztell (
    gzFile file)
{
    return gzseek(file, 0L, SEEK_CUR);
}

/* ===========================================================================
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/
int ZEXPORT gzeof (
    gzFile file)
{
    gz_stream *s = (gz_stream*)file;
    
    return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;
}

/* ===========================================================================
   Outputs a long in LSB order to the given file
*/
local void putLong (
    FILE *file,
    uLong x)
{
    int n;
    for (n = 0; n < 4; n++) {
        fputc((int)(x & 0xff), file);
        x >>= 8;
    }
}

/* ===========================================================================
   Reads a long in LSB order from the given gz_stream. Sets z_err in case
   of error.
*/
local uLong getLong (
    gz_stream *s)
{
    uLong x = (uLong)get_byte(s);
    int c;

    x += ((uLong)get_byte(s))<<8;
    x += ((uLong)get_byte(s))<<16;
    c = get_byte(s);
    if (c == EOF) s->z_err = Z_DATA_ERROR;
    x += ((uLong)c)<<24;
    return x;
}

/* ===========================================================================
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state.
*/
int ZEXPORT gzclose (
    gzFile file)
{
    int err;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL) return Z_STREAM_ERROR;

    if (s->mode == 'w') {
#ifdef NO_DEFLATE
	return Z_STREAM_ERROR;
#else
        err = do_flush (file, Z_FINISH);
        if (err != Z_OK) return destroy((gz_stream*)file);

        putLong (s->file, s->crc);
        putLong (s->file, s->stream.total_in);
#endif
    }
    return destroy((gz_stream*)file);
}

/* ===========================================================================
     Returns the error message for the last error which occured on the
   given compressed file. errnum is set to zlib error number. If an
   error occured in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/
const char*  ZEXPORT gzerror (
    gzFile file,
    int *errnum)
{
    char *m;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL) {
        *errnum = Z_STREAM_ERROR;
        return (const char*)ERR_MSG(Z_STREAM_ERROR);
    }
    *errnum = s->z_err;
    if (*errnum == Z_OK) return (const char*)"";

    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);

    if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);

    TRYFREE(s->msg);
    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);
    strcpy(s->msg, s->path);
    strcat(s->msg, ": ");
    strcat(s->msg, m);
    return (const char*)s->msg;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\infblock.cpp ===
/* infblock.c -- interpret and process block types to last block
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"
#include "inftrees.h"
#include "infcodes.h"
#include "infutil.h"

namespace D3DX
{

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

/* Table for deflate from PKZIP's appnote.txt. */
local const uInt border[] = { /* Order of the bit length code lengths */
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

/*
   Notes beyond the 1.93a appnote.txt:

   1. Distance pointers never point before the beginning of the output
      stream.
   2. Distance pointers can point back across blocks, up to 32k away.
   3. There is an implied maximum of 7 bits for the bit length table and
      15 bits for the actual data.
   4. If only one code exists, then it is encoded using one bit.  (Zero
      would be more efficient, but perhaps a little confusing.)  If two
      codes exist, they are coded using one bit each (0 and 1).
   5. There is no way of sending zero distance codes--a dummy must be
      sent if there are none.  (History: a pre 2.0 version of PKZIP would
      store blocks with no distance codes, but this was discovered to be
      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
      zero distance codes, which is sent as one code of zero bits in
      length.
   6. There are up to 286 literal/length codes.  Code 256 represents the
      end-of-block.  Note however that the static length tree defines
      288 codes just to fill out the Huffman codes.  Codes 286 and 287
      cannot be used though, since there is no length base or extra bits
      defined for them.  Similarily, there are up to 30 distance codes.
      However, static trees define 32 codes (all 5 bits) to fill out the
      Huffman codes, but the last two had better not show up in the data.
   7. Unzip can check dynamic Huffman blocks for complete code sets.
      The exception is that a single code would not be complete (see #4).
   8. The five bits following the block type is really the number of
      literal codes sent minus 257.
   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
      (1+6+6).  Therefore, to output three times the length, you output
      three codes (1+1+1), whereas to output four times the same length,
      you only need two codes (1+3).  Hmm.
  10. In the tree reconstruction algorithm, Code = Code + Increment
      only if BitLength(i) is not zero.  (Pretty obvious.)
  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
  12. Note: length code 284 can represent 227-258, but length code 285
      really is 258.  The last length deserves its own, short code
      since it gets used a lot in very redundant files.  The length
      258 is special since 258 - 3 (the min match length) is 255.
  13. The literal/length and distance code bit lengths are read as a
      single stream of lengths.  It is possible (and advantageous) for
      a repeat code (16, 17, or 18) to go across the boundary between
      the two sets of lengths.
 */


void inflate_blocks_reset(
    inflate_blocks_statef *s,
    z_streamp z,
    uLongf *c)
{
  if (c != Z_NULL)
    *c = s->check;
  if (s->mode == BTREE || s->mode == DTREE)
    ZFREE(z, s->sub.trees.blens);
  if (s->mode == CODES)
    inflate_codes_free(s->sub.decode.codes, z);
  s->mode = TYPE;
  s->bitk = 0;
  s->bitb = 0;
  s->read = s->write = s->window;
  if (s->checkfn != Z_NULL)
    z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);
  Tracev((stderr, "inflate:   blocks reset\n"));
}


inflate_blocks_statef *inflate_blocks_new(
    z_streamp z,
    check_func c,
    uInt w)
{
  inflate_blocks_statef *s;

  if ((s = (inflate_blocks_statef *)ZALLOC
       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
    return s;
  if ((s->hufts =
       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)
  {
    ZFREE(z, s);
    return Z_NULL;
  }
  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
  {
    ZFREE(z, s->hufts);
    ZFREE(z, s);
    return Z_NULL;
  }
  s->end = s->window + w;
  s->checkfn = c;
  s->mode = TYPE;
  Tracev((stderr, "inflate:   blocks allocated\n"));
  inflate_blocks_reset(s, z, Z_NULL);
  return s;
}


int inflate_blocks(
    inflate_blocks_statef *s,
    z_streamp z,
    int r)
{
  uInt t;               /* temporary storage */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD

  /* process input based on current state */
  while (1) switch (s->mode)
  {
    case TYPE:
      NEEDBITS(3)
      t = (uInt)b & 7;
      s->last = t & 1;
      switch (t >> 1)
      {
        case 0:                         /* stored */
          Tracev((stderr, "inflate:     stored block%s\n",
                 s->last ? " (last)" : ""));
          DUMPBITS(3)
          t = k & 7;                    /* go to byte boundary */
          DUMPBITS(t)
          s->mode = LENS;               /* get length of stored block */
          break;
        case 1:                         /* fixed */
          Tracev((stderr, "inflate:     fixed codes block%s\n",
                 s->last ? " (last)" : ""));
          {
            uInt bl, bd;
            inflate_huft *tl, *td;

            inflate_trees_fixed(&bl, &bd, &tl, &td, z);
            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
            if (s->sub.decode.codes == Z_NULL)
            {
              r = Z_MEM_ERROR;
              LEAVE
            }
          }
          DUMPBITS(3)
          s->mode = CODES;
          break;
        case 2:                         /* dynamic */
          Tracev((stderr, "inflate:     dynamic codes block%s\n",
                 s->last ? " (last)" : ""));
          DUMPBITS(3)
          s->mode = TABLE;
          break;
        case 3:                         /* illegal */
          DUMPBITS(3)
          s->mode = BAD;
          z->msg = (char*)"invalid block type";
          r = Z_DATA_ERROR;
          LEAVE
      }
      break;
    case LENS:
      NEEDBITS(32)
      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))
      {
        s->mode = BAD;
        z->msg = (char*)"invalid stored block lengths";
        r = Z_DATA_ERROR;
        LEAVE
      }
      s->sub.left = (uInt)b & 0xffff;
      b = k = 0;                      /* dump bits */
      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);
      break;
    case STORED:
      if (n == 0)
        LEAVE
      NEEDOUT
      t = s->sub.left;
      if (t > n) t = n;
      if (t > m) t = m;
      zmemcpy(q, p, t);
      p += t;  n -= t;
      q += t;  m -= t;
      if ((s->sub.left -= t) != 0)
        break;
      Tracev((stderr, "inflate:       stored end, %lu total out\n",
              z->total_out + (q >= s->read ? q - s->read :
              (s->end - s->read) + (q - s->window))));
      s->mode = s->last ? DRY : TYPE;
      break;
    case TABLE:
      NEEDBITS(14)
      s->sub.trees.table = t = (uInt)b & 0x3fff;
#ifndef PKZIP_BUG_WORKAROUND
      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
      {
        s->mode = BAD;
        z->msg = (char*)"too many length or distance symbols";
        r = Z_DATA_ERROR;
        LEAVE
      }
#endif
      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
      {
        r = Z_MEM_ERROR;
        LEAVE
      }
      DUMPBITS(14)
      s->sub.trees.index = 0;
      Tracev((stderr, "inflate:       table sizes ok\n"));
      s->mode = BTREE;
    case BTREE:
      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
      {
        NEEDBITS(3)
        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
        DUMPBITS(3)
      }
      while (s->sub.trees.index < 19)
        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
      s->sub.trees.bb = 7;
      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
                             &s->sub.trees.tb, s->hufts, z);
      if (t != Z_OK)
      {
        ZFREE(z, s->sub.trees.blens);
        r = t;
        if (r == Z_DATA_ERROR)
          s->mode = BAD;
        LEAVE
      }
      s->sub.trees.index = 0;
      Tracev((stderr, "inflate:       bits tree ok\n"));
      s->mode = DTREE;
    case DTREE:
      while (t = s->sub.trees.table,
             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
      {
        inflate_huft *h;
        uInt i, j, c;

        t = s->sub.trees.bb;
        NEEDBITS(t)
        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
        t = h->bits;
        c = h->base;
        if (c < 16)
        {
          DUMPBITS(t)
          s->sub.trees.blens[s->sub.trees.index++] = c;
        }
        else /* c == 16..18 */
        {
          i = c == 18 ? 7 : c - 14;
          j = c == 18 ? 11 : 3;
          NEEDBITS(t + i)
          DUMPBITS(t)
          j += (uInt)b & inflate_mask[i];
          DUMPBITS(i)
          i = s->sub.trees.index;
          t = s->sub.trees.table;
          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
              (c == 16 && i < 1))
          {
            ZFREE(z, s->sub.trees.blens);
            s->mode = BAD;
            z->msg = (char*)"invalid bit length repeat";
            r = Z_DATA_ERROR;
            LEAVE
          }
          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
          do {
            s->sub.trees.blens[i++] = c;
          } while (--j);
          s->sub.trees.index = i;
        }
      }
      s->sub.trees.tb = Z_NULL;
      {
        uInt bl, bd;
        inflate_huft *tl, *td;
        inflate_codes_statef *c;

        bl = 9;         /* must be <= 9 for lookahead assumptions */
        bd = 6;         /* must be <= 9 for lookahead assumptions */
        t = s->sub.trees.table;
        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
                                  s->sub.trees.blens, &bl, &bd, &tl, &td,
                                  s->hufts, z);
        ZFREE(z, s->sub.trees.blens);
        if (t != Z_OK)
        {
          if (t == (uInt)Z_DATA_ERROR)
            s->mode = BAD;
          r = t;
          LEAVE
        }
        Tracev((stderr, "inflate:       trees ok\n"));
        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
        {
          r = Z_MEM_ERROR;
          LEAVE
        }
        s->sub.decode.codes = c;
      }
      s->mode = CODES;
    case CODES:
      UPDATE
      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
        return inflate_flush(s, z, r);
      r = Z_OK;
      inflate_codes_free(s->sub.decode.codes, z);
      LOAD
      Tracev((stderr, "inflate:       codes end, %lu total out\n",
              z->total_out + (q >= s->read ? q - s->read :
              (s->end - s->read) + (q - s->window))));
      if (!s->last)
      {
        s->mode = TYPE;
        break;
      }
      s->mode = DRY;
    case DRY:
      FLUSH
      if (s->read != s->write)
        LEAVE
      s->mode = DONE;
    case DONE:
      r = Z_STREAM_END;
      LEAVE
    case BAD:
      r = Z_DATA_ERROR;
      LEAVE
    default:
      r = Z_STREAM_ERROR;
      LEAVE
  }
}


int inflate_blocks_free(
    inflate_blocks_statef *s,
    z_streamp z)
{
  inflate_blocks_reset(s, z, Z_NULL);
  ZFREE(z, s->window);
  ZFREE(z, s->hufts);
  ZFREE(z, s);
  Tracev((stderr, "inflate:   blocks freed\n"));
  return Z_OK;
}


void inflate_set_dictionary(
    inflate_blocks_statef *s,
    const Bytef *d,
    uInt  n)
{
  zmemcpy(s->window, d, n);
  s->read = s->write = s->window + n;
}


/* Returns true if inflate is currently at the end of a block generated
 * by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
 * IN assertion: s != Z_NULL
 */
int inflate_blocks_sync_point(
    inflate_blocks_statef *s)
{
  return s->mode == LENS;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\inffast.h ===
/* inffast.h -- header to use inffast.c
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

namespace D3DX
{

extern int inflate_fast OF((
    uInt,
    uInt,
    inflate_huft *,
    inflate_huft *,
    inflate_blocks_statef *,
    z_streamp ));

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\infcodes.h ===
/* infcodes.h -- header to use infcodes.c
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

namespace D3DX
{

struct inflate_codes_state;
typedef struct inflate_codes_state FAR inflate_codes_statef;

extern inflate_codes_statef *inflate_codes_new OF((
    uInt, uInt,
    inflate_huft *, inflate_huft *,
    z_streamp ));

extern int inflate_codes OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));

extern void inflate_codes_free OF((
    inflate_codes_statef *,
    z_streamp ));


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\inffast.cpp ===
/* inffast.c -- process literals and length/distance pairs fast
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"
#include "infblock.h"
#include "infcodes.h"
#include "infutil.h"
#include "inffast.h"

namespace D3DX
{

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

/* macros for bit input with no checking and for returning unused bytes */
#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}

/* Called with number of bytes left to write in window at least 258
   (the maximum string length) and number of input bytes available
   at least ten.  The ten bytes are six bytes for the longest length/
   distance pair plus four bytes for overloading the bit buffer. */

int inflate_fast(
    uInt bl,
    uInt bd,
    inflate_huft *tl,
    inflate_huft *td, /* need separate declaration for Borland C++ */
    inflate_blocks_statef *s,
    z_streamp z)
{
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  uInt ml;              /* mask for literal/length tree */
  uInt md;              /* mask for distance tree */
  uInt c;               /* bytes to copy */
  uInt d;               /* distance back to copy from */
  Bytef *r;             /* copy source pointer */

  /* load input, output, bit values */
  LOAD

  /* initialize masks */
  ml = inflate_mask[bl];
  md = inflate_mask[bd];

  /* do until not enough input or output space for fast loop */
  do {                          /* assume called with m >= 258 && n >= 10 */
    /* get literal/length code */
    GRABBITS(20)                /* max bits for literal/length code */
    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
    {
      DUMPBITS(t->bits)
      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                "inflate:         * literal '%c'\n" :
                "inflate:         * literal 0x%02x\n", t->base));
      *q++ = (Byte)t->base;
      m--;
      continue;
    }
    do {
      DUMPBITS(t->bits)
      if (e & 16)
      {
        /* get extra bits for length */
        e &= 15;
        c = t->base + ((uInt)b & inflate_mask[e]);
        DUMPBITS(e)
        Tracevv((stderr, "inflate:         * length %u\n", c));

        /* decode distance base of block to copy */
        GRABBITS(15);           /* max bits for distance code */
        e = (t = td + ((uInt)b & md))->exop;
        do {
          DUMPBITS(t->bits)
          if (e & 16)
          {
            /* get extra bits to add to distance base */
            e &= 15;
            GRABBITS(e)         /* get extra bits (up to 13) */
            d = t->base + ((uInt)b & inflate_mask[e]);
            DUMPBITS(e)
            Tracevv((stderr, "inflate:         * distance %u\n", d));

            /* do the copy */
            m -= c;
            if ((uInt)(q - s->window) >= d)     /* offset before dest */
            {                                   /*  just copy */
              r = q - d;
              *q++ = *r++;  c--;        /* minimum count is three, */
              *q++ = *r++;  c--;        /*  so unroll loop a little */
            }
            else                        /* else offset after destination */
            {
              e = d - (uInt)(q - s->window); /* bytes from offset to end */
              r = s->end - e;           /* pointer to offset */
              if (c > e)                /* if source crosses, */
              {
                c -= e;                 /* copy to end of window */
                do {
                  *q++ = *r++;
                } while (--e);
                r = s->window;          /* copy rest from start of window */
              }
            }
            do {                        /* copy all or what's left */
              *q++ = *r++;
            } while (--c);
            break;
          }
          else if ((e & 64) == 0)
          {
            t += t->base;
            e = (t += ((uInt)b & inflate_mask[e]))->exop;
          }
          else
          {
            z->msg = (char*)"invalid distance code";
            UNGRAB
            UPDATE
            return Z_DATA_ERROR;
          }
        } while (1);
        break;
      }
      if ((e & 64) == 0)
      {
        t += t->base;
        if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)
        {
          DUMPBITS(t->bits)
          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                    "inflate:         * literal '%c'\n" :
                    "inflate:         * literal 0x%02x\n", t->base));
          *q++ = (Byte)t->base;
          m--;
          break;
        }
      }
      else if (e & 32)
      {
        Tracevv((stderr, "inflate:         * end of block\n"));
        UNGRAB
        UPDATE
        return Z_STREAM_END;
      }
      else
      {
        z->msg = (char*)"invalid literal/length code";
        UNGRAB
        UPDATE
        return Z_DATA_ERROR;
      }
    } while (1);
  } while (m >= 258 && n >= 10);

  /* not enough input or output--restore pointers and return */
  UNGRAB
  UPDATE
  return Z_OK;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\inflate.cpp ===
/* inflate.c -- zlib interface to inflate modules
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"

namespace D3DX
{

struct inflate_blocks_state {int dummy;}; /* for buggy compilers */

typedef enum {
      METHOD,   /* waiting for method byte */
      FLAG,     /* waiting for flag byte */
      DICT4,    /* four dictionary check bytes to go */
      DICT3,    /* three dictionary check bytes to go */
      DICT2,    /* two dictionary check bytes to go */
      DICT1,    /* one dictionary check byte to go */
      DICT0,    /* waiting for inflateSetDictionary */
      BLOCKS,   /* decompressing blocks */
      CHECK4,   /* four check bytes to go */
      CHECK3,   /* three check bytes to go */
      CHECK2,   /* two check bytes to go */
      CHECK1,   /* one check byte to go */
      DONE,     /* finished check, done */
      BAD}      /* got an error--stay here */
inflate_mode;

/* inflate private state */
struct internal_state {

  /* mode */
  inflate_mode  mode;   /* current inflate mode */

  /* mode dependent information */
  union {
    uInt method;        /* if FLAGS, method byte */
    struct {
      uLong was;                /* computed check value */
      uLong need;               /* stream check value */
    } check;            /* if CHECK, check values to compare */
    uInt marker;        /* if BAD, inflateSync's marker bytes count */
  } sub;        /* submode */

  /* mode independent information */
  int  nowrap;          /* flag for no wrapper */
  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
  inflate_blocks_statef 
    *blocks;            /* current inflate_blocks state */

};


int ZEXPORT inflateReset(
    z_streamp z)
{
  if (z == Z_NULL || z->state == Z_NULL)
    return Z_STREAM_ERROR;
  z->total_in = z->total_out = 0;
  z->msg = Z_NULL;
  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
  inflate_blocks_reset(z->state->blocks, z, Z_NULL);
  Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}


int ZEXPORT inflateEnd(
    z_streamp z)
{
  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->blocks != Z_NULL)
    inflate_blocks_free(z->state->blocks, z);
  ZFREE(z, z->state);
  z->state = Z_NULL;
  Tracev((stderr, "inflate: end\n"));
  return Z_OK;
}


int ZEXPORT inflateInit2_(
    z_streamp z,
    int w,
    const char *version,
    int stream_size)
{
  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
      stream_size != sizeof(z_stream))
      return Z_VERSION_ERROR;

  /* initialize state */
  if (z == Z_NULL)
    return Z_STREAM_ERROR;
  z->msg = Z_NULL;
  if (z->zalloc == Z_NULL)
  {
    z->zalloc = zcalloc;
    z->opaque = (voidpf)0;
  }
  if (z->zfree == Z_NULL) z->zfree = zcfree;
  if ((z->state = (struct internal_state FAR *)
       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
    return Z_MEM_ERROR;
  z->state->blocks = Z_NULL;

  /* handle undocumented nowrap option (no zlib header or check) */
  z->state->nowrap = 0;
  if (w < 0)
  {
    w = - w;
    z->state->nowrap = 1;
  }

  /* set window size */
  if (w < 8 || w > 15)
  {
    inflateEnd(z);
    return Z_STREAM_ERROR;
  }
  z->state->wbits = (uInt)w;

  /* create inflate_blocks state */
  if ((z->state->blocks =
      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
      == Z_NULL)
  {
    inflateEnd(z);
    return Z_MEM_ERROR;
  }
  Tracev((stderr, "inflate: allocated\n"));

  /* reset state */
  inflateReset(z);
  return Z_OK;
}


int ZEXPORT inflateInit_(
    z_streamp z,
    const char *version,
    int stream_size)
{
  return inflateInit2_(z, DEF_WBITS, version, stream_size);
}


#define NEEDBYTE {if(z->avail_in==0)return r;r=f;}
#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)

int ZEXPORT inflate(
    z_streamp z,
    int f)
{
  int r;
  uInt b;

  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)
    return Z_STREAM_ERROR;
  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
  r = Z_BUF_ERROR;
  while (1) switch (z->state->mode)
  {
    case METHOD:
      NEEDBYTE
      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)
      {
        z->state->mode = BAD;
        z->msg = (char*)"unknown compression method";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
      {
        z->state->mode = BAD;
        z->msg = (char*)"invalid window size";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      z->state->mode = FLAG;
    case FLAG:
      NEEDBYTE
      b = NEXTBYTE;
      if (((z->state->sub.method << 8) + b) % 31)
      {
        z->state->mode = BAD;
        z->msg = (char*)"incorrect header check";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      Tracev((stderr, "inflate: zlib header ok\n"));
      if (!(b & PRESET_DICT))
      {
        z->state->mode = BLOCKS;
        break;
      }
      z->state->mode = DICT4;
    case DICT4:
      NEEDBYTE
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = DICT3;
    case DICT3:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = DICT2;
    case DICT2:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = DICT1;
    case DICT1:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE;
      z->adler = z->state->sub.check.need;
      z->state->mode = DICT0;
      return Z_NEED_DICT;
    case DICT0:
      z->state->mode = BAD;
      z->msg = (char*)"need dictionary";
      z->state->sub.marker = 0;       /* can try inflateSync */
      return Z_STREAM_ERROR;
    case BLOCKS:
      r = inflate_blocks(z->state->blocks, z, r);
      if (r == Z_DATA_ERROR)
      {
        z->state->mode = BAD;
        z->state->sub.marker = 0;       /* can try inflateSync */
        break;
      }
      if (r == Z_OK)
        r = f;
      if (r != Z_STREAM_END)
        return r;
      r = f;
      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
      if (z->state->nowrap)
      {
        z->state->mode = DONE;
        break;
      }
      z->state->mode = CHECK4;
    case CHECK4:
      NEEDBYTE
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = CHECK3;
    case CHECK3:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = CHECK2;
    case CHECK2:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = CHECK1;
    case CHECK1:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE;

      if (z->state->sub.check.was != z->state->sub.check.need)
      {
        z->state->mode = BAD;
        z->msg = (char*)"incorrect data check";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      Tracev((stderr, "inflate: zlib check ok\n"));
      z->state->mode = DONE;
    case DONE:
      return Z_STREAM_END;
    case BAD:
      return Z_DATA_ERROR;
    default:
      return Z_STREAM_ERROR;
  }
#ifdef NEED_DUMMY_RETURN
  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
#endif
}


int ZEXPORT inflateSetDictionary(
    z_streamp z,
    const Bytef *dictionary,
    uInt  dictLength)
{
  uInt length = dictLength;

  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
    return Z_STREAM_ERROR;

  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
  z->adler = 1L;

  if (length >= ((uInt)1<<z->state->wbits))
  {
    length = (1<<z->state->wbits)-1;
    dictionary += dictLength - length;
  }
  inflate_set_dictionary(z->state->blocks, dictionary, length);
  z->state->mode = BLOCKS;
  return Z_OK;
}


int ZEXPORT inflateSync(
    z_streamp z)
{
  uInt n;       /* number of bytes to look at */
  Bytef *p;     /* pointer to bytes */
  uInt m;       /* number of marker bytes found in a row */
  uLong r, w;   /* temporaries to save total_in and total_out */

  /* set up */
  if (z == Z_NULL || z->state == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->mode != BAD)
  {
    z->state->mode = BAD;
    z->state->sub.marker = 0;
  }
  if ((n = z->avail_in) == 0)
    return Z_BUF_ERROR;
  p = z->next_in;
  m = z->state->sub.marker;

  /* search */
  while (n && m < 4)
  {
    static const Byte mark[4] = {0, 0, 0xff, 0xff};
    if (*p == mark[m])
      m++;
    else if (*p)
      m = 0;
    else
      m = 4 - m;
    p++, n--;
  }

  /* restore */
  z->total_in += (uLong)(p - z->next_in);
  z->next_in = p;
  z->avail_in = n;
  z->state->sub.marker = m;

  /* return no joy or set up to restart on a new block */
  if (m != 4)
    return Z_DATA_ERROR;
  r = z->total_in;  w = z->total_out;
  inflateReset(z);
  z->total_in = r;  z->total_out = w;
  z->state->mode = BLOCKS;
  return Z_OK;
}


/* Returns true if inflate is currently at the end of a block generated
 * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
 * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
 * but removes the length bytes of the resulting empty stored block. When
 * decompressing, PPP checks that at the end of input packet, inflate is
 * waiting for these length bytes.
 */
int ZEXPORT inflateSyncPoint(
    z_streamp z)
{
  if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)
    return Z_STREAM_ERROR;
  return inflate_blocks_sync_point(z->state->blocks);
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\inftrees.cpp ===
/* inftrees.c -- generate Huffman trees for efficient decoding
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"

namespace D3DX
{

#if !defined(BUILDFIXED) && !defined(STDC)
#  define BUILDFIXED   /* non ANSI compilers may not accept inffixed.h */
#endif

const char inflate_copyright[] =
   " inflate 1.1.3 Copyright 1995-1998 Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */
struct internal_state  {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits


local int huft_build OF((
    uIntf *,            /* code lengths in bits */
    uInt,               /* number of codes */
    uInt,               /* number of "simple" codes */
    const uIntf *,      /* list of base values for non-simple codes */
    const uIntf *,      /* list of extra bits for non-simple codes */
    inflate_huft * FAR*,/* result: starting table */
    uIntf *,            /* maximum lookup bits (returns actual) */
    inflate_huft *,     /* space for trees */
    uInt *,             /* hufts used in space */
    uIntf * ));         /* space for values */

/* Tables for deflate from PKZIP's appnote.txt. */
local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
        /* see note #13 above about 258 */
local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */
local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577};
local const uInt cpdext[30] = { /* Extra bits for distance codes */
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        12, 12, 13, 13};

/*
   Huffman code decoding is performed using a multi-level table lookup.
   The fastest way to decode is to simply build a lookup table whose
   size is determined by the longest code.  However, the time it takes
   to build this table can also be a factor if the data being decoded
   is not very long.  The most common codes are necessarily the
   shortest codes, so those codes dominate the decoding time, and hence
   the speed.  The idea is you can have a shorter table that decodes the
   shorter, more probable codes, and then point to subsidiary tables for
   the longer codes.  The time it costs to decode the longer codes is
   then traded against the time it takes to make longer tables.

   This results of this trade are in the variables lbits and dbits
   below.  lbits is the number of bits the first level table for literal/
   length codes can decode in one step, and dbits is the same thing for
   the distance codes.  Subsequent tables are also less than or equal to
   those sizes.  These values may be adjusted either when all of the
   codes are shorter than that, in which case the longest code length in
   bits is used, or when the shortest code is *longer* than the requested
   table size, in which case the length of the shortest code in bits is
   used.

   There are two different values for the two tables, since they code a
   different number of possibilities each.  The literal/length table
   codes 286 possible values, or in a flat code, a little over eight
   bits.  The distance table codes 30 possible values, or a little less
   than five bits, flat.  The optimum values for speed end up being
   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
   The optimum values may differ though from machine to machine, and
   possibly even between compilers.  Your mileage may vary.
 */


/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
#define BMAX 15         /* maximum bit length of any code */

local int huft_build(
    uIntf *b,               /* code lengths in bits (all assumed <= BMAX) */
    uInt n,                 /* number of codes (assumed <= 288) */
    uInt s,                 /* number of simple-valued codes (0..s-1) */
    const uIntf *d,         /* list of base values for non-simple codes */
    const uIntf *e,         /* list of extra bits for non-simple codes */
    inflate_huft * FAR *t,  /* result: starting table */
    uIntf *m,               /* maximum lookup bits, returns actual */
    inflate_huft *hp,       /* space for trees */
    uInt *hn,               /* hufts used in space */
    uIntf *v)               /* working area: values in order of bit length */

/* Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
   if the given code set is incomplete (the tables are still built in this
   case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of
   lengths), or Z_MEM_ERROR if not enough memory. */
{

  uInt a;                       /* counter for codes of length k */
  uInt c[BMAX+1];               /* bit length count table */
  uInt f;                       /* i repeats in table every f entries */
  int g;                        /* maximum code length */
  int h;                        /* table level */
  register uInt i;              /* counter, current code */
  register uInt j;              /* counter */
  register int k;               /* number of bits in current code */
  int l;                        /* bits per table (returned in m) */
  uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */
  register uIntf *p;            /* pointer into c[], b[], or v[] */
  inflate_huft *q;              /* points to current table */
  struct inflate_huft_s r;      /* table entry for structure assignment */
  inflate_huft *u[BMAX];        /* table stack */
  register int w;               /* bits before this table == (l * h) */
  uInt x[BMAX+1];               /* bit offsets, then code stack */
  uIntf *xp;                    /* pointer into x */
  int y;                        /* number of dummy codes added */
  uInt z;                       /* number of entries in current table */


  /* Generate counts for each bit length */
  p = c;
#define C0 *p++ = 0;
#define C2 C0 C0 C0 C0
#define C4 C2 C2 C2 C2
  C4                            /* clear c[]--assume BMAX+1 is 16 */
  p = b;  i = n;
  do {
    c[*p++]++;                  /* assume all entries <= BMAX */
  } while (--i);
  if (c[0] == n)                /* null input--all zero length codes */
  {
    *t = (inflate_huft *)Z_NULL;
    *m = 0;
    return Z_OK;
  }


  /* Find minimum and maximum length, bound *m by those */
  l = *m;
  for (j = 1; j <= BMAX; j++)
    if (c[j])
      break;
  k = j;                        /* minimum code length */
  if ((uInt)l < j)
    l = j;
  for (i = BMAX; i; i--)
    if (c[i])
      break;
  g = i;                        /* maximum code length */
  if ((uInt)l > i)
    l = i;
  *m = l;


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
    if ((y -= c[j]) < 0)
      return Z_DATA_ERROR;
  if ((y -= c[i]) < 0)
    return Z_DATA_ERROR;
  c[i] += y;


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
  p = c + 1;  xp = x + 2;
  while (--i) {                 /* note that i == g from above */
    *xp++ = (j += *p++);
  }


  /* Make a table of values in order of bit lengths */
  p = b;  i = 0;
  do {
    if ((j = *p++) != 0)
      v[x[j]++] = i;
  } while (++i < n);
  n = x[g];                     /* set n to length of v */


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
  h = -1;                       /* no tables yet--level -1 */
  w = -l;                       /* bits decoded == (l * h) */
  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
  q = (inflate_huft *)Z_NULL;   /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
  {
    a = c[k];
    while (a--)
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l)
      {
        h++;
        w += l;                 /* previous table always l bits */

        /* compute minimum size table less than or equal to l bits */
        z = g - w;
        z = z > (uInt)l ? l : z;        /* table size upper limit */
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
        {                       /* too few codes for k-w bit table */
          f -= a + 1;           /* deduct codes from patterns left */
          xp = c + k;
          if (j < z)
            while (++j < z)     /* try smaller tables up to z bits */
            {
              if ((f <<= 1) <= *++xp)
                break;          /* enough codes to use up j bits */
              f -= *xp;         /* else deduct codes from patterns */
            }
        }
        z = 1 << j;             /* table entries for j-bit table */

        /* allocate new table */
        if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */
          return Z_MEM_ERROR;   /* not enough memory */
        u[h] = q = hp + *hn;
        *hn += z;

        /* connect to last table, if there is one */
        if (h)
        {
          x[h] = i;             /* save pattern for backing up */
          r.bits = (Byte)l;     /* bits to dump before this table */
          r.exop = (Byte)j;     /* bits in this table */
          j = i >> (w - l);
          r.base = (uInt)(q - u[h-1] - j);   /* offset to this table */
          u[h-1][j] = r;        /* connect to last table */
        }
        else
          *t = q;               /* first table is returned result */
      }

      /* set up table entry in r */
      r.bits = (Byte)(k - w);
      if (p >= v + n)
        r.exop = 128 + 64;      /* out of values--invalid code */
      else if (*p < s)
      {
        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
        r.base = *p++;          /* simple code is just the value */
      }
      else
      {
        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
        r.base = d[*p++ - s];
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
        q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
        i ^= j;
      i ^= j;

      /* backup over finished tables */
      mask = (1 << w) - 1;      /* needed on HP, cc -O bug */
      while ((i & mask) != x[h])
      {
        h--;                    /* don't need to update q */
        w -= l;
        mask = (1 << w) - 1;
      }
    }
  }


  /* Return Z_BUF_ERROR if we were given an incomplete table */
  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
}


int inflate_trees_bits(
    uIntf *c,               /* 19 code lengths */
    uIntf *bb,              /* bits tree desired/actual depth */
    inflate_huft * FAR *tb, /* bits tree result */
    inflate_huft *hp,       /* space for trees */
    z_streamp z)            /* for messages */
{
  int r;
  uInt hn = 0;          /* hufts used in space */
  uIntf *v;             /* work area for huft_build */

  if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)
    return Z_MEM_ERROR;
  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,
                 tb, bb, hp, &hn, v);
  if (r == Z_DATA_ERROR)
    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
  else if (r == Z_BUF_ERROR || *bb == 0)
  {
    z->msg = (char*)"incomplete dynamic bit lengths tree";
    r = Z_DATA_ERROR;
  }
  ZFREE(z, v);
  return r;
}


int inflate_trees_dynamic(
    uInt nl,                /* number of literal/length codes */
    uInt nd,                /* number of distance codes */
    uIntf *c,               /* that many (total) code lengths */
    uIntf *bl,              /* literal desired/actual bit depth */
    uIntf *bd,              /* distance desired/actual bit depth */
    inflate_huft * FAR *tl, /* literal/length tree result */
    inflate_huft * FAR *td, /* distance tree result */
    inflate_huft *hp,       /* space for trees */
    z_streamp z)            /* for messages */
{
  int r;
  uInt hn = 0;          /* hufts used in space */
  uIntf *v;             /* work area for huft_build */

  /* allocate work area */
  if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
    return Z_MEM_ERROR;

  /* build literal/length tree */
  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);
  if (r != Z_OK || *bl == 0)
  {
    if (r == Z_DATA_ERROR)
      z->msg = (char*)"oversubscribed literal/length tree";
    else if (r != Z_MEM_ERROR)
    {
      z->msg = (char*)"incomplete literal/length tree";
      r = Z_DATA_ERROR;
    }
    ZFREE(z, v);
    return r;
  }

  /* build distance tree */
  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);
  if (r != Z_OK || (*bd == 0 && nl > 257))
  {
    if (r == Z_DATA_ERROR)
      z->msg = (char*)"oversubscribed distance tree";
    else if (r == Z_BUF_ERROR) {
#ifdef PKZIP_BUG_WORKAROUND
      r = Z_OK;
    }
#else
      z->msg = (char*)"incomplete distance tree";
      r = Z_DATA_ERROR;
    }
    else if (r != Z_MEM_ERROR)
    {
      z->msg = (char*)"empty distance tree with lengths";
      r = Z_DATA_ERROR;
    }
    ZFREE(z, v);
    return r;
#endif
  }

  /* done */
  ZFREE(z, v);
  return Z_OK;
}


/* build fixed tables only once--keep them here */
#ifdef BUILDFIXED
local int fixed_built = 0;
#define FIXEDH 544      /* number of hufts used by fixed tables */
local inflate_huft fixed_mem[FIXEDH];
local uInt fixed_bl;
local uInt fixed_bd;
local inflate_huft *fixed_tl;
local inflate_huft *fixed_td;
#else
}
#include "inffixed.h"
namespace D3DX
{
#endif


int inflate_trees_fixed(
    uIntf *bl,               /* literal desired/actual bit depth */
    uIntf *bd,               /* distance desired/actual bit depth */
    inflate_huft * FAR *tl,  /* literal/length tree result */
    inflate_huft * FAR *td,  /* distance tree result */
    z_streamp z)             /* for memory allocation */
{
#ifdef BUILDFIXED
  /* build fixed tables if not already */
  if (!fixed_built)
  {
    int k;              /* temporary variable */
    uInt f = 0;         /* number of hufts used in fixed_mem */
    uIntf *c;           /* length list for huft_build */
    uIntf *v;           /* work area for huft_build */

    /* allocate memory */
    if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
      return Z_MEM_ERROR;
    if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
    {
      ZFREE(z, c);
      return Z_MEM_ERROR;
    }

    /* literal table */
    for (k = 0; k < 144; k++)
      c[k] = 8;
    for (; k < 256; k++)
      c[k] = 9;
    for (; k < 280; k++)
      c[k] = 7;
    for (; k < 288; k++)
      c[k] = 8;
    fixed_bl = 9;
    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl,
               fixed_mem, &f, v);

    /* distance table */
    for (k = 0; k < 30; k++)
      c[k] = 5;
    fixed_bd = 5;
    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd,
               fixed_mem, &f, v);

    /* done */
    ZFREE(z, v);
    ZFREE(z, c);
    fixed_built = 1;
  }
#endif
  *bl = fixed_bl;
  *bd = fixed_bd;
  *tl = fixed_tl;
  *td = fixed_td;
  return Z_OK;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\inftrees.h ===
/* inftrees.h -- header to use inftrees.c
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* Huffman code lookup table entry--this entry is four bytes for machines
   that have 16-bit pointers (e.g. PC's in the small or medium model). */

namespace D3DX
{

typedef struct inflate_huft_s FAR inflate_huft;

struct inflate_huft_s {
  union {
    struct {
      Byte Exop;        /* number of extra bits or operation */
      Byte Bits;        /* number of bits in this code or subcode */
    } what;
    uInt pad;           /* pad structure to a power of 2 (4 bytes for */
  } word;               /*  16-bit, 8 bytes for 32-bit int's) */
  uInt base;            /* literal, length base, distance base,
                           or table offset */
};

/* Maximum size of dynamic tree.  The maximum found in a long but non-
   exhaustive search was 1004 huft structures (850 for length/literals
   and 154 for distances, the latter actually the result of an
   exhaustive search).  The actual maximum is not known, but the
   value below is more than safe. */
#define MANY 1440

extern int inflate_trees_bits OF((
    uIntf *,                    /* 19 code lengths */
    uIntf *,                    /* bits tree desired/actual depth */
    inflate_huft * FAR *,       /* bits tree result */
    inflate_huft *,             /* space for trees */
    z_streamp));                /* for messages */

extern int inflate_trees_dynamic OF((
    uInt,                       /* number of literal/length codes */
    uInt,                       /* number of distance codes */
    uIntf *,                    /* that many (total) code lengths */
    uIntf *,                    /* literal desired/actual bit depth */
    uIntf *,                    /* distance desired/actual bit depth */
    inflate_huft * FAR *,       /* literal/length tree result */
    inflate_huft * FAR *,       /* distance tree result */
    inflate_huft *,             /* space for trees */
    z_streamp));                /* for messages */

extern int inflate_trees_fixed OF((
    uIntf *,                    /* literal desired/actual bit depth */
    uIntf *,                    /* distance desired/actual bit depth */
    inflate_huft * FAR *,       /* literal/length tree result */
    inflate_huft * FAR *,       /* distance tree result */
    z_streamp));                /* for memory allocation */

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\inffixed.h ===
/* inffixed.h -- table for decoding fixed codes
 * Generated automatically by the maketree.c program
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

namespace D3DX
{

local uInt fixed_bl = 9;
local uInt fixed_bd = 5;
local inflate_huft fixed_tl[] = {
    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},
    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},
    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},
    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},
    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},
    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},
    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},
    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},
    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},
    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},
    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},
    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},
    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},
    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},
    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},
    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},
    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},
    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},
    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},
    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},
    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},
    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},
    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},
    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},
    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},
    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},
    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},
    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},
    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},
    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},
    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},
    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},
    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},
    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},
    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},
    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},
    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},
    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},
    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},
    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},
    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},
    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},
    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},
    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},
    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},
    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},
    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},
    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},
    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},
    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},
    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},
    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},
    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},
    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},
    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},
    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},
    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},
    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},
    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},
    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},
    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},
    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},
    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},
    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},
    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},
    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},
    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},
    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},
    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},
    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},
    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},
    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},
    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},
    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},
    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},
    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},
    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},
    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},
    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},
    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},
    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},
    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},
    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},
    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},
    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},
    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},
    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},
    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},
    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},
    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},
    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},
    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},
    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},
    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},
    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},
    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},
    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},
    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},
    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},
    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},
    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},
    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},
    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},
    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},
    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},
    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},
    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},
    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},
    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},
    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},
    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},
    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}
  };
local inflate_huft fixed_td[] = {
    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},
    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},
    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},
    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},
    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},
    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},
    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},
    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}
  };

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\infutil.cpp ===
/* inflate_util.c -- data and routines common to blocks and codes
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"
#include "inftrees.h"
#include "infcodes.h"
#include "infutil.h"

namespace D3DX
{

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* And'ing with mask[n] masks the lower n bits */
uInt inflate_mask[17] = {
    0x0000,
    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
};


/* copy as much as possible from the sliding window to the output area */
int inflate_flush(
    inflate_blocks_statef *s,
    z_streamp z,
    int r)
{
  uInt n;
  Bytef *p;
  Bytef *q;

  /* local copies of source and destination pointers */
  p = z->next_out;
  q = s->read;

  /* compute number of bytes to copy as far as end of window */
  n = (uInt)((q <= s->write ? s->write : s->end) - q);
  if (n > z->avail_out) n = z->avail_out;
  if (n && r == Z_BUF_ERROR) r = Z_OK;

  /* update counters */
  z->avail_out -= n;
  z->total_out += n;

  /* update check information */
  if (s->checkfn != Z_NULL)
    z->adler = s->check = (*s->checkfn)(s->check, q, n);

  /* copy as far as end of window */
  zmemcpy(p, q, n);
  p += n;
  q += n;

  /* see if more to copy at beginning of window */
  if (q == s->end)
  {
    /* wrap pointers */
    q = s->window;
    if (s->write == s->end)
      s->write = s->window;

    /* compute bytes to copy */
    n = (uInt)(s->write - q);
    if (n > z->avail_out) n = z->avail_out;
    if (n && r == Z_BUF_ERROR) r = Z_OK;

    /* update counters */
    z->avail_out -= n;
    z->total_out += n;

    /* update check information */
    if (s->checkfn != Z_NULL)
      z->adler = s->check = (*s->checkfn)(s->check, q, n);

    /* copy */
    zmemcpy(p, q, n);
    p += n;
    q += n;
  }

  /* update pointers */
  z->next_out = p;
  s->read = q;

  /* done */
  return r;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\maketree.cpp ===
/* maketree.c -- make inffixed.h table for decoding fixed codes
 * Copyright (C) 1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* This program is included in the distribution for completeness.
   You do not need to compile or run this program since inffixed.h
   is already included in the distribution.  To use this program
   you need to compile zlib with BUILDFIXED defined and then compile
   and link this program with the zlib library.  Then the output of
   this program can be piped to inffixed.h. */

#include <stdio.h>
#include <stdlib.h>
#include "zutil.h"
#include "inftrees.h"

namespace D3DX
{

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

/* generate initialization table for an inflate_huft structure array */
void maketree(uInt b, inflate_huft *t)
{
  int i, e;

  i = 0;
  while (1)
  {
    e = t[i].exop;
    if (e && (e & (16+64)) == 0)        /* table pointer */
    {
      fprintf(stderr, "maketree: cannot initialize sub-tables!\n");
      exit(1);
    }
    if (i % 4 == 0)
      printf("\n   ");
    printf(" {{{%u,%u}},%u}", t[i].exop, t[i].bits, t[i].base);
    if (++i == (1<<b))
      break;
    putchar(',');
  }
  puts("");
}

/* create the fixed tables in C initialization syntax */
void main(void)
{
  int r;
  uInt bl, bd;
  inflate_huft *tl, *td;
  z_stream z;

  z.zalloc = zcalloc;
  z.opaque = (voidpf)0;
  z.zfree = zcfree;
  r = inflate_trees_fixed(&bl, &bd, &tl, &td, &z);
  if (r)
  {
    fprintf(stderr, "inflate_trees_fixed error %d\n", r);
    return;
  }
  puts("/* inffixed.h -- table for decoding fixed codes");
  puts(" * Generated automatically by the maketree.c program");
  puts(" */");
  puts("");
  puts("/* WARNING: this file should *not* be used by applications. It is");
  puts("   part of the implementation of the compression library and is");
  puts("   subject to change. Applications should only use zlib.h.");
  puts(" */");
  puts("");
  printf("local uInt fixed_bl = %d;\n", bl);
  printf("local uInt fixed_bd = %d;\n", bd);
  printf("local inflate_huft fixed_tl[] = {");
  maketree(bl, tl);
  puts("  };");
  printf("local inflate_huft fixed_td[] = {");
  maketree(bd, td);
  puts("  };");
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\minigzip.cpp ===
/* minigzip.c -- simulate gzip using the zlib compression library
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 * minigzip is a minimal implementation of the gzip utility. This is
 * only an example of using zlib and isn't meant to replace the
 * full-featured gzip. No attempt is made to deal with file systems
 * limiting names to 14 or 8+3 characters, etc... Error checking is
 * very limited. So use minigzip only for testing; use gzip for the
 * real thing. On MSDOS, use only on file names without extension
 * or in pipe mode.
 */

/* @(#) $Id$ */

#include <stdio.h>
#include "zlib.h"

#ifdef STDC
#  include <string.h>
#  include <stdlib.h>
#else
   extern void exit  OF((int));
#endif

#ifdef USE_MMAP
#  include <sys/types.h>
#  include <sys/mman.h>
#  include <sys/stat.h>
#endif

#if defined(MSDOS) || defined(OS2) || defined(WIN32)
#  include <fcntl.h>
#  include <io.h>
#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
#else
#  define SET_BINARY_MODE(file)
#endif

#ifdef VMS
#  define unlink delete
#  define GZ_SUFFIX "-gz"
#endif
#ifdef RISCOS
#  define unlink remove
#  define GZ_SUFFIX "-gz"
#  define fileno(file) file->__file
#endif
#if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#  include <unix.h> /* for fileno */
#endif

#ifndef WIN32 /* unlink already in stdio.h for WIN32 */
  extern int unlink OF((const char *));
#endif

#ifndef GZ_SUFFIX
#  define GZ_SUFFIX ".gz"
#endif
#define SUFFIX_LEN (sizeof(GZ_SUFFIX)-1)

#define BUFLEN      16384
#define MAX_NAME_LEN 1024

#ifdef MAXSEG_64K
#  define local static
   /* Needed for systems with limitation on stack size. */
#else
#  define local
#endif

namespace D3DX
{

char *prog;

void error            OF((const char *msg));
void gz_compress      OF((FILE   *in, gzFile out));
#ifdef USE_MMAP
int  gz_compress_mmap OF((FILE   *in, gzFile out));
#endif
void gz_uncompress    OF((gzFile in, FILE   *out));
void file_compress    OF((char  *file, char *mode));
void file_uncompress  OF((char  *file));
int  main             OF((int argc, char *argv[]));

/* ===========================================================================
 * Display error message and exit
 */
void error(msg)
    const char *msg;
{
    fprintf(stderr, "%s: %s\n", prog, msg);
    exit(1);
}

/* ===========================================================================
 * Compress input to output then close both files.
 */

void gz_compress(in, out)
    FILE   *in;
    gzFile out;
{
    local char buf[BUFLEN];
    int len;
    int err;

#ifdef USE_MMAP
    /* Try first compressing with mmap. If mmap fails (minigzip used in a
     * pipe), use the normal fread loop.
     */
    if (gz_compress_mmap(in, out) == Z_OK) return;
#endif
    for (;;) {
        len = fread(buf, 1, sizeof(buf), in);
        if (ferror(in)) {
            perror("fread");
            exit(1);
        }
        if (len == 0) break;

        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));
    }
    fclose(in);
    if (gzclose(out) != Z_OK) error("failed gzclose");
}

#ifdef USE_MMAP /* MMAP version, Miguel Albrecht <malbrech@eso.org> */

/* Try compressing the input file at once using mmap. Return Z_OK if
 * if success, Z_ERRNO otherwise.
 */
int gz_compress_mmap(in, out)
    FILE   *in;
    gzFile out;
{
    int len;
    int err;
    int ifd = fileno(in);
    caddr_t buf;    /* mmap'ed buffer for the entire input file */
    off_t buf_len;  /* length of the input file */
    struct stat sb;

    /* Determine the size of the file, needed for mmap: */
    if (fstat(ifd, &sb) < 0) return Z_ERRNO;
    buf_len = sb.st_size;
    if (buf_len <= 0) return Z_ERRNO;

    /* Now do the actual mmap: */
    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0); 
    if (buf == (caddr_t)(-1)) return Z_ERRNO;

    /* Compress the whole file at once: */
    len = gzwrite(out, (char *)buf, (unsigned)buf_len);

    if (len != (int)buf_len) error(gzerror(out, &err));

    munmap(buf, buf_len);
    fclose(in);
    if (gzclose(out) != Z_OK) error("failed gzclose");
    return Z_OK;
}
#endif /* USE_MMAP */

/* ===========================================================================
 * Uncompress input to output then close both files.
 */
void gz_uncompress(in, out)
    gzFile in;
    FILE   *out;
{
    local char buf[BUFLEN];
    int len;
    int err;

    for (;;) {
        len = gzread(in, buf, sizeof(buf));
        if (len < 0) error (gzerror(in, &err));
        if (len == 0) break;

        if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {
	    error("failed fwrite");
	}
    }
    if (fclose(out)) error("failed fclose");

    if (gzclose(in) != Z_OK) error("failed gzclose");
}


/* ===========================================================================
 * Compress the given file: create a corresponding .gz file and remove the
 * original.
 */
void file_compress(file, mode)
    char  *file;
    char  *mode;
{
    local char outfile[MAX_NAME_LEN];
    FILE  *in;
    gzFile out;

    strcpy(outfile, file);
    strcat(outfile, GZ_SUFFIX);

    in = fopen(file, "rb");
    if (in == NULL) {
        perror(file);
        exit(1);
    }
    out = gzopen(outfile, mode);
    if (out == NULL) {
        fprintf(stderr, "%s: can't gzopen %s\n", prog, outfile);
        exit(1);
    }
    gz_compress(in, out);

    unlink(file);
}


/* ===========================================================================
 * Uncompress the given file and remove the original.
 */
void file_uncompress(file)
    char  *file;
{
    local char buf[MAX_NAME_LEN];
    char *infile, *outfile;
    FILE  *out;
    gzFile in;
    int len = strlen(file);

    strcpy(buf, file);

    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {
        infile = file;
        outfile = buf;
        outfile[len-3] = '\0';
    } else {
        outfile = file;
        infile = buf;
        strcat(infile, GZ_SUFFIX);
    }
    in = gzopen(infile, "rb");
    if (in == NULL) {
        fprintf(stderr, "%s: can't gzopen %s\n", prog, infile);
        exit(1);
    }
    out = fopen(outfile, "wb");
    if (out == NULL) {
        perror(file);
        exit(1);
    }

    gz_uncompress(in, out);

    unlink(infile);
}


/* ===========================================================================
 * Usage:  minigzip [-d] [-f] [-h] [-1 to -9] [files...]
 *   -d : decompress
 *   -f : compress with Z_FILTERED
 *   -h : compress with Z_HUFFMAN_ONLY
 *   -1 to -9 : compression level
 */

int main(argc, argv)
    int argc;
    char *argv[];
{
    int uncompr = 0;
    gzFile file;
    char outmode[20];

    strcpy(outmode, "wb6 ");

    prog = argv[0];
    argc--, argv++;

    while (argc > 0) {
      if (strcmp(*argv, "-d") == 0)
	uncompr = 1;
      else if (strcmp(*argv, "-f") == 0)
	outmode[3] = 'f';
      else if (strcmp(*argv, "-h") == 0)
	outmode[3] = 'h';
      else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&
	       (*argv)[2] == 0)
	outmode[2] = (*argv)[1];
      else
	break;
      argc--, argv++;
    }
    if (argc == 0) {
        SET_BINARY_MODE(stdin);
        SET_BINARY_MODE(stdout);
        if (uncompr) {
            file = gzdopen(fileno(stdin), "rb");
            if (file == NULL) error("can't gzdopen stdin");
            gz_uncompress(file, stdout);
        } else {
            file = gzdopen(fileno(stdout), outmode);
            if (file == NULL) error("can't gzdopen stdout");
            gz_compress(stdin, file);
        }
    } else {
        do {
            if (uncompr) {
                file_uncompress(*argv);
            } else {
                file_compress(*argv, outmode);
            }
        } while (argv++, --argc);
    }
    exit(0);
    return 0; /* to avoid warning */
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\infutil.h ===
/* infutil.h -- types and macros common to blocks and codes
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

#ifndef _INFUTIL_H
#define _INFUTIL_H

namespace D3DX
{

typedef enum {
      TYPE,     /* get type bits (3, including end bit) */
      LENS,     /* get lengths for stored */
      STORED,   /* processing stored block */
      TABLE,    /* get table lengths */
      BTREE,    /* get bit lengths tree for a dynamic block */
      DTREE,    /* get length, distance trees for a dynamic block */
      CODES,    /* processing fixed or dynamic block */
      DRY,      /* output remaining window bytes */
      DONE,     /* finished last block, done */
      BAD}      /* got a data error--stuck here */
inflate_block_mode;

/* inflate blocks semi-private state */
struct inflate_blocks_state {

  /* mode */
  inflate_block_mode  mode;     /* current inflate_block mode */

  /* mode dependent information */
  union {
    uInt left;          /* if STORED, bytes left to copy */
    struct {
      uInt table;               /* table lengths (14 bits) */
      uInt index;               /* index into blens (or border) */
      uIntf *blens;             /* bit lengths of codes */
      uInt bb;                  /* bit length tree depth */
      inflate_huft *tb;         /* bit length decoding tree */
    } trees;            /* if DTREE, decoding info for trees */
    struct {
      inflate_codes_statef 
         *codes;
    } decode;           /* if CODES, current state */
  } sub;                /* submode */
  uInt last;            /* true if this block is the last block */

  /* mode independent information */
  uInt bitk;            /* bits in bit buffer */
  uLong bitb;           /* bit buffer */
  inflate_huft *hufts;  /* single malloc for tree space */
  Bytef *window;        /* sliding window */
  Bytef *end;           /* one byte after sliding window */
  Bytef *read;          /* window read pointer */
  Bytef *write;         /* window write pointer */
  check_func checkfn;   /* check function */
  uLong check;          /* check on output */

};


/* defines for inflate input/output */
/*   update pointers and return */
#define UPDBITS {s->bitb=b;s->bitk=k;}
#define UPDIN {z->avail_in=n;z->total_in+=(uLong)(p-z->next_in);z->next_in=p;}
#define UPDOUT {s->write=q;}
#define UPDATE {UPDBITS UPDIN UPDOUT}
#define LEAVE {UPDATE return inflate_flush(s,z,r);}
/*   get bytes and bits */
#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
#define NEXTBYTE (n--,*p++)
#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define DUMPBITS(j) {b>>=(j);k-=(j);}
/*   output bytes */
#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)
#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}
#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}
#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
/*   load local pointers */
#define LOAD {LOADIN LOADOUT}

/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
extern uInt inflate_mask[17];

/* copy as much as possible from the sliding window to the output area */
extern int inflate_flush OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));

struct internal_state      {int dummy;}; /* for buggy compilers */

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\uncompr.cpp ===
/* uncompr.c -- decompress a memory buffer
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

namespace D3DX
{

/* ===========================================================================
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/
int ZEXPORT uncompress (
    Bytef *dest,
    uLongf *destLen,
    const Bytef *source,
    uLong sourceLen)
{
    z_stream stream;
    int err;

    stream.next_in = (Bytef*)source;
    stream.avail_in = (uInt)sourceLen;
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;

    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;

    err = inflateInit(&stream);
    if (err != Z_OK) return err;

    err = inflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        inflateEnd(&stream);
        return err == Z_OK ? Z_BUF_ERROR : err;
    }
    *destLen = stream.total_out;

    err = inflateEnd(&stream);
    return err;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\zconf.h ===
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#ifndef _ZCONF_H
#define _ZCONF_H

namespace D3DX
{

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 */
#ifdef Z_PREFIX
#  define deflateInit_	z_deflateInit_
#  define deflate	z_deflate
#  define deflateEnd	z_deflateEnd
#  define inflateInit_ 	z_inflateInit_
#  define inflate	z_inflate
#  define inflateEnd	z_inflateEnd
#  define deflateInit2_	z_deflateInit2_
#  define deflateSetDictionary z_deflateSetDictionary
#  define deflateCopy	z_deflateCopy
#  define deflateReset	z_deflateReset
#  define deflateParams	z_deflateParams
#  define inflateInit2_	z_inflateInit2_
#  define inflateSetDictionary z_inflateSetDictionary
#  define inflateSync	z_inflateSync
#  define inflateSyncPoint z_inflateSyncPoint
#  define inflateReset	z_inflateReset
#  define compress	z_compress
#  define compress2	z_compress2
#  define uncompress	z_uncompress
#  define adler32	z_adler32
#  define crc32		z_crc32
#  define get_crc_table z_get_crc_table

#  define Byte		z_Byte
#  define uInt		z_uInt
#  define uLong		z_uLong
#  define Bytef	        z_Bytef
#  define charf		z_charf
#  define intf		z_intf
#  define uIntf		z_uIntf
#  define uLongf	z_uLongf
#  define voidpf	z_voidpf
#  define voidp		z_voidp
#endif

#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
#  define WIN32
#endif
#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
#  ifndef __32BIT__
#    define __32BIT__
#  endif
#endif
#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#if defined(MSDOS) && !defined(__32BIT__)
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
#  define STDC
#endif
#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
#  ifndef STDC
#    define STDC
#  endif
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const
#  endif
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Old Borland C incorrectly complains about missing returns: */
#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
#  define NEED_DUMMY_RETURN
#endif


/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
   /* MSC small or medium model */
#  define SMALL_MEDIUM
#  ifdef _MSC_VER
#    define FAR _far
#  else
#    define FAR far
#  endif
#endif
#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
#  ifndef __32BIT__
#    define SMALL_MEDIUM
#    define FAR _far
#  endif
#endif

/* Compile with -DZLIB_DLL for Windows DLL support */
#if defined(ZLIB_DLL)
#  if defined(_WINDOWS) || defined(WINDOWS)
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
#    define ZEXPORT  WINAPI
#    ifdef WIN32
#      define ZEXPORTVA  WINAPIV
#    else
#      define ZEXPORTVA  FAR _cdecl _export
#    endif
#  endif
#  if defined (__BORLANDC__)
#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
#      include <windows.h>
#      define ZEXPORT __declspec(dllexport) WINAPI
#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
#    else
#      if defined (_Windows) && defined (__DLL__)
#        define ZEXPORT _export
#        define ZEXPORTVA _export
#      endif
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  if defined (ZLIB_DLL)
#    define ZEXTERN extern __declspec(dllexport)
#  else
#    define ZEXTERN extern __declspec(dllimport)
#  endif
#endif

#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif
#ifndef ZEXTERN
//#  define ZEXTERN extern
#  define ZEXTERN
#endif

#ifndef FAR
#   define FAR
#endif

#if !defined(MACOS) && !defined(TARGET_OS_MAC)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void FAR *voidpf;
   typedef void     *voidp;
#else
   typedef Byte FAR *voidpf;
   typedef Byte     *voidp;
#endif

#ifdef HAVE_UNISTD_H
#  include <sys/types.h> /* for off_t */
#  include <unistd.h>    /* for SEEK_* and off_t */
#  define z_off_t  off_t
#endif
#ifndef SEEK_SET
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif
#ifndef z_off_t
#  define  z_off_t long
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
#   pragma map(deflateInit_,"DEIN")
#   pragma map(deflateInit2_,"DEIN2")
#   pragma map(deflateEnd,"DEEND")
#   pragma map(inflateInit_,"ININ")
#   pragma map(inflateInit2_,"ININ2")
#   pragma map(inflateEnd,"INEND")
#   pragma map(inflateSync,"INSY")
#   pragma map(inflateSetDictionary,"INSEDI")
#   pragma map(inflate_blocks,"INBL")
#   pragma map(inflate_blocks_new,"INBLNE")
#   pragma map(inflate_blocks_free,"INBLFR")
#   pragma map(inflate_blocks_reset,"INBLRE")
#   pragma map(inflate_codes_free,"INCOFR")
#   pragma map(inflate_codes,"INCO")
#   pragma map(inflate_fast,"INFA")
#   pragma map(inflate_flush,"INFLU")
#   pragma map(inflate_mask,"INMA")
#   pragma map(inflate_set_dictionary,"INSEDI2")
#   pragma map(inflate_copyright,"INCOPY")
#   pragma map(inflate_trees_bits,"INTRBI")
#   pragma map(inflate_trees_dynamic,"INTRDY")
#   pragma map(inflate_trees_fixed,"INTRFI")
#   pragma map(inflate_trees_free,"INTRFR")
#endif

}
#endif /* _ZCONF_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\trees.h ===
/* header created automatically with -DGEN_TREES_H */

namespace D3DX
{

local const ct_data static_ltree[L_CODES+2] = {
{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
};

local const ct_data static_dtree[D_CODES] = {
{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
};

const uch _dist_code[DIST_CODE_LEN] = {
 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
};

const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {
 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
};

local const int base_length[LENGTH_CODES] = {
0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
64, 80, 96, 112, 128, 160, 192, 224, 0
};

local const int base_dist[D_CODES] = {
    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
};

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\trees.cpp ===
/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-1998 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */

/* @(#) $Id$ */

/* #define GEN_TREES_H */

#include "deflate.h"

#ifdef DEBUG
#  include <ctype.h>
#endif

namespace D3DX
{

/* ===========================================================================
 * Constants
 */

#define MAX_BL_BITS 7
/* Bit length codes must not exceed MAX_BL_BITS bits */

#define END_BLOCK 256
/* end of block literal code */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};

local const int extra_dbits[D_CODES] /* extra bits for each distance code */
   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

local const uch bl_order[BL_CODES]
   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

#define Buf_size (8 * 2*sizeof(char))
/* Number of bits used within bi_buf. (bi_buf might be implemented on
 * more than 16 bits on some systems.)
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

#define DIST_CODE_LEN  512 /* see definition of array dist_code below */

#if defined(GEN_TREES_H) || !defined(STDC)
/* non ANSI compilers may not accept trees.h */

local ct_data static_ltree[L_CODES+2];
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

local ct_data static_dtree[D_CODES];
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

uch _dist_code[DIST_CODE_LEN];
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

uch _length_code[MAX_MATCH-MIN_MATCH+1];
/* length code for each normalized match length (0 == MIN_MATCH) */

local int base_length[LENGTH_CODES];
/* First normalized length for each code (0 = MIN_MATCH) */

local int base_dist[D_CODES];
/* First normalized distance for each code (0 = distance of 1) */

#else
}
#  include "trees.h"
namespace D3DX
{
#endif /* GEN_TREES_H */

struct static_tree_desc_s {
    const ct_data *static_tree;  /* static tree or NULL */
    const intf *extra_bits;      /* extra bits for each code or NULL */
    int     extra_base;          /* base index for extra_bits */
    int     elems;               /* max number of elements in the tree */
    int     max_length;          /* max bit length for the codes */
};

local static_tree_desc  static_l_desc =
{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};

local static_tree_desc  static_d_desc =
{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};

local static_tree_desc  static_bl_desc =
{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};

/* ===========================================================================
 * Local (static) routines in this file.
 */

local void tr_static_init OF((void));
local void init_block     OF((deflate_state *s));
local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
local void build_tree     OF((deflate_state *s, tree_desc *desc));
local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local int  build_bl_tree  OF((deflate_state *s));
local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
                              int blcodes));
local void compress_block OF((deflate_state *s, ct_data *ltree,
                              ct_data *dtree));
local void set_data_type  OF((deflate_state *s));
local unsigned bi_reverse OF((unsigned value, int length));
local void bi_windup      OF((deflate_state *s));
local void bi_flush       OF((deflate_state *s));
local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
                              int header));

#ifdef GEN_TREES_H
local void gen_trees_header OF((void));
#endif

#ifndef DEBUG
#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
   /* Send a code of the given tree. c and tree must not have side effects */

#else /* DEBUG */
#  define send_code(s, c, tree) \
     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }
#endif

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
#define put_short(s, w) { \
    put_byte(s, (uch)((w) & 0xff)); \
    put_byte(s, (uch)((ush)(w) >> 8)); \
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
#ifdef DEBUG
local void send_bits      OF((deflate_state *s, int value, int length));

local void send_bits(
    deflate_state *s,
    int value,  /* value to send */
    int length) /* number of bits */
{
    Tracevv((stderr," l %2d v %4x ", length, value));
    Assert(length > 0 && length <= 15, "invalid length");
    s->bits_sent += (ulg)length;

    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if (s->bi_valid > (int)Buf_size - length) {
        s->bi_buf |= (value << s->bi_valid);
        put_short(s, s->bi_buf);
        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
        s->bi_valid += length - Buf_size;
    } else {
        s->bi_buf |= value << s->bi_valid;
        s->bi_valid += length;
    }
}
#else /* !DEBUG */

#define send_bits(s, value, length) \
{ int len = length;\
  if (s->bi_valid > (int)Buf_size - len) {\
    int val = value;\
    s->bi_buf |= (val << s->bi_valid);\
    put_short(s, s->bi_buf);\
    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
    s->bi_valid += len - Buf_size;\
  } else {\
    s->bi_buf |= (value) << s->bi_valid;\
    s->bi_valid += len;\
  }\
}
#endif /* DEBUG */


#define MAX(a,b) (a >= b ? a : b)
/* the arguments must not have side effects */

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
local void tr_static_init()
{
#if defined(GEN_TREES_H) || !defined(STDC)
    static int static_init_done = 0;
    int n;        /* iterates over tree elements */
    int bits;     /* bit counter */
    int length;   /* length value */
    int code;     /* code value */
    int dist;     /* distance index */
    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    if (static_init_done) return;

    /* For some embedded targets, global variables are not initialized: */
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    length = 0;
    for (code = 0; code < LENGTH_CODES-1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1<<extra_lbits[code]); n++) {
            _length_code[length++] = (uch)code;
        }
    }
    Assert (length == 256, "tr_static_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    _length_code[length-1] = (uch)code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code = 0 ; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1<<extra_dbits[code]); n++) {
            _dist_code[dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */
    for ( ; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
            _dist_code[256 + dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */
    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
    n = 0;
    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);

    /* The static distance tree is trivial: */
    for (n = 0; n < D_CODES; n++) {
        static_dtree[n].Len = 5;
        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
    }
    static_init_done = 1;

#  ifdef GEN_TREES_H
    gen_trees_header();
#  endif
#endif /* defined(GEN_TREES_H) || !defined(STDC) */
}

/* ===========================================================================
 * Genererate the file trees.h describing the static trees.
 */
#ifdef GEN_TREES_H
#  ifndef DEBUG
}
#    include <stdio.h>
namespace D3DX
{
#  endif

#  define SEPARATOR(i, last, width) \
      ((i) == (last)? "\n};\n\n" :    \
       ((i) % (width) == (width)-1 ? ",\n" : ", "))

void gen_trees_header()
{
    FILE *header = fopen("trees.h", "w");
    int i;

    Assert (header != NULL, "Can't open trees.h");
    fprintf(header,
            "/* header created automatically with -DGEN_TREES_H */\n\n");

    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
    for (i = 0; i < L_CODES+2; i++) {
        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
    }

    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
    }

    fprintf(header, "const uch _dist_code[DIST_CODE_LEN] = {\n");
    for (i = 0; i < DIST_CODE_LEN; i++) {
        fprintf(header, "%2u%s", _dist_code[i],
                SEPARATOR(i, DIST_CODE_LEN-1, 20));
    }

    fprintf(header, "const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
        fprintf(header, "%2u%s", _length_code[i],
                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
    }

    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
    for (i = 0; i < LENGTH_CODES; i++) {
        fprintf(header, "%1u%s", base_length[i],
                SEPARATOR(i, LENGTH_CODES-1, 20));
    }

    fprintf(header, "local const int base_dist[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
        fprintf(header, "%5u%s", base_dist[i],
                SEPARATOR(i, D_CODES-1, 10));
    }

    fclose(header);
}
#endif /* GEN_TREES_H */

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
void _tr_init(
    deflate_state *s)
{
    tr_static_init();

    s->l_desc.dyn_tree = s->dyn_ltree;
    s->l_desc.stat_desc = &static_l_desc;

    s->d_desc.dyn_tree = s->dyn_dtree;
    s->d_desc.stat_desc = &static_d_desc;

    s->bl_desc.dyn_tree = s->bl_tree;
    s->bl_desc.stat_desc = &static_bl_desc;

    s->bi_buf = 0;
    s->bi_valid = 0;
    s->last_eob_len = 8; /* enough lookahead for inflate */
#ifdef DEBUG
    s->compressed_len = 0L;
    s->bits_sent = 0L;
#endif

    /* Initialize the first block of the first file: */
    init_block(s);
}

/* ===========================================================================
 * Initialize a new block.
 */
local void init_block(
    deflate_state *s)
{
    int n; /* iterates over tree elements */

    /* Initialize the trees. */
    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

    s->dyn_ltree[END_BLOCK].Freq = 1;
    s->opt_len = s->static_len = 0L;
    s->last_lit = s->matches = 0;
}

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */
#define pqremove(s, tree, top) \
{\
    top = s->heap[SMALLEST]; \
    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define smaller(tree, n, m, depth) \
   (tree[n].Freq < tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
local void pqdownheap(
    deflate_state *s,
    ct_data *tree,  /* the tree to restore */
    int k)               /* node to move down */
{
    int v = s->heap[k];
    int j = k << 1;  /* left son of k */
    while (j <= s->heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s->heap_len &&
            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
            j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s->heap[j], s->depth)) break;

        /* Exchange v with the smallest son */
        s->heap[k] = s->heap[j];  k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
    }
    s->heap[k] = v;
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
local void gen_bitlen(
    deflate_state *s,
    tree_desc *desc)    /* the tree descriptor */
{
    ct_data *tree        = desc->dyn_tree;
    int max_code         = desc->max_code;
    const ct_data *stree = desc->stat_desc->static_tree;
    const intf *extra    = desc->stat_desc->extra_bits;
    int base             = desc->stat_desc->extra_base;
    int max_length       = desc->stat_desc->max_length;
    int h;              /* heap index */
    int n, m;           /* iterate over the tree elements */
    int bits;           /* bit length */
    int xbits;          /* extra bits */
    ush f;              /* frequency */
    int overflow = 0;   /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
        n = s->heap[h];
        bits = tree[tree[n].Dad].Len + 1;
        if (bits > max_length) bits = max_length, overflow++;
        tree[n].Len = (ush)bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) continue; /* not a leaf node */

        s->bl_count[bits]++;
        xbits = 0;
        if (n >= base) xbits = extra[n-base];
        f = tree[n].Freq;
        s->opt_len += (ulg)f * (bits + xbits);
        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
    }
    if (overflow == 0) return;

    Trace((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do {
        bits = max_length-1;
        while (s->bl_count[bits] == 0) bits--;
        s->bl_count[bits]--;      /* move one leaf down the tree */
        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
        s->bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
    } while (overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (bits = max_length; bits != 0; bits--) {
        n = s->bl_count[bits];
        while (n != 0) {
            m = s->heap[--h];
            if (m > max_code) continue;
            if (tree[m].Len != (unsigned) bits) {
                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                s->opt_len += ((long)bits - (long)tree[m].Len)
                              *(long)tree[m].Freq;
                tree[m].Len = (ush)bits;
            }
            n--;
        }
    }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
local void gen_codes (
    ct_data *tree,             /* the tree to decorate */
    int max_code,              /* largest code with non zero frequency */
    ushf *bl_count)            /* number of codes at each bit length */
{
    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
    ush code = 0;              /* running code value */
    int bits;                  /* bit index */
    int n;                     /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            "inconsistent bit counts");
    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
        int len = tree[n].Len;
        if (len == 0) continue;
        /* Now reverse the bits */
        tree[n].Code = (unsigned short)bi_reverse(next_code[len]++, len);

        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
local void build_tree(
    deflate_state *s,
    tree_desc *desc) /* the tree descriptor */
{
    ct_data *tree         = desc->dyn_tree;
    const ct_data *stree  = desc->stat_desc->static_tree;
    int elems             = desc->stat_desc->elems;
    int n, m;          /* iterate over heap elements */
    int max_code = -1; /* largest code with non zero frequency */
    int node;          /* new node being created */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    s->heap_len = 0, s->heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
        if (tree[n].Freq != 0) {
            s->heap[++(s->heap_len)] = max_code = n;
            s->depth[n] = 0;
        } else {
            tree[n].Len = 0;
        }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (s->heap_len < 2) {
        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
        tree[node].Freq = 1;
        s->depth[node] = 0;
        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
        /* node is 0 or 1 so it does not have extra bits */
    }
    desc->max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    node = elems;              /* next internal node of the tree */
    do {
        pqremove(s, tree, n);  /* n = node of least frequency */
        m = s->heap[SMALLEST]; /* m = node of next least frequency */

        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
        s->heap[--(s->heap_max)] = m;

        /* Create a new node father of n and m */
        tree[node].Freq = tree[n].Freq + tree[m].Freq;
        s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
        tree[n].Dad = tree[m].Dad = (ush)node;
#ifdef DUMP_BL_TREE
        if (tree == s->bl_tree) {
            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        }
#endif
        /* and insert the new node in the heap */
        s->heap[SMALLEST] = node++;
        pqdownheap(s, tree, SMALLEST);

    } while (s->heap_len >= 2);

    s->heap[--(s->heap_max)] = s->heap[SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    gen_bitlen(s, (tree_desc *)desc);

    /* The field len is now set, we can generate the bit codes */
    gen_codes ((ct_data *)tree, max_code, s->bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
local void scan_tree (
    deflate_state *s,
    ct_data *tree,   /* the tree to be scanned */
    int max_code)    /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    if (nextlen == 0) max_count = 138, min_count = 3;
    tree[max_code+1].Len = (ush)0xffff; /* guard */

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            s->bl_tree[curlen].Freq += (unsigned short)count;
        } else if (curlen != 0) {
            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
            s->bl_tree[REP_3_6].Freq++;
        } else if (count <= 10) {
            s->bl_tree[REPZ_3_10].Freq++;
        } else {
            s->bl_tree[REPZ_11_138].Freq++;
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
local void send_tree (
    deflate_state *s,
    ct_data *tree, /* the tree to be scanned */
    int max_code)       /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    /* tree[max_code+1].Len = -1; */  /* guard already set */
    if (nextlen == 0) max_count = 138, min_count = 3;

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

        } else if (curlen != 0) {
            if (curlen != prevlen) {
                send_code(s, curlen, s->bl_tree); count--;
            }
            Assert(count >= 3 && count <= 6, " 3_6?");
            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

        } else if (count <= 10) {
            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

        } else {
            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
local int build_bl_tree(
    deflate_state *s)
{
    int max_blindex;  /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */
    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

    /* Build the bit length tree: */
    build_tree(s, (tree_desc *)(&(s->bl_desc)));
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    s->opt_len += 3*(max_blindex+1) + 5+5+4;
    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
            s->opt_len, s->static_len));

    return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
local void send_all_trees(
    deflate_state *s,
    int lcodes,  /* number of codes for each tree */
    int dcodes,  /* number of codes for each tree */
    int blcodes) /* number of codes for each tree */
{
    int rank;                    /* index in bl_order */

    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            "too many codes");
    Tracev((stderr, "\nbl counts: "));
    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
    send_bits(s, dcodes-1,   5);
    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
    for (rank = 0; rank < blcodes; rank++) {
        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
    }
    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Send a stored block
 */
void _tr_stored_block(
    deflate_state *s,
    charf *buf,       /* input block */
    ulg stored_len,   /* length of input block */
    int eof)          /* true if this is the last block for a file */
{
    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
#ifdef DEBUG
    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
    s->compressed_len += (stored_len + 4) << 3;
#endif
    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 * The current inflate code requires 9 bits of lookahead. If the
 * last two codes for the previous block (real code plus EOB) were coded
 * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
 * the last real code. In this case we send two empty static blocks instead
 * of one. (There are no problems if the previous block is stored or fixed.)
 * To simplify the code, we assume the worst case of last real code encoded
 * on one bit only.
 */
void _tr_align(
    deflate_state *s)
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
    /* Of the 10 bits for the empty block, we have already sent
     * (10 - bi_valid) bits. The lookahead for the last real code (before
     * the EOB of the previous block) was thus at least one plus the length
     * of the EOB plus what we have just sent of the empty static block.
     */
    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
        send_bits(s, STATIC_TREES<<1, 3);
        send_code(s, END_BLOCK, static_ltree);
#ifdef DEBUG
        s->compressed_len += 10L;
#endif
        bi_flush(s);
    }
    s->last_eob_len = 7;
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
void _tr_flush_block(
    deflate_state *s,
    charf *buf,       /* input block, or NULL if too old */
    ulg stored_len,   /* length of input block */
    int eof)          /* true if this is the last block for a file */
{
    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
    int max_blindex = 0;  /* index of last bit length code of non zero freq */

    /* Build the Huffman trees unless a stored block is forced */
    if (s->level > 0) {

         /* Check if the file is ascii or binary */
        if (s->data_type == Z_UNKNOWN) set_data_type(s);

        /* Construct the literal and distance trees */
        build_tree(s, (tree_desc *)(&(s->l_desc)));
        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
                s->static_len));

        build_tree(s, (tree_desc *)(&(s->d_desc)));
        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
                s->static_len));
        /* At this point, opt_len and static_len are the total bit lengths of
         * the compressed block data, excluding the tree representations.
         */

        /* Build the bit length tree for the above two trees, and get the index
         * in bl_order of the last bit length code to send.
         */
        max_blindex = build_bl_tree(s);

        /* Determine the best encoding. Compute first the block length in bytes*/
        opt_lenb = (s->opt_len+3+7)>>3;
        static_lenb = (s->static_len+3+7)>>3;

        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
                s->last_lit));

        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

    } else {
        Assert(buf != (char*)0, "lost buf");
        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
    }

#ifdef FORCE_STORED
    if (buf != (char*)0) { /* force stored block */
#else
    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
                       /* 4: two words for the lengths */
#endif
        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block(s, buf, stored_len, eof);

#ifdef FORCE_STATIC
    } else if (static_lenb >= 0) { /* force static trees */
#else
    } else if (static_lenb == opt_lenb) {
#endif
        send_bits(s, (STATIC_TREES<<1)+eof, 3);
        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->static_len;
#endif
    } else {
        send_bits(s, (DYN_TREES<<1)+eof, 3);
        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                       max_blindex+1);
        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->opt_len;
#endif
    }
    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
    /* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */
    init_block(s);

    if (eof) {
        bi_windup(s);
#ifdef DEBUG
        s->compressed_len += 7;  /* align on byte boundary */
#endif
    }
    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
           s->compressed_len-7*eof));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
int _tr_tally (
    deflate_state *s,
    unsigned dist,  /* distance of matched string */
    unsigned lc)    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
    s->d_buf[s->last_lit] = (ush)dist;
    s->l_buf[s->last_lit++] = (uch)lc;
    if (dist == 0) {
        /* lc is the unmatched char */
        s->dyn_ltree[lc].Freq++;
    } else {
        s->matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        Assert((ush)dist < (ush)MAX_DIST(s) &&
               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
        s->dyn_dtree[d_code(dist)].Freq++;
    }

#ifdef TRUNCATE_BLOCK
    /* Try to guess if it is profitable to stop the current block here */
    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
        /* Compute an upper bound for the compressed length */
        ulg out_length = (ulg)s->last_lit*8L;
        ulg in_length = (ulg)((long)s->strstart - s->block_start);
        int dcode;
        for (dcode = 0; dcode < D_CODES; dcode++) {
            out_length += (ulg)s->dyn_dtree[dcode].Freq *
                (5L+extra_dbits[dcode]);
        }
        out_length >>= 3;
        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
               s->last_lit, in_length, out_length,
               100L - out_length*100L/in_length));
        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
    }
#endif
    return (s->last_lit == s->lit_bufsize-1);
    /* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
local void compress_block(
    deflate_state *s,
    ct_data *ltree, /* literal tree */
    ct_data *dtree) /* distance tree */
{
    unsigned dist;      /* distance of matched string */
    int lc;             /* match length or unmatched char (if dist == 0) */
    unsigned lx = 0;    /* running index in l_buf */
    unsigned code;      /* the code to send */
    int extra;          /* number of extra bits to send */

    if (s->last_lit != 0) do {
        dist = s->d_buf[lx];
        lc = s->l_buf[lx++];
        if (dist == 0) {
            send_code(s, lc, ltree); /* send a literal byte */
            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = _length_code[lc];
            send_code(s, code+LITERALS+1, ltree); /* send the length code */
            extra = extra_lbits[code];
            if (extra != 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);       /* send the extra length bits */
            }
            dist--; /* dist is now the match distance - 1 */
            code = d_code(dist);
            Assert (code < D_CODES, "bad d_code");

            send_code(s, code, dtree);       /* send the distance code */
            extra = extra_dbits[code];
            if (extra != 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);   /* send the extra distance bits */
            }
        } /* literal or match pair ? */

        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
        Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");

    } while (lx < s->last_lit);

    send_code(s, END_BLOCK, ltree);
    s->last_eob_len = ltree[END_BLOCK].Len;
}

/* ===========================================================================
 * Set the data type to ASCII or BINARY, using a crude approximation:
 * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
 * IN assertion: the fields freq of dyn_ltree are set and the total of all
 * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
 */
local void set_data_type(
    deflate_state *s)
{
    int n = 0;
    unsigned ascii_freq = 0;
    unsigned bin_freq = 0;
    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
local unsigned bi_reverse(
    unsigned code, /* the value to invert */
    int len)       /* its bit length */
{
    register unsigned res = 0;
    do {
        res |= code & 1;
        code >>= 1, res <<= 1;
    } while (--len > 0);
    return res >> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
local void bi_flush(
    deflate_state *s)
{
    if (s->bi_valid == 16) {
        put_short(s, s->bi_buf);
        s->bi_buf = 0;
        s->bi_valid = 0;
    } else if (s->bi_valid >= 8) {
        put_byte(s, (Byte)s->bi_buf);
        s->bi_buf >>= 8;
        s->bi_valid -= 8;
    }
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
local void bi_windup(
    deflate_state *s)
{
    if (s->bi_valid > 8) {
        put_short(s, s->bi_buf);
    } else if (s->bi_valid > 0) {
        put_byte(s, (Byte)s->bi_buf);
    }
    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef DEBUG
    s->bits_sent = (s->bits_sent+7) & ~7;
#endif
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
local void copy_block(
    deflate_state *s,
    charf    *buf,    /* the input data */
    unsigned len,     /* its length */
    int      header)  /* true if block header must be written */
{
    bi_windup(s);        /* align on byte boundary */
    s->last_eob_len = 8; /* enough lookahead for inflate */

    if (header) {
        put_short(s, (ush)len);
        put_short(s, (ush)~len);
#ifdef DEBUG
        s->bits_sent += 2*16;
#endif
    }
#ifdef DEBUG
    s->bits_sent += (ulg)len<<3;
#endif
    while (len--) {
        put_byte(s, *buf++);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\zlib.h ===
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.1.3, July 9th, 1998

  Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef _ZLIB_H
#define _ZLIB_H

/* For Xbox link this with d3dx8.lib, and place in appropriate section */
#include <d3dx8seg.h>

#include "zconf.h"

namespace D3DX
{

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.1.3"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce some
  output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows. deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far. (In particular
  avail_in is zero after the call if enough output space has been provided
  before the call.)  Flushing may degrade compression for some compression
  algorithms and so it should be used only when necessary.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
  the compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
   value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller.  msg is set to null if there is no error
   message. inflateInit does not perform any decompression apart from reading
   the zlib header if present: this will be done by inflate().  (So next_in and
   avail_in may be modified, but next_out and avail_out are unchanged.)
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may some
  introduce some output latency (reading input without producing any output)
  except when forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_SYNC_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

     If a preset dictionary is needed at this point (see inflateSetDictionary
  below), inflate sets strm-adler to the adler32 checksum of the
  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
  it sets strm->adler to the adler32 checksum of all output produced
  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
  an error code as described below. At the end of the stream, inflate()
  checks that its computed adler32 checksum is equal to that saved by the
  compressor and returns Z_STREAM_END only if the checksum is correct.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect
  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
  case, the application may then call inflateSync to look for a good
  compression block.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library. Larger values of this parameter result in better
   compression at the expense of memory usage. The default value is 15 if
   deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
   method). msg is set to null if there is no error message.  deflateInit2 does
   not perform any compression: this will be done by deflate().
*/
                            
ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output. This function must be called
   immediately after deflateInit, deflateInit2 or deflateReset, before any
   call of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size in
   deflate or deflate2. Thus the strings most likely to be useful should be
   put at the end of the dictionary, not at the front.

     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if the compression method is bsort). deflateSetDictionary does not
   perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
				      int level,
				      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different
   strategy. If the compression level is changed, the input available so far
   is compressed with the old level (and may be flushed); the new level will
   take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter. The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library. The default value is 15 if inflateInit is used
   instead. If a compressed stream with a larger window size is given as
   input, inflate() will return with the error code Z_DATA_ERROR instead of
   trying to allocate a larger window.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
   memLevel). msg is set to null if there is no error message.  inflateInit2
   does not perform any decompression apart from reading the zlib header if
   present: this will be done by inflate(). (So next_in and avail_in may be
   modified, but next_out and avail_out are unchanged.)
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence. This function must be called immediately after a call of inflate
   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
   can be determined from the Adler32 value returned by this call of
   inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/* 
    Skips invalid compressed data until a full flush point (see above the
  description of deflate with Z_FULL_FLUSH) can be found, or until all
  available input is skipped. No output is provided.

    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level and memory usage,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
   Huffman only compression as in "wb1h". (See the description
   of deflateInit2 for more information about the strategy parameter.)

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.

     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).  */

ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy. See the description
   of deflateInit2 for the meaning of these parameters.
     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
				   const voidp buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
      Reads bytes from the compressed file until len-1 characters are read, or
   a newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  The string is then terminated with a null
   character.
      gzgets returns buf, or Z_NULL in case of error.
*/

ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
/*
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
/*
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/

ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
				      z_off_t offset, int whence));
/* 
      Sets the starting position for the next gzread or gzwrite on the
   given compressed file. The offset represents a number of bytes in the
   uncompressed data stream. The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.
     If the file is opened for reading, this function is emulated but can be
   extremely slow. If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
/*
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.

   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))


#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

ZEXTERN const char   * ZEXPORT zError           OF((int err));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));

#ifdef __cplusplus
}
#endif

}

#endif /* _ZLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\zutil.h ===
/* zutil.h -- internal interface and configuration of the compression library
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef _Z_UTIL_H
#define _Z_UTIL_H

#include "zlib.h"

#ifdef STDC
#  include <stddef.h>
#  include <string.h>
#  include <stdlib.h>
#endif
#ifdef NO_ERRNO_H
    extern int errno;
#else
#   include <errno.h>
#endif

namespace D3DX
{

#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

typedef unsigned char  uch;
typedef uch FAR uchf;
typedef unsigned short ush;
typedef ush FAR ushf;
typedef unsigned long  ulg;

extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
/* (size given to avoid silly warnings with Visual C++) */

#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

#define ERR_RETURN(strm,err) \
  return (strm->msg = (char*)ERR_MSG(err), (err))
/* To be used only when the state is known to be valid */

        /* common constants */

#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
/* default windowBits for decompression. MAX_WBITS is for compression only */

#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
/* default memLevel */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

        /* target dependencies */

#ifdef MSDOS
#  define OS_CODE  0x00
#  if defined(__TURBOC__) || defined(__BORLANDC__)
#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
       /* Allow compilation with ANSI keywords only enabled */
       void _Cdecl farfree( void *block );
       void *_Cdecl farmalloc( unsigned long nbytes );
#    else
#     include <alloc.h>
#    endif
#  else /* MSC or DJGPP */
#    include <malloc.h>
#  endif
#endif

#ifdef OS2
#  define OS_CODE  0x06
#endif

#ifdef WIN32 /* Window 95 & Windows NT */
#  define OS_CODE  0x0b
#endif

#if defined(VAXC) || defined(VMS)
#  define OS_CODE  0x02
#  define F_OPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif

#ifdef AMIGA
#  define OS_CODE  0x01
#endif

#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
#endif

#if defined(MACOS) || defined(TARGET_OS_MAC)
#  define OS_CODE  0x07
#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#    include <unix.h> /* for fdopen */
#  else
#    ifndef fdopen
#      define fdopen(fd,mode) NULL /* No fdopen() */
#    endif
#  endif
#endif

#ifdef __50SERIES /* Prime/PRIMOS */
#  define OS_CODE  0x0F
#endif

#ifdef TOPS20
#  define OS_CODE  0x0a
#endif

#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL /* No fdopen() */
#endif

#if (defined(_MSC_VER) && (_MSC_VER > 600))
#  define fdopen(fd,type)  _fdopen(fd,type)
#endif


        /* Common defaults */

#ifndef OS_CODE
#  define OS_CODE  0x03  /* assume Unix */
#endif

#ifndef F_OPEN
#  define F_OPEN(name, mode) fopen((name), (mode))
#endif

         /* functions */

#ifdef HAVE_STRERROR
   extern char *strerror OF((int));
#  define zstrerror(errnum) strerror(errnum)
#else
#  define zstrerror(errnum) ""
#endif

#if defined(pyr)
#  define NO_MEMCPY
#endif
#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
 /* Use our own functions for small and medium model with MSC <= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  * The __SC__ check is for Symantec.
  */
#  define NO_MEMCPY
#endif
#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#ifdef HAVE_MEMCPY
#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
   extern void zmemzero OF((Bytef* dest, uInt len));
#endif

/* Diagnostic functions */
#ifdef DEBUG
#  include <stdio.h>
   extern int z_verbose;
   extern void z_error    OF((char *m));
#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif


typedef uLong (ZEXPORT *check_func) OF((uLong check, const Bytef *buf,
				       uInt len));
voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
void   zcfree  OF((voidpf opaque, voidpf ptr));

#define ZALLOC(strm, items, size) \
           (*((strm)->zalloc))((strm)->opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}

}
#endif /* _Z_UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\zutil.cpp ===
/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zutil.h"

namespace D3DX
{

struct internal_state      {int dummy;}; /* for buggy compilers */

#ifndef STDC
extern void exit OF((int));
#endif

const char *z_errmsg[10] = {
"need dictionary",     /* Z_NEED_DICT       2  */
"stream end",          /* Z_STREAM_END      1  */
"",                    /* Z_OK              0  */
"file error",          /* Z_ERRNO         (-1) */
"stream error",        /* Z_STREAM_ERROR  (-2) */
"data error",          /* Z_DATA_ERROR    (-3) */
"insufficient memory", /* Z_MEM_ERROR     (-4) */
"buffer error",        /* Z_BUF_ERROR     (-5) */
"incompatible version",/* Z_VERSION_ERROR (-6) */
""};


const char * ZEXPORT zlibVersion()
{
    return ZLIB_VERSION;
}

#ifdef DEBUG

#  ifndef verbose
#    define verbose 0
#  endif
int z_verbose = verbose;

void z_error (
    char *m)
{
    fprintf(stderr, "%s\n", m);
    exit(1);
}
#endif

/* exported to allow conversion of error code to string for compress() and
 * uncompress()
 */
const char * ZEXPORT zError(
    int err)
{
    return ERR_MSG(err);
}


#ifndef HAVE_MEMCPY

void zmemcpy(
    Bytef* dest,
    const Bytef* source,
    uInt  len)
{
    if (len == 0) return;
    do {
        *dest++ = *source++; /* ??? to be unrolled */
    } while (--len != 0);
}

int zmemcmp(
    const Bytef* s1,
    const Bytef* s2,
    uInt  len)
{
    uInt j;

    for (j = 0; j < len; j++) {
        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
    }
    return 0;
}

void zmemzero(
    Bytef* dest,
    uInt  len)
{
    if (len == 0) return;
    do {
        *dest++ = 0;  /* ??? to be unrolled */
    } while (--len != 0);
}
#endif

#ifdef __TURBOC__
#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) && !defined(__32BIT__)
/* Small and medium model in Turbo C are for now limited to near allocation
 * with reduced MAX_WBITS and MAX_MEM_LEVEL
 */
#  define MY_ZCALLOC

/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
 * and farmalloc(64K) returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */

#define MAX_PTR 10
/* 10*64K = 640K */

local int next_ptr = 0;

typedef struct ptr_table_s {
    voidpf org_ptr;
    voidpf new_ptr;
} ptr_table;

local ptr_table table[MAX_PTR];
/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since MSDOS is not a preemptive multitasking OS, this table is not
 * protected from concurrent access. This hack doesn't work anyway on
 * a protected system like OS/2. Use Microsoft C instead.
 */

voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    voidpf buf = opaque; /* just to make some compilers happy */
    ulg bsize = (ulg)items*size;

    /* If we allocate less than 65520 bytes, we assume that farmalloc
     * will return a usable pointer which doesn't have to be normalized.
     */
    if (bsize < 65520L) {
        buf = farmalloc(bsize);
        if (*(ush*)&buf != 0) return buf;
    } else {
        buf = farmalloc(bsize + 16L);
    }
    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
    table[next_ptr].org_ptr = buf;

    /* Normalize the pointer to seg:0 */
    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
    *(ush*)&buf = 0;
    table[next_ptr++].new_ptr = buf;
    return buf;
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    int n;
    if (*(ush*)&ptr != 0) { /* object < 64K */
        farfree(ptr);
        return;
    }
    /* Find the original pointer */
    for (n = 0; n < next_ptr; n++) {
        if (ptr != table[n].new_ptr) continue;

        farfree(table[n].org_ptr);
        while (++n < next_ptr) {
            table[n-1] = table[n];
        }
        next_ptr--;
        return;
    }
    ptr = opaque; /* just to make some compilers happy */
    Assert(0, "zcfree: ptr not found");
}
#endif
#endif /* __TURBOC__ */


#if defined(M_I86) && !defined(__32BIT__)
/* Microsoft C in 16-bit mode */

#  define MY_ZCALLOC

#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
#  define _halloc  halloc
#  define _hfree   hfree
#endif

voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    return _halloc((long)items, size);
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    _hfree(ptr);
}

#endif /* MSC */


#ifndef MY_ZCALLOC /* Any system without a special alloc function */

#ifndef STDC
extern voidp  calloc OF((uInt items, uInt size));
extern void   free   OF((voidpf ptr));
#endif

voidpf zcalloc (
    voidpf opaque,
    unsigned items,
    unsigned size)
{
    if (opaque) items += size - size; /* make compiler happy */
    return (voidpf)calloc(items, size);
}

void  zcfree (
    voidpf opaque,
    voidpf ptr)
{
    free(ptr);
    if (opaque) return; /* make compiler happy */
}

#endif /* MY_ZCALLOC */

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\asm386\gvmat32.asm ===
;
; gvmat32.asm -- Asm portion of the optimized longest_match for 32 bits x86
; Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.
; File written by Gilles Vollant, by modifiying the longest_match
;  from Jean-loup Gailly in deflate.c
; It need wmask == 0x7fff
;     (assembly code is faster with a fixed wmask)
;
; For Visual C++ 4.2 and ML 6.11c (version in directory \MASM611C of Win95 DDK)
;   I compile with : "ml /coff /Zi /c gvmat32.asm"
;

;uInt longest_match_7fff(s, cur_match)
;    deflate_state *s;
;    IPos cur_match;                             /* current match */

        NbStack         equ     76
        cur_match       equ     dword ptr[esp+NbStack-0]
        str_s           equ     dword ptr[esp+NbStack-4]
; 5 dword on top (ret,ebp,esi,edi,ebx)
        adrret          equ     dword ptr[esp+NbStack-8]
        pushebp         equ     dword ptr[esp+NbStack-12]
        pushedi         equ     dword ptr[esp+NbStack-16]
        pushesi         equ     dword ptr[esp+NbStack-20]
        pushebx         equ     dword ptr[esp+NbStack-24]

        chain_length    equ     dword ptr [esp+NbStack-28]
        limit           equ     dword ptr [esp+NbStack-32]
        best_len        equ     dword ptr [esp+NbStack-36]
        window          equ     dword ptr [esp+NbStack-40]
        prev            equ     dword ptr [esp+NbStack-44]
        scan_start      equ      word ptr [esp+NbStack-48]
        wmask           equ     dword ptr [esp+NbStack-52]
        match_start_ptr equ     dword ptr [esp+NbStack-56]
        nice_match      equ     dword ptr [esp+NbStack-60]
        scan            equ     dword ptr [esp+NbStack-64]

        windowlen       equ     dword ptr [esp+NbStack-68]
        match_start     equ     dword ptr [esp+NbStack-72]
        strend          equ     dword ptr [esp+NbStack-76]
        NbStackAdd      equ     (NbStack-24)

    .386p

    name    gvmatch
    .MODEL  FLAT



;  all the +4 offsets are due to the addition of pending_buf_size (in zlib
;  in the deflate_state structure since the asm code was first written
;  (if you compile with zlib 1.0.4 or older, remove the +4).
;  Note : these value are good with a 8 bytes boundary pack structure
    dep_chain_length    equ     70h+4
    dep_window          equ     2ch+4
    dep_strstart        equ     60h+4
    dep_prev_length     equ     6ch+4
    dep_nice_match      equ     84h+4
    dep_w_size          equ     20h+4
    dep_prev            equ     34h+4
    dep_w_mask          equ     28h+4
    dep_good_match      equ     80h+4
    dep_match_start     equ     64h+4
    dep_lookahead       equ     68h+4


_TEXT                   segment

IFDEF NOUNDERLINE
                        public  longest_match_7fff
;                        public  match_init
ELSE
                        public  _longest_match_7fff
;                        public  _match_init
ENDIF

    MAX_MATCH           equ     258
    MIN_MATCH           equ     3
    MIN_LOOKAHEAD       equ     (MAX_MATCH+MIN_MATCH+1)



IFDEF NOUNDERLINE
;match_init      proc near
;                ret
;match_init      endp
ELSE
;_match_init     proc near
;                ret
;_match_init     endp
ENDIF


IFDEF NOUNDERLINE
longest_match_7fff   proc near
ELSE
_longest_match_7fff  proc near
ENDIF

        mov     edx,[esp+4]



        push    ebp
        push    edi
        push    esi
        push    ebx

        sub     esp,NbStackAdd

; initialize or check the variables used in match.asm.
        mov     ebp,edx

; chain_length = s->max_chain_length
; if (prev_length>=good_match) chain_length >>= 2
        mov     edx,[ebp+dep_chain_length]
        mov     ebx,[ebp+dep_prev_length]
        cmp     [ebp+dep_good_match],ebx
        ja      noshr
        shr     edx,2
noshr:
; we increment chain_length because in the asm, the --chain_lenght is in the beginning of the loop
        inc     edx
        mov     edi,[ebp+dep_nice_match]
        mov     chain_length,edx
        mov     eax,[ebp+dep_lookahead]
        cmp     eax,edi
; if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
        jae     nolookaheadnicematch
        mov     edi,eax
nolookaheadnicematch:
; best_len = s->prev_length
        mov     best_len,ebx

; window = s->window
        mov     esi,[ebp+dep_window]
        mov     ecx,[ebp+dep_strstart]
        mov     window,esi

        mov     nice_match,edi
; scan = window + strstart
        add     esi,ecx
        mov     scan,esi
; dx = *window
        mov     dx,word ptr [esi]
; bx = *(window+best_len-1)
        mov     bx,word ptr [esi+ebx-1]
        add     esi,MAX_MATCH-1
; scan_start = *scan
        mov     scan_start,dx
; strend = scan + MAX_MATCH-1
        mov     strend,esi
; bx = scan_end = *(window+best_len-1)

;    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
;        s->strstart - (IPos)MAX_DIST(s) : NIL;

        mov     esi,[ebp+dep_w_size]
        sub     esi,MIN_LOOKAHEAD
; here esi = MAX_DIST(s)
        sub     ecx,esi
        ja      nodist
        xor     ecx,ecx
nodist:
        mov     limit,ecx

; prev = s->prev
        mov     edx,[ebp+dep_prev]
        mov     prev,edx

;
        mov     edx,dword ptr [ebp+dep_match_start]
        mov     bp,scan_start
        mov     eax,cur_match
        mov     match_start,edx

        mov     edx,window
        mov     edi,edx
        add     edi,best_len
        mov     esi,prev
        dec     edi
; windowlen = window + best_len -1
        mov     windowlen,edi

        jmp     beginloop2
        align   4

; here, in the loop
;       eax = ax = cur_match
;       ecx = limit
;        bx = scan_end
;        bp = scan_start
;       edi = windowlen (window + best_len -1)
;       esi = prev


;// here; chain_length <=16
normalbeg0add16:
        add     chain_length,16
        jz      exitloop
normalbeg0:
        cmp     word ptr[edi+eax],bx
        je      normalbeg2noroll
rcontlabnoroll:
; cur_match = prev[cur_match & wmask]
        and     eax,7fffh
        mov     ax,word ptr[esi+eax*2]
; if cur_match > limit, go to exitloop
        cmp     ecx,eax
        jnb     exitloop
; if --chain_length != 0, go to exitloop
        dec     chain_length
        jnz     normalbeg0
        jmp     exitloop

normalbeg2noroll:
; if (scan_start==*(cur_match+window)) goto normalbeg2
        cmp     bp,word ptr[edx+eax]
        jne     rcontlabnoroll
        jmp     normalbeg2

contloop3:
        mov     edi,windowlen

; cur_match = prev[cur_match & wmask]
        and     eax,7fffh
        mov     ax,word ptr[esi+eax*2]
; if cur_match > limit, go to exitloop
        cmp     ecx,eax
jnbexitloopshort1:
        jnb     exitloop
; if --chain_length != 0, go to exitloop


; begin the main loop
beginloop2:
        sub     chain_length,16+1
; if chain_length <=16, don't use the unrolled loop
        jna     normalbeg0add16

do16:
        cmp     word ptr[edi+eax],bx
        je      normalbeg2dc0

maccn   MACRO   lab
        and     eax,7fffh
        mov     ax,word ptr[esi+eax*2]
        cmp     ecx,eax
        jnb     exitloop
        cmp     word ptr[edi+eax],bx
        je      lab
        ENDM

rcontloop0:
        maccn   normalbeg2dc1

rcontloop1:
        maccn   normalbeg2dc2

rcontloop2:
        maccn   normalbeg2dc3

rcontloop3:
        maccn   normalbeg2dc4

rcontloop4:
        maccn   normalbeg2dc5

rcontloop5:
        maccn   normalbeg2dc6

rcontloop6:
        maccn   normalbeg2dc7

rcontloop7:
        maccn   normalbeg2dc8

rcontloop8:
        maccn   normalbeg2dc9

rcontloop9:
        maccn   normalbeg2dc10

rcontloop10:
        maccn   short normalbeg2dc11

rcontloop11:
        maccn   short normalbeg2dc12

rcontloop12:
        maccn   short normalbeg2dc13

rcontloop13:
        maccn   short normalbeg2dc14

rcontloop14:
        maccn   short normalbeg2dc15

rcontloop15:
        and     eax,7fffh
        mov     ax,word ptr[esi+eax*2]
        cmp     ecx,eax
        jnb     exitloop

        sub     chain_length,16
        ja      do16
        jmp     normalbeg0add16

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

normbeg MACRO   rcontlab,valsub
; if we are here, we know that *(match+best_len-1) == scan_end
        cmp     bp,word ptr[edx+eax]
; if (match != scan_start) goto rcontlab
        jne     rcontlab
; calculate the good chain_length, and we'll compare scan and match string
        add     chain_length,16-valsub
        jmp     iseq
        ENDM


normalbeg2dc11:
        normbeg rcontloop11,11

normalbeg2dc12:
        normbeg short rcontloop12,12

normalbeg2dc13:
        normbeg short rcontloop13,13

normalbeg2dc14:
        normbeg short rcontloop14,14

normalbeg2dc15:
        normbeg short rcontloop15,15

normalbeg2dc10:
        normbeg rcontloop10,10

normalbeg2dc9:
        normbeg rcontloop9,9

normalbeg2dc8:
        normbeg rcontloop8,8

normalbeg2dc7:
        normbeg rcontloop7,7

normalbeg2dc6:
        normbeg rcontloop6,6

normalbeg2dc5:
        normbeg rcontloop5,5

normalbeg2dc4:
        normbeg rcontloop4,4

normalbeg2dc3:
        normbeg rcontloop3,3

normalbeg2dc2:
        normbeg rcontloop2,2

normalbeg2dc1:
        normbeg rcontloop1,1

normalbeg2dc0:
        normbeg rcontloop0,0


; we go in normalbeg2 because *(ushf*)(match+best_len-1) == scan_end

normalbeg2:
        mov     edi,window

        cmp     bp,word ptr[edi+eax]
        jne     contloop3                   ; if *(ushf*)match != scan_start, continue

iseq:
; if we are here, we know that *(match+best_len-1) == scan_end
; and (match == scan_start)

        mov     edi,edx
        mov     esi,scan                    ; esi = scan
        add     edi,eax                     ; edi = window + cur_match = match

        mov     edx,[esi+3]                 ; compare manually dword at match+3
        xor     edx,[edi+3]                 ; and scan +3

        jz      begincompare                ; if equal, go to long compare

; we will determine the unmatch byte and calculate len (in esi)
        or      dl,dl
        je      eq1rr
        mov     esi,3
        jmp     trfinval
eq1rr:
        or      dx,dx
        je      eq1

        mov     esi,4
        jmp     trfinval
eq1:
        and     edx,0ffffffh
        jz      eq11
        mov     esi,5
        jmp     trfinval
eq11:
        mov     esi,6
        jmp     trfinval

begincompare:
        ; here we now scan and match begin same
        add     edi,6
        add     esi,6
        mov     ecx,(MAX_MATCH-(2+4))/4     ; scan for at most MAX_MATCH bytes
        repe    cmpsd                       ; loop until mismatch

        je      trfin                       ; go to trfin if not unmatch
; we determine the unmatch byte
        sub     esi,4
        mov     edx,[edi-4]
        xor     edx,[esi]

        or      dl,dl
        jnz     trfin
        inc     esi

        or      dx,dx
        jnz     trfin
        inc     esi

        and     edx,0ffffffh
        jnz     trfin
        inc     esi

trfin:
        sub     esi,scan          ; esi = len
trfinval:
; here we have finised compare, and esi contain len of equal string
        cmp     esi,best_len        ; if len > best_len, go newbestlen
        ja      short newbestlen
; now we restore edx, ecx and esi, for the big loop
        mov     esi,prev
        mov     ecx,limit
        mov     edx,window
        jmp     contloop3

newbestlen:
        mov     best_len,esi        ; len become best_len

        mov     match_start,eax     ; save new position as match_start
        cmp     esi,nice_match      ; if best_len >= nice_match, exit
        jae     exitloop
        mov     ecx,scan
        mov     edx,window          ; restore edx=window
        add     ecx,esi
        add     esi,edx

        dec     esi
        mov     windowlen,esi       ; windowlen = window + best_len-1
        mov     bx,[ecx-1]          ; bx = *(scan+best_len-1) = scan_end

; now we restore ecx and esi, for the big loop :
        mov     esi,prev
        mov     ecx,limit
        jmp     contloop3

exitloop:
; exit : s->match_start=match_start
        mov     ebx,match_start
        mov     ebp,str_s
        mov     ecx,best_len
        mov     dword ptr [ebp+dep_match_start],ebx        
        mov     eax,dword ptr [ebp+dep_lookahead]
        cmp     ecx,eax
        ja      minexlo
        mov     eax,ecx
minexlo:
; return min(best_len,s->lookahead)
        
; restore stack and register ebx,esi,edi,ebp
        add     esp,NbStackAdd

        pop     ebx
        pop     esi
        pop     edi
        pop     ebp
        ret
InfoAuthor:
; please don't remove this string !
; Your are free use gvmat32 in any fre or commercial apps if you don't remove the string in the binary!
        db     0dh,0ah,"GVMat32 optimised assembly code written 1996-98 by Gilles Vollant",0dh,0ah



IFDEF NOUNDERLINE
longest_match_7fff   endp
ELSE
_longest_match_7fff  endp
ENDIF


IFDEF NOUNDERLINE
cpudetect32     proc near
ELSE
_cpudetect32    proc near
ENDIF


	pushfd                  ; push original EFLAGS
	pop     eax             ; get original EFLAGS
	mov     ecx, eax        ; save original EFLAGS
	xor     eax, 40000h     ; flip AC bit in EFLAGS
	push    eax             ; save new EFLAGS value on stack
	popfd                   ; replace current EFLAGS value
	pushfd                  ; get new EFLAGS
	pop     eax             ; store new EFLAGS in EAX
	xor     eax, ecx        ; cant toggle AC bit, processor=80386
	jz      end_cpu_is_386  ; jump if 80386 processor
	push    ecx
	popfd                   ; restore AC bit in EFLAGS first

	pushfd
	pushfd
	pop     ecx
			
	mov     eax, ecx        ; get original EFLAGS
	xor     eax, 200000h    ; flip ID bit in EFLAGS
	push    eax             ; save new EFLAGS value on stack
	popfd                   ; replace current EFLAGS value
	pushfd                  ; get new EFLAGS
	pop		eax	            ; store new EFLAGS in EAX
	popfd                   ; restore original EFLAGS
	xor		eax, ecx        ; cant toggle ID bit,
	je		is_old_486		; processor=old

	mov     eax,1
	db      0fh,0a2h        ;CPUID   

exitcpudetect:
	ret

end_cpu_is_386:
	mov     eax,0300h
	jmp     exitcpudetect

is_old_486:
	mov     eax,0400h
	jmp     exitcpudetect

IFDEF NOUNDERLINE
cpudetect32     endp
ELSE
_cpudetect32    endp
ENDIF

_TEXT   ends
end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\asm586\match.S ===
/* match.s -- Pentium-optimized version of longest_match()
 * Written for zlib 1.1.2
 * Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License.
 */

#ifndef NO_UNDERLINE
#define	match_init	_match_init
#define	longest_match	_longest_match
#endif

#define	MAX_MATCH	(258)
#define	MIN_MATCH	(3)
#define	MIN_LOOKAHEAD	(MAX_MATCH + MIN_MATCH + 1)
#define	MAX_MATCH_8	((MAX_MATCH + 7) & ~7)

/* stack frame offsets */

#define	wmask			0	/* local copy of s->wmask	*/
#define	window			4	/* local copy of s->window	*/
#define	windowbestlen		8	/* s->window + bestlen		*/
#define	chainlenscanend		12	/* high word: current chain len	*/
					/* low word: last bytes sought	*/
#define	scanstart		16	/* first two bytes of string	*/
#define	scanalign		20	/* dword-misalignment of string	*/
#define	nicematch		24	/* a good enough match size	*/
#define	bestlen			28	/* size of best match so far	*/
#define	scan			32	/* ptr to string wanting match	*/

#define	LocalVarsSize		(36)
/*	saved ebx		36 */
/*	saved edi		40 */
/*	saved esi		44 */
/*	saved ebp		48 */
/*	return address		52 */
#define	deflatestate		56	/* the function arguments	*/
#define	curmatch		60

/* Offsets for fields in the deflate_state structure. These numbers
 * are calculated from the definition of deflate_state, with the
 * assumption that the compiler will dword-align the fields. (Thus,
 * changing the definition of deflate_state could easily cause this
 * program to crash horribly, without so much as a warning at
 * compile time. Sigh.)
 */
#define	dsWSize			36
#define	dsWMask			44
#define	dsWindow		48
#define	dsPrev			56
#define	dsMatchLen		88
#define	dsPrevMatch		92
#define	dsStrStart		100
#define	dsMatchStart		104
#define	dsLookahead		108
#define	dsPrevLen		112
#define	dsMaxChainLen		116
#define	dsGoodMatch		132
#define	dsNiceMatch		136


.file "match.S"

.globl	match_init, longest_match

.text

/* uInt longest_match(deflate_state *deflatestate, IPos curmatch) */

longest_match:

/* Save registers that the compiler may be using, and adjust %esp to	*/
/* make room for our stack frame.					*/

		pushl	%ebp
		pushl	%edi
		pushl	%esi
		pushl	%ebx
		subl	$LocalVarsSize, %esp

/* Retrieve the function arguments. %ecx will hold cur_match		*/
/* throughout the entire function. %edx will hold the pointer to the	*/
/* deflate_state structure during the function's setup (before		*/
/* entering the main loop).						*/

		movl	deflatestate(%esp), %edx
		movl	curmatch(%esp), %ecx

/* if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;	*/

		movl	dsNiceMatch(%edx), %eax
		movl	dsLookahead(%edx), %ebx
		cmpl	%eax, %ebx
		jl	LookaheadLess
		movl	%eax, %ebx
LookaheadLess:	movl	%ebx, nicematch(%esp)

/* register Bytef *scan = s->window + s->strstart;			*/

		movl	dsWindow(%edx), %esi
		movl	%esi, window(%esp)
		movl	dsStrStart(%edx), %ebp
		lea	(%esi,%ebp), %edi
		movl	%edi, scan(%esp)

/* Determine how many bytes the scan ptr is off from being		*/
/* dword-aligned.							*/

		movl	%edi, %eax
		negl	%eax
		andl	$3, %eax
		movl	%eax, scanalign(%esp)

/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?			*/
/*     s->strstart - (IPos)MAX_DIST(s) : NIL;				*/

		movl	dsWSize(%edx), %eax
		subl	$MIN_LOOKAHEAD, %eax
		subl	%eax, %ebp
		jg	LimitPositive
		xorl	%ebp, %ebp
LimitPositive:

/* unsigned chain_length = s->max_chain_length;				*/
/* if (s->prev_length >= s->good_match) {				*/
/*     chain_length >>= 2;						*/
/* }									*/

		movl	dsPrevLen(%edx), %eax
		movl	dsGoodMatch(%edx), %ebx
		cmpl	%ebx, %eax
		movl	dsMaxChainLen(%edx), %ebx
		jl	LastMatchGood
		shrl	$2, %ebx
LastMatchGood:

/* chainlen is decremented once beforehand so that the function can	*/
/* use the sign flag instead of the zero flag for the exit test.	*/
/* It is then shifted into the high word, to make room for the scanend	*/
/* scanend value, which it will always accompany.			*/

		decl	%ebx
		shll	$16, %ebx

/* int best_len = s->prev_length;					*/

		movl	dsPrevLen(%edx), %eax
		movl	%eax, bestlen(%esp)

/* Store the sum of s->window + best_len in %esi locally, and in %esi.	*/

		addl	%eax, %esi
		movl	%esi, windowbestlen(%esp)

/* register ush scan_start = *(ushf*)scan;				*/
/* register ush scan_end   = *(ushf*)(scan+best_len-1);			*/

		movw	(%edi), %bx
		movw	%bx, scanstart(%esp)
		movw	-1(%edi,%eax), %bx
		movl	%ebx, chainlenscanend(%esp)

/* Posf *prev = s->prev;						*/
/* uInt wmask = s->w_mask;						*/

		movl	dsPrev(%edx), %edi
		movl	dsWMask(%edx), %edx
		mov	%edx, wmask(%esp)

/* Jump into the main loop.						*/

		jmp	LoopEntry

.balign 16

/* do {
 *     match = s->window + cur_match;
 *     if (*(ushf*)(match+best_len-1) != scan_end ||
 *         *(ushf*)match != scan_start) continue;
 *     [...]
 * } while ((cur_match = prev[cur_match & wmask]) > limit
 *          && --chain_length != 0);
 *
 * Here is the inner loop of the function. The function will spend the
 * majority of its time in this loop, and majority of that time will
 * be spent in the first ten instructions.
 *
 * Within this loop:
 * %ebx = chainlenscanend - i.e., ((chainlen << 16) | scanend)
 * %ecx = curmatch
 * %edx = curmatch & wmask
 * %esi = windowbestlen - i.e., (window + bestlen)
 * %edi = prev
 * %ebp = limit
 *
 * Two optimization notes on the choice of instructions:
 *
 * The first instruction uses a 16-bit address, which costs an extra,
 * unpairable cycle. This is cheaper than doing a 32-bit access and
 * zeroing the high word, due to the 3-cycle misalignment penalty which
 * would occur half the time. This also turns out to be cheaper than
 * doing two separate 8-bit accesses, as the memory is so rarely in the
 * L1 cache.
 *
 * The window buffer, however, apparently spends a lot of time in the
 * cache, and so it is faster to retrieve the word at the end of the
 * match string with two 8-bit loads. The instructions that test the
 * word at the beginning of the match string, however, are executed
 * much less frequently, and there it was cheaper to use 16-bit
 * instructions, which avoided the necessity of saving off and
 * subsequently reloading one of the other registers.
 */
LookupLoop:
							/* 1 U & V  */
		movw	(%edi,%edx,2), %cx		/* 2 U pipe */
		movl	wmask(%esp), %edx		/* 2 V pipe */
		cmpl	%ebp, %ecx			/* 3 U pipe */
		jbe	LeaveNow			/* 3 V pipe */
		subl	$0x00010000, %ebx		/* 4 U pipe */
		js	LeaveNow			/* 4 V pipe */
LoopEntry:	movb	-1(%esi,%ecx), %al		/* 5 U pipe */
		andl	%ecx, %edx			/* 5 V pipe */
		cmpb	%bl, %al			/* 6 U pipe */
		jnz	LookupLoop			/* 6 V pipe */
		movb	(%esi,%ecx), %ah
		cmpb	%bh, %ah
		jnz	LookupLoop
		movl	window(%esp), %eax
		movw	(%eax,%ecx), %ax
		cmpw	scanstart(%esp), %ax
		jnz	LookupLoop

/* Store the current value of chainlen.					*/

		movl	%ebx, chainlenscanend(%esp)

/* Point %edi to the string under scrutiny, and %esi to the string we	*/
/* are hoping to match it up with. In actuality, %esi and %edi are	*/
/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is	*/
/* initialized to -(MAX_MATCH_8 - scanalign).				*/

		movl	window(%esp), %esi
		movl	scan(%esp), %edi
		addl	%ecx, %esi
		movl	scanalign(%esp), %eax
		movl	$(-MAX_MATCH_8), %edx
		lea	MAX_MATCH_8(%edi,%eax), %edi
		lea	MAX_MATCH_8(%esi,%eax), %esi

/* Test the strings for equality, 8 bytes at a time. At the end,
 * adjust %edx so that it is offset to the exact byte that mismatched.
 *
 * We already know at this point that the first three bytes of the
 * strings match each other, and they can be safely passed over before
 * starting the compare loop. So what this code does is skip over 0-3
 * bytes, as much as necessary in order to dword-align the %edi
 * pointer. (%esi will still be misaligned three times out of four.)
 *
 * It should be confessed that this loop usually does not represent
 * much of the total running time. Replacing it with a more
 * straightforward "rep cmpsb" would not drastically degrade
 * performance.
 */
LoopCmps:
		movl	(%esi,%edx), %eax
		movl	(%edi,%edx), %ebx
		xorl	%ebx, %eax
		jnz	LeaveLoopCmps
		movl	4(%esi,%edx), %eax
		movl	4(%edi,%edx), %ebx
		xorl	%ebx, %eax
		jnz	LeaveLoopCmps4
		addl	$8, %edx
		jnz	LoopCmps
		jmp	LenMaximum
LeaveLoopCmps4:	addl	$4, %edx
LeaveLoopCmps:	testl	$0x0000FFFF, %eax
		jnz	LenLower
		addl	$2, %edx
		shrl	$16, %eax
LenLower:	subb	$1, %al
		adcl	$0, %edx

/* Calculate the length of the match. If it is longer than MAX_MATCH,	*/
/* then automatically accept it as the best possible match and leave.	*/

		lea	(%edi,%edx), %eax
		movl	scan(%esp), %edi
		subl	%edi, %eax
		cmpl	$MAX_MATCH, %eax
		jge	LenMaximum

/* If the length of the match is not longer than the best match we	*/
/* have so far, then forget it and return to the lookup loop.		*/

		movl	deflatestate(%esp), %edx
		movl	bestlen(%esp), %ebx
		cmpl	%ebx, %eax
		jg	LongerMatch
		movl	chainlenscanend(%esp), %ebx
		movl	windowbestlen(%esp), %esi
		movl	dsPrev(%edx), %edi
		movl	wmask(%esp), %edx
		andl	%ecx, %edx
		jmp	LookupLoop

/*         s->match_start = cur_match;					*/
/*         best_len = len;						*/
/*         if (len >= nice_match) break;				*/
/*         scan_end = *(ushf*)(scan+best_len-1);			*/

LongerMatch:	movl	nicematch(%esp), %ebx
		movl	%eax, bestlen(%esp)
		movl	%ecx, dsMatchStart(%edx)
		cmpl	%ebx, %eax
		jge	LeaveNow
		movl	window(%esp), %esi
		addl	%eax, %esi
		movl	%esi, windowbestlen(%esp)
		movl	chainlenscanend(%esp), %ebx
		movw	-1(%edi,%eax), %bx
		movl	dsPrev(%edx), %edi
		movl	%ebx, chainlenscanend(%esp)
		movl	wmask(%esp), %edx
		andl	%ecx, %edx
		jmp	LookupLoop

/* Accept the current string, with the maximum possible length.		*/

LenMaximum:	movl	deflatestate(%esp), %edx
		movl	$MAX_MATCH, bestlen(%esp)
		movl	%ecx, dsMatchStart(%edx)

/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;		*/
/* return s->lookahead;							*/

LeaveNow:
		movl	deflatestate(%esp), %edx
		movl	bestlen(%esp), %ebx
		movl	dsLookahead(%edx), %eax
		cmpl	%eax, %ebx
		jg	LookaheadRet
		movl	%ebx, %eax
LookaheadRet:

/* Restore the stack and return from whence we came.			*/

		addl	$LocalVarsSize, %esp
		popl	%ebx
		popl	%esi
		popl	%edi
		popl	%ebp
match_init:	ret
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\asm686\match.S ===
/* match.s -- Pentium-Pro-optimized version of longest_match()
 * Written for zlib 1.1.2
 * Copyright (C) 1998 Brian Raiter <breadbox@muppetlabs.com>
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License.
 */

#ifndef NO_UNDERLINE
#define	match_init	_match_init
#define	longest_match	_longest_match
#endif

#define	MAX_MATCH	(258)
#define	MIN_MATCH	(3)
#define	MIN_LOOKAHEAD	(MAX_MATCH + MIN_MATCH + 1)
#define	MAX_MATCH_8	((MAX_MATCH + 7) & ~7)

/* stack frame offsets */

#define	chainlenwmask		0	/* high word: current chain len	*/
					/* low word: s->wmask		*/
#define	window			4	/* local copy of s->window	*/
#define	windowbestlen		8	/* s->window + bestlen		*/
#define	scanstart		16	/* first two bytes of string	*/
#define	scanend			12	/* last two bytes of string	*/
#define	scanalign		20	/* dword-misalignment of string	*/
#define	nicematch		24	/* a good enough match size	*/
#define	bestlen			28	/* size of best match so far	*/
#define	scan			32	/* ptr to string wanting match	*/

#define	LocalVarsSize		(36)
/*	saved ebx		36 */
/*	saved edi		40 */
/*	saved esi		44 */
/*	saved ebp		48 */
/*	return address		52 */
#define	deflatestate		56	/* the function arguments	*/
#define	curmatch		60

/* Offsets for fields in the deflate_state structure. These numbers
 * are calculated from the definition of deflate_state, with the
 * assumption that the compiler will dword-align the fields. (Thus,
 * changing the definition of deflate_state could easily cause this
 * program to crash horribly, without so much as a warning at
 * compile time. Sigh.)
 */
#define	dsWSize			36
#define	dsWMask			44
#define	dsWindow		48
#define	dsPrev			56
#define	dsMatchLen		88
#define	dsPrevMatch		92
#define	dsStrStart		100
#define	dsMatchStart		104
#define	dsLookahead		108
#define	dsPrevLen		112
#define	dsMaxChainLen		116
#define	dsGoodMatch		132
#define	dsNiceMatch		136


.file "match.S"

.globl	match_init, longest_match

.text

/* uInt longest_match(deflate_state *deflatestate, IPos curmatch) */

longest_match:

/* Save registers that the compiler may be using, and adjust %esp to	*/
/* make room for our stack frame.					*/

		pushl	%ebp
		pushl	%edi
		pushl	%esi
		pushl	%ebx
		subl	$LocalVarsSize, %esp

/* Retrieve the function arguments. %ecx will hold cur_match		*/
/* throughout the entire function. %edx will hold the pointer to the	*/
/* deflate_state structure during the function's setup (before		*/
/* entering the main loop).						*/

		movl	deflatestate(%esp), %edx
		movl	curmatch(%esp), %ecx

/* uInt wmask = s->w_mask;						*/
/* unsigned chain_length = s->max_chain_length;				*/
/* if (s->prev_length >= s->good_match) {				*/
/*     chain_length >>= 2;						*/
/* }									*/

		movl	dsPrevLen(%edx), %eax
		movl	dsGoodMatch(%edx), %ebx
		cmpl	%ebx, %eax
		movl	dsWMask(%edx), %eax
		movl	dsMaxChainLen(%edx), %ebx
		jl	LastMatchGood
		shrl	$2, %ebx
LastMatchGood:

/* chainlen is decremented once beforehand so that the function can	*/
/* use the sign flag instead of the zero flag for the exit test.	*/
/* It is then shifted into the high word, to make room for the wmask	*/
/* value, which it will always accompany.				*/

		decl	%ebx
		shll	$16, %ebx
		orl	%eax, %ebx
		movl	%ebx, chainlenwmask(%esp)

/* if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;	*/

		movl	dsNiceMatch(%edx), %eax
		movl	dsLookahead(%edx), %ebx
		cmpl	%eax, %ebx
		jl	LookaheadLess
		movl	%eax, %ebx
LookaheadLess:	movl	%ebx, nicematch(%esp)

/* register Bytef *scan = s->window + s->strstart;			*/

		movl	dsWindow(%edx), %esi
		movl	%esi, window(%esp)
		movl	dsStrStart(%edx), %ebp
		lea	(%esi,%ebp), %edi
		movl	%edi, scan(%esp)

/* Determine how many bytes the scan ptr is off from being		*/
/* dword-aligned.							*/

		movl	%edi, %eax
		negl	%eax
		andl	$3, %eax
		movl	%eax, scanalign(%esp)

/* IPos limit = s->strstart > (IPos)MAX_DIST(s) ?			*/
/*     s->strstart - (IPos)MAX_DIST(s) : NIL;				*/

		movl	dsWSize(%edx), %eax
		subl	$MIN_LOOKAHEAD, %eax
		subl	%eax, %ebp
		jg	LimitPositive
		xorl	%ebp, %ebp
LimitPositive:

/* int best_len = s->prev_length;					*/

		movl	dsPrevLen(%edx), %eax
		movl	%eax, bestlen(%esp)

/* Store the sum of s->window + best_len in %esi locally, and in %esi.	*/

		addl	%eax, %esi
		movl	%esi, windowbestlen(%esp)

/* register ush scan_start = *(ushf*)scan;				*/
/* register ush scan_end   = *(ushf*)(scan+best_len-1);			*/
/* Posf *prev = s->prev;						*/

		movzwl	(%edi), %ebx
		movl	%ebx, scanstart(%esp)
		movzwl	-1(%edi,%eax), %ebx
		movl	%ebx, scanend(%esp)
		movl	dsPrev(%edx), %edi

/* Jump into the main loop.						*/

		movl	chainlenwmask(%esp), %edx
		jmp	LoopEntry

.balign 16

/* do {
 *     match = s->window + cur_match;
 *     if (*(ushf*)(match+best_len-1) != scan_end ||
 *         *(ushf*)match != scan_start) continue;
 *     [...]
 * } while ((cur_match = prev[cur_match & wmask]) > limit
 *          && --chain_length != 0);
 *
 * Here is the inner loop of the function. The function will spend the
 * majority of its time in this loop, and majority of that time will
 * be spent in the first ten instructions.
 *
 * Within this loop:
 * %ebx = scanend
 * %ecx = curmatch
 * %edx = chainlenwmask - i.e., ((chainlen << 16) | wmask)
 * %esi = windowbestlen - i.e., (window + bestlen)
 * %edi = prev
 * %ebp = limit
 */
LookupLoop:
		andl	%edx, %ecx
		movzwl	(%edi,%ecx,2), %ecx
		cmpl	%ebp, %ecx
		jbe	LeaveNow
		subl	$0x00010000, %edx
		js	LeaveNow
LoopEntry:	movzwl	-1(%esi,%ecx), %eax
		cmpl	%ebx, %eax
		jnz	LookupLoop
		movl	window(%esp), %eax
		movzwl	(%eax,%ecx), %eax
		cmpl	scanstart(%esp), %eax
		jnz	LookupLoop

/* Store the current value of chainlen.					*/

		movl	%edx, chainlenwmask(%esp)

/* Point %edi to the string under scrutiny, and %esi to the string we	*/
/* are hoping to match it up with. In actuality, %esi and %edi are	*/
/* both pointed (MAX_MATCH_8 - scanalign) bytes ahead, and %edx is	*/
/* initialized to -(MAX_MATCH_8 - scanalign).				*/

		movl	window(%esp), %esi
		movl	scan(%esp), %edi
		addl	%ecx, %esi
		movl	scanalign(%esp), %eax
		movl	$(-MAX_MATCH_8), %edx
		lea	MAX_MATCH_8(%edi,%eax), %edi
		lea	MAX_MATCH_8(%esi,%eax), %esi

/* Test the strings for equality, 8 bytes at a time. At the end,
 * adjust %edx so that it is offset to the exact byte that mismatched.
 *
 * We already know at this point that the first three bytes of the
 * strings match each other, and they can be safely passed over before
 * starting the compare loop. So what this code does is skip over 0-3
 * bytes, as much as necessary in order to dword-align the %edi
 * pointer. (%esi will still be misaligned three times out of four.)
 *
 * It should be confessed that this loop usually does not represent
 * much of the total running time. Replacing it with a more
 * straightforward "rep cmpsb" would not drastically degrade
 * performance.
 */
LoopCmps:
		movl	(%esi,%edx), %eax
		xorl	(%edi,%edx), %eax
		jnz	LeaveLoopCmps
		movl	4(%esi,%edx), %eax
		xorl	4(%edi,%edx), %eax
		jnz	LeaveLoopCmps4
		addl	$8, %edx
		jnz	LoopCmps
		jmp	LenMaximum
LeaveLoopCmps4:	addl	$4, %edx
LeaveLoopCmps:	testl	$0x0000FFFF, %eax
		jnz	LenLower
		addl	$2, %edx
		shrl	$16, %eax
LenLower:	subb	$1, %al
		adcl	$0, %edx

/* Calculate the length of the match. If it is longer than MAX_MATCH,	*/
/* then automatically accept it as the best possible match and leave.	*/

		lea	(%edi,%edx), %eax
		movl	scan(%esp), %edi
		subl	%edi, %eax
		cmpl	$MAX_MATCH, %eax
		jge	LenMaximum

/* If the length of the match is not longer than the best match we	*/
/* have so far, then forget it and return to the lookup loop.		*/

		movl	deflatestate(%esp), %edx
		movl	bestlen(%esp), %ebx
		cmpl	%ebx, %eax
		jg	LongerMatch
		movl	windowbestlen(%esp), %esi
		movl	dsPrev(%edx), %edi
		movl	scanend(%esp), %ebx
		movl	chainlenwmask(%esp), %edx
		jmp	LookupLoop

/*         s->match_start = cur_match;					*/
/*         best_len = len;						*/
/*         if (len >= nice_match) break;				*/
/*         scan_end = *(ushf*)(scan+best_len-1);			*/

LongerMatch:	movl	nicematch(%esp), %ebx
		movl	%eax, bestlen(%esp)
		movl	%ecx, dsMatchStart(%edx)
		cmpl	%ebx, %eax
		jge	LeaveNow
		movl	window(%esp), %esi
		addl	%eax, %esi
		movl	%esi, windowbestlen(%esp)
		movzwl	-1(%edi,%eax), %ebx
		movl	dsPrev(%edx), %edi
		movl	%ebx, scanend(%esp)
		movl	chainlenwmask(%esp), %edx
		jmp	LookupLoop

/* Accept the current string, with the maximum possible length.		*/

LenMaximum:	movl	deflatestate(%esp), %edx
		movl	$MAX_MATCH, bestlen(%esp)
		movl	%ecx, dsMatchStart(%edx)

/* if ((uInt)best_len <= s->lookahead) return (uInt)best_len;		*/
/* return s->lookahead;							*/

LeaveNow:
		movl	deflatestate(%esp), %edx
		movl	bestlen(%esp), %ebx
		movl	dsLookahead(%edx), %eax
		cmpl	%eax, %ebx
		jg	LookaheadRet
		movl	%ebx, %eax
LookaheadRet:

/* Restore the stack and return from whence we came.			*/

		addl	$LocalVarsSize, %esp
		popl	%ebx
		popl	%esi
		popl	%edi
		popl	%ebp
match_init:	ret
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\asm386\gvmat32c.c ===
/* gvmat32.c -- C portion of the optimized longest_match for 32 bits x86
 * Copyright (C) 1995-1996 Jean-loup Gailly and Gilles Vollant.
 * File written by Gilles Vollant, by modifiying the longest_match
 *  from Jean-loup Gailly in deflate.c
 *  it prepare all parameters and call the assembly longest_match_gvasm
 *  longest_match execute standard C code is wmask != 0x7fff
 *     (assembly code is faster with a fixed wmask)
 *
 */

#include "deflate.h"

#undef FAR
#include <windows.h>

#ifdef ASMV
#define NIL 0

#define UNALIGNED_OK


/* if your C compiler don't add underline before function name,
		define ADD_UNDERLINE_ASMFUNC */
#ifdef ADD_UNDERLINE_ASMFUNC
#define longest_match_7fff _longest_match_7fff
#endif



void match_init()
{
}

unsigned long cpudetect32();

uInt longest_match_c(
    deflate_state *s,
    IPos cur_match);                             /* current match */


uInt longest_match_7fff(
    deflate_state *s,
    IPos cur_match);                             /* current match */

uInt longest_match(
    deflate_state *s,
    IPos cur_match)                             /* current match */
{
	static uInt iIsPPro=2;

    if ((s->w_mask == 0x7fff) && (iIsPPro==0))
        return longest_match_7fff(s,cur_match);

	if (iIsPPro==2)
		iIsPPro = (((cpudetect32()/0x100)&0xf)>=6) ? 1 : 0;

	return longest_match_c(s,cur_match);
}



uInt longest_match_c(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    unsigned chain_length = s->max_chain_length;/* max hash chain length */
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    int best_len = s->prev_length;              /* best match length so far */
    int nice_match = s->nice_match;             /* stop if match long enough */
    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
        s->strstart - (IPos)MAX_DIST(s) : NIL;
    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */
    Posf *prev = s->prev;
    uInt wmask = s->w_mask;

#ifdef UNALIGNED_OK
    /* Compare two bytes at a time. Note: this is not always beneficial.
     * Try with and without -DUNALIGNED_OK to check.
     */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
    register ush scan_start = *(ushf*)scan;
    register ush scan_end   = *(ushf*)(scan+best_len-1);
#else
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
    register Byte scan_end1  = scan[best_len-1];
    register Byte scan_end   = scan[best_len];
#endif

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    /* Do not waste too much time if we already have a good match: */
    if (s->prev_length >= s->good_match) {
        chain_length >>= 2;
    }
    /* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */
    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    do {
        Assert(cur_match < s->strstart, "no future");
        match = s->window + cur_match;

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2:
         */
#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
        /* This code assumes sizeof(unsigned short) == 2. Do not use
         * UNALIGNED_OK if your compiler uses a different size.
         */
        if (*(ushf*)(match+best_len-1) != scan_end ||
            *(ushf*)match != scan_start) continue;

        /* It is not necessary to compare scan[2] and match[2] since they are
         * always equal when the other bytes match, given that the hash keys
         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
         * strstart+3, +5, ... up to strstart+257. We check for insufficient
         * lookahead only every 4th comparison; the 128th check will be made
         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
         * necessary to put more guard bytes at the end of the window, or
         * to check more often for insufficient lookahead.
         */
        Assert(scan[2] == match[2], "scan[2]?");
        scan++, match++;
        do {
        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 scan < strend);
        /* The funny "do {}" generates better code on most compilers */

        /* Here, scan <= window+strstart+257 */
        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
        if (*scan == *match) scan++;

        len = (MAX_MATCH - 1) - (int)(strend-scan);
        scan = strend - (MAX_MATCH-1);

#else /* UNALIGNED_OK */

        if (match[best_len]   != scan_end  ||
            match[best_len-1] != scan_end1 ||
            *match            != *scan     ||
            *++match          != scan[1])      continue;

        /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
        scan += 2, match++;
        Assert(*scan == *match, "match[2]?");

        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
        do {
        } while (*++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 scan < strend);

        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

        len = MAX_MATCH - (int)(strend - scan);
        scan = strend - MAX_MATCH;

#endif /* UNALIGNED_OK */

        if (len > best_len) {
            s->match_start = cur_match;
            best_len = len;
            if (len >= nice_match) break;
#ifdef UNALIGNED_OK
            scan_end = *(ushf*)(scan+best_len-1);
#else
            scan_end1  = scan[best_len-1];
            scan_end   = scan[best_len];
#endif
        }
    } while ((cur_match = prev[cur_match & wmask]) > limit
             && --chain_length != 0);

    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
    return s->lookahead;
}

#endif /* ASMV */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\delphi2\d_zlib.cpp ===
#include <condefs.h>
#pragma hdrstop
//---------------------------------------------------------------------------
USEUNIT("adler32.c");
USEUNIT("deflate.c");
USEUNIT("infblock.c");
USEUNIT("infcodes.c");
USEUNIT("inffast.c");
USEUNIT("inflate.c");
USEUNIT("inftrees.c");
USEUNIT("infutil.c");
USEUNIT("trees.c");
//---------------------------------------------------------------------------
#define Library

// To add a file to the library use the Project menu 'Add to Project'.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\delphi2\zlib.cpp ===
#include <condefs.h>
#pragma hdrstop
//---------------------------------------------------------------------------
USEUNIT("adler32.c");
USEUNIT("compress.c");
USEUNIT("crc32.c");
USEUNIT("deflate.c");
USEUNIT("gzio.c");
USEUNIT("infblock.c");
USEUNIT("infcodes.c");
USEUNIT("inffast.c");
USEUNIT("inflate.c");
USEUNIT("inftrees.c");
USEUNIT("infutil.c");
USEUNIT("trees.c");
USEUNIT("uncompr.c");
USEUNIT("zutil.c");
//---------------------------------------------------------------------------
#define Library

// To add a file to the library use the Project menu 'Add to Project'.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\delphi2\zlib32.cpp ===
#include <windows.h>
#pragma hdrstop
#include <condefs.h>


//---------------------------------------------------------------------------
//   Important note about DLL memory management in a VCL DLL:
//
//
//
// If your DLL uses VCL and exports any functions that pass VCL String objects
// (or structs/classes containing nested Strings) as parameter or function
// results, you will need to build both your DLL project and any EXE projects
// that use your DLL with the dynamic RTL (the RTL DLL).  This will change your
// DLL and its calling EXE's to use BORLNDMM.DLL as their memory manager. In
// these cases, the file BORLNDMM.DLL should be deployed along with your DLL
// and the RTL DLL (CP3240MT.DLL). To avoid the requiring BORLNDMM.DLL in
// these situations, pass string information using "char *" or ShortString
// parameters and then link with the static RTL.
//
//---------------------------------------------------------------------------
USEUNIT("adler32.c");
USEUNIT("compress.c");
USEUNIT("crc32.c");
USEUNIT("deflate.c");
USEUNIT("gzio.c");
USEUNIT("infblock.c");
USEUNIT("infcodes.c");
USEUNIT("inffast.c");
USEUNIT("inflate.c");
USEUNIT("inftrees.c");
USEUNIT("infutil.c");
USEUNIT("trees.c");
USEUNIT("uncompr.c");
USEUNIT("zutil.c");
//---------------------------------------------------------------------------
#pragma argsused
int WINAPI DllEntryPoint(HINSTANCE hinst, unsigned long reason, void*)
{
        return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\iostream\zfstream.cpp ===
#include <memory.h>
#include "zfstream.h"

gzfilebuf::gzfilebuf() :
  file(NULL),
  mode(0),
  own_file_descriptor(0)
{ }

gzfilebuf::~gzfilebuf() {

  sync();
  if ( own_file_descriptor )
    close();

}

gzfilebuf *gzfilebuf::open( const char *name,
			    int io_mode ) {

  if ( is_open() )
    return NULL;

  char char_mode[10];
  char *p;
  memset(char_mode,'\0',10);
  p = char_mode;

  if ( io_mode & ios::in ) {
    mode = ios::in;
    *p++ = 'r';
  } else if ( io_mode & ios::app ) {
    mode = ios::app;
    *p++ = 'a';
  } else {
    mode = ios::out;
    *p++ = 'w';
  }

  if ( io_mode & ios::binary ) {
    mode |= ios::binary;
    *p++ = 'b';
  }

  // Hard code the compression level
  if ( io_mode & (ios::out|ios::app )) {
    *p++ = '9';
  }

  if ( (file = gzopen(name, char_mode)) == NULL )
    return NULL;

  own_file_descriptor = 1;

  return this;

}

gzfilebuf *gzfilebuf::attach( int file_descriptor,
			      int io_mode ) {

  if ( is_open() )
    return NULL;

  char char_mode[10];
  char *p;
  memset(char_mode,'\0',10);
  p = char_mode;

  if ( io_mode & ios::in ) {
    mode = ios::in;
    *p++ = 'r';
  } else if ( io_mode & ios::app ) {
    mode = ios::app;
    *p++ = 'a';
  } else {
    mode = ios::out;
    *p++ = 'w';
  }

  if ( io_mode & ios::binary ) {
    mode |= ios::binary;
    *p++ = 'b';
  }

  // Hard code the compression level
  if ( io_mode & (ios::out|ios::app )) {
    *p++ = '9';
  }

  if ( (file = gzdopen(file_descriptor, char_mode)) == NULL )
    return NULL;

  own_file_descriptor = 0;

  return this;

}

gzfilebuf *gzfilebuf::close() {

  if ( is_open() ) {

    sync();
    gzclose( file );
    file = NULL;

  }

  return this;

}

int gzfilebuf::setcompressionlevel( short comp_level ) {

  return gzsetparams(file, comp_level, -2);

}

int gzfilebuf::setcompressionstrategy( short comp_strategy ) {

  return gzsetparams(file, -2, comp_strategy);

}


streampos gzfilebuf::seekoff( streamoff off, ios::seek_dir dir, int which ) {

  return streampos(EOF);

}

int gzfilebuf::underflow() {

  // If the file hasn't been opened for reading, error.
  if ( !is_open() || !(mode & ios::in) )
    return EOF;

  // if a buffer doesn't exists, allocate one.
  if ( !base() ) {

    if ( (allocate()) == EOF )
      return EOF;
    setp(0,0);

  } else {

    if ( in_avail() )
      return (unsigned char) *gptr();

    if ( out_waiting() ) {
      if ( flushbuf() == EOF )
	return EOF;
    }

  }

  // Attempt to fill the buffer.

  int result = fillbuf();
  if ( result == EOF ) {
    // disable get area
    setg(0,0,0);
    return EOF;
  }

  return (unsigned char) *gptr();

}

int gzfilebuf::overflow( int c ) {

  if ( !is_open() || !(mode & ios::out) )
    return EOF;

  if ( !base() ) {
    if ( allocate() == EOF )
      return EOF;
    setg(0,0,0);
  } else {
    if (in_avail()) {
	return EOF;
    }
    if (out_waiting()) {
      if (flushbuf() == EOF)
	return EOF;
    }
  }

  int bl = blen();
  setp( base(), base() + bl);

  if ( c != EOF ) {

    *pptr() = c;
    pbump(1);

  }

  return 0;

}

int gzfilebuf::sync() {

  if ( !is_open() )
    return EOF;

  if ( out_waiting() )
    return flushbuf();

  return 0;

}

int gzfilebuf::flushbuf() {

  int n;
  char *q;

  q = pbase();
  n = pptr() - q;

  if ( gzwrite( file, q, n) < n )
    return EOF;

  setp(0,0);

  return 0;

}

int gzfilebuf::fillbuf() {

  int required;
  char *p;

  p = base();

  required = blen();

  int t = gzread( file, p, required );

  if ( t <= 0) return EOF;

  setg( base(), base(), base()+t);

  return t;

}

gzfilestream_common::gzfilestream_common() :
  ios( gzfilestream_common::rdbuf() )
{ }

gzfilestream_common::~gzfilestream_common()
{ }

void gzfilestream_common::attach( int fd, int io_mode ) {

  if ( !buffer.attach( fd, io_mode) )
    clear( ios::failbit | ios::badbit );
  else
    clear();

}

void gzfilestream_common::open( const char *name, int io_mode ) {

  if ( !buffer.open( name, io_mode ) )
    clear( ios::failbit | ios::badbit );
  else
    clear();

}

void gzfilestream_common::close() {

  if ( !buffer.close() )
    clear( ios::failbit | ios::badbit );

}

gzfilebuf *gzfilestream_common::rdbuf() {

  return &buffer;

}
     
gzifstream::gzifstream() :
  ios( gzfilestream_common::rdbuf() )
{
  clear( ios::badbit );
}

gzifstream::gzifstream( const char *name, int io_mode ) :
  ios( gzfilestream_common::rdbuf() )
{
  gzfilestream_common::open( name, io_mode );
}

gzifstream::gzifstream( int fd, int io_mode ) :
  ios( gzfilestream_common::rdbuf() )
{
  gzfilestream_common::attach( fd, io_mode );
}

gzifstream::~gzifstream() { }

gzofstream::gzofstream() :
  ios( gzfilestream_common::rdbuf() )
{
  clear( ios::badbit );
}

gzofstream::gzofstream( const char *name, int io_mode ) :
  ios( gzfilestream_common::rdbuf() )
{
  gzfilestream_common::open( name, io_mode );
}

gzofstream::gzofstream( int fd, int io_mode ) :
  ios( gzfilestream_common::rdbuf() )
{
  gzfilestream_common::attach( fd, io_mode );
}

gzofstream::~gzofstream() { }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\iostream2\zstream_test.cpp ===
#include "zstream.h"
#include <math.h>
#include <stdlib.h>
#include <iomanip.h>

void main() {
	char h[256] = "Hello";
	char* g = "Goodbye";
	ozstream out("temp.gz");
    out < "This works well" < h < g;
    out.close();

    izstream in("temp.gz"); // read it back
    char *x = read_string(in), *y = new char[256], z[256];
    in > y > z;
    in.close();
    cout << x << endl << y << endl << z << endl;

    out.open("temp.gz"); // try ascii output; zcat temp.gz to see the results
    out << setw(50) << setfill('#') << setprecision(20) << x << endl << y << endl << z << endl;
    out << z << endl << y << endl << x << endl;
    out << 1.1234567890123456789 << endl;

    delete[] x; delete[] y;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\iostream\test.cpp ===
#include "zfstream.h"

int main() {

  // Construct a stream object with this filebuffer.  Anything sent
  // to this stream will go to standard out.
  gzofstream os( 1, ios::out );

  // This text is getting compressed and sent to stdout.
  // To prove this, run 'test | zcat'.
  os << "Hello, Mommy" << endl;

  os << setcompressionlevel( Z_NO_COMPRESSION );
  os << "hello, hello, hi, ho!" << endl;

  setcompressionlevel( os, Z_DEFAULT_COMPRESSION )
    << "I'm compressing again" << endl;

  os.close();

  return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\iostream\zfstream.h ===
#ifndef _zfstream_h
#define _zfstream_h

#include <fstream.h>
#include "zlib.h"

class gzfilebuf : public streambuf {

public:

  gzfilebuf( );
  virtual ~gzfilebuf();

  gzfilebuf *open( const char *name, int io_mode );
  gzfilebuf *attach( int file_descriptor, int io_mode );
  gzfilebuf *close();

  int setcompressionlevel( short comp_level );
  int setcompressionstrategy( short comp_strategy );

  inline int is_open() const { return (file !=NULL); }

  virtual streampos seekoff( streamoff, ios::seek_dir, int );

  virtual int sync();

protected:

  virtual int underflow();
  virtual int overflow( int = EOF );

private:

  gzFile file;
  short mode;
  short own_file_descriptor;

  int flushbuf();
  int fillbuf();

};

class gzfilestream_common : virtual public ios {

  friend class gzifstream;
  friend class gzofstream;
  friend gzofstream &setcompressionlevel( gzofstream &, int );
  friend gzofstream &setcompressionstrategy( gzofstream &, int );

public:
  virtual ~gzfilestream_common();

  void attach( int fd, int io_mode );
  void open( const char *name, int io_mode );
  void close();

protected:
  gzfilestream_common();

private:
  gzfilebuf *rdbuf();

  gzfilebuf buffer;

};

class gzifstream : public gzfilestream_common, public istream {

public:

  gzifstream();
  gzifstream( const char *name, int io_mode = ios::in );
  gzifstream( int fd, int io_mode = ios::in );

  virtual ~gzifstream();

};

class gzofstream : public gzfilestream_common, public ostream {

public:

  gzofstream();
  gzofstream( const char *name, int io_mode = ios::out );
  gzofstream( int fd, int io_mode = ios::out );

  virtual ~gzofstream();

};

template<class T> class gzomanip {
  friend gzofstream &operator<<(gzofstream &, const gzomanip<T> &);
public:
  gzomanip(gzofstream &(*f)(gzofstream &, T), T v) : func(f), val(v) { }
private:
  gzofstream &(*func)(gzofstream &, T);
  T val;
};

template<class T> gzofstream &operator<<(gzofstream &s,
					 const gzomanip<T> &m) {
  return (*m.func)(s, m.val);
  
}

inline gzofstream &setcompressionlevel( gzofstream &s, int l ) {
  (s.rdbuf())->setcompressionlevel(l);
  return s;
}

inline gzofstream &setcompressionstrategy( gzofstream &s, int l ) {
  (s.rdbuf())->setcompressionstrategy(l);
  return s;
}

inline gzomanip<int> setcompressionlevel(int l)
{
  return gzomanip<int>(&setcompressionlevel,l);
}

inline gzomanip<int> setcompressionstrategy(int l)
{
  return gzomanip<int>(&setcompressionstrategy,l);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\iostream2\zstream.h ===
/*
 *
 * Copyright (c) 1997
 * Christian Michelsen Research AS
 * Advanced Computing
 * Fantoftvegen 38, 5036 BERGEN, Norway
 * http://www.cmr.no
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Christian Michelsen Research AS makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 */

#ifndef ZSTREAM__H
#define ZSTREAM__H

/*
 * zstream.h - C++ interface to the 'zlib' general purpose compression library
 * $Id: zstream.h 1.1 1997-06-25 12:00:56+02 tyge Exp tyge $
 */

#include <strstream.h>
#include <string.h>
#include <stdio.h>
#include "zlib.h"

#if defined(_WIN32)
#   include <fcntl.h>
#   include <io.h>
#   define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
#else
#   define SET_BINARY_MODE(file)
#endif

class zstringlen {
public:
    zstringlen(class izstream&);
    zstringlen(class ozstream&, const char*);
    size_t value() const { return val.word; }
private:
    struct Val { unsigned char byte; size_t word; } val;
};

//  ----------------------------- izstream -----------------------------

class izstream
{
    public:
        izstream() : m_fp(0) {}
        izstream(FILE* fp) : m_fp(0) { open(fp); }
        izstream(const char* name) : m_fp(0) { open(name); }
        ~izstream() { close(); }

        /* Opens a gzip (.gz) file for reading.
         * open() can be used to read a file which is not in gzip format;
         * in this case read() will directly read from the file without
         * decompression. errno can be checked to distinguish two error
         * cases (if errno is zero, the zlib error is Z_MEM_ERROR).
         */
        void open(const char* name) {
            if (m_fp) close();
            m_fp = ::gzopen(name, "rb");
        }

        void open(FILE* fp) {
            SET_BINARY_MODE(fp);
            if (m_fp) close();
            m_fp = ::gzdopen(fileno(fp), "rb");
        }

        /* Flushes all pending input if necessary, closes the compressed file
         * and deallocates all the (de)compression state. The return value is
         * the zlib error number (see function error() below).
         */
        int close() {
            int r = ::gzclose(m_fp);
            m_fp = 0; return r;
        }

        /* Binary read the given number of bytes from the compressed file.
         */
        int read(void* buf, size_t len) {
            return ::gzread(m_fp, buf, len);
        }

        /* Returns the error message for the last error which occurred on the
         * given compressed file. errnum is set to zlib error number. If an
         * error occurred in the file system and not in the compression library,
         * errnum is set to Z_ERRNO and the application may consult errno
         * to get the exact error code.
         */
        const char* error(int* errnum) {
            return ::gzerror(m_fp, errnum);
        }

        gzFile fp() { return m_fp; }

    private:
        gzFile m_fp;
};

/*
 * Binary read the given (array of) object(s) from the compressed file.
 * If the input file was not in gzip format, read() copies the objects number
 * of bytes into the buffer.
 * returns the number of uncompressed bytes actually read
 * (0 for end of file, -1 for error).
 */
template <class T, class Items>
inline int read(izstream& zs, T* x, Items items) {
    return ::gzread(zs.fp(), x, items*sizeof(T));
}

/*
 * Binary input with the '>' operator.
 */
template <class T>
inline izstream& operator>(izstream& zs, T& x) {
    ::gzread(zs.fp(), &x, sizeof(T));
    return zs;
}


inline zstringlen::zstringlen(izstream& zs) {
    zs > val.byte;
    if (val.byte == 255) zs > val.word;
    else val.word = val.byte;
}

/*
 * Read length of string + the string with the '>' operator.
 */
inline izstream& operator>(izstream& zs, char* x) {
    zstringlen len(zs);
    ::gzread(zs.fp(), x, len.value());
    x[len.value()] = '\0';
    return zs;
}

inline char* read_string(izstream& zs) {
    zstringlen len(zs);
    char* x = new char[len.value()+1];
    ::gzread(zs.fp(), x, len.value());
    x[len.value()] = '\0';
    return x;
}

// ----------------------------- ozstream -----------------------------

class ozstream
{
    public:
        ozstream() : m_fp(0), m_os(0) {
        }
        ozstream(FILE* fp, int level = Z_DEFAULT_COMPRESSION)
            : m_fp(0), m_os(0) {
            open(fp, level);
        }
        ozstream(const char* name, int level = Z_DEFAULT_COMPRESSION)
            : m_fp(0), m_os(0) {
            open(name, level);
        }
        ~ozstream() {
            close();
        }

        /* Opens a gzip (.gz) file for writing.
         * The compression level parameter should be in 0..9
         * errno can be checked to distinguish two error cases
         * (if errno is zero, the zlib error is Z_MEM_ERROR).
         */
        void open(const char* name, int level = Z_DEFAULT_COMPRESSION) {
            char mode[4] = "wb\0";
            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;
            if (m_fp) close();
            m_fp = ::gzopen(name, mode);
        }

        /* open from a FILE pointer.
         */
        void open(FILE* fp, int level = Z_DEFAULT_COMPRESSION) {
            SET_BINARY_MODE(fp);
            char mode[4] = "wb\0";
            if (level != Z_DEFAULT_COMPRESSION) mode[2] = '0'+level;
            if (m_fp) close();
            m_fp = ::gzdopen(fileno(fp), mode);
        }

        /* Flushes all pending output if necessary, closes the compressed file
         * and deallocates all the (de)compression state. The return value is
         * the zlib error number (see function error() below).
         */
        int close() {
            if (m_os) {
                ::gzwrite(m_fp, m_os->str(), m_os->pcount());
                delete[] m_os->str(); delete m_os; m_os = 0;
            }
            int r = ::gzclose(m_fp); m_fp = 0; return r;
        }

        /* Binary write the given number of bytes into the compressed file.
         */
        int write(const void* buf, size_t len) {
            return ::gzwrite(m_fp, (voidp) buf, len);
        }

        /* Flushes all pending output into the compressed file. The parameter
         * _flush is as in the deflate() function. The return value is the zlib
         * error number (see function gzerror below). flush() returns Z_OK if
         * the flush_ parameter is Z_FINISH and all output could be flushed.
         * flush() should be called only when strictly necessary because it can
         * degrade compression.
         */
        int flush(int _flush) {
            os_flush();
            return ::gzflush(m_fp, _flush);
        }

        /* Returns the error message for the last error which occurred on the
         * given compressed file. errnum is set to zlib error number. If an
         * error occurred in the file system and not in the compression library,
         * errnum is set to Z_ERRNO and the application may consult errno
         * to get the exact error code.
         */
        const char* error(int* errnum) {
            return ::gzerror(m_fp, errnum);
        }

        gzFile fp() { return m_fp; }

        ostream& os() {
            if (m_os == 0) m_os = new ostrstream;
            return *m_os;
        }

        void os_flush() {
            if (m_os && m_os->pcount()>0) {
                ostrstream* oss = new ostrstream;
                oss->fill(m_os->fill());
                oss->flags(m_os->flags());
                oss->precision(m_os->precision());
                oss->width(m_os->width());
                ::gzwrite(m_fp, m_os->str(), m_os->pcount());
                delete[] m_os->str(); delete m_os; m_os = oss;
            }
        }

    private:
        gzFile m_fp;
        ostrstream* m_os;
};

/*
 * Binary write the given (array of) object(s) into the compressed file.
 * returns the number of uncompressed bytes actually written
 * (0 in case of error).
 */
template <class T, class Items>
inline int write(ozstream& zs, const T* x, Items items) {
    return ::gzwrite(zs.fp(), (voidp) x, items*sizeof(T));
}

/*
 * Binary output with the '<' operator.
 */
template <class T>
inline ozstream& operator<(ozstream& zs, const T& x) {
    ::gzwrite(zs.fp(), (voidp) &x, sizeof(T));
    return zs;
}

inline zstringlen::zstringlen(ozstream& zs, const char* x) {
    val.byte = 255;  val.word = ::strlen(x);
    if (val.word < 255) zs < (val.byte = val.word);
    else zs < val;
}

/*
 * Write length of string + the string with the '<' operator.
 */
inline ozstream& operator<(ozstream& zs, const char* x) {
    zstringlen len(zs, x);
    ::gzwrite(zs.fp(), (voidp) x, len.value());
    return zs;
}

#ifdef _MSC_VER
inline ozstream& operator<(ozstream& zs, char* const& x) {
    return zs < (const char*) x;
}
#endif

/*
 * Ascii write with the << operator;
 */
template <class T>
inline ostream& operator<<(ozstream& zs, const T& x) {
    zs.os_flush();
    return zs.os() << x;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\minizip\miniunz.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>

#ifdef unix
# include <unistd.h>
# include <utime.h>
#else
# include <direct.h>
# include <io.h>
#endif

#include "unzip.h"

#define CASESENSITIVITY (0)
#define WRITEBUFFERSIZE (8192)

/*
  mini unzip, demo of unzip package

  usage :
  Usage : miniunz [-exvlo] file.zip [file_to_extract]

  list the file in the zipfile, and print the content of FILE_ID.ZIP or README.TXT
    if it exists
*/


/* change_file_date : change the date/time of a file
    filename : the filename of the file where date/time must be modified
    dosdate : the new date at the MSDos format (4 bytes)
    tmu_date : the SAME new date at the tm_unz format */
void change_file_date(filename,dosdate,tmu_date)
	const char *filename;
	uLong dosdate;
	tm_unz tmu_date;
{
#ifdef WIN32
  HANDLE hFile;
  FILETIME ftm,ftLocal,ftCreate,ftLastAcc,ftLastWrite;

  hFile = CreateFile(filename,GENERIC_READ | GENERIC_WRITE,
                      0,NULL,OPEN_EXISTING,0,NULL);
  GetFileTime(hFile,&ftCreate,&ftLastAcc,&ftLastWrite);
  DosDateTimeToFileTime((WORD)(dosdate>>16),(WORD)dosdate,&ftLocal);
  LocalFileTimeToFileTime(&ftLocal,&ftm);
  SetFileTime(hFile,&ftm,&ftLastAcc,&ftm);
  CloseHandle(hFile);
#else
#ifdef unix
  struct utimbuf ut;
  struct tm newdate;
  newdate.tm_sec = tmu_date.tm_sec;
  newdate.tm_min=tmu_date.tm_min;
  newdate.tm_hour=tmu_date.tm_hour;
  newdate.tm_mday=tmu_date.tm_mday;
  newdate.tm_mon=tmu_date.tm_mon;
  if (tmu_date.tm_year > 1900)
      newdate.tm_year=tmu_date.tm_year - 1900;
  else
      newdate.tm_year=tmu_date.tm_year ;
  newdate.tm_isdst=-1;

  ut.actime=ut.modtime=mktime(&newdate);
  utime(filename,&ut);
#endif
#endif
}


/* mymkdir and change_file_date are not 100 % portable
   As I don't know well Unix, I wait feedback for the unix portion */

int mymkdir(dirname)
	const char* dirname;
{
    int ret=0;
#ifdef WIN32
	ret = mkdir(dirname);
#else
#ifdef unix
	ret = mkdir (dirname,0775);
#endif
#endif
	return ret;
}

int makedir (newdir)
    char *newdir;
{
  char *buffer ;
  char *p;
  int  len = strlen(newdir);  

  if (len <= 0) 
    return 0;

  buffer = (char*)malloc(len+1);
  strcpy(buffer,newdir);
  
  if (buffer[len-1] == '/') {
    buffer[len-1] = '\0';
  }
  if (mymkdir(buffer) == 0)
    {
      free(buffer);
      return 1;
    }

  p = buffer+1;
  while (1)
    {
      char hold;

      while(*p && *p != '\\' && *p != '/')
        p++;
      hold = *p;
      *p = 0;
      if ((mymkdir(buffer) == -1) && (errno == ENOENT))
        {
          printf("couldn't create directory %s\n",buffer);
          free(buffer);
          return 0;
        }
      if (hold == 0)
        break;
      *p++ = hold;
    }
  free(buffer);
  return 1;
}

void do_banner()
{
	printf("MiniUnz 0.15, demo of zLib + Unz package written by Gilles Vollant\n");
	printf("more info at http://wwww.winimage/zLibDll/unzip.htm\n\n");
}

void do_help()
{	
	printf("Usage : miniunz [-exvlo] file.zip [file_to_extract]\n\n") ;
}


int do_list(uf)
	unzFile uf;
{
	uLong i;
	unz_global_info gi;
	int err;

	err = unzGetGlobalInfo (uf,&gi);
	if (err!=UNZ_OK)
		printf("error %d with zipfile in unzGetGlobalInfo \n",err);
    printf(" Length  Method   Size  Ratio   Date    Time   CRC-32     Name\n");
    printf(" ------  ------   ----  -----   ----    ----   ------     ----\n");
	for (i=0;i<gi.number_entry;i++)
	{
		char filename_inzip[256];
		unz_file_info file_info;
		uLong ratio=0;
		const char *string_method;
		err = unzGetCurrentFileInfo(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);
		if (err!=UNZ_OK)
		{
			printf("error %d with zipfile in unzGetCurrentFileInfo\n",err);
			break;
		}
		if (file_info.uncompressed_size>0)
			ratio = (file_info.compressed_size*100)/file_info.uncompressed_size;

		if (file_info.compression_method==0)
			string_method="Stored";
		else
		if (file_info.compression_method==Z_DEFLATED)
		{
			uInt iLevel=(uInt)((file_info.flag & 0x6)/2);
			if (iLevel==0)
			  string_method="Defl:N";
			else if (iLevel==1)
			  string_method="Defl:X";
			else if ((iLevel==2) || (iLevel==3))
			  string_method="Defl:F"; /* 2:fast , 3 : extra fast*/
		}
		else
			string_method="Unkn. ";

		printf("%7lu  %6s %7lu %3lu%%  %2.2lu-%2.2lu-%2.2lu  %2.2lu:%2.2lu  %8.8lx   %s\n",
			    file_info.uncompressed_size,string_method,file_info.compressed_size,
				ratio,
				(uLong)file_info.tmu_date.tm_mon + 1,
                (uLong)file_info.tmu_date.tm_mday,
				(uLong)file_info.tmu_date.tm_year % 100,
				(uLong)file_info.tmu_date.tm_hour,(uLong)file_info.tmu_date.tm_min,
				(uLong)file_info.crc,filename_inzip);
		if ((i+1)<gi.number_entry)
		{
			err = unzGoToNextFile(uf);
			if (err!=UNZ_OK)
			{
				printf("error %d with zipfile in unzGoToNextFile\n",err);
				break;
			}
		}
	}

	return 0;
}


int do_extract_currentfile(uf,popt_extract_without_path,popt_overwrite)
	unzFile uf;
	const int* popt_extract_without_path;
    int* popt_overwrite;
{
	char filename_inzip[256];
	char* filename_withoutpath;
	char* p;
    int err=UNZ_OK;
    FILE *fout=NULL;
    void* buf;
    uInt size_buf;
	
	unz_file_info file_info;
	uLong ratio=0;
	err = unzGetCurrentFileInfo(uf,&file_info,filename_inzip,sizeof(filename_inzip),NULL,0,NULL,0);

	if (err!=UNZ_OK)
	{
		printf("error %d with zipfile in unzGetCurrentFileInfo\n",err);
		return err;
	}

    size_buf = WRITEBUFFERSIZE;
    buf = (void*)malloc(size_buf);
    if (buf==NULL)
    {
        printf("Error allocating memory\n");
        return UNZ_INTERNALERROR;
    }

	p = filename_withoutpath = filename_inzip;
	while ((*p) != '\0')
	{
		if (((*p)=='/') || ((*p)=='\\'))
			filename_withoutpath = p+1;
		p++;
	}

	if ((*filename_withoutpath)=='\0')
	{
		if ((*popt_extract_without_path)==0)
		{
			printf("creating directory: %s\n",filename_inzip);
			mymkdir(filename_inzip);
		}
	}
	else
	{
		const char* write_filename;
		int skip=0;

		if ((*popt_extract_without_path)==0)
			write_filename = filename_inzip;
		else
			write_filename = filename_withoutpath;

		err = unzOpenCurrentFile(uf);
		if (err!=UNZ_OK)
		{
			printf("error %d with zipfile in unzOpenCurrentFile\n",err);
		}

		if (((*popt_overwrite)==0) && (err==UNZ_OK))
		{
			char rep;
			FILE* ftestexist;
			ftestexist = fopen(write_filename,"rb");
			if (ftestexist!=NULL)
			{
				fclose(ftestexist);
				do
				{
					char answer[128];
					printf("The file %s exist. Overwrite ? [y]es, [n]o, [A]ll: ",write_filename);
					scanf("%1s",answer);
					rep = answer[0] ;
					if ((rep>='a') && (rep<='z'))
						rep -= 0x20;
				}
				while ((rep!='Y') && (rep!='N') && (rep!='A'));
			}

			if (rep == 'N')
				skip = 1;

			if (rep == 'A')
				*popt_overwrite=1;
		}

		if ((skip==0) && (err==UNZ_OK))
		{
			fout=fopen(write_filename,"wb");

            /* some zipfile don't contain directory alone before file */
            if ((fout==NULL) && ((*popt_extract_without_path)==0) && 
                                (filename_withoutpath!=(char*)filename_inzip))
            {
                char c=*(filename_withoutpath-1);
                *(filename_withoutpath-1)='\0';
                makedir(write_filename);
                *(filename_withoutpath-1)=c;
                fout=fopen(write_filename,"wb");
            }

			if (fout==NULL)
			{
				printf("error opening %s\n",write_filename);
			}
		}

		if (fout!=NULL)
		{
			printf(" extracting: %s\n",write_filename);

			do
			{
				err = unzReadCurrentFile(uf,buf,size_buf);
				if (err<0)	
				{
					printf("error %d with zipfile in unzReadCurrentFile\n",err);
					break;
				}
				if (err>0)
					if (fwrite(buf,err,1,fout)!=1)
					{
						printf("error in writing extracted file\n");
                        err=UNZ_ERRNO;
						break;
					}
			}
			while (err>0);
			fclose(fout);
			if (err==0) 
				change_file_date(write_filename,file_info.dosDate,
					             file_info.tmu_date);
		}

        if (err==UNZ_OK)
        {
		    err = unzCloseCurrentFile (uf);
		    if (err!=UNZ_OK)
		    {
			    printf("error %d with zipfile in unzCloseCurrentFile\n",err);
		    }
        }
        else
            unzCloseCurrentFile(uf); /* don't lose the error */       
	}

    free(buf);    
    return err;
}


int do_extract(uf,opt_extract_without_path,opt_overwrite)
	unzFile uf;
	int opt_extract_without_path;
    int opt_overwrite;
{
	uLong i;
	unz_global_info gi;
	int err;
	FILE* fout=NULL;	

	err = unzGetGlobalInfo (uf,&gi);
	if (err!=UNZ_OK)
		printf("error %d with zipfile in unzGetGlobalInfo \n",err);

	for (i=0;i<gi.number_entry;i++)
	{
        if (do_extract_currentfile(uf,&opt_extract_without_path,
                                      &opt_overwrite) != UNZ_OK)
            break;

		if ((i+1)<gi.number_entry)
		{
			err = unzGoToNextFile(uf);
			if (err!=UNZ_OK)
			{
				printf("error %d with zipfile in unzGoToNextFile\n",err);
				break;
			}
		}
	}

	return 0;
}

int do_extract_onefile(uf,filename,opt_extract_without_path,opt_overwrite)
	unzFile uf;
	const char* filename;
	int opt_extract_without_path;
    int opt_overwrite;
{
    int err = UNZ_OK;
    if (unzLocateFile(uf,filename,CASESENSITIVITY)!=UNZ_OK)
    {
        printf("file %s not found in the zipfile\n",filename);
        return 2;
    }

    if (do_extract_currentfile(uf,&opt_extract_without_path,
                                      &opt_overwrite) == UNZ_OK)
        return 0;
    else
        return 1;
}


int main(argc,argv)
	int argc;
	char *argv[];
{
	const char *zipfilename=NULL;
    const char *filename_to_extract=NULL;
	int i;
	int opt_do_list=0;
	int opt_do_extract=1;
	int opt_do_extract_withoutpath=0;
	int opt_overwrite=0;
	char filename_try[512];
	unzFile uf=NULL;

	do_banner();
	if (argc==1)
	{
		do_help();
		exit(0);
	}
	else
	{
		for (i=1;i<argc;i++)
		{
			if ((*argv[i])=='-')
			{
				const char *p=argv[i]+1;
				
				while ((*p)!='\0')
				{			
					char c=*(p++);;
					if ((c=='l') || (c=='L'))
						opt_do_list = 1;
					if ((c=='v') || (c=='V'))
						opt_do_list = 1;
					if ((c=='x') || (c=='X'))
						opt_do_extract = 1;
					if ((c=='e') || (c=='E'))
						opt_do_extract = opt_do_extract_withoutpath = 1;
					if ((c=='o') || (c=='O'))
						opt_overwrite=1;
				}
			}
			else
            {
				if (zipfilename == NULL)
					zipfilename = argv[i];
                else if (filename_to_extract==NULL)
                        filename_to_extract = argv[i] ;
            }
		}
	}

	if (zipfilename!=NULL)
	{
		strcpy(filename_try,zipfilename);
		uf = unzOpen(zipfilename);
		if (uf==NULL)
		{
			strcat(filename_try,".zip");
			uf = unzOpen(filename_try);
		}
	}

	if (uf==NULL)
	{
		printf("Cannot open %s or %s.zip\n",zipfilename,zipfilename);
		exit (1);
	}
    printf("%s opened\n",filename_try);

	if (opt_do_list==1)
		return do_list(uf);
	else if (opt_do_extract==1)
    {
        if (filename_to_extract == NULL)
		    return do_extract(uf,opt_do_extract_withoutpath,opt_overwrite);
        else
            return do_extract_onefile(uf,filename_to_extract,
                                      opt_do_extract_withoutpath,opt_overwrite);
    }
	unzCloseCurrentFile(uf);

	return 0;  /* to avoid warning */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\minizip\minizip.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>

#ifdef unix
# include <unistd.h>
# include <utime.h>
# include <sys/types.h>
# include <sys/stat.h>
#else
# include <direct.h>
# include <io.h>
#endif

#include "zip.h"


#define WRITEBUFFERSIZE (16384)
#define MAXFILENAME (256)

#ifdef WIN32
uLong filetime(f, tmzip, dt)
    char *f;                /* name of file to get info on */
    tm_zip *tmzip;             /* return value: access, modific. and creation times */
    uLong *dt;             /* dostime */
{
  int ret = 0;
  {
      FILETIME ftLocal;
      HANDLE hFind;
      WIN32_FIND_DATA  ff32;

      hFind = FindFirstFile(f,&ff32);
      if (hFind != INVALID_HANDLE_VALUE)
      {
        FileTimeToLocalFileTime(&(ff32.ftLastWriteTime),&ftLocal);
        FileTimeToDosDateTime(&ftLocal,((LPWORD)dt)+1,((LPWORD)dt)+0);
        FindClose(hFind);
        ret = 1;
      }
  }
  return ret;
}
#else
#ifdef unix
uLong filetime(f, tmzip, dt)
    char *f;                /* name of file to get info on */
    tm_zip *tmzip;             /* return value: access, modific. and creation times */
    uLong *dt;             /* dostime */
{
  int ret=0;
  struct stat s;        /* results of stat() */
  struct tm* filedate;
  time_t tm_t=0;
  
  if (strcmp(f,"-")!=0)
  {
    char name[MAXFILENAME];
    int len = strlen(f);
    strcpy(name, f);
    if (name[len - 1] == '/')
      name[len - 1] = '\0';
    /* not all systems allow stat'ing a file with / appended */
    if (stat(name,&s)==0)
    {
      tm_t = s.st_mtime;
      ret = 1;
    }
  }
  filedate = localtime(&tm_t);

  tmzip->tm_sec  = filedate->tm_sec;
  tmzip->tm_min  = filedate->tm_min;
  tmzip->tm_hour = filedate->tm_hour;
  tmzip->tm_mday = filedate->tm_mday;
  tmzip->tm_mon  = filedate->tm_mon ;
  tmzip->tm_year = filedate->tm_year;

  return ret;
}
#else
uLong filetime(f, tmzip, dt)
    char *f;                /* name of file to get info on */
    tm_zip *tmzip;             /* return value: access, modific. and creation times */
    uLong *dt;             /* dostime */
{
    return 0;
}
#endif
#endif




int check_exist_file(filename)
    const char* filename;
{
	FILE* ftestexist;
    int ret = 1;
	ftestexist = fopen(filename,"rb");
	if (ftestexist==NULL)
        ret = 0;
    else
        fclose(ftestexist);
    return ret;
}

void do_banner()
{
	printf("MiniZip 0.15, demo of zLib + Zip package written by Gilles Vollant\n");
	printf("more info at http://wwww.winimage/zLibDll/unzip.htm\n\n");
}

void do_help()
{	
	printf("Usage : minizip [-o] file.zip [files_to_add]\n\n") ;
}

int main(argc,argv)
	int argc;
	char *argv[];
{
	int i;
	int opt_overwrite=0;
    int opt_compress_level=Z_DEFAULT_COMPRESSION;
    int zipfilenamearg = 0;
	char filename_try[MAXFILENAME];
    int zipok;
    int err=0;
    int size_buf=0;
    void* buf=NULL,


	do_banner();
	if (argc==1)
	{
		do_help();
		exit(0);
        return 0;
	}
	else
	{
		for (i=1;i<argc;i++)
		{
			if ((*argv[i])=='-')
			{
				const char *p=argv[i]+1;
				
				while ((*p)!='\0')
				{			
					char c=*(p++);;
					if ((c=='o') || (c=='O'))
						opt_overwrite = 1;
                    if ((c>='0') && (c<='9'))
                        opt_compress_level = c-'0';
				}
			}
			else
				if (zipfilenamearg == 0)
                    zipfilenamearg = i ;
		}
	}

    size_buf = WRITEBUFFERSIZE;
    buf = (void*)malloc(size_buf);
    if (buf==NULL)
    {
        printf("Error allocating memory\n");
        return ZIP_INTERNALERROR;
    }

	if (zipfilenamearg==0)
        zipok=0;
    else
	{
        int i,len;
        int dot_found=0;

        zipok = 1 ;
		strcpy(filename_try,argv[zipfilenamearg]);
        len=strlen(filename_try);
        for (i=0;i<len;i++)
            if (filename_try[i]=='.')
                dot_found=1;

        if (dot_found==0)
            strcat(filename_try,".zip");

        if (opt_overwrite==0)
            if (check_exist_file(filename_try)!=0)
			{
                char rep;
				do
				{
					char answer[128];
					printf("The file %s exist. Overwrite ? [y]es, [n]o : ",filename_try);
					scanf("%1s",answer);
					rep = answer[0] ;
					if ((rep>='a') && (rep<='z'))
						rep -= 0x20;
				}
				while ((rep!='Y') && (rep!='N'));
                if (rep=='N')
                    zipok = 0;
			}
    }

    if (zipok==1)
    {
        zipFile zf;
        int errclose;
        zf = zipOpen(filename_try,0);
        if (zf == NULL)
        {
            printf("error opening %s\n",filename_try);
            err= ZIP_ERRNO;
        }
        else 
            printf("creating %s\n",filename_try);

        for (i=zipfilenamearg+1;(i<argc) && (err==ZIP_OK);i++)
        {
            if (((*(argv[i]))!='-') && ((*(argv[i]))!='/'))
            {
                FILE * fin;
                int size_read;
                const char* filenameinzip = argv[i];
                zip_fileinfo zi;

                zi.tmz_date.tm_sec = zi.tmz_date.tm_min = zi.tmz_date.tm_hour = 
                zi.tmz_date.tm_mday = zi.tmz_date.tm_min = zi.tmz_date.tm_year = 0;
                zi.dosDate = 0;
                zi.internal_fa = 0;
                zi.external_fa = 0;
                filetime(filenameinzip,&zi.tmz_date,&zi.dosDate);


                err = zipOpenNewFileInZip(zf,filenameinzip,&zi,
                                 NULL,0,NULL,0,NULL /* comment*/,
                                 (opt_compress_level != 0) ? Z_DEFLATED : 0,
                                 opt_compress_level);

                if (err != ZIP_OK)
                    printf("error in opening %s in zipfile\n",filenameinzip);
                else
                {
                    fin = fopen(filenameinzip,"rb");
                    if (fin==NULL)
                    {
                        err=ZIP_ERRNO;
                        printf("error in opening %s for reading\n",filenameinzip);
                    }
                }

                if (err == ZIP_OK)
                    do
                    {
                        err = ZIP_OK;
                        size_read = fread(buf,1,size_buf,fin);
                        if (size_read < size_buf)
                            if (feof(fin)==0)
                        {
                            printf("error in reading %s\n",filenameinzip);
                            err = ZIP_ERRNO;
                        }

                        if (size_read>0)
                        {
                            err = zipWriteInFileInZip (zf,buf,size_read);
                            if (err<0)
                            {
                                printf("error in writing %s in the zipfile\n",
                                                 filenameinzip);
                            }
                                
                        }
                    } while ((err == ZIP_OK) && (size_read>0));

                fclose(fin);
                if (err<0)
                    err=ZIP_ERRNO;
                else
                {                    
                    err = zipCloseFileInZip(zf);
                    if (err!=ZIP_OK)
                        printf("error in closing %s in the zipfile\n",
                                    filenameinzip);
                }
            }
        }
        errclose = zipClose(zf,NULL);
        if (errclose != ZIP_OK)
            printf("error in closing %s\n",filename_try);
   }

    free(buf);
    exit(0);
	return 0;  /* to avoid warning */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\minizip\zip.c ===
/* zip.c -- IO on .zip files using zlib 
   Version 0.15 beta, Mar 19th, 1998,

   Read zip.h for more info
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "zlib.h"
#include "zip.h"

#ifdef STDC
#  include <stddef.h>
#  include <string.h>
#  include <stdlib.h>
#endif
#ifdef NO_ERRNO_H
    extern int errno;
#else
#   include <errno.h>
#endif


#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

#ifndef VERSIONMADEBY
# define VERSIONMADEBY   (0x0) /* platform depedent */
#endif

#ifndef Z_BUFSIZE
#define Z_BUFSIZE (16384)
#endif

#ifndef Z_MAXFILENAMEINZIP
#define Z_MAXFILENAMEINZIP (256)
#endif

#ifndef ALLOC
# define ALLOC(size) (malloc(size))
#endif
#ifndef TRYFREE
# define TRYFREE(p) {if (p) free(p);}
#endif

/*
#define SIZECENTRALDIRITEM (0x2e)
#define SIZEZIPLOCALHEADER (0x1e)
*/

/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */

#ifndef SEEK_CUR
#define SEEK_CUR    1
#endif

#ifndef SEEK_END
#define SEEK_END    2
#endif

#ifndef SEEK_SET
#define SEEK_SET    0
#endif

const char zip_copyright[] =
   " zip 0.15 Copyright 1998 Gilles Vollant ";


#define SIZEDATA_INDATABLOCK (4096-(4*4))

#define LOCALHEADERMAGIC    (0x04034b50)
#define CENTRALHEADERMAGIC  (0x02014b50)
#define ENDHEADERMAGIC      (0x06054b50)

#define FLAG_LOCALHEADER_OFFSET (0x06)
#define CRC_LOCALHEADER_OFFSET  (0x0e)

#define SIZECENTRALHEADER (0x2e) /* 46 */

typedef struct linkedlist_datablock_internal_s
{
  struct linkedlist_datablock_internal_s* next_datablock;
  uLong  avail_in_this_block;
  uLong  filled_in_this_block;
  uLong  unused; /* for future use and alignement */
  unsigned char data[SIZEDATA_INDATABLOCK];
} linkedlist_datablock_internal;

typedef struct linkedlist_data_s
{
    linkedlist_datablock_internal* first_block;
    linkedlist_datablock_internal* last_block;
} linkedlist_data;


typedef struct
{
	z_stream stream;            /* zLib stream structure for inflate */
    int  stream_initialised;    /* 1 is stream is initialised */
    uInt pos_in_buffered_data;  /* last written byte in buffered_data */

    uLong pos_local_header;     /* offset of the local header of the file 
                                     currenty writing */
    char* central_header;       /* central header data for the current file */
    uLong size_centralheader;   /* size of the central header for cur file */
    uLong flag;                 /* flag of the file currently writing */

    int  method;                /* compression method of file currenty wr.*/
    Byte buffered_data[Z_BUFSIZE];/* buffer contain compressed data to be writ*/
    uLong dosDate;
    uLong crc32;
} curfile_info;

typedef struct
{
    FILE * filezip;
    linkedlist_data central_dir;/* datablock with central dir in construction*/
    int  in_opened_file_inzip;  /* 1 if a file in the zip is currently writ.*/
    curfile_info ci;            /* info on the file curretly writing */

    uLong begin_pos;            /* position of the beginning of the zipfile */
    uLong number_entry;
} zip_internal;

local linkedlist_datablock_internal* allocate_new_datablock()
{
    linkedlist_datablock_internal* ldi;
    ldi = (linkedlist_datablock_internal*)
                 ALLOC(sizeof(linkedlist_datablock_internal));
    if (ldi!=NULL)
    {
        ldi->next_datablock = NULL ;
        ldi->filled_in_this_block = 0 ;
        ldi->avail_in_this_block = SIZEDATA_INDATABLOCK ;
    }
    return ldi;
}

local void free_datablock(ldi)
    linkedlist_datablock_internal* ldi;
{
    while (ldi!=NULL)
    {
        linkedlist_datablock_internal* ldinext = ldi->next_datablock;
        TRYFREE(ldi);
        ldi = ldinext;
    }
}

local void init_linkedlist(ll)
    linkedlist_data* ll;
{
    ll->first_block = ll->last_block = NULL;
}

local void free_linkedlist(ll)
    linkedlist_data* ll;
{
    free_datablock(ll->first_block);
    ll->first_block = ll->last_block = NULL;
}


local int add_data_in_datablock(ll,buf,len)
    linkedlist_data* ll;    
    const void* buf;
    uLong len;
{
    linkedlist_datablock_internal* ldi;
    const unsigned char* from_copy;

    if (ll==NULL)
        return ZIP_INTERNALERROR;

    if (ll->last_block == NULL)
    {
        ll->first_block = ll->last_block = allocate_new_datablock();
        if (ll->first_block == NULL)
            return ZIP_INTERNALERROR;
    }

    ldi = ll->last_block;
    from_copy = (unsigned char*)buf;

    while (len>0)
    {
        uInt copy_this;
        uInt i;
        unsigned char* to_copy;

        if (ldi->avail_in_this_block==0)
        {
            ldi->next_datablock = allocate_new_datablock();
            if (ldi->next_datablock == NULL)
                return ZIP_INTERNALERROR;
            ldi = ldi->next_datablock ;
            ll->last_block = ldi;
        }

        if (ldi->avail_in_this_block < len)
            copy_this = (uInt)ldi->avail_in_this_block;
        else
            copy_this = (uInt)len;

        to_copy = &(ldi->data[ldi->filled_in_this_block]);

        for (i=0;i<copy_this;i++)
            *(to_copy+i)=*(from_copy+i);

        ldi->filled_in_this_block += copy_this;
        ldi->avail_in_this_block -= copy_this;
        from_copy += copy_this ;
        len -= copy_this;
    }
    return ZIP_OK;
}


local int write_datablock(fout,ll)
    FILE * fout;
    linkedlist_data* ll;    
{
    linkedlist_datablock_internal* ldi;
    ldi = ll->first_block;
    while (ldi!=NULL)
    {
        if (ldi->filled_in_this_block > 0)
            if (fwrite(ldi->data,(uInt)ldi->filled_in_this_block,1,fout)!=1)
                return ZIP_ERRNO;
        ldi = ldi->next_datablock;
    }
    return ZIP_OK;
}

/****************************************************************************/

/* ===========================================================================
   Outputs a long in LSB order to the given file
   nbByte == 1, 2 or 4 (byte, short or long)
*/

local int ziplocal_putValue OF((FILE *file, uLong x, int nbByte));
local int ziplocal_putValue (file, x, nbByte)
    FILE *file;
    uLong x;
    int nbByte;
{
    unsigned char buf[4];
    int n;
    for (n = 0; n < nbByte; n++) {
        buf[n] = (unsigned char)(x & 0xff);
        x >>= 8;
    }
    if (fwrite(buf,nbByte,1,file)!=1)
        return ZIP_ERRNO;
    else
        return ZIP_OK;
}

local void ziplocal_putValue_inmemory OF((void* dest, uLong x, int nbByte));
local void ziplocal_putValue_inmemory (dest, x, nbByte)
    void* dest;
    uLong x;
    int nbByte;
{
    unsigned char* buf=(unsigned char*)dest;
    int n;
    for (n = 0; n < nbByte; n++) {
        buf[n] = (unsigned char)(x & 0xff);
        x >>= 8;
    }
}
/****************************************************************************/


local uLong ziplocal_TmzDateToDosDate(ptm,dosDate)
    tm_zip* ptm;
    uLong dosDate;
{
    uLong year = (uLong)ptm->tm_year;
    if (year>1980)
        year-=1980;
    else if (year>80)
        year-=80;
    return
      (uLong) (((ptm->tm_mday) + (32 * (ptm->tm_mon+1)) + (512 * year)) << 16) |
        ((ptm->tm_sec/2) + (32* ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));
}


/****************************************************************************/

extern zipFile ZEXPORT zipOpen (pathname, append)
    const char *pathname;
    int append;
{
    zip_internal ziinit;
    zip_internal* zi;

    ziinit.filezip = fopen(pathname,(append == 0) ? "wb" : "ab");
    if (ziinit.filezip == NULL)
        return NULL;
    ziinit.begin_pos = ftell(ziinit.filezip);
    ziinit.in_opened_file_inzip = 0;
    ziinit.ci.stream_initialised = 0;
    ziinit.number_entry = 0;
    init_linkedlist(&(ziinit.central_dir));


    zi = (zip_internal*)ALLOC(sizeof(zip_internal));
    if (zi==NULL)
    {
        fclose(ziinit.filezip);
        return NULL;
    }

    *zi = ziinit;
    return (zipFile)zi;
}

extern int ZEXPORT zipOpenNewFileInZip (file, filename, zipfi, 
                                        extrafield_local, size_extrafield_local,
                                        extrafield_global, size_extrafield_global,
                                        comment, method, level)
    zipFile file;
    const char* filename;
    const zip_fileinfo* zipfi;
    const void* extrafield_local;
    uInt size_extrafield_local;
    const void* extrafield_global;
    uInt size_extrafield_global;
    const char* comment;
    int method;
    int level;
{
    zip_internal* zi;
    uInt size_filename;
    uInt size_comment;
    uInt i;
    int err = ZIP_OK;

    if (file == NULL)
        return ZIP_PARAMERROR;
    if ((method!=0) && (method!=Z_DEFLATED))
        return ZIP_PARAMERROR;

    zi = (zip_internal*)file;

    if (zi->in_opened_file_inzip == 1)
    {
        err = zipCloseFileInZip (file);
        if (err != ZIP_OK)
            return err;
    }


    if (filename==NULL)
        filename="-";

    if (comment==NULL)
        size_comment = 0;
    else
        size_comment = strlen(comment);

    size_filename = strlen(filename);

    if (zipfi == NULL)
        zi->ci.dosDate = 0;
    else
    {
        if (zipfi->dosDate != 0)
            zi->ci.dosDate = zipfi->dosDate;
        else zi->ci.dosDate = ziplocal_TmzDateToDosDate(&zipfi->tmz_date,zipfi->dosDate);
    }

    zi->ci.flag = 0;
    if ((level==8) || (level==9))
      zi->ci.flag |= 2;
    if ((level==2))
      zi->ci.flag |= 4;
    if ((level==1))
      zi->ci.flag |= 6;

    zi->ci.crc32 = 0;
    zi->ci.method = method;
    zi->ci.stream_initialised = 0;
    zi->ci.pos_in_buffered_data = 0;
    zi->ci.pos_local_header = ftell(zi->filezip);
    zi->ci.size_centralheader = SIZECENTRALHEADER + size_filename + 
                                      size_extrafield_global + size_comment;
    zi->ci.central_header = (char*)ALLOC((uInt)zi->ci.size_centralheader);

    ziplocal_putValue_inmemory(zi->ci.central_header,(uLong)CENTRALHEADERMAGIC,4);
    /* version info */
    ziplocal_putValue_inmemory(zi->ci.central_header+4,(uLong)VERSIONMADEBY,2);
    ziplocal_putValue_inmemory(zi->ci.central_header+6,(uLong)20,2);
    ziplocal_putValue_inmemory(zi->ci.central_header+8,(uLong)zi->ci.flag,2);
    ziplocal_putValue_inmemory(zi->ci.central_header+10,(uLong)zi->ci.method,2);
    ziplocal_putValue_inmemory(zi->ci.central_header+12,(uLong)zi->ci.dosDate,4);
    ziplocal_putValue_inmemory(zi->ci.central_header+16,(uLong)0,4); /*crc*/
    ziplocal_putValue_inmemory(zi->ci.central_header+20,(uLong)0,4); /*compr size*/
    ziplocal_putValue_inmemory(zi->ci.central_header+24,(uLong)0,4); /*uncompr size*/
    ziplocal_putValue_inmemory(zi->ci.central_header+28,(uLong)size_filename,2);
    ziplocal_putValue_inmemory(zi->ci.central_header+30,(uLong)size_extrafield_global,2);
    ziplocal_putValue_inmemory(zi->ci.central_header+32,(uLong)size_comment,2);
    ziplocal_putValue_inmemory(zi->ci.central_header+34,(uLong)0,2); /*disk nm start*/

    if (zipfi==NULL)
        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)0,2); 
    else
        ziplocal_putValue_inmemory(zi->ci.central_header+36,(uLong)zipfi->internal_fa,2); 

    if (zipfi==NULL)
        ziplocal_putValue_inmemory(zi->ci.central_header+38,(uLong)0,4); 
    else
        ziplocal_putValue_inmemory(zi->ci.central_header+38,(uLong)zipfi->external_fa,4);

    ziplocal_putValue_inmemory(zi->ci.central_header+42,(uLong)zi->ci.pos_local_header,4);

    for (i=0;i<size_filename;i++)
        *(zi->ci.central_header+SIZECENTRALHEADER+i) = *(filename+i);

    for (i=0;i<size_extrafield_global;i++)
        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+i) =
              *(((const char*)extrafield_global)+i);

    for (i=0;i<size_comment;i++)
        *(zi->ci.central_header+SIZECENTRALHEADER+size_filename+
              size_extrafield_global+i) = *(filename+i);
    if (zi->ci.central_header == NULL)
        return ZIP_INTERNALERROR;

    /* write the local header */
    err = ziplocal_putValue(zi->filezip,(uLong)LOCALHEADERMAGIC,4);

    if (err==ZIP_OK)
        err = ziplocal_putValue(zi->filezip,(uLong)20,2);/* version needed to extract */
    if (err==ZIP_OK)
        err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.flag,2);

    if (err==ZIP_OK)
        err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.method,2);

    if (err==ZIP_OK)
        err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.dosDate,4);

    if (err==ZIP_OK)
        err = ziplocal_putValue(zi->filezip,(uLong)0,4); /* crc 32, unknown */
    if (err==ZIP_OK)
        err = ziplocal_putValue(zi->filezip,(uLong)0,4); /* compressed size, unknown */
    if (err==ZIP_OK)
        err = ziplocal_putValue(zi->filezip,(uLong)0,4); /* uncompressed size, unknown */

    if (err==ZIP_OK)
        err = ziplocal_putValue(zi->filezip,(uLong)size_filename,2);

    if (err==ZIP_OK)
        err = ziplocal_putValue(zi->filezip,(uLong)size_extrafield_local,2);

    if ((err==ZIP_OK) && (size_filename>0))
        if (fwrite(filename,(uInt)size_filename,1,zi->filezip)!=1)
                err = ZIP_ERRNO;

    if ((err==ZIP_OK) && (size_extrafield_local>0))
        if (fwrite(extrafield_local,(uInt)size_extrafield_local,1,zi->filezip)
                                                                           !=1)
                err = ZIP_ERRNO;

    zi->ci.stream.avail_in = (uInt)0;
    zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
    zi->ci.stream.next_out = zi->ci.buffered_data;
    zi->ci.stream.total_in = 0;
    zi->ci.stream.total_out = 0;

    if ((err==ZIP_OK) && (zi->ci.method == Z_DEFLATED))
    {
        zi->ci.stream.zalloc = (alloc_func)0;
        zi->ci.stream.zfree = (free_func)0;
        zi->ci.stream.opaque = (voidpf)0;

        err = deflateInit2(&zi->ci.stream, level,
               Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, 0);

        if (err==Z_OK)
            zi->ci.stream_initialised = 1;
    }


    if (err==Z_OK)
        zi->in_opened_file_inzip = 1;
    return err;
}

extern int ZEXPORT zipWriteInFileInZip (file, buf, len)
    zipFile file;
    const voidp buf;
    unsigned len;
{
    zip_internal* zi;
    int err=ZIP_OK;

    if (file == NULL)
        return ZIP_PARAMERROR;
    zi = (zip_internal*)file;

    if (zi->in_opened_file_inzip == 0)
        return ZIP_PARAMERROR;

    zi->ci.stream.next_in = buf;
    zi->ci.stream.avail_in = len;
    zi->ci.crc32 = crc32(zi->ci.crc32,buf,len);

    while ((err==ZIP_OK) && (zi->ci.stream.avail_in>0))
    {
        if (zi->ci.stream.avail_out == 0)
        {
            if (fwrite(zi->ci.buffered_data,(uInt)zi->ci.pos_in_buffered_data,1,zi->filezip)
                                                                           !=1)
                err = ZIP_ERRNO;
            zi->ci.pos_in_buffered_data = 0;
            zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
            zi->ci.stream.next_out = zi->ci.buffered_data;
        }

        if (zi->ci.method == Z_DEFLATED)
        {
            uLong uTotalOutBefore = zi->ci.stream.total_out;
            err=deflate(&zi->ci.stream,  Z_NO_FLUSH);
            zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;

        }
        else
        {
            uInt copy_this,i;
            if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)
                copy_this = zi->ci.stream.avail_in;
            else
                copy_this = zi->ci.stream.avail_out;
            for (i=0;i<copy_this;i++)
                *(((char*)zi->ci.stream.next_out)+i) =
                    *(((const char*)zi->ci.stream.next_in)+i);
            {
                zi->ci.stream.avail_in -= copy_this;
                zi->ci.stream.avail_out-= copy_this;
                zi->ci.stream.next_in+= copy_this;
                zi->ci.stream.next_out+= copy_this;
                zi->ci.stream.total_in+= copy_this;
                zi->ci.stream.total_out+= copy_this;
                zi->ci.pos_in_buffered_data += copy_this;
            }
        }
    }

    return 0;
}

extern int ZEXPORT zipCloseFileInZip (file)
    zipFile file;
{
    zip_internal* zi;
    int err=ZIP_OK;

    if (file == NULL)
        return ZIP_PARAMERROR;
    zi = (zip_internal*)file;

    if (zi->in_opened_file_inzip == 0)    
        return ZIP_PARAMERROR;
    zi->ci.stream.avail_in = 0;
    
    if (zi->ci.method == Z_DEFLATED)
        while (err==ZIP_OK)
    {
        uLong uTotalOutBefore;
        if (zi->ci.stream.avail_out == 0)
        {
            if (fwrite(zi->ci.buffered_data,(uInt)zi->ci.pos_in_buffered_data,1,zi->filezip)
                                                                           !=1)
                err = ZIP_ERRNO;
            zi->ci.pos_in_buffered_data = 0;
            zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
            zi->ci.stream.next_out = zi->ci.buffered_data;
        }
        uTotalOutBefore = zi->ci.stream.total_out;
        err=deflate(&zi->ci.stream,  Z_FINISH);
        zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - uTotalOutBefore) ;
    }

    if (err==Z_STREAM_END)
        err=ZIP_OK; /* this is normal */

    if ((zi->ci.pos_in_buffered_data>0) && (err==ZIP_OK))
        if (fwrite(zi->ci.buffered_data,(uInt)zi->ci.pos_in_buffered_data,1,zi->filezip)
                                                                       !=1)
            err = ZIP_ERRNO;

    if ((zi->ci.method == Z_DEFLATED) && (err==ZIP_OK))
    {
        err=deflateEnd(&zi->ci.stream);
        zi->ci.stream_initialised = 0;
    }

    ziplocal_putValue_inmemory(zi->ci.central_header+16,(uLong)zi->ci.crc32,4); /*crc*/
    ziplocal_putValue_inmemory(zi->ci.central_header+20,
                                (uLong)zi->ci.stream.total_out,4); /*compr size*/
    ziplocal_putValue_inmemory(zi->ci.central_header+24,
                                (uLong)zi->ci.stream.total_in,4); /*uncompr size*/

    if (err==ZIP_OK)
        err = add_data_in_datablock(&zi->central_dir,zi->ci.central_header,
                                       (uLong)zi->ci.size_centralheader);
    free(zi->ci.central_header);

    if (err==ZIP_OK)
    {
        long cur_pos_inzip = ftell(zi->filezip);
	    if (fseek(zi->filezip,
                  zi->ci.pos_local_header + 14,SEEK_SET)!=0)
		    err = ZIP_ERRNO;

        if (err==ZIP_OK)
            err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.crc32,4); /* crc 32, unknown */

        if (err==ZIP_OK) /* compressed size, unknown */
            err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.stream.total_out,4); 

        if (err==ZIP_OK) /* uncompressed size, unknown */
            err = ziplocal_putValue(zi->filezip,(uLong)zi->ci.stream.total_in,4);

	    if (fseek(zi->filezip,
                  cur_pos_inzip,SEEK_SET)!=0)
		    err = ZIP_ERRNO;
    }

    zi->number_entry ++;
    zi->in_opened_file_inzip = 0;

    return err;
}

extern int ZEXPORT zipClose (file, global_comment)
    zipFile file;
    const char* global_comment;
{
    zip_internal* zi;
    int err = 0;
    uLong size_centraldir = 0;
    uLong centraldir_pos_inzip ;
    uInt size_global_comment;
    if (file == NULL)
        return ZIP_PARAMERROR;
    zi = (zip_internal*)file;

    if (zi->in_opened_file_inzip == 1)
    {
        err = zipCloseFileInZip (file);
    }

    if (global_comment==NULL)
        size_global_comment = 0;
    else
        size_global_comment = strlen(global_comment);


    centraldir_pos_inzip = ftell(zi->filezip);
    if (err==ZIP_OK)
    {
        linkedlist_datablock_internal* ldi = zi->central_dir.first_block ;
        while (ldi!=NULL)
        {
            if ((err==ZIP_OK) && (ldi->filled_in_this_block>0))
                if (fwrite(ldi->data,(uInt)ldi->filled_in_this_block,
                                        1,zi->filezip) !=1 )
                    err = ZIP_ERRNO;

            size_centraldir += ldi->filled_in_this_block;
            ldi = ldi->next_datablock;
        }
    }
    free_datablock(zi->central_dir.first_block);

    if (err==ZIP_OK) /* Magic End */
        err = ziplocal_putValue(zi->filezip,(uLong)ENDHEADERMAGIC,4);

    if (err==ZIP_OK) /* number of this disk */
        err = ziplocal_putValue(zi->filezip,(uLong)0,2);

    if (err==ZIP_OK) /* number of the disk with the start of the central directory */
        err = ziplocal_putValue(zi->filezip,(uLong)0,2);

    if (err==ZIP_OK) /* total number of entries in the central dir on this disk */
        err = ziplocal_putValue(zi->filezip,(uLong)zi->number_entry,2);

    if (err==ZIP_OK) /* total number of entries in the central dir */
        err = ziplocal_putValue(zi->filezip,(uLong)zi->number_entry,2);

    if (err==ZIP_OK) /* size of the central directory */
        err = ziplocal_putValue(zi->filezip,(uLong)size_centraldir,4);

    if (err==ZIP_OK) /* offset of start of central directory with respect to the 
	                        starting disk number */
        err = ziplocal_putValue(zi->filezip,(uLong)centraldir_pos_inzip ,4);

    if (err==ZIP_OK) /* zipfile comment length */
        err = ziplocal_putValue(zi->filezip,(uLong)size_global_comment,2);

    if ((err==ZIP_OK) && (size_global_comment>0))
        if (fwrite(global_comment,(uInt)size_global_comment,1,zi->filezip) !=1 )
                err = ZIP_ERRNO;
    fclose(zi->filezip);
    TRYFREE(zi);

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\minizip\unzip.h ===
/* unzip.h -- IO for uncompress .zip files using zlib 
   Version 0.15 beta, Mar 19th, 1998,

   Copyright (C) 1998 Gilles Vollant

   This unzip package allow extract file from .ZIP file, compatible with PKZip 2.04g
     WinZip, InfoZip tools and compatible.
   Encryption and multi volume ZipFile (span) are not supported.
   Old compressions used by old PKZip 1.x are not supported

   THIS IS AN ALPHA VERSION. AT THIS STAGE OF DEVELOPPEMENT, SOMES API OR STRUCTURE
   CAN CHANGE IN FUTURE VERSION !!
   I WAIT FEEDBACK at mail info@winimage.com
   Visit also http://www.winimage.com/zLibDll/unzip.htm for evolution

   Condition of use and distribution are the same than zlib :

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.


*/
/* for more info about .ZIP format, see 
      ftp://ftp.cdrom.com/pub/infozip/doc/appnote-970311-iz.zip
   PkWare has also a specification at :
      ftp://ftp.pkware.com/probdesc.zip */

#ifndef _unz_H
#define _unz_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _ZLIB_H
#include "zlib.h"
#endif

#if defined(STRICTUNZIP) || defined(STRICTZIPUNZIP)
/* like the STRICT of WIN32, we define a pointer that cannot be converted
    from (void*) without cast */
typedef struct TagunzFile__ { int unused; } unzFile__; 
typedef unzFile__ *unzFile;
#else
typedef voidp unzFile;
#endif


#define UNZ_OK                                  (0)
#define UNZ_END_OF_LIST_OF_FILE (-100)
#define UNZ_ERRNO               (Z_ERRNO)
#define UNZ_EOF                 (0)
#define UNZ_PARAMERROR                  (-102)
#define UNZ_BADZIPFILE                  (-103)
#define UNZ_INTERNALERROR               (-104)
#define UNZ_CRCERROR                    (-105)

/* tm_unz contain date/time info */
typedef struct tm_unz_s 
{
	uInt tm_sec;            /* seconds after the minute - [0,59] */
	uInt tm_min;            /* minutes after the hour - [0,59] */
	uInt tm_hour;           /* hours since midnight - [0,23] */
	uInt tm_mday;           /* day of the month - [1,31] */
	uInt tm_mon;            /* months since January - [0,11] */
	uInt tm_year;           /* years - [1980..2044] */
} tm_unz;

/* unz_global_info structure contain global data about the ZIPfile
   These data comes from the end of central dir */
typedef struct unz_global_info_s
{
	uLong number_entry;         /* total number of entries in
				       the central dir on this disk */
	uLong size_comment;         /* size of the global comment of the zipfile */
} unz_global_info;


/* unz_file_info contain information about a file in the zipfile */
typedef struct unz_file_info_s
{
    uLong version;              /* version made by                 2 bytes */
    uLong version_needed;       /* version needed to extract       2 bytes */
    uLong flag;                 /* general purpose bit flag        2 bytes */
    uLong compression_method;   /* compression method              2 bytes */
    uLong dosDate;              /* last mod file date in Dos fmt   4 bytes */
    uLong crc;                  /* crc-32                          4 bytes */
    uLong compressed_size;      /* compressed size                 4 bytes */ 
    uLong uncompressed_size;    /* uncompressed size               4 bytes */ 
    uLong size_filename;        /* filename length                 2 bytes */
    uLong size_file_extra;      /* extra field length              2 bytes */
    uLong size_file_comment;    /* file comment length             2 bytes */

    uLong disk_num_start;       /* disk number start               2 bytes */
    uLong internal_fa;          /* internal file attributes        2 bytes */
    uLong external_fa;          /* external file attributes        4 bytes */

    tm_unz tmu_date;
} unz_file_info;

extern int ZEXPORT unzStringFileNameCompare OF ((const char* fileName1,
												 const char* fileName2,
												 int iCaseSensitivity));
/*
   Compare two filename (fileName1,fileName2).
   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
								or strcasecmp)
   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
	(like 1 on Unix, 2 on Windows)
*/


extern unzFile ZEXPORT unzOpen OF((const char *path));
/*
  Open a Zip file. path contain the full pathname (by example,
     on a Windows NT computer "c:\\zlib\\zlib111.zip" or on an Unix computer
	 "zlib/zlib111.zip".
	 If the zipfile cannot be opened (file don't exist or in not valid), the
	   return value is NULL.
     Else, the return value is a unzFile Handle, usable with other function
	   of this unzip package.
*/

extern int ZEXPORT unzClose OF((unzFile file));
/*
  Close a ZipFile opened with unzipOpen.
  If there is files inside the .Zip opened with unzOpenCurrentFile (see later),
    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
  return UNZ_OK if there is no problem. */

extern int ZEXPORT unzGetGlobalInfo OF((unzFile file,
					unz_global_info *pglobal_info));
/*
  Write info about the ZipFile in the *pglobal_info structure.
  No preparation of the structure is needed
  return UNZ_OK if there is no problem. */


extern int ZEXPORT unzGetGlobalComment OF((unzFile file,
										   char *szComment,
					   uLong uSizeBuf));
/*
  Get the global comment string of the ZipFile, in the szComment buffer.
  uSizeBuf is the size of the szComment buffer.
  return the number of byte copied or an error code <0
*/


/***************************************************************************/
/* Unzip package allow you browse the directory of the zipfile */

extern int ZEXPORT unzGoToFirstFile OF((unzFile file));
/*
  Set the current file of the zipfile to the first file.
  return UNZ_OK if there is no problem
*/

extern int ZEXPORT unzGoToNextFile OF((unzFile file));
/*
  Set the current file of the zipfile to the next file.
  return UNZ_OK if there is no problem
  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
*/

extern int ZEXPORT unzLocateFile OF((unzFile file, 
				     const char *szFileName,
				     int iCaseSensitivity));
/*
  Try locate the file szFileName in the zipfile.
  For the iCaseSensitivity signification, see unzStringFileNameCompare

  return value :
  UNZ_OK if the file is found. It becomes the current file.
  UNZ_END_OF_LIST_OF_FILE if the file is not found
*/


extern int ZEXPORT unzGetCurrentFileInfo OF((unzFile file,
					     unz_file_info *pfile_info,
					     char *szFileName,
					     uLong fileNameBufferSize,
					     void *extraField,
					     uLong extraFieldBufferSize,
					     char *szComment,
					     uLong commentBufferSize));
/*
  Get Info about the current file
  if pfile_info!=NULL, the *pfile_info structure will contain somes info about
	    the current file
  if szFileName!=NULL, the filemane string will be copied in szFileName
			(fileNameBufferSize is the size of the buffer)
  if extraField!=NULL, the extra field information will be copied in extraField
			(extraFieldBufferSize is the size of the buffer).
			This is the Central-header version of the extra field
  if szComment!=NULL, the comment string of the file will be copied in szComment
			(commentBufferSize is the size of the buffer)
*/

/***************************************************************************/
/* for reading the content of the current zipfile, you can open it, read data
   from it, and close it (you can close it before reading all the file)
   */

extern int ZEXPORT unzOpenCurrentFile OF((unzFile file));
/*
  Open for reading data the current file in the zipfile.
  If there is no error, the return value is UNZ_OK.
*/

extern int ZEXPORT unzCloseCurrentFile OF((unzFile file));
/*
  Close the file in zip opened with unzOpenCurrentFile
  Return UNZ_CRCERROR if all the file was read but the CRC is not good
*/

												
extern int ZEXPORT unzReadCurrentFile OF((unzFile file, 
					  voidp buf,
					  unsigned len));
/*
  Read bytes from the current file (opened by unzOpenCurrentFile)
  buf contain buffer where data must be copied
  len the size of buf.

  return the number of byte copied if somes bytes are copied
  return 0 if the end of file was reached
  return <0 with error code if there is an error
    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
*/

extern z_off_t ZEXPORT unztell OF((unzFile file));
/*
  Give the current position in uncompressed data
*/

extern int ZEXPORT unzeof OF((unzFile file));
/*
  return 1 if the end of file was reached, 0 elsewhere 
*/

extern int ZEXPORT unzGetLocalExtrafield OF((unzFile file,
											 voidp buf,
											 unsigned len));
/*
  Read extra field from the current file (opened by unzOpenCurrentFile)
  This is the local-header version of the extra field (sometimes, there is
    more info in the local-header version than in the central-header)

  if buf==NULL, it return the size of the local extra field

  if buf!=NULL, len is the size of the buffer, the extra header is copied in
	buf.
  the return value is the number of bytes copied in buf, or (if <0) 
	the error code
*/

#ifdef __cplusplus
}
#endif

#endif /* _unz_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\minizip\zip.h ===
/* zip.h -- IO for compress .zip files using zlib 
   Version 0.15 alpha, Mar 19th, 1998,

   Copyright (C) 1998 Gilles Vollant

   This unzip package allow creates .ZIP file, compatible with PKZip 2.04g
     WinZip, InfoZip tools and compatible.
   Encryption and multi volume ZipFile (span) are not supported.
   Old compressions used by old PKZip 1.x are not supported

  For uncompress .zip file, look at unzip.h

   THIS IS AN ALPHA VERSION. AT THIS STAGE OF DEVELOPPEMENT, SOMES API OR STRUCTURE
   CAN CHANGE IN FUTURE VERSION !!
   I WAIT FEEDBACK at mail info@winimage.com
   Visit also http://www.winimage.com/zLibDll/zip.htm for evolution

   Condition of use and distribution are the same than zlib :

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.


*/

/* for more info about .ZIP format, see 
      ftp://ftp.cdrom.com/pub/infozip/doc/appnote-970311-iz.zip
   PkWare has also a specification at :
      ftp://ftp.pkware.com/probdesc.zip
*/

#ifndef _zip_H
#define _zip_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _ZLIB_H
#include "zlib.h"
#endif

#if defined(STRICTZIP) || defined(STRICTZIPUNZIP)
/* like the STRICT of WIN32, we define a pointer that cannot be converted
    from (void*) without cast */
typedef struct TagzipFile__ { int unused; } zipFile__; 
typedef zipFile__ *zipFile;
#else
typedef voidp zipFile;
#endif

#define ZIP_OK                                  (0)
#define ZIP_ERRNO               (Z_ERRNO)
#define ZIP_PARAMERROR                  (-102)
#define ZIP_INTERNALERROR               (-104)

/* tm_zip contain date/time info */
typedef struct tm_zip_s 
{
	uInt tm_sec;            /* seconds after the minute - [0,59] */
	uInt tm_min;            /* minutes after the hour - [0,59] */
	uInt tm_hour;           /* hours since midnight - [0,23] */
	uInt tm_mday;           /* day of the month - [1,31] */
	uInt tm_mon;            /* months since January - [0,11] */
	uInt tm_year;           /* years - [1980..2044] */
} tm_zip;

typedef struct
{
	tm_zip      tmz_date;       /* date in understandable format           */
    uLong       dosDate;       /* if dos_date == 0, tmu_date is used      */
/*    uLong       flag;        */   /* general purpose bit flag        2 bytes */

    uLong       internal_fa;    /* internal file attributes        2 bytes */
    uLong       external_fa;    /* external file attributes        4 bytes */
} zip_fileinfo;

extern zipFile ZEXPORT zipOpen OF((const char *pathname, int append));
/*
  Create a zipfile.
	 pathname contain on Windows NT a filename like "c:\\zlib\\zlib111.zip" or on
	   an Unix computer "zlib/zlib111.zip".
	 if the file pathname exist and append=1, the zip will be created at the end
	   of the file. (useful if the file contain a self extractor code)
	 If the zipfile cannot be opened, the return value is NULL.
     Else, the return value is a zipFile Handle, usable with other function
	   of this zip package.


*/

extern int ZEXPORT zipOpenNewFileInZip OF((zipFile file,
					   const char* filename,
					   const zip_fileinfo* zipfi,
					   const void* extrafield_local,
					   uInt size_extrafield_local,
					   const void* extrafield_global,
					   uInt size_extrafield_global,
					   const char* comment,
					   int method,
					   int level));
/*
  Open a file in the ZIP for writing.
  filename : the filename in zip (if NULL, '-' without quote will be used
  *zipfi contain supplemental information
  if extrafield_local!=NULL and size_extrafield_local>0, extrafield_local
    contains the extrafield data the the local header
  if extrafield_global!=NULL and size_extrafield_global>0, extrafield_global
    contains the extrafield data the the local header
  if comment != NULL, comment contain the comment string
  method contain the compression method (0 for store, Z_DEFLATED for deflate)
  level contain the level of compression (can be Z_DEFAULT_COMPRESSION)
*/

extern int ZEXPORT zipWriteInFileInZip OF((zipFile file,
					   const voidp buf,
					   unsigned len));
/*
  Write data in the zipfile
*/

extern int ZEXPORT zipCloseFileInZip OF((zipFile file));
/*
  Close the current file in the zipfile
*/

extern int ZEXPORT zipClose OF((zipFile file,
				const char* global_comment));
/*
  Close the zipfile
*/

#ifdef __cplusplus
}
#endif

#endif /* _zip_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\untgz\untgz.c ===
/*
 * untgz.c -- Display contents and/or extract file from
 * a gzip'd TAR file
 * written by "Pedro A. Aranda Guti\irrez" <paag@tid.es>
 * adaptation to Unix by Jean-loup Gailly <jloup@gzip.org>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>
#ifdef unix
# include <unistd.h>
#else
# include <direct.h>
# include <io.h>
#endif

#include "zlib.h"

#ifdef WIN32
#  ifndef F_OK
#    define F_OK (0)
#  endif
#  ifdef _MSC_VER
#    define mkdir(dirname,mode) _mkdir(dirname)
#    define strdup(str)         _strdup(str)
#    define unlink(fn)          _unlink(fn)
#    define access(path,mode)   _access(path,mode)
#  else
#    define mkdir(dirname,mode) _mkdir(dirname)
#  endif
#else
#  include <utime.h>
#endif


/* Values used in typeflag field.  */

#define REGTYPE	 '0'		/* regular file */
#define AREGTYPE '\0'		/* regular file */
#define LNKTYPE  '1'		/* link */
#define SYMTYPE  '2'		/* reserved */
#define CHRTYPE  '3'		/* character special */
#define BLKTYPE  '4'		/* block special */
#define DIRTYPE  '5'		/* directory */
#define FIFOTYPE '6'		/* FIFO special */
#define CONTTYPE '7'		/* reserved */

#define BLOCKSIZE 512

struct tar_header
{				/* byte offset */
  char name[100];		/*   0 */
  char mode[8];			/* 100 */
  char uid[8];			/* 108 */
  char gid[8];			/* 116 */
  char size[12];		/* 124 */
  char mtime[12];		/* 136 */
  char chksum[8];		/* 148 */
  char typeflag;		/* 156 */
  char linkname[100];		/* 157 */
  char magic[6];		/* 257 */
  char version[2];		/* 263 */
  char uname[32];		/* 265 */
  char gname[32];		/* 297 */
  char devmajor[8];		/* 329 */
  char devminor[8];		/* 337 */
  char prefix[155];		/* 345 */
				/* 500 */
};

union tar_buffer {
  char               buffer[BLOCKSIZE];
  struct tar_header  header;
};

enum { TGZ_EXTRACT = 0, TGZ_LIST };

static char *TGZfname	OF((const char *));
void TGZnotfound	OF((const char *));

int getoct		OF((char *, int));
char *strtime		OF((time_t *));
int ExprMatch		OF((char *,char *));

int makedir		OF((char *));
int matchname		OF((int,int,char **,char *));

void error		OF((const char *));
int  tar		OF((gzFile, int, int, int, char **));

void help		OF((int));
int main		OF((int, char **));

char *prog;

/* This will give a benign warning */

static char *TGZprefix[] = { "\0", ".tgz", ".tar.gz", ".tar", NULL };

/* Return the real name of the TGZ archive */
/* or NULL if it does not exist. */

static char *TGZfname OF((const char *fname))
{
  static char buffer[1024];
  int origlen,i;
  
  strcpy(buffer,fname);
  origlen = strlen(buffer);

  for (i=0; TGZprefix[i]; i++)
    {
       strcpy(buffer+origlen,TGZprefix[i]);
       if (access(buffer,F_OK) == 0)
         return buffer;
    }
  return NULL;
}

/* error message for the filename */

void TGZnotfound OF((const char *fname))
{
  int i;

  fprintf(stderr,"%s : couldn't find ",prog);
  for (i=0;TGZprefix[i];i++)
    fprintf(stderr,(TGZprefix[i+1]) ? "%s%s, " : "or %s%s\n",
            fname,
            TGZprefix[i]);
  exit(1);
}


/* help functions */

int getoct(char *p,int width)
{
  int result = 0;
  char c;
  
  while (width --)
    {
      c = *p++;
      if (c == ' ')
	continue;
      if (c == 0)
	break;
      result = result * 8 + (c - '0');
    }
  return result;
}

char *strtime (time_t *t)
{
  struct tm   *local;
  static char result[32];

  local = localtime(t);
  sprintf(result,"%2d/%02d/%4d %02d:%02d:%02d",
	  local->tm_mday, local->tm_mon+1, local->tm_year+1900,
	  local->tm_hour, local->tm_min,   local->tm_sec);
  return result;
}


/* regular expression matching */

#define ISSPECIAL(c) (((c) == '*') || ((c) == '/'))

int ExprMatch(char *string,char *expr)
{
  while (1)
    {
      if (ISSPECIAL(*expr))
	{
	  if (*expr == '/')
	    {
	      if (*string != '\\' && *string != '/')
		return 0;
	      string ++; expr++;
	    }
	  else if (*expr == '*')
	    {
	      if (*expr ++ == 0)
		return 1;
	      while (*++string != *expr)
		if (*string == 0)
		  return 0;
	    }
	}
      else
	{
	  if (*string != *expr)
	    return 0;
	  if (*expr++ == 0)
	    return 1;
	  string++;
	}
    }
}

/* recursive make directory */
/* abort if you get an ENOENT errno somewhere in the middle */
/* e.g. ignore error "mkdir on existing directory" */
/* */
/* return 1 if OK */
/*        0 on error */

int makedir (char *newdir)
{
  char *buffer = strdup(newdir);
  char *p;
  int  len = strlen(buffer);
  
  if (len <= 0) {
    free(buffer);
    return 0;
  }
  if (buffer[len-1] == '/') {
    buffer[len-1] = '\0';
  }
  if (mkdir(buffer, 0775) == 0)
    {
      free(buffer);
      return 1;
    }

  p = buffer+1;
  while (1)
    {
      char hold;
      
      while(*p && *p != '\\' && *p != '/')
	p++;
      hold = *p;
      *p = 0;
      if ((mkdir(buffer, 0775) == -1) && (errno == ENOENT))
	{
	  fprintf(stderr,"%s: couldn't create directory %s\n",prog,buffer);
	  free(buffer);
	  return 0;
	}
      if (hold == 0)
	break;
      *p++ = hold;
    }
  free(buffer);
  return 1;
}

int matchname (int arg,int argc,char **argv,char *fname)
{
  if (arg == argc)		/* no arguments given (untgz tgzarchive) */
    return 1;

  while (arg < argc)
    if (ExprMatch(fname,argv[arg++]))
      return 1;

  return 0; /* ignore this for the moment being */
}


/* Tar file list or extract */

int tar (gzFile in,int action,int arg,int argc,char **argv)
{
  union  tar_buffer buffer;
  int    len;
  int    err;
  int    getheader = 1;
  int    remaining = 0;
  FILE   *outfile = NULL;
  char   fname[BLOCKSIZE];
  time_t tartime;
  
  if (action == TGZ_LIST)
    printf("     day      time     size                       file\n"
	   " ---------- -------- --------- -------------------------------------\n");
  while (1)
    {
      len = gzread(in, &buffer, BLOCKSIZE);
      if (len < 0)
	error (gzerror(in, &err));
      /*
       * Always expect complete blocks to process
       * the tar information.
       */
      if (len != BLOCKSIZE)
	error("gzread: incomplete block read");
      
      /*
       * If we have to get a tar header
       */
      if (getheader == 1)
	{
	  /*
	   * if we met the end of the tar
	   * or the end-of-tar block,
	   * we are done
	   */
	  if ((len == 0)  || (buffer.header.name[0]== 0)) break;

	  tartime = (time_t)getoct(buffer.header.mtime,12);
	  strcpy(fname,buffer.header.name);
	  
	  switch (buffer.header.typeflag)
	    {
	    case DIRTYPE:
	      if (action == TGZ_LIST)
		printf(" %s     <dir> %s\n",strtime(&tartime),fname);
	      if (action == TGZ_EXTRACT)
		makedir(fname);
	      break;
	    case REGTYPE:
	    case AREGTYPE:
	      remaining = getoct(buffer.header.size,12);
	      if (action == TGZ_LIST)
		printf(" %s %9d %s\n",strtime(&tartime),remaining,fname);
	      if (action == TGZ_EXTRACT)
		{
		  if ((remaining) && (matchname(arg,argc,argv,fname)))
		    {
		      outfile = fopen(fname,"wb");
		      if (outfile == NULL) {
			/* try creating directory */
			char *p = strrchr(fname, '/');
			if (p != NULL) {
			  *p = '\0';
			  makedir(fname);
			  *p = '/';
			  outfile = fopen(fname,"wb");
			}
		      }
		      fprintf(stderr,
			      "%s %s\n",
			      (outfile) ? "Extracting" : "Couldn't create",
			      fname);
		    }
		  else
		    outfile = NULL;
		}
	      /*
	       * could have no contents
	       */
	      getheader = (remaining) ? 0 : 1;
	      break;
	    default:
	      if (action == TGZ_LIST)
		printf(" %s     <---> %s\n",strtime(&tartime),fname);
	      break;
	    }
	}
      else
	{
	  unsigned int bytes = (remaining > BLOCKSIZE) ? BLOCKSIZE : remaining;

	  if ((action == TGZ_EXTRACT) && (outfile != NULL))
	    {
	      if (fwrite(&buffer,sizeof(char),bytes,outfile) != bytes)
		{
		  fprintf(stderr,"%s : error writing %s skipping...\n",prog,fname);
		  fclose(outfile);
		  unlink(fname);
		}
	    }
	  remaining -= bytes;
	  if (remaining == 0)
	    {
	      getheader = 1;
	      if ((action == TGZ_EXTRACT) && (outfile != NULL))
		{
#ifdef WIN32
		  HANDLE hFile;
		  FILETIME ftm,ftLocal;
		  SYSTEMTIME st;
		  struct tm localt;
 
		  fclose(outfile);

		  localt = *localtime(&tartime);

		  hFile = CreateFile(fname, GENERIC_READ | GENERIC_WRITE,
				     0, NULL, OPEN_EXISTING, 0, NULL);
		  
		  st.wYear = (WORD)localt.tm_year+1900;
		  st.wMonth = (WORD)localt.tm_mon;
		  st.wDayOfWeek = (WORD)localt.tm_wday;
		  st.wDay = (WORD)localt.tm_mday;
		  st.wHour = (WORD)localt.tm_hour;
		  st.wMinute = (WORD)localt.tm_min;
		  st.wSecond = (WORD)localt.tm_sec;
		  st.wMilliseconds = 0;
		  SystemTimeToFileTime(&st,&ftLocal);
		  LocalFileTimeToFileTime(&ftLocal,&ftm);
		  SetFileTime(hFile,&ftm,NULL,&ftm);
		  CloseHandle(hFile);

		  outfile = NULL;
#else
		  struct utimbuf settime;

		  settime.actime = settime.modtime = tartime;

		  fclose(outfile);
		  outfile = NULL;
		  utime(fname,&settime);
#endif
		}
	    }
	}
    }
  
  if (gzclose(in) != Z_OK)
    error("failed gzclose");

  return 0;
}


/* =========================================================== */

void help(int exitval)
{
  fprintf(stderr,
	  "untgz v 0.1\n"
	  " an sample application of zlib 1.0.4\n\n"
          "Usage : untgz TGZfile            to extract all files\n"
          "        untgz TGZfile fname ...  to extract selected files\n"
          "        untgz -l TGZfile         to list archive contents\n"
          "        untgz -h                 to display this help\n\n");
  exit(exitval);
}

void error(const char *msg)
{
    fprintf(stderr, "%s: %s\n", prog, msg);
    exit(1);
}


/* ====================================================================== */

int _CRT_glob = 0;	/* disable globbing of the arguments */

int main(int argc,char **argv)
{
    int 	action = TGZ_EXTRACT;
    int 	arg = 1;
    char	*TGZfile;
    gzFile	*f;
    

    prog = strrchr(argv[0],'\\');
    if (prog == NULL)
      {
	prog = strrchr(argv[0],'/');
	if (prog == NULL)
	  {
	    prog = strrchr(argv[0],':');
	    if (prog == NULL)
	      prog = argv[0];
	    else
	      prog++;
	  }
	else
	  prog++;
      }
    else
      prog++;
    
    if (argc == 1)
      help(0);

    if (strcmp(argv[arg],"-l") == 0)
      {
	action = TGZ_LIST;
	if (argc == ++arg)
	  help(0);
      }
    else if (strcmp(argv[arg],"-h") == 0)
      {
	help(0);
      }

    if ((TGZfile = TGZfname(argv[arg])) == NULL)
      TGZnotfound(argv[arg]);            

    ++arg;
    if ((action == TGZ_LIST) && (arg != argc))
      help(1);

/*
 *  Process the TGZ file
 */
    switch(action)
      {
      case TGZ_LIST:
      case TGZ_EXTRACT:
	f = gzopen(TGZfile,"rb");
	if (f == NULL)
	  {
	    fprintf(stderr,"%s: Couldn't gzopen %s\n",
		    prog,
		    TGZfile);
	    return 1;
	  }
	exit(tar(f, action, arg, argc, argv));
      break;
	
      default:
	error("Unknown option!");
	exit(1);
      }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\misc\zlib113\contrib\minizip\unzip.c ===
/* unzip.c -- IO on .zip files using zlib 
   Version 0.15 beta, Mar 19th, 1998,

   Read unzip.h for more info
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "zlib.h"
#include "unzip.h"

#ifdef STDC
#  include <stddef.h>
#  include <string.h>
#  include <stdlib.h>
#endif
#ifdef NO_ERRNO_H
    extern int errno;
#else
#   include <errno.h>
#endif


#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */



#if !defined(unix) && !defined(CASESENSITIVITYDEFAULT_YES) && \
                      !defined(CASESENSITIVITYDEFAULT_NO)
#define CASESENSITIVITYDEFAULT_NO
#endif


#ifndef UNZ_BUFSIZE
#define UNZ_BUFSIZE (16384)
#endif

#ifndef UNZ_MAXFILENAMEINZIP
#define UNZ_MAXFILENAMEINZIP (256)
#endif

#ifndef ALLOC
# define ALLOC(size) (malloc(size))
#endif
#ifndef TRYFREE
# define TRYFREE(p) {if (p) free(p);}
#endif

#define SIZECENTRALDIRITEM (0x2e)
#define SIZEZIPLOCALHEADER (0x1e)


/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */

#ifndef SEEK_CUR
#define SEEK_CUR    1
#endif

#ifndef SEEK_END
#define SEEK_END    2
#endif

#ifndef SEEK_SET
#define SEEK_SET    0
#endif

const char unz_copyright[] =
   " unzip 0.15 Copyright 1998 Gilles Vollant ";

/* unz_file_info_interntal contain internal info about a file in zipfile*/
typedef struct unz_file_info_internal_s
{
    uLong offset_curfile;/* relative offset of local header 4 bytes */
} unz_file_info_internal;


/* file_in_zip_read_info_s contain internal information about a file in zipfile,
    when reading and decompress it */
typedef struct
{
	char  *read_buffer;         /* internal buffer for compressed data */
	z_stream stream;            /* zLib stream structure for inflate */

	uLong pos_in_zipfile;       /* position in byte on the zipfile, for fseek*/
	uLong stream_initialised;   /* flag set if stream structure is initialised*/

	uLong offset_local_extrafield;/* offset of the local extra field */
	uInt  size_local_extrafield;/* size of the local extra field */
	uLong pos_local_extrafield;   /* position in the local extra field in read*/

	uLong crc32;                /* crc32 of all data uncompressed */
	uLong crc32_wait;           /* crc32 we must obtain after decompress all */
	uLong rest_read_compressed; /* number of byte to be decompressed */
	uLong rest_read_uncompressed;/*number of byte to be obtained after decomp*/
	FILE* file;                 /* io structore of the zipfile */
	uLong compression_method;   /* compression method (0==store) */
	uLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
} file_in_zip_read_info_s;


/* unz_s contain internal information about the zipfile
*/
typedef struct
{
	FILE* file;                 /* io structore of the zipfile */
	unz_global_info gi;       /* public global information */
	uLong byte_before_the_zipfile;/* byte before the zipfile, (>0 for sfx)*/
	uLong num_file;             /* number of the current file in the zipfile*/
	uLong pos_in_central_dir;   /* pos of the current file in the central dir*/
	uLong current_file_ok;      /* flag about the usability of the current file*/
	uLong central_pos;          /* position of the beginning of the central dir*/

	uLong size_central_dir;     /* size of the central directory  */
	uLong offset_central_dir;   /* offset of start of central directory with
								   respect to the starting disk number */

	unz_file_info cur_file_info; /* public info about the current file in zip*/
	unz_file_info_internal cur_file_info_internal; /* private info about it*/
    file_in_zip_read_info_s* pfile_in_zip_read; /* structure about the current
	                                    file if we are decompressing it */
} unz_s;


/* ===========================================================================
     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
   for end of file.
   IN assertion: the stream s has been sucessfully opened for reading.
*/


local int unzlocal_getByte(fin,pi)
	FILE *fin;
	int *pi;
{
    unsigned char c;
	int err = fread(&c, 1, 1, fin);
    if (err==1)
    {
        *pi = (int)c;
        return UNZ_OK;
    }
    else
    {
        if (ferror(fin)) 
            return UNZ_ERRNO;
        else
            return UNZ_EOF;
    }
}


/* ===========================================================================
   Reads a long in LSB order from the given gz_stream. Sets 
*/
local int unzlocal_getShort (fin,pX)
	FILE* fin;
    uLong *pX;
{
    uLong x ;
    int i;
    int err;

    err = unzlocal_getByte(fin,&i);
    x = (uLong)i;
    
    if (err==UNZ_OK)
        err = unzlocal_getByte(fin,&i);
    x += ((uLong)i)<<8;
   
    if (err==UNZ_OK)
        *pX = x;
    else
        *pX = 0;
    return err;
}

local int unzlocal_getLong (fin,pX)
	FILE* fin;
    uLong *pX;
{
    uLong x ;
    int i;
    int err;

    err = unzlocal_getByte(fin,&i);
    x = (uLong)i;
    
    if (err==UNZ_OK)
        err = unzlocal_getByte(fin,&i);
    x += ((uLong)i)<<8;

    if (err==UNZ_OK)
        err = unzlocal_getByte(fin,&i);
    x += ((uLong)i)<<16;

    if (err==UNZ_OK)
        err = unzlocal_getByte(fin,&i);
    x += ((uLong)i)<<24;
   
    if (err==UNZ_OK)
        *pX = x;
    else
        *pX = 0;
    return err;
}


/* My own strcmpi / strcasecmp */
local int strcmpcasenosensitive_internal (fileName1,fileName2)
	const char* fileName1;
	const char* fileName2;
{
	for (;;)
	{
		char c1=*(fileName1++);
		char c2=*(fileName2++);
		if ((c1>='a') && (c1<='z'))
			c1 -= 0x20;
		if ((c2>='a') && (c2<='z'))
			c2 -= 0x20;
		if (c1=='\0')
			return ((c2=='\0') ? 0 : -1);
		if (c2=='\0')
			return 1;
		if (c1<c2)
			return -1;
		if (c1>c2)
			return 1;
	}
}


#ifdef  CASESENSITIVITYDEFAULT_NO
#define CASESENSITIVITYDEFAULTVALUE 2
#else
#define CASESENSITIVITYDEFAULTVALUE 1
#endif

#ifndef STRCMPCASENOSENTIVEFUNCTION
#define STRCMPCASENOSENTIVEFUNCTION strcmpcasenosensitive_internal
#endif

/* 
   Compare two filename (fileName1,fileName2).
   If iCaseSenisivity = 1, comparision is case sensitivity (like strcmp)
   If iCaseSenisivity = 2, comparision is not case sensitivity (like strcmpi
                                                                or strcasecmp)
   If iCaseSenisivity = 0, case sensitivity is defaut of your operating system
        (like 1 on Unix, 2 on Windows)

*/
extern int ZEXPORT unzStringFileNameCompare (fileName1,fileName2,iCaseSensitivity)
	const char* fileName1;
	const char* fileName2;
	int iCaseSensitivity;
{
	if (iCaseSensitivity==0)
		iCaseSensitivity=CASESENSITIVITYDEFAULTVALUE;

	if (iCaseSensitivity==1)
		return strcmp(fileName1,fileName2);

	return STRCMPCASENOSENTIVEFUNCTION(fileName1,fileName2);
} 

#define BUFREADCOMMENT (0x400)

/*
  Locate the Central directory of a zipfile (at the end, just before
    the global comment)
*/
local uLong unzlocal_SearchCentralDir(fin)
	FILE *fin;
{
	unsigned char* buf;
	uLong uSizeFile;
	uLong uBackRead;
	uLong uMaxBack=0xffff; /* maximum size of global comment */
	uLong uPosFound=0;
	
	if (fseek(fin,0,SEEK_END) != 0)
		return 0;


	uSizeFile = ftell( fin );
	
	if (uMaxBack>uSizeFile)
		uMaxBack = uSizeFile;

	buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
	if (buf==NULL)
		return 0;

	uBackRead = 4;
	while (uBackRead<uMaxBack)
	{
		uLong uReadSize,uReadPos ;
		int i;
		if (uBackRead+BUFREADCOMMENT>uMaxBack) 
			uBackRead = uMaxBack;
		else
			uBackRead+=BUFREADCOMMENT;
		uReadPos = uSizeFile-uBackRead ;
		
		uReadSize = ((BUFREADCOMMENT+4) < (uSizeFile-uReadPos)) ? 
                     (BUFREADCOMMENT+4) : (uSizeFile-uReadPos);
		if (fseek(fin,uReadPos,SEEK_SET)!=0)
			break;

		if (fread(buf,(uInt)uReadSize,1,fin)!=1)
			break;

                for (i=(int)uReadSize-3; (i--)>0;)
			if (((*(buf+i))==0x50) && ((*(buf+i+1))==0x4b) && 
				((*(buf+i+2))==0x05) && ((*(buf+i+3))==0x06))
			{
				uPosFound = uReadPos+i;
				break;
			}

		if (uPosFound!=0)
			break;
	}
	TRYFREE(buf);
	return uPosFound;
}

/*
  Open a Zip file. path contain the full pathname (by example,
     on a Windows NT computer "c:\\test\\zlib109.zip" or on an Unix computer
	 "zlib/zlib109.zip".
	 If the zipfile cannot be opened (file don't exist or in not valid), the
	   return value is NULL.
     Else, the return value is a unzFile Handle, usable with other function
	   of this unzip package.
*/
extern unzFile ZEXPORT unzOpen (path)
	const char *path;
{
	unz_s us;
	unz_s *s;
	uLong central_pos,uL;
	FILE * fin ;

	uLong number_disk;          /* number of the current dist, used for 
								   spaning ZIP, unsupported, always 0*/
	uLong number_disk_with_CD;  /* number the the disk with central dir, used
								   for spaning ZIP, unsupported, always 0*/
	uLong number_entry_CD;      /* total number of entries in
	                               the central dir 
	                               (same than number_entry on nospan) */

	int err=UNZ_OK;

    if (unz_copyright[0]!=' ')
        return NULL;

    fin=fopen(path,"rb");
	if (fin==NULL)
		return NULL;

	central_pos = unzlocal_SearchCentralDir(fin);
	if (central_pos==0)
		err=UNZ_ERRNO;

	if (fseek(fin,central_pos,SEEK_SET)!=0)
		err=UNZ_ERRNO;

	/* the signature, already checked */
	if (unzlocal_getLong(fin,&uL)!=UNZ_OK)
		err=UNZ_ERRNO;

	/* number of this disk */
	if (unzlocal_getShort(fin,&number_disk)!=UNZ_OK)
		err=UNZ_ERRNO;

	/* number of the disk with the start of the central directory */
	if (unzlocal_getShort(fin,&number_disk_with_CD)!=UNZ_OK)
		err=UNZ_ERRNO;

	/* total number of entries in the central dir on this disk */
	if (unzlocal_getShort(fin,&us.gi.number_entry)!=UNZ_OK)
		err=UNZ_ERRNO;

	/* total number of entries in the central dir */
	if (unzlocal_getShort(fin,&number_entry_CD)!=UNZ_OK)
		err=UNZ_ERRNO;

	if ((number_entry_CD!=us.gi.number_entry) ||
		(number_disk_with_CD!=0) ||
		(number_disk!=0))
		err=UNZ_BADZIPFILE;

	/* size of the central directory */
	if (unzlocal_getLong(fin,&us.size_central_dir)!=UNZ_OK)
		err=UNZ_ERRNO;

	/* offset of start of central directory with respect to the 
	      starting disk number */
	if (unzlocal_getLong(fin,&us.offset_central_dir)!=UNZ_OK)
		err=UNZ_ERRNO;

	/* zipfile comment length */
	if (unzlocal_getShort(fin,&us.gi.size_comment)!=UNZ_OK)
		err=UNZ_ERRNO;

	if ((central_pos<us.offset_central_dir+us.size_central_dir) && 
		(err==UNZ_OK))
		err=UNZ_BADZIPFILE;

	if (err!=UNZ_OK)
	{
		fclose(fin);
		return NULL;
	}

	us.file=fin;
	us.byte_before_the_zipfile = central_pos -
		                    (us.offset_central_dir+us.size_central_dir);
	us.central_pos = central_pos;
    us.pfile_in_zip_read = NULL;
	

	s=(unz_s*)ALLOC(sizeof(unz_s));
	*s=us;
	unzGoToFirstFile((unzFile)s);	
	return (unzFile)s;	
}


/*
  Close a ZipFile opened with unzipOpen.
  If there is files inside the .Zip opened with unzipOpenCurrentFile (see later),
    these files MUST be closed with unzipCloseCurrentFile before call unzipClose.
  return UNZ_OK if there is no problem. */
extern int ZEXPORT unzClose (file)
	unzFile file;
{
	unz_s* s;
	if (file==NULL)
		return UNZ_PARAMERROR;
	s=(unz_s*)file;

    if (s->pfile_in_zip_read!=NULL)
        unzCloseCurrentFile(file);

	fclose(s->file);
	TRYFREE(s);
	return UNZ_OK;
}


/*
  Write info about the ZipFile in the *pglobal_info structure.
  No preparation of the structure is needed
  return UNZ_OK if there is no problem. */
extern int ZEXPORT unzGetGlobalInfo (file,pglobal_info)
	unzFile file;
	unz_global_info *pglobal_info;
{
	unz_s* s;
	if (file==NULL)
		return UNZ_PARAMERROR;
	s=(unz_s*)file;
	*pglobal_info=s->gi;
	return UNZ_OK;
}


/*
   Translate date/time from Dos format to tm_unz (readable more easilty)
*/
local void unzlocal_DosDateToTmuDate (ulDosDate, ptm)
    uLong ulDosDate;
    tm_unz* ptm;
{
    uLong uDate;
    uDate = (uLong)(ulDosDate>>16);
    ptm->tm_mday = (uInt)(uDate&0x1f) ;
    ptm->tm_mon =  (uInt)((((uDate)&0x1E0)/0x20)-1) ;
    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980) ;

    ptm->tm_hour = (uInt) ((ulDosDate &0xF800)/0x800);
    ptm->tm_min =  (uInt) ((ulDosDate&0x7E0)/0x20) ;
    ptm->tm_sec =  (uInt) (2*(ulDosDate&0x1f)) ;
}

/*
  Get Info about the current file in the zipfile, with internal only info
*/
local int unzlocal_GetCurrentFileInfoInternal OF((unzFile file,
                                                  unz_file_info *pfile_info,
                                                  unz_file_info_internal 
                                                  *pfile_info_internal,
                                                  char *szFileName,
												  uLong fileNameBufferSize,
                                                  void *extraField,
												  uLong extraFieldBufferSize,
                                                  char *szComment,
												  uLong commentBufferSize));

local int unzlocal_GetCurrentFileInfoInternal (file,
                                              pfile_info,
                                              pfile_info_internal,
                                              szFileName, fileNameBufferSize,
                                              extraField, extraFieldBufferSize,
                                              szComment,  commentBufferSize)
	unzFile file;
	unz_file_info *pfile_info;
	unz_file_info_internal *pfile_info_internal;
	char *szFileName;
	uLong fileNameBufferSize;
	void *extraField;
	uLong extraFieldBufferSize;
	char *szComment;
	uLong commentBufferSize;
{
	unz_s* s;
	unz_file_info file_info;
	unz_file_info_internal file_info_internal;
	int err=UNZ_OK;
	uLong uMagic;
	long lSeek=0;

	if (file==NULL)
		return UNZ_PARAMERROR;
	s=(unz_s*)file;
	if (fseek(s->file,s->pos_in_central_dir+s->byte_before_the_zipfile,SEEK_SET)!=0)
		err=UNZ_ERRNO;


	/* we check the magic */
	if (err==UNZ_OK)
		if (unzlocal_getLong(s->file,&uMagic) != UNZ_OK)
			err=UNZ_ERRNO;
		else if (uMagic!=0x02014b50)
			err=UNZ_BADZIPFILE;

	if (unzlocal_getShort(s->file,&file_info.version) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getShort(s->file,&file_info.version_needed) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getShort(s->file,&file_info.flag) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getShort(s->file,&file_info.compression_method) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getLong(s->file,&file_info.dosDate) != UNZ_OK)
		err=UNZ_ERRNO;

    unzlocal_DosDateToTmuDate(file_info.dosDate,&file_info.tmu_date);

	if (unzlocal_getLong(s->file,&file_info.crc) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getLong(s->file,&file_info.compressed_size) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getLong(s->file,&file_info.uncompressed_size) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getShort(s->file,&file_info.size_filename) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getShort(s->file,&file_info.size_file_extra) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getShort(s->file,&file_info.size_file_comment) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getShort(s->file,&file_info.disk_num_start) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getShort(s->file,&file_info.internal_fa) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getLong(s->file,&file_info.external_fa) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getLong(s->file,&file_info_internal.offset_curfile) != UNZ_OK)
		err=UNZ_ERRNO;

	lSeek+=file_info.size_filename;
	if ((err==UNZ_OK) && (szFileName!=NULL))
	{
		uLong uSizeRead ;
		if (file_info.size_filename<fileNameBufferSize)
		{
			*(szFileName+file_info.size_filename)='\0';
			uSizeRead = file_info.size_filename;
		}
		else
			uSizeRead = fileNameBufferSize;

		if ((file_info.size_filename>0) && (fileNameBufferSize>0))
			if (fread(szFileName,(uInt)uSizeRead,1,s->file)!=1)
				err=UNZ_ERRNO;
		lSeek -= uSizeRead;
	}

	
	if ((err==UNZ_OK) && (extraField!=NULL))
	{
		uLong uSizeRead ;
		if (file_info.size_file_extra<extraFieldBufferSize)
			uSizeRead = file_info.size_file_extra;
		else
			uSizeRead = extraFieldBufferSize;

		if (lSeek!=0)
			if (fseek(s->file,lSeek,SEEK_CUR)==0)
				lSeek=0;
			else
				err=UNZ_ERRNO;
		if ((file_info.size_file_extra>0) && (extraFieldBufferSize>0))
			if (fread(extraField,(uInt)uSizeRead,1,s->file)!=1)
				err=UNZ_ERRNO;
		lSeek += file_info.size_file_extra - uSizeRead;
	}
	else
		lSeek+=file_info.size_file_extra; 

	
	if ((err==UNZ_OK) && (szComment!=NULL))
	{
		uLong uSizeRead ;
		if (file_info.size_file_comment<commentBufferSize)
		{
			*(szComment+file_info.size_file_comment)='\0';
			uSizeRead = file_info.size_file_comment;
		}
		else
			uSizeRead = commentBufferSize;

		if (lSeek!=0)
			if (fseek(s->file,lSeek,SEEK_CUR)==0)
				lSeek=0;
			else
				err=UNZ_ERRNO;
		if ((file_info.size_file_comment>0) && (commentBufferSize>0))
			if (fread(szComment,(uInt)uSizeRead,1,s->file)!=1)
				err=UNZ_ERRNO;
		lSeek+=file_info.size_file_comment - uSizeRead;
	}
	else
		lSeek+=file_info.size_file_comment;

	if ((err==UNZ_OK) && (pfile_info!=NULL))
		*pfile_info=file_info;

	if ((err==UNZ_OK) && (pfile_info_internal!=NULL))
		*pfile_info_internal=file_info_internal;

	return err;
}



/*
  Write info about the ZipFile in the *pglobal_info structure.
  No preparation of the structure is needed
  return UNZ_OK if there is no problem.
*/
extern int ZEXPORT unzGetCurrentFileInfo (file,
                                                  pfile_info,
                                                  szFileName, fileNameBufferSize,
                                                  extraField, extraFieldBufferSize,
                                                  szComment,  commentBufferSize)
	unzFile file;
	unz_file_info *pfile_info;
	char *szFileName;
	uLong fileNameBufferSize;
	void *extraField;
	uLong extraFieldBufferSize;
	char *szComment;
	uLong commentBufferSize;
{
	return unzlocal_GetCurrentFileInfoInternal(file,pfile_info,NULL,
												szFileName,fileNameBufferSize,
												extraField,extraFieldBufferSize,
												szComment,commentBufferSize);
}

/*
  Set the current file of the zipfile to the first file.
  return UNZ_OK if there is no problem
*/
extern int ZEXPORT unzGoToFirstFile (file)
	unzFile file;
{
	int err=UNZ_OK;
	unz_s* s;
	if (file==NULL)
		return UNZ_PARAMERROR;
	s=(unz_s*)file;
	s->pos_in_central_dir=s->offset_central_dir;
	s->num_file=0;
	err=unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
											 &s->cur_file_info_internal,
											 NULL,0,NULL,0,NULL,0);
	s->current_file_ok = (err == UNZ_OK);
	return err;
}


/*
  Set the current file of the zipfile to the next file.
  return UNZ_OK if there is no problem
  return UNZ_END_OF_LIST_OF_FILE if the actual file was the latest.
*/
extern int ZEXPORT unzGoToNextFile (file)
	unzFile file;
{
	unz_s* s;	
	int err;

	if (file==NULL)
		return UNZ_PARAMERROR;
	s=(unz_s*)file;
	if (!s->current_file_ok)
		return UNZ_END_OF_LIST_OF_FILE;
	if (s->num_file+1==s->gi.number_entry)
		return UNZ_END_OF_LIST_OF_FILE;

	s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +
			s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment ;
	s->num_file++;
	err = unzlocal_GetCurrentFileInfoInternal(file,&s->cur_file_info,
											   &s->cur_file_info_internal,
											   NULL,0,NULL,0,NULL,0);
	s->current_file_ok = (err == UNZ_OK);
	return err;
}


/*
  Try locate the file szFileName in the zipfile.
  For the iCaseSensitivity signification, see unzipStringFileNameCompare

  return value :
  UNZ_OK if the file is found. It becomes the current file.
  UNZ_END_OF_LIST_OF_FILE if the file is not found
*/
extern int ZEXPORT unzLocateFile (file, szFileName, iCaseSensitivity)
	unzFile file;
	const char *szFileName;
	int iCaseSensitivity;
{
	unz_s* s;	
	int err;

	
	uLong num_fileSaved;
	uLong pos_in_central_dirSaved;


	if (file==NULL)
		return UNZ_PARAMERROR;

    if (strlen(szFileName)>=UNZ_MAXFILENAMEINZIP)
        return UNZ_PARAMERROR;

	s=(unz_s*)file;
	if (!s->current_file_ok)
		return UNZ_END_OF_LIST_OF_FILE;

	num_fileSaved = s->num_file;
	pos_in_central_dirSaved = s->pos_in_central_dir;

	err = unzGoToFirstFile(file);

	while (err == UNZ_OK)
	{
		char szCurrentFileName[UNZ_MAXFILENAMEINZIP+1];
		unzGetCurrentFileInfo(file,NULL,
								szCurrentFileName,sizeof(szCurrentFileName)-1,
								NULL,0,NULL,0);
		if (unzStringFileNameCompare(szCurrentFileName,
										szFileName,iCaseSensitivity)==0)
			return UNZ_OK;
		err = unzGoToNextFile(file);
	}

	s->num_file = num_fileSaved ;
	s->pos_in_central_dir = pos_in_central_dirSaved ;
	return err;
}


/*
  Read the local header of the current zipfile
  Check the coherency of the local header and info in the end of central
        directory about this file
  store in *piSizeVar the size of extra info in local header
        (filename and size of extra field data)
*/
local int unzlocal_CheckCurrentFileCoherencyHeader (s,piSizeVar,
													poffset_local_extrafield,
													psize_local_extrafield)
	unz_s* s;
	uInt* piSizeVar;
	uLong *poffset_local_extrafield;
	uInt  *psize_local_extrafield;
{
	uLong uMagic,uData,uFlags;
	uLong size_filename;
	uLong size_extra_field;
	int err=UNZ_OK;

	*piSizeVar = 0;
	*poffset_local_extrafield = 0;
	*psize_local_extrafield = 0;

	if (fseek(s->file,s->cur_file_info_internal.offset_curfile +
								s->byte_before_the_zipfile,SEEK_SET)!=0)
		return UNZ_ERRNO;


	if (err==UNZ_OK)
		if (unzlocal_getLong(s->file,&uMagic) != UNZ_OK)
			err=UNZ_ERRNO;
		else if (uMagic!=0x04034b50)
			err=UNZ_BADZIPFILE;

	if (unzlocal_getShort(s->file,&uData) != UNZ_OK)
		err=UNZ_ERRNO;
/*
	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.wVersion))
		err=UNZ_BADZIPFILE;
*/
	if (unzlocal_getShort(s->file,&uFlags) != UNZ_OK)
		err=UNZ_ERRNO;

	if (unzlocal_getShort(s->file,&uData) != UNZ_OK)
		err=UNZ_ERRNO;
	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compression_method))
		err=UNZ_BADZIPFILE;

    if ((err==UNZ_OK) && (s->cur_file_info.compression_method!=0) &&
                         (s->cur_file_info.compression_method!=Z_DEFLATED))
        err=UNZ_BADZIPFILE;

	if (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* date/time */
		err=UNZ_ERRNO;

	if (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* crc */
		err=UNZ_ERRNO;
	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.crc) &&
		                      ((uFlags & 8)==0))
		err=UNZ_BADZIPFILE;

	if (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* size compr */
		err=UNZ_ERRNO;
	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.compressed_size) &&
							  ((uFlags & 8)==0))
		err=UNZ_BADZIPFILE;

	if (unzlocal_getLong(s->file,&uData) != UNZ_OK) /* size uncompr */
		err=UNZ_ERRNO;
	else if ((err==UNZ_OK) && (uData!=s->cur_file_info.uncompressed_size) && 
							  ((uFlags & 8)==0))
		err=UNZ_BADZIPFILE;


	if (unzlocal_getShort(s->file,&size_filename) != UNZ_OK)
		err=UNZ_ERRNO;
	else if ((err==UNZ_OK) && (size_filename!=s->cur_file_info.size_filename))
		err=UNZ_BADZIPFILE;

	*piSizeVar += (uInt)size_filename;

	if (unzlocal_getShort(s->file,&size_extra_field) != UNZ_OK)
		err=UNZ_ERRNO;
	*poffset_local_extrafield= s->cur_file_info_internal.offset_curfile +
									SIZEZIPLOCALHEADER + size_filename;
	*psize_local_extrafield = (uInt)size_extra_field;

	*piSizeVar += (uInt)size_extra_field;

	return err;
}
												
/*
  Open for reading data the current file in the zipfile.
  If there is no error and the file is opened, the return value is UNZ_OK.
*/
extern int ZEXPORT unzOpenCurrentFile (file)
	unzFile file;
{
	int err=UNZ_OK;
	int Store;
	uInt iSizeVar;
	unz_s* s;
	file_in_zip_read_info_s* pfile_in_zip_read_info;
	uLong offset_local_extrafield;  /* offset of the local extra field */
	uInt  size_local_extrafield;    /* size of the local extra field */

	if (file==NULL)
		return UNZ_PARAMERROR;
	s=(unz_s*)file;
	if (!s->current_file_ok)
		return UNZ_PARAMERROR;

    if (s->pfile_in_zip_read != NULL)
        unzCloseCurrentFile(file);

	if (unzlocal_CheckCurrentFileCoherencyHeader(s,&iSizeVar,
				&offset_local_extrafield,&size_local_extrafield)!=UNZ_OK)
		return UNZ_BADZIPFILE;

	pfile_in_zip_read_info = (file_in_zip_read_info_s*)
									    ALLOC(sizeof(file_in_zip_read_info_s));
	if (pfile_in_zip_read_info==NULL)
		return UNZ_INTERNALERROR;

	pfile_in_zip_read_info->read_buffer=(char*)ALLOC(UNZ_BUFSIZE);
	pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;
	pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;
	pfile_in_zip_read_info->pos_local_extrafield=0;

	if (pfile_in_zip_read_info->read_buffer==NULL)
	{
		TRYFREE(pfile_in_zip_read_info);
		return UNZ_INTERNALERROR;
	}

	pfile_in_zip_read_info->stream_initialised=0;
	
	if ((s->cur_file_info.compression_method!=0) &&
        (s->cur_file_info.compression_method!=Z_DEFLATED))
		err=UNZ_BADZIPFILE;
	Store = s->cur_file_info.compression_method==0;

	pfile_in_zip_read_info->crc32_wait=s->cur_file_info.crc;
	pfile_in_zip_read_info->crc32=0;
	pfile_in_zip_read_info->compression_method =
            s->cur_file_info.compression_method;
	pfile_in_zip_read_info->file=s->file;
	pfile_in_zip_read_info->byte_before_the_zipfile=s->byte_before_the_zipfile;

    pfile_in_zip_read_info->stream.total_out = 0;

	if (!Store)
	{
	  pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
	  pfile_in_zip_read_info->stream.zfree = (free_func)0;
	  pfile_in_zip_read_info->stream.opaque = (voidpf)0; 
      
	  err=inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);
	  if (err == Z_OK)
	    pfile_in_zip_read_info->stream_initialised=1;
        /* windowBits is passed < 0 to tell that there is no zlib header.
         * Note that in this case inflate *requires* an extra "dummy" byte
         * after the compressed stream in order to complete decompression and
         * return Z_STREAM_END. 
         * In unzip, i don't wait absolutely Z_STREAM_END because I known the 
         * size of both compressed and uncompressed data
         */
	}
	pfile_in_zip_read_info->rest_read_compressed = 
            s->cur_file_info.compressed_size ;
	pfile_in_zip_read_info->rest_read_uncompressed = 
            s->cur_file_info.uncompressed_size ;

	
	pfile_in_zip_read_info->pos_in_zipfile = 
            s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER + 
			  iSizeVar;
	
	pfile_in_zip_read_info->stream.avail_in = (uInt)0;


	s->pfile_in_zip_read = pfile_in_zip_read_info;
    return UNZ_OK;
}


/*
  Read bytes from the current file.
  buf contain buffer where data must be copied
  len the size of buf.

  return the number of byte copied if somes bytes are copied
  return 0 if the end of file was reached
  return <0 with error code if there is an error
    (UNZ_ERRNO for IO error, or zLib error for uncompress error)
*/
extern int ZEXPORT unzReadCurrentFile  (file, buf, len)
	unzFile file;
	voidp buf;
	unsigned len;
{
	int err=UNZ_OK;
	uInt iRead = 0;
	unz_s* s;
	file_in_zip_read_info_s* pfile_in_zip_read_info;
	if (file==NULL)
		return UNZ_PARAMERROR;
	s=(unz_s*)file;
    pfile_in_zip_read_info=s->pfile_in_zip_read;

	if (pfile_in_zip_read_info==NULL)
		return UNZ_PARAMERROR;


	if ((pfile_in_zip_read_info->read_buffer == NULL))
		return UNZ_END_OF_LIST_OF_FILE;
	if (len==0)
		return 0;

	pfile_in_zip_read_info->stream.next_out = (Bytef*)buf;

	pfile_in_zip_read_info->stream.avail_out = (uInt)len;
	
	if (len>pfile_in_zip_read_info->rest_read_uncompressed)
		pfile_in_zip_read_info->stream.avail_out = 
		  (uInt)pfile_in_zip_read_info->rest_read_uncompressed;

	while (pfile_in_zip_read_info->stream.avail_out>0)
	{
		if ((pfile_in_zip_read_info->stream.avail_in==0) &&
            (pfile_in_zip_read_info->rest_read_compressed>0))
		{
			uInt uReadThis = UNZ_BUFSIZE;
			if (pfile_in_zip_read_info->rest_read_compressed<uReadThis)
				uReadThis = (uInt)pfile_in_zip_read_info->rest_read_compressed;
			if (uReadThis == 0)
				return UNZ_EOF;
			if (fseek(pfile_in_zip_read_info->file,
                      pfile_in_zip_read_info->pos_in_zipfile + 
                         pfile_in_zip_read_info->byte_before_the_zipfile,SEEK_SET)!=0)
				return UNZ_ERRNO;
			if (fread(pfile_in_zip_read_info->read_buffer,uReadThis,1,
                         pfile_in_zip_read_info->file)!=1)
				return UNZ_ERRNO;
			pfile_in_zip_read_info->pos_in_zipfile += uReadThis;

			pfile_in_zip_read_info->rest_read_compressed-=uReadThis;
			
			pfile_in_zip_read_info->stream.next_in = 
                (Bytef*)pfile_in_zip_read_info->read_buffer;
			pfile_in_zip_read_info->stream.avail_in = (uInt)uReadThis;
		}

		if (pfile_in_zip_read_info->compression_method==0)
		{
			uInt uDoCopy,i ;
			if (pfile_in_zip_read_info->stream.avail_out < 
                            pfile_in_zip_read_info->stream.avail_in)
				uDoCopy = pfile_in_zip_read_info->stream.avail_out ;
			else
				uDoCopy = pfile_in_zip_read_info->stream.avail_in ;
				
			for (i=0;i<uDoCopy;i++)
				*(pfile_in_zip_read_info->stream.next_out+i) =
                        *(pfile_in_zip_read_info->stream.next_in+i);
					
			pfile_in_zip_read_info->crc32 = crc32(pfile_in_zip_read_info->crc32,
								pfile_in_zip_read_info->stream.next_out,
								uDoCopy);
			pfile_in_zip_read_info->rest_read_uncompressed-=uDoCopy;
			pfile_in_zip_read_info->stream.avail_in -= uDoCopy;
			pfile_in_zip_read_info->stream.avail_out -= uDoCopy;
			pfile_in_zip_read_info->stream.next_out += uDoCopy;
			pfile_in_zip_read_info->stream.next_in += uDoCopy;
            pfile_in_zip_read_info->stream.total_out += uDoCopy;
			iRead += uDoCopy;
		}
		else
		{
			uLong uTotalOutBefore,uTotalOutAfter;
			const Bytef *bufBefore;
			uLong uOutThis;
			int flush=Z_SYNC_FLUSH;

			uTotalOutBefore = pfile_in_zip_read_info->stream.total_out;
			bufBefore = pfile_in_zip_read_info->stream.next_out;

			/*
			if ((pfile_in_zip_read_info->rest_read_uncompressed ==
			         pfile_in_zip_read_info->stream.avail_out) &&
				(pfile_in_zip_read_info->rest_read_compressed == 0))
				flush = Z_FINISH;
			*/
			err=inflate(&pfile_in_zip_read_info->stream,flush);

			uTotalOutAfter = pfile_in_zip_read_info->stream.total_out;
			uOutThis = uTotalOutAfter-uTotalOutBefore;
			
			pfile_in_zip_read_info->crc32 = 
                crc32(pfile_in_zip_read_info->crc32,bufBefore,
                        (uInt)(uOutThis));

			pfile_in_zip_read_info->rest_read_uncompressed -=
                uOutThis;

			iRead += (uInt)(uTotalOutAfter - uTotalOutBefore);
            
			if (err==Z_STREAM_END)
				return (iRead==0) ? UNZ_EOF : iRead;
			if (err!=Z_OK) 
				break;
		}
	}

	if (err==Z_OK)
		return iRead;
	return err;
}


/*
  Give the current position in uncompressed data
*/
extern z_off_t ZEXPORT unztell (file)
	unzFile file;
{
	unz_s* s;
	file_in_zip_read_info_s* pfile_in_zip_read_info;
	if (file==NULL)
		return UNZ_PARAMERROR;
	s=(unz_s*)file;
    pfile_in_zip_read_info=s->pfile_in_zip_read;

	if (pfile_in_zip_read_info==NULL)
		return UNZ_PARAMERROR;

	return (z_off_t)pfile_in_zip_read_info->stream.total_out;
}


/*
  return 1 if the end of file was reached, 0 elsewhere 
*/
extern int ZEXPORT unzeof (file)
	unzFile file;
{
	unz_s* s;
	file_in_zip_read_info_s* pfile_in_zip_read_info;
	if (file==NULL)
		return UNZ_PARAMERROR;
	s=(unz_s*)file;
    pfile_in_zip_read_info=s->pfile_in_zip_read;

	if (pfile_in_zip_read_info==NULL)
		return UNZ_PARAMERROR;
	
	if (pfile_in_zip_read_info->rest_read_uncompressed == 0)
		return 1;
	else
		return 0;
}



/*
  Read extra field from the current file (opened by unzOpenCurrentFile)
  This is the local-header version of the extra field (sometimes, there is
    more info in the local-header version than in the central-header)

  if buf==NULL, it return the size of the local extra field that can be read

  if buf!=NULL, len is the size of the buffer, the extra header is copied in
	buf.
  the return value is the number of bytes copied in buf, or (if <0) 
	the error code
*/
extern int ZEXPORT unzGetLocalExtrafield (file,buf,len)
	unzFile file;
	voidp buf;
	unsigned len;
{
	unz_s* s;
	file_in_zip_read_info_s* pfile_in_zip_read_info;
	uInt read_now;
	uLong size_to_read;

	if (file==NULL)
		return UNZ_PARAMERROR;
	s=(unz_s*)file;
    pfile_in_zip_read_info=s->pfile_in_zip_read;

	if (pfile_in_zip_read_info==NULL)
		return UNZ_PARAMERROR;

	size_to_read = (pfile_in_zip_read_info->size_local_extrafield - 
				pfile_in_zip_read_info->pos_local_extrafield);

	if (buf==NULL)
		return (int)size_to_read;
	
	if (len>size_to_read)
		read_now = (uInt)size_to_read;
	else
		read_now = (uInt)len ;

	if (read_now==0)
		return 0;
	
	if (fseek(pfile_in_zip_read_info->file,
              pfile_in_zip_read_info->offset_local_extrafield + 
			  pfile_in_zip_read_info->pos_local_extrafield,SEEK_SET)!=0)
		return UNZ_ERRNO;

	if (fread(buf,(uInt)size_to_read,1,pfile_in_zip_read_info->file)!=1)
		return UNZ_ERRNO;

	return (int)read_now;
}

/*
  Close the file in zip opened with unzipOpenCurrentFile
  Return UNZ_CRCERROR if all the file was read but the CRC is not good
*/
extern int ZEXPORT unzCloseCurrentFile (file)
	unzFile file;
{
	int err=UNZ_OK;

	unz_s* s;
	file_in_zip_read_info_s* pfile_in_zip_read_info;
	if (file==NULL)
		return UNZ_PARAMERROR;
	s=(unz_s*)file;
    pfile_in_zip_read_info=s->pfile_in_zip_read;

	if (pfile_in_zip_read_info==NULL)
		return UNZ_PARAMERROR;


	if (pfile_in_zip_read_info->rest_read_uncompressed == 0)
	{
		if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)
			err=UNZ_CRCERROR;
	}


	TRYFREE(pfile_in_zip_read_info->read_buffer);
	pfile_in_zip_read_info->read_buffer = NULL;
	if (pfile_in_zip_read_info->stream_initialised)
		inflateEnd(&pfile_in_zip_read_info->stream);

	pfile_in_zip_read_info->stream_initialised = 0;
	TRYFREE(pfile_in_zip_read_info);

    s->pfile_in_zip_read=NULL;

	return err;
}


/*
  Get the global comment string of the ZipFile, in the szComment buffer.
  uSizeBuf is the size of the szComment buffer.
  return the number of byte copied or an error code <0
*/
extern int ZEXPORT unzGetGlobalComment (file, szComment, uSizeBuf)
	unzFile file;
	char *szComment;
	uLong uSizeBuf;
{
	int err=UNZ_OK;
	unz_s* s;
	uLong uReadThis ;
	if (file==NULL)
		return UNZ_PARAMERROR;
	s=(unz_s*)file;

	uReadThis = uSizeBuf;
	if (uReadThis>s->gi.size_comment)
		uReadThis = s->gi.size_comment;

	if (fseek(s->file,s->central_pos+22,SEEK_SET)!=0)
		return UNZ_ERRNO;

	if (uReadThis>0)
    {
      *szComment='\0';
	  if (fread(szComment,(uInt)uReadThis,1,s->file)!=1)
		return UNZ_ERRNO;
    }

	if ((szComment != NULL) && (uSizeBuf > s->gi.size_comment))
		*(szComment+s->gi.size_comment)='\0';
	return (int)uReadThis;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\3dsmax3\meshdata.cpp ===
//-----------------------------------------------------------------------------
// File: MeshData.cpp
//
// Desc: Functions used to massage mesh data into a format useable in X Files
//
// Copyright (C) 1998-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "pch.h"
#include "MeshData.h"

BOOL FindIdenticalVertex
    (
    SMeshData *pMeshData, 
    DWORD iVertexIndex, 
    DWORD iSmoothingGroup, 
    DWORD iTextureIndex,
    DWORD iMaterial,
    DWORD *piVertex
    )
{
    DWORD iHeadVertex;
    DWORD iCurVertex;

    // walk the wedge list to see if any of the other vertice have the same smoothing and texture index
    iHeadVertex = iVertexIndex;
    iCurVertex = iHeadVertex;
    do
    {
        // if identical requirements, then return true with the vertex index
        if ((pMeshData->m_rgVertices[iCurVertex].iSmoothingGroupIndex == iSmoothingGroup)
            && (pMeshData->m_rgVertices[iCurVertex].iTextureIndex == iTextureIndex) 
            && (pMeshData->m_rgVertices[iCurVertex].iMaterial == iMaterial) )
        {
            *piVertex = iCurVertex;
            return TRUE;
        }

        // move to next element of wedge list and check to see if we wrapped (circular list)
        iCurVertex = pMeshData->m_rgVertices[iCurVertex].iWedgeList;
    }
    while (iHeadVertex != iCurVertex);

    return FALSE;
}

void AddNormalContribution
    (
    SMeshData *pMeshData,
    DWORD iVertexIndex, 
    DWORD iSmoothingGroup,
    Point3 vNormal 
    )
{
    DWORD iHeadVertex;
    DWORD iCurVertex;

    // walk the wedge list to find other split vertices with the same smoothing group
    iHeadVertex = iVertexIndex;
    iCurVertex = iHeadVertex;
    do
    {
        // if same smoothing group add the normal in
        if (pMeshData->m_rgVertices[iCurVertex].iSmoothingGroupIndex == iSmoothingGroup)    
        {
            pMeshData->m_rgVertices[iCurVertex].vNormal += vNormal;
        }

        // move to next element of wedge list and check to see if we wrapped (circular list)
        iCurVertex = pMeshData->m_rgVertices[iCurVertex].iWedgeList;
    }
    while (iHeadVertex != iCurVertex);

}

HRESULT GenerateMeshData
    (
    Mesh *pMesh,
    SMeshData *pMeshData,
    DWORD *rgdwMeshMaterials
    )
{
    HRESULT hr = S_OK;
    BOOL *rgbVertexReferencedArray = NULL;
    DWORD cVerticesMax;
    DWORD iRawVertexIndex;
    DWORD iTextureIndex;
    DWORD iSmoothingGroupIndex;
    DWORD iVertex;
    DWORD iFace;
    DWORD iPoint;
    DWORD iNewVertex;
    BOOL bFound;
    SVertexData *rgVerticesNew;
    DWORD iMaterial;

    assert(pMesh != NULL);
    assert(pMeshData != NULL);

    pMeshData->m_bTexCoordsPresent = FALSE;
    pMeshData->m_cFaces = pMesh->numFaces;
    pMeshData->m_cVertices = pMesh->numVerts;
    pMeshData->m_cVerticesBeforeDuplication = pMesh->numVerts;
    cVerticesMax = pMesh->numVerts;

    pMeshData->m_rgVertices = new SVertexData[cVerticesMax];
    pMeshData->m_rgFaces = new SFaceData[pMeshData->m_cFaces];
    rgbVertexReferencedArray = new BOOL[pMeshData->m_cVerticesBeforeDuplication];

    if ((pMeshData ->m_rgVertices == NULL) 
            || (pMeshData ->m_rgFaces == NULL)
            || (rgbVertexReferencedArray == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    if( !(pMesh->normalsBuilt) )
    {
        pMesh->checkNormals(TRUE);
    }

    // Initialize vertex node list so that first batch are the same as the
    // vertex array in the mesh.  Duplicated vertices will be appended to the list.
    // The first time a vertex comes up in face enumeration below, the initial vertex
    // node added here will be modified to reflect the smoothing and texture info.
    // When the vertex comes up again with different smoothing or texture info, the
    // vertex will be duplicated and appended to the list.
    for (iVertex = 0; iVertex < pMeshData->m_cVertices; iVertex++ )
    {
        rgbVertexReferencedArray[iVertex] = FALSE;

        pMeshData->m_rgVertices[iVertex].iPointRep = iVertex;
        pMeshData->m_rgVertices[iVertex].iWedgeList = iVertex;

        // default values that should be reset if the vertex is actually used by a face...
        pMeshData->m_rgVertices[iVertex].vNormal.x = 0;
        pMeshData->m_rgVertices[iVertex].vNormal.y = 0;
        pMeshData->m_rgVertices[iVertex].vNormal.z = 0;
        pMeshData->m_rgVertices[iVertex].iSmoothingGroupIndex = 0;
        pMeshData->m_rgVertices[iVertex].iTextureIndex = 0;
        pMeshData->m_rgVertices[iVertex].iMaterial = 0;
    }
    
    // for each face, add the face normal for each corner to the vertex node list array.
    // The index into the vertex node list array is just the vertex index, and a list of CVertexNodes
    // is built for the unique smoothing groups for that vertex.  Each CVertexNode holds the normal
    // at that vertex based on a particular smoothing group.  All CVertexNodes get an index, and
    // the list of CFaceIndices is a face list with the corners updated with the new expanded vertex
    // indices (CVertexNode index).
    //
    // Added: Now CVertexNodes each represent a unique smoothing group + texture coordinate set
    // for a vertex.
    for( iFace = 0; iFace < pMeshData->m_cFaces; iFace++ )
    {
        for( iPoint = 0; iPoint < 3; iPoint++ ) // vertex indices
        {
            iRawVertexIndex = pMesh->faces[iFace].v[iPoint];
            iTextureIndex = 0xFFFFFFFF;
            iSmoothingGroupIndex = pMesh->faces[iFace].smGroup;
            iMaterial = rgdwMeshMaterials[iFace];

            if ((pMesh->faces[iFace].flags & HAS_TVERTS) 
                    && (NULL != pMesh->tvFace)
                    && ((int)pMesh->tvFace[iFace].t[iPoint] < pMesh->numTVerts) )
            {
                pMeshData->m_bTexCoordsPresent = TRUE;

                iTextureIndex = pMesh->tvFace[iFace].t[iPoint];
            }
            
            if (FALSE == rgbVertexReferencedArray[iRawVertexIndex])
            {
                // first reference to this vertex.
                rgbVertexReferencedArray[iRawVertexIndex] = TRUE;

                pMeshData->m_rgVertices[iRawVertexIndex].iSmoothingGroupIndex = iSmoothingGroupIndex;
                pMeshData->m_rgVertices[iRawVertexIndex].iTextureIndex = iTextureIndex;
                pMeshData->m_rgVertices[iRawVertexIndex].iMaterial = iMaterial;

                pMeshData->m_rgFaces[iFace].index[iPoint] = iRawVertexIndex;
            }
            else
            {
                // need to remember the index
                bFound = FindIdenticalVertex(pMeshData, iRawVertexIndex, iSmoothingGroupIndex, iTextureIndex, iMaterial, &iNewVertex);

                // if not found, then split out another vertex
                if (!bFound)
                {
                    // realloc if array too small
                    if (pMeshData->m_cVertices == cVerticesMax)
                    {
                        cVerticesMax = cVerticesMax * 2;
                        rgVerticesNew = new SVertexData[cVerticesMax];
                        if (rgVerticesNew == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto e_Exit;
                        }

                        memcpy(rgVerticesNew, pMeshData->m_rgVertices, sizeof(SVertexData) * pMeshData->m_cVertices);

                        delete []pMeshData->m_rgVertices;
                        pMeshData->m_rgVertices = rgVerticesNew;
                    }

                    // grab the next spot in the array
                    iNewVertex = pMeshData->m_cVertices;
                    pMeshData->m_cVertices += 1;

                    // setup point rep and wedge list
                    pMeshData->m_rgVertices[iNewVertex].iPointRep = iRawVertexIndex;

                    // link into wedge list of point rep
                    pMeshData->m_rgVertices[iNewVertex].iWedgeList = pMeshData->m_rgVertices[iRawVertexIndex].iWedgeList;
                    pMeshData->m_rgVertices[iRawVertexIndex].iWedgeList = iNewVertex;

                    // setup vertex info
                    pMeshData->m_rgVertices[iNewVertex].vNormal.x = 0;
                    pMeshData->m_rgVertices[iNewVertex].vNormal.y = 0;
                    pMeshData->m_rgVertices[iNewVertex].vNormal.z = 0;
                    pMeshData->m_rgVertices[iNewVertex].iSmoothingGroupIndex = iSmoothingGroupIndex;
                    pMeshData->m_rgVertices[iNewVertex].iTextureIndex = iTextureIndex;
                    pMeshData->m_rgVertices[iNewVertex].iMaterial = iMaterial;
                }

                pMeshData->m_rgFaces[iFace].index[iPoint] = iNewVertex;
            }

            // add normal contribution to every vertex with this rawVertexIndex and
            // this smoothinggroup
            AddNormalContribution(pMeshData, iRawVertexIndex, iSmoothingGroupIndex, pMesh->getFaceNormal(iFace));
        }
    }

    for (iVertex = 0; iVertex < pMeshData->m_cVertices; iVertex++)
    {
        pMeshData->m_rgVertices[iVertex].vNormal.Normalize();
    }

e_Exit:
    delete[] rgbVertexReferencedArray;

    return hr;
}



BOOL FindIdenticalPatchVertex
    (
    SPatchMeshData *pPatchMeshData, 
    DWORD iVertexIndex, 
    DWORD iTextureIndex,
    DWORD *piVertex
    )
{
    DWORD iHeadVertex;
    DWORD iCurVertex;

    // walk the wedge list to see if any of the other vertice have the same smoothing and texture index
    iHeadVertex = iVertexIndex;
    iCurVertex = iHeadVertex;
    do
    {
        // if identical requirements, then return true with the vertex index
        if (pPatchMeshData->m_rgVertices[iCurVertex].iTextureIndex == iTextureIndex)
        {
            *piVertex = iCurVertex;
            return TRUE;
        }

        // move to next element of wedge list and check to see if we wrapped (circular list)
        iCurVertex = pPatchMeshData->m_rgVertices[iCurVertex].iWedgeList;
    }
    while (iHeadVertex != iCurVertex);

    return FALSE;
}

HRESULT GeneratePatchMeshData
    (
    PatchMesh *pPatchMesh,
    SPatchMeshData *pPatchMeshData 
    )
{
    HRESULT hr = S_OK;
    BYTE *rgbVertexReferencedArray = NULL;
    DWORD cVerticesMax;
    DWORD iRawVertexIndex;
    DWORD iTextureIndex;
    DWORD iVertex;
    DWORD iPoint;
    DWORD iNewVertex;
    BOOL bFound;
    SPatchVertexData *rgVerticesNew;
	DWORD iCurVertex;
	DWORD iPatch;
	DWORD cPoints;
	PatchVec *pvPatchVecs;
    Patch *pPatch;
	DWORD *rgdwControl;

    assert(pPatchMesh != NULL);
    assert(pPatchMeshData != NULL);

    pPatchMeshData->m_bTexCoordsPresent = FALSE;
    pPatchMeshData->m_cPatches = pPatchMesh->numPatches;

	// UNDONE - need to refine
    cVerticesMax = pPatchMeshData->m_cPatches * 16;

    pPatchMeshData->m_rgVertices = new SPatchVertexData[cVerticesMax];
    pPatchMeshData->m_rgPatches = new SPatchData[pPatchMesh->numPatches];

    if ((pPatchMeshData->m_rgVertices == NULL) 
            || (pPatchMeshData->m_rgPatches == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

	// initialize the verts being copied from the pPatchMesh->verts array
	for (iVertex = 0; iVertex < pPatchMesh->numVerts; iVertex++)
	{
        pPatchMeshData->m_rgVertices[iVertex].vPosition = pPatchMesh->verts[iVertex].p;

		pPatchMeshData->m_rgVertices[iVertex].iPointRep = iVertex;
		pPatchMeshData->m_rgVertices[iVertex].iWedgeList = iVertex;

        pPatchMeshData->m_rgVertices[iVertex].iTextureIndex = 0;
	}

	// for the rest of vers, init the non position fields, position filled in when
	//   reading patches
	iCurVertex = pPatchMesh->numVerts;
	for (iVertex = iCurVertex; iVertex < cVerticesMax; iVertex++)
	{
		pPatchMeshData->m_rgVertices[iVertex].iPointRep = iVertex;
		pPatchMeshData->m_rgVertices[iVertex].iWedgeList = iVertex;

        pPatchMeshData->m_rgVertices[iVertex].iTextureIndex = 0;
	}


    pvPatchVecs = pPatchMesh->vecs;
    for (iPatch = 0; iPatch < pPatchMesh->numPatches; iPatch++)
    {
        pPatch = &pPatchMesh->patches[iPatch];

        if (pPatch->type == PATCH_TRI)
        {
            // nControlIndices
            pPatchMeshData->m_rgPatches[iPatch].m_cControl = 10;

            rgdwControl = pPatchMeshData->m_rgPatches[iPatch].m_rgdwControl;
            rgdwControl[0] = pPatch->v[0];
            rgdwControl[3] = pPatch->v[1];
            rgdwControl[6] = pPatch->v[2];

            rgdwControl[1] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[0]].p;
            iCurVertex += 1;
        
            rgdwControl[2] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[1]].p;
            iCurVertex += 1;
        
            rgdwControl[4] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[2]].p;
            iCurVertex += 1;
        
            rgdwControl[5] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[3]].p;
            iCurVertex += 1;
        
            rgdwControl[7] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[4]].p;
            iCurVertex += 1;
        
            rgdwControl[8] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[5]].p;
            iCurVertex += 1;
        
            // UNDONE - is the correct way to get a single interior control
            //  point from 3ds max
            rgdwControl[9] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->interior[0]].p;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition += pvPatchVecs[pPatch->interior[1]].p;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition += pvPatchVecs[pPatch->interior[2]].p;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition /= 3;
            iCurVertex += 1;
        }
        else if (pPatch->type == PATCH_QUAD)
        {
            // nControlIndices
            pPatchMeshData->m_rgPatches[iPatch].m_cControl = 16;

            rgdwControl = pPatchMeshData->m_rgPatches[iPatch].m_rgdwControl;
            rgdwControl[0] = pPatch->v[0];
            rgdwControl[3] = pPatch->v[1];
            rgdwControl[6] = pPatch->v[2];
            rgdwControl[9] = pPatch->v[3];

            rgdwControl[1] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[0]].p;
            iCurVertex += 1;
        
            rgdwControl[2] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[1]].p;
            iCurVertex += 1;
        
            rgdwControl[4] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[2]].p;
            iCurVertex += 1;
        
            rgdwControl[5] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[3]].p;
            iCurVertex += 1;
        
            rgdwControl[7] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[4]].p;
            iCurVertex += 1;
        
            rgdwControl[8] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[5]].p;
            iCurVertex += 1;
        
            rgdwControl[10] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[6]].p;
            iCurVertex += 1;

            rgdwControl[11] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->vec[7]].p;
            iCurVertex += 1;

            rgdwControl[12] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->interior[0]].p;
            iCurVertex += 1;

            rgdwControl[13] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->interior[1]].p;
            iCurVertex += 1;

            rgdwControl[14] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->interior[2]].p;
            iCurVertex += 1;

            rgdwControl[15] = iCurVertex;
            pPatchMeshData->m_rgVertices[iCurVertex].vPosition = pvPatchVecs[pPatch->interior[3]].p;
            iCurVertex += 1;
        }
        else // undefined patch type
        {
            hr = E_INVALIDARG;
            goto e_Exit;
        }
    }

	// now record the initial number of vertices
	pPatchMeshData->m_cVerticesBeforeDuplication = iCurVertex;
	pPatchMeshData->m_cVertices = iCurVertex;

    rgbVertexReferencedArray = new BYTE[pPatchMeshData->m_cVertices];
	if (rgbVertexReferencedArray == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto e_Exit;
	}
	memset(rgbVertexReferencedArray, 0, sizeof(BYTE) * pPatchMeshData->m_cVertices);

    for( iPatch = 0; iPatch < pPatchMeshData->m_cPatches; iPatch++ )
    {
		cPoints = (pPatchMeshData->m_rgPatches[iPatch].m_cControl == 10) ? 3 : 4;
        for( iPoint = 0; iPoint < cPoints; iPoint++ ) 
		{
            iTextureIndex = 0xFFFFFFFF;
			iRawVertexIndex = pPatchMeshData->m_rgPatches[iPatch].m_rgdwControl[iPoint * 3];

			// try to get a texture index
            if ((pPatchMesh->tvPatches.Count() >= 2) && (pPatchMesh->tvPatches[1] != NULL))
			{
				iTextureIndex = pPatchMesh->tvPatches[1][iPatch].tv[iPoint];
				if (iTextureIndex < pPatchMesh->numTVerts[1])
				{
	                pPatchMeshData->m_bTexCoordsPresent = TRUE;
				}
				else
				{
					iTextureIndex = 0xFFFFFFFF;
				}
			}

            if (rgbVertexReferencedArray[iRawVertexIndex] == FALSE)
            {
                // first reference to this vertex.
                rgbVertexReferencedArray[iRawVertexIndex] = TRUE;

                pPatchMeshData->m_rgVertices[iRawVertexIndex].iTextureIndex = iTextureIndex;
            }
            else
            {
                // need to remember the index
                bFound = FindIdenticalPatchVertex(pPatchMeshData, iRawVertexIndex, iTextureIndex, &iNewVertex);

                // if not found, then split out another vertex
                if (!bFound)
                {
                    // realloc if array too small
                    if (pPatchMeshData->m_cVertices == cVerticesMax)
                    {
                        cVerticesMax = cVerticesMax * 2;
                        rgVerticesNew = new SPatchVertexData[cVerticesMax];
                        if (rgVerticesNew == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto e_Exit;
                        }

                        memcpy(rgVerticesNew, pPatchMeshData->m_rgVertices, sizeof(SPatchVertexData) * pPatchMeshData->m_cVertices);

                        delete []pPatchMeshData->m_rgVertices;
                        pPatchMeshData->m_rgVertices = rgVerticesNew;
                    }

                    // grab the next spot in the array
                    iNewVertex = pPatchMeshData->m_cVertices;
                    pPatchMeshData->m_cVertices += 1;

                    // setup point rep and wedge list
                    pPatchMeshData->m_rgVertices[iNewVertex].iPointRep = iRawVertexIndex;

                    // link into wedge list of point rep
                    pPatchMeshData->m_rgVertices[iNewVertex].iWedgeList = pPatchMeshData->m_rgVertices[iRawVertexIndex].iWedgeList;
                    pPatchMeshData->m_rgVertices[iRawVertexIndex].iWedgeList = iNewVertex;

                    // setup vertex info
                    pPatchMeshData->m_rgVertices[iNewVertex].vPosition = pPatchMeshData->m_rgVertices[iRawVertexIndex].vPosition;
                    pPatchMeshData->m_rgVertices[iNewVertex].iTextureIndex = iTextureIndex;
                }

				// update the control point to the new vertex position
                pPatchMeshData->m_rgPatches[iPatch].m_rgdwControl[iPoint * 3] = iNewVertex;
            }
		}

	}

e_Exit:
	delete []rgbVertexReferencedArray;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\3dsmax3\dllentry.cpp ===
//-----------------------------------------------------------------------------
// File: DllEntry.cpp
//
// Desc: Contains the Dll Entry stuff
//
// Copyright (C) 1998-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "pch.h"
#include "xskinexp.h"

extern ClassDesc* GetXSkinExpDesc();

HINSTANCE g_hInstance;
int controlsInit = FALSE;

// This function is called by Windows when the DLL is loaded.  This 
// function may also be called many times during time critical operations
// like rendering.  Therefore developers need to be careful what they
// do inside this function.  In the code below, note how after the DLL is
// loaded the first time only a few statements are executed.

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved)
{
    g_hInstance = hinstDLL;                // Hang on to this DLL's instance handle.

    if (!controlsInit) {
        controlsInit = TRUE;
        InitCustomControls(g_hInstance);    // Initialize MAX's custom controls
        InitCommonControls();            // Initialize Win95 controls
    }
            
    return (TRUE);
}

// This function returns a string that describes the DLL and where the user
// could purchase the DLL if they don't have it.
__declspec( dllexport ) const TCHAR* LibDescription()
{
    return GetString(IDS_LIBDESCRIPTION);
}

// This function returns the number of plug-in classes this DLL
//TODO: Must change this number when adding a new class
__declspec( dllexport ) int LibNumberClasses()
{
    return 1;
}

// This function returns the number of plug-in classes this DLL
__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
    switch(i) {
        case 0: return GetXSkinExpDesc();
        default: return 0;
    }
}

// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG LibVersion()
{
    return VERSION_3DSMAX;
}

TCHAR *GetString(int id)
{
    static TCHAR buf[256];

    if (g_hInstance)
        return LoadString(g_hInstance, id, buf, sizeof(buf)) ? buf : NULL;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\3dsmax3\pch.h ===
//-----------------------------------------------------------------------------
// File: Pch.h
//
// Desc: Header file to precompile
//
// Copyright (C) 1998-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef __PCH__H
#define __PCH__H

#include "Max.h"
#include "resource.h"
#include "istdplug.h"
#include "iparamb2.h"
#include "iparamm2.h"
#include <assert.h>
#include <io.h>
#include <fcntl.h>
#include <direct.h>
#include <commdlg.h>
#include "phyexp.h"
#include "d3dx8.h"
#include "stdmat.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\3dsmax3\ExportXFile.cpp ===
//-----------------------------------------------------------------------------
// File: ExportXFile.cpp
//
// Desc: Functions used to export max data to an X File
//
// Copyright (C) 1998-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "pch.h"
#include "XSkinExp.h"
#include "MeshData.h"

#include <initguid.h>

#include "XSkinExpTemplates.h"
#include "dxfile.h"
#include "rmxfguid.h"
#include "rmxftmpl.h"

#define POWER_DEFAULT   0.0

struct SDialogOptions
{
    BOOL                        m_bProceedWithExport;
    DXFILEFORMAT                m_xFormat;
    DWORD                       m_cMaxBonesPerVertex;
    DWORD                       m_cMaxBonesPerFace;

    BOOL                        m_bSavePatchData;
    BOOL                        m_bSaveAnimationData;
    DWORD                       m_iAnimSamplingRate;
};

struct SBoneInfo
{
    INode                       *m_pBoneNode;
    DWORD                       m_cVertices;
};

// structure used to map an mesh to a bone info structure
struct SSkinMap
{
    SSkinMap()
        :m_pMeshNode(NULL), m_rgbiBones(NULL), m_cbiBones(0), m_cbiBonesMax(0) {}
    ~SSkinMap()
        { delete []m_rgbiBones; }

    INode                       *m_pMeshNode;

    SBoneInfo                   *m_rgbiBones;
    DWORD                       m_cbiBones;
    DWORD                       m_cbiBonesMax;

    SBoneInfo *FindBone(INode *pBoneNode)
    {
        SBoneInfo *pbi = NULL;
        DWORD iBone;

        for (iBone = 0; iBone < m_cbiBones; iBone++)
        {
            if (pBoneNode == m_rgbiBones[iBone].m_pBoneNode)
            {
                pbi = &m_rgbiBones[iBone];
                break;
            }
        }

        return pbi;
    }

    HRESULT AddBone(INode *pBoneNode, SBoneInfo **ppbiBoneInfo)
    {
        HRESULT hr = S_OK;
        SBoneInfo *rgbiTemp;

        // reallocate if neccessary
        if (m_cbiBones == m_cbiBonesMax)
        {
            m_cbiBonesMax = max(1, m_cbiBonesMax);
            m_cbiBonesMax *= 2;

            rgbiTemp = m_rgbiBones;
            m_rgbiBones = new SBoneInfo[m_cbiBonesMax];
            if (m_rgbiBones == NULL)
            {
                m_rgbiBones = rgbiTemp;
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }

            if (m_cbiBones > 0)
            {
                memcpy(m_rgbiBones, rgbiTemp, m_cbiBones * sizeof(SBoneInfo));
            }

            delete []rgbiTemp;
        }

        // not initialize the next bone in the array and return a pointer to it

        m_rgbiBones[m_cbiBones].m_cVertices = 0;
        m_rgbiBones[m_cbiBones].m_pBoneNode = pBoneNode;

        *ppbiBoneInfo = &m_rgbiBones[m_cbiBones];

        m_cbiBones += 1;

e_Exit:
        return hr;
    }
};

struct SPreprocessContext
{
    SPreprocessContext()
        :m_rgpsmSkinMaps(NULL), 
		 m_cpsmSkinMaps(NULL), 
		 m_cpsmSkinMapsMax(0), 
		 m_cMaxWeightsPerVertex(0), 
		 m_cMaxWeightsPerFace(0),
         m_cNodes(0) {}

    ~SPreprocessContext()
        { delete []m_rgpsmSkinMaps; }

    BOOL                        m_bSaveSelection;

    SSkinMap                    **m_rgpsmSkinMaps;
    DWORD                       m_cpsmSkinMaps;
    DWORD                       m_cpsmSkinMapsMax;

    DWORD                       m_cMaxWeightsPerVertex;
    DWORD                       m_cMaxWeightsPerFace;

    DWORD                       m_cNodes;
};

const int x_cbStringBufferMax = 4088;

struct SStringBlock
{
	SStringBlock()
		:m_psbNext(NULL), m_cbData(0) {}
	~SStringBlock()
	{
		delete m_psbNext;
	}

	SStringBlock				*m_psbNext;
	DWORD						m_cbData;

	TCHAR						szData[x_cbStringBufferMax];
};

class CStringTable
{
public:
	CStringTable()
		:m_psbHead(NULL) {}

	~CStringTable()
	{
		delete m_psbHead;
	}

	// allocate a string out of the data blocks to be free'd later, and make it a valid
	//   x-file name at the same time
	TCHAR *CreateNiceString(TCHAR *szString)
    {
        TCHAR* szNewString = NULL;
		BOOL bFirstCharIsDigit;
		DWORD cbLength;
		SStringBlock *psbNew;

        if (szString == NULL)
            return NULL;

        cbLength = _tcslen(szString) + 1;

        bFirstCharIsDigit = _istdigit(*szString);
        if (bFirstCharIsDigit)
        {
            cbLength += 1;
        }

		// if no string blocks or the current doesn't have enough space, then allocate one
		if ((m_psbHead == NULL) || ((x_cbStringBufferMax - m_psbHead->m_cbData) < cbLength))
		{
			psbNew = new SStringBlock();
			if (psbNew == NULL)
				return NULL;

			psbNew->m_psbNext = m_psbHead;
			m_psbHead = psbNew;
		}

		// allocate a string out of the data block
        szNewString = m_psbHead->szData + m_psbHead->m_cbData;
		m_psbHead->m_cbData += cbLength;

		// deal with the fact that the string can't start with digits
        *szNewString = _T('\0');
        if( bFirstCharIsDigit ) 
        {
            _tcscat(szNewString, _T("_"));
        }

        _tcscat(szNewString, szString);

        TCHAR* pchCur = szNewString;
        while( NULL != *pchCur )
        {
            if( *pchCur != _T('_') && !_istalnum(*pchCur) )
            {
                *pchCur = _T('_');
            }
            pchCur++;
        }
        return szNewString;
    }

	// Allocate a new string with '\\' in place of '\' characters
	TCHAR* CreateNiceFilename(TCHAR *szString)
	{
		TCHAR* szNewString = NULL;
		DWORD cbNameLength;
		DWORD cbLength;
		TCHAR* pchCur;
		TCHAR* pchOrig;
		SStringBlock *psbNew;

		if( NULL == szString )
		{
			return NULL;
		}

		cbNameLength = _tcslen(szString);
		cbLength = cbNameLength*2 + 1;


		// if no string blocks or the current doesn't have enough space, then allocate one
		if ((m_psbHead == NULL) || ((x_cbStringBufferMax - m_psbHead->m_cbData) < cbLength))
		{
			psbNew = new SStringBlock();
			if (psbNew == NULL)
				return NULL;

			psbNew->m_psbNext = m_psbHead;
			m_psbHead = psbNew;
		}

		// allocate a string out of the data block
        szNewString = m_psbHead->szData + m_psbHead->m_cbData;
		m_psbHead->m_cbData += cbLength;

		pchCur = szNewString;
		pchOrig = szString;
		while (NULL != *pchOrig)
		{
			if( _T('\\') == *pchOrig )
			{
				*(pchCur++) = _T('\\');
				*(pchCur++) = _T('\\');
			}
			else
			{
				*(pchCur++) = *pchOrig;
			}
			pchOrig++;
		}
		*pchCur = _T('\0');

		return szNewString;
	}

	// Allocate a new string without fiddling with the '\' characters
	TCHAR* CreateNormalFilename(TCHAR *szString)
	{
		TCHAR* szNewString = NULL;
		DWORD cbNameLength;
		DWORD cbLength;
		SStringBlock *psbNew;

		if( NULL == szString )
		{
			return NULL;
		}

		cbNameLength = _tcslen(szString);
		cbLength = cbNameLength + 1;


		// if no string blocks or the current doesn't have enough space, then allocate one
		if ((m_psbHead == NULL) || ((x_cbStringBufferMax - m_psbHead->m_cbData) < cbLength))
		{
			psbNew = new SStringBlock();
			if (psbNew == NULL)
				return NULL;

			psbNew->m_psbNext = m_psbHead;
			m_psbHead = psbNew;
		}

		// allocate a string out of the data block
        szNewString = m_psbHead->szData + m_psbHead->m_cbData;
		m_psbHead->m_cbData += cbLength;

        memcpy(szNewString, szString, cbLength);

		return szNewString;
	}
private:
	SStringBlock *m_psbHead;
};

struct SSaveContext
{
    SSaveContext()
        :m_rgpsmSkinMaps(NULL), m_pAnimationSet(NULL) {}

    ~SSaveContext()
        { delete []m_rgpsmSkinMaps; }

    LPDIRECTXFILESAVEOBJECT     m_pxofsave;
    DXFILEFORMAT                m_xFormat;
    DWORD                       m_iTime;
    BOOL                        m_bSaveSelection;
    BOOL                        m_bSavePatchData;
    BOOL                        m_bSaveAnimationData;
    DWORD                       m_iAnimSamplingRate;
    DWORD                       m_cMaxWeightsPerVertex;
    DWORD                       m_cMaxWeightsPerFace;

    SSkinMap                    **m_rgpsmSkinMaps;
    DWORD                       m_cpsmSkinMaps;

    LPDIRECTXFILEDATA           m_pAnimationSet;
    Interface                   *m_pInterface;

    DWORD                       m_cNodes;
    DWORD                       m_cNodesCur;
    INode                       **m_rgpnNodes;

	CStringTable				m_stStrings;

    SSkinMap *GetSkinMap(INode *pMeshNode)
    {
        SSkinMap *psm = NULL;
        DWORD iMesh;

        for (iMesh = 0; iMesh < m_cpsmSkinMaps; iMesh++)
        {
            if (pMeshNode == m_rgpsmSkinMaps[iMesh]->m_pMeshNode)
            {
                psm = m_rgpsmSkinMaps[iMesh];
                break;
            }
        }

        return psm;
    }

};


// Macros for saving data to memory at DWORD* pbCur (this pointer is incremented)
#define WRITE_PTCHAR(pbCur, ptchar) {TCHAR** __pptchar = (TCHAR**)pbCur; *(__pptchar++) = ptchar;\
                             pbCur = (PBYTE)__pptchar;}

#define WRITE_STRING(pbCur, pstring) {TCHAR* __pCurrDestChar = (TCHAR*)pbCur; TCHAR* __pCurrOrgChar = pstring;\
                                while(NULL != *__pCurrOrgChar) { *(__pCurrDestChar++) = *(__pCurrOrgChar++); }\
                                *(__pCurrDestChar++) = _T('\0'); pbCur = __pCurrDestChar;}\

#define WRITE_WORD(pbCur, word) {WORD* __pword = (WORD*)pbCur; *(__pword++) = word;\
                             pbCur = (PBYTE)__pword;}

#define WRITE_DWORD(pbCur, dword) {DWORD* __pdword = (DWORD*)pbCur; *(__pdword++) = dword;\
                             pbCur = (PBYTE)__pdword;}

#define WRITE_FLOAT(pbCur, _float) {float* __pfloat = (float*)pbCur; *(__pfloat++) = _float;\
                             pbCur = (PBYTE)__pfloat;}

#define WRITE_POINT3(pbCur, _point3) {Point3 _temp = (Point3)_point3; float __tempVal;\
                               __tempVal = _temp[0]; WRITE_FLOAT(pbCur, __tempVal);\
                               __tempVal = _temp[1]; WRITE_FLOAT(pbCur, __tempVal);\
                               __tempVal = _temp[2]; WRITE_FLOAT(pbCur, __tempVal);}

#define WRITE_COLOR(pbCur, _color) {D3DXCOLOR _temp = (D3DXCOLOR)_color; float __tempVal;\
                               __tempVal = _temp.r; WRITE_FLOAT(pbCur, __tempVal);\
                               __tempVal = _temp.g; WRITE_FLOAT(pbCur, __tempVal);\
                               __tempVal = _temp.b; WRITE_FLOAT(pbCur, __tempVal);\
                               __tempVal = _temp.a; WRITE_FLOAT(pbCur, __tempVal);}

#define WRITE_MATRIX4_FROM_MATRIX3(pbCur, _matrix3) {Point3 __tempRow = ((Matrix3)_matrix3).GetRow(0);\
                                WRITE_POINT3(pbCur, __tempRow); WRITE_FLOAT(pbCur, 0);\
                                __tempRow = _matrix3.GetRow(1); WRITE_POINT3(pbCur, __tempRow); WRITE_FLOAT(pbCur, 0);\
                                __tempRow = _matrix3.GetRow(2); WRITE_POINT3(pbCur, __tempRow); WRITE_FLOAT(pbCur, 0);\
                                __tempRow = _matrix3.GetRow(3); WRITE_POINT3(pbCur, __tempRow); WRITE_FLOAT(pbCur, 1);}

#define WRITE_MATRIX(pbCur, mat) { *(D3DXMATRIX*)pbCur = mat;\
                               pbCur = (PBYTE)pbCur + sizeof(D3DXMATRIX);}

const GUID* aIds[] = {&DXFILEOBJ_XSkinMeshHeader,
                &DXFILEOBJ_VertexDuplicationIndices,
                &DXFILEOBJ_SkinWeights};




BOOL CALLBACK XSkinExpOptionsDlgProc
    (
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    ) 
{
    static SDialogOptions *pDialogOptions = NULL;
    TCHAR buff[8];

    switch(message) 
    {
        case WM_INITDIALOG:
            pDialogOptions = (SDialogOptions *)lParam;

            CenterWindow(hWnd,GetParent(hWnd));

            CheckDlgButton(hWnd, IDC_ANIMATION, 
                    pDialogOptions->m_bSaveAnimationData ? BST_CHECKED : BST_UNCHECKED);

            CheckDlgButton(hWnd, IDC_PATCHDATA, 
                    pDialogOptions->m_bSavePatchData ? BST_CHECKED : BST_UNCHECKED);

            if (pDialogOptions == NULL)
                return FALSE;

            switch (pDialogOptions->m_xFormat)
            {
                case DXFILEFORMAT_BINARY:
                    CheckRadioButton(hWnd,IDC_TEXT,IDC_BINARYCOMPRESSED,IDC_BINARY);
                    break;

                case DXFILEFORMAT_TEXT:
                    CheckRadioButton(hWnd,IDC_TEXT,IDC_BINARYCOMPRESSED,IDC_TEXT);
                    break;

                case DXFILEFORMAT_BINARY | DXFILEFORMAT_COMPRESSED:
                    CheckRadioButton(hWnd,IDC_TEXT,IDC_BINARYCOMPRESSED,IDC_BINARYCOMPRESSED);
                    break;
            }

            _stprintf(buff,_T("%d"),pDialogOptions->m_cMaxBonesPerVertex);
            SetDlgItemText(hWnd,IDC_MAX_BONES_PER_VERTEX,buff);

            _stprintf(buff,_T("%d"),pDialogOptions->m_cMaxBonesPerFace);
            SetDlgItemText(hWnd,IDC_MAX_BONES_PER_FACE,buff);

            _stprintf(buff,_T("%d"),pDialogOptions->m_iAnimSamplingRate);
            SetDlgItemText(hWnd,IDC_SAMPLERATE,buff);

            return TRUE;

        case WM_CLOSE:
            pDialogOptions->m_bProceedWithExport = FALSE;

            EndDialog(hWnd, 0);
            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
            case IDC_GO:
                pDialogOptions->m_bProceedWithExport = TRUE;

                EndDialog(hWnd,0);
                break;

            case IDC_CANCEL:
                pDialogOptions->m_bProceedWithExport = FALSE;

                EndDialog(hWnd,0);
                break;

            case IDC_TEXT:
                pDialogOptions->m_xFormat = DXFILEFORMAT_TEXT;
                break;

            case IDC_BINARY:
                pDialogOptions->m_xFormat = DXFILEFORMAT_BINARY;
                break;

            case IDC_BINARYCOMPRESSED:
                pDialogOptions->m_xFormat = DXFILEFORMAT_BINARY | DXFILEFORMAT_COMPRESSED;
                break;

            case IDC_ANIMATION:
                pDialogOptions->m_bSaveAnimationData = !pDialogOptions->m_bSaveAnimationData;
                break;

            case IDC_PATCHDATA:
                pDialogOptions->m_bSavePatchData = !pDialogOptions->m_bSavePatchData;
                break;

            case IDC_SAMPLERATE:
                GetDlgItemText(hWnd,IDC_SAMPLERATE,buff,sizeof(buff) / sizeof(TCHAR));

                pDialogOptions->m_iAnimSamplingRate = _ttoi(buff);
                break;

            default:
                break;
            }
    }
    return FALSE;
}

// ================================================== FindPhysiqueModifier()
// Find if a given node contains a Physique Modifier
// DerivedObjectPtr requires you include "modstack.h" from the MAX SDK
Modifier* FindPhysiqueModifier (INode* nodePtr)
{
    // Get object from node. Abort if no object.
    Object* ObjectPtr = nodePtr->GetObjectRef();
    

    if ( NULL == ObjectPtr)
    {
        return NULL;
    }

    // Is derived object ?
    if (ObjectPtr->SuperClassID() == GEN_DERIVOB_CLASS_ID)
    {
        // Yes -> Cast.
        IDerivedObject* DerivedObjectPtr = static_cast<IDerivedObject*>(ObjectPtr);

        // Iterate over all entries of the modifier stack.
        int ModStackIndex = 0;
        while (ModStackIndex < DerivedObjectPtr->NumModifiers())
        {
            // Get current modifier.
            Modifier* ModifierPtr = DerivedObjectPtr->GetModifier(ModStackIndex);
            Class_ID clsid = ModifierPtr->ClassID();
            // Is this Physique ?
            if (ModifierPtr->ClassID() == Class_ID(PHYSIQUE_CLASS_ID_A, PHYSIQUE_CLASS_ID_B))
            {
                // Yes -> Exit.
                return ModifierPtr;
            }

            // Next modifier stack entry.
            ModStackIndex++;
        }
    }

    // Not found.
    return NULL;
}

// ================================================== GetTriObjectFromObjRef
// Return a pointer to a TriObject given an object reference or return NULL
// if the node cannot be converted to a TriObject
TriObject *GetTriObjectFromObjRef
	(
	Object* pObj, 
	BOOL *pbDeleteIt
	) 
{
	TriObject *pTri;

	assert(pObj != NULL);
	assert(pbDeleteIt != NULL);

    *pbDeleteIt = FALSE;

    if (pObj->CanConvertToType(Class_ID(TRIOBJ_CLASS_ID, 0))) 
	{ 
        pTri = (TriObject *) pObj->ConvertToType(0, Class_ID(TRIOBJ_CLASS_ID, 0));

        // Note that the TriObject should only be deleted
        // if the pointer to it is not equal to the object
        // pointer that called ConvertToType()
        if (pObj != pTri) 
			*pbDeleteIt = TRUE;

        return pTri;
    } 
	else 
	{
        return NULL;
    }
}

// ================================================== GetTriObjectFromObjRef
// Return a pointer to a TriObject given an object reference or return NULL
// if the node cannot be converted to a TriObject
PatchObject *GetPatchObjectFromObjRef
	(
	Object* pObj, 
	BOOL *pbDeleteIt
	) 
{
	PatchObject *pPatchObject;

	assert(pObj != NULL);
	assert(pbDeleteIt != NULL);

    *pbDeleteIt = FALSE;

    if (pObj->CanConvertToType(Class_ID(PATCHOBJ_CLASS_ID, 0))) 
	{ 
        pPatchObject = (PatchObject *) pObj->ConvertToType(0, Class_ID(PATCHOBJ_CLASS_ID, 0));

        // Note that the PatchObject should only be deleted
        // if the pointer to it is not equal to the object
        // pointer that called ConvertToType()
        if (pObj != pPatchObject) 
			*pbDeleteIt = TRUE;

        return pPatchObject;
    } 
	else 
	{
        return NULL;
    }
}

// ================================================== IsExportableMesh()
BOOL IsExportableMesh(INode* pNode, Object* &pObj)
{
    ULONG superClassID;

    assert(pNode);
    pObj = pNode->GetObjectRef();

    if (pObj == NULL)
    {
        return FALSE;
    }

    superClassID = pObj->SuperClassID();
    //find out if mesh is renderable

    if( !pNode->Renderable() || pNode->IsNodeHidden())
    {
        return FALSE;
    }

    BOOL bFoundGeomObject = FALSE;
    //find out if mesh is renderable (more)
    switch(superClassID)
    {
    case GEN_DERIVOB_CLASS_ID:

        do
        {
            pObj = ((IDerivedObject*)pObj)->GetObjRef();
            superClassID = pObj->SuperClassID();
        }
        while( superClassID == GEN_DERIVOB_CLASS_ID );

        switch(superClassID)
        {
        case GEOMOBJECT_CLASS_ID:
            bFoundGeomObject = TRUE;
            break;
        }
        break;

    case GEOMOBJECT_CLASS_ID:
        bFoundGeomObject = TRUE;

    default:
        break;
    }

    return bFoundGeomObject;
}

// ================================================== IsExportablePatchMesh()
BOOL IsExportablePatchMesh(INode* pNode, Object* &pObj)
{
    ULONG superClassID;
	Object *pObjBase;

    assert(pNode != NULL);

    pObj = pNode->GetObjectRef();
    if (pObj == NULL)
        return FALSE;

    if( !pNode->Renderable() || pNode->IsNodeHidden())
        return FALSE;


	pObjBase = pObj;

    superClassID = pObjBase->SuperClassID();
    switch(superClassID)
    {
    case GEN_DERIVOB_CLASS_ID:

        do
        {
            pObjBase = ((IDerivedObject*)pObjBase)->GetObjRef();
            superClassID = pObjBase->SuperClassID();
        }
        while( superClassID == GEN_DERIVOB_CLASS_ID );

        switch(superClassID)
        {
        case GEOMOBJECT_CLASS_ID:
            break;
        }
        break;

    case GEOMOBJECT_CLASS_ID:
		break;

    default:
        break;
    }

	pObj = pObjBase;

	// if the base object is a patch based object
	if ((pObjBase->ClassID() == Class_ID(PATCHOBJ_CLASS_ID, 0))
		|| (pObjBase->ClassID() == Class_ID(PATCHGRID_CLASS_ID, 0)))
	{
		// then check to make sure that the intervening steps don't disallow
		//   a patch object to be converted to
		return pObjBase->CanConvertToType(Class_ID(PATCHOBJ_CLASS_ID, 0));
	}
	else
		return FALSE;
}

// ================================================== dummyFn()
// used by 3DS progress bar
DWORD WINAPI dummyFn(LPVOID arg)
{
    return(0);
}

// -------------------------------------------------------------------------------
//   class      CFindRootNode
//
//   devnote    Helper class for FindRootNode, used to implement callback function
//                  for scene traversal.  Finds the root node by aborting the search
//                  after the first node is returned.  It takes the first node and
//                  walks to the root from there.
//
class CFindRootNode : public ITreeEnumProc
{
public:
    CFindRootNode()
        :m_pNodeRoot(NULL) {}

    virtual int callback(INode *pNode)
    {
        INode *pNodeCur = pNode;

        while (!pNodeCur->IsRootNode())
        {
            pNodeCur = pNodeCur->GetParentNode();
        }
        m_pNodeRoot = pNodeCur;

        return TREE_ABORT;
    }

    INode *m_pNodeRoot;
};

// -------------------------------------------------------------------------------
//  function    FindRootNode
//
//   devnote    Finds the root node of the scene by aborting a tree walk after the first node
//
//   returns    S_OK if a node is found, E_FAIL if not
//
HRESULT FindRootNode
    (
    IScene *pScene, 
    INode **ppNode
    )
{
    CFindRootNode RootNode;

    // grab the first node of the scene graph
    pScene->EnumTree(&RootNode);

    *ppNode = RootNode.m_pNodeRoot;

    return RootNode.m_pNodeRoot != NULL ? S_OK : E_FAIL;
}

HRESULT AddNormals
    (
    SSaveContext *psc,
    SMeshData *pMeshData, 
    BOOL bSwapTriOrder,
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT hr = S_OK;
    LPDIRECTXFILEDATA pDataObject = NULL;
    PBYTE         pbData = NULL;
    PBYTE         pbCur;        
    DWORD          cbSize;
    DWORD cNormals;
    DWORD cFaces;
    DWORD iFace;
    DWORD iVertex;

    assert(psc != NULL);
    assert(pParent != NULL);
    assert(pMeshData != NULL);

    cNormals = pMeshData->m_cVertices;
    cFaces = pMeshData->m_cFaces;

    cbSize = sizeof(DWORD) // nNormals
             + 3*sizeof(float)*cNormals // normals
             + sizeof(DWORD) // nFaces
             + cFaces* // MeshFace array
                (sizeof(DWORD) //nFaceVertexIndices (number of normal indices)
                 + 3*sizeof(DWORD)); // faceVertexIndices (normal indices)

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // nNormals
    WRITE_DWORD(pbCur, cNormals);

    // normals
    for (iVertex = 0; iVertex < pMeshData->m_cVertices; iVertex++)
    {
        WRITE_POINT3(pbCur, pMeshData->m_rgVertices[iVertex].vNormal);
    }

    // nFaces
    WRITE_DWORD(pbCur, cFaces);


    // MeshFace array
    for( iFace = 0; iFace < cFaces; iFace++ )
    {
        WRITE_DWORD(pbCur, 3); // nFaceVertexIndices (number of normal indices)

        // faceVertexIndices (indices to normals - same as indices to vertices for us)
        if( bSwapTriOrder )
        {
            WRITE_DWORD(pbCur, pMeshData->m_rgFaces[iFace].index[0]);
            WRITE_DWORD(pbCur, pMeshData->m_rgFaces[iFace].index[2]);
            WRITE_DWORD(pbCur, pMeshData->m_rgFaces[iFace].index[1]);
        }
        else
        {
            WRITE_DWORD(pbCur, pMeshData->m_rgFaces[iFace].index[0]);
            WRITE_DWORD(pbCur, pMeshData->m_rgFaces[iFace].index[1]);
            WRITE_DWORD(pbCur, pMeshData->m_rgFaces[iFace].index[2]);
        }
    }

    hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMMeshNormals,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
    {
        OutputDebugString("Failed to create x file data object!");
        goto e_Exit;
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
    {
        OutputDebugString("Failed to add x file data object!");
        goto e_Exit;
    }

    // falling through
e_Exit:
    RELEASE(pDataObject);
    delete []pbData;

    return hr;
}

HRESULT AddTextureCoordinates
    (
    SSaveContext *psc,
    SMeshData *pMeshData, 
    SCropInfo *rgCropInfo,
    Mesh* pMesh,
    LPDIRECTXFILEDATA pParent
    )
{
    LPDIRECTXFILEDATA pDataObject = NULL;
    PBYTE         pbData = NULL;
    PBYTE         pbCur = NULL;
    DWORD         cbSize;
    DWORD         cTexCoords;
    DWORD         iVertex;
    DWORD         iTextureIndex;
    HRESULT    hr = S_OK;
    float         fX;
    float         fY;
    DWORD         iMaterial;

    assert( psc );
    assert( pParent );
    assert( pMesh );
    assert( pMeshData );

    // if no tex coords, then don't add them
    if( !pMeshData->m_bTexCoordsPresent )
        goto e_Exit;

    cTexCoords = pMeshData->m_cVertices;

    cbSize = sizeof(DWORD) //nTextureCoords
             + cTexCoords*2*sizeof(float); //texture coords

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    WRITE_DWORD(pbCur, cTexCoords); //nTextureCoords

    for (iVertex = 0; iVertex < pMeshData->m_cVertices; iVertex++)
    {
        iTextureIndex  = pMeshData->m_rgVertices[iVertex].iTextureIndex;
        iMaterial = pMeshData->m_rgVertices[iVertex].iMaterial;
        if( iTextureIndex == 0xFFFFFFFF ) // none present, or bad data
        {
            WRITE_FLOAT(pbCur, 0); //u
            WRITE_FLOAT(pbCur, 0); //v
        }
        else
        {
            fX = pMesh->tVerts[iTextureIndex].x;
            fY = (1.0f - pMesh->tVerts[iTextureIndex].y);

            fX = (fX > 1.0f) ? 1.0f : ((fX < 0.0f) ? 0.0f : fX);
            fY = (fY > 1.0f) ? 1.0f : ((fY < 0.0f) ? 0.0f : fY);

            fX = (fX * rgCropInfo[iMaterial].fClipW) + rgCropInfo[iMaterial].fClipU;
            fY = (fY * rgCropInfo[iMaterial].fClipH) + rgCropInfo[iMaterial].fClipV;

            WRITE_FLOAT(pbCur, fX); //u
            WRITE_FLOAT(pbCur, fY); //v
        }
    }

    hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMMeshTextureCoords,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
    {
        OutputDebugString("Failed to create x file data object!");
        goto e_Exit;
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
    {
        OutputDebugString("Failed to add x file data object!");
        goto e_Exit;
    }

    // falling through
e_Exit:
    RELEASE(pDataObject);

    delete []pbData;
    return hr;
}

HRESULT AddPatchTextureCoordinates
    (
    SSaveContext *psc,
    SPatchMeshData* pPatchMeshData, 
    PatchMesh* pPatchMesh,
    LPDIRECTXFILEDATA pParent
    )
{
    LPDIRECTXFILEDATA pDataObject = NULL;
    PBYTE         pbData = NULL;
    PBYTE         pbCur = NULL;
    DWORD         cbSize;
    DWORD         cTexCoords;
    DWORD         iVertex;
    DWORD         iTextureIndex;
    HRESULT    hr = S_OK;

    assert( psc );
    assert( pParent );
    assert( pPatchMesh );
    assert( pPatchMeshData );

    // if no tex coords, then don't add them
    if( !pPatchMeshData->m_bTexCoordsPresent )
        goto e_Exit;

    cTexCoords = pPatchMeshData->m_cVertices;

    cbSize = sizeof(DWORD) //nTextureCoords
             + cTexCoords*2*sizeof(float); //texture coords

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    WRITE_DWORD(pbCur, cTexCoords); //nTextureCoords

    for (iVertex = 0; iVertex < pPatchMeshData->m_cVertices; iVertex++)
    {
        iTextureIndex  = pPatchMeshData->m_rgVertices[iVertex].iTextureIndex;
        if( iTextureIndex == 0xFFFFFFFF ) // none present, or bad data
        {
            WRITE_FLOAT(pbCur, 0); //u
            WRITE_FLOAT(pbCur, 0); //v
        }
        else
        {
            WRITE_FLOAT(pbCur, pPatchMesh->tVerts[1][iTextureIndex].x); //u
            WRITE_FLOAT(pbCur, pPatchMesh->tVerts[1][iTextureIndex].y * -1); //v
        }
    }

    hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMMeshTextureCoords,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
    {
        OutputDebugString("Failed to create x file data object!");
        goto e_Exit;
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
    {
        OutputDebugString("Failed to add x file data object!");
        goto e_Exit;
    }

    // falling through
e_Exit:
    RELEASE(pDataObject);

    delete []pbData;
    return hr;
}

HRESULT AddVertexDuplicationIndices
    (
    SSaveContext *psc,
    SMeshData *pMeshData, 
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT    hr = S_OK;
    LPDIRECTXFILEDATA pDataObject = NULL;
    PBYTE         pbData = NULL;
    PBYTE         pbCur = NULL;
    DWORD         cbSize;
    DWORD         cIndices;
    DWORD         cVerticesBeforeDuplication;
    DWORD         iVertex;

    assert(psc != NULL);
    assert(pParent != NULL);
    assert(pMeshData != NULL);

    cIndices = pMeshData->m_cVertices;
    cVerticesBeforeDuplication = pMeshData->m_cVerticesBeforeDuplication;

	// if no new vertices, then don't add a record to the file
	if (pMeshData->m_cVerticesBeforeDuplication == pMeshData->m_cVertices)
		goto e_Exit;

    cbSize = sizeof(DWORD) //nIndices
             + sizeof(DWORD) //nVerticesBeforeDuplication
             + cIndices*sizeof(DWORD); // array of indices

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    WRITE_DWORD(pbCur, cIndices) // nIndices;
    WRITE_DWORD(pbCur, cVerticesBeforeDuplication) // nVerticesBeforeDuplication
    
    for (iVertex = 0; iVertex < cIndices; iVertex++)
    {
        WRITE_DWORD(pbCur, pMeshData->m_rgVertices[iVertex].iPointRep); // index to original vertex without duplication.
    }

    hr = psc->m_pxofsave->CreateDataObject(DXFILEOBJ_VertexDuplicationIndices,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
    {
        OutputDebugString("Failed to create x file data object!");
        goto e_Exit;
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
    {
        OutputDebugString("Failed to add x file data object!");
        goto e_Exit;
    }

    // falling through
e_Exit:
    RELEASE(pDataObject);

    delete []pbData;
    return hr;
}

HRESULT AddPatchVertexDuplicationIndices
    (
    SSaveContext *psc,
    SPatchMeshData *pPatchMeshData, 
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT    hr = S_OK;
    LPDIRECTXFILEDATA pDataObject = NULL;
    PBYTE         pbData = NULL;
    PBYTE         pbCur = NULL;
    DWORD         cbSize;
    DWORD         cIndices;
    DWORD         cVerticesBeforeDuplication;
    DWORD         iVertex;

    assert(psc != NULL);
    assert(pParent != NULL);
    assert(pPatchMeshData != NULL);

    cIndices = pPatchMeshData->m_cVertices;
    cVerticesBeforeDuplication = pPatchMeshData->m_cVerticesBeforeDuplication;

	// if no new vertices, then don't add a record to the file
	if (pPatchMeshData->m_cVerticesBeforeDuplication == pPatchMeshData->m_cVertices)
		goto e_Exit;

    cbSize = sizeof(DWORD) //nIndices
             + sizeof(DWORD) //nVerticesBeforeDuplication
             + cIndices*sizeof(DWORD); // array of indices

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    WRITE_DWORD(pbCur, cIndices) // nIndices;
    WRITE_DWORD(pbCur, cVerticesBeforeDuplication) // nVerticesBeforeDuplication
    
    for (iVertex = 0; iVertex < cIndices; iVertex++)
    {
        WRITE_DWORD(pbCur, pPatchMeshData->m_rgVertices[iVertex].iPointRep); // index to original vertex without duplication.
    }

    hr = psc->m_pxofsave->CreateDataObject(DXFILEOBJ_VertexDuplicationIndices,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
    {
        OutputDebugString("Failed to create x file data object!");
        goto e_Exit;
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
    {
        OutputDebugString("Failed to add x file data object!");
        goto e_Exit;
    }

    // falling through
e_Exit:
    RELEASE(pDataObject);

    delete []pbData;
    return hr;
}

HRESULT
AddWireframeMaterial(
    SSaveContext *psc,
    INode *pNode,
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT hr = S_OK;
    DWORD cbSize;
    LPDIRECTXFILEDATA pDataObject = NULL;
    PBYTE pbData = NULL;
    PBYTE pbCur;
    DWORD dwWFColor;
    D3DXCOLOR colorWF;

    cbSize = 4*sizeof(float) // colorRGBA
             + sizeof(float) //power
             + 3*sizeof(float) //specularColor
             + 3*sizeof(float); //emissiveColor

    pbData = pbCur = new BYTE[cbSize];
    if (pbCur == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    
    // get the wireframe color
    dwWFColor = pNode->GetWireColor();
    dwWFColor |= 0xff000000;  // set alpha to fully opaque

    // convert to floating point
    colorWF = D3DXCOLOR(dwWFColor);

    //RGBA
    WRITE_COLOR(pbCur, colorWF);

    // Wireframe doesn't have an explicit specular power, so output our default.
    WRITE_FLOAT(pbCur, POWER_DEFAULT);

    // Set the specular color identical to diffuse, as recommended in 3DSMax docs.
    WRITE_FLOAT(pbCur, colorWF.r);
    WRITE_FLOAT(pbCur, colorWF.g);
    WRITE_FLOAT(pbCur, colorWF.b);

    // Set the luminence to 0: the material isn't glowing.
    WRITE_FLOAT(pbCur, 0.0f);
    WRITE_FLOAT(pbCur, 0.0f);
    WRITE_FLOAT(pbCur, 0.0f);

    hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMMaterial,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    delete []pbData;
    RELEASE(pDataObject);

    return hr;
}

HRESULT
AddTextureFilename(
    SSaveContext *psc,
    TCHAR *szName,
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT hr = S_OK;
    LPDIRECTXFILEDATA pDataObject = NULL;
    DWORD cbSize;

    cbSize = sizeof(TCHAR**);

    hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMTextureFilename,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    &szName,
                                    &pDataObject
                                    );
    if (FAILED(hr))
        goto e_Exit;

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    RELEASE(pDataObject);

    return hr;
}

// ================================================== FindTextureFileName
// callback called by 3DSMAX
class FindTextureFilename : public NameEnumCallback
{
public:
    FindTextureFilename()
        :m_szTextureName(NULL) {}

    virtual void RecordName(TCHAR *szName)
    {
        m_szTextureName = szName;
    }

    TCHAR *m_szTextureName;    
};

HRESULT
AddMaterial(
    SSaveContext *psc,
    Mtl *pMtl,
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT hr = S_OK;
    LPDIRECTXFILEDATA pDataObject = NULL;
    PBYTE pbData = NULL;
    PBYTE pbCur;
    DWORD cbSize;
    TCHAR *szNiceFilename;
    Texmap *pTexMap;
    FindTextureFilename findTextureFilename;
    BOOL bDetailMap = FALSE;

    cbSize = 4*sizeof(float) // colorRGBA
             + sizeof(float) //power
             + 3*sizeof(float) //specularColor
             + 3*sizeof(float); //emissiveColor

    pbData = pbCur = new BYTE[cbSize];
    if (pbCur == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    pTexMap = pMtl->GetActiveTexmap();
    if ((pTexMap != NULL) && (pTexMap->ClassID() == Class_ID(BMTEX_CLASS_ID, 0x00)))
    {
        bDetailMap = TRUE;
    }
    
    // 'Ambient color' is specified in Max docs as "the color of the object in shadows," and 
    //                 is usually a darker version of the diffuse color.
    // 'Diffuse color' is specified in the Max docs as "the color of the object in 
    //                  good lighting," usually referred to as the objects' color.
    // 'Specular color' is specified as the color of reflection highlights in direct lighting,
    //                  and according to Max docs is usually the same as diffuse.

    if (!bDetailMap)
    {
        // We're going to use the 'Diffuse' color as the object color for DirectX
        WRITE_POINT3(pbCur, pMtl->GetDiffuse());
        //Alpha
        WRITE_FLOAT(pbCur, 1 - pMtl->GetXParency());

        // 3DSMax specular power is comprised of shininess, and shininess strength.
        // TODO - figure out a mapping from shininess to power
        WRITE_FLOAT(pbCur, POWER_DEFAULT);

        // Specular
        WRITE_POINT3(pbCur, pMtl->GetSpecular());

        // Emmissive
        WRITE_POINT3(pbCur, pMtl->GetSelfIllumColor());

    }
    else  // if a detail map, then don't write the color
    {
        // diffuse - write white RGBA
        WRITE_FLOAT(pbCur, 1.0f);
        WRITE_FLOAT(pbCur, 1.0f);
        WRITE_FLOAT(pbCur, 1.0f);
        WRITE_FLOAT(pbCur, 1.0f);

        // specular power
        WRITE_FLOAT(pbCur, POWER_DEFAULT);

        // specular - write white RGBA
        WRITE_FLOAT(pbCur, 1.0f);
        WRITE_FLOAT(pbCur, 1.0f);
        WRITE_FLOAT(pbCur, 1.0f);

        // emmissive - write white RGBA
        WRITE_FLOAT(pbCur, 0.0f);
        WRITE_FLOAT(pbCur, 0.0f);
        WRITE_FLOAT(pbCur, 0.0f);
    }

    hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMMaterial,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
        goto e_Exit;

    // See if there is a valid bitmap texture
    if (bDetailMap)
    {
        pTexMap->EnumAuxFiles(findTextureFilename, FILE_ENUM_ALL);

        if (findTextureFilename.m_szTextureName == NULL)
        {
            OutputDebugString("AddMaterial: Bitmap texture found, but no texture name\n");
            hr = E_FAIL;
            goto e_Exit;
        }

        if (psc->m_xFormat == DXFILEFORMAT_TEXT)
        {
            szNiceFilename = psc->m_stStrings.CreateNiceFilename(findTextureFilename.m_szTextureName); /*expand \ char to \\ */
			if (szNiceFilename == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto e_Exit;
			}


            hr = AddTextureFilename(psc, szNiceFilename, pDataObject);
            if (FAILED(hr))
                goto e_Exit;
        }
        else
        {
            hr = AddTextureFilename(psc, findTextureFilename.m_szTextureName, pDataObject);
            if (FAILED(hr))
                goto e_Exit;
        }
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    delete []pbData;
    RELEASE(pDataObject);

    return hr;
}

HRESULT
AddMaterial(
    SSaveContext *psc,
    D3DXMATERIAL *pMaterial,
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT hr = S_OK;
    LPDIRECTXFILEDATA pDataObject = NULL;
    PBYTE pbData = NULL;
    PBYTE pbCur;
    DWORD cbSize;

    cbSize = 4*sizeof(float) // colorRGBA
             + sizeof(float) //power
             + 3*sizeof(float) //specularColor
             + 3*sizeof(float); //emissiveColor

    pbData = pbCur = new BYTE[cbSize];
    if (pbCur == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    
    // diffuse - write white RGBA
    WRITE_FLOAT(pbCur, pMaterial->MatD3D.Diffuse.r);
    WRITE_FLOAT(pbCur, pMaterial->MatD3D.Diffuse.g);
    WRITE_FLOAT(pbCur, pMaterial->MatD3D.Diffuse.b);
    WRITE_FLOAT(pbCur, pMaterial->MatD3D.Diffuse.a);

    // specular power
    WRITE_FLOAT(pbCur, POWER_DEFAULT);

    // specular - write white RGBA
    WRITE_FLOAT(pbCur, pMaterial->MatD3D.Specular.r);
    WRITE_FLOAT(pbCur, pMaterial->MatD3D.Specular.g);
    WRITE_FLOAT(pbCur, pMaterial->MatD3D.Specular.b);

    // emmissive - write white RGBA
    WRITE_FLOAT(pbCur, pMaterial->MatD3D.Emissive.r);
    WRITE_FLOAT(pbCur, pMaterial->MatD3D.Emissive.g);
    WRITE_FLOAT(pbCur, pMaterial->MatD3D.Emissive.b);

    hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMMaterial,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
        goto e_Exit;

    // if there is a bitmap texture, then add the filename
    if (pMaterial->pTextureFilename != NULL)
    {
        hr = AddTextureFilename(psc, pMaterial->pTextureFilename, pDataObject);
        if (FAILED(hr))
            goto e_Exit;
    }

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    delete []pbData;
    RELEASE(pDataObject);

    return hr;
}

HRESULT
GatherMeshMaterials(
    SSaveContext *psc,
    INode *pNode,
    Mesh *pMesh,
    DWORD **prgdwMeshMaterials,
    D3DXMATERIAL **prgMaterials,
    SCropInfo **prgCropInfo,
    DWORD *pcMaterials
    )
{
    HRESULT hr = S_OK;
    Mtl *pMtlMain;
    Mtl *pMtlCur;
    DWORD iCurMaterial;
    DWORD cSubMaterials;
    DWORD iFace;
    DWORD cFaces;
    BOOL bNoSubMaterials;
    BOOL bWireframeColor;
    DWORD dwCurMatID;
    DWORD *rgdwMeshMaterials = NULL;
    SCropInfo *rgCropInfo = NULL;
    IParamBlock2 *pParamBlock;
    Texmap *pTexMap;
    D3DXMATERIAL *rgMaterials = NULL;
    TCHAR *szFilename;
    DWORD dwWFColor;
    D3DXCOLOR colorWF;
    BOOL bDetailMap;
    FindTextureFilename findTextureFilename;

    pMtlMain = pNode->GetMtl();
    cFaces = pMesh->getNumFaces();
    cSubMaterials = 0;
    bNoSubMaterials = FALSE;
    bWireframeColor = FALSE;

    rgdwMeshMaterials = new DWORD[cFaces];
    if (rgdwMeshMaterials == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // The color of a given mesh can be provided by three different sources:
    //   1) applied texture maps, as part of a material
    //   2) explicitly defined & applied materials without texture maps
    //   3) a 'wireframe' color.
    
    // For our purposes, we will output these in this order of preference, ignoring
    // processing past the first one we find.

    if (pMtlMain != NULL)
    {
        // There is at least one material. We're in case 1) or 2)

        cSubMaterials = pMtlMain->NumSubMtls();
        if (cSubMaterials < 1)
        {
            // Count the material itself as a submaterial.
            cSubMaterials = 1;
            bNoSubMaterials = TRUE;
        }
    }
    else  // no material, then we'll create a material corresponding to the default wire color.
    {
        bWireframeColor = TRUE;
        cSubMaterials = 1;
    }

    for (iFace=0; iFace < cFaces; iFace++)
    {
        if (bWireframeColor || bNoSubMaterials) 
        {
            // If we're using wireframe color, it's our only material
            rgdwMeshMaterials[iFace] = 0;
        }
        else
        {
            // Otherwise we have at least one material to process.

            dwCurMatID = pMesh->faces[iFace].getMatID();

            if (cSubMaterials == 1)
            {
                dwCurMatID = 0;
            }
            else
            {
                // SDK recommends mod'ing the material ID by the valid # of materials, 
                // as sometimes a material number that's too high is returned.
                dwCurMatID %= cSubMaterials;
            }

            // output the appropriate material color

            rgdwMeshMaterials[iFace] = dwCurMatID;

        } 

    } 

    rgCropInfo = new SCropInfo[cSubMaterials];
    rgMaterials = new D3DXMATERIAL[cSubMaterials];
    if ((rgCropInfo == NULL) || (rgMaterials == NULL))
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    memset(rgMaterials, 0, sizeof(D3DXMATERIAL) * cSubMaterials);

    for (iCurMaterial = 0; iCurMaterial < cSubMaterials; iCurMaterial++)
    {
        rgCropInfo[iCurMaterial].fClipH = 0.0f;
        rgCropInfo[iCurMaterial].fClipV = 0.0f;
        rgCropInfo[iCurMaterial].fClipW = 1.0f;
        rgCropInfo[iCurMaterial].fClipH = 1.0f;
    }

    if (!bWireframeColor)
    {
        // 3DSMax allows multiple materials to be used on a single mesh via
        // 'submaterials'. When the first submaterial is defined, the main material
        // is copied into submaterial #1, and the new submaterial because submaterial #2.
        // 
        // We have to catch the case where there's a material, but no submaterials. For this
        // case, set NumSubMaterials to 1 which would never happen otherwise. It's imperative
        // that the first material be set to MtlMain, rather than trying to GetSubMtl() to 
        // allow this logic to work.

        // Loop through the materials (if any) and output them.

        // first collect the crop info and the list of materials
        for (iCurMaterial = 0; iCurMaterial < cSubMaterials; iCurMaterial++)
        {
            if (bNoSubMaterials)
            {
                // We're on the parent material, possibly the ONLY material.
                // We won't be able to get it with GetSubMtl() if it's the only one, and
                // the data in the first submaterial is identical to the main material,
                // so just use the main material.

                pMtlCur = pMtlMain;
            }
            else
            {
                // We're into the true submaterials. Safe to get with 'GetSubMtl'

                pMtlCur = pMtlMain->GetSubMtl(iCurMaterial);
            }

            // if using texture as a detail map, get the crop info
			bDetailMap = FALSE;
            pTexMap = pMtlCur->GetActiveTexmap();
            if ((pTexMap != NULL) && (pTexMap->ClassID() == Class_ID(BMTEX_CLASS_ID, 0x00)))
            {
                pParamBlock = pTexMap->GetParamBlock(0);

                if (pParamBlock != NULL)
                {
                    pParamBlock->GetValue(bmtex_clipu, 0, rgCropInfo[iCurMaterial].fClipU, FOREVER);
                    pParamBlock->GetValue(bmtex_clipv, 0, rgCropInfo[iCurMaterial].fClipV, FOREVER);
                    pParamBlock->GetValue(bmtex_clipw, 0, rgCropInfo[iCurMaterial].fClipW, FOREVER);
                    pParamBlock->GetValue(bmtex_cliph, 0, rgCropInfo[iCurMaterial].fClipH, FOREVER);       
                }

                bDetailMap = TRUE;
            }

            // 'Ambient color' is specified in Max docs as "the color of the object in shadows," and 
            //                 is usually a darker version of the diffuse color.
            // 'Diffuse color' is specified in the Max docs as "the color of the object in 
            //                  good lighting," usually referred to as the objects' color.
            // 'Specular color' is specified as the color of reflection highlights in direct lighting,
            //                  and according to Max docs is usually the same as diffuse.

            if (!bDetailMap)
            {
                // We're going to use the 'Diffuse' color as the object color for DirectX
                rgMaterials[iCurMaterial].MatD3D.Diffuse.r = pMtlCur->GetDiffuse().r;
                rgMaterials[iCurMaterial].MatD3D.Diffuse.g = pMtlCur->GetDiffuse().g;
                rgMaterials[iCurMaterial].MatD3D.Diffuse.b = pMtlCur->GetDiffuse().b;

                //Alpha
                rgMaterials[iCurMaterial].MatD3D.Diffuse.a = 1.0f - pMtlCur->GetXParency();

                // 3DSMax specular power is comprised of shininess, and shininess strength.
                // TODO - figure out a mapping from shininess to power
                rgMaterials[iCurMaterial].MatD3D.Power = POWER_DEFAULT;

                // Specular
                rgMaterials[iCurMaterial].MatD3D.Specular.r = pMtlCur->GetSpecular().r;
                rgMaterials[iCurMaterial].MatD3D.Specular.g = pMtlCur->GetSpecular().g;
                rgMaterials[iCurMaterial].MatD3D.Specular.b = pMtlCur->GetSpecular().b;
                rgMaterials[iCurMaterial].MatD3D.Specular.a = 1.0f;

                // Emmissive
                rgMaterials[iCurMaterial].MatD3D.Emissive.r = pMtlCur->GetSelfIllumColor().r;
                rgMaterials[iCurMaterial].MatD3D.Emissive.g = pMtlCur->GetSelfIllumColor().g;
                rgMaterials[iCurMaterial].MatD3D.Emissive.b = pMtlCur->GetSelfIllumColor().b;
                rgMaterials[iCurMaterial].MatD3D.Emissive.a = 1.0f;
            }
            else  // if a detail map, then don't write the color
            {
                // diffuse - write white RGBA
                rgMaterials[iCurMaterial].MatD3D.Diffuse.r = 1.0f;
                rgMaterials[iCurMaterial].MatD3D.Diffuse.g = 1.0f;
                rgMaterials[iCurMaterial].MatD3D.Diffuse.b = 1.0f;
                rgMaterials[iCurMaterial].MatD3D.Diffuse.a = 1.0f;

                rgMaterials[iCurMaterial].MatD3D.Power = POWER_DEFAULT;

                // specular - write white RGBA
                rgMaterials[iCurMaterial].MatD3D.Specular.r = 1.0f;
                rgMaterials[iCurMaterial].MatD3D.Specular.g = 1.0f;
                rgMaterials[iCurMaterial].MatD3D.Specular.b = 1.0f;
                rgMaterials[iCurMaterial].MatD3D.Specular.a = 1.0f;

                // emmissive - write white RGBA
                rgMaterials[iCurMaterial].MatD3D.Emissive.r = 0.0f;
                rgMaterials[iCurMaterial].MatD3D.Emissive.g = 0.0f;
                rgMaterials[iCurMaterial].MatD3D.Emissive.b = 0.0f;
                rgMaterials[iCurMaterial].MatD3D.Emissive.a = 1.0f;
            }

            if (bDetailMap)
            {
                pTexMap->EnumAuxFiles(findTextureFilename, FILE_ENUM_ALL);

                if (findTextureFilename.m_szTextureName == NULL)
                {
                    OutputDebugString("AddMaterial: Bitmap texture found, but no texture name\n");
                    hr = E_FAIL;
                    goto e_Exit;
                }

                // allocate a new string, doing the '\' fixup if neccessary
                if (psc->m_xFormat == DXFILEFORMAT_TEXT)
                    szFilename = psc->m_stStrings.CreateNiceFilename(findTextureFilename.m_szTextureName); /*expand \ char to \\ */
                else
                    szFilename = psc->m_stStrings.CreateNormalFilename(findTextureFilename.m_szTextureName); /*DON'T! expand \ char to \\ */

			    if (szFilename == NULL)
			    {
				    hr = E_OUTOFMEMORY;
				    goto e_Exit;
			    }

                rgMaterials[iCurMaterial].pTextureFilename = szFilename;
            }
        } 
    }
    else // wireframe color
    {
       // get the wireframe color
        dwWFColor = pNode->GetWireColor();
        dwWFColor |= 0xff000000;  // set alpha to fully opaque

        // convert to floating point
        colorWF = D3DXCOLOR(dwWFColor);

        //RGBA
        rgMaterials[0].MatD3D.Diffuse.r = colorWF.r;
        rgMaterials[0].MatD3D.Diffuse.g = colorWF.g;
        rgMaterials[0].MatD3D.Diffuse.b = colorWF.b;
        rgMaterials[0].MatD3D.Diffuse.a = 1.0f;

        // Wireframe doesn't have an explicit specular power, so output our default.
        rgMaterials[0].MatD3D.Power = POWER_DEFAULT;

        // Set the specular color identical to diffuse, as recommended in 3DSMax docs.
        rgMaterials[0].MatD3D.Specular.r = colorWF.r;
        rgMaterials[0].MatD3D.Specular.g = colorWF.g;
        rgMaterials[0].MatD3D.Specular.b = colorWF.b;
        rgMaterials[0].MatD3D.Specular.a = 1.0f;

        // Set the luminence to 0: the material isn't glowing.
        rgMaterials[0].MatD3D.Emissive.r = 0.0f;
        rgMaterials[0].MatD3D.Emissive.g = 0.0f;
        rgMaterials[0].MatD3D.Emissive.b = 0.0f;
        rgMaterials[0].MatD3D.Emissive.a = 1.0f;

    }

    *prgdwMeshMaterials = rgdwMeshMaterials;
    rgdwMeshMaterials = NULL;

    *prgCropInfo = rgCropInfo;
    rgCropInfo = NULL;

    *prgMaterials = rgMaterials;
    rgMaterials = NULL;

    *pcMaterials = cSubMaterials;

e_Exit:
    delete []rgdwMeshMaterials;
    delete []rgMaterials;
    delete []rgCropInfo;
    return hr;
}

HRESULT
AddMeshMaterials(
    SSaveContext *psc,
    INode *pNode,
    Mesh *pMesh,
    DWORD *rgdwMeshMaterials,
    D3DXMATERIAL *rgMaterials,
    DWORD cMaterials,
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT hr = S_OK;
    LPDIRECTXFILEDATA pDataObject = NULL;
    DWORD iFace;
    DWORD cFaces;
    PBYTE pbCur;
    PBYTE pbData = NULL;
    DWORD cbSize;
    DWORD iCurMaterial;
    BOOL bFound;
    DWORD cUniqueMaterials;
    DWORD iSearchMaterial;
    DWORD iPrevMaterial;
    DWORD iDestMaterial;
    DWORD *rgdwMaterialRemap = NULL;

    cFaces = pMesh->getNumFaces();

    rgdwMaterialRemap = new DWORD[cMaterials];
    if (rgdwMaterialRemap == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // first go through and remove redundant materials (might not have had the same crop info!)
    cUniqueMaterials = 1;
    rgdwMaterialRemap[0] = 0;
    for (iCurMaterial = 1; iCurMaterial < cMaterials; iCurMaterial++)
    {
        bFound = FALSE;
        for (iSearchMaterial = 0; iSearchMaterial < iCurMaterial; iSearchMaterial++)
        {
            if (iSearchMaterial == iCurMaterial)
                continue;

            // if both the material and texture name are the same, then it is a redundant material
            if ((memcmp(&(rgMaterials[iCurMaterial].MatD3D), &(rgMaterials[iSearchMaterial].MatD3D), sizeof(D3DMATERIAL8)) == 0)
                && (strcmp(rgMaterials[iCurMaterial].pTextureFilename, rgMaterials[iSearchMaterial].pTextureFilename) == 0))
            {
                bFound = TRUE;
                break;
            }

        }

        // if found, just remap to the material that was found
        if (bFound)
        {
            rgdwMaterialRemap[iCurMaterial] = rgdwMaterialRemap[iSearchMaterial];
        }
        else  // not found, another unique material
        {
            rgdwMaterialRemap[iCurMaterial] = cUniqueMaterials;
            cUniqueMaterials += 1;
        }
    }

    // now remap the materials
    iPrevMaterial = 0;
    for (iCurMaterial = 1; iCurMaterial < cMaterials; iCurMaterial++)
    {
        iDestMaterial = rgdwMaterialRemap[iCurMaterial];

        // if a unique material, then move it
        if (iDestMaterial > iPrevMaterial)
        {
            iPrevMaterial += 1;
            assert(iDestMaterial == iPrevMaterial);

            // if not staying in the same place, then copy it
            if (iCurMaterial != iDestMaterial)
            {
                memcpy(&rgMaterials[iDestMaterial], &rgMaterials[iCurMaterial], sizeof(D3DXMATERIAL));
            }
        }
    }


    cbSize = sizeof(DWORD) // nMaterials
                + sizeof(DWORD) // nFaceIndexes
                + cFaces*sizeof(DWORD); // face indexes

    pbData = pbCur = new BYTE[cbSize];
    if (pbCur == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    WRITE_DWORD(pbCur, cUniqueMaterials);
    WRITE_DWORD(pbCur, cFaces);


    // For each face, output the index of the material which applies to it, 
    // starting from  0

    for (iFace=0; iFace < cFaces; iFace++)
    {
        // don't forget to remap the matrerial before writing it to the file
        WRITE_DWORD(pbCur, rgdwMaterialRemap[rgdwMeshMaterials[iFace]];);
    } 

    // now finally create the mesh material list
    hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMMeshMaterialList,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
        goto e_Exit;

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
        goto e_Exit;

    for (iCurMaterial = 0; iCurMaterial < cUniqueMaterials; iCurMaterial++)
    {
        hr = AddMaterial(psc, &rgMaterials[iCurMaterial], pDataObject);
        if (FAILED(hr))
            goto e_Exit;
    } 

e_Exit:
    delete []pbData;
    delete []rgdwMaterialRemap;
    RELEASE(pDataObject);


    return hr;
} 

// structe used by AddSkinData to convert skin data from per vertex to per bone
struct SBoneState
{
    SBoneState()
        :m_pbData(NULL), m_szBoneName(NULL) {}
    ~SBoneState()
        { 
            delete []m_pbData; 

			// Bone name is allocated out of a string pool because it has to be deleted after
			//   the data has been saved to disk
            //delete []m_szBoneName; 
        }

    // info computed up front (note m_rgdwIndices, m_rgfWeights and m_pmatOFfset point into pbData)
    INode *m_pBoneNode;
    DWORD m_cVertices;
    DWORD m_cbData;
    PBYTE m_pbData;
    char *m_szBoneName;
    DWORD *m_rgdwIndices;
    float *m_rgfWeights;
    D3DXMATRIX *m_pmatOffset;

    // current index of last added vertex index
    DWORD m_iCurIndex;
};

SBoneState *FindBoneData
    (
    INode *pBoneNode, 
    SBoneState *rgbsBoneData, 
    DWORD cBones
    )
{
    DWORD iBone;
    SBoneState *pbs = NULL;

    for (iBone = 0; iBone < cBones; iBone++)
    {
        if (rgbsBoneData[iBone].m_pBoneNode == pBoneNode)
        {
            pbs = &rgbsBoneData[iBone];
            break;
        }
    }

    return pbs;
}

HRESULT AddSkinData
    (
    SSaveContext *psc,
    INode *pNode,
    SMeshData *pMeshData,
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT hr = S_OK;
    IPhyVertexExport *pVertexExport;
    IPhyRigidVertex* pRigidVertexExport;
    IPhyBlendedRigidVertex *pBlendedRigidVertexExport;
    INode* pBoneNode;
    SSkinMap *psmSkinMap = NULL;
    Modifier* pPhyMod = NULL;
    IPhysiqueExport* pPhyExport = NULL;
    IPhyContextExport* pPhyContextExport = NULL;
    SBoneState *rgbsBoneData = NULL;
    SBoneState *rgbsBoneDataDups = NULL;
    SBoneState *pbsCurData = NULL;
    SBoneState *pbsOldData = NULL;
    DWORD iVertex;
    DWORD cVertices;
    DWORD iVertexType;
    DWORD cTotalBones;
    DWORD iBone;
    PBYTE pbCur;
    float fWeight;
    LPDIRECTXFILEDATA pDataObject = NULL;
    DWORD iIndex;
    DWORD iNextWedge;
    Matrix3 matMesh;
    Matrix3 matOffset;
	PBYTE pbHeaderData = NULL;
	DWORD cbHeaderData;

    pPhyMod = FindPhysiqueModifier(pNode);
    if (pPhyMod != NULL)
    {
        // Get a Physique Export interface
        pPhyExport = (IPhysiqueExport *)pPhyMod->GetInterface(I_PHYINTERFACE);
        if (pPhyExport == NULL)
        {   // not all interfaces present, so ignore
            goto e_NoPhysique;
        }

        // get the init matrix for the mesh (used to mult by the bone matrices)
        pPhyExport->GetInitNodeTM(pNode, matMesh);

        // For a given Object's INode get a
        // ModContext Interface from the Physique Export Interface:
        pPhyContextExport = (IPhyContextExport *)pPhyExport->GetContextInterface(pNode);
        if(pPhyContextExport == NULL)
        {
            // not all interfaces present, so ignore
            goto e_NoPhysique;
        }

        // should already have been converted to rigid with blending by Preprocess
            // convert to rigid with blending
            pPhyContextExport->ConvertToRigid(TRUE);
            pPhyContextExport->AllowBlending(TRUE);

        psmSkinMap = psc->GetSkinMap(pNode);
        if (psmSkinMap == NULL)
        {
            OutputDebugString("AddSkinData: Found physique info at save time, but not preprocess\n");
            hr = E_FAIL;
            goto e_Exit;
        }

        // now setup state used to fill arrays for output 
        rgbsBoneData = new SBoneState[psmSkinMap->m_cbiBones];
        if (rgbsBoneData == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        // intialize each of the bone structures 
        for (iBone = 0; iBone < psmSkinMap->m_cbiBones; iBone++)
        {
            pbsCurData = &rgbsBoneData[iBone];

            pbsCurData->m_iCurIndex = 0;
            pbsCurData->m_cVertices = psmSkinMap->m_rgbiBones[iBone].m_cVertices;
            pbsCurData->m_pBoneNode = psmSkinMap->m_rgbiBones[iBone].m_pBoneNode;

            // allocate memory to pass to D3DXOF lib
            pbsCurData->m_cbData = sizeof(TCHAR*)
                                    + sizeof(DWORD) // numWeights
                                    + sizeof(DWORD) * pbsCurData->m_cVertices // array of vertex indices
                                    + sizeof(float) * pbsCurData->m_cVertices // array of weights
                                    + sizeof(float) * 16; // offset matrix

            pbCur = pbsCurData->m_pbData = new BYTE[pbsCurData->m_cbData];
            if (pbsCurData->m_pbData == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }

            // fill first few entries, and remember pointers to the other arrays/matrix
            WRITE_PTCHAR(pbCur, pbsCurData->m_szBoneName);
            WRITE_DWORD(pbCur, pbsCurData->m_cVertices);

            pbsCurData->m_rgdwIndices = (DWORD*)pbCur;
            pbCur += sizeof(DWORD) * pbsCurData->m_cVertices;

            pbsCurData->m_rgfWeights = (float*)pbCur;
            pbCur += sizeof(float) * pbsCurData->m_cVertices;

            pbsCurData->m_pmatOffset = (D3DXMATRIX*)pbCur;

            // compute the mat offset
            pPhyExport->GetInitNodeTM(pbsCurData->m_pBoneNode, matOffset);
            matOffset.Invert();
            matOffset = matMesh * matOffset;

            WRITE_MATRIX4_FROM_MATRIX3(pbCur, matOffset);
        }

        cVertices = pPhyContextExport->GetNumberVertices();
        for (iVertex = 0; iVertex < cVertices; iVertex++ )
        {
            pVertexExport = (IPhyVertexExport *)pPhyContextExport->GetVertexInterface(iVertex);    
            if (pVertexExport == NULL)
            {
                OutputDebugString("Couldn't get export interface!");
                hr = E_FAIL;
                goto e_Exit;
            }
        
            // What kind of vertices are these?
            iVertexType = pVertexExport->GetVertexType();

            pPhyContextExport->ReleaseVertexInterface( pVertexExport );    

            if( iVertexType == RIGID_TYPE )
            {
                pRigidVertexExport = (IPhyRigidVertex *)pPhyContextExport->GetVertexInterface(iVertex);
                if (pRigidVertexExport == NULL)
                {
                    OutputDebugString("Couldn't get rigid vertex export interface!");
                    hr = E_FAIL;
                    goto e_Exit;
                }
                // Get the vertex info!
            
                pBoneNode = pRigidVertexExport->GetNode();

                pbsCurData = FindBoneData(pBoneNode, rgbsBoneData, psmSkinMap->m_cbiBones);
                if (pbsCurData == NULL)
                {
                    assert(0);
                    OutputDebugString("AddSkinData: Bone node not found on second pass\n");
                    hr = E_FAIL;
                    goto e_Exit;
                }

                pbsCurData->m_rgdwIndices[pbsCurData->m_iCurIndex] = iVertex;
                pbsCurData->m_rgfWeights[pbsCurData->m_iCurIndex] = 1.0f;
                pbsCurData->m_iCurIndex += 1;

                pPhyContextExport->ReleaseVertexInterface( pRigidVertexExport);
            }
            else
            {
                assert( iVertexType == RIGID_BLENDED_TYPE );

                pBlendedRigidVertexExport = (IPhyBlendedRigidVertex *)pPhyContextExport->GetVertexInterface(iVertex);
                if (pBlendedRigidVertexExport == NULL)
                {
                    OutputDebugString("Couldn't get blended rigid vertex export interface!");
                    hr = E_FAIL;
                    goto e_Exit;
                }

                // How many nodes affect his vertex?
                cTotalBones = pBlendedRigidVertexExport->GetNumberNodes();
                for (iBone = 0; iBone < cTotalBones; iBone++ )
                {
                    pBoneNode = pBlendedRigidVertexExport->GetNode(iBone);

                    pbsCurData = FindBoneData(pBoneNode, rgbsBoneData, psmSkinMap->m_cbiBones);
                    if (pbsCurData == NULL)
                    {
                        assert(0);
                        OutputDebugString("AddSkinData: Bone node not found on second pass\n");
                        hr = E_FAIL;
                        goto e_Exit;
                    }

                    fWeight = pBlendedRigidVertexExport->GetWeight(iBone);

                    // first see if it is a repeat weight, is so just add to previous
                    if ((pbsCurData->m_iCurIndex > 0) && (pbsCurData->m_rgdwIndices[pbsCurData->m_iCurIndex-1] == iVertex))
                    {
                        pbsCurData->m_rgfWeights[pbsCurData->m_iCurIndex-1] += fWeight;
                    }
                    else
                    {
                        pbsCurData->m_rgdwIndices[pbsCurData->m_iCurIndex] = iVertex;
                        pbsCurData->m_rgfWeights[pbsCurData->m_iCurIndex] = fWeight;
                        pbsCurData->m_iCurIndex += 1;
                    }                    
                }

                pPhyContextExport->ReleaseVertexInterface( pBlendedRigidVertexExport);
            }
        }
    }
e_NoPhysique:



    if (rgbsBoneData != NULL)
    {
        assert(psmSkinMap != NULL);

// now deal with the wonderful world of duplicated indices
        rgbsBoneDataDups = new SBoneState[psmSkinMap->m_cbiBones];
        if (rgbsBoneDataDups == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        // first calculate new lengths for the bone weight arrays
        for (iBone = 0; iBone < psmSkinMap->m_cbiBones; iBone++)
        {
            pbsOldData = &rgbsBoneData[iBone];
            pbsCurData = &rgbsBoneDataDups[iBone];

            pbsCurData->m_cVertices = pbsOldData->m_cVertices;
            for (iIndex = 0; iIndex < pbsOldData->m_cVertices; iIndex++)
            {
                iVertex = pbsOldData->m_rgdwIndices[iIndex];

                iNextWedge = pMeshData->m_rgVertices[iVertex].iWedgeList;
                while (iVertex != iNextWedge)
                {
                    pbsCurData->m_cVertices += 1;

                    iNextWedge = pMeshData->m_rgVertices[iNextWedge].iWedgeList;
                }
            }
        }

        // next build 
        for (iBone = 0; iBone < psmSkinMap->m_cbiBones; iBone++)
        {
            pbsOldData = &rgbsBoneData[iBone];
            pbsCurData = &rgbsBoneDataDups[iBone];

            pbsCurData->m_pBoneNode = pbsOldData->m_pBoneNode;
            pbsCurData->m_iCurIndex = 0;

            // allocate memory to pass to D3DXOF lib
            pbsCurData->m_cbData = sizeof(TCHAR*)
                                    + sizeof(DWORD) // numWeights
                                    + sizeof(DWORD) * pbsCurData->m_cVertices // array of vertex indices
                                    + sizeof(float) * pbsCurData->m_cVertices // array of weights
                                    + sizeof(float) * 16; // offset matrix

            pbCur = pbsCurData->m_pbData = new BYTE[pbsCurData->m_cbData];
            pbsCurData->m_szBoneName = psc->m_stStrings.CreateNiceString(pbsCurData->m_pBoneNode->GetName());
            if ((pbsCurData->m_pbData == NULL) || (pbsCurData->m_szBoneName == NULL))
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }

            // fill first few entries, and remember pointers to the other arrays/matrix
            WRITE_PTCHAR(pbCur, pbsCurData->m_szBoneName);
            WRITE_DWORD(pbCur, pbsCurData->m_cVertices);

            pbsCurData->m_rgdwIndices = (DWORD*)pbCur;
            pbCur += sizeof(DWORD) * pbsCurData->m_cVertices;

            pbsCurData->m_rgfWeights = (float*)pbCur;
            pbCur += sizeof(float) * pbsCurData->m_cVertices;

            pbsCurData->m_pmatOffset = (D3DXMATRIX*)pbCur;

            // already loaded above, copy from the original state data
            *pbsCurData->m_pmatOffset = *pbsOldData->m_pmatOffset;


            // now that we have the new states set up, copy the data from the old states
            for (iIndex = 0; iIndex < pbsOldData->m_cVertices; iIndex++)
            {
                iVertex = pbsOldData->m_rgdwIndices[iIndex];

                pbsCurData->m_rgdwIndices[pbsCurData->m_iCurIndex] = iVertex;
                pbsCurData->m_rgfWeights[pbsCurData->m_iCurIndex] = pbsOldData->m_rgfWeights[iIndex];
                pbsCurData->m_iCurIndex += 1;

                iNextWedge = pMeshData->m_rgVertices[iVertex].iWedgeList;
                while (iVertex != iNextWedge)
                {
                    pbsCurData->m_rgdwIndices[pbsCurData->m_iCurIndex] = iNextWedge;
                    pbsCurData->m_rgfWeights[pbsCurData->m_iCurIndex] = pbsOldData->m_rgfWeights[iIndex];
                    pbsCurData->m_iCurIndex += 1;

                    iNextWedge = pMeshData->m_rgVertices[iNextWedge].iWedgeList;
                }
            }
        }

		// now that we do have skin data to put in the file, add a skinning header record
		cbHeaderData = sizeof(DWORD) * 3;
		pbCur = pbHeaderData = new BYTE[cbHeaderData];
		if (pbHeaderData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto e_Exit;
		}

		WRITE_WORD(pbCur, psc->m_cMaxWeightsPerVertex);
		WRITE_WORD(pbCur, psc->m_cMaxWeightsPerFace);
		WRITE_WORD(pbCur, psmSkinMap->m_cbiBones);

        hr = psc->m_pxofsave->CreateDataObject(DXFILEOBJ_XSkinMeshHeader,
                                        NULL,
                                        NULL,
                                        cbHeaderData,
                                        pbHeaderData,
                                        &pDataObject
                                        );
        hr = pParent->AddDataObject(pDataObject);
        if (FAILED(hr))
            goto e_Exit;

        RELEASE(pDataObject);

// now actually output the prepared buffers
        for (iBone = 0; iBone < psmSkinMap->m_cbiBones; iBone++)
        {
            assert(rgbsBoneData[iBone].m_iCurIndex == rgbsBoneData[iBone].m_cVertices);
            assert(rgbsBoneDataDups[iBone].m_iCurIndex == rgbsBoneDataDups[iBone].m_cVertices);

            hr = psc->m_pxofsave->CreateDataObject(DXFILEOBJ_SkinWeights,
                                            NULL,
                                            NULL,
                                            rgbsBoneDataDups[iBone].m_cbData,
                                            rgbsBoneDataDups[iBone].m_pbData,
                                            &pDataObject
                                            );
            if (FAILED(hr))
                goto e_Exit;

            hr = pParent->AddDataObject(pDataObject);
            if (FAILED(hr))
                goto e_Exit;

            RELEASE(pDataObject);
        }
    }

e_Exit:
	delete []pbHeaderData;
    delete []rgbsBoneData;
    delete []rgbsBoneDataDups;
    return hr;
}

HRESULT AddMesh
    (
    SSaveContext *psc,
    INode *pNode, 
    Object* pObj,
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT hr = S_OK;
    BOOL bDeleteTriObject = false;
    TriObject *pTriObject = NULL;
    Mesh *pMesh;
    BOOL bSwapTriOrder;
    PBYTE pbData = NULL;
    PBYTE pbCur;
    DWORD cbSize;
    DWORD cVertices;
    DWORD cFaces;
    DWORD iFace;
    Matrix3 matNodeTM;
    SMeshData MeshData;
    LPDIRECTXFILEDATA pDataObject = NULL;
    DWORD iVertex;
    DWORD *rgdwMeshMaterials = NULL;
    SCropInfo *rgCropInfo = NULL;
    D3DXMATERIAL *rgMaterials = NULL;
    DWORD cMaterials;

    // Retrieve the TriObject from the node

    pTriObject = GetTriObjectFromObjRef(pObj, &bDeleteTriObject);

    // If no TriObject then skip
    if (pTriObject == NULL) 
        goto e_Exit;

    pMesh = &(pTriObject->mesh);
    pMesh->checkNormals(TRUE); // TODO: Is this necessary?
    matNodeTM = pNode->GetNodeTM(psc->m_iTime);
    bSwapTriOrder = matNodeTM.Parity();

    hr = GatherMeshMaterials(psc, pNode, pMesh, &rgdwMeshMaterials, &rgMaterials, &rgCropInfo, &cMaterials);
    if (FAILED(hr))
        goto e_Exit;

    hr = GenerateMeshData(pMesh, &MeshData, rgdwMeshMaterials);
    if (FAILED(hr))
        goto e_Exit;

    cVertices = MeshData.m_cVertices;
    cFaces = MeshData.m_cFaces;
    cbSize = sizeof(DWORD) // nVertices
             + cVertices*sizeof(float)*3 // vertices
             + sizeof(DWORD) // nFaces
             + cFaces*(sizeof(DWORD) /*nFaceVertexIndices*/ 
                            + sizeof(DWORD)*3 /*faceVertexIndices*/); // faces

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // write nVertices
    WRITE_DWORD(pbCur, cVertices);

    // write vertices
    for (iVertex = 0; iVertex < MeshData.m_cVertices; iVertex++)
    {
        WRITE_POINT3(pbCur, pMesh->verts[MeshData.m_rgVertices[iVertex].iPointRep]);
    }

    // write nFaces
    WRITE_DWORD(pbCur, cFaces);
    
    // write faces
    for( iFace = 0; iFace < cFaces; iFace++ )
    {
        WRITE_DWORD(pbCur, 3); //nFaceVertexIndices

        // face vertex indices
        if( bSwapTriOrder )
        {
            WRITE_DWORD(pbCur, MeshData.m_rgFaces[iFace].index[0]);
            WRITE_DWORD(pbCur, MeshData.m_rgFaces[iFace].index[2]);
            WRITE_DWORD(pbCur, MeshData.m_rgFaces[iFace].index[1]);
        }
        else
        {
            WRITE_DWORD(pbCur, MeshData.m_rgFaces[iFace].index[0]);
            WRITE_DWORD(pbCur, MeshData.m_rgFaces[iFace].index[1]);
            WRITE_DWORD(pbCur, MeshData.m_rgFaces[iFace].index[2]);
        }
    }

    hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMMesh,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
        goto e_Exit;

    // add the normals to the file
    hr = AddNormals(psc, &MeshData, bSwapTriOrder, pDataObject);
    if (FAILED(hr))
        goto e_Exit;

    // write texture coordinates
    hr = AddTextureCoordinates(psc, &MeshData, rgCropInfo, pMesh, pDataObject);
    if (FAILED(hr))
        goto e_Exit;

    hr = AddVertexDuplicationIndices(psc, &MeshData, pDataObject);
    if (FAILED(hr))
        goto e_Exit;

    hr = AddMeshMaterials(psc, pNode, pMesh, rgdwMeshMaterials, rgMaterials, cMaterials, pDataObject);
    if (FAILED(hr))
        goto e_Exit;

    hr = AddSkinData(psc, pNode, &MeshData, pDataObject);
    if (FAILED(hr))
        goto e_Exit;

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    if (bDeleteTriObject)
    {
        delete pTriObject;
    }

    RELEASE(pDataObject);
    delete []rgdwMeshMaterials;
    delete []rgMaterials;
    delete []rgCropInfo;
    return hr;
}

HRESULT
AddPatchMeshMaterials(
    SSaveContext *psc,
    INode *pNode,
    PatchMesh *pPatchMesh,
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT hr = S_OK;
    LPDIRECTXFILEDATA pDataObject = NULL;
    Mtl *pMtlMain;
    Mtl *pMtlCur;
    DWORD cSubMaterials;
    DWORD iPatch;
    DWORD cPatches;
    BOOL bNoSubMaterials;
    BOOL bWireframeColor;
    PBYTE pbCur;
    PBYTE pbData = NULL;
    DWORD cbSize;
    DWORD iCurMatID;
    DWORD iCurMaterial;

    pMtlMain = pNode->GetMtl();
    cPatches = pPatchMesh->getNumPatches();
    cSubMaterials = 0;
    bNoSubMaterials = FALSE;
    bWireframeColor = FALSE;

    // The color of a given mesh can be provided by three different sources:
    //   1) applied texture maps, as part of a material
    //   2) explicitly defined & applied materials without texture maps
    //   3) a 'wireframe' color.
    
    // For our purposes, we will output these in this order of preference, ignoring
    // processing past the first one we find.

    cbSize = sizeof(DWORD) // nMaterials
                + sizeof(DWORD) // nFaceIndexes
                + cPatches*sizeof(DWORD); // face indexes

    pbData = pbCur = new BYTE[cbSize];
    if (pbCur == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    
    if (pMtlMain != NULL)
    {
        // There is at least one material. We're in case 1) or 2)

        cSubMaterials = pMtlMain->NumSubMtls();
        if (cSubMaterials < 1)
        {
            // Count the material itself as a submaterial.
            cSubMaterials = 1;
            bNoSubMaterials = TRUE;
        }
    }
    else  // no material, then we'll create a material corresponding to the default wire color.
    {
        bWireframeColor = TRUE;
        cSubMaterials = 1;
    }

    WRITE_DWORD(pbCur, cSubMaterials);
    WRITE_DWORD(pbCur, cPatches);


    // For each face, output the index of the material which applies to it, 
    // starting from  0

    for (iPatch=0; iPatch < cPatches; iPatch++)
    {

        if (bWireframeColor || bNoSubMaterials) 
        {
            // If we're using wireframe color, it's our only material
            WRITE_DWORD(pbCur, 0);
        }
        else
        {
            // Otherwise we have at least one material to process.

            iCurMatID = pPatchMesh->getPatchMtlIndex(iPatch);

            if (cSubMaterials == 1)
            {
                iCurMatID = 0;
            }
            else
            {
                // SDK recommends mod'ing the material ID by the valid # of materials, 
                // as sometimes a material number that's too high is returned.
                iCurMatID %= cSubMaterials;
            }

            // output the appropriate material color

            WRITE_DWORD(pbCur, iCurMatID);

        } 

    } 

    // now finally create the mesh material list
    hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMMeshMaterialList,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
        goto e_Exit;

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
        goto e_Exit;

    // 3DSMax uses wireframe color as its default material for a mesh.
    // Output the wireframe color as the material if there are no explicit materials.

    if (bWireframeColor)
    {
        AddWireframeMaterial(psc, pNode, pDataObject);
    } 
    else
    {
        // 3DSMax allows multiple materials to be used on a single mesh via
        // 'submaterials'. When the first submaterial is defined, the main material
        // is copied into submaterial #1, and the new submaterial because submaterial #2.
        // 
        // We have to catch the case where there's a material, but no submaterials. For this
        // case, set NumSubMaterials to 1 which would never happen otherwise. It's imperative
        // that the first material be set to MtlMain, rather than trying to GetSubMtl() to 
        // allow this logic to work.

        // Loop through the materials (if any) and output them.

        for (iCurMaterial = 0; (iCurMaterial < cSubMaterials); iCurMaterial++)
        {
            if (bNoSubMaterials)
            {
                // We're on the parent material, possibly the ONLY material.
                // We won't be able to get it with GetSubMtl() if it's the only one, and
                // the data in the first submaterial is identical to the main material,
                // so just use the main material.

                pMtlCur = pMtlMain;
            }
            else
            {
                // We're into the true submaterials. Safe to get with 'GetSubMtl'

                pMtlCur = pMtlMain->GetSubMtl(iCurMaterial);
            }

            hr = AddMaterial(psc, pMtlCur, pDataObject);
            if (FAILED(hr))
                goto e_Exit;
        } 
    }

e_Exit:
    delete []pbData;
    RELEASE(pDataObject);


    return hr;
} 

HRESULT AddPatchMesh
    (
    SSaveContext *psc,
    INode *pNode, 
    Object* pObj,
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT    hr = S_OK;
    LPDIRECTXFILEDATA pDataObject = NULL;
    PBYTE         pbData = NULL;
    PBYTE		  pbCur = NULL;        
    DWORD          cbSize;
    DWORD iVertex;
    DWORD iPatch;
    Point3 *pvVertices;
    PatchMesh *pPatchMesh;
	PatchObject *pPatchObject = NULL;
	BOOL bDeletePatchObject;
	DWORD iControl;
    DWORD cPatchIndices;
	SPatchMeshData PatchMeshData;

	assert(psc != NULL);
	assert(pNode != NULL);
	assert(pObj != NULL);
	assert(pParent != NULL);

    pPatchObject = GetPatchObjectFromObjRef(pObj, &bDeletePatchObject);

    // If no PatchObject then skip
    if (pPatchObject == NULL) 
        goto e_Exit;

    pPatchMesh = &pPatchObject->patch;

	// massage the patch data into an outputable format (including texture coord handling)
	hr = GeneratePatchMeshData(pPatchMesh, &PatchMeshData);
	if (FAILED(hr))
		goto e_Exit;

	// figure out the total number of control indices
	cPatchIndices = 0;
	for (iPatch = 0; iPatch < PatchMeshData.m_cPatches; iPatch++)
	{
		cPatchIndices += PatchMeshData.m_rgPatches[iPatch].m_cControl;
	}

    cbSize = sizeof(DWORD) // nVertices
             + PatchMeshData.m_cVertices * sizeof(float)*3 // vertices
             + sizeof(DWORD) // nPatches
             + PatchMeshData.m_cPatches * sizeof(DWORD) /*nControlIndices*/ 
             + cPatchIndices * sizeof(DWORD) /*controlIndices*/; // patches

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

	// write the number of vertices
	WRITE_DWORD(pbCur, PatchMeshData.m_cVertices);

    // first write all the vertices
    pvVertices = (Point3*)pbCur;
    for (iVertex = 0; iVertex < PatchMeshData.m_cVertices; iVertex++)
    {
        pvVertices[iVertex] = PatchMeshData.m_rgVertices[iVertex].vPosition;
    }

    // skip over the vertices
    pbCur = pbData + sizeof(DWORD) + sizeof(float)*3*PatchMeshData.m_cVertices;

	// write the number of patches
	WRITE_DWORD(pbCur, PatchMeshData.m_cPatches);

	// now write all the patch data
	for (iPatch = 0; iPatch < PatchMeshData.m_cPatches; iPatch++)
	{
		WRITE_DWORD(pbCur, PatchMeshData.m_rgPatches[iPatch].m_cControl);
		for (iControl = 0; iControl < PatchMeshData.m_rgPatches[iPatch].m_cControl; iControl++)
		{
			WRITE_DWORD(pbCur, PatchMeshData.m_rgPatches[iPatch].m_rgdwControl[iControl]);
		}
	}

    hr = psc->m_pxofsave->CreateDataObject(DXFILEOBJ_PatchMesh,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
        goto e_Exit;

    hr = AddPatchTextureCoordinates(psc, &PatchMeshData, pPatchMesh, pDataObject);
    if (FAILED(hr))
        goto e_Exit;

    hr = AddPatchVertexDuplicationIndices(psc, &PatchMeshData, pDataObject);
    if (FAILED(hr))
        goto e_Exit;

    hr = AddPatchMeshMaterials(psc, pNode, pPatchMesh, pDataObject);
    if (FAILED(hr))
        goto e_Exit;

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    delete []pbData;
    RELEASE(pDataObject);

    if (bDeletePatchObject)
    {
        delete pPatchObject;
    }

    return hr;
}

HRESULT AddTransform
    (
    SSaveContext *psc,
    INode *pNode, 
    LPDIRECTXFILEDATA pParent
    )
{
    HRESULT hr = S_OK;
    PBYTE pbData = NULL;
    PBYTE pbCur;
    DWORD cbSize;
    Matrix3 matNodeTM;
    Matrix3 matRelativeTM;
    LPDIRECTXFILEDATA pDataObject = NULL;

    cbSize = 16*sizeof(float);

    pbCur = pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // Node transform
    matNodeTM = pNode->GetNodeTM(psc->m_iTime);
    if( pNode->IsRootNode() )
    {
        // scene root
        matRelativeTM = matNodeTM;
    }
    else
    {
        Matrix3 matParentTM = pNode->GetParentTM(psc->m_iTime);
        if( memcmp(&matNodeTM,&matParentTM,12*sizeof(float)) == 0 )
        {
            matRelativeTM.IdentityMatrix();
        }
        else
        {
            matRelativeTM = matNodeTM * Inverse(matParentTM);
        }
    }

    WRITE_MATRIX4_FROM_MATRIX3(pbCur, matRelativeTM);

    hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMFrameTransformMatrix,
                                    NULL,
                                    NULL,
                                    cbSize,
                                    pbData,
                                    &pDataObject
                                    );
    if (FAILED(hr))
        goto e_Exit;

    hr = pParent->AddDataObject(pDataObject);
    if (FAILED(hr))
        goto e_Exit;

e_Exit:
    delete []pbData;
    RELEASE(pDataObject);

    return hr;
}

HRESULT AddObjectOffsetTransform
    (
    SSaveContext *psc,
	INode *pNode,
    LPDIRECTXFILEDATA pParent,
    LPDIRECTXFILEDATA *ppMeshParent
    )
{
    HRESULT hr = S_OK;
    PBYTE pbData = NULL;
    PBYTE pbCur;
    DWORD cbSize;
    LPDIRECTXFILEDATA pDataObject = NULL;
	Matrix3 matNodeTM;
	Matrix3 matObjTMAfterWSM;
	Matrix3 matObjectOffset;
    LPDIRECTXFILEDATA pObjectOffset = NULL;

	// check to see if the node has an object offset matrix
	matNodeTM = pNode->GetNodeTM(psc->m_iTime);
	matObjTMAfterWSM = pNode->GetObjTMAfterWSM(psc->m_iTime);
	if (memcmp(&matObjTMAfterWSM, &matNodeTM,12*sizeof(Matrix3)) != 0)
	{
		// the mesh is positioned offset from the node, so add another
		//   frame (unnamed) to offset the mesh without affecting the node's children
		//   and/or animation attached to the node
		hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMFrame,
										NULL,
										NULL,
										0,
										NULL,
										&pObjectOffset
										);

		matObjectOffset = matObjTMAfterWSM * Inverse(matNodeTM);


		cbSize = 16*sizeof(float);

		pbCur = pbData = new BYTE[cbSize];
		if (pbData == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto e_Exit;
		}

		WRITE_MATRIX4_FROM_MATRIX3(pbCur, matObjectOffset);

		hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMFrameTransformMatrix,
										NULL,
										NULL,
										cbSize,
										pbData,
										&pDataObject
										);
		if (FAILED(hr))
			goto e_Exit;

		hr = pObjectOffset->AddDataObject(pDataObject);
		if (FAILED(hr))
			goto e_Exit;

		hr = pParent->AddDataObject(pObjectOffset);
		if (FAILED(hr))
			goto e_Exit;


		*ppMeshParent = pObjectOffset;
	}
	else  // identity object offset, mesh should use node as parent
	{
		*ppMeshParent = pParent;
	}

e_Exit:
    delete []pbData;
    RELEASE(pDataObject);
	RELEASE(pObjectOffset);

    return hr;
}

HRESULT EnumTree
    (
    SSaveContext *psc,
    INode *pNode, 
    LPDIRECTXFILEDATA *ppDataObjectNew
    )
{
    HRESULT hr = S_OK;
    DWORD cChildren;
    DWORD iChild;
    LPDIRECTXFILEDATA pChildDataObject;
    LPDIRECTXFILEDATA pDataObject = NULL;
    LPDIRECTXFILEDATA pMeshParent;
    Object* pObj;
    char *szName = NULL;
    
    szName = psc->m_stStrings.CreateNiceString(pNode->GetName());
    if (szName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    OutputDebugString(szName);
    OutputDebugString("\n");

    // add the node to the array for anim purposes
    assert( psc->m_cNodesCur < psc->m_cNodes );
    psc->m_rgpnNodes[psc->m_cNodesCur] = pNode;
    psc->m_cNodesCur += 1;

    hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMFrame,
                                    szName,
                                    NULL,
                                    0,
                                    NULL,
                                    &pDataObject
                                    );

    hr = AddTransform(psc, pNode, pDataObject);
    if (FAILED(hr))
        goto e_Exit;

	if (psc->m_bSavePatchData && IsExportablePatchMesh(pNode, pObj) && !(psc->m_bSaveSelection && !pNode->Selected()))
	{
		hr = AddObjectOffsetTransform(psc, pNode, pDataObject, &pMeshParent);
		if (FAILED(hr))
			goto e_Exit;

        hr = AddPatchMesh(psc, pNode, pObj, pMeshParent);
        if (FAILED(hr))
            goto e_Exit;
	}
    else if (IsExportableMesh(pNode, pObj) && !(psc->m_bSaveSelection && !pNode->Selected()))
    {
		hr = AddObjectOffsetTransform(psc, pNode, pDataObject, &pMeshParent);
		if (FAILED(hr))
			goto e_Exit;
		
        hr = AddMesh(psc, pNode, pObj, pMeshParent);
        if (FAILED(hr))
            goto e_Exit;
    }

    cChildren = pNode->NumberOfChildren();
    for (iChild = 0; iChild < cChildren; iChild++)
    {
        // enumerate the child
        hr = EnumTree(psc, pNode->GetChildNode(iChild), &pChildDataObject);
        if (FAILED(hr))
            goto e_Exit;
        
        hr = pDataObject->AddDataObject(pChildDataObject);
        if (FAILED(hr))
            goto e_Exit;

        RELEASE(pChildDataObject);
    }

    *ppDataObjectNew = pDataObject;
e_Exit:
    return hr;
}


HRESULT Preprocess
    (
    SPreprocessContext *ppc,
    INode *pNode
    )
{
    HRESULT hr = S_OK;
    DWORD cChildren;
    DWORD iChild;
    Object* pObj;
    SSkinMap **rgpsmTemp = NULL;
    IPhyVertexExport *pVertexExport;
    IPhyRigidVertex* pRigidVertexExport;
    IPhyBlendedRigidVertex *pBlendedRigidVertexExport;
    INode* pBoneNode;
    SSkinMap *psmSkinMap;
    Modifier* pPhyMod = NULL;
    IPhysiqueExport* pPhyExport = NULL;
    IPhyContextExport* pPhyContextExport = NULL;
    DWORD iVertex;
    DWORD cVertices;
    DWORD iVertexType;
    SBoneInfo *pbi;
    DWORD cTotalBones;
    DWORD iBone;
    DWORD cpnBonesSeen;
    DWORD cpnBonesSeenMax;
    INode **rgpnBonesSeen = NULL;
    INode **rgpnTemp;
    BOOL bBoneSeen;
    DWORD iBoneSeen;
    BOOL bDeleteTriObject = false;
    TriObject *pTriObject = NULL;
    Mesh *pMesh;
	DWORD iFace;
	DWORD iPoint;

    ppc->m_cNodes += 1;

    if (IsExportableMesh(pNode,pObj) && !(ppc->m_bSaveSelection && !pNode->Selected()))
    {
        // first see if physique is present
        pPhyMod = FindPhysiqueModifier(pNode);
        if (pPhyMod != NULL)
        {
            // Get a Physique Export interface
            pPhyExport = (IPhysiqueExport *)pPhyMod->GetInterface(I_PHYINTERFACE);
            if (pPhyExport == NULL)
            {   // not all interfaces present, so ignore
                goto e_NoPhysique;
            }
            // For a given Object's INode get a
            // ModContext Interface from the Physique Export Interface:
            pPhyContextExport = (IPhyContextExport *)pPhyExport->GetContextInterface(pNode);
            if(pPhyContextExport == NULL)
            {
                // not all interfaces present, so ignore
                goto e_NoPhysique;
            }

            // convert to rigid with blending
            pPhyContextExport->ConvertToRigid(TRUE);
            pPhyContextExport->AllowBlending(TRUE);

            psmSkinMap = new SSkinMap;
            if (psmSkinMap == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }

            // realloc if necessary
            if (ppc->m_cpsmSkinMaps == ppc->m_cpsmSkinMapsMax)
            {
                rgpsmTemp = ppc->m_rgpsmSkinMaps;

                ppc->m_cpsmSkinMapsMax = max(1, ppc->m_cpsmSkinMapsMax);
                ppc->m_cpsmSkinMapsMax = ppc->m_cpsmSkinMapsMax * 2;
                ppc->m_rgpsmSkinMaps = new SSkinMap*[ppc->m_cpsmSkinMapsMax];
                if (ppc->m_rgpsmSkinMaps == NULL)
                {
                    ppc->m_rgpsmSkinMaps = rgpsmTemp;
                    hr = E_OUTOFMEMORY;
                    goto e_Exit;
                }

                if (ppc->m_cpsmSkinMaps > 0)
                {
                    memcpy(ppc->m_rgpsmSkinMaps, rgpsmTemp, sizeof(SSkinMap*) * ppc->m_cpsmSkinMaps);
                }

                delete []rgpsmTemp;
            }
            ppc->m_rgpsmSkinMaps[ppc->m_cpsmSkinMaps] = psmSkinMap;
            ppc->m_cpsmSkinMaps += 1;

            // init the map
            psmSkinMap->m_pMeshNode = pNode;
            psmSkinMap->m_cbiBonesMax = 30;
            psmSkinMap->m_rgbiBones = new SBoneInfo[psmSkinMap->m_cbiBonesMax];
            if (psmSkinMap->m_rgbiBones == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }

            // init duplication removal for redundant weights
            cpnBonesSeenMax = 30;
            cpnBonesSeen = 0;
            rgpnBonesSeen = new INode*[cpnBonesSeenMax];
            if (rgpnBonesSeen == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }

            cVertices = pPhyContextExport->GetNumberVertices();
            for (iVertex = 0; iVertex < cVertices; iVertex++ )
            {
                pVertexExport = (IPhyVertexExport *)pPhyContextExport->GetVertexInterface(iVertex);    
                if (pVertexExport == NULL)
                {
                    OutputDebugString("Couldn't get export interface!");
                    hr = E_FAIL;
                    goto e_Exit;
                }
            
                // What kind of vertices are these?
                iVertexType = pVertexExport->GetVertexType();

                pPhyContextExport->ReleaseVertexInterface( pVertexExport );    

                if( iVertexType == RIGID_TYPE )
                {
                    pRigidVertexExport = (IPhyRigidVertex *)pPhyContextExport->GetVertexInterface(iVertex);
                    if (pRigidVertexExport == NULL)
                    {
                        OutputDebugString("Couldn't get rigid vertex export interface!");
                        hr = E_FAIL;
                        goto e_Exit;
                    }
                    // Get the vertex info!
                
                    pBoneNode = pRigidVertexExport->GetNode();

                    pbi = psmSkinMap->FindBone(pBoneNode);
                    if (pbi == NULL)
                    {
                        hr = psmSkinMap->AddBone(pBoneNode, &pbi);
                        if (FAILED(hr))
                            goto e_Exit;
                    }

                    pbi->m_cVertices += 1;

                    ppc->m_cMaxWeightsPerVertex = max(1, ppc->m_cMaxWeightsPerVertex);

                    pPhyContextExport->ReleaseVertexInterface( pRigidVertexExport);
                }
                else
                {
                    assert( iVertexType == RIGID_BLENDED_TYPE );

                    pBlendedRigidVertexExport = (IPhyBlendedRigidVertex *)pPhyContextExport->GetVertexInterface(iVertex);
                    if (pBlendedRigidVertexExport == NULL)
                    {
                        OutputDebugString("Couldn't get blended rigid vertex export interface!");
                        hr = E_FAIL;
                        goto e_Exit;
                    }

                    // How many nodes affect his vertex?
                    cTotalBones = pBlendedRigidVertexExport->GetNumberNodes();
                    cpnBonesSeen = 0;
                    for (iBone = 0; iBone < cTotalBones; iBone++ )
                    {
                        pBoneNode = pBlendedRigidVertexExport->GetNode(iBone);

                        // first see if the bone has already been seen
                        bBoneSeen = FALSE;
                        for (iBoneSeen = 0; iBoneSeen < cpnBonesSeen; iBoneSeen++)
                        {
                            if (rgpnBonesSeen[iBoneSeen] == pBoneNode)
                            {
                                bBoneSeen = TRUE;
                                break;
                            }
                        }
                        
                        // if not seen, collect stats and add to already seen
                        if (!bBoneSeen)
                        {
                            pbi = psmSkinMap->FindBone(pBoneNode);
                            if (pbi == NULL)
                            {
                                hr = psmSkinMap->AddBone(pBoneNode, &pbi);
                                if (FAILED(hr))
                                    goto e_Exit;
                            }
                            pbi->m_cVertices += 1;

                            if (cpnBonesSeen >= cpnBonesSeenMax)
                            {
                                rgpnTemp = rgpnBonesSeen;
                                cpnBonesSeenMax *= 2;

                                rgpnBonesSeen = new INode*[cpnBonesSeenMax];
                                if (rgpnBonesSeen == NULL)
                                {
                                    rgpnBonesSeen = rgpnTemp;
                                    hr = E_OUTOFMEMORY;
                                    goto e_Exit;
                                }

                                memcpy(rgpnBonesSeen, rgpnTemp, cpnBonesSeen * sizeof(INode*));
                                delete []rgpnTemp;
                            }

                            rgpnBonesSeen[cpnBonesSeen] = pBoneNode;
                            cpnBonesSeen += 1;
                        }
                    }

                    // actualNum... accounts for duplicated weights to same transform node
                    // that are combined automatically above
                    ppc->m_cMaxWeightsPerVertex = max(cpnBonesSeen, ppc->m_cMaxWeightsPerVertex);
            
                    pPhyContextExport->ReleaseVertexInterface( pBlendedRigidVertexExport);
                }
            }


		// now figure out the max number of weights per face

            pTriObject = GetTriObjectFromObjRef(pObj, &bDeleteTriObject);
            if (pTriObject == NULL) 
            {
                OutputDebugString("Physique info, but no mesh");
                hr = E_FAIL;
                goto e_Exit;
            }

            pMesh = &(pTriObject->mesh);

            for (iFace = 0; iFace < pMesh->numFaces; iFace++)
            {
				cpnBonesSeen = 0;
				for (iPoint = 0; iPoint < 3; iPoint++ )
				{
					iVertex = pMesh->faces[iFace].v[iPoint];

					pVertexExport = (IPhyVertexExport *)pPhyContextExport->GetVertexInterface(iVertex);    
					if (pVertexExport == NULL)
					{
						OutputDebugString("Couldn't get export interface!");
						hr = E_FAIL;
						goto e_Exit;
					}
            
					// What kind of vertices are these?
					iVertexType = pVertexExport->GetVertexType();

					pPhyContextExport->ReleaseVertexInterface( pVertexExport );    

					if( iVertexType == RIGID_TYPE )
					{
						pRigidVertexExport = (IPhyRigidVertex *)pPhyContextExport->GetVertexInterface(iVertex);
						if (pRigidVertexExport == NULL)
						{
							OutputDebugString("Couldn't get rigid vertex export interface!");
							hr = E_FAIL;
							goto e_Exit;
						}
						// Get the vertex info!
                
						pBoneNode = pRigidVertexExport->GetNode();

						pbi = psmSkinMap->FindBone(pBoneNode);
						if (pbi == NULL)
						{
							hr = psmSkinMap->AddBone(pBoneNode, &pbi);
							if (FAILED(hr))
								goto e_Exit;
						}

						// first see if the bone has already been seen
						bBoneSeen = FALSE;
						for (iBoneSeen = 0; iBoneSeen < cpnBonesSeen; iBoneSeen++)
						{
							if (rgpnBonesSeen[iBoneSeen] == pBoneNode)
							{
								bBoneSeen = TRUE;
								break;
							}
						}
                    
						// if not seen, collect stats and add to already seen
						if (!bBoneSeen)
						{
							if (cpnBonesSeen >= cpnBonesSeenMax)
							{
								rgpnTemp = rgpnBonesSeen;
								cpnBonesSeenMax *= 2;

								rgpnBonesSeen = new INode*[cpnBonesSeenMax];
								if (rgpnBonesSeen == NULL)
								{
									rgpnBonesSeen = rgpnTemp;
									hr = E_OUTOFMEMORY;
									goto e_Exit;
								}

								memcpy(rgpnBonesSeen, rgpnTemp, cpnBonesSeen * sizeof(INode*));
								delete []rgpnTemp;
							}

							rgpnBonesSeen[cpnBonesSeen] = pBoneNode;
							cpnBonesSeen += 1;
						}

						pPhyContextExport->ReleaseVertexInterface( pRigidVertexExport);
					}
					else
					{
						assert( iVertexType == RIGID_BLENDED_TYPE );

						pBlendedRigidVertexExport = (IPhyBlendedRigidVertex *)pPhyContextExport->GetVertexInterface(iVertex);
						if (pBlendedRigidVertexExport == NULL)
						{
							OutputDebugString("Couldn't get blended rigid vertex export interface!");
							hr = E_FAIL;
							goto e_Exit;
						}

						// How many nodes affect his vertex?
						cTotalBones = pBlendedRigidVertexExport->GetNumberNodes();
						for (iBone = 0; iBone < cTotalBones; iBone++ )
						{
							pBoneNode = pBlendedRigidVertexExport->GetNode(iBone);

							// first see if the bone has already been seen
							bBoneSeen = FALSE;
							for (iBoneSeen = 0; iBoneSeen < cpnBonesSeen; iBoneSeen++)
							{
								if (rgpnBonesSeen[iBoneSeen] == pBoneNode)
								{
									bBoneSeen = TRUE;
									break;
								}
							}
                        
							// if not seen, collect stats and add to already seen
							if (!bBoneSeen)
							{
								if (cpnBonesSeen >= cpnBonesSeenMax)
								{
									rgpnTemp = rgpnBonesSeen;
									cpnBonesSeenMax *= 2;

									rgpnBonesSeen = new INode*[cpnBonesSeenMax];
									if (rgpnBonesSeen == NULL)
									{
										rgpnBonesSeen = rgpnTemp;
										hr = E_OUTOFMEMORY;
										goto e_Exit;
									}

									memcpy(rgpnBonesSeen, rgpnTemp, cpnBonesSeen * sizeof(INode*));
									delete []rgpnTemp;
								}

								rgpnBonesSeen[cpnBonesSeen] = pBoneNode;
								cpnBonesSeen += 1;
							}
						}

						pPhyContextExport->ReleaseVertexInterface( pBlendedRigidVertexExport);
					}
				}

				ppc->m_cMaxWeightsPerFace = max(cpnBonesSeen, ppc->m_cMaxWeightsPerFace);
            }
        }

e_NoPhysique:;
    }

    cChildren = pNode->NumberOfChildren();
    for (iChild = 0; iChild < cChildren; iChild++)
    {
        // enumerate the child
        hr = Preprocess(ppc, pNode->GetChildNode(iChild));
        if (FAILED(hr))
            goto e_Exit;        
    }

e_Exit:
    if (bDeleteTriObject)
    {
        delete pTriObject;
    }

    delete []rgpnBonesSeen;
    return hr;
}


struct SAnimInfo
{
    DWORD dwTime;
    DWORD dwNumValues;
    float rgfValues[16];
};

BOOL BFloatsEqual
    (
    float f1,
    float f2
    )
{
    // first do a bitwise compare
    if ((*(DWORD*)&f1) == (*(DWORD*)&f2))
        return TRUE;

    // next do an epsilon compare
    float fDiff = (f1 - f2);
    return (fDiff <= 1e-6f) && (fDiff >= -1e-6f);
}

BOOL BEqualMatrices(float *rgfMat1, float *rgfMat2)
{
    DWORD iFloat;

    for (iFloat = 0; iFloat < 16; iFloat++)
    {
        if (!BFloatsEqual(rgfMat1[iFloat], rgfMat2[iFloat]))
            return FALSE;
    }

    return TRUE;
}

HRESULT GenerateAnimationSet
    (
    SSaveContext *psc
    )
{
    HRESULT hr = S_OK;
    DWORD cKeys;
    PBYTE pbData = NULL;
    PBYTE pbCur;
    DWORD cTicksPerFrame;
    DWORD iCurTime;
    DWORD iCurKey;
    Matrix3 matFirstTM;
    Matrix3 matTM;
    Matrix3 matRelativeTM;
    Matrix3 matParentTM;
	Interval interval;
    DWORD iNode;
    INode *pNode;
    DWORD cbSize;
    DWORD iKey;
    DWORD cCurrentKeys;
    SAnimInfo *rgaiAnimData = NULL;
    SAnimInfo *rgaiAnimDataCur;
    LPDIRECTXFILEDATA pAnimation = NULL;
    LPDIRECTXFILEDATA pAnimationKeys = NULL;
    char *szName;
    BOOL bAddEndKey = FALSE;
    DWORD iInterval;
    DWORD iStartTime;
    DWORD iEndTime;
    DWORD cFrameRate;

    // find the animation info from the interface
    interval = psc->m_pInterface->GetAnimRange();
    cTicksPerFrame = GetTicksPerFrame();
    cFrameRate = GetFrameRate();
    iStartTime = interval.Start();
    iEndTime = interval.End();

    iInterval = (cTicksPerFrame * cFrameRate) / psc->m_iAnimSamplingRate;

    cKeys = (iEndTime - iStartTime) / iInterval;

    // if the sampling frequency doesn't end directly on 
    //   on the end time, then add a partial end key
    if (((iEndTime - iStartTime) % iInterval) != 0)
    {
        bAddEndKey = TRUE;
        cKeys += 1;
    }

    // add one more key for looping
    cKeys += 1;

    rgaiAnimData = new SAnimInfo[psc->m_cNodes*cKeys];
    if (rgaiAnimData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

	for (iCurKey = 0, iCurTime = iStartTime; iCurTime <= iEndTime; iCurTime += iInterval, iCurKey++ )
	{
        for (iNode = 0; iNode < psc->m_cNodes; iNode++)
        {
            pNode = psc->m_rgpnNodes[iNode];

		    //iCurTime = iFrame * (cTicksPerFrame / 2);
		    matTM = pNode->GetNodeTM(iCurTime);

            if (pNode->GetParentNode() == NULL)
            {
                matRelativeTM = matTM;
            }
            else
            {
                matParentTM = pNode->GetParentNode()->GetNodeTM(iCurTime);
                if( memcmp(&matTM,&matParentTM,12*sizeof(float)) == 0 )
                {
                    matRelativeTM.IdentityMatrix();
                }
                else
                {
                    matRelativeTM = matTM * Inverse(matParentTM);
                }
            }

            // set the current pointer to the correct buffer position
            pbCur = (PBYTE)&rgaiAnimData[iNode*cKeys + iCurKey];

            // first write the time and dword count            
            WRITE_DWORD(pbCur, iCurTime);
            WRITE_DWORD(pbCur, 16);

            // next write the matrix
            WRITE_MATRIX4_FROM_MATRIX3(pbCur, matRelativeTM);

        }
    }

    // if the sampling rate doesn't evenly end on the last frame, add a partial key frame
    if (bAddEndKey)
    {
        assert(((iEndTime - iStartTime) % iInterval) != 0);

        // just add the end time as a key frame
        for (iNode = 0; iNode < psc->m_cNodes; iNode++)
        {
            // set the current pointer to the correct buffer position
            pbCur = (PBYTE)&rgaiAnimData[iCurKey];

		    matTM = pNode->GetNodeTM(iEndTime);
            if (pNode->GetParentNode() == NULL)
            {
                matRelativeTM = matTM;
            }
            else
            {
                matParentTM = pNode->GetParentNode()->GetNodeTM(iEndTime);
                if( memcmp(&matTM,&matParentTM,12*sizeof(float)) == 0 )
                {
                    matRelativeTM.IdentityMatrix();
                }
                else
                {
                    matRelativeTM = matTM * Inverse(matParentTM);
                }
            }

            WRITE_DWORD(pbCur, iEndTime);
            WRITE_DWORD(pbCur, 16);

            // next write the matrix
            WRITE_MATRIX4_FROM_MATRIX3(pbCur, matRelativeTM);
        }
    }

    // loop the anim
    for (iNode = 0; iNode < psc->m_cNodes; iNode++)
    {
        // set the current pointer to the correct buffer position
        pbCur = (PBYTE)&rgaiAnimData[iNode*cKeys + (cKeys-1)];

        WRITE_DWORD(pbCur, iEndTime + iInterval);
        WRITE_DWORD(pbCur, 16);

        // next write the matrix
        memcpy(pbCur, rgaiAnimData[iNode*cKeys].rgfValues, sizeof(float)*16);
    }

    // allocate memory to send to D3DXOF lib
    cbSize = sizeof(DWORD) + sizeof(DWORD) +
            (sizeof(DWORD) //time
                + sizeof(DWORD) //nValues
                + sizeof(FLOAT)*16) // x, y, z
               * cKeys; // number of keys

    pbData = new BYTE[cbSize];
    if (pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMAnimationSet,
                                    NULL,
                                    NULL,
                                    0,
                                    NULL,
                                    &psc->m_pAnimationSet
                                    );
    if (FAILED(hr))
        goto e_Exit;

	for (iNode = 0; iNode < psc->m_cNodes; iNode++)
	{
		pbCur = pbData;

        szName = psc->m_stStrings.CreateNiceString(psc->m_rgpnNodes[iNode]->GetName());
        if (szName == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

		// write the key type
		WRITE_DWORD(pbCur, 4);

		// write the number of keys
		WRITE_DWORD(pbCur, cKeys);

        rgaiAnimDataCur = &rgaiAnimData[iNode*cKeys];
        cCurrentKeys = 0;
        for (iKey = 0; iKey < cKeys; iKey++)
        {
		    memcpy(pbCur, &rgaiAnimDataCur[iKey], sizeof(SAnimInfo));
            pbCur += sizeof(SAnimInfo);
            cCurrentKeys += 1;

            // if not last key, then check for start of a run of identical keys
            if (iKey < (cKeys-1))
            {
                // if equal to next, check for a run of equal matrices
                if (BEqualMatrices(rgaiAnimDataCur[iKey].rgfValues, rgaiAnimDataCur[iKey+1].rgfValues))
                {
                    // move to the next key, and skip all equal matrices
                    iKey += 1;
                    while ((iKey < (cKeys-1)) && BEqualMatrices(rgaiAnimDataCur[iKey].rgfValues, rgaiAnimDataCur[iKey+1].rgfValues))
                    {
                        iKey += 1;
                    }

		            memcpy(pbCur, &rgaiAnimDataCur[iKey], sizeof(SAnimInfo));
                    pbCur += sizeof(SAnimInfo);
                    cCurrentKeys += 1;
                }
            }
        }

        // update to current count of keys
        ((DWORD*)pbData)[1] = cCurrentKeys;

		hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMAnimation,
										NULL,
										NULL,
										0,
										NULL,
										&pAnimation
										);

	// add the data to the file
		hr = psc->m_pxofsave->CreateDataObject(TID_D3DRMAnimationKey,
										NULL,
										NULL,
										cbSize,
										pbData,
										&pAnimationKeys
										);
		if (FAILED(hr))
			goto e_Exit;

		// add to the animation set
		hr = pAnimation->AddDataObject(pAnimationKeys);
		if (FAILED(hr))
			goto e_Exit;

		hr = pAnimation->AddDataReference(szName, NULL);
		if (FAILED(hr))
			goto e_Exit;

		hr = psc->m_pAnimationSet->AddDataObject(pAnimation);
		if (FAILED(hr))
			goto e_Exit;

        RELEASE(pAnimation);
        RELEASE(pAnimationKeys);
	}

e_Exit:
    delete []rgaiAnimData;
	delete []pbData;
    RELEASE(pAnimation);
    RELEASE(pAnimationKeys);

    return hr;
}


// ================================================== CDataSave::CDataSave()
HRESULT ExportXFile
    (
    const TCHAR *szFilename,
    ExpInterface *pExportInterface,
    Interface *pInterface, 
    BOOL bSuppressPrompts,
    BOOL bSaveSelection,
    HWND hwndParent
    ) 
{
    LPDIRECTXFILE pxofapi = NULL;
    LPDIRECTXFILEDATA pRootData = NULL;
    LPDIRECTXFILESAVEOBJECT pxofsave = NULL; 
    HRESULT hr = S_OK;
    INode *pRootNode;
    SSaveContext sc;
    SPreprocessContext pc;
    SDialogOptions DlgOptions;

    assert(szFilename && pExportInterface && pInterface);

    // Extract scene information
    pInterface->ProgressStart(_T("Extracting skinning data"),TRUE,dummyFn,NULL);
    pInterface->ProgressUpdate(0);
    //pInterface->ProgressUpdate(100);

    // first find the root node
    hr = FindRootNode(pExportInterface->theScene, &pRootNode);
    if (FAILED(hr))
        goto e_Exit;

    // setup options for Preprocess stage
    pc.m_bSaveSelection = bSaveSelection;

    // figure out bone counts, etc.
    hr = Preprocess(&pc, pRootNode);
    if (FAILED(hr))
        goto e_Exit;

    // move the skin map data from the preprocess context to the save context
    sc.m_cpsmSkinMaps = pc.m_cpsmSkinMaps;
    sc.m_rgpsmSkinMaps = pc.m_rgpsmSkinMaps;
    pc.m_rgpsmSkinMaps = NULL;

    pInterface->ProgressUpdate(25);

    // setup dialog options
    DlgOptions.m_xFormat = DXFILEFORMAT_BINARY;
    DlgOptions.m_bSavePatchData = FALSE;
    DlgOptions.m_bSaveAnimationData = TRUE;
    DlgOptions.m_iAnimSamplingRate = 30;
    DlgOptions.m_cMaxBonesPerVertex = pc.m_cMaxWeightsPerVertex;
    DlgOptions.m_cMaxBonesPerFace = pc.m_cMaxWeightsPerFace;

    // if prompts not suppressed, then check with the user on options
    if (!bSuppressPrompts)
    {
        DialogBoxParam(g_hInstance, 
                       MAKEINTRESOURCE(IDD_PANEL), 
                        hwndParent, 
                        XSkinExpOptionsDlgProc, 
                        (LPARAM)&DlgOptions);

        if (!DlgOptions.m_bProceedWithExport)
            goto e_Exit;
    }

    pInterface->ProgressStart(_T("Exporting data"),TRUE,dummyFn,NULL);
    pInterface->ProgressUpdate(25);

    // Create xofapi object.
    hr = DirectXFileCreate(&pxofapi);
    if (FAILED(hr))
        goto e_Exit;

    // Register templates for d3drm.
    hr = pxofapi->RegisterTemplates((LPVOID)D3DRM_XTEMPLATES,
                                    D3DRM_XTEMPLATE_BYTES);
    if (FAILED(hr))
        goto e_Exit;

    hr = pxofapi->RegisterTemplates((LPVOID)XSKINEXP_TEMPLATES,
                                    strlen(XSKINEXP_TEMPLATES));
    if (FAILED(hr))
        goto e_Exit;

    // Create save object.
    hr = pxofapi->CreateSaveObject(szFilename,    // filename
                                   DlgOptions.m_xFormat,  // binary or text
                                   &pxofsave);
    if (FAILED(hr))
        goto e_Exit;

    hr = pxofsave->SaveTemplates(3, aIds);
    if (FAILED(hr))
        goto e_Exit;

    sc.m_pxofsave = pxofsave;
    sc.m_xFormat = DlgOptions.m_xFormat;
    sc.m_bSaveAnimationData = DlgOptions.m_bSaveAnimationData;
    sc.m_iAnimSamplingRate = DlgOptions.m_iAnimSamplingRate;
	sc.m_bSavePatchData = DlgOptions.m_bSavePatchData;
    sc.m_iTime = pInterface->GetTime();
    sc.m_pInterface = pInterface;
    sc.m_bSaveSelection = bSaveSelection;
    sc.m_cMaxWeightsPerVertex = pc.m_cMaxWeightsPerVertex;
    sc.m_cMaxWeightsPerFace = pc.m_cMaxWeightsPerFace;

    sc.m_cNodes = pc.m_cNodes;
    sc.m_cNodesCur = 0;
    sc.m_rgpnNodes = new INode*[sc.m_cNodes];
    if (sc.m_rgpnNodes == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    // then write the whole tree out into file data's
    hr = EnumTree(&sc, pRootNode, &pRootData);
    if (FAILED(hr))
        goto e_Exit;

    pInterface->ProgressStart(_T("Saving data to file"),TRUE,dummyFn,NULL);
    pInterface->ProgressUpdate(50);

    // now save that file data to the file
    hr = pxofsave->SaveData(pRootData);
    if (FAILED(hr))
        goto e_Exit;

    pInterface->ProgressUpdate(75);

    if (DlgOptions.m_bSaveAnimationData)
    {
        pInterface->ProgressStart(_T("Saving animation data to file"),TRUE,dummyFn,NULL);
        pInterface->ProgressUpdate(75);

        hr = GenerateAnimationSet(&sc);
        if (FAILED(hr))
            goto e_Exit;

        hr = pxofsave->SaveData(sc.m_pAnimationSet);
        if (FAILED(hr))
        {
            OutputDebugString("Failed to add animation set to X File\n");
            goto e_Exit;
        }            
    }

e_Exit:
    if (FAILED(hr))
    {
        OutputDebugString("File was not successfully exported.");
        {
            TCHAR errstr[500 + _MAX_PATH];
            _stprintf(errstr,"Could not write to file: %s.\n"\
                "Try checking the file's permissions, or if it is currently open.",szFilename);
            MessageBox(hwndParent,errstr,_T("Error!"),MB_OK);
        }
    }

    // falling through
    // Free up outstanding interfaces
    RELEASE(pxofsave);
    RELEASE(pRootData);
    RELEASE(pxofapi);

    pInterface->ProgressUpdate(100);
    pInterface->ProgressEnd();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\3dsmax3\meshdata.h ===
//-----------------------------------------------------------------------------
// File: MeshData.h
//
// Desc: Structures to store a reformated mesh in (split vertices, etc)
//
// Copyright (C) 1998-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef __MESHDATA_H__
#define __MESHDATA_H__

// ================================================== CVertexNode
// Node for a data stucture what will help expand an array of vertices
// into a list of vertices each of which may have more than one normal based
// on the smoothing groups that the vertex belongs to.  This new expanded
// list of vertices (with duplicated verts) will be what gets exported out.
struct SVertexData
{
    Point3 vNormal;
    DWORD iPointRep; // index not including duplicated vertices (raw vertex index)
    DWORD iWedgeList; // index to next vertex in a list of vertices 

    DWORD iTextureIndex;
    DWORD iSmoothingGroupIndex;
    DWORD iMaterial;
};

// ================================================== CFaceData
struct SFaceData
{
    DWORD index[3];
};

struct SMeshData
{
    SMeshData()
        :m_rgVertices(NULL), m_rgFaces(NULL) {}

    ~SMeshData()
    {
        delete []m_rgVertices;
        delete []m_rgFaces;
    }

    BOOL m_bTexCoordsPresent;
    DWORD m_cFaces;
    DWORD m_cVertices;
    DWORD m_cVerticesBeforeDuplication;

    SVertexData *m_rgVertices;
    SFaceData *m_rgFaces;

};

HRESULT GenerateMeshData
    (
    Mesh *pMesh,
    SMeshData *pMeshData,
    DWORD *rgdwMeshMaterials
    );

struct SPatchVertexData
{
    Point3 vPosition;
    DWORD iPointRep; // index not including duplicated vertices (raw vertex index)
    DWORD iWedgeList; // index to next vertex in a list of vertices 

    DWORD iTextureIndex;
};

struct SPatchData
{
	DWORD m_cControl;
	DWORD m_rgdwControl[16];
};

struct SPatchMeshData
{
    SPatchMeshData()
        :m_rgVertices(NULL), m_rgPatches(NULL) {}

    ~SPatchMeshData()
    {
        delete []m_rgVertices;
        delete []m_rgPatches;
    }

    BOOL m_bTexCoordsPresent;
    DWORD m_cPatches;
    DWORD m_cVertices;
    DWORD m_cVerticesBeforeDuplication;

    SPatchVertexData *m_rgVertices;
    SPatchData *m_rgPatches;
};

HRESULT GeneratePatchMeshData
    (
    PatchMesh *pPatchMesh,
    SPatchMeshData *pPatchMeshData 
    );

enum 
{ 
	bmtex_clipu,bmtex_clipv,bmtex_clipw,bmtex_cliph,
	bmtex_jitter,bmtex_usejitter,
	bmtex_apply,bmtex_crop_place,
	bmtex_filtering,
	bmtex_monooutput,
	bmtex_rgboutput,
	bmtex_alphasource,
	bmtex_premultalpha,
	bmtex_bitmap,
	bmtex_coords,	 // access for UVW mapping
	bmtex_output,	 //output window
	bmtex_filename   // bitmap filename virtual parameter, JBW 2/23/99
};

struct SCropInfo
{
    float fClipU;
    float fClipV;
    float fClipW;
    float fClipH;
};

#endif // __MESHDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\3dsmax3\xskinexp.cpp ===
//-----------------------------------------------------------------------------
// File: XSkinExp.cpp
//
// Desc: Export interface for max
//
// Copyright (C) 1998-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------

#include "pch.h"
#include "XSkinExp.h"

HRESULT ExportXFile
    (
    const TCHAR *szFilename,
    ExpInterface *pExportInterface,
    Interface *pInterface, 
    BOOL bSuppressPrompts,
    BOOL bSaveSelection,
    HWND hwndParent
    );


static XSkinExpClassDesc XSkinExpDesc;
ClassDesc* GetXSkinExpDesc() {return &XSkinExpDesc;}

void XSkinExpClassDesc::ResetClassParams (BOOL fileReset) 
{
    // nothing to reset when Max is reset.
}

//--- XSkinExp -------------------------------------------------------
XSkinExp::XSkinExp()
{
}

XSkinExp::~XSkinExp() 
{

}

int XSkinExp::ExtCount()
{
    //TODO: Returns the number of file name extensions supported by the plug-in.
    return 1;
}

const TCHAR *XSkinExp::Ext(int n)
{        
    //TODO: Return the 'i-th' file name extension (i.e. "3DS").
    return _T("x");
}

const TCHAR *XSkinExp::LongDesc()
{
    //TODO: Return long ASCII description (i.e. "Targa 2.0 Image File")
    return _T("DirectX X-File");
}
    
const TCHAR *XSkinExp::ShortDesc() 
{            
    //TODO: Return short ASCII description (i.e. "Targa")
    return _T("X-File");
}

const TCHAR *XSkinExp::AuthorName()
{            
    //TODO: Return ASCII Author name
    return _T("Craig Peeper");
}

const TCHAR *XSkinExp::CopyrightMessage() 
{    
    // Return ASCII Copyright message
    return _T("Copyright 2000, Microsoft Corporation");
}

const TCHAR *XSkinExp::OtherMessage1() 
{        
    //TODO: Return Other message #1 if any
    return _T("");
}

const TCHAR *XSkinExp::OtherMessage2() 
{        
    //TODO: Return other message #2 in any
    return _T("");
}

unsigned int XSkinExp::Version()
{                
    //TODO: Return Version number * 100 (i.e. v3.01 = 301)
    return 100;
}

void XSkinExp::ShowAbout(HWND hWnd)
{            
    // Optional
}

BOOL XSkinExp::SupportsOptions(int ext, DWORD options)
{
    return ( options == SCENE_EXPORT_SELECTED );
}

int XSkinExp::DoExport(const TCHAR *szFilename,ExpInterface *ei,
                        Interface *i, BOOL suppressPrompts, DWORD options) 
{
    HRESULT hr;
    BOOL bSaveSelection = (options & SCENE_EXPORT_SELECTED);

    // return failure if no filename provided
    if (szFilename == NULL)
        return FALSE;

    // actually export the file
    hr = ExportXFile(szFilename, ei, i, suppressPrompts, bSaveSelection, GetActiveWindow());
    if (FAILED(hr))
        return FALSE;
    else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\3dsmax3\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by XSkinExp.rc
//
#define IDS_LIBDESCRIPTION              1
#define IDS_CATEGORY                    2
#define IDS_CLASS_NAME                  3
#define IDS_PARAMS                      4
#define IDS_SPIN                        5
#define IDD_PANEL                       101
#define IDC_CLOSEBUTTON                 1000
#define IDC_DOSTUFF                     1000
#define IDC_TEXT                        1001
#define IDC_BINARY                      1002
#define IDC_BINARYCOMPRESSED            1003
#define IDC_GO                          1004
#define IDC_CANCEL                      1005
#define IDC_MAX_BONES_PER_VERTEX        1007
#define IDC_MAX_BONES_PER_FACE          1008
#define IDC_ANIMATION                   1009
#define IDC_PATCHDATA                   1010
#define IDC_SAMPLERATE                  1011
#define IDC_COLOR                       1456
#define IDC_EDIT                        1490
#define IDC_SPIN2                       1496

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\3dsmax3\xskinexp.h ===
//-----------------------------------------------------------------------------
// File: XSkinExp.h
//
// Desc: Export interface to max definition
//
// Copyright (C) 1998-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef __XSKINEXP__H
#define __XSKINEXP__H

// The unique ClassID
#define XSKINEXP_CLASS_ID    Class_ID(0x8788d182, 0x43774da6)

// Class ID of the skin modifier included in 3DStudio R3
// This modifier is part of R3 (installed), and the source is in the Max SDK under
// \samples\modifier\bonesdef
#define SKINMOD_CLASS_ID    Class_ID(0x0095C723, 0x00015666)

#define VERSION_NUMBER 1
#define RELEASE(x) if(x) {x->Release(); x = NULL;}

#define MAX_OFFSET_VECTORS 20

extern TCHAR *GetString(int id);
extern HINSTANCE g_hInstance;

// ================================================== XSkinExp
class XSkinExp : public SceneExport {
    public:

    //Constructor/Destructor
        XSkinExp();
        virtual ~XSkinExp();

        virtual int              ExtCount();                    // Number of extensions supported
        virtual const TCHAR *    Ext(int n);                    // Extension #n (i.e. "3DS")
        virtual const TCHAR *    LongDesc();                    // Long ASCII description (i.e. "Autodesk 3D Studio File")
        virtual const TCHAR *    ShortDesc();                // Short ASCII description (i.e. "3D Studio")
        virtual const TCHAR *    AuthorName();                // ASCII Author name
        virtual const TCHAR *    CopyrightMessage();            // ASCII Copyright message
        virtual const TCHAR *    OtherMessage1();            // Other message #1
        virtual const TCHAR *    OtherMessage2();            // Other message #2
        virtual unsigned int    Version();                    // Version number * 100 (i.e. v3.01 = 301)
        virtual void            ShowAbout(HWND hWnd);        // Show DLL's "About..." box
        virtual int             DoExport(   const TCHAR *name,
                                    ExpInterface *ei,
                                    Interface *i, 
                                    BOOL suppressPrompts, 
                                    DWORD options); 
        virtual BOOL SupportsOptions(int ext, DWORD options);
};



// ================================================== XSkinExpClassDesc
// This is the Class Descriptor for the XSkinExp plug-in
class XSkinExpClassDesc:public ClassDesc {
    public:
    int             IsPublic() {return 1;}
    void *             Create(BOOL loading = FALSE) {return new XSkinExp();}
    const TCHAR *    ClassName() {return GetString(IDS_CLASS_NAME);}
    SClass_ID        SuperClassID() {return SCENE_EXPORT_CLASS_ID;}
    Class_ID        ClassID() {return XSKINEXP_CLASS_ID;}
    const TCHAR*     Category() {return GetString(IDS_CATEGORY);}
    void            ResetClassParams (BOOL fileReset);
};

#endif // __XSKINEXP__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\maya25\MyDt.cpp ===
#include "MyDt.h"
#include "MyAssert.h"

// Maya API
#include <maya/MObject.h>
#include <maya/MColor.h>
#include <maya/MMatrix.h>
#include <maya/MDagPath.h>
#include <maya/MTime.h>
#include <maya/MAnimControl.h>
#include <maya/MFileObject.h>
#include <maya/MPlug.h>


#include <maya/MIntArray.h>
#include <maya/MFloatArray.h>
#include <maya/MFloatVectorArray.h>
#include <maya/MFloatPointArray.h>
#include <maya/MPointArray.h>
#include <maya/MObjectArray.h>
#include <maya/MDagPathArray.h>
#include <maya/MPlugArray.h>
#include <maya/MSelectionList.h>

#include <maya/MFnMatrixData.h>
#include <maya/MFnMeshData.h>
#include <maya/MFnDoubleArrayData.h>
#include <maya/MFnVectorArrayData.h>

#include <maya/MFnSingleIndexedComponent.h>
#include <maya/MFnSet.h>
#include <maya/MFnTypedAttribute.h>
#include <maya/MFnSkinCluster.h>
#include <maya/MFnWeightGeometryFilter.h>
#include <maya/MFnDagNode.h>
#include <maya/MFnIKJoint.h>
#include <maya/MFnMesh.h>
#include <maya/MFnNurbsSurface.h>
#include <maya/MFnLambertShader.h>

#include <maya/MItDependencyNodes.h>
#include <maya/MItGeometry.h>


bool	g_bRelativeTexFile;
bool	g_bExportAnimation;
bool	g_bKeyframeAnimation;
bool	g_bAnimateEverything;
int		g_iFrameStep;
int		g_iFlipU;
int		g_iFlipV;
bool	g_bExportPatches;

StringTable	g_Strings;



int	MyDtShapeGetParentID
	(
		int	iShape
	) 
{
	int	cShapes		= DtShapeGetCount();


	MObject	objTransform;

	DtExt_ShapeGetTransform(iShape, objTransform);

	MFnDagNode	fnNode(objTransform);

	int cParents	= fnNode.parentCount();

	for (int iParent = 0; iParent < cParents; iParent++) 
	{
		MFnDagNode	fnParent(fnNode.parent(iParent));

		for (int iShape_ = 0; iShape_ < cShapes; iShape_++) 
		{
			MObject	objTransform_;

			DtExt_ShapeGetTransform(iShape_, objTransform_);

			if (fnParent.fullPathName() == MFnDagNode(objTransform_).fullPathName())
				return iShape_;
		}
	}

	return -1;
}



int MyDtShapeGetChildren
    (
		int     iShape, 
        int*    cChildren, 
        int**   rgiChildren
    ) 
{
	int	cShapes		= DtShapeGetCount();

	MObject	objTransform;

	DtExt_ShapeGetTransform(iShape, objTransform);

	MFnDagNode	fnNode(objTransform);

	int cChildren_	= fnNode.childCount();

	*cChildren		= 0;

	if (cChildren_ > 0) 
	{
		*rgiChildren	= new int[cChildren_];

	
		for (int iChild = 0; iChild < cChildren_; iChild++) 
		{
			MFnDagNode fnChild(fnNode.child(iChild));

			for (int iShape_ = 0; iShape_ < cShapes; iShape_++) 
			{
				MObject	objTransform_;

				DtExt_ShapeGetTransform(iShape_, objTransform_);

				if (fnChild.fullPathName() == MFnDagNode(objTransform_).fullPathName()) 
				{
					(*rgiChildren)[*cChildren]	= iShape_;
					(*cChildren)++;

					break;
				}
			}
		}
	}
	else
		*rgiChildren	= new int[1];	// just in case delete doesn't like "int[0]"

	return 1;
}


int	MyDtShapeGetVertices
	(
		MObject&	objInput, 
		MObject&	objOutput, 
		int*		pcVertices, 
		DtVec3f**	prgVertices
	) 
{
	*pcVertices		= 0;
	*prgVertices	= NULL;

	
	assert(objInput.hasFn(MFn::kMesh) && objOutput.hasFn(MFn::kMesh));


	MFnMesh	fnOutput(objOutput);
	MFnMesh	fnInput(objInput);

	*pcVertices		= fnOutput.numVertices();
	*prgVertices	= new DtVec3f[*pcVertices];

	if (!*prgVertices) 
	{
		*pcVertices	= 0;

		return 0;
	}

	// check for tweaks
	MPlug	plgTweakLoc	= fnOutput.findPlug("tweakLocation");

	MObject	objTweakLocVal;

	plgTweakLoc.getValue(objTweakLocVal);

	if (!objTweakLocVal.isNull())	// tweak found
	{	
		MPlugArray	rgplgTweakLocConnections;

		plgTweakLoc.connectedTo(rgplgTweakLocConnections, true, false);		// get source plugs

		assert(rgplgTweakLocConnections.length() == 1);

		MObject	objTweak = rgplgTweakLocConnections[0].node();

		assert(objTweak.hasFn(MFn::kTweak));

		MFnGeometryFilter	fnTweak(objTweak);

		bool	bRelativeTweak;

		fnTweak.findPlug("relativeTweak").getValue(bRelativeTweak);

		if (!bRelativeTweak) 
			cout << "\t\tWARNING: Encountered an absolute tweak; treating as relative!" << endl;

		MPlug plgOffsets = fnTweak.findPlug("vlist")[0].child(0);


		//	WARNING: Seems like Maya doesn't initialize it's numElements properly!!
//		assert((int)plgOffsets.numElements() == cVertices);
//		if ((int)plgOffsets.numElements() != *pcVertices)
//			cout << "\t\tWARNING: tweak count doesn't match vertex count!" << endl;

		float	fEnvelope	= fnTweak.envelope();

		for (int iVertex = 0; iVertex < *pcVertices; iVertex++) 
		{
			plgOffsets.elementByLogicalIndex(iVertex).child(0).getValue((*prgVertices)[iVertex].vec[0]);
			plgOffsets.elementByLogicalIndex(iVertex).child(1).getValue((*prgVertices)[iVertex].vec[1]);
			plgOffsets.elementByLogicalIndex(iVertex).child(2).getValue((*prgVertices)[iVertex].vec[2]);

			(*prgVertices)[iVertex].vec[0]	*= fEnvelope;
			(*prgVertices)[iVertex].vec[1]	*= fEnvelope;
			(*prgVertices)[iVertex].vec[2]	*= fEnvelope;
		}
	}
	else 
	{
		for (int iVertex = 0; iVertex < *pcVertices; iVertex++) 
		{
			(*prgVertices)[iVertex].vec[0]	= 0.0f;
			(*prgVertices)[iVertex].vec[1]	= 0.0f;
			(*prgVertices)[iVertex].vec[2]	= 0.0f;
		}
    }
			
			

	// load vertices and add them to the tweaks
	assert(*pcVertices == fnInput.numVertices());

	MFloatPointArray rgOrigVertices;

	fnInput.getPoints(rgOrigVertices);

	assert(*pcVertices == (int)rgOrigVertices.length());

	for (int iVertex = 0; iVertex < *pcVertices; iVertex++) 
	{
		(*prgVertices)[iVertex].vec[0] += rgOrigVertices[iVertex][0];
		(*prgVertices)[iVertex].vec[1] += rgOrigVertices[iVertex][1];
		(*prgVertices)[iVertex].vec[2] += rgOrigVertices[iVertex][2];
	}


	return 1;
}


int	MyDtTextureGetFileName
	(
		char*	szMaterial, 
		char**	pszTextureFile
	)
{
	if (!DtTextureGetFileName(szMaterial, pszTextureFile))
		return 0;

	if (g_bRelativeTexFile && *pszTextureFile) 
	{
		// use a trick to get the file name without too much hassle
		MFileObject mFile;

		mFile.setFullName(MString(*pszTextureFile));

        *pszTextureFile = new char[256];

        if (*pszTextureFile == NULL)
            return 0;

		strcpy(*pszTextureFile, mFile.name().asChar());

		g_Strings.add(*pszTextureFile);
	}

	return 1;
}







bool	MyDtShapeIsJoint
		(
			int	iShape
		) 
{
	MObject	objShape;

	DtExt_ShapeGetShapeNode(iShape, objShape);

	return (objShape.apiType() == MFn::kInvalid);
}





bool	MyDtShapeIsPatchMesh
		(
			int	iShape
		) 
{
	MObject	objNurb;

	DtExt_ShapeGetShapeNode(iShape, objNurb);

	if (!objNurb.hasFn(MFn::kNurbsSurface))
		return	false;		// not a nurbs surface

	MFnNurbsSurface	fnNurb(objNurb);

	if (fnNurb.degreeU() != 3 || fnNurb.degreeV() != 3)	
		return false;		// not a bicubic surface

	int	kFormInU	= fnNurb.formInU();
	int	kFormInV	= fnNurb.formInV();

	if (kFormInU == MFnNurbsSurface::kInvalid || kFormInV == MFnNurbsSurface::kInvalid)
		return false;		// surface has invalid form

	if (kFormInU == MFnNurbsSurface::kPeriodic || kFormInV == MFnNurbsSurface::kPeriodic)
		return false;		// can't handle periodic surfaces
	
	int	cCVsInU	= fnNurb.numCVsInU();
	int	cCVsInV	= fnNurb.numCVsInV();

	if ((cCVsInU - 1) % 3 != 0 || (cCVsInV - 1) % 3 != 0)
		return false;		// invalid control point count (we only deal with quad patches)

	int	cSpansInU	= (cCVsInU - 1) / 3;
	int	cSpansInV	= (cCVsInV - 1) / 3;

	if (cSpansInU <= 0 || cSpansInV <= 0)
		return false;		// invalid span count


	MPointArray rgCVs;

	fnNurb.getCVs(rgCVs);

	if ((int)rgCVs.length() != cCVsInU * cCVsInV)
		return false;		// inconsistency in cv count

	return true;			// all tests passed
}




int MyDtShapeGetVertices
	(
		int			iShape, 
		int*		pcVertices, 
		DtVec3f**	prgVertices
	)
{
	*pcVertices		= 0;
	*prgVertices	= NULL;

	DtVec3f*	rgVertices;

	if (!DtShapeGetVertices(iShape, pcVertices, &rgVertices))
	{
		*pcVertices	= 0;

		return 0;
	}

	if (!(*prgVertices	= new DtVec3f[*pcVertices]))
	{
		*pcVertices	= 0;

		return 0;
	}

	memcpy(*prgVertices, rgVertices, *pcVertices * sizeof(DtVec3f));

	return 1;
}


int MyDtShapeGetNormals
	(
		int			iShape, 
		int*		pcNormals, 
		DtVec3f**	prgNormals
	)
{
	*pcNormals	= 0;
	*prgNormals	= NULL;

	DtVec3f*	rgNormals;

	if (!DtShapeGetNormals(iShape, pcNormals, &rgNormals))
	{
		*pcNormals	= 0;

		return 0;
	}

	if (!(*prgNormals	= new DtVec3f[*pcNormals]))
	{
		*pcNormals	= 0;

		return 0;
	}

	memcpy(*prgNormals, rgNormals, *pcNormals * sizeof(DtVec3f));

	return 1;
}




int	MyDtShapeGetNormals
	(
		MObject&	objInput, 
		MObject&	objOutput, 
		int*		pcNormals, 
		DtVec3f**	prgNormals
	) 
{
	*pcNormals	= 0;
	*prgNormals	= NULL;

	assert(objInput.hasFn(MFn::kMesh) && objOutput.hasFn(MFn::kMesh));

	MFnMesh	fnInput(objInput);
	MFnMesh	fnOutput(objOutput);

	assert(fnInput.numNormals() == fnOutput.numNormals());
	
	*pcNormals	= fnInput.numNormals();
	*prgNormals	= new DtVec3f[*pcNormals];

	if (!*prgNormals)
	{
		*pcNormals	= 0;

		return 0;
	}

	MFloatVectorArray	rgOrigNormals;

	fnInput.getNormals(rgOrigNormals);

	assert(*pcNormals == (int)rgOrigNormals.length());

	for (int iNormal = 0; iNormal < *pcNormals; iNormal++) 
	{
		(*prgNormals)[iNormal].vec[0]	= rgOrigNormals[iNormal][0];
		(*prgNormals)[iNormal].vec[1]	= rgOrigNormals[iNormal][1];
		(*prgNormals)[iNormal].vec[2]	= rgOrigNormals[iNormal][2];
	}

	return 1;
}







int MyDtShapeGetTextureVertices
	(
		int			iShape, 
		int*		pcTexCoords, 
		DtVec2f**	prgTexCoords
	)
{
	*pcTexCoords	= 0;
	*prgTexCoords	= NULL;

	DtVec2f*	rgTexCoords;

	if (!DtShapeGetTextureVertices(iShape, pcTexCoords, &rgTexCoords))
	{
		*pcTexCoords	= 0;

		return 0;
	}

	if (!(*prgTexCoords	= new DtVec2f[*pcTexCoords]))
	{
		*pcTexCoords	= 0;

		return 0;
	}
	
	memcpy(*prgTexCoords, rgTexCoords, *pcTexCoords * sizeof(DtVec2f));

	return 1;
}





int MyDtShapeGetVerticesColor
	(
		int			iShape, 
		int*		pcColors, 
		DtRGBA**	prgColors
	)
{
	*pcColors	= 0;
	*prgColors	= NULL;

	DtRGBA*	rgColors;

	if (!DtShapeGetVerticesColor(iShape, pcColors, &rgColors))
	{
		*pcColors	= 0;

		return 0;
	}

	if (!(*prgColors	= new DtRGBA[*pcColors]))
	{
		*pcColors	= 0;

		return 0;
	}
	
	memcpy(*prgColors, rgColors, *pcColors * sizeof(DtRGBA));

	return 1;
}









int	MyDtShapeGetControlPoints
	(
		MObject&	objInput, 
		MObject&	objOutput, 
		int*		pcVertices, 
		DtVec3f**	prgVertices
	) 
{
	*pcVertices		= 0;
	*prgVertices	= NULL;

	
	assert(objInput.hasFn(MFn::kNurbsSurface) && objOutput.hasFn(MFn::kNurbsSurface));


	MFnNurbsSurface	fnOutput(objOutput);
	MFnNurbsSurface	fnInput(objInput);



	MPointArray rgCVs;

	fnInput.getCVs(rgCVs);

	*pcVertices		= rgCVs.length();
	*prgVertices	= new DtVec3f[*pcVertices];

	if (!*prgVertices) 
	{
		*pcVertices	= 0;

		return 0;
	}

	// WARNING:  Is this homogeneous coordinates? Should I divide w?
	for (int iVertex = 0; iVertex < *pcVertices; iVertex++) 
	{
		(*prgVertices)[iVertex].vec[0]	= (float)rgCVs[iVertex][0];
		(*prgVertices)[iVertex].vec[1]	= (float)rgCVs[iVertex][1];
		(*prgVertices)[iVertex].vec[2]	= (float)rgCVs[iVertex][2];
	}


	// check for tweaks
	MPlug	plgTweakLoc	= fnOutput.findPlug("tweakLocation");

	MObject	objTweakLocVal;

	plgTweakLoc.getValue(objTweakLocVal);

	if (!objTweakLocVal.isNull())	// tweak found
	{	
		MPlugArray	rgplgTweakLocConnections;

		plgTweakLoc.connectedTo(rgplgTweakLocConnections, true, false);		// get source plugs

		assert(rgplgTweakLocConnections.length() == 1);

		MObject	objTweak = rgplgTweakLocConnections[0].node();

		assert(objTweak.hasFn(MFn::kTweak));

		MFnGeometryFilter	fnTweak(objTweak);

		bool	bRelativeTweak;

		fnTweak.findPlug("relativeTweak").getValue(bRelativeTweak);

		if (!bRelativeTweak) 
			cout << "\t\tWARNING: Encountered an absolute tweak; treating as relative!" << endl;

		MPlug plgOffsets = fnTweak.findPlug("plist")[0].child(0);


		//	WARNING: Seems like Maya doesn't initialize it's numElements properly!!
//		assert((int)plgOffsets.numElements() == cVertices);
		if ((int)plgOffsets.numElements() != *pcVertices)
			cout << "\t\tWARNING: tweak count doesn't match vertex count!" << endl;

		float	fEnvelope	= fnTweak.envelope();

		for (int iVertex = 0; iVertex < *pcVertices; iVertex++) 
		{
			DtVec3f	vecOffset;

			plgOffsets.elementByLogicalIndex(iVertex).child(0).getValue(vecOffset.vec[0]);
			plgOffsets.elementByLogicalIndex(iVertex).child(1).getValue(vecOffset.vec[1]);
			plgOffsets.elementByLogicalIndex(iVertex).child(2).getValue(vecOffset.vec[2]);

			(*prgVertices)[iVertex].vec[0]	+= fEnvelope * vecOffset.vec[0];
			(*prgVertices)[iVertex].vec[1]	+= fEnvelope * vecOffset.vec[1];
			(*prgVertices)[iVertex].vec[2]	+= fEnvelope * vecOffset.vec[2];
		}
	}
			
			

	return 1;
}

















Mesh::Mesh() 
{
	m_kType					= Mesh::UNKNOWN;

	m_cGroups				= 0;
	m_rgGroups				= NULL;

	m_cVertices				= 0;
	m_rgVertices			= NULL;

	m_cVertexColors			= 0;
	m_rgVertexColors		= NULL;

	m_cNormals				= 0;
	m_rgNormals				= NULL;

	m_cTexCoords			= 0;
	m_rgTexCoords			= NULL;

	m_cReps					= 0;
	m_rgReps				= NULL;

	m_cFaces				= 0;
	m_rgFaces				= NULL;

    m_cFaceIndices			= 0;

	m_cBones				= 0;
	m_rgBones				= NULL;

	m_cMaxBonesPerFace		= 0;
	m_cMaxBonesPerVertex	= 0;
}



Mesh::~Mesh() 
{
	delete[] m_rgReps;

	delete[] m_rgVertices;
	delete[] m_rgNormals;
	delete[] m_rgTexCoords;
	delete[] m_rgVertexColors;

	for (int iFace = 0; iFace < m_cFaces; iFace++)
	{
		delete[] m_rgFaces[iFace].m_rgIndices;
	}

	delete[] m_rgFaces;

	delete[] m_rgGroups;

	for (int iBone = 0; iBone < m_cBones; iBone++) 
	{
		delete[] m_rgBones[iBone].m_rgfWeights;
		delete[] m_rgBones[iBone].m_rgiVertices;
	}

	delete[] m_rgBones;
}


Face::Face()
{
	m_cIndices	= 0;
	m_rgIndices	= NULL;

	m_iGroup	= -1;
}

Face::~Face() 
{
}


Bone::Bone()
{
	m_szName		= NULL;

	m_cWeights		= 0;
	m_rgfWeights	= NULL;
	m_rgiVertices	= NULL;

	m_cReps			= 0;
}

Bone::~Bone()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\maya25\MyAssert.h ===
#ifndef MyAssert_h
#define MyAssert_h


#include <assert.h>


#define INIT								try	{															

#define EXIT								}																\
											catch (char* szError) {											\
												cerr << "ERROR [" << szError << "]" << endl;				\
																											\
												hr	= E_FAIL;												\
											}


#define ASSERT(condition, error_msg)		if (!(condition)) {												\
												throw error_msg;											\
											}

#define HR_ATTEMPT(hresult, error_msg)		ASSERT(SUCCEEDED(hresult), (error_msg))


// assert one type of Dt function
#define	DT_ATTEMPT(statement)				statement






#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\maya25\xportTranslator.cpp ===
// TBD	
//		- magic number "xof";
//		- skinning for bezier patches????
//		- adjust normals according to tweaks
//		- test animation with different models (hierarchies, etc.)
//		- support for single-sided vs. double sided
//		- check whether there really is vertex coloring info
//		- make sure that shape names are unique and valid
//		- option to export only selected items
//		- uncomment vertex coloring info


// DONE
//		- multiply envelope by tweaks
//		- export bicubic bezier patches
//		- relative pathnames for textures
//		- make animation optional
//		- speed up animation by rearranging loops
//		- error handling
//		- free Mesh::rgBones[iBone].m_szName
//		- option to flip UV tex coords
//		- option for animation transforms a) ONLY at keyframes or b) at EVERY frame
//		- dialog box interface
//		- option for Text/Binary/Compressed mode

// BUGS
//		- wierd errors loading cowboy.		- Dt library crashes during it's initialization





#include "MyDt.h"
#include "MyAssert.h"

#include "xportTranslator.h"

#include <iostream.h>



// DirectX File Format
#include <dxfile.h>

#include <initguid.h>
#include <rmxfguid.h>
#include <rmxftmpl.h>

// Additional X-file Templates
#include "xskinexptemplates.h"

const GUID* aIds[] = {&DXFILEOBJ_XSkinMeshHeader,
					  &DXFILEOBJ_VertexDuplicationIndices,
					  &DXFILEOBJ_SkinWeights};


// Maya API
#include <maya/MFnPlugin.h>
#include <maya/MSimple.h>
#include <maya/MObject.h>
#include <maya/MColor.h>
#include <maya/MMatrix.h>
#include <maya/MDagPath.h>
#include <maya/MTime.h>
#include <maya/MAnimControl.h>

#include <maya/MDataBlock.h>
#include <maya/MDataHandle.h>

#include <maya/MIntArray.h>
#include <maya/MFloatArray.h>
#include <maya/MFloatVectorArray.h>
#include <maya/MFloatPointArray.h>
#include <maya/MPointArray.h>
#include <maya/MObjectArray.h>
#include <maya/MDagPathArray.h>
#include <maya/MPlugArray.h>
#include <maya/MSelectionList.h>

#include <maya/MFnMatrixData.h>
#include <maya/MFnMeshData.h>
#include <maya/MFnDoubleArrayData.h>
#include <maya/MFnVectorArrayData.h>

#include <maya/MFnSingleIndexedComponent.h>
#include <maya/MFnDoubleIndexedComponent.h>
#include <maya/MFnSet.h>
#include <maya/MFnTypedAttribute.h>
#include <maya/MFnSkinCluster.h>
#include <maya/MFnWeightGeometryFilter.h>
#include <maya/MFnDagNode.h>
#include <maya/MFnIKJoint.h>
#include <maya/MFnMesh.h>
#include <maya/MFnNurbsSurface.h>
#include <maya/MFnLambertShader.h>

#include <maya/MItDependencyNodes.h>
#include <maya/MItGeometry.h>



extern	StringTable g_Strings;


// Dt API
#include <MDt.h>
#include <MDtExt.h>


// Options

DXFILEFORMAT			g_FileFormat;
extern	bool			g_bExportAnimation;
extern	bool			g_bKeyframeAnimation;
extern	bool			g_bAnimateEverything;
extern	int				g_iFrameStep;
extern	int				g_iFlipU;
extern	int				g_iFlipV;
extern	bool			g_bRelativeTexFile;
extern	bool			g_bExportPatches;












HRESULT	AddAnim
		(
			Anim*					pAnim, 
			LPDIRECTXFILEDATA		pAnimSetObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{
	HRESULT				hr							= S_OK;
	
	LPDIRECTXFILEDATA	pAnimDataObject				= NULL;

	LPDIRECTXFILEDATA	pQuaternionKeyDataObject	= NULL;
	LPDIRECTXFILEDATA	pScaleKeyDataObject			= NULL;
	LPDIRECTXFILEDATA	pPositionKeyDataObject		= NULL;

	PBYTE				pbQuaternionKeyData			= NULL;
	PBYTE				pbScaleKeyData				= NULL;
	PBYTE				pbPositionKeyData			= NULL;



	INIT;



	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMAnimation, NULL, NULL, 0, NULL, &pAnimDataObject),
				"Could not create pAnimDataObject.");


	int		cbQuaternionKeySize	= sizeof(DWORD)												// keyType
								+ sizeof(DWORD)												// nKeys
								+ pAnim->m_cKeys 
									* (sizeof(DWORD) + sizeof(DWORD) + 4 * sizeof(float));	// keys[nKeys]


	PBYTE	pbQuaternionKeyCurr	= pbQuaternionKeyData	= new BYTE[cbQuaternionKeySize];

	ASSERT(pbQuaternionKeyData,
				"Could not allocate memory for pbQuaternionKeyData.");


	int		cbScaleKeySize	= sizeof(DWORD)													// keyType
							+ sizeof(DWORD)													// nKeys
							+ pAnim->m_cKeys 
								* (sizeof(DWORD) + sizeof(DWORD) + 3 * sizeof(float));		// keys[nKeys]

	PBYTE	pbScaleKeyCurr	= pbScaleKeyData	= new BYTE[cbScaleKeySize];

	ASSERT(pbScaleKeyData,
				"Could not allocate memory for pbScaleKeyData.");


	int		cbPositionKeySize	= sizeof(DWORD)												// keyType
								+ sizeof(DWORD)												// nKeys
								+ pAnim->m_cKeys 
									* (sizeof(DWORD) + sizeof(DWORD) + 3 * sizeof(float));	// keys[nKeys]

	PBYTE	pbPositionKeyCurr	= pbPositionKeyData	= new BYTE[cbPositionKeySize];

	ASSERT(pbPositionKeyData,
				"Could not allocate memory for pbPositionKeyData.");


	// keyType
	WRITE_DWORD(pbQuaternionKeyCurr,	((DWORD)0));
	WRITE_DWORD(pbScaleKeyCurr,			((DWORD)1));
	WRITE_DWORD(pbPositionKeyCurr,		((DWORD)2));

	// nKeys
	WRITE_DWORD(pbQuaternionKeyCurr,	((DWORD)pAnim->m_cKeys));
	WRITE_DWORD(pbScaleKeyCurr,			((DWORD)pAnim->m_cKeys));
	WRITE_DWORD(pbPositionKeyCurr,		((DWORD)pAnim->m_cKeys));

	// keys[nKeys]
	for (int iKey = 0; iKey < pAnim->m_cKeys; iKey++) 
	{
		// time
		WRITE_DWORD(pbQuaternionKeyCurr,	((DWORD)pAnim->m_rgKeys[iKey].m_iFrame));
		WRITE_DWORD(pbScaleKeyCurr,			((DWORD)pAnim->m_rgKeys[iKey].m_iFrame));
		WRITE_DWORD(pbPositionKeyCurr,		((DWORD)pAnim->m_rgKeys[iKey].m_iFrame));


		// nValues
		WRITE_DWORD(pbQuaternionKeyCurr,	((DWORD)4));
		WRITE_DWORD(pbScaleKeyCurr,			((DWORD)3));
		WRITE_DWORD(pbPositionKeyCurr,		((DWORD)3));

		// values
		WRITE_FLOAT(pbQuaternionKeyCurr,   -pAnim->m_rgKeys[iKey].m_rgfQuaternion[0]);
		WRITE_FLOAT(pbQuaternionKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfQuaternion[1]);
		WRITE_FLOAT(pbQuaternionKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfQuaternion[2]);
		WRITE_FLOAT(pbQuaternionKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfQuaternion[3]);

		WRITE_FLOAT(pbScaleKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfScale[0]);
		WRITE_FLOAT(pbScaleKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfScale[1]);
		WRITE_FLOAT(pbScaleKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfScale[2]);

		WRITE_FLOAT(pbPositionKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfPosition[0]);
		WRITE_FLOAT(pbPositionKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfPosition[1]);
		WRITE_FLOAT(pbPositionKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfPosition[2]);
	}

	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMAnimationKey, NULL, NULL, cbQuaternionKeySize, pbQuaternionKeyData, &pQuaternionKeyDataObject),
				"Could not create pQuaternionKeyDataObject.");


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMAnimationKey, NULL, NULL, cbScaleKeySize, pbScaleKeyData, &pScaleKeyDataObject),
				"Could not create pScaleKeyDataObject.");


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMAnimationKey, NULL, NULL, cbPositionKeySize, pbPositionKeyData, &pPositionKeyDataObject),
				"Could not create pPositionKeyDataObject.");


	HR_ATTEMPT(pAnimDataObject->AddDataReference(pAnim->m_szName, NULL),
				"Could not add data reference to pAnimDataObject.");

    HR_ATTEMPT(pAnimDataObject->AddDataObject(pQuaternionKeyDataObject),
				"Could not add pQuaternionKeyDataObject to pAnimDataObject.");


	HR_ATTEMPT(pAnimDataObject->AddDataObject(pScaleKeyDataObject),
				"Could not add pScaleKeyDataObject to pAnimDataObject.");

	
	HR_ATTEMPT(pAnimDataObject->AddDataObject(pPositionKeyDataObject),
				"Could not add pPositionKeyDataObject to pAnimDataObject.");



	HR_ATTEMPT(pAnimSetObject->AddDataObject(pAnimDataObject),
				"Could not add pAnimDataObject to pAnimSetObject.");



	EXIT;



	delete[] pbQuaternionKeyData;

	delete[] pbScaleKeyData;
	
	delete[] pbPositionKeyData;


	if (pQuaternionKeyDataObject)
		pQuaternionKeyDataObject->Release();

	if (pScaleKeyDataObject)
		pScaleKeyDataObject->Release();

	if (pPositionKeyDataObject)
		pPositionKeyDataObject->Release();

	if (pAnimDataObject)
		pAnimDataObject->Release();


	return hr;
}










HRESULT	loadAllAnims
		(
			Anim*	rgAnims
		) 
{
	HRESULT	hr	= S_OK;

	cout << "\treading at intervals of " << g_iFrameStep << " frame(s)" << endl;

	// calculate the frames per second
	int	iFPS	= 1;

	switch(MTime::uiUnit()) 
	{
		case MTime::kSeconds:		// 1 fps
			iFPS	= 1;
			break;
		case MTime::kMilliseconds:	// 1000 fps
			iFPS	= 1000;
			break;
		case MTime::kGames:			// 15 fps
			iFPS	= 15;
			break;
		case MTime::kFilm:			// 24 fps
			iFPS	= 24;
			break;
		case MTime::kPALFrame:		// 25 fps
			iFPS	= 25;
			break;
		case MTime::kNTSCFrame:		// 30 fps
			iFPS	= 30;
			break;
		case MTime::kShowScan:		// 48 fps
			iFPS	= 48;
			break;
		case MTime::kPALField:		// 50 fps
			iFPS	= 50;
			break;
		case MTime::kNTSCField:		// 60 fps
			iFPS	= 60;
			break;
		default:
			iFPS	= 1;
			break;
	};

	float fTimeFactor	= 3600.0f / (float)iFPS;


	MTime	timeStart(MAnimControl::minTime().value(), MTime::uiUnit());
	MTime	timeEnd(MAnimControl::maxTime().value(), MTime::uiUnit());
	MTime	timeCurrent(MAnimControl::currentTime().value(), MTime::uiUnit());


	DtFrameSetStart((int)timeStart.value());
	DtFrameSetEnd((int)timeEnd.value());


	int cShapes	= DtShapeGetCount();


	MIntArray*	rgrgiKeys	= new MIntArray[cShapes];


	for (int iShape = 0; iShape < cShapes; iShape++) 
	{
		rgAnims[iShape].m_szName	= new char[256];
		rgAnims[iShape].m_cKeys		= 0;
		rgAnims[iShape].m_rgKeys	= new Key[1 + (DtFrameGetEnd() - DtFrameGetStart() + 1) / g_iFrameStep];

		g_Strings.add(rgAnims[iShape].m_szName);

		char* szName;

		DtShapeGetName(iShape, &szName);

		strcpy(rgAnims[iShape].m_szName, szName);

		DtShapeGetTRSAnimKeys(iShape, &rgrgiKeys[iShape]);
	}

	for (int iFrame = DtFrameGetStart(); iFrame <= DtFrameGetEnd(); iFrame += g_iFrameStep) 
	{
		DtFrameSet(iFrame);

		for (int iShape = 0; iShape < cShapes; iShape++) 
		{
			if (rgrgiKeys[iShape].length() > 0 || g_bAnimateEverything) 
			{
				rgAnims[iShape].m_rgKeys[rgAnims[iShape].m_cKeys].m_iFrame	= (int)((float)iFrame * fTimeFactor);

				float*	rgfTRS;

				DtShapeGetMatrix(iShape, &rgfTRS);

				DtMatrixGetTransforms(rgfTRS, 
									  rgAnims[iShape].m_rgKeys[rgAnims[iShape].m_cKeys].m_rgfPosition, 
									  rgAnims[iShape].m_rgKeys[rgAnims[iShape].m_cKeys].m_rgfScale, 
									  rgAnims[iShape].m_rgKeys[rgAnims[iShape].m_cKeys].m_rgfQuaternion, 
									  rgAnims[iShape].m_rgKeys[rgAnims[iShape].m_cKeys].m_rgfRotation);

				rgAnims[iShape].m_cKeys++;
			}
		}
	}

	DtFrameSet((int)timeCurrent.value());

	delete[] rgrgiKeys;

	return hr;
}



void	freeAllAnims
		(
			Anim*	rgAnims
		) 
{
	for (int iShape = 0; iShape < DtShapeGetCount(); iShape++)
		delete[] rgAnims[iShape].m_rgKeys;
}


HRESULT	loadAnim
		(
			int		iShape, 
			Anim*	pAnim
		) 
{
	HRESULT	hr	= S_OK;


	char*	szName;

	DtShapeGetName(iShape, &szName);


	cout << "\treading " << szName << endl;

	int		cKeys	= 0;
	Key*	rgKeys	= NULL;


	MTime	timeStart(MAnimControl::minTime().value(), MTime::uiUnit());
	MTime	timeEnd(MAnimControl::maxTime().value(), MTime::uiUnit());
	MTime	timeCurrent(MAnimControl::currentTime().value(), MTime::uiUnit());

	MIntArray	rgiKeys;

	DtShapeGetTRSAnimKeys(iShape, &rgiKeys);


	cKeys	= rgiKeys.length();

	if (cKeys > 0) 
	{
		DtFrameSetStart(rgiKeys[0]);
		DtFrameSetEnd(rgiKeys[cKeys - 1]);

		// calculate the frames per second
		int	iFPS	= 1;

		switch(MTime::uiUnit()) 
		{
			case MTime::kSeconds:		// 1 fps
				iFPS	= 1;
				break;
			case MTime::kMilliseconds:	// 1000 fps
				iFPS	= 1000;
				break;
			case MTime::kGames:			// 15 fps
				iFPS	= 15;
				break;
			case MTime::kFilm:			// 24 fps
				iFPS	= 24;
				break;
			case MTime::kPALFrame:		// 25 fps
				iFPS	= 25;
				break;
			case MTime::kNTSCFrame:		// 30 fps
				iFPS	= 30;
				break;
			case MTime::kShowScan:		// 48 fps
				iFPS	= 48;
				break;
			case MTime::kPALField:		// 50 fps
				iFPS	= 50;
				break;
			case MTime::kNTSCField:		// 60 fps
				iFPS	= 60;
				break;
			default:
				iFPS	= 1;
				break;
		};


		float fTimeFactor	= 3600.0f / (float)iFPS;

		
		rgKeys	= new Key[cKeys];

		for (int iKey = 0; iKey < cKeys; iKey++) 
		{
			rgKeys[iKey].m_iFrame	= (int)((float)rgiKeys[iKey] * fTimeFactor);

			DtFrameSet(rgiKeys[iKey]);

			float*	rgfTRS;

			DtShapeGetMatrix(iShape, &rgfTRS);

			DtMatrixGetTransforms(rgfTRS, rgKeys[iKey].m_rgfPosition, rgKeys[iKey].m_rgfScale, rgKeys[iKey].m_rgfQuaternion, rgKeys[iKey].m_rgfRotation);
		}

		DtFrameSetStart((int)timeStart.value());
		DtFrameSetEnd((int)timeEnd.value());
		DtFrameSet((int)timeCurrent.value());
	}


	pAnim->m_szName	= new char[256];

	g_Strings.add(pAnim->m_szName);

	strcpy(pAnim->m_szName, szName);

	pAnim->m_cKeys	= cKeys; 
	pAnim->m_rgKeys	= rgKeys;


	return hr;
}











void	freeAnim
		(
			Anim*	pAnim
		) 
{
	delete[] pAnim->m_rgKeys;
}




//	Assumes that the shape is indeed a patch mesh.  This can be checked using MyDtShapeIsPatchMesh

HRESULT	LoadPatchMesh
		(
			int		iShape, 
			Mesh*	pShape
		) 
{
	HRESULT	hr		= S_OK;
	MStatus	mStat	= MS::kSuccess;

	
	// set up references

	Mesh::ShapeType&	kType		= pShape->m_kType;

	int&		cReps				= pShape->m_cReps;
	Rep*&		rgReps				= pShape->m_rgReps;

	int&		cVertices			= pShape->m_cVertices;
	DtVec3f*&	rgVertices			= pShape->m_rgVertices;

	int&		cNormals			= pShape->m_cNormals;
	DtVec3f*&	rgNormals			= pShape->m_rgNormals;

	int&		cTexCoords			= pShape->m_cTexCoords;
	DtVec2f*&	rgTexCoords			= pShape->m_rgTexCoords;

	int&		cVertexColors		= pShape->m_cVertexColors;
	DtRGBA*&	rgVertexColors		= pShape->m_rgVertexColors;


	int&		cFaces				= pShape->m_cFaces;
	Face*&		rgFaces				= pShape->m_rgFaces;

	int&		cFaceIndices		= pShape->m_cFaceIndices;

	int&		cGroups				= pShape->m_cGroups;
	Group*&		rgGroups			= pShape->m_rgGroups;


	int&		cBones				= pShape->m_cBones;
	Bone*&		rgBones				= pShape->m_rgBones;

	int&		cMaxBonesPerVertex	= pShape->m_cMaxBonesPerVertex;
	int&		cMaxBonesPerFace	= pShape->m_cMaxBonesPerFace;



	INIT;		// begin error checking

	// ensure that shape is a nurbs surface
	MObject	objNurb;

	DT_ATTEMPT(DtExt_ShapeGetShapeNode(iShape, objNurb));

	ASSERT(objNurb.hasFn(MFn::kNurbsSurface),	
				"Not a nurb surface");

	MFnNurbsSurface	fnNurb(objNurb);

	// ensure that surface is bicubic
	ASSERT(fnNurb.degreeU() == 3 && fnNurb.degreeV() == 3,	
				"Not a bicubic surface");

	// ensure correct form in U and V 
	int	kFormInU	= fnNurb.formInU();
	int	kFormInV	= fnNurb.formInV();

	ASSERT(kFormInU	== MFnNurbsSurface::kOpen || kFormInU == MFnNurbsSurface::kClosed,
				"Invalid form in U");

	ASSERT(kFormInV == MFnNurbsSurface::kOpen || kFormInV == MFnNurbsSurface::kClosed,
				"Invalid form in V");

	// ensure that surface is a quad mesh
	int	cCVsInU	= fnNurb.numCVsInU();
	int	cCVsInV	= fnNurb.numCVsInV();

	ASSERT((cCVsInU - 1) % 3 == 0 && (cCVsInV - 1) % 3 == 0,
				"Invalid CV count");

	// ensure that there is at least one patch
	int	cSpansInU	= (cCVsInU - 1) / 3;
	int	cSpansInV	= (cCVsInV - 1) / 3;

	ASSERT(cSpansInU > 0 && cSpansInV > 0, 
				"Invalid span count");


	// control vertices

	MPointArray rgCVs;

	fnNurb.getCVs(rgCVs);

	cVertices	= (int)rgCVs.length();
	rgVertices	= new DtVec3f[cVertices];

	ASSERT(rgVertices, 
				"Can't allocate memory for vertex array");

	for (int iVertex = 0; iVertex < cVertices; iVertex++) 
	{
		rgVertices[iVertex].vec[0]	= (float)rgCVs[iVertex][0];
		rgVertices[iVertex].vec[1]	= (float)rgCVs[iVertex][1];
		rgVertices[iVertex].vec[2]	= (float)rgCVs[iVertex][2];
	}



	// texture coordinates
	cTexCoords	= (int)rgCVs.length();
	rgTexCoords	= new DtVec2f[cTexCoords];

	ASSERT(rgTexCoords, 
				"Can't allocate memory for texture coordinate array");

	for (int iCVInU = 0, iTexCoord = 0; iCVInU < cCVsInU; iCVInU++)
	{
		for (int iCVInV = 0; iCVInV < cCVsInV; iCVInV++, iTexCoord++)
		{
			rgTexCoords[iTexCoord].vec[0] =  ((float)iCVInU) / ((float)(cCVsInU - 1));
			rgTexCoords[iTexCoord].vec[1] =  ((float)iCVInV) / ((float)(cCVsInV - 1));
		}
	}



	// face info
	cFaces	= cSpansInU * cSpansInV;
	rgFaces	= new Face[cFaces];

	ASSERT(rgFaces, 
				"Can't allocate memory for patch array");


	cFaceIndices	= 0;
			
	for (int iSpanInU = 0, iPatch = 0; iSpanInU < cSpansInU; iSpanInU++) 
	{
		int iCVIndexInU	= iSpanInU * 3;

		for (int iSpanInV = 0; iSpanInV < cSpansInV; iSpanInV++, iPatch++) 
		{
			int iCVIndexInV	= iSpanInV * 3;

			rgFaces[iPatch].m_cIndices		= 16;
            rgFaces[iPatch].m_rgIndices		= new int[rgFaces[iPatch].m_cIndices];

			ASSERT(rgFaces[iPatch].m_rgIndices,
						"Could not allocate memory for patch indices");

            rgFaces[iPatch].m_rgIndices[0]	= cCVsInV * (iCVIndexInU + 0) + (iCVIndexInV + 0);
            rgFaces[iPatch].m_rgIndices[1]	= cCVsInV * (iCVIndexInU + 1) + (iCVIndexInV + 0);
			rgFaces[iPatch].m_rgIndices[2]	= cCVsInV * (iCVIndexInU + 2) + (iCVIndexInV + 0);

            rgFaces[iPatch].m_rgIndices[3]	= cCVsInV * (iCVIndexInU + 3) + (iCVIndexInV + 0);
			rgFaces[iPatch].m_rgIndices[4]	= cCVsInV * (iCVIndexInU + 3) + (iCVIndexInV + 1);
			rgFaces[iPatch].m_rgIndices[5]	= cCVsInV * (iCVIndexInU + 3) + (iCVIndexInV + 2);

			rgFaces[iPatch].m_rgIndices[6]	= cCVsInV * (iCVIndexInU + 3) + (iCVIndexInV + 3);
			rgFaces[iPatch].m_rgIndices[7]	= cCVsInV * (iCVIndexInU + 2) + (iCVIndexInV + 3);
			rgFaces[iPatch].m_rgIndices[8]	= cCVsInV * (iCVIndexInU + 1) + (iCVIndexInV + 3);

			rgFaces[iPatch].m_rgIndices[9]	= cCVsInV * (iCVIndexInU + 0) + (iCVIndexInV + 3);
			rgFaces[iPatch].m_rgIndices[10]	= cCVsInV * (iCVIndexInU + 0) + (iCVIndexInV + 2);
			rgFaces[iPatch].m_rgIndices[11]	= cCVsInV * (iCVIndexInU + 0) + (iCVIndexInV + 1);

			rgFaces[iPatch].m_rgIndices[12]	= cCVsInV * (iCVIndexInU + 1) + (iCVIndexInV + 1);
			rgFaces[iPatch].m_rgIndices[13]	= cCVsInV * (iCVIndexInU + 2) + (iCVIndexInV + 1);

			rgFaces[iPatch].m_rgIndices[14]	= cCVsInV * (iCVIndexInU + 2) + (iCVIndexInV + 2);
			rgFaces[iPatch].m_rgIndices[15]	= cCVsInV * (iCVIndexInU + 1) + (iCVIndexInV + 2);

			rgFaces[iPatch].m_iGroup		= 0;			//	WARNING: assumes only 1 material per surface


			cFaceIndices	+= rgFaces[iPatch].m_cIndices;
		}
	}



	// material info

	cGroups		= DtGroupGetCount(iShape);
	rgGroups	= new Group[cGroups];

	ASSERT(rgGroups, 
				"Can't allocate memory for material group array");


	ASSERT(cGroups == 1,
				"Assumption was made that NURBS surfaces have only 1 material");


	for (int iGroup	= 0; iGroup < cGroups; iGroup++)
	{

		// material name
		DT_ATTEMPT(DtMtlGetName(iShape, iGroup, &rgGroups[iGroup].m_szMaterial));

		// texture file name
		DT_ATTEMPT(MyDtTextureGetFileName(rgGroups[iGroup].m_szMaterial, &rgGroups[iGroup].m_szTextureFile));

		// diffuse color 
		if (!rgGroups[iGroup].m_szTextureFile)
		{
			DT_ATTEMPT(DtMtlGetDiffuseClr(rgGroups[iGroup].m_szMaterial, 0, 
									   &rgGroups[iGroup].m_fDiffuseRed, 
									   &rgGroups[iGroup].m_fDiffuseGreen,
									   &rgGroups[iGroup].m_fDiffuseBlue));
		}
		else 	// material has a texture
		{
			//	load the diffuse factor into the diffuse components

			int		iMaterial;

			DT_ATTEMPT(DtMtlGetID(iShape, iGroup, &iMaterial));

			MObject	mShader;

			DT_ATTEMPT(DtExt_MtlGetShader(iMaterial, mShader));

			MFnLambertShader	fnShader;

			fnShader.setObject(mShader);

			float	fDiffuseFactor	= fnShader.diffuseCoeff();

			rgGroups[iGroup].m_fDiffuseRed	= fDiffuseFactor;
			rgGroups[iGroup].m_fDiffuseGreen	= fDiffuseFactor;
			rgGroups[iGroup].m_fDiffuseBlue	= fDiffuseFactor;
		}

		// specular color
		DT_ATTEMPT(DtMtlGetSpecularClr(rgGroups[iGroup].m_szMaterial, 0, 
									&rgGroups[iGroup].m_fSpecularRed, 
									&rgGroups[iGroup].m_fSpecularGreen, 
									&rgGroups[iGroup].m_fSpecularBlue));

		// emissive color
		DT_ATTEMPT(DtMtlGetEmissiveClr(rgGroups[iGroup].m_szMaterial, 0, 
									&rgGroups[iGroup].m_fEmissiveRed, 
									&rgGroups[iGroup].m_fEmissiveGreen, 
									&rgGroups[iGroup].m_fEmissiveBlue));

		// power / shininess
		DT_ATTEMPT(DtMtlGetShininess(rgGroups[iGroup].m_szMaterial, 0, &rgGroups[iGroup].m_fShininess));

		// transparency / alpha
		DT_ATTEMPT(DtMtlGetTransparency(rgGroups[iGroup].m_szMaterial, 0, &rgGroups[iGroup].m_fTransparency));
	}
	




	// vertex duplication info (very simple for patch meshes)

	cReps	= (int)rgCVs.length();
	rgReps	= new Rep[cReps];

	ASSERT(rgReps, 
				"Can't allocate memory for rep array");

	for (int iRep = 0; iRep < cReps; iRep++) 
	{
		rgReps[iRep].m_iNormalIdx	= -1;			// patches don't export normal info
		rgReps[iRep].m_iTexCoordIdx	= iRep;
		rgReps[iRep].m_iFirst		= iRep;
		rgReps[iRep].m_iNext		= iRep;

		rgReps[iRep].m_cReps		= 1;
	}



	// skinning info
			

	MObject	objShape;
	MObject objTransform;
	MObject	objInput;

	DT_ATTEMPT(DtExt_ShapeGetShapeNode(iShape, objShape));
	DT_ATTEMPT(DtExt_ShapeGetTransform(iShape, objTransform));




	// load the mesh's world transform (needed if skinning info is found)
	MDagPath	pathTransform;

	MFnDagNode(objTransform).getPath(pathTransform);

	MMatrix		matMeshWorldTransform	= pathTransform.inclusiveMatrix();





	cBones				= 0;
	rgBones				= NULL;

	cMaxBonesPerVertex	= 0;
	cMaxBonesPerFace	= 0;


	MObjectArray	rgobjBones;







	// smooth skinning

	bool*	rgbNonZeroFlagTable	= NULL;		// table of influences vs. vertices
	int*	rgcNonZeros			= NULL;		// array of influence counts 

	bool bFoundSmoothSkin	= false;

	if (objShape.hasFn(MFn::kNurbsSurface)) 		// if this shape is a mesh
	{ 
		// loop through skin clusters
		for (MItDependencyNodes itSkin(MFn::kSkinClusterFilter); !itSkin.isDone(); itSkin.next()) 
		{
			MFnSkinCluster fnSkin(itSkin.item());

			// load input and output geometries
			MObjectArray	rgInputs;
			MObjectArray	rgOutputs;

			fnSkin.getInputGeometry(rgInputs);
			fnSkin.getOutputGeometry(rgOutputs);

			assert(rgInputs.length() == rgOutputs.length());		// ensure that input geometry count 
																	// equals output geometry count

			int	cInputs, cOutputs;

			cInputs	= cOutputs	= (int)rgOutputs.length();

			// loop through the output geometries
			for (int iOutput = 0, iInput = 0; iOutput < cOutputs; iOutput++, iInput++) 
			{
				assert(iOutput == iInput);		// sanity check

				
				if (rgOutputs[iOutput] == objShape) 		// if our shape is one of the output geometries
				{
					MDagPathArray	rgdagpathInfluences;
					
					cBones	= (int)fnSkin.influenceObjects(rgdagpathInfluences, &mStat);

					rgBones	= new Bone[cBones];

					ASSERT(rgBones,
								"Could not allocate memory for bone array");


					// initialize bones
					for (int iBone = 0; iBone < cBones; iBone++) 
					{	// WARNING: not checking for new failure
						rgBones[iBone].m_szName			= new char[256];
						rgBones[iBone].m_cReps			= 0;
						rgBones[iBone].m_cWeights		= 0;
						rgBones[iBone].m_rgiVertices	= new int[cVertices];
						rgBones[iBone].m_rgfWeights		= new float[cVertices];

						g_Strings.add(rgBones[iBone].m_szName);		// housekeeping

						// bone name
						strcpy(rgBones[iBone].m_szName, rgdagpathInfluences[iBone].partialPathName().asChar());

						// matrix offset
						MFnIkJoint fnBone(rgdagpathInfluences[iBone]);

						MObject objBindPose;

						fnBone.findPlug("bindPose").getValue(objBindPose);

						MFnMatrixData fnBindPose(objBindPose);

						(matMeshWorldTransform * fnBindPose.matrix().inverse()).get(rgBones[iBone].m_matOffset);



						rgobjBones.append(rgdagpathInfluences[iBone].node());
					}

					rgcNonZeros			= new int[cVertices];

					ASSERT(rgcNonZeros,
								"Could not allocate memory for non zero count array");

					rgbNonZeroFlagTable	= new bool[cVertices * cBones];

					ASSERT(rgbNonZeroFlagTable,
								"Could not allocate memory for non zero table");

					// bone info; calculate max number of bones per vertex
					cMaxBonesPerVertex = 0;

					int iVertex = 0;

					MFnNurbsSurface fnOutput(rgOutputs[iOutput]);

					MDagPath dagpathOutputShape;
				
					fnOutput.getPath(dagpathOutputShape);

					// loop through the vertices
					for (MItGeometry itGeom(rgOutputs[iOutput]); !itGeom.isDone(); itGeom.next()) 
					{
	
						MFloatArray rgfWeights;

						unsigned cInfs;

						fnSkin.getWeights(dagpathOutputShape, itGeom.component(), rgfWeights, cInfs);

						int a = rgdagpathInfluences.length();
						int b = rgfWeights.length();
						int c = itGeom.count();

						assert(rgdagpathInfluences.length() == rgfWeights.length());
						assert(rgfWeights.length() == cInfs);

						rgcNonZeros[iVertex] = 0;


						float fWeightSum = 0.0f;

						for (int iBone = 0; iBone < cBones; iBone++)
							fWeightSum += rgfWeights[iBone];

						assert(fWeightSum > 0.00001f);

						for (iBone = 0; iBone < cBones; iBone++) 
						{
							rgbNonZeroFlagTable[iBone * cVertices + iVertex]	= false;

							rgfWeights[iBone] = rgfWeights[iBone] / fWeightSum;		// normalize the weight

							if (rgfWeights[iBone] != 0.0f) 
							{
								rgcNonZeros[iVertex]++;

								rgBones[iBone].m_cReps += rgReps[iVertex].m_cReps;
		
								rgBones[iBone].m_rgiVertices[rgBones[iBone].m_cWeights]	= iVertex;							
								rgBones[iBone].m_rgfWeights[rgBones[iBone].m_cWeights]	= rgfWeights[iBone];

								rgbNonZeroFlagTable[iBone * cVertices + iVertex]	= true;

								rgBones[iBone].m_cWeights++;
							}
						}


						if (rgcNonZeros[iVertex] > cMaxBonesPerVertex)
							cMaxBonesPerVertex = rgcNonZeros[iVertex];

						iVertex++;
					}



					// calculate max number of bones per vertex

					cMaxBonesPerFace	= 0;

					for (int iFace = 0; iFace < cFaces; iFace++) 
					{
						int	cBonesPerFace	= 0;

						for (int iBone = 0; iBone < cBones; iBone++) 
						{
							for (int iIndex = 0; iIndex < rgFaces[iFace].m_cIndices; iIndex++) 
							{
								if (rgbNonZeroFlagTable[iBone * cVertices + rgReps[rgFaces[iFace].m_rgIndices[iIndex]].m_iFirst]) 
								{
									cBonesPerFace++;

									break;
								}
							}
						}

						if (cBonesPerFace > cMaxBonesPerFace)
							cMaxBonesPerFace = cBonesPerFace;
					}




					objInput = rgInputs[iInput];

					bFoundSmoothSkin = true;

					break;
				}
			}

			if (bFoundSmoothSkin)
				break;
		}
	}


	delete[] rgcNonZeros;
	delete[] rgbNonZeroFlagTable;



















	// rigid skinning

	rgbNonZeroFlagTable	= NULL;

	bool	bFoundRigidSkin	= false;

	if (!bFoundSmoothSkin) 	
	{
		cBones			= 1;						// zero'th bone is the extra "fake" bone
		int cBonesMax	= 64;
		rgBones			= new Bone[cBonesMax];

		ASSERT(rgBones,
					"Could not allocate memory for bone array");

		rgbNonZeroFlagTable	= new bool[cBonesMax * cVertices];

		ASSERT(rgbNonZeroFlagTable,
					"Could not allocate memory for non-zero flag table");

		// fill non zero table with 0's
		memset(rgbNonZeroFlagTable, 0, cBonesMax * cVertices * sizeof(bool));

		// initialize "fake" iBone
		// WARNING: not checking for new failure
		rgBones[0].m_szName			= new char[256];
		rgBones[0].m_cReps			= 0;
		rgBones[0].m_cWeights		= 0;
		rgBones[0].m_rgfWeights		= new float[cVertices];
		rgBones[0].m_rgiVertices	= new int[cVertices];

		g_Strings.add(rgBones[0].m_szName);							// housekeeping

		strcpy(rgBones[0].m_szName, SCENE_ROOT);					// bone name
	
		matMeshWorldTransform.get(rgBones[0].m_matOffset);			// "fake" bone has identity matrix


		// loop through joint clusters
		for (MItDependencyNodes itCluster(MFn::kJointCluster); !itCluster.isDone(); itCluster.next()) 
		{
			MFnWeightGeometryFilter fnCluster(itCluster.item());

			// load input and output geometries
			MObjectArray	rgInputs;
			MObjectArray	rgOutputs;

			fnCluster.getInputGeometry(rgInputs);
			fnCluster.getOutputGeometry(rgOutputs);

			assert(rgInputs.length() == rgOutputs.length());	// ensure input geometry count equals 
																// output geometry count

			int	cInputs, cOutputs;

			cInputs	= cOutputs	
				= (int)rgOutputs.length();

			// loop through the output geometries
			for (int iOutput = 0, iInput = 0; iOutput < cOutputs; iOutput++, iInput++) 
			{
				assert(iOutput == iInput);
				
				if (rgOutputs[iOutput] == objShape) 	// our shape is one of the output geometries
				{
					bFoundRigidSkin	= true;
		
					assert(rgInputs[iInput] == fnCluster.inputShapeAtIndex(iInput));	// sanity check

					objInput	= rgInputs[iInput];

					// get bone
					MPlug		plgMatrix	= fnCluster.findPlug("matrix", &mStat);

					MPlugArray	rgplgMatrixConnections;

					plgMatrix.connectedTo(rgplgMatrixConnections, true, false);			// get source plugs
					assert(rgplgMatrixConnections.length() == 1);

					MObject	objBone	= rgplgMatrixConnections[0].node();

					assert(objBone.hasFn(MFn::kJoint));

					MFnIkJoint fnBone(objBone);

					char	szBone[64];

					strcpy(szBone, fnBone.name().asChar());

					// find bone's index in current bone list
					for (int iBone = 1; iBone < cBones;	iBone++) 
					{
						if (!strcmp(rgBones[iBone].m_szName, szBone))
							break;
					}
	
					if (iBone == cBones) 	// bone was not found in current bone list
					{
						// add bone
						if (cBones >= cBonesMax) 
						{
							// double array size
							cBonesMax  += cBonesMax;

							Bone*	rgNewBones	= new Bone[cBonesMax];

							ASSERT(rgNewBones, 
										"Could not allocate memory for new bone array");

							memcpy(rgNewBones, rgBones, cBones * sizeof(Bone));

							delete[] rgBones;

							rgBones	= rgNewBones;


							bool*	rgbNewNonZeroFlagTable	= new bool[cBonesMax * cVertices];

							ASSERT(rgbNewNonZeroFlagTable, 
										"Could not allocate memory for new non-zero flag table");

							memset(rgbNewNonZeroFlagTable, 0, cBonesMax * cVertices * sizeof(bool));
							memcpy(rgbNewNonZeroFlagTable, rgbNonZeroFlagTable, cBones * cVertices * sizeof(bool));

							delete[] rgbNonZeroFlagTable;

							rgbNonZeroFlagTable	= rgbNewNonZeroFlagTable;
						}
		
						// initialize iBone
						// WARNING: not checking for new failure
						rgBones[iBone].m_szName			= new char[256];
						rgBones[iBone].m_cReps			= 0;
						rgBones[iBone].m_cWeights		= 0;
						rgBones[iBone].m_rgiVertices	= new int[cVertices];
						rgBones[iBone].m_rgfWeights		= new float[cVertices];

						g_Strings.add(rgBones[iBone].m_szName);							// housekeeping

						strcpy(rgBones[iBone].m_szName, szBone);						// bone name
	
						// matrix info
						MObject objBindPose;

						fnBone.findPlug("bindPose").getValue(objBindPose);

						MFnMatrixData fnBindPose(objBindPose);

						(matMeshWorldTransform * fnBindPose.matrix().inverse()).get(rgBones[iBone].m_matOffset);


						rgobjBones.append(objBone);

						cBones++;
					}



					char	szParent[64];

					bool	bFoundParent	= false;
					MObject	objParent; 

					for (int iParent = 0; iParent < (int)fnBone.parentCount(); iParent++) 
					{
						objParent	= fnBone.parent(iParent);

						MFnDagNode	fnParent(objParent);
						
						strcpy(szParent, fnParent.name().asChar());		// parent's name

						for (int iShape_ = 0; iShape_ < DtShapeGetCount(); iShape_++) 
						{
							char*	szShape;

							DT_ATTEMPT(DtShapeGetName(iShape_, &szShape));

							if (!strcmp(szParent, szShape)) 
							{
								bFoundParent	= true;

								break;
							}
						}

						if (bFoundParent)
							break;
					}
  
					iParent	= 0;

					if (bFoundParent) 	// parent shape found
					{
						// find parent bone's index in current bone list
						for (iParent = 1; iParent < cBones;	iParent++) 
						{
							if (!strcmp(rgBones[iParent].m_szName, szParent)) 
							{
								break;
							}
						}


						if (iParent == cBones) 		// parent bone was not found in current bone list
						{
							// add parent bone
							if (cBones >= cBonesMax) 
							{
								// double array size
								cBonesMax  += cBonesMax;

								Bone*	rgNewBones	= new Bone[cBonesMax];

								ASSERT(rgNewBones, 
											"Could not allocate memory for new bone array");
	
								memcpy(rgNewBones, rgBones, cBones * sizeof(Bone));
	
								delete[] rgBones;

								rgBones	= rgNewBones;

								
								bool*	rgbNewNonZeroFlagTable	= new bool[cBonesMax * cVertices];

								ASSERT(rgbNewNonZeroFlagTable, 
											"Could not allocate memory for new non-zero flag table");

								memset(rgbNewNonZeroFlagTable, 0, cBonesMax * cVertices * sizeof(bool));
								memcpy(rgbNewNonZeroFlagTable, rgbNonZeroFlagTable, cBones * cVertices * sizeof(bool));

								delete[] rgbNonZeroFlagTable;

								rgbNonZeroFlagTable	= rgbNewNonZeroFlagTable;
							}
			
							// initialize iBone
							// WARNING: not checking for new failure
							rgBones[iParent].m_szName		= new char[256];
							rgBones[iParent].m_cReps		= 0;
							rgBones[iParent].m_cWeights		= 0;
							rgBones[iParent].m_rgiVertices	= new int[cVertices];
							rgBones[iParent].m_rgfWeights	= new float[cVertices];
	
							g_Strings.add(rgBones[iParent].m_szName);			// housekeeping
	
							strcpy(rgBones[iParent].m_szName, szParent);		// bone name

							// matrix info
							MObject	objBindPose;
	
							assert(objParent.hasFn(MFn::kJoint));

							MFnIkJoint(objParent).findPlug("bindPose").getValue(objBindPose);
	
							MFnMatrixData fnBindPose(objBindPose);
	
							(matMeshWorldTransform * fnBindPose.matrix().inverse()).get(rgBones[iParent].m_matOffset);


							rgobjBones.append(objParent);

							cBones++;
						}
					}


					// load weights
					MPlug		plgMessage	= fnCluster.findPlug("message");

					MPlugArray	rgplgMessageConnections;

					plgMessage.connectedTo(rgplgMessageConnections, false, true);	// get destination plugs

					assert(rgplgMessageConnections.length() == 1);
					assert(rgplgMessageConnections[0].node().hasFn(MFn::kSet));

					MFnSet fnSet(rgplgMessageConnections[0].node());
				
					MSelectionList list;

					fnSet.getMembers(list, false);

					assert(list.length() == 1);

					MDagPath	path;
					MObject		objComponents;

					list.getDagPath(0, path, objComponents);

					MFloatArray	rgWeights;

					fnCluster.getWeights(path, objComponents, rgWeights);

					assert(objComponents.hasFn(MFn::kDoubleIndexedComponent));


					MFnDoubleIndexedComponent fnComponent(objComponents);

					assert(fnComponent.elementCount() == (int)rgWeights.length());

					// loop through the weights
					for (int iWeight = 0; iWeight < (int)rgWeights.length(); iWeight++) 
					{
						assert(rgWeights[iWeight] <= 1.0f);

						int	iU, iV;

						fnComponent.getElement(iWeight, iU, iV);

						// WARNING: check calculation of iVertex
						int	iVertex	= iU * cCVsInV + iV;
						
						rgBones[iBone].m_rgfWeights[rgBones[iBone].m_cWeights]	= rgWeights[iWeight];
						rgBones[iBone].m_rgiVertices[rgBones[iBone].m_cWeights]	= iVertex;

						rgBones[iBone].m_cReps	 += rgReps[iVertex].m_cReps;
						rgBones[iBone].m_cWeights++;

						rgbNonZeroFlagTable[iBone * cVertices + iVertex]	= true;

						if (rgWeights[iWeight] != 1.0f) 
						{
							rgBones[iParent].m_rgfWeights[rgBones[iParent].m_cWeights]	= 1.0f - rgWeights[iWeight];
							rgBones[iParent].m_rgiVertices[rgBones[iParent].m_cWeights]	= iVertex;

							rgBones[iParent].m_cReps   += rgReps[iVertex].m_cReps;
							rgBones[iParent].m_cWeights++;				// IMPORTANT: Don't change line position

							rgbNonZeroFlagTable[iParent * cVertices + iVertex]	= true;
						}
					}

					break;
				}	// if found our mesh
			}	// loop thru geom's
		}	// loop thru joint clusters


		if (cBones == 1) 		// no rigid skinning found
		{
			delete[] rgBones[0].m_rgfWeights;
			delete[] rgBones[0].m_rgiVertices;

			cBones	= 0;
		}
		else 
		{
			// at most 2 bones per vertex in rigid skinning (i.e. bone + parent)
			cMaxBonesPerVertex	= 2;

			// calculate max number of bones per vertex
			cMaxBonesPerFace	= 0;

			for (int iFace = 0; iFace < cFaces; iFace++) 
			{
				int	cBonesPerFace	= 0;

				for (int iBone = 0; iBone < cBones; iBone++) 
				{
					for (int iIndex = 0; iIndex < rgFaces[iFace].m_cIndices; iIndex++) 
					{
						if (rgbNonZeroFlagTable[iBone * cVertices + rgReps[rgFaces[iFace].m_rgIndices[iIndex]].m_iFirst]) 
						{
							cBonesPerFace++;

							break;
						}
					}
				}

				if (cBonesPerFace > cMaxBonesPerFace)
					cMaxBonesPerFace = cBonesPerFace;
			}
			
		}
	}
				
				
	delete[] rgbNonZeroFlagTable;



















	// reload control vertices if skinning info was found

	if (bFoundSmoothSkin || bFoundRigidSkin)
	{
		delete[]	rgVertices;

		MyDtShapeGetControlPoints(objInput, objShape, &cVertices, &rgVertices);
	}





	// mesh type
	pShape->m_kType			= Mesh::PATCH_MESH;


	EXIT;

	return hr;	
}










HRESULT	LoadPolyMesh
		(
			int		iShape, 
			Mesh*	pShape
		) 
{
	HRESULT	hr		= S_OK;
	MStatus	mStat	= MStatus::kSuccess;


	// set up references

	Mesh::ShapeType&	kType		= pShape->m_kType;

	int&		cReps				= pShape->m_cReps;
	Rep*&		rgReps				= pShape->m_rgReps;

	int&		cVertices			= pShape->m_cVertices;
	DtVec3f*&	rgVertices			= pShape->m_rgVertices;

	int&		cNormals			= pShape->m_cNormals;
	DtVec3f*&	rgNormals			= pShape->m_rgNormals;

	int&		cTexCoords			= pShape->m_cTexCoords;
	DtVec2f*&	rgTexCoords			= pShape->m_rgTexCoords;

	int&		cVertexColors		= pShape->m_cVertexColors;
	DtRGBA*&	rgVertexColors		= pShape->m_rgVertexColors;


	int&		cFaces				= pShape->m_cFaces;
	Face*&		rgFaces				= pShape->m_rgFaces;

	int&		cFaceIndices		= pShape->m_cFaceIndices;

	int&		cGroups				= pShape->m_cGroups;
	Group*&		rgGroups			= pShape->m_rgGroups;


	int&		cBones				= pShape->m_cBones;
	Bone*&		rgBones				= pShape->m_rgBones;

	int&		cMaxBonesPerVertex	= pShape->m_cMaxBonesPerVertex;
	int&		cMaxBonesPerFace	= pShape->m_cMaxBonesPerFace;




	INIT;




	cGroups		= DtGroupGetCount(iShape);
	rgGroups	= new Group[cGroups];

	ASSERT(rgGroups,
				"Could not allocate memory for group array");

	DT_ATTEMPT(DtShapeGetVertices(iShape, &cVertices, &rgVertices));

	DT_ATTEMPT(DtShapeGetNormals(iShape, &cNormals, &rgNormals));

	DT_ATTEMPT(DtShapeGetTextureVertices(iShape, &cTexCoords, &rgTexCoords));
	
	DT_ATTEMPT(DtShapeGetVerticesColor(iShape, &cVertexColors, &rgVertexColors));	
	
	ASSERT(cVertexColors == cVertices,
				"Vertex color count does not match vertex count");


	int	cRepsMax	= cReps	
					= cVertices;
	rgReps			= new Rep[cRepsMax];

	ASSERT(rgReps,
				"Could not allocate memory for rep array");
	
	// initialize reps
	for (int iRep = 0; iRep < cReps; iRep++) 
	{
		rgReps[iRep].m_iTexCoordIdx	= -1;						// signifies "unvisited"
		rgReps[iRep].m_iNormalIdx	= -1;						// signifies "unvisited"
		rgReps[iRep].m_iNext		= iRep;
		rgReps[iRep].m_iFirst		= iRep;

		rgReps[iRep].m_cReps		= 1;
	}


	int	cFacesMax	= cFaces
					= 0;
	rgFaces			= new Face[cFacesMax];

	ASSERT(rgFaces,
				"Could not allocate memory for face array");

	cFaceIndices	= 0;				// total number of indices over all faces


	// go through each group of polygons (grouped by material)
	for (int iGroup = 0; iGroup < cGroups; iGroup++) 
	{
		// material name
		DT_ATTEMPT(DtMtlGetName(iShape, iGroup, &rgGroups[iGroup].m_szMaterial));

		// texture file name

		DT_ATTEMPT(MyDtTextureGetFileName(rgGroups[iGroup].m_szMaterial, &rgGroups[iGroup].m_szTextureFile));


		// diffuse color 
		if (!rgGroups[iGroup].m_szTextureFile)
		{
			DT_ATTEMPT(DtMtlGetDiffuseClr(rgGroups[iGroup].m_szMaterial, 0, 
									   &rgGroups[iGroup].m_fDiffuseRed, 
									   &rgGroups[iGroup].m_fDiffuseGreen, 
									   &rgGroups[iGroup].m_fDiffuseBlue));
		}
		else 
		{	// if the material has a texture then load the diffuse factor into the diffuse components
			int		iMaterial;

			DT_ATTEMPT(DtMtlGetID(iShape, iGroup, &iMaterial));

			MObject	objShader;

			DT_ATTEMPT(DtExt_MtlGetShader(iMaterial, objShader));

			MFnLambertShader	fnShader(objShader);

			float	fDiffuseFactor	= fnShader.diffuseCoeff();

			rgGroups[iGroup].m_fDiffuseRed		= fDiffuseFactor;
			rgGroups[iGroup].m_fDiffuseGreen	= fDiffuseFactor;
			rgGroups[iGroup].m_fDiffuseBlue		= fDiffuseFactor;
		}

		// specular color
		DT_ATTEMPT(DtMtlGetSpecularClr(rgGroups[iGroup].m_szMaterial, 0, 
										&rgGroups[iGroup].m_fSpecularRed, 
										&rgGroups[iGroup].m_fSpecularGreen, 
										&rgGroups[iGroup].m_fSpecularBlue));

		// emissive color
		DT_ATTEMPT(DtMtlGetEmissiveClr(rgGroups[iGroup].m_szMaterial, 0, 
										&rgGroups[iGroup].m_fEmissiveRed, 
										&rgGroups[iGroup].m_fEmissiveGreen, 
										&rgGroups[iGroup].m_fEmissiveBlue));

		// power / shininess
		DT_ATTEMPT(DtMtlGetShininess(rgGroups[iGroup].m_szMaterial, 0, &rgGroups[iGroup].m_fShininess));

		// transparency / alpha
		DT_ATTEMPT(DtMtlGetTransparency(rgGroups[iGroup].m_szMaterial, 0, &rgGroups[iGroup].m_fTransparency));


		int	cPolygons;

		DT_ATTEMPT(DtPolygonGetCount(iShape, iGroup, &cPolygons));


		// increase array size
		cFacesMax  += cPolygons;

		Face*	rgNewFaces	= new Face[cFacesMax];
		
		ASSERT(rgNewFaces,
					"Could not allocate memory for new face array");

		memcpy(rgNewFaces, rgFaces, cFaces * sizeof(Face));

		delete[] rgFaces;

		rgFaces	= rgNewFaces;

		// loop through the polygons in this shape
		for (int iPolygon = 0; iPolygon < cPolygons; iPolygon++) 
		{
			int		cIndices;

			long*	rglVertexIndices;
			long*	rglNormalIndices;
			long*	rglTexCoordIndices;

			DT_ATTEMPT(DtPolygonGetIndices(iPolygon, &cIndices, &rglVertexIndices, &rglNormalIndices, &rglTexCoordIndices));

			cFaceIndices	+=	cIndices;

			// initialize face
			rgFaces[cFaces].m_cIndices	= cIndices;
			rgFaces[cFaces].m_rgIndices	= new int[cIndices];

			ASSERT(rgFaces[cFaces].m_rgIndices,
						"Could not allocate memory for face indices array");
			
			rgFaces[cFaces].m_iGroup	= iGroup;

			// no need for the following 2 lines
////		memcpy(rgFaces[cFaces].m_rgNormalIndices, rgNormalIndices, cIndices * sizeof(long));
//			memcpy(rgFaces[cFaces].m_rgIndices, rgVertexIndices, cIndices * sizeof(long));

			// create repetition if texture coords differ
			for (int iIndex = 0; iIndex < cIndices; iIndex++) 
			{
				int iRep	= rglVertexIndices[iIndex];
				int iLastRep;

				bool bFound = false;

				do 
				{
					if (rglTexCoordIndices[iIndex] == rgReps[iRep].m_iTexCoordIdx && rglNormalIndices[iIndex] == rgReps[iRep].m_iNormalIdx)
						bFound = true;

					iLastRep	= iRep;
					iRep		= rgReps[iRep].m_iNext;
				} while (!bFound && rgReps[iRep].m_iNext != rgReps[iRep].m_iFirst);


				if (bFound) 
				{
					rgFaces[cFaces].m_rgIndices[iIndex]	= iLastRep;	// update face indices
				}
				else 
				{
					if (rgReps[rgReps[iRep].m_iFirst].m_iTexCoordIdx == -1) 	// if first time through this rep
					{
						// initialize index into lump of texture coordinates
						rgReps[rgReps[iRep].m_iFirst].m_iTexCoordIdx	= rglTexCoordIndices[iIndex];
						rgReps[rgReps[iRep].m_iFirst].m_iNormalIdx		= rglNormalIndices[iIndex];

						// update face indices
						rgFaces[cFaces].m_rgIndices[iIndex] = rgReps[iRep].m_iFirst;
					}
					else 
					{
						// append new rep 

						if (cReps >= cRepsMax) 
						{
							// double array size
							cRepsMax += cRepsMax;

							Rep*	rgNewReps	= new Rep[cRepsMax];

							ASSERT(rgNewReps,
										"Could not allocate memory for new rep array");

							memcpy(rgNewReps, rgReps, cReps * sizeof(Rep));

							delete[] rgReps;

							rgReps	  = rgNewReps;
						}

						// create new rep at the end of the array
						rgReps[cReps].m_iTexCoordIdx	= rglTexCoordIndices[iIndex];
						rgReps[cReps].m_iNormalIdx		= rglNormalIndices[iIndex];
						rgReps[cReps].m_iFirst			= rgReps[iRep].m_iFirst;
						rgReps[cReps].m_iNext			= rgReps[iRep].m_iFirst;

						rgReps[iRep].m_iNext			= cReps;

						// increment rep count at the first rep
						rgReps[rgReps[iRep].m_iFirst].m_cReps++;


						// update face indices
						rgFaces[cFaces].m_rgIndices[iIndex] = cReps;	

						cReps++;
					}
				}
			}

			cFaces++;
		}
	}







			

	
	// skinning info
			

	MObject	objShape;
	MObject objTransform;
	MObject	objInput;

	DT_ATTEMPT(DtExt_ShapeGetShapeNode(iShape, objShape));
	DT_ATTEMPT(DtExt_ShapeGetTransform(iShape, objTransform));




	// load the mesh's world transform (needed if skinning info is found)
	MDagPath	pathTransform;

	MFnDagNode(objTransform).getPath(pathTransform);

	MMatrix		matMeshWorldTransform	= pathTransform.inclusiveMatrix();





	cBones				= 0;
	rgBones				= NULL;

	cMaxBonesPerVertex	= 0;
	cMaxBonesPerFace	= 0;


	MObjectArray	rgobjBones;







	// smooth skinning

	bool*	rgbNonZeroFlagTable	= NULL;		// table of influences vs. vertices
	int*	rgcNonZeros			= NULL;		// array of influence counts 

	bool bFoundSmoothSkin	= false;

	if (objShape.hasFn(MFn::kMesh)) 		// if this shape is a mesh
	{
		// loop through skin clusters
		for (MItDependencyNodes itSkin(MFn::kSkinClusterFilter); !itSkin.isDone(); itSkin.next()) 
		{
			MFnSkinCluster fnSkin(itSkin.item());

			// load input and output geometries
			MObjectArray	rgInputs;
			MObjectArray	rgOutputs;

			fnSkin.getInputGeometry(rgInputs);
			fnSkin.getOutputGeometry(rgOutputs);

			assert(rgInputs.length() == rgOutputs.length());		// ensure that input geometry count 
																	// equals output geometry count

			int	cInputs, cOutputs;

			cInputs	= cOutputs	= (int)rgOutputs.length();

			// loop through the output geometries
			for (int iOutput = 0, iInput = 0; iOutput < cOutputs; iOutput++, iInput++) 
			{
				assert(iOutput == iInput);		// sanity check

				
				if (rgOutputs[iOutput] == objShape) 		// if our shape is one of the output geometries
				{
					MDagPathArray	rgdagpathInfluences;
					
					cBones	= (int)fnSkin.influenceObjects(rgdagpathInfluences, &mStat);

					rgBones	= new Bone[cBones];

					ASSERT(rgBones,
								"Could not allocate memory for bone array");


					// initialize bones
					for (int iBone = 0; iBone < cBones; iBone++) 
					{	// WARNING: not checking for new failure
						rgBones[iBone].m_szName			= new char[256];
						rgBones[iBone].m_cReps			= 0;
						rgBones[iBone].m_cWeights		= 0;
						rgBones[iBone].m_rgiVertices	= new int[cVertices];
						rgBones[iBone].m_rgfWeights		= new float[cVertices];

						g_Strings.add(rgBones[iBone].m_szName);		// housekeeping

						// bone name
						strcpy(rgBones[iBone].m_szName, rgdagpathInfluences[iBone].partialPathName().asChar());

						// matrix offset
						MFnIkJoint fnBone(rgdagpathInfluences[iBone]);

						MObject objBindPose;

						fnBone.findPlug("bindPose").getValue(objBindPose);

						MFnMatrixData fnBindPose(objBindPose);

						(matMeshWorldTransform * fnBindPose.matrix().inverse()).get(rgBones[iBone].m_matOffset);



						rgobjBones.append(rgdagpathInfluences[iBone].node());
					}

					rgcNonZeros			= new int[cVertices];

					ASSERT(rgcNonZeros,
								"Could not allocate memory for non zero count array");

					rgbNonZeroFlagTable	= new bool[cVertices * cBones];

					ASSERT(rgbNonZeroFlagTable,
								"Could not allocate memory for non zero table");

					// bone info; calculate max number of bones per vertex
					cMaxBonesPerVertex = 0;

					int iVertex = 0;

					MFnMesh fnOutput(rgOutputs[iOutput]);

					MDagPath dagpathOutputShape;
				
					fnOutput.getPath(dagpathOutputShape);

					// loop through the vertices
					for (MItGeometry itGeom(rgOutputs[iOutput]); !itGeom.isDone(); itGeom.next()) 
					{
						MFloatArray rgfWeights;

						unsigned cInfs;

						fnSkin.getWeights(dagpathOutputShape, itGeom.component(), rgfWeights, cInfs);

						assert(rgdagpathInfluences.length() == rgfWeights.length());
						assert(rgfWeights.length() == cInfs);

						rgcNonZeros[iVertex] = 0;


						float fWeightSum = 0.0f;

						for (int iBone = 0; iBone < cBones; iBone++)
							fWeightSum += rgfWeights[iBone];

						assert(fWeightSum > 0.00001f);

						for (iBone = 0; iBone < cBones; iBone++) 
						{
							rgbNonZeroFlagTable[iBone * cVertices + iVertex]	= false;

							rgfWeights[iBone] = rgfWeights[iBone] / fWeightSum;		// normalize the weight

							if (rgfWeights[iBone] != 0.0f) 
							{
								rgcNonZeros[iVertex]++;

								rgBones[iBone].m_cReps += rgReps[iVertex].m_cReps;
		
								rgBones[iBone].m_rgiVertices[rgBones[iBone].m_cWeights]	= iVertex;							
								rgBones[iBone].m_rgfWeights[rgBones[iBone].m_cWeights]	= rgfWeights[iBone];

								rgbNonZeroFlagTable[iBone * cVertices + iVertex]	= true;

								rgBones[iBone].m_cWeights++;
							}
						}


						if (rgcNonZeros[iVertex] > cMaxBonesPerVertex)
							cMaxBonesPerVertex = rgcNonZeros[iVertex];

						iVertex++;
					}



					// calculate max number of bones per vertex

					cMaxBonesPerFace	= 0;

					for (int iFace = 0; iFace < cFaces; iFace++) 
					{
						int	cBonesPerFace	= 0;

						for (int iBone = 0; iBone < cBones; iBone++) 
						{
							for (int iIndex = 0; iIndex < rgFaces[iFace].m_cIndices; iIndex++) 
							{
								if (rgbNonZeroFlagTable[iBone * cVertices + rgReps[rgFaces[iFace].m_rgIndices[iIndex]].m_iFirst]) 
								{
									cBonesPerFace++;

									break;
								}
							}
						}

						if (cBonesPerFace > cMaxBonesPerFace)
							cMaxBonesPerFace = cBonesPerFace;
					}





					objInput = rgInputs[iInput];

					bFoundSmoothSkin = true;

					break;
				}
			}

			if (bFoundSmoothSkin)
				break;
		}
	}


	delete[] rgcNonZeros;
	delete[] rgbNonZeroFlagTable;

















	// rigid skinning

	rgbNonZeroFlagTable	= NULL;

	bool	bFoundRigidSkin	= false;

	if (!bFoundSmoothSkin && objShape.hasFn(MFn::kMesh)) 	// shape is a mesh 
	{
		cBones			= 1;						// zero'th bone is the extra "fake" bone
		int cBonesMax	= 64;
		rgBones			= new Bone[cBonesMax];

		ASSERT(rgBones,
					"Could not allocate memory for bone array");

		rgbNonZeroFlagTable	= new bool[cBonesMax * cVertices];

		ASSERT(rgbNonZeroFlagTable,
					"Could not allocate memory for non-zero flag table");

		// fill non zero table with 0's
		memset(rgbNonZeroFlagTable, 0, cBonesMax * cVertices * sizeof(bool));

		// initialize "fake" iBone
		// WARNING: not checking for new failure
		rgBones[0].m_szName			= new char[256];
		rgBones[0].m_cReps			= 0;
		rgBones[0].m_cWeights		= 0;
		rgBones[0].m_rgfWeights		= new float[cVertices];
		rgBones[0].m_rgiVertices	= new int[cVertices];

		g_Strings.add(rgBones[0].m_szName);							// housekeeping

		strcpy(rgBones[0].m_szName, SCENE_ROOT);					// bone name
	
		matMeshWorldTransform.get(rgBones[0].m_matOffset);			// "fake" bone has identity matrix


		// loop through joint clusters
		for (MItDependencyNodes itCluster(MFn::kJointCluster); !itCluster.isDone(); itCluster.next()) 
		{
			MFnWeightGeometryFilter fnCluster(itCluster.item());

			// load input and output geometries
			MObjectArray	rgInputs;
			MObjectArray	rgOutputs;

			fnCluster.getInputGeometry(rgInputs);
			fnCluster.getOutputGeometry(rgOutputs);

			assert(rgInputs.length() == rgOutputs.length());	// ensure input geometry count equals 
																// output geometry count

			int	cInputs, cOutputs;

			cInputs	= cOutputs	
				= (int)rgOutputs.length();

			// loop through the output geometries
			for (int iOutput = 0, iInput = 0; iOutput < cOutputs; iOutput++, iInput++) 
			{
				assert(iOutput == iInput);
				
				if (rgOutputs[iOutput] == objShape) 	// our shape is one of the output geometries
				{
					bFoundRigidSkin	= true;
		
					assert(rgInputs[iInput] == fnCluster.inputShapeAtIndex(iInput));	// sanity check

					objInput	= rgInputs[iInput];

					// get bone
					MPlug		plgMatrix	= fnCluster.findPlug("matrix", &mStat);

					MPlugArray	rgplgMatrixConnections;

					plgMatrix.connectedTo(rgplgMatrixConnections, true, false);			// get source plugs
					assert(rgplgMatrixConnections.length() == 1);

					MObject	objBone	= rgplgMatrixConnections[0].node();

					assert(objBone.hasFn(MFn::kJoint));

					MFnIkJoint fnBone(objBone);

					char	szBone[64];

					strcpy(szBone, fnBone.name().asChar());

					// find bone's index in current bone list
					for (int iBone = 1; iBone < cBones;	iBone++) 
					{
						if (!strcmp(rgBones[iBone].m_szName, szBone))
							break;
					}
	
					if (iBone == cBones) 	// bone was not found in current bone list
					{
						// add bone
						if (cBones >= cBonesMax) 
						{
							// double array size
							cBonesMax  += cBonesMax;

							Bone*	rgNewBones	= new Bone[cBonesMax];

							ASSERT(rgNewBones, 
										"Could not allocate memory for new bone array");

							memcpy(rgNewBones, rgBones, cBones * sizeof(Bone));

							delete[] rgBones;

							rgBones	= rgNewBones;


							bool*	rgbNewNonZeroFlagTable	= new bool[cBonesMax * cVertices];

							ASSERT(rgbNewNonZeroFlagTable, 
										"Could not allocate memory for new non-zero flag table");

							memset(rgbNewNonZeroFlagTable, 0, cBonesMax * cVertices * sizeof(bool));
							memcpy(rgbNewNonZeroFlagTable, rgbNonZeroFlagTable, cBones * cVertices * sizeof(bool));

							delete[] rgbNonZeroFlagTable;

							rgbNonZeroFlagTable	= rgbNewNonZeroFlagTable;
						}
		
						// initialize iBone
						// WARNING: not checking for new failure
						rgBones[iBone].m_szName			= new char[256];
						rgBones[iBone].m_cReps			= 0;
						rgBones[iBone].m_cWeights		= 0;
						rgBones[iBone].m_rgiVertices	= new int[cVertices];
						rgBones[iBone].m_rgfWeights		= new float[cVertices];

						g_Strings.add(rgBones[iBone].m_szName);							// housekeeping

						strcpy(rgBones[iBone].m_szName, szBone);						// bone name
	
						// matrix info
						MObject objBindPose;

						fnBone.findPlug("bindPose").getValue(objBindPose);

						MFnMatrixData fnBindPose(objBindPose);

						(matMeshWorldTransform * fnBindPose.matrix().inverse()).get(rgBones[iBone].m_matOffset);


						rgobjBones.append(objBone);

						cBones++;
					}



					char	szParent[64];

					bool	bFoundParent	= false;
					MObject	objParent;

					for (int iParent = 0; iParent < (int)fnBone.parentCount(); iParent++) 
					{
						objParent	= fnBone.parent(iParent);

						MFnDagNode	fnParent(objParent);
						
						strcpy(szParent, fnParent.name().asChar());		// parent's name

						for (int iShape_ = 0; iShape_ < DtShapeGetCount(); iShape_++) 
						{
							char*	szShape;

							DT_ATTEMPT(DtShapeGetName(iShape_, &szShape));

							if (!strcmp(szParent, szShape)) 
							{
								bFoundParent	= true;

								break;
							}
						}

						if (bFoundParent)
							break;
					}

					iParent	= 0;

					if (bFoundParent) 	// parent shape found
					{
						// find parent bone's index in current bone list
						for (iParent = 1; iParent < cBones;	iParent++) 
						{
							if (!strcmp(rgBones[iParent].m_szName, szParent)) 
							{
								break;
							}
						}


						if (iParent == cBones) 		// parent bone was not found in current bone list
						{
							// add parent bone
							if (cBones >= cBonesMax) 
							{
								// double array size
								cBonesMax  += cBonesMax;

								Bone*	rgNewBones	= new Bone[cBonesMax];

								ASSERT(rgNewBones, 
											"Could not allocate memory for new bone array");
	
								memcpy(rgNewBones, rgBones, cBones * sizeof(Bone));
	
								delete[] rgBones;

								rgBones	= rgNewBones;

								
								bool*	rgbNewNonZeroFlagTable	= new bool[cBonesMax * cVertices];

								ASSERT(rgbNewNonZeroFlagTable, 
											"Could not allocate memory for new non-zero flag table");

								memset(rgbNewNonZeroFlagTable, 0, cBonesMax * cVertices * sizeof(bool));
								memcpy(rgbNewNonZeroFlagTable, rgbNonZeroFlagTable, cBones * cVertices * sizeof(bool));

								delete[] rgbNonZeroFlagTable;

								rgbNonZeroFlagTable	= rgbNewNonZeroFlagTable;
							}
			
							// initialize iBone
							// WARNING: not checking for new failure
							rgBones[iParent].m_szName		= new char[256];
							rgBones[iParent].m_cReps		= 0;
							rgBones[iParent].m_cWeights		= 0;
							rgBones[iParent].m_rgiVertices	= new int[cVertices];
							rgBones[iParent].m_rgfWeights	= new float[cVertices];
	
							g_Strings.add(rgBones[iParent].m_szName);						// housekeeping
	
							strcpy(rgBones[iParent].m_szName, szParent);		// bone name

							// matrix info
							MObject	objBindPose;
	
							assert(objParent.hasFn(MFn::kJoint));

							MFnIkJoint(objParent).findPlug("bindPose").getValue(objBindPose);
	
							MFnMatrixData fnBindPose(objBindPose);
	
							(matMeshWorldTransform * fnBindPose.matrix().inverse()).get(rgBones[iParent].m_matOffset);


							rgobjBones.append(objParent);

							cBones++;
						}
					}


					// load weights
					MPlug		plgMessage	= fnCluster.findPlug("message");

					MPlugArray	rgplgMessageConnections;

					plgMessage.connectedTo(rgplgMessageConnections, false, true);	// get destination plugs

					assert(rgplgMessageConnections.length() == 1);
					assert(rgplgMessageConnections[0].node().hasFn(MFn::kSet));

					MFnSet fnSet(rgplgMessageConnections[0].node());
				
					MSelectionList list;

					fnSet.getMembers(list, false);

					assert(list.length() == 1);

					MDagPath	path;
					MObject		objComponents;

					list.getDagPath(0, path, objComponents);

					MFloatArray	rgWeights;

					fnCluster.getWeights(path, objComponents, rgWeights);

					MFnSingleIndexedComponent fnComponent(objComponents);

					assert (fnComponent.elementCount() == (int)rgWeights.length());

					// loop through the weights
					for (int iWeight = 0; iWeight < (int)rgWeights.length(); iWeight++) 
					{
						assert(rgWeights[iWeight] <= 1.0f);

						int	iVertex	= fnComponent.element(iWeight);
						
						rgBones[iBone].m_rgfWeights[rgBones[iBone].m_cWeights]	= rgWeights[iWeight];
						rgBones[iBone].m_rgiVertices[rgBones[iBone].m_cWeights]	= iVertex;

						rgBones[iBone].m_cReps	 += rgReps[iVertex].m_cReps;
						rgBones[iBone].m_cWeights++;

						rgbNonZeroFlagTable[iBone * cVertices + iVertex]	= true;

						if (rgWeights[iWeight] != 1.0f) 
						{
							rgBones[iParent].m_rgfWeights[rgBones[iParent].m_cWeights]	= 1.0f - rgWeights[iWeight];
							rgBones[iParent].m_rgiVertices[rgBones[iParent].m_cWeights]	= iVertex;

							rgBones[iParent].m_cReps   += rgReps[iVertex].m_cReps;
							rgBones[iParent].m_cWeights++;				// IMPORTANT: Don't change line position

							rgbNonZeroFlagTable[iParent * cVertices + iVertex]	= true;
						}
					}

					break;
				}	// if found our mesh
			}	// loop thru geom's
		}	// loop thru joint clusters


		if (cBones == 1) 		// no rigid skinning found
		{
			delete[] rgBones[0].m_rgfWeights;
			delete[] rgBones[0].m_rgiVertices;

			cBones	= 0;
		}
		else 
		{
			// at most 2 bones per vertex in rigid skinning (i.e. bone + parent)
			cMaxBonesPerVertex	= 2;

			// calculate max number of bones per vertex
			cMaxBonesPerFace	= 0;

			for (int iFace = 0; iFace < cFaces; iFace++) 
			{
				int	cBonesPerFace	= 0;

				for (int iBone = 0; iBone < cBones; iBone++) 
				{
					for (int iIndex = 0; iIndex < rgFaces[iFace].m_cIndices; iIndex++) 
					{
						if (rgbNonZeroFlagTable[iBone * cVertices + rgReps[rgFaces[iFace].m_rgIndices[iIndex]].m_iFirst]) 
						{
							cBonesPerFace++;

							break;
						}
					}
				}

				if (cBonesPerFace > cMaxBonesPerFace)
					cMaxBonesPerFace = cBonesPerFace;
			}



			
			
			
			
		}
	}
				
				
	delete[] rgbNonZeroFlagTable;



	// load lumps of control vertex data

	if (cBones == 0)		// no skinning found
	{
		DT_ATTEMPT(MyDtShapeGetVertices(iShape, &cVertices, &rgVertices));				// lump of vertices
		DT_ATTEMPT(MyDtShapeGetNormals(iShape, &cNormals, &rgNormals));					// lump of normals
	}
	else					// skinning found
	{
		DT_ATTEMPT(MyDtShapeGetVertices(objInput, objShape, &cVertices, &rgVertices));	// lump of vertices
		DT_ATTEMPT(MyDtShapeGetNormals(objInput, objShape, &cNormals, &rgNormals));		// lump of normals
	}

	DT_ATTEMPT(MyDtShapeGetTextureVertices(iShape, &cTexCoords, &rgTexCoords));			// lump of texture coords
	DT_ATTEMPT(MyDtShapeGetVerticesColor(iShape, &cVertexColors, &rgVertexColors));		// lump of vertex colors



	// mesh type

	pShape->m_kType				= Mesh::POLY_MESH;


	EXIT;


	return	hr;
}
















HRESULT	LoadShape
		(
			int		iShape, 
			Mesh*	pShape
		)
{
	HRESULT	hr	= S_OK;

	INIT;

	if (MyDtShapeIsJoint(iShape)) 
	{
		pShape->m_kType	= Mesh::BONE;
	}
	else if (g_bExportPatches && MyDtShapeIsPatchMesh(iShape)) 
	{
		HR_ATTEMPT(LoadPatchMesh(iShape, pShape),
			"Could not load patch-mesh");
	}
	else 
	{
		HR_ATTEMPT(LoadPolyMesh(iShape, pShape),
			"Could not load poly-mesh");
	}

	EXIT;

	return	hr;
}
























HRESULT	AddSkin
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pShapeDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{
	HRESULT	hr	= S_OK;


	LPDIRECTXFILEDATA	pSkinDataObject	= NULL;


	PBYTE	pbSkinData	= NULL;



	INIT;



	int		cbSkinSize	= sizeof(WORD)		// nMaxSkinWeightsPerVertex
						+ sizeof(WORD)		// nMaxSkinWeightsPerFace
						+ sizeof(WORD);		// nBones

	PBYTE	pbSkinCurr	= pbSkinData	= new BYTE[cbSkinSize];

	ASSERT(pbSkinData,
				"Could not allocate memory for pbSkinData");


	// nMaxSkinWeightsPerVertex
	WRITE_WORD(pbSkinCurr, ((WORD)pShape->m_cMaxBonesPerVertex));

	// nMaxSkinWeightsPerFace
	WRITE_WORD(pbSkinCurr, ((WORD)pShape->m_cMaxBonesPerFace));

	// nBones
	WRITE_WORD(pbSkinCurr, ((WORD)pShape->m_cBones));


	HR_ATTEMPT(pxofSave->CreateDataObject(DXFILEOBJ_XSkinMeshHeader, NULL, NULL, cbSkinSize, pbSkinData, &pSkinDataObject),
				"Could not create pSkinDataObject");


	HR_ATTEMPT(pShapeDataObject->AddDataObject(pSkinDataObject),
				"Could not add pSkinDataObject to pShapeDataObject");



	EXIT;



	delete[] pbSkinData;

	if (pSkinDataObject)
		pSkinDataObject->Release();


	if (FAILED(hr))
		return hr;


	// SkinWeights
	for (int iBone = 0; iBone < pShape->m_cBones; iBone++) 
	{
		LPDIRECTXFILEDATA	pBoneDataObject	= NULL;

		PBYTE	pbBoneData	= NULL;


		INIT;

		int		cbBoneSize	= sizeof(char*)									// transformNodeName
							+ sizeof(DWORD)									// nWeights
							+ sizeof(DWORD) * pShape->m_rgBones[iBone].m_cReps	// vertexIndices[nWeights]
							+ sizeof(float) * pShape->m_rgBones[iBone].m_cReps	// weights[nWeights]
							+ sizeof(float) * 16;							// matrixOffset

		PBYTE	pbBoneCurr	= pbBoneData	= new BYTE[cbBoneSize];

		ASSERT(pbBoneData,
					"Could not allocate memory for pbBoneData.");


		// transformNodeName
		WRITE_PCHAR(pbBoneCurr, ((char*)pShape->m_rgBones[iBone].m_szName));

		// nWeights
		WRITE_DWORD(pbBoneCurr, ((DWORD)pShape->m_rgBones[iBone].m_cReps));

		// vertexIndices[nWeights]
		for (int iVertex = 0; iVertex < pShape->m_rgBones[iBone].m_cWeights; iVertex++) 
		{
			int iRep = pShape->m_rgBones[iBone].m_rgiVertices[iVertex];

			do 
			{
				WRITE_DWORD(pbBoneCurr, ((DWORD)iRep));

				iRep = pShape->m_rgReps[iRep].m_iNext;
			} while (iRep != pShape->m_rgReps[iRep].m_iFirst);
		}

		// weights[nWeights]
		for (iVertex = 0; iVertex < pShape->m_rgBones[iBone].m_cWeights; iVertex++)
		{
			for (int iRep = 0; iRep < pShape->m_rgReps[pShape->m_rgBones[iBone].m_rgiVertices[iVertex]].m_cReps; iRep++)
			{
				WRITE_FLOAT(pbBoneCurr, pShape->m_rgBones[iBone].m_rgfWeights[iVertex]);
			}
		}

		// matrixOffset
		for (int iRow = 0; iRow < 4; iRow++)
		{
			for (int iCol = 0; iCol < 4; iCol++)
			{
				WRITE_FLOAT(pbBoneCurr, pShape->m_rgBones[iBone].m_matOffset[iRow][iCol]);
			}
		}


		HR_ATTEMPT(pxofSave->CreateDataObject(DXFILEOBJ_SkinWeights, NULL, NULL, cbBoneSize, pbBoneData, &pBoneDataObject),
					"Could not create pBoneDataObject");


		HR_ATTEMPT(pShapeDataObject->AddDataObject(pBoneDataObject),
					"Could not add pBoneDataObject to pShapeDataObject");



		EXIT;



		delete[] pbBoneData;

		if (pBoneDataObject)
			pBoneDataObject->Release();


		if (FAILED(hr))
			return hr;
	}


	return hr;
}










HRESULT	AddNormals
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pShapeDataObject, 
			LPDIRECTXFILESAVEOBJECT pxofSave
		) 
{
	HRESULT	hr	= S_OK;

	LPDIRECTXFILEDATA	pNormalsDataObject	= NULL;

	PBYTE	pbNormalsData	= NULL;

	INIT;
	
	int		cbNormalsSize	= sizeof(DWORD)													// nNormals
							+ pShape->m_cReps * (3 * sizeof(float))							// normals
							+ sizeof(DWORD)													// nFaceNormals
							+ (pShape->m_cFaces + pShape->m_cFaceIndices) * sizeof(DWORD);	// faceNormals

	PBYTE	pbNormalsCurr	= pbNormalsData	
							= new BYTE[cbNormalsSize];

	ASSERT(pbNormalsCurr, "Could not allocate memory for pbNormalsData");


	// nNormals
	WRITE_DWORD(pbNormalsCurr, ((DWORD)pShape->m_cReps));

	// normals
	int iRep;

	for (iRep = 0; iRep < pShape->m_cReps; iRep++) 
	{
		if (pShape->m_rgReps[iRep].m_iNormalIdx == -1)		// no normal index found
        {
			WRITE_FLOAT(pbNormalsCurr, 1.0f);
			WRITE_FLOAT(pbNormalsCurr, 0.0f);
			WRITE_FLOAT(pbNormalsCurr, 0.0f);
		}
		else 
        {
			WRITE_FLOAT(pbNormalsCurr, pShape->m_rgNormals[pShape->m_rgReps[iRep].m_iNormalIdx].vec[0]);
			WRITE_FLOAT(pbNormalsCurr, pShape->m_rgNormals[pShape->m_rgReps[iRep].m_iNormalIdx].vec[1]);
			WRITE_FLOAT(pbNormalsCurr, pShape->m_rgNormals[pShape->m_rgReps[iRep].m_iNormalIdx].vec[2]);
		}
	}

	// nFaceNormals
	WRITE_DWORD(pbNormalsCurr, ((DWORD)pShape->m_cFaces));

	// faceNormals
	int iFace;

	for (iFace = 0; iFace < pShape->m_cFaces; iFace++) 
	{
		WRITE_DWORD(pbNormalsCurr, ((DWORD)pShape->m_rgFaces[iFace].m_cIndices));

		for (int iIndex = 0; iIndex < pShape->m_rgFaces[iFace].m_cIndices; iIndex++)
			WRITE_DWORD(pbNormalsCurr, ((DWORD)pShape->m_rgFaces[iFace].m_rgIndices[iIndex]));
	}


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMMeshNormals, NULL, NULL, cbNormalsSize, pbNormalsData, &pNormalsDataObject),
				"Could not create normals data object")


	HR_ATTEMPT(pShapeDataObject->AddDataObject(pNormalsDataObject),
				"Could not add pNormalsDataObject to pShapeDataObject")



	EXIT;

	// clean up
	delete[] pbNormalsData;

	if (pNormalsDataObject)
		pNormalsDataObject->Release();

	return hr;
}










HRESULT	AddTexCoords
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pShapeDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{
	HRESULT	hr	= S_OK;

	LPDIRECTXFILEDATA	pTexCoordsDataObject	= NULL;

	PBYTE	pbTexCoordsData	= NULL;


	INIT;


	int		cbTexCoordsSize	= sizeof(DWORD)							// nTextureCoords
							+ pShape->m_cReps * (2 * sizeof(float));	// textureCoords

	PBYTE	pbTexCoordsCurr	= pbTexCoordsData	= new BYTE[cbTexCoordsSize];

	ASSERT(pbTexCoordsData,
				"Could not allocate memory for pbTexCoordsData");


	// nTextureCoords
	WRITE_DWORD(pbTexCoordsCurr, ((DWORD)pShape->m_cReps));

	// textureCoords
	for (int iRep = 0; iRep < pShape->m_cReps; iRep++) 
	{
		if (pShape->m_rgReps[iRep].m_iTexCoordIdx == -1)
		{
			WRITE_FLOAT(pbTexCoordsCurr, 0.0f);
			WRITE_FLOAT(pbTexCoordsCurr, 0.0f);
		}
		else 
		{
			WRITE_FLOAT(pbTexCoordsCurr, g_iFlipU * pShape->m_rgTexCoords[pShape->m_rgReps[iRep].m_iTexCoordIdx].vec[0]);
			WRITE_FLOAT(pbTexCoordsCurr, g_iFlipV * pShape->m_rgTexCoords[pShape->m_rgReps[iRep].m_iTexCoordIdx].vec[1]);
		}
	}

	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMMeshTextureCoords, NULL, NULL, cbTexCoordsSize, pbTexCoordsData, &pTexCoordsDataObject),
				"Could not create pTexCoordsDataObject");


	HR_ATTEMPT(pShapeDataObject->AddDataObject(pTexCoordsDataObject),
				"Could not add data object");


	EXIT;


	delete[] pbTexCoordsData;

	if (pTexCoordsDataObject)
		pTexCoordsDataObject->Release();

	return hr;
}







HRESULT	AddMaterialList
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pShapeDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{
	HRESULT				hr						= S_OK;

	LPDIRECTXFILEDATA	pMaterialsDataObject	= NULL;

	PBYTE				pbMaterialsData			= NULL;
	
	INIT;

	int		cbMaterialsSize	= sizeof(DWORD)						// nMaterials
							+ sizeof(DWORD)						// nFaceIndexes
							+ pShape->m_cFaces * sizeof(DWORD);	// FaceIndexes

	PBYTE	pbMaterialsCurr	= pbMaterialsData	= new BYTE[cbMaterialsSize];

	ASSERT(pbMaterialsCurr, 
				"Could not allocate memory for pbMaterialsData");


	// nMaterials
	WRITE_DWORD(pbMaterialsCurr, ((DWORD)pShape->m_cGroups));

	// nFaceIndexes
	WRITE_DWORD(pbMaterialsCurr, ((DWORD)pShape->m_cFaces));

	// FaceIndexes
	for (int iFace = 0; iFace < pShape->m_cFaces; iFace++)
		WRITE_DWORD(pbMaterialsCurr, pShape->m_rgFaces[iFace].m_iGroup);


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMMeshMaterialList, NULL, NULL, cbMaterialsSize, pbMaterialsData, &pMaterialsDataObject),
				"Could not create pMaterialsDataObject");

	// material data
	for (int iGroup = 0; iGroup < pShape->m_cGroups; iGroup++) 
	{
		LPDIRECTXFILEDATA	pMaterialDataObject	= NULL;
		LPDIRECTXFILEDATA	pTextureDataObject	= NULL;

		PBYTE				pbMaterialData		= NULL;

		INIT;

		int		cbMaterialSize	= 4 * sizeof(float)		// faceColor
								+ sizeof(float)			// power
								+ 3 * sizeof(float)		// specularColor
								+ 3 * sizeof(float);	// emissiveColor

		PBYTE	pbMaterialCurr	= pbMaterialData	= new BYTE[cbMaterialSize];

		ASSERT(pbMaterialCurr,
					"Could not allocate memory for pbMaterialData");


		// faceColor
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fDiffuseRed);
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fDiffuseGreen);
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fDiffuseBlue);
		WRITE_FLOAT(pbMaterialCurr, (1.0f - pShape->m_rgGroups[iGroup].m_fTransparency));

		// power
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fShininess);
		
		// specularColor
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fSpecularRed);
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fSpecularGreen);
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fSpecularBlue);

		// emissiveColor
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fEmissiveRed);
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fEmissiveGreen);
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fEmissiveBlue);


		HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMMaterial, NULL, NULL, cbMaterialSize, pbMaterialData, &pMaterialDataObject),
					"Could not create pMaterialDataObject");


		// TextureFilename		
		if (pShape->m_rgGroups[iGroup].m_szTextureFile) 
		{
			int		cbTextureSize	= sizeof(char**);

			HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMTextureFilename, NULL, NULL, cbTextureSize, &pShape->m_rgGroups[iGroup].m_szTextureFile, &pTextureDataObject),
						"Could not create pMaterialDataObject");

			HR_ATTEMPT(pMaterialDataObject->AddDataObject(pTextureDataObject),
						"Could not add pTextureDataObject to pMaterialDataObject");
		}


	    HR_ATTEMPT(pMaterialsDataObject->AddDataObject(pMaterialDataObject),
					"Could not add pMaterialDataObject to pMaterialsDataObject");


		EXIT;


		delete[] pbMaterialData;

		if (pMaterialDataObject)
			pMaterialDataObject->Release();

		if (pTextureDataObject)
			pTextureDataObject->Release();


		ASSERT(SUCCEEDED(hr),	
					"Error occured while adding materials");
	}


	HR_ATTEMPT(pShapeDataObject->AddDataObject(pMaterialsDataObject),
				"Could not add pMaterialsDataObject to pShapeDataObject");


	EXIT;


	delete[] pbMaterialsData;

	if (pMaterialsDataObject)
		pMaterialsDataObject->Release();	
	
		
	return hr;
}








HRESULT	AddVertexColors
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pShapeDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{
	HRESULT	hr	= S_OK;

	LPDIRECTXFILEDATA	pColorsDataObject	= NULL;

	PBYTE	pbColorsData	= NULL;
	

	INIT;

	int		cbColorsSize	= sizeof(DWORD)												// nVertexColors
							+ pShape->m_cReps * (sizeof(DWORD) + 4 * sizeof(float));		// vertexColors

	PBYTE	pbColorsCurr	= pbColorsData	= new BYTE[cbColorsSize];

	ASSERT(pbColorsData,
				"Could not allocate memory for pbColorsData");


	// nVertexColors
	WRITE_DWORD(pbColorsCurr, ((DWORD)pShape->m_cReps));

	// vertexColors
	for (int iRep = 0; iRep < pShape->m_cReps; iRep++) 
	{
		// index
		WRITE_DWORD(pbColorsCurr, ((DWORD)iRep));

		// indexedColor
		WRITE_FLOAT(pbColorsCurr, pShape->m_rgVertexColors[pShape->m_rgReps[iRep].m_iFirst].r);	// red
		WRITE_FLOAT(pbColorsCurr, pShape->m_rgVertexColors[pShape->m_rgReps[iRep].m_iFirst].g);	// green
		WRITE_FLOAT(pbColorsCurr, pShape->m_rgVertexColors[pShape->m_rgReps[iRep].m_iFirst].b);	// blue
		WRITE_FLOAT(pbColorsCurr, pShape->m_rgVertexColors[pShape->m_rgReps[iRep].m_iFirst].a);	// alpha
	}


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMMeshVertexColors, NULL, NULL, cbColorsSize, pbColorsData, &pColorsDataObject),
				"Could not create pColorsDataObject");


	HR_ATTEMPT(pShapeDataObject->AddDataObject(pColorsDataObject),
				"Could not add pColorsDataObject to pShapeDataObject");


	EXIT;


	delete[] pbColorsData;

	if (pColorsDataObject)
		pColorsDataObject->Release();


	return hr;
}











HRESULT	AddRepInfo
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pShapeDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{
	HRESULT	hr	= S_OK;


	LPDIRECTXFILEDATA	pRepsDataObject	= NULL;


	PBYTE	pbRepsData	= NULL;
	
	INIT;

	int		cbRepsSize	= sizeof(DWORD)						// nIndices
						+ sizeof(DWORD)						// nOriginalVertices
						+ pShape->m_cReps * sizeof(DWORD);	// indices

	PBYTE	pbRepsCurr	= pbRepsData	= new BYTE[cbRepsSize];

	ASSERT(pbRepsData,
				"Could not allocate memory for pbRepsData");


	// nIndices
	WRITE_DWORD(pbRepsCurr, ((DWORD)pShape->m_cReps));

	// nOriginalVertices
	WRITE_DWORD(pbRepsCurr, ((DWORD)pShape->m_cVertices));

	// indices
	for (int iRep = 0; iRep < pShape->m_cReps; iRep++)
		WRITE_DWORD(pbRepsCurr, ((DWORD)pShape->m_rgReps[iRep].m_iFirst));


	HR_ATTEMPT(pxofSave->CreateDataObject(DXFILEOBJ_VertexDuplicationIndices, NULL, NULL, cbRepsSize, pbRepsData, &pRepsDataObject),
				"Could not create pRepsDataObject");


	HR_ATTEMPT(pShapeDataObject->AddDataObject(pRepsDataObject),
				"Could not add pRepsDataObject to pShapeDataObject");


	EXIT;


	delete[] pbRepsData;

	if (pRepsDataObject)
		pRepsDataObject->Release();


	return hr;
}













HRESULT	AddPatchMesh
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pFrameDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{

	HRESULT	hr	= S_OK;

	LPDIRECTXFILEDATA	pShapeDataObject	= NULL;

	PBYTE	pbShapeData	= NULL;


	INIT;


	int		cbShapeSize	= sizeof(DWORD)													// nVertices
						+ pShape->m_cReps * (3 * sizeof(float))							// vertices
						+ sizeof(DWORD)													// nPatches
						+ (pShape->m_cFaces + pShape->m_cFaceIndices) * sizeof(DWORD);	// patches

	PBYTE	pbShapeCurr	= pbShapeData	= new BYTE[cbShapeSize];

	ASSERT(pbShapeData,
				"Could not allocate memory for pbpShapeData");
	

	// nVertices
	WRITE_DWORD(pbShapeCurr, ((DWORD)pShape->m_cVertices));

	// vertices
	for (int iRep = 0; iRep < pShape->m_cReps; iRep++) 
	{
		WRITE_FLOAT(pbShapeCurr, pShape->m_rgVertices[pShape->m_rgReps[iRep].m_iFirst].vec[0]);
		WRITE_FLOAT(pbShapeCurr, pShape->m_rgVertices[pShape->m_rgReps[iRep].m_iFirst].vec[1]);
		WRITE_FLOAT(pbShapeCurr, pShape->m_rgVertices[pShape->m_rgReps[iRep].m_iFirst].vec[2]);
	}

	// nPatches
	WRITE_DWORD(pbShapeCurr, ((DWORD)pShape->m_cFaces));

	// faces
	for (int iFace = 0; iFace < pShape->m_cFaces; iFace++) 
	{
		WRITE_DWORD(pbShapeCurr, ((DWORD)16));

		for (int iIndex = 0; iIndex < 16; iIndex++)
			WRITE_DWORD(pbShapeCurr, pShape->m_rgFaces[iFace].m_rgIndices[iIndex]);
	}


	HR_ATTEMPT(pxofSave->CreateDataObject(DXFILEOBJ_PatchMesh, NULL, NULL, cbShapeSize, pbShapeData, &pShapeDataObject),
				"Could not create pShapeDataObject");



	// MeshTextureCoords
	if (pShape->m_cTexCoords > 0) 
	{
		HR_ATTEMPT(AddTexCoords(pShape, pShapeDataObject, pxofSave),
					"Could not add texture coordinate info");
	}

	// MeshVertexColors
//	HR_ATTEMPT(AddVertexColors(pShape, pShapeDataObject, pxofSave),
//				"Could not add vertex color info");
	
	// MeshMaterialList
	HR_ATTEMPT(AddMaterialList(pShape, pShapeDataObject, pxofSave),
				"Could not add materials info");

	// VertexDuplicationIndices
	HR_ATTEMPT(AddRepInfo(pShape, pShapeDataObject, pxofSave),
				"Could not add rep info");

	// XSkinMeshHeader
	if (pShape->m_cBones > 0) 
	{
		HR_ATTEMPT(AddSkin(pShape, pShapeDataObject, pxofSave),
					"Could not add skin info");
	}



	HR_ATTEMPT(pFrameDataObject->AddDataObject(pShapeDataObject),
				"Could not add pShapeDataObject to pFrameDataObject");


	EXIT;


	delete[] pbShapeData;

	if (pShapeDataObject)
		pShapeDataObject->Release();


	return hr;
}
















HRESULT	AddPolyMesh
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pFrameDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{

	HRESULT				hr				= S_OK;

	LPDIRECTXFILEDATA	pShapeDataObject	= NULL;

	PBYTE				pbMeshData		= NULL;

	INIT;

	int		cbMeshSize	= sizeof(DWORD)													// nVertices
						+ pShape->m_cReps * (3 * sizeof(float))							// vertices
						+ sizeof(DWORD)													// nFaces
						+ (pShape->m_cFaces + pShape->m_cFaceIndices) * sizeof(DWORD);	// faces

	PBYTE	pbMeshCurr	= pbMeshData	= new BYTE[cbMeshSize];

	ASSERT(pbMeshData,
				"Could not allocate memory for pbMeshData");
	

	// nVertices
	WRITE_DWORD(pbMeshCurr, ((DWORD)pShape->m_cReps));

	// vertices
	for (int iRep = 0; iRep < pShape->m_cReps; iRep++) 
	{
		WRITE_FLOAT(pbMeshCurr, pShape->m_rgVertices[pShape->m_rgReps[iRep].m_iFirst].vec[0]);
		WRITE_FLOAT(pbMeshCurr, pShape->m_rgVertices[pShape->m_rgReps[iRep].m_iFirst].vec[1]);
		WRITE_FLOAT(pbMeshCurr, pShape->m_rgVertices[pShape->m_rgReps[iRep].m_iFirst].vec[2]);
	}

	// nFaces
	WRITE_DWORD(pbMeshCurr, ((DWORD)pShape->m_cFaces));

	// faces
	for (int iFace = 0; iFace < pShape->m_cFaces; iFace++) 
	{
		WRITE_DWORD(pbMeshCurr, ((DWORD)pShape->m_rgFaces[iFace].m_cIndices));

		for (int iIndex = 0; iIndex < pShape->m_rgFaces[iFace].m_cIndices; iIndex++)
			WRITE_DWORD(pbMeshCurr, ((DWORD)pShape->m_rgFaces[iFace].m_rgIndices[iIndex]));
	}


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMMesh, NULL, NULL, cbMeshSize, pbMeshData, &pShapeDataObject),
				"Could not create pShapeDataObject");


	// MeshNormals
	if (pShape->m_cNormals > 0) 
	{
		HR_ATTEMPT(AddNormals(pShape, pShapeDataObject, pxofSave),
					"Could not add normal info");
	}


	// MeshTextureCoords
	if (pShape->m_cTexCoords > 0) 
	{
		HR_ATTEMPT(AddTexCoords(pShape, pShapeDataObject, pxofSave),
					"Could not add texture coordinate info");
	}

	// MeshVertexColors
//	HR_ATTEMPT(AddVertexColors(pShape, pShapeDataObject, pxofSave),
//				"Could not add vertex color info");

	
	// MeshMaterialList
	HR_ATTEMPT(AddMaterialList(pShape, pShapeDataObject, pxofSave),
				"Could not add materials info");


	// VertexDuplicationIndices
	HR_ATTEMPT(AddRepInfo(pShape, pShapeDataObject, pxofSave),
				"Could not add rep info");


	// XSkinMeshHeader
	if (pShape->m_cBones > 0) 
	{
		HR_ATTEMPT(AddSkin(pShape, pShapeDataObject, pxofSave),
					"Could not add skin info");
	}


	HR_ATTEMPT(pFrameDataObject->AddDataObject(pShapeDataObject),
				"Could not add pShapeDataObject to pFrameDataObject");



	EXIT;



	delete[] pbMeshData;

	if (pShapeDataObject)
		pShapeDataObject->Release();


	return hr;
}









HRESULT	AddShape
		(
			int						iShape, 
			LPDIRECTXFILEDATA		pParentFrameDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{

	HRESULT				hr					= S_OK;

    LPDIRECTXFILEDATA	pFrameDataObject	= NULL;
	LPDIRECTXFILEDATA	pMatrixDataObject	= NULL;


	INIT;


	// shape name
	char*	szName;

	DT_ATTEMPT(DtShapeGetName(iShape, &szName));


	cout << "\treading " << szName << endl;


	// local transform
	float*	rgfLocalTransform;

	DT_ATTEMPT(DtShapeGetMatrix(iShape, &rgfLocalTransform));


	// Frame
	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMFrame, szName, NULL, 0, NULL, &pFrameDataObject),
				"Could not create pFrameDataObject");

	// FrameTransformMatrix
	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMFrameTransformMatrix, NULL, NULL, 16 * sizeof(float), rgfLocalTransform, &pMatrixDataObject),
				"Could not create pMatrixDataObject");



	HR_ATTEMPT(pFrameDataObject->AddDataObject(pMatrixDataObject),
				"Could not add pMatrixDataObject to pFrameDataObject");


	// the reason for the braces here is to place Mesh in a local scope so that will be deleted quickly 
	{	
		Mesh	mesh;

		LoadShape(iShape, &mesh);

		switch (mesh.m_kType) 
		{
			case Mesh::PATCH_MESH:
				HR_ATTEMPT(AddPatchMesh(&mesh, pFrameDataObject, pxofSave),
							"Could not add patch mesh");
				break;
			case Mesh::POLY_MESH:
				// DtShapeGetVertexCount returns an error code if cVertices == 0
				HR_ATTEMPT(AddPolyMesh(&mesh, pFrameDataObject, pxofSave),
							"Could not add mesh");
				break;
			case Mesh::BONE:
				break;
			default:
				ASSERT(false, "Unknown shape type");
				break;
		};
	}	

	// add children
	int		cChildren;
	int*	rgiChildren;

	DT_ATTEMPT(MyDtShapeGetChildren(iShape, &cChildren, &rgiChildren));

	for (int iChild = 0; iChild < cChildren; iChild++) 
	{
		HR_ATTEMPT(AddShape(rgiChildren[iChild], pFrameDataObject, pxofSave),
					"Could not add shape");
	}

	delete[] rgiChildren;

	HR_ATTEMPT(pParentFrameDataObject->AddDataObject(pFrameDataObject),
				"Could not add pFrameDataObject to pParentFrameDataObject");

	EXIT;

	
	if (pMatrixDataObject)
		pMatrixDataObject->Release();

	if (pFrameDataObject)
		pFrameDataObject->Release();
	

	return hr;
}






HRESULT	AddScene
		(
			const char*	szFile
		) 
{
	HRESULT	hr	= S_OK;


    LPDIRECTXFILE			pxofApi					= NULL;
    LPDIRECTXFILESAVEOBJECT	pxofSave				= NULL; 

	LPDIRECTXFILEDATA		pAnimSetObject			= NULL;
	LPDIRECTXFILEDATA		pRootFrameObject		= NULL;
	LPDIRECTXFILEDATA		pRootTransformObject	= NULL;

	INIT;


	// Initialize the Dt database 
	DtExt_SceneInit("scene");

	DtExt_setJointHierarchy(true);
	DtExt_setParents(true);
	DtExt_setOutputTransforms(kTRANSFORMALL);
	DtExt_setTesselate(kTESSTRI);
	DtExt_setWalkMode(0);
	DtExt_setInlineTextures(0);			    // jimn; 9/25/00; Don't convert textures
	DtExt_setOriginalTexture(1);			// jimn; 9/25/00; Use original textures.
//    DtExt_setSoftTextures(1);
    DtExt_setOutputCameras(0);

	DtExt_dbInit();


	cout << "Exporting to " << szFile << " ..." << endl;


	// create xofapi object.
	HR_ATTEMPT(DirectXFileCreate(&pxofApi),
				"Could not create xofapi object");


	// register templates for d3drm.
	HR_ATTEMPT(pxofApi->RegisterTemplates((LPVOID)D3DRM_XTEMPLATES, D3DRM_XTEMPLATE_BYTES),
				"Could not register D3D templates");


	// register extra templates for skinning info and vertex duplication
	HR_ATTEMPT(pxofApi->RegisterTemplates((LPVOID)XSKINEXP_TEMPLATES, strlen(XSKINEXP_TEMPLATES)),
				"Could not register Skinning and/or Vertex Duplication templates");


	// create save object.
	HR_ATTEMPT(pxofApi->CreateSaveObject(szFile, g_FileFormat, &pxofSave),
				"Could not create save object");


	// save templates
	HR_ATTEMPT(pxofSave->SaveTemplates(3, aIds),
				"Could not save templates.");


	// save file data to the file

	// first create the SCENE_ROOT Frame
	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMFrame, SCENE_ROOT, NULL, 0, NULL, &pRootFrameObject),
				"Could not create pRootFrameObject");


	// next create the SCENE_ROOT FrameTransformMatrix as the Identity 
	float rgfIdentity[16] = {1.0f, 0.0f, 0.0f, 0.0f,
							 0.0f, 1.0f, 0.0f, 0.0f,
							 0.0f, 0.0f, 1.0f, 0.0f,
							 0.0f, 0.0f, 0.0f, 1.0f};


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMFrameTransformMatrix, NULL, NULL, 16 * sizeof(float), rgfIdentity, &pRootTransformObject),
				"Could not create pRootTransformObject");


	HR_ATTEMPT(pRootFrameObject->AddDataObject(pRootTransformObject),
				"Could not add pRootTransformObject to pRootFrameObject");


	cout << endl << "Loading scene data..." << endl;

	int cShapes = DtShapeGetCount();

	// add all shapes which have no parents
	for (int iShape = 0; iShape < cShapes; iShape++) 
	{
		if (MyDtShapeGetParentID(iShape) == -1) 
		{
			HR_ATTEMPT(AddShape(iShape, pRootFrameObject, pxofSave),
						"Could not add top level shape");
		}
	}


	cout << "Writing scene data..." << endl;

	HR_ATTEMPT(pxofSave->SaveData(pRootFrameObject),
				"Could not save scene data to file");




	if (g_bExportAnimation) 
	{
		HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMAnimationSet, NULL, NULL, 0, NULL, &pAnimSetObject),
					"Could not create pAnimSetObject");

	
		cout << endl << "Loading animation data..." << endl;

		bool	bAnimDataFound	= false;

		if (g_bKeyframeAnimation) 
		{
			for (iShape = 0; iShape < cShapes; iShape++) 
			{
				Anim	anim;

				loadAnim(iShape, &anim);

				if (anim.m_cKeys > 0) 
				{
					hr = AddAnim(&anim, pAnimSetObject, pxofSave);

					if (FAILED(hr))
						break;

					bAnimDataFound	= true;
				}


				freeAnim(&anim);

				ASSERT(SUCCEEDED(hr), "Could not add animation data");
			}
		}
		else 		// regular animation
		{
			Anim*	rgAnims	= new Anim[cShapes];

			ASSERT(rgAnims,
						"Could not allocate memory for large animation array");

			loadAllAnims(rgAnims);

			for (int iShape = 0; iShape < cShapes; iShape++) 
			{
				if (rgAnims[iShape].m_cKeys > 0) 
				{
					hr = AddAnim(&rgAnims[iShape], pAnimSetObject, pxofSave);

					if (FAILED(hr))
						break; 

					bAnimDataFound	= true;
				}
			}


			freeAllAnims(rgAnims);

			delete[] rgAnims;

			ASSERT(SUCCEEDED(hr), "Could not add animation data");
		}

		if (bAnimDataFound) 
		{
			cout << "Writing animation data..." << endl;

			HR_ATTEMPT(pxofSave->SaveData(pAnimSetObject),
						"Could not save animation data to file");
		}
		else 
		{
			cout << "Writing skipped (no animation data found)..." << endl;
		}
	}
	else 
	{
		cout << endl << "Ignoring animation..." << endl;
	}

	EXIT;


	if (pRootFrameObject)
		pRootFrameObject->Release();

	if (pRootTransformObject)
		pRootTransformObject->Release();

	if (pAnimSetObject)
		pAnimSetObject->Release();


	if (pxofSave) 
		pxofSave->Release();

	if (pxofApi)
		pxofApi->Release();



	cout << endl;

	if (FAILED(hr))
		cout << "There were errors.";
	else 
		cout << "Completed successfully.";

	cout << endl << "...................................................." << endl << endl;


	cout.flush();

	// Clean up the allocated memory and internal storage
	DtExt_CleanUp();

	return hr;
}





void	ParseOptions
		(
			MString	sOptions
		) 
{
	if (sOptions.length() > 0) 
	{
		MStringArray	optionList;

		sOptions.split(';', optionList);

		// break out all the options.
		for (int iOption = 0; iOption < (int)optionList.length(); iOption++) 
		{
			MStringArray    theOption;

			optionList[iOption].split('=', theOption);

			if (theOption.length() > 1) 
			{
				if (theOption[0] == "fileFormat") 
				{
					if (theOption[1] == "binary") 
					{
						g_FileFormat	= DXFILEFORMAT_BINARY;
					}
					else if (theOption[1] == "compressed") 
					{
						g_FileFormat	= DXFILEFORMAT_COMPRESSED;
					}
					else	// "text" 
					{	
						g_FileFormat	= DXFILEFORMAT_TEXT;
					}
				}
				else if (theOption[0] == "exportAnimation") 
				{
					if (theOption[1] == "false") 
					{
						g_bExportAnimation	= false;
					}
					else 	// "true"
					{
						g_bExportAnimation	= true;
					}
				}
				else if (theOption[0] == "keyframeAnimation") 
				{
					if (theOption[1] == "false") 
					{
						g_bKeyframeAnimation	= false;
					}
					else 	// "true"
					{
						g_bKeyframeAnimation	= true;
					}
				}
				else if (theOption[0] == "animateEverything") 
				{
					if (theOption[1] == "false") 
					{
						g_bAnimateEverything	= false;
					}
					else 	// "true"
					{
						g_bAnimateEverything	= true;
					}
				}
				else if (theOption[0] == "frameStep") 
				{
					g_iFrameStep	= theOption[1].asInt();
				}
				else if (theOption[0] == "flipU") 
				{
					if (theOption[1] == "true") 
					{
						g_iFlipU	= -1;
					}
					else 	// "false"
					{
						g_iFlipU	= 1;
					}
				}
				else if (theOption[0] == "flipV") 
				{
					if (theOption[1] == "true") 
					{
						g_iFlipV	= 1;
					}
					else 	// "false"
					{
						g_iFlipV	= -1;
					}
				}
				else if (theOption[0] == "exportPatches") 
				{
					if (theOption[1] == "true") 
					{
						g_bExportPatches	= true;
					}
					else 	// "false"
					{
						g_bExportPatches	= false;
					}
				}
				else if (theOption[0] == "relTexFilename")
				{
					if (theOption[1] == "true") 
					{
						g_bRelativeTexFile	= true;
					}
					else 	// "false"
					{
						g_bRelativeTexFile	= false;
					}
				}
			}
		}
	}
}



MStatus	xfileTranslator::writer
		(	// parameters
			const MFileObject& file, 
			const MString& sOptions, 
			MPxFileTranslator::FileAccessMode mode
		) 
{
	g_Strings.reset();

	ParseOptions(sOptions);

	MString	sFile	= file.fullName();

	int		iExt	= sFile.rindex('.');
	MString	sExt	= sFile.substring(iExt, sFile.length() - 1);

	sFile	= (sExt == ".x" || sExt == ".X") ? sFile : (sFile + ".x");

	AddScene(sFile.asChar());

	g_Strings.clear();

	return MS::kSuccess;
}





MStatus	initializePlugin 
		(	
			MObject	obj
		) 
{
	MStatus         status;
	char			version[256];

	strcpy(version, "0.3");				// plug-in version
	strcat(version, ".");
	strcat(version, DtAPIVersion());
	
	MFnPlugin       plugin(obj, "XFile Translator for Maya", version, "Any");

	// register the translator
	status = plugin.registerFileTranslator("XFile", "xfileTranslator.rgb", xfileTranslator::creator, "xfileTranslatorOpts", "", true);

	if (!status)
		status.perror("registerFileTranslator");

	return status;
}


MStatus	uninitializePlugin
		(	
			MObject obj
		) 
{
	MStatus         status;
	MFnPlugin       plugin(obj);

	status = plugin.deregisterFileTranslator("XFile");

	if (!status)
		status.perror("deregisterFileTranslator");

	return status;
}





/*** TOOLS

	// print out the attributes of a dependency node
	for (unsigned iAttr = 0; iAttr < fnNode.attributeCount(); iAttr++) 
	{
		MFnAttribute fnAttr(fnNode.attribute(iAttr));

		cout << fnNode.name() << "." << fnAttr.name() << ": " << fnNode.attribute(iAttr).apiTypeStr() << endl;
	}





	// print the node containing the corresponging plug to 'plug'
	MPlugArray rgPlugs;

	plug.connectedTo(rgPlugs, true, true);

	for (int i = 0; i < (int)rgPlugs.length(); i++) 
	{
		MFnDependencyNode fnNode(rgPlugs[i].node());

		cout << fnNode.name() << "\t" << rgPlugs[i].name() << endl;
	}
 ***/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\maya25\xportTranslator.h ===
#ifndef xfileTranslator_h
#define xfileTranslator_h




#include <maya/MPxFileTranslator.h>

#include <MDt.h>



class xfileTranslator: public MPxFileTranslator 
{
	public:

		xfileTranslator() {};
	   ~xfileTranslator() {};

		static void*	creator ()	{ return new xfileTranslator(); };

		MStatus			reader(const MFileObject& file,
							   const MString& optionsString,
							   MPxFileTranslator::FileAccessMode mode)	{ return MS::kSuccess; };

		MStatus         writer(const MFileObject& file,
		                       const MString& optionsString,
		                       MPxFileTranslator::FileAccessMode mode);

		bool            haveReadMethod()	const	{ return false; };
		bool            haveWriteMethod()	const	{ return true; };
		bool            canBeOpened()		const	{ return false; };
		MString         defaultExtension()	const	{ return ""; };
		MFileKind       identifyFile (const MFileObject& fileName, const char *buffer, short size)	const	
							{ return kIsMyFileType; };

};






#define WRITE_FLOAT(pbCur, _float)	{												\
										float* __pfloat	= (float*)pbCur;			\
										*(__pfloat++)	= _float;					\
										pbCur			= (PBYTE)__pfloat;			\
									}

#define WRITE_PCHAR(pbCur, pchar)	{												\
										char** __ppchar	= (char**)pbCur;			\
										*(__ppchar++)	= pchar;					\
										pbCur			= (PBYTE)__ppchar;			\
									}

#define WRITE_DWORD(pbCur, dword)	{												\
										DWORD* __pdword	= (DWORD*)pbCur;			\
										*(__pdword++)	= dword;					\
										pbCur			= (PBYTE)__pdword;			\
									}

#define WRITE_WORD(pbCur, word)		{												\
										WORD* __pword	= (WORD*)pbCur;				\
										*(__pword++)	= word;						\
										pbCur			= (PBYTE)__pword;			\
									}


#define	SCENE_ROOT	"SCENE_ROOT"












#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\maya25\MyDt.h ===
#ifndef MyDt_h
#define MyDt_h

// Dt API
#include <MDt.h>
#include <MDtExt.h>


struct Rep {
	int		m_iTexCoordIdx;		// index into lump of texture coordinates 
	int		m_iNormalIdx;		// index into lump of normals

	int		m_iNext;			// next repetition
	int		m_iFirst;			// can also be thought of as "index into lump of vertices";

	// IMPORTANT: the following members are only valid in the instances corresponging to the first rep's.
	int		m_cReps;					
};


struct Face {
	Face();
   ~Face();

	int		m_cIndices;			// number of vertices in this face
	int*	m_rgIndices;

	long	m_iGroup;			// material group
};



struct Group {
	char*	m_szMaterial;		// material name

	char*	m_szTextureFile;	// texture file name

	float	m_fDiffuseRed;		
	float	m_fDiffuseGreen;	// diffuse components
	float	m_fDiffuseBlue;		

	float	m_fSpecularRed;		
	float	m_fSpecularGreen;	// specular components
	float	m_fSpecularBlue;		

	float	m_fEmissiveRed;		
	float	m_fEmissiveGreen;	// emissive components
	float	m_fEmissiveBlue;		

	float	m_fShininess;		// specular power

	float	m_fTransparency;	// transparency
};


struct Bone {
	Bone();
   ~Bone();

	char*	m_szName;			// bone name

	int		m_cReps;			// number of rep's influenced

	int		m_cWeights;		// number of points influenced
	float*	m_rgfWeights;
	int*	m_rgiVertices;

	float	m_matOffset[4][4];	// inverse of bone's world coordinate transform at the time of binding
};


struct Mesh 
{
	Mesh();
   ~Mesh();

	enum ShapeType
	{
		UNKNOWN,
		POLY_MESH,
		PATCH_MESH,
		BONE
	};

	ShapeType	m_kType;

	// control point info
	
	int			m_cReps;
	Rep*		m_rgReps;
	
	int			m_cVertices;
	DtVec3f*	m_rgVertices;		// lump of vertices

	int			m_cVertexColors;
	DtRGBA*		m_rgVertexColors;	// lump of vertex colors

	int			m_cTexCoords;
	DtVec2f*	m_rgTexCoords;		// lump of texture coords

	int			m_cNormals;
	DtVec3f*	m_rgNormals;		// lump of normals


	// face info

	int			m_cFaces;
	Face*		m_rgFaces;

	int			m_cFaceIndices;	// total number of face indices (over all faces).

	// material info
	
	int			m_cGroups;
	Group*		m_rgGroups;			// material groups


	// skinning info

	int			m_cBones;
	Bone*		m_rgBones;

	int			m_cMaxBonesPerVertex;
	int			m_cMaxBonesPerFace;
};







		



struct Key 
{
	int		m_iFrame;

	float	m_rgfTRS[4][4];			// TRS transform matrix		- NOT USED

	float	m_rgfQuaternion[4];		// quaternion rotation
	float	m_rgfRotation[3];		// euler angles				- NOT USED
	float	m_rgfScale[3];			// scale
	float	m_rgfPosition[3];		// translation
};


struct Anim 
{
	char*	m_szName;

	int		m_cKeys;
	Key*	m_rgKeys;
};















































int	MyDtShapeGetParentID
	(
		int	iShape
	);


int MyDtShapeGetChildren
    (
		int     iShape, 
        int*    cChildren, 
        int**   rgiChildren
    );

int	MyDtShapeGetVertices
	(
		int			iShape,
		int*		pcVertices, 
		DtVec3f**	prgVertices
	);


int	MyDtShapeGetVertices
	(
		MObject&	objInput, 
		MObject&	objOutput, 
		int*		pcVertices, 
		DtVec3f**	prgVertices
	);

int	MyDtShapeGetControlPoints
	(
		MObject&	objInput, 
		MObject&	objOutput, 
		int*		pcVertices, 
		DtVec3f**	prgVertices
	);

int	MyDtShapeGetNormals
	(
		int			iShape,
		int*		pcNormals, 
		DtVec3f**	prgNormals
	);


int	MyDtShapeGetNormals
	(
		MObject&	objInput, 
		MObject&	objOutput, 
		int*		pcNormals, 
		DtVec3f**	prgNormals
	);

int	MyDtShapeGetTextureVertices
	(
		int			iShape,
		int*		pcTexCoords, 
		DtVec2f**	prgTexCoords
	);

int	MyDtShapeGetVerticesColor
	(
		int			iShape,
		int*		pcColors, 
		DtRGBA**	prgColors
	);

int	MyDtTextureGetFileName
	(
		char*	szMaterial, 
		char**	pszTextureFile
	);






bool	MyDtShapeIsJoint
		(
			int	iShape
		);


bool	MyDtShapeIsPatchMesh
		(
			int	iShape
		);
















#include <iostream.h>

class StringTable {
	public:
		StringTable() {};
	   ~StringTable() {};

		void reset();
		void clear();
		void add(char*);

	private:
		char**	m_rgszStrings;
		int		m_cStrings;
		int		m_cStringsMax;
};

inline void StringTable::reset() {
	m_cStrings		= 0;
	m_cStringsMax	= 64;
	m_rgszStrings	= new char*[m_cStringsMax];
}

inline void StringTable::clear() {
	for (int iString = 0; iString < m_cStrings; iString++)
		delete[] m_rgszStrings[iString];

	delete[] m_rgszStrings;
}

inline void StringTable::add(char* szString) {
	if (m_cStrings >= m_cStringsMax) {	// double the array size

		char**	rgszStrings	= m_rgszStrings;

		m_rgszStrings	= new char*[m_cStringsMax * 2];

        if (m_rgszStrings == NULL)
            return;

		m_cStringsMax *= 2;

		memcpy(m_rgszStrings, rgszStrings, m_cStrings * sizeof(char*));

		delete[] rgszStrings;
	}

	m_rgszStrings[m_cStrings]	= szString;

	m_cStrings++;
}












































#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\maya25\xskinexptemplates.h ===
//-----------------------------------------------------------------------------
// File: XSkinExpTemplates.h
//
// Desc: Custom templates used for skin export format.
//
// Copyright (C) 1998-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef __XSKINEXPTEMPLATES_H__
#define __XSKINEXPTEMPLATES_H__

// {3CF169CE-FF7C-44ab-93C0-F78F62D172E2}
DEFINE_GUID(DXFILEOBJ_XSkinMeshHeader,
0x3cf169ce, 0xff7c, 0x44ab, 0x93, 0xc0, 0xf7, 0x8f, 0x62, 0xd1, 0x72, 0xe2);

// {B8D65549-D7C9-4995-89CF-53A9A8B031E3}
DEFINE_GUID(DXFILEOBJ_VertexDuplicationIndices, 
0xb8d65549, 0xd7c9, 0x4995, 0x89, 0xcf, 0x53, 0xa9, 0xa8, 0xb0, 0x31, 0xe3);

// {6F0D123B-BAD2-4167-A0D0-80224F25FABB}
DEFINE_GUID(DXFILEOBJ_SkinWeights, 
0x6f0d123b, 0xbad2, 0x4167, 0xa0, 0xd0, 0x80, 0x22, 0x4f, 0x25, 0xfa, 0xbb);

// {A3EB5D44-FC22-429d-9AFB-3221CB9719A6}
DEFINE_GUID(DXFILEOBJ_Patch, 
0xa3eb5d44, 0xfc22, 0x429d, 0x9a, 0xfb, 0x32, 0x21, 0xcb, 0x97, 0x19, 0xa6);

// {D02C95CC-EDBA-4305-9B5D-1820D7704BBF}
DEFINE_GUID(DXFILEOBJ_PatchMesh, 
0xd02c95cc, 0xedba, 0x4305, 0x9b, 0x5d, 0x18, 0x20, 0xd7, 0x70, 0x4b, 0xbf);

#define XSKINEXP_TEMPLATES \
        "xof 0303txt 0032\
        template XSkinMeshHeader \
        { \
            <3CF169CE-FF7C-44ab-93C0-F78F62D172E2> \
            WORD nMaxSkinWeightsPerVertex; \
            WORD nMaxSkinWeightsPerFace; \
            WORD nBones; \
        } \
        template VertexDuplicationIndices \
        { \
            <B8D65549-D7C9-4995-89CF-53A9A8B031E3> \
            DWORD nIndices; \
            DWORD nOriginalVertices; \
            array DWORD indices[nIndices]; \
        } \
        template SkinWeights \
        { \
            <6F0D123B-BAD2-4167-A0D0-80224F25FABB> \
            STRING transformNodeName;\
            DWORD nWeights; \
            array DWORD vertexIndices[nWeights]; \
            array float weights[nWeights]; \
            Matrix4x4 matrixOffset; \
        } \
        template Patch \
        { \
            <A3EB5D44-FC22-429D-9AFB-3221CB9719A6> \
            DWORD nControlIndices; \
            array DWORD controlIndices[nControlIndices]; \
        } \
        template PatchMesh \
        { \
            <D02C95CC-EDBA-4305-9B5D-1820D7704BBF> \
            DWORD nVertices; \
            array Vector vertices[nVertices]; \
            DWORD nPatches; \
            array Patch patches[nPatches]; \
        } "


#endif //__XSKINEXPTEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\maya30\xporttranslator.h ===
#ifndef xfileTranslator_h
#define xfileTranslator_h




#include <maya/MPxFileTranslator.h>

#include <MDt.h>



class xfileTranslator: public MPxFileTranslator 
{
	public:

		xfileTranslator() {};
	   ~xfileTranslator() {};

		static void*	creator ()	{ return new xfileTranslator(); };

		MStatus			reader(const MFileObject& file,
							   const MString& optionsString,
							   MPxFileTranslator::FileAccessMode mode)	{ return MS::kSuccess; };

		MStatus         writer(const MFileObject& file,
		                       const MString& optionsString,
		                       MPxFileTranslator::FileAccessMode mode);

		bool            haveReadMethod()	const	{ return false; };
		bool            haveWriteMethod()	const	{ return true; };
		bool            canBeOpened()		const	{ return false; };
		MString         defaultExtension()	const	{ return ""; };
		MFileKind       identifyFile (const MFileObject& fileName, const char *buffer, short size)	const	
							{ return kIsMyFileType; };

};






#define WRITE_FLOAT(pbCur, _float)	{												\
										float* __pfloat	= (float*)pbCur;			\
										*(__pfloat++)	= _float;					\
										pbCur			= (PBYTE)__pfloat;			\
									}

#define WRITE_PCHAR(pbCur, pchar)	{												\
										char** __ppchar	= (char**)pbCur;			\
										*(__ppchar++)	= pchar;					\
										pbCur			= (PBYTE)__ppchar;			\
									}

#define WRITE_DWORD(pbCur, dword)	{												\
										DWORD* __pdword	= (DWORD*)pbCur;			\
										*(__pdword++)	= dword;					\
										pbCur			= (PBYTE)__pdword;			\
									}

#define WRITE_WORD(pbCur, word)		{												\
										WORD* __pword	= (WORD*)pbCur;				\
										*(__pword++)	= word;						\
										pbCur			= (PBYTE)__pword;			\
									}


#define	SCENE_ROOT	"SCENE_ROOT"












#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\maya30\xskinexptemplates.h ===
//-----------------------------------------------------------------------------
// File: XSkinExpTemplates.h
//
// Desc: Custom templates used for skin export format.
//
// Copyright (C) 1998-2000 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#ifndef __XSKINEXPTEMPLATES_H__
#define __XSKINEXPTEMPLATES_H__

// {3CF169CE-FF7C-44ab-93C0-F78F62D172E2}
DEFINE_GUID(DXFILEOBJ_XSkinMeshHeader,
0x3cf169ce, 0xff7c, 0x44ab, 0x93, 0xc0, 0xf7, 0x8f, 0x62, 0xd1, 0x72, 0xe2);

// {B8D65549-D7C9-4995-89CF-53A9A8B031E3}
DEFINE_GUID(DXFILEOBJ_VertexDuplicationIndices, 
0xb8d65549, 0xd7c9, 0x4995, 0x89, 0xcf, 0x53, 0xa9, 0xa8, 0xb0, 0x31, 0xe3);

// {6F0D123B-BAD2-4167-A0D0-80224F25FABB}
DEFINE_GUID(DXFILEOBJ_SkinWeights, 
0x6f0d123b, 0xbad2, 0x4167, 0xa0, 0xd0, 0x80, 0x22, 0x4f, 0x25, 0xfa, 0xbb);

// {A3EB5D44-FC22-429d-9AFB-3221CB9719A6}
DEFINE_GUID(DXFILEOBJ_Patch, 
0xa3eb5d44, 0xfc22, 0x429d, 0x9a, 0xfb, 0x32, 0x21, 0xcb, 0x97, 0x19, 0xa6);

// {D02C95CC-EDBA-4305-9B5D-1820D7704BBF}
DEFINE_GUID(DXFILEOBJ_PatchMesh, 
0xd02c95cc, 0xedba, 0x4305, 0x9b, 0x5d, 0x18, 0x20, 0xd7, 0x70, 0x4b, 0xbf);

// {B6C3E656-EC8B-4b92-9B62-681659522947}
DEFINE_GUID(DXFILEOBJ_PMInfo, 
0xb6c3e656, 0xec8b, 0x4b92, 0x9b, 0x62, 0x68, 0x16, 0x59, 0x52, 0x29, 0x47);

// {917E0427-C61E-4a14-9C64-AFE65F9E9844}
DEFINE_GUID(DXFILEOBJ_PMAttributeRange, 
0x917e0427, 0xc61e, 0x4a14, 0x9c, 0x64, 0xaf, 0xe6, 0x5f, 0x9e, 0x98, 0x44);

// {574CCC14-F0B3-4333-822D-93E8A8A08E4C}
DEFINE_GUID(DXFILEOBJ_PMVSplitRecord,
0x574ccc14, 0xf0b3, 0x4333, 0x82, 0x2d, 0x93, 0xe8, 0xa8, 0xa0, 0x8e, 0x4c);

// {B6E70A0E-8EF9-4e83-94AD-ECC8B0C04897}
DEFINE_GUID(DXFILEOBJ_FVFData, 
0xb6e70a0e, 0x8ef9, 0x4e83, 0x94, 0xad, 0xec, 0xc8, 0xb0, 0xc0, 0x48, 0x97);


#define XSKINEXP_TEMPLATES \
        "xof 0303txt 0032\
        template XSkinMeshHeader \
        { \
            <3CF169CE-FF7C-44ab-93C0-F78F62D172E2> \
            WORD nMaxSkinWeightsPerVertex; \
            WORD nMaxSkinWeightsPerFace; \
            WORD nBones; \
        } \
        template VertexDuplicationIndices \
        { \
            <B8D65549-D7C9-4995-89CF-53A9A8B031E3> \
            DWORD nIndices; \
            DWORD nOriginalVertices; \
            array DWORD indices[nIndices]; \
        } \
        template SkinWeights \
        { \
            <6F0D123B-BAD2-4167-A0D0-80224F25FABB> \
            STRING transformNodeName;\
            DWORD nWeights; \
            array DWORD vertexIndices[nWeights]; \
            array float weights[nWeights]; \
            Matrix4x4 matrixOffset; \
        } \
        template Patch \
        { \
            <A3EB5D44-FC22-429D-9AFB-3221CB9719A6> \
            DWORD nControlIndices; \
            array DWORD controlIndices[nControlIndices]; \
        } \
        template PatchMesh \
        { \
            <D02C95CC-EDBA-4305-9B5D-1820D7704BBF> \
            DWORD nVertices; \
            array Vector vertices[nVertices]; \
            DWORD nPatches; \
            array Patch patches[nPatches]; \
        } "

#define XEXTENSIONS_TEMPLATES \
        "xof 0303txt 0032\
        template FVFData \
        { \
            <B6E70A0E-8EF9-4e83-94AD-ECC8B0C04897> \
            DWORD dwFVF; \
            DWORD nDWords; \
            array DWORD data[nDWords]; \
        } \
        template PMAttributeRange \
        { \
            <917E0427-C61E-4a14-9C64-AFE65F9E9844> \
            DWORD iFaceOffset; \
            DWORD nFacesMin; \
            DWORD nFacesMax; \
            DWORD iVertexOffset; \
            DWORD nVerticesMin; \
            DWORD nVerticesMax; \
        } \
        template PMVSplitRecord \
        { \
            <574CCC14-F0B3-4333-822D-93E8A8A08E4C> \
            DWORD iFaceCLW; \
            DWORD iVlrOffset; \
            DWORD iCode; \
        } \
        template PMInfo \
        { \
            <B6C3E656-EC8B-4b92-9B62-681659522947> \
            DWORD nAttributes; \
            array PMAttributeRange attributeRanges[nAttributes]; \
            DWORD nMaxValence; \
            DWORD nMinLogicalVertices; \
            DWORD nMaxLogicalVertices; \
            DWORD nVSplits; \
            array PMVSplitRecord splitRecords[nVSplits]; \
            DWORD nAttributeMispredicts; \
            array DWORD attributeMispredicts[nAttributeMispredicts]; \
        } "

#endif //__XSKINEXPTEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\maya30\myassert.h ===
#ifndef MyAssert_h
#define MyAssert_h


#include <assert.h>


#define INIT								try	{															

#define EXIT								}																\
											catch (char* szError) {											\
												cerr << "ERROR [" << szError << "]" << endl;				\
																											\
												hr	= E_FAIL;												\
											}


#define ASSERT(condition, error_msg)		if (!(condition)) {												\
												throw error_msg;											\
											}

#define HR_ATTEMPT(hresult, error_msg)		ASSERT(SUCCEEDED(hresult), (error_msg))


// assert one type of Dt function
#define	DT_ATTEMPT(statement)				statement






#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\maya30\mydt.h ===
#ifndef MyDt_h
#define MyDt_h

// Dt API
#include <MDt.h>
#include <MDtExt.h>


struct Rep {
	int		m_iTexCoordIdx;		// index into lump of texture coordinates 
	int		m_iNormalIdx;		// index into lump of normals

	int		m_iNext;			// next repetition
	int		m_iFirst;			// can also be thought of as "index into lump of vertices";

	// IMPORTANT: the following members are only valid in the instances corresponging to the first rep's.
	int		m_cReps;					
};


struct Face {
	Face();
   ~Face();

	int		m_cIndices;			// number of vertices in this face
	int*	m_rgIndices;

	long	m_iGroup;			// material group
};



struct Group {
	char*	m_szMaterial;		// material name

	char*	m_szTextureFile;	// texture file name

	float	m_fDiffuseRed;		
	float	m_fDiffuseGreen;	// diffuse components
	float	m_fDiffuseBlue;		

	float	m_fSpecularRed;		
	float	m_fSpecularGreen;	// specular components
	float	m_fSpecularBlue;		

	float	m_fEmissiveRed;		
	float	m_fEmissiveGreen;	// emissive components
	float	m_fEmissiveBlue;		

	float	m_fShininess;		// specular power

	float	m_fTransparency;	// transparency
};


struct Bone {
	Bone();
   ~Bone();

	char*	m_szName;			// bone name

	int		m_cReps;			// number of rep's influenced

	int		m_cWeights;		// number of points influenced
	float*	m_rgfWeights;
	int*	m_rgiVertices;

	float	m_matOffset[4][4];	// inverse of bone's world coordinate transform at the time of binding
};


struct Mesh 
{
	Mesh();
   ~Mesh();

	enum ShapeType
	{
		UNKNOWN,
		POLY_MESH,
		PATCH_MESH,
		BONE
	};

	ShapeType	m_kType;

	// control point info
	
	int			m_cReps;
	Rep*		m_rgReps;
	
	int			m_cVertices;
	DtVec3f*	m_rgVertices;		// lump of vertices

	int			m_cVertexColors;
	DtRGBA*		m_rgVertexColors;	// lump of vertex colors

	int			m_cTexCoords;
	DtVec2f*	m_rgTexCoords;		// lump of texture coords

	int			m_cNormals;
	DtVec3f*	m_rgNormals;		// lump of normals


	// face info

	int			m_cFaces;
	Face*		m_rgFaces;

	int			m_cFaceIndices;	// total number of face indices (over all faces).

	// material info
	
	int			m_cGroups;
	Group*		m_rgGroups;			// material groups


	// skinning info

	int			m_cBones;
	Bone*		m_rgBones;

	int			m_cMaxBonesPerVertex;
	int			m_cMaxBonesPerFace;
};







		



struct Key 
{
	int		m_iFrame;

	float	m_rgfTRS[4][4];			// TRS transform matrix		- NOT USED

	float	m_rgfQuaternion[4];		// quaternion rotation
	float	m_rgfRotation[3];		// euler angles				- NOT USED
	float	m_rgfScale[3];			// scale
	float	m_rgfPosition[3];		// translation
};


struct Anim 
{
	char*	m_szName;

	int		m_cKeys;
	Key*	m_rgKeys;
};















































int	MyDtShapeGetParentID
	(
		int	iShape
	);


int MyDtShapeGetChildren
    (
		int     iShape, 
        int*    cChildren, 
        int**   rgiChildren
    );

int	MyDtShapeGetVertices
	(
		int			iShape,
		int*		pcVertices, 
		DtVec3f**	prgVertices
	);


int	MyDtShapeGetVertices
	(
		MObject&	objInput, 
		MObject&	objOutput, 
		int*		pcVertices, 
		DtVec3f**	prgVertices
	);

int	MyDtShapeGetControlPoints
	(
		MObject&	objInput, 
		MObject&	objOutput, 
		int*		pcVertices, 
		DtVec3f**	prgVertices
	);

int	MyDtShapeGetNormals
	(
		int			iShape,
		int*		pcNormals, 
		DtVec3f**	prgNormals
	);


int	MyDtShapeGetNormals
	(
		MObject&	objInput, 
		MObject&	objOutput, 
		int*		pcNormals, 
		DtVec3f**	prgNormals
	);

int	MyDtShapeGetTextureVertices
	(
		int			iShape,
		int*		pcTexCoords, 
		DtVec2f**	prgTexCoords
	);

int	MyDtShapeGetVerticesColor
	(
		int			iShape,
		int*		pcColors, 
		DtRGBA**	prgColors
	);

int	MyDtTextureGetFileName
	(
		char*	szMaterial, 
		char**	pszTextureFile
	);






bool	MyDtShapeIsJoint
		(
			int	iShape
		);


bool	MyDtShapeIsPatchMesh
		(
			int	iShape
		);
















#include <iostream.h>

class StringTable {
	public:
		StringTable() {};
	   ~StringTable() {};

		void reset();
		void clear();
		void add(char*);

	private:
		char**	m_rgszStrings;
		int		m_cStrings;
		int		m_cStringsMax;
};

inline void StringTable::reset() {
	m_cStrings		= 0;
	m_cStringsMax	= 64;
	m_rgszStrings	= new char*[m_cStringsMax];
}

inline void StringTable::clear() {
	for (int iString = 0; iString < m_cStrings; iString++)
		delete[] m_rgszStrings[iString];

	delete[] m_rgszStrings;
}

inline void StringTable::add(char* szString) {
	if (m_cStrings >= m_cStringsMax) {	// double the array size

		char**	rgszStrings	= m_rgszStrings;

		m_rgszStrings	= new char*[m_cStringsMax * 2];

        if (m_rgszStrings == NULL)
            return;

		m_cStringsMax *= 2;

		memcpy(m_rgszStrings, rgszStrings, m_cStrings * sizeof(char*));

		delete[] rgszStrings;
	}

	m_rgszStrings[m_cStrings]	= szString;

	m_cStrings++;
}












































#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\shape\d3dxexcept.h ===
#ifndef __D3DXEXCEPT_H__
#define __D3DXEXCEPT_H__

#include <string.h>
#include "calloc.h"

#define D3DX_THROW( hResult, string )  throw CD3DXException( hResult, string, __LINE__);
#define D3DX_CATCH   catch( CD3DXException e ) { e.DebugString(); return e.error; }
#define D3DX_TRY     try

class CD3DXException : public CD3duAlloc
{
public:
    CD3DXException(HRESULT res, char *msg, int LineNumber = __LINE__) 
    {
        error = res; 
        strcpy(message, msg); 
        line = LineNumber;
    }
    char message[128];
    HRESULT error;
    int line;
    
    void DebugString() {};
    void Popup() {};
};

#endif // __D3DXEXCEPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\maya30\mydt.cpp ===
#include "MyDt.h"
#include "MyAssert.h"

// Maya API
#include <maya/MObject.h>
#include <maya/MColor.h>
#include <maya/MMatrix.h>
#include <maya/MDagPath.h>
#include <maya/MTime.h>
#include <maya/MAnimControl.h>
#include <maya/MFileObject.h>
#include <maya/MPlug.h>


#include <maya/MIntArray.h>
#include <maya/MFloatArray.h>
#include <maya/MFloatVectorArray.h>
#include <maya/MFloatPointArray.h>
#include <maya/MPointArray.h>
#include <maya/MObjectArray.h>
#include <maya/MDagPathArray.h>
#include <maya/MPlugArray.h>
#include <maya/MSelectionList.h>

#include <maya/MFnMatrixData.h>
#include <maya/MFnMeshData.h>
#include <maya/MFnDoubleArrayData.h>
#include <maya/MFnVectorArrayData.h>

#include <maya/MFnSingleIndexedComponent.h>
#include <maya/MFnSet.h>
#include <maya/MFnTypedAttribute.h>
#include <maya/MFnSkinCluster.h>
#include <maya/MFnWeightGeometryFilter.h>
#include <maya/MFnDagNode.h>
#include <maya/MFnIKJoint.h>
#include <maya/MFnMesh.h>
#include <maya/MFnNurbsSurface.h>
#include <maya/MFnLambertShader.h>

#include <maya/MItDependencyNodes.h>
#include <maya/MItGeometry.h>


bool	g_bRelativeTexFile;
bool	g_bExportAnimation;
bool	g_bKeyframeAnimation;
bool	g_bAnimateEverything;
int		g_iFrameStep;
int		g_iFlipU;
int		g_iFlipV;
bool	g_bExportPatches;

StringTable	g_Strings;



int	MyDtShapeGetParentID
	(
		int	iShape
	) 
{
	int	cShapes		= DtShapeGetCount();


	MObject	objTransform;

	DtExt_ShapeGetTransform(iShape, objTransform);

	MFnDagNode	fnNode(objTransform);

	int cParents	= fnNode.parentCount();

	for (int iParent = 0; iParent < cParents; iParent++) 
	{
		MFnDagNode	fnParent(fnNode.parent(iParent));

		for (int iShape_ = 0; iShape_ < cShapes; iShape_++) 
		{
			MObject	objTransform_;

			DtExt_ShapeGetTransform(iShape_, objTransform_);

			if (fnParent.fullPathName() == MFnDagNode(objTransform_).fullPathName())
				return iShape_;
		}
	}

	return -1;
}



int MyDtShapeGetChildren
    (
		int     iShape, 
        int*    cChildren, 
        int**   rgiChildren
    ) 
{
	int	cShapes		= DtShapeGetCount();

	MObject	objTransform;

	DtExt_ShapeGetTransform(iShape, objTransform);

	MFnDagNode	fnNode(objTransform);

	int cChildren_	= fnNode.childCount();

	*cChildren		= 0;

	if (cChildren_ > 0) 
	{
		*rgiChildren	= new int[cChildren_];

	
		for (int iChild = 0; iChild < cChildren_; iChild++) 
		{
			MFnDagNode fnChild(fnNode.child(iChild));

			for (int iShape_ = 0; iShape_ < cShapes; iShape_++) 
			{
				MObject	objTransform_;

				DtExt_ShapeGetTransform(iShape_, objTransform_);

				if (fnChild.fullPathName() == MFnDagNode(objTransform_).fullPathName()) 
				{
					(*rgiChildren)[*cChildren]	= iShape_;
					(*cChildren)++;

					break;
				}
			}
		}
	}
	else
		*rgiChildren	= new int[1];	// just in case delete doesn't like "int[0]"

	return 1;
}


int	MyDtShapeGetVertices
	(
		MObject&	objInput, 
		MObject&	objOutput, 
		int*		pcVertices, 
		DtVec3f**	prgVertices
	) 
{
	*pcVertices		= 0;
	*prgVertices	= NULL;

	
	assert(objInput.hasFn(MFn::kMesh) && objOutput.hasFn(MFn::kMesh));


	MFnMesh	fnOutput(objOutput);
	MFnMesh	fnInput(objInput);

	*pcVertices		= fnOutput.numVertices();
	*prgVertices	= new DtVec3f[*pcVertices];

	if (!*prgVertices) 
	{
		*pcVertices	= 0;

		return 0;
	}

	// check for tweaks
	MPlug	plgTweakLoc	= fnOutput.findPlug("tweakLocation");

	MObject	objTweakLocVal;

	plgTweakLoc.getValue(objTweakLocVal);

	if (!objTweakLocVal.isNull())	// tweak found
	{	
		MPlugArray	rgplgTweakLocConnections;

		plgTweakLoc.connectedTo(rgplgTweakLocConnections, true, false);		// get source plugs

		assert(rgplgTweakLocConnections.length() == 1);

		MObject	objTweak = rgplgTweakLocConnections[0].node();

		assert(objTweak.hasFn(MFn::kTweak));

		MFnGeometryFilter	fnTweak(objTweak);

		bool	bRelativeTweak;

		fnTweak.findPlug("relativeTweak").getValue(bRelativeTweak);

		if (!bRelativeTweak) 
			cout << "\t\tWARNING: Encountered an absolute tweak; treating as relative!" << endl;

		MPlug plgOffsets = fnTweak.findPlug("vlist")[0].child(0);


		//	WARNING: Seems like Maya doesn't initialize it's numElements properly!!
//		assert((int)plgOffsets.numElements() == cVertices);
//		if ((int)plgOffsets.numElements() != *pcVertices)
//			cout << "\t\tWARNING: tweak count doesn't match vertex count!" << endl;

		float	fEnvelope	= fnTweak.envelope();

		for (int iVertex = 0; iVertex < *pcVertices; iVertex++) 
		{
			plgOffsets.elementByLogicalIndex(iVertex).child(0).getValue((*prgVertices)[iVertex].vec[0]);
			plgOffsets.elementByLogicalIndex(iVertex).child(1).getValue((*prgVertices)[iVertex].vec[1]);
			plgOffsets.elementByLogicalIndex(iVertex).child(2).getValue((*prgVertices)[iVertex].vec[2]);

			(*prgVertices)[iVertex].vec[0]	*= fEnvelope;
			(*prgVertices)[iVertex].vec[1]	*= fEnvelope;
			(*prgVertices)[iVertex].vec[2]	*= fEnvelope;
		}
	}
	else 
	{
		for (int iVertex = 0; iVertex < *pcVertices; iVertex++) 
		{
			(*prgVertices)[iVertex].vec[0]	= 0.0f;
			(*prgVertices)[iVertex].vec[1]	= 0.0f;
			(*prgVertices)[iVertex].vec[2]	= 0.0f;
		}
    }
			
			

	// load vertices and add them to the tweaks
	assert(*pcVertices == fnInput.numVertices());

	MFloatPointArray rgOrigVertices;

	fnInput.getPoints(rgOrigVertices);

	assert(*pcVertices == (int)rgOrigVertices.length());

	for (int iVertex = 0; iVertex < *pcVertices; iVertex++) 
	{
		(*prgVertices)[iVertex].vec[0] += rgOrigVertices[iVertex][0];
		(*prgVertices)[iVertex].vec[1] += rgOrigVertices[iVertex][1];
		(*prgVertices)[iVertex].vec[2] += rgOrigVertices[iVertex][2];
	}


	return 1;
}


int	MyDtTextureGetFileName
	(
		char*	szMaterial, 
		char**	pszTextureFile
	)
{
	if (!DtTextureGetFileName(szMaterial, pszTextureFile))
		return 0;

	if (g_bRelativeTexFile && *pszTextureFile) 
	{
		// use a trick to get the file name without too much hassle
		MFileObject mFile;

		mFile.setFullName(MString(*pszTextureFile));

        *pszTextureFile = new char[256];

        if (*pszTextureFile == NULL)
            return 0;

		strcpy(*pszTextureFile, mFile.name().asChar());

		g_Strings.add(*pszTextureFile);
	}

	return 1;
}







bool	MyDtShapeIsJoint
		(
			int	iShape
		) 
{
	MObject	objShape;

	DtExt_ShapeGetShapeNode(iShape, objShape);

	return (objShape.apiType() == MFn::kInvalid);
}





bool	MyDtShapeIsPatchMesh
		(
			int	iShape
		) 
{
	MObject	objNurb;

	DtExt_ShapeGetShapeNode(iShape, objNurb);

	if (!objNurb.hasFn(MFn::kNurbsSurface))
		return	false;		// not a nurbs surface

	MFnNurbsSurface	fnNurb(objNurb);

	if (fnNurb.degreeU() != 3 || fnNurb.degreeV() != 3)	
		return false;		// not a bicubic surface

	int	kFormInU	= fnNurb.formInU();
	int	kFormInV	= fnNurb.formInV();

	if (kFormInU == MFnNurbsSurface::kInvalid || kFormInV == MFnNurbsSurface::kInvalid)
		return false;		// surface has invalid form

	if (kFormInU == MFnNurbsSurface::kPeriodic || kFormInV == MFnNurbsSurface::kPeriodic)
		return false;		// can't handle periodic surfaces
	
	int	cCVsInU	= fnNurb.numCVsInU();
	int	cCVsInV	= fnNurb.numCVsInV();

	if ((cCVsInU - 1) % 3 != 0 || (cCVsInV - 1) % 3 != 0)
		return false;		// invalid control point count (we only deal with quad patches)

	int	cSpansInU	= (cCVsInU - 1) / 3;
	int	cSpansInV	= (cCVsInV - 1) / 3;

	if (cSpansInU <= 0 || cSpansInV <= 0)
		return false;		// invalid span count


	MPointArray rgCVs;

	fnNurb.getCVs(rgCVs);

	if ((int)rgCVs.length() != cCVsInU * cCVsInV)
		return false;		// inconsistency in cv count

	return true;			// all tests passed
}




int MyDtShapeGetVertices
	(
		int			iShape, 
		int*		pcVertices, 
		DtVec3f**	prgVertices
	)
{
	*pcVertices		= 0;
	*prgVertices	= NULL;

	DtVec3f*	rgVertices;

	if (!DtShapeGetVertices(iShape, pcVertices, &rgVertices))
	{
		*pcVertices	= 0;

		return 0;
	}

	if (!(*prgVertices	= new DtVec3f[*pcVertices]))
	{
		*pcVertices	= 0;

		return 0;
	}

	memcpy(*prgVertices, rgVertices, *pcVertices * sizeof(DtVec3f));

	return 1;
}


int MyDtShapeGetNormals
	(
		int			iShape, 
		int*		pcNormals, 
		DtVec3f**	prgNormals
	)
{
	*pcNormals	= 0;
	*prgNormals	= NULL;

	DtVec3f*	rgNormals;

	if (!DtShapeGetNormals(iShape, pcNormals, &rgNormals))
	{
		*pcNormals	= 0;

		return 0;
	}

	if (!(*prgNormals	= new DtVec3f[*pcNormals]))
	{
		*pcNormals	= 0;

		return 0;
	}

	memcpy(*prgNormals, rgNormals, *pcNormals * sizeof(DtVec3f));

	return 1;
}




int	MyDtShapeGetNormals
	(
		MObject&	objInput, 
		MObject&	objOutput, 
		int*		pcNormals, 
		DtVec3f**	prgNormals
	) 
{
	*pcNormals	= 0;
	*prgNormals	= NULL;

	assert(objInput.hasFn(MFn::kMesh) && objOutput.hasFn(MFn::kMesh));

	MFnMesh	fnInput(objInput);
	MFnMesh	fnOutput(objOutput);

	assert(fnInput.numNormals() == fnOutput.numNormals());
	
	*pcNormals	= fnInput.numNormals();
	*prgNormals	= new DtVec3f[*pcNormals];

	if (!*prgNormals)
	{
		*pcNormals	= 0;

		return 0;
	}

	MFloatVectorArray	rgOrigNormals;

	fnInput.getNormals(rgOrigNormals);

	assert(*pcNormals == (int)rgOrigNormals.length());

	for (int iNormal = 0; iNormal < *pcNormals; iNormal++) 
	{
		(*prgNormals)[iNormal].vec[0]	= rgOrigNormals[iNormal][0];
		(*prgNormals)[iNormal].vec[1]	= rgOrigNormals[iNormal][1];
		(*prgNormals)[iNormal].vec[2]	= rgOrigNormals[iNormal][2];
	}

	return 1;
}







int MyDtShapeGetTextureVertices
	(
		int			iShape, 
		int*		pcTexCoords, 
		DtVec2f**	prgTexCoords
	)
{
	*pcTexCoords	= 0;
	*prgTexCoords	= NULL;

	DtVec2f*	rgTexCoords;

	if (!DtShapeGetTextureVertices(iShape, pcTexCoords, &rgTexCoords))
	{
		*pcTexCoords	= 0;

		return 0;
	}

	if (!(*prgTexCoords	= new DtVec2f[*pcTexCoords]))
	{
		*pcTexCoords	= 0;

		return 0;
	}
	
	memcpy(*prgTexCoords, rgTexCoords, *pcTexCoords * sizeof(DtVec2f));

	return 1;
}





int MyDtShapeGetVerticesColor
	(
		int			iShape, 
		int*		pcColors, 
		DtRGBA**	prgColors
	)
{
	*pcColors	= 0;
	*prgColors	= NULL;

	DtRGBA*	rgColors;

	if (!DtShapeGetVerticesColor(iShape, pcColors, &rgColors))
	{
		*pcColors	= 0;

		return 0;
	}

	if (!(*prgColors	= new DtRGBA[*pcColors]))
	{
		*pcColors	= 0;

		return 0;
	}
	
	memcpy(*prgColors, rgColors, *pcColors * sizeof(DtRGBA));

	return 1;
}









int	MyDtShapeGetControlPoints
	(
		MObject&	objInput, 
		MObject&	objOutput, 
		int*		pcVertices, 
		DtVec3f**	prgVertices
	) 
{
	*pcVertices		= 0;
	*prgVertices	= NULL;

	
	assert(objInput.hasFn(MFn::kNurbsSurface) && objOutput.hasFn(MFn::kNurbsSurface));


	MFnNurbsSurface	fnOutput(objOutput);
	MFnNurbsSurface	fnInput(objInput);



	MPointArray rgCVs;

	fnInput.getCVs(rgCVs);

	*pcVertices		= rgCVs.length();
	*prgVertices	= new DtVec3f[*pcVertices];

	if (!*prgVertices) 
	{
		*pcVertices	= 0;

		return 0;
	}

	// WARNING:  Is this homogeneous coordinates? Should I divide w?
	for (int iVertex = 0; iVertex < *pcVertices; iVertex++) 
	{
		(*prgVertices)[iVertex].vec[0]	= (float)rgCVs[iVertex][0];
		(*prgVertices)[iVertex].vec[1]	= (float)rgCVs[iVertex][1];
		(*prgVertices)[iVertex].vec[2]	= (float)rgCVs[iVertex][2];
	}


	// check for tweaks
	MPlug	plgTweakLoc	= fnOutput.findPlug("tweakLocation");

	MObject	objTweakLocVal;

	plgTweakLoc.getValue(objTweakLocVal);

	if (!objTweakLocVal.isNull())	// tweak found
	{	
		MPlugArray	rgplgTweakLocConnections;

		plgTweakLoc.connectedTo(rgplgTweakLocConnections, true, false);		// get source plugs

		assert(rgplgTweakLocConnections.length() == 1);

		MObject	objTweak = rgplgTweakLocConnections[0].node();

		assert(objTweak.hasFn(MFn::kTweak));

		MFnGeometryFilter	fnTweak(objTweak);

		bool	bRelativeTweak;

		fnTweak.findPlug("relativeTweak").getValue(bRelativeTweak);

		if (!bRelativeTweak) 
			cout << "\t\tWARNING: Encountered an absolute tweak; treating as relative!" << endl;

		MPlug plgOffsets = fnTweak.findPlug("plist")[0].child(0);


		//	WARNING: Seems like Maya doesn't initialize it's numElements properly!!
//		assert((int)plgOffsets.numElements() == cVertices);
		if ((int)plgOffsets.numElements() != *pcVertices)
			cout << "\t\tWARNING: tweak count doesn't match vertex count!" << endl;

		float	fEnvelope	= fnTweak.envelope();

		for (int iVertex = 0; iVertex < *pcVertices; iVertex++) 
		{
			DtVec3f	vecOffset;

			plgOffsets.elementByLogicalIndex(iVertex).child(0).getValue(vecOffset.vec[0]);
			plgOffsets.elementByLogicalIndex(iVertex).child(1).getValue(vecOffset.vec[1]);
			plgOffsets.elementByLogicalIndex(iVertex).child(2).getValue(vecOffset.vec[2]);

			(*prgVertices)[iVertex].vec[0]	+= fEnvelope * vecOffset.vec[0];
			(*prgVertices)[iVertex].vec[1]	+= fEnvelope * vecOffset.vec[1];
			(*prgVertices)[iVertex].vec[2]	+= fEnvelope * vecOffset.vec[2];
		}
	}
			
			

	return 1;
}

















Mesh::Mesh() 
{
	m_kType					= Mesh::UNKNOWN;

	m_cGroups				= 0;
	m_rgGroups				= NULL;

	m_cVertices				= 0;
	m_rgVertices			= NULL;

	m_cVertexColors			= 0;
	m_rgVertexColors		= NULL;

	m_cNormals				= 0;
	m_rgNormals				= NULL;

	m_cTexCoords			= 0;
	m_rgTexCoords			= NULL;

	m_cReps					= 0;
	m_rgReps				= NULL;

	m_cFaces				= 0;
	m_rgFaces				= NULL;

    m_cFaceIndices			= 0;

	m_cBones				= 0;
	m_rgBones				= NULL;

	m_cMaxBonesPerFace		= 0;
	m_cMaxBonesPerVertex	= 0;
}



Mesh::~Mesh() 
{
	delete[] m_rgReps;

	delete[] m_rgVertices;
	delete[] m_rgNormals;
	delete[] m_rgTexCoords;
	delete[] m_rgVertexColors;

	for (int iFace = 0; iFace < m_cFaces; iFace++)
	{
		delete[] m_rgFaces[iFace].m_rgIndices;
	}

	delete[] m_rgFaces;

	delete[] m_rgGroups;

	for (int iBone = 0; iBone < m_cBones; iBone++) 
	{
		delete[] m_rgBones[iBone].m_rgfWeights;
		delete[] m_rgBones[iBone].m_rgiVertices;
	}

	delete[] m_rgBones;
}


Face::Face()
{
	m_cIndices	= 0;
	m_rgIndices	= NULL;

	m_iGroup	= -1;
}

Face::~Face() 
{
}


Bone::Bone()
{
	m_szName		= NULL;

	m_cWeights		= 0;
	m_rgfWeights	= NULL;
	m_rgiVertices	= NULL;

	m_cReps			= 0;
}

Bone::~Bone()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\shape\calloc.h ===
#ifndef __CALLOC_H__
#define __CALLOC_H__

// D3DX Memory Allocation Rules:
//
// The memory manager class CD3duAlloc will be able to provide useful debug
// information, if DBG is defined and you follow the rules below in D3DX.
// The memory statistics functions are are 
// DPF_ShowAllocStats() and DPF_ListUnfreedMemory().
//
// When DBG is *not* defined,
// all of the rules listed below will just automatically degenerate to plain
// vanilla C++ new/delete.
//
// 1) "Internal" memory.
//    To allocate objects and memory for use exclusively within D3DX, inherit
//    CD3duAlloc in your class, and just use the overloaded new and delete.
//
// 2) Interfaces
//    For interfaces which are to be returned to the app, such as the D3du
//    context interface, use ::new to create, and ::delete to destroy.
//    "::" forces the call not to use any overridden new, so this memory
//    does not get categorized as "Internal" memory.
//    For convenience, you can just use the #defines below for interfaces.

#define D3DX_INSTANTIATE_INTERFACE  ::new
#define D3DX_DESTROY_INTERFACE      ::delete

#if 0 // Debug memory allocator.  See below for the trivial non-debug version.

#define DPF_SHOWALLOCSTATS      DPF_ShowAllocStats
#define DPF_LISTUNFREEDMEMORY   DPF_ListUnfreedMemory

typedef struct _ALLOC_STUB
{
    LPVOID              pvMem;       // allocated memory
    DWORD               dwSize;       // size allocated
    DWORD               dwAllocationNumber; // allocation number 
                                            // (first allocation is allocation 1)
                              // This can help track down the source of unfreed memory.
    _ALLOC_STUB*        pNext;
} ALLOC_STUB;

void DPF_ListUnfreedMemory();
void DPF_ShowAllocStats();

class CD3duAlloc
{
public:
    CD3duAlloc();
    void* operator new(size_t size);
    void operator delete(void* pv);
};

#else

#define DPF_SHOWALLOCSTATS()
#define DPF_LISTUNFREEDMEMORY()

class CD3duAlloc
{
public:
    void* operator new(size_t size)
    {
        return new BYTE[size];
    }

    void operator delete(void* pv)
    {
        if( pv ) delete pv;
    }
};

#endif

extern CD3duAlloc g_CD3duAlloc; 

#endif //__CALLOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\plugins\maya30\xporttranslator.cpp ===
// TBD	
//		- magic number "xof";
//		- skinning for bezier patches????
//		- adjust normals according to tweaks
//		- test animation with different models (hierarchies, etc.)
//		- support for single-sided vs. double sided
//		- check whether there really is vertex coloring info
//		- make sure that shape names are unique and valid
//		- option to export only selected items
//		- uncomment vertex coloring info


// DONE
//		- multiply envelope by tweaks
//		- export bicubic bezier patches
//		- relative pathnames for textures
//		- make animation optional
//		- speed up animation by rearranging loops
//		- error handling
//		- free Mesh::rgBones[iBone].m_szName
//		- option to flip UV tex coords
//		- option for animation transforms a) ONLY at keyframes or b) at EVERY frame
//		- dialog box interface
//		- option for Text/Binary/Compressed mode

// BUGS
//		- wierd errors loading cowboy.		- Dt library crashes during it's initialization





#include "MyDt.h"
#include "MyAssert.h"

#include "xportTranslator.h"

#include <iostream.h>



// DirectX File Format
#include <dxfile.h>

#include <initguid.h>
#include <rmxfguid.h>
#include <rmxftmpl.h>

// Additional X-file Templates
#include "xskinexptemplates.h"

const GUID* aIds[] = {&DXFILEOBJ_XSkinMeshHeader,
					  &DXFILEOBJ_VertexDuplicationIndices,
					  &DXFILEOBJ_SkinWeights};


// Maya API
#include <maya/MFnPlugin.h>
#include <maya/MSimple.h>
#include <maya/MObject.h>
#include <maya/MColor.h>
#include <maya/MMatrix.h>
#include <maya/MDagPath.h>
#include <maya/MTime.h>
#include <maya/MAnimControl.h>

#include <maya/MDataBlock.h>
#include <maya/MDataHandle.h>

#include <maya/MIntArray.h>
#include <maya/MFloatArray.h>
#include <maya/MFloatVectorArray.h>
#include <maya/MFloatPointArray.h>
#include <maya/MPointArray.h>
#include <maya/MObjectArray.h>
#include <maya/MDagPathArray.h>
#include <maya/MPlugArray.h>
#include <maya/MSelectionList.h>

#include <maya/MFnMatrixData.h>
#include <maya/MFnMeshData.h>
#include <maya/MFnDoubleArrayData.h>
#include <maya/MFnVectorArrayData.h>

#include <maya/MFnSingleIndexedComponent.h>
#include <maya/MFnDoubleIndexedComponent.h>
#include <maya/MFnSet.h>
#include <maya/MFnTypedAttribute.h>
#include <maya/MFnSkinCluster.h>
#include <maya/MFnWeightGeometryFilter.h>
#include <maya/MFnDagNode.h>
#include <maya/MFnIKJoint.h>
#include <maya/MFnMesh.h>
#include <maya/MFnNurbsSurface.h>
#include <maya/MFnLambertShader.h>

#include <maya/MItDependencyNodes.h>
#include <maya/MItGeometry.h>



extern	StringTable g_Strings;


// Dt API
#include <MDt.h>
#include <MDtExt.h>


// Options

DXFILEFORMAT			g_FileFormat;
extern	bool			g_bExportAnimation;
extern	bool			g_bKeyframeAnimation;
extern	bool			g_bAnimateEverything;
extern	int				g_iFrameStep;
extern	int				g_iFlipU;
extern	int				g_iFlipV;
extern	bool			g_bRelativeTexFile;
extern	bool			g_bExportPatches;












HRESULT	AddAnim
		(
			Anim*					pAnim, 
			LPDIRECTXFILEDATA		pAnimSetObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{
	HRESULT				hr							= S_OK;
	
	LPDIRECTXFILEDATA	pAnimDataObject				= NULL;

	LPDIRECTXFILEDATA	pQuaternionKeyDataObject	= NULL;
	LPDIRECTXFILEDATA	pScaleKeyDataObject			= NULL;
	LPDIRECTXFILEDATA	pPositionKeyDataObject		= NULL;

	PBYTE				pbQuaternionKeyData			= NULL;
	PBYTE				pbScaleKeyData				= NULL;
	PBYTE				pbPositionKeyData			= NULL;



	INIT;



	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMAnimation, NULL, NULL, 0, NULL, &pAnimDataObject),
				"Could not create pAnimDataObject.");


	int		cbQuaternionKeySize	= sizeof(DWORD)												// keyType
								+ sizeof(DWORD)												// nKeys
								+ pAnim->m_cKeys 
									* (sizeof(DWORD) + sizeof(DWORD) + 4 * sizeof(float));	// keys[nKeys]


	PBYTE	pbQuaternionKeyCurr	= pbQuaternionKeyData	= new BYTE[cbQuaternionKeySize];

	ASSERT(pbQuaternionKeyData,
				"Could not allocate memory for pbQuaternionKeyData.");


	int		cbScaleKeySize	= sizeof(DWORD)													// keyType
							+ sizeof(DWORD)													// nKeys
							+ pAnim->m_cKeys 
								* (sizeof(DWORD) + sizeof(DWORD) + 3 * sizeof(float));		// keys[nKeys]

	PBYTE	pbScaleKeyCurr	= pbScaleKeyData	= new BYTE[cbScaleKeySize];

	ASSERT(pbScaleKeyData,
				"Could not allocate memory for pbScaleKeyData.");


	int		cbPositionKeySize	= sizeof(DWORD)												// keyType
								+ sizeof(DWORD)												// nKeys
								+ pAnim->m_cKeys 
									* (sizeof(DWORD) + sizeof(DWORD) + 3 * sizeof(float));	// keys[nKeys]

	PBYTE	pbPositionKeyCurr	= pbPositionKeyData	= new BYTE[cbPositionKeySize];

	ASSERT(pbPositionKeyData,
				"Could not allocate memory for pbPositionKeyData.");


	// keyType
	WRITE_DWORD(pbQuaternionKeyCurr,	((DWORD)0));
	WRITE_DWORD(pbScaleKeyCurr,			((DWORD)1));
	WRITE_DWORD(pbPositionKeyCurr,		((DWORD)2));

	// nKeys
	WRITE_DWORD(pbQuaternionKeyCurr,	((DWORD)pAnim->m_cKeys));
	WRITE_DWORD(pbScaleKeyCurr,			((DWORD)pAnim->m_cKeys));
	WRITE_DWORD(pbPositionKeyCurr,		((DWORD)pAnim->m_cKeys));

	// keys[nKeys]
	for (int iKey = 0; iKey < pAnim->m_cKeys; iKey++) 
	{
		// time
		WRITE_DWORD(pbQuaternionKeyCurr,	((DWORD)pAnim->m_rgKeys[iKey].m_iFrame));
		WRITE_DWORD(pbScaleKeyCurr,			((DWORD)pAnim->m_rgKeys[iKey].m_iFrame));
		WRITE_DWORD(pbPositionKeyCurr,		((DWORD)pAnim->m_rgKeys[iKey].m_iFrame));


		// nValues
		WRITE_DWORD(pbQuaternionKeyCurr,	((DWORD)4));
		WRITE_DWORD(pbScaleKeyCurr,			((DWORD)3));
		WRITE_DWORD(pbPositionKeyCurr,		((DWORD)3));

		// values
		WRITE_FLOAT(pbQuaternionKeyCurr,   -pAnim->m_rgKeys[iKey].m_rgfQuaternion[0]);
		WRITE_FLOAT(pbQuaternionKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfQuaternion[1]);
		WRITE_FLOAT(pbQuaternionKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfQuaternion[2]);
		WRITE_FLOAT(pbQuaternionKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfQuaternion[3]);

		WRITE_FLOAT(pbScaleKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfScale[0]);
		WRITE_FLOAT(pbScaleKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfScale[1]);
		WRITE_FLOAT(pbScaleKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfScale[2]);

		WRITE_FLOAT(pbPositionKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfPosition[0]);
		WRITE_FLOAT(pbPositionKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfPosition[1]);
		WRITE_FLOAT(pbPositionKeyCurr,	pAnim->m_rgKeys[iKey].m_rgfPosition[2]);
	}

	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMAnimationKey, NULL, NULL, cbQuaternionKeySize, pbQuaternionKeyData, &pQuaternionKeyDataObject),
				"Could not create pQuaternionKeyDataObject.");


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMAnimationKey, NULL, NULL, cbScaleKeySize, pbScaleKeyData, &pScaleKeyDataObject),
				"Could not create pScaleKeyDataObject.");


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMAnimationKey, NULL, NULL, cbPositionKeySize, pbPositionKeyData, &pPositionKeyDataObject),
				"Could not create pPositionKeyDataObject.");


	HR_ATTEMPT(pAnimDataObject->AddDataReference(pAnim->m_szName, NULL),
				"Could not add data reference to pAnimDataObject.");

    HR_ATTEMPT(pAnimDataObject->AddDataObject(pQuaternionKeyDataObject),
				"Could not add pQuaternionKeyDataObject to pAnimDataObject.");


	HR_ATTEMPT(pAnimDataObject->AddDataObject(pScaleKeyDataObject),
				"Could not add pScaleKeyDataObject to pAnimDataObject.");

	
	HR_ATTEMPT(pAnimDataObject->AddDataObject(pPositionKeyDataObject),
				"Could not add pPositionKeyDataObject to pAnimDataObject.");



	HR_ATTEMPT(pAnimSetObject->AddDataObject(pAnimDataObject),
				"Could not add pAnimDataObject to pAnimSetObject.");



	EXIT;



	delete[] pbQuaternionKeyData;

	delete[] pbScaleKeyData;
	
	delete[] pbPositionKeyData;


	if (pQuaternionKeyDataObject)
		pQuaternionKeyDataObject->Release();

	if (pScaleKeyDataObject)
		pScaleKeyDataObject->Release();

	if (pPositionKeyDataObject)
		pPositionKeyDataObject->Release();

	if (pAnimDataObject)
		pAnimDataObject->Release();


	return hr;
}










HRESULT	loadAllAnims
		(
			Anim*	rgAnims
		) 
{
	HRESULT	hr	= S_OK;

	cout << "\treading at intervals of " << g_iFrameStep << " frame(s)" << endl;

	// calculate the frames per second
	int	iFPS	= 1;

	switch(MTime::uiUnit()) 
	{
		case MTime::kSeconds:		// 1 fps
			iFPS	= 1;
			break;
		case MTime::kMilliseconds:	// 1000 fps
			iFPS	= 1000;
			break;
		case MTime::kGames:			// 15 fps
			iFPS	= 15;
			break;
		case MTime::kFilm:			// 24 fps
			iFPS	= 24;
			break;
		case MTime::kPALFrame:		// 25 fps
			iFPS	= 25;
			break;
		case MTime::kNTSCFrame:		// 30 fps
			iFPS	= 30;
			break;
		case MTime::kShowScan:		// 48 fps
			iFPS	= 48;
			break;
		case MTime::kPALField:		// 50 fps
			iFPS	= 50;
			break;
		case MTime::kNTSCField:		// 60 fps
			iFPS	= 60;
			break;
		default:
			iFPS	= 1;
			break;
	};

	float fTimeFactor	= 3600.0f / (float)iFPS;


	MTime	timeStart(MAnimControl::minTime().value(), MTime::uiUnit());
	MTime	timeEnd(MAnimControl::maxTime().value(), MTime::uiUnit());
	MTime	timeCurrent(MAnimControl::currentTime().value(), MTime::uiUnit());


	DtFrameSetStart((int)timeStart.value());
	DtFrameSetEnd((int)timeEnd.value());


	int cShapes	= DtShapeGetCount();


	MIntArray*	rgrgiKeys	= new MIntArray[cShapes];


	for (int iShape = 0; iShape < cShapes; iShape++) 
	{
		rgAnims[iShape].m_szName	= new char[256];
		rgAnims[iShape].m_cKeys		= 0;
		rgAnims[iShape].m_rgKeys	= new Key[1 + (DtFrameGetEnd() - DtFrameGetStart() + 1) / g_iFrameStep];

		g_Strings.add(rgAnims[iShape].m_szName);

		char* szName;

		DtShapeGetName(iShape, &szName);

		strcpy(rgAnims[iShape].m_szName, szName);

		DtShapeGetTRSAnimKeys(iShape, &rgrgiKeys[iShape]);
	}

	for (int iFrame = DtFrameGetStart(); iFrame <= DtFrameGetEnd(); iFrame += g_iFrameStep) 
	{
		DtFrameSet(iFrame);

		for (int iShape = 0; iShape < cShapes; iShape++) 
		{
			if (rgrgiKeys[iShape].length() > 0 || g_bAnimateEverything) 
			{
				rgAnims[iShape].m_rgKeys[rgAnims[iShape].m_cKeys].m_iFrame	= (int)((float)iFrame * fTimeFactor);

				float*	rgfTRS;

				DtShapeGetMatrix(iShape, &rgfTRS);

				DtMatrixGetTransforms(rgfTRS, 
									  rgAnims[iShape].m_rgKeys[rgAnims[iShape].m_cKeys].m_rgfPosition, 
									  rgAnims[iShape].m_rgKeys[rgAnims[iShape].m_cKeys].m_rgfScale, 
									  rgAnims[iShape].m_rgKeys[rgAnims[iShape].m_cKeys].m_rgfQuaternion, 
									  rgAnims[iShape].m_rgKeys[rgAnims[iShape].m_cKeys].m_rgfRotation);

				rgAnims[iShape].m_cKeys++;
			}
		}
	}

	DtFrameSet((int)timeCurrent.value());

	delete[] rgrgiKeys;

	return hr;
}



void	freeAllAnims
		(
			Anim*	rgAnims
		) 
{
	for (int iShape = 0; iShape < DtShapeGetCount(); iShape++)
		delete[] rgAnims[iShape].m_rgKeys;
}


HRESULT	loadAnim
		(
			int		iShape, 
			Anim*	pAnim
		) 
{
	HRESULT	hr	= S_OK;


	char*	szName;

	DtShapeGetName(iShape, &szName);


	cout << "\treading " << szName << endl;

	int		cKeys	= 0;
	Key*	rgKeys	= NULL;


	MTime	timeStart(MAnimControl::minTime().value(), MTime::uiUnit());
	MTime	timeEnd(MAnimControl::maxTime().value(), MTime::uiUnit());
	MTime	timeCurrent(MAnimControl::currentTime().value(), MTime::uiUnit());

	MIntArray	rgiKeys;

	DtShapeGetTRSAnimKeys(iShape, &rgiKeys);


	cKeys	= rgiKeys.length();

	if (cKeys > 0) 
	{
		DtFrameSetStart(rgiKeys[0]);
		DtFrameSetEnd(rgiKeys[cKeys - 1]);

		// calculate the frames per second
		int	iFPS	= 1;

		switch(MTime::uiUnit()) 
		{
			case MTime::kSeconds:		// 1 fps
				iFPS	= 1;
				break;
			case MTime::kMilliseconds:	// 1000 fps
				iFPS	= 1000;
				break;
			case MTime::kGames:			// 15 fps
				iFPS	= 15;
				break;
			case MTime::kFilm:			// 24 fps
				iFPS	= 24;
				break;
			case MTime::kPALFrame:		// 25 fps
				iFPS	= 25;
				break;
			case MTime::kNTSCFrame:		// 30 fps
				iFPS	= 30;
				break;
			case MTime::kShowScan:		// 48 fps
				iFPS	= 48;
				break;
			case MTime::kPALField:		// 50 fps
				iFPS	= 50;
				break;
			case MTime::kNTSCField:		// 60 fps
				iFPS	= 60;
				break;
			default:
				iFPS	= 1;
				break;
		};


		float fTimeFactor	= 3600.0f / (float)iFPS;

		
		rgKeys	= new Key[cKeys];

		for (int iKey = 0; iKey < cKeys; iKey++) 
		{
			rgKeys[iKey].m_iFrame	= (int)((float)rgiKeys[iKey] * fTimeFactor);

			DtFrameSet(rgiKeys[iKey]);

			float*	rgfTRS;

			DtShapeGetMatrix(iShape, &rgfTRS);

			DtMatrixGetTransforms(rgfTRS, rgKeys[iKey].m_rgfPosition, rgKeys[iKey].m_rgfScale, rgKeys[iKey].m_rgfQuaternion, rgKeys[iKey].m_rgfRotation);
		}

		DtFrameSetStart((int)timeStart.value());
		DtFrameSetEnd((int)timeEnd.value());
		DtFrameSet((int)timeCurrent.value());
	}


	pAnim->m_szName	= new char[256];

	g_Strings.add(pAnim->m_szName);

	strcpy(pAnim->m_szName, szName);

	pAnim->m_cKeys	= cKeys; 
	pAnim->m_rgKeys	= rgKeys;


	return hr;
}











void	freeAnim
		(
			Anim*	pAnim
		) 
{
	delete[] pAnim->m_rgKeys;
}




//	Assumes that the shape is indeed a patch mesh.  This can be checked using MyDtShapeIsPatchMesh

HRESULT	LoadPatchMesh
		(
			int		iShape, 
			Mesh*	pShape
		) 
{
	HRESULT	hr		= S_OK;
	MStatus	mStat	= MS::kSuccess;

	
	// set up references

	Mesh::ShapeType&	kType		= pShape->m_kType;

	int&		cReps				= pShape->m_cReps;
	Rep*&		rgReps				= pShape->m_rgReps;

	int&		cVertices			= pShape->m_cVertices;
	DtVec3f*&	rgVertices			= pShape->m_rgVertices;

	int&		cNormals			= pShape->m_cNormals;
	DtVec3f*&	rgNormals			= pShape->m_rgNormals;

	int&		cTexCoords			= pShape->m_cTexCoords;
	DtVec2f*&	rgTexCoords			= pShape->m_rgTexCoords;

	int&		cVertexColors		= pShape->m_cVertexColors;
	DtRGBA*&	rgVertexColors		= pShape->m_rgVertexColors;


	int&		cFaces				= pShape->m_cFaces;
	Face*&		rgFaces				= pShape->m_rgFaces;

	int&		cFaceIndices		= pShape->m_cFaceIndices;

	int&		cGroups				= pShape->m_cGroups;
	Group*&		rgGroups			= pShape->m_rgGroups;


	int&		cBones				= pShape->m_cBones;
	Bone*&		rgBones				= pShape->m_rgBones;

	int&		cMaxBonesPerVertex	= pShape->m_cMaxBonesPerVertex;
	int&		cMaxBonesPerFace	= pShape->m_cMaxBonesPerFace;



	INIT;		// begin error checking

	// ensure that shape is a nurbs surface
	MObject	objNurb;

	DT_ATTEMPT(DtExt_ShapeGetShapeNode(iShape, objNurb));

	ASSERT(objNurb.hasFn(MFn::kNurbsSurface),	
				"Not a nurb surface");

	MFnNurbsSurface	fnNurb(objNurb);

	// ensure that surface is bicubic
	ASSERT(fnNurb.degreeU() == 3 && fnNurb.degreeV() == 3,	
				"Not a bicubic surface");

	// ensure correct form in U and V 
	int	kFormInU	= fnNurb.formInU();
	int	kFormInV	= fnNurb.formInV();

	ASSERT(kFormInU	== MFnNurbsSurface::kOpen || kFormInU == MFnNurbsSurface::kClosed,
				"Invalid form in U");

	ASSERT(kFormInV == MFnNurbsSurface::kOpen || kFormInV == MFnNurbsSurface::kClosed,
				"Invalid form in V");

	// ensure that surface is a quad mesh
	int	cCVsInU	= fnNurb.numCVsInU();
	int	cCVsInV	= fnNurb.numCVsInV();

	ASSERT((cCVsInU - 1) % 3 == 0 && (cCVsInV - 1) % 3 == 0,
				"Invalid CV count");

	// ensure that there is at least one patch
	int	cSpansInU	= (cCVsInU - 1) / 3;
	int	cSpansInV	= (cCVsInV - 1) / 3;

	ASSERT(cSpansInU > 0 && cSpansInV > 0, 
				"Invalid span count");


	// control vertices

	MPointArray rgCVs;

	fnNurb.getCVs(rgCVs);

	cVertices	= (int)rgCVs.length();
	rgVertices	= new DtVec3f[cVertices];

	ASSERT(rgVertices, 
				"Can't allocate memory for vertex array");

	for (int iVertex = 0; iVertex < cVertices; iVertex++) 
	{
		rgVertices[iVertex].vec[0]	= (float)rgCVs[iVertex][0];
		rgVertices[iVertex].vec[1]	= (float)rgCVs[iVertex][1];
		rgVertices[iVertex].vec[2]	= (float)rgCVs[iVertex][2];
	}



	// texture coordinates
	cTexCoords	= (int)rgCVs.length();
	rgTexCoords	= new DtVec2f[cTexCoords];

	ASSERT(rgTexCoords, 
				"Can't allocate memory for texture coordinate array");

	for (int iCVInU = 0, iTexCoord = 0; iCVInU < cCVsInU; iCVInU++)
	{
		for (int iCVInV = 0; iCVInV < cCVsInV; iCVInV++, iTexCoord++)
		{
			rgTexCoords[iTexCoord].vec[0] =  ((float)iCVInU) / ((float)(cCVsInU - 1));
			rgTexCoords[iTexCoord].vec[1] =  ((float)iCVInV) / ((float)(cCVsInV - 1));
		}
	}



	// face info
	cFaces	= cSpansInU * cSpansInV;
	rgFaces	= new Face[cFaces];

	ASSERT(rgFaces, 
				"Can't allocate memory for patch array");


	cFaceIndices	= 0;
			
	for (int iSpanInU = 0, iPatch = 0; iSpanInU < cSpansInU; iSpanInU++) 
	{
		int iCVIndexInU	= iSpanInU * 3;

		for (int iSpanInV = 0; iSpanInV < cSpansInV; iSpanInV++, iPatch++) 
		{
			int iCVIndexInV	= iSpanInV * 3;

			rgFaces[iPatch].m_cIndices		= 16;
            rgFaces[iPatch].m_rgIndices		= new int[rgFaces[iPatch].m_cIndices];

			ASSERT(rgFaces[iPatch].m_rgIndices,
						"Could not allocate memory for patch indices");

            rgFaces[iPatch].m_rgIndices[0]	= cCVsInV * (iCVIndexInU + 0) + (iCVIndexInV + 0);
            rgFaces[iPatch].m_rgIndices[1]	= cCVsInV * (iCVIndexInU + 1) + (iCVIndexInV + 0);
			rgFaces[iPatch].m_rgIndices[2]	= cCVsInV * (iCVIndexInU + 2) + (iCVIndexInV + 0);

            rgFaces[iPatch].m_rgIndices[3]	= cCVsInV * (iCVIndexInU + 3) + (iCVIndexInV + 0);
			rgFaces[iPatch].m_rgIndices[4]	= cCVsInV * (iCVIndexInU + 3) + (iCVIndexInV + 1);
			rgFaces[iPatch].m_rgIndices[5]	= cCVsInV * (iCVIndexInU + 3) + (iCVIndexInV + 2);

			rgFaces[iPatch].m_rgIndices[6]	= cCVsInV * (iCVIndexInU + 3) + (iCVIndexInV + 3);
			rgFaces[iPatch].m_rgIndices[7]	= cCVsInV * (iCVIndexInU + 2) + (iCVIndexInV + 3);
			rgFaces[iPatch].m_rgIndices[8]	= cCVsInV * (iCVIndexInU + 1) + (iCVIndexInV + 3);

			rgFaces[iPatch].m_rgIndices[9]	= cCVsInV * (iCVIndexInU + 0) + (iCVIndexInV + 3);
			rgFaces[iPatch].m_rgIndices[10]	= cCVsInV * (iCVIndexInU + 0) + (iCVIndexInV + 2);
			rgFaces[iPatch].m_rgIndices[11]	= cCVsInV * (iCVIndexInU + 0) + (iCVIndexInV + 1);

			rgFaces[iPatch].m_rgIndices[12]	= cCVsInV * (iCVIndexInU + 1) + (iCVIndexInV + 1);
			rgFaces[iPatch].m_rgIndices[13]	= cCVsInV * (iCVIndexInU + 2) + (iCVIndexInV + 1);

			rgFaces[iPatch].m_rgIndices[14]	= cCVsInV * (iCVIndexInU + 2) + (iCVIndexInV + 2);
			rgFaces[iPatch].m_rgIndices[15]	= cCVsInV * (iCVIndexInU + 1) + (iCVIndexInV + 2);

			rgFaces[iPatch].m_iGroup		= 0;			//	WARNING: assumes only 1 material per surface


			cFaceIndices	+= rgFaces[iPatch].m_cIndices;
		}
	}



	// material info

	cGroups		= DtGroupGetCount(iShape);
	rgGroups	= new Group[cGroups];

	ASSERT(rgGroups, 
				"Can't allocate memory for material group array");


	ASSERT(cGroups == 1,
				"Assumption was made that NURBS surfaces have only 1 material");


	for (int iGroup	= 0; iGroup < cGroups; iGroup++)
	{

		// material name
		DT_ATTEMPT(DtMtlGetName(iShape, iGroup, &rgGroups[iGroup].m_szMaterial));

		// texture file name
		DT_ATTEMPT(MyDtTextureGetFileName(rgGroups[iGroup].m_szMaterial, &rgGroups[iGroup].m_szTextureFile));

		// diffuse color 
		if (!rgGroups[iGroup].m_szTextureFile)
		{
			DT_ATTEMPT(DtMtlGetDiffuseClr(rgGroups[iGroup].m_szMaterial, 0, 
									   &rgGroups[iGroup].m_fDiffuseRed, 
									   &rgGroups[iGroup].m_fDiffuseGreen,
									   &rgGroups[iGroup].m_fDiffuseBlue));
		}
		else 	// material has a texture
		{
			//	load the diffuse factor into the diffuse components

			int		iMaterial;

			DT_ATTEMPT(DtMtlGetID(iShape, iGroup, &iMaterial));

			MObject	mShader;

			DT_ATTEMPT(DtExt_MtlGetShader(iMaterial, mShader));

			MFnLambertShader	fnShader;

			fnShader.setObject(mShader);

			float	fDiffuseFactor	= fnShader.diffuseCoeff();

			rgGroups[iGroup].m_fDiffuseRed	= fDiffuseFactor;
			rgGroups[iGroup].m_fDiffuseGreen	= fDiffuseFactor;
			rgGroups[iGroup].m_fDiffuseBlue	= fDiffuseFactor;
		}

		// specular color
		DT_ATTEMPT(DtMtlGetSpecularClr(rgGroups[iGroup].m_szMaterial, 0, 
									&rgGroups[iGroup].m_fSpecularRed, 
									&rgGroups[iGroup].m_fSpecularGreen, 
									&rgGroups[iGroup].m_fSpecularBlue));

		// emissive color
		DT_ATTEMPT(DtMtlGetEmissiveClr(rgGroups[iGroup].m_szMaterial, 0, 
									&rgGroups[iGroup].m_fEmissiveRed, 
									&rgGroups[iGroup].m_fEmissiveGreen, 
									&rgGroups[iGroup].m_fEmissiveBlue));

		// power / shininess
		DT_ATTEMPT(DtMtlGetShininess(rgGroups[iGroup].m_szMaterial, 0, &rgGroups[iGroup].m_fShininess));

		// transparency / alpha
		DT_ATTEMPT(DtMtlGetTransparency(rgGroups[iGroup].m_szMaterial, 0, &rgGroups[iGroup].m_fTransparency));
	}
	




	// vertex duplication info (very simple for patch meshes)

	cReps	= (int)rgCVs.length();
	rgReps	= new Rep[cReps];

	ASSERT(rgReps, 
				"Can't allocate memory for rep array");

	for (int iRep = 0; iRep < cReps; iRep++) 
	{
		rgReps[iRep].m_iNormalIdx	= -1;			// patches don't export normal info
		rgReps[iRep].m_iTexCoordIdx	= iRep;
		rgReps[iRep].m_iFirst		= iRep;
		rgReps[iRep].m_iNext		= iRep;

		rgReps[iRep].m_cReps		= 1;
	}



	// skinning info
			

	MObject	objShape;
	MObject objTransform;
	MObject	objInput;

	DT_ATTEMPT(DtExt_ShapeGetShapeNode(iShape, objShape));
	DT_ATTEMPT(DtExt_ShapeGetTransform(iShape, objTransform));




	// load the mesh's world transform (needed if skinning info is found)
	MDagPath	pathTransform;

	MFnDagNode(objTransform).getPath(pathTransform);

	MMatrix		matMeshWorldTransform	= pathTransform.inclusiveMatrix();





	cBones				= 0;
	rgBones				= NULL;

	cMaxBonesPerVertex	= 0;
	cMaxBonesPerFace	= 0;


	MObjectArray	rgobjBones;







	// smooth skinning

	bool*	rgbNonZeroFlagTable	= NULL;		// table of influences vs. vertices
	int*	rgcNonZeros			= NULL;		// array of influence counts 

	bool bFoundSmoothSkin	= false;

	if (objShape.hasFn(MFn::kNurbsSurface)) 		// if this shape is a mesh
	{ 
		// loop through skin clusters
		for (MItDependencyNodes itSkin(MFn::kSkinClusterFilter); !itSkin.isDone(); itSkin.next()) 
		{
			MFnSkinCluster fnSkin(itSkin.item());

			// load input and output geometries
			MObjectArray	rgInputs;
			MObjectArray	rgOutputs;

			fnSkin.getInputGeometry(rgInputs);
			fnSkin.getOutputGeometry(rgOutputs);

			assert(rgInputs.length() == rgOutputs.length());		// ensure that input geometry count 
																	// equals output geometry count

			int	cInputs, cOutputs;

			cInputs	= cOutputs	= (int)rgOutputs.length();

			// loop through the output geometries
			for (int iOutput = 0, iInput = 0; iOutput < cOutputs; iOutput++, iInput++) 
			{
				assert(iOutput == iInput);		// sanity check

				
				if (rgOutputs[iOutput] == objShape) 		// if our shape is one of the output geometries
				{
					MDagPathArray	rgdagpathInfluences;
					
					cBones	= (int)fnSkin.influenceObjects(rgdagpathInfluences, &mStat);

					rgBones	= new Bone[cBones];

					ASSERT(rgBones,
								"Could not allocate memory for bone array");


					// initialize bones
					for (int iBone = 0; iBone < cBones; iBone++) 
					{	// WARNING: not checking for new failure
						rgBones[iBone].m_szName			= new char[256];
						rgBones[iBone].m_cReps			= 0;
						rgBones[iBone].m_cWeights		= 0;
						rgBones[iBone].m_rgiVertices	= new int[cVertices];
						rgBones[iBone].m_rgfWeights		= new float[cVertices];

						g_Strings.add(rgBones[iBone].m_szName);		// housekeeping

						// bone name
						strcpy(rgBones[iBone].m_szName, rgdagpathInfluences[iBone].partialPathName().asChar());

						// matrix offset
						MFnIkJoint fnBone(rgdagpathInfluences[iBone]);

						MObject objBindPose;

						fnBone.findPlug("bindPose").getValue(objBindPose);

						MFnMatrixData fnBindPose(objBindPose);

						(matMeshWorldTransform * fnBindPose.matrix().inverse()).get(rgBones[iBone].m_matOffset);



						rgobjBones.append(rgdagpathInfluences[iBone].node());
					}

					rgcNonZeros			= new int[cVertices];

					ASSERT(rgcNonZeros,
								"Could not allocate memory for non zero count array");

					rgbNonZeroFlagTable	= new bool[cVertices * cBones];

					ASSERT(rgbNonZeroFlagTable,
								"Could not allocate memory for non zero table");

					// bone info; calculate max number of bones per vertex
					cMaxBonesPerVertex = 0;

					int iVertex = 0;

					MFnNurbsSurface fnOutput(rgOutputs[iOutput]);

					MDagPath dagpathOutputShape;
				
					fnOutput.getPath(dagpathOutputShape);

					// loop through the vertices
					for (MItGeometry itGeom(rgOutputs[iOutput]); !itGeom.isDone(); itGeom.next()) 
					{
	
						MFloatArray rgfWeights;

						unsigned cInfs;

						fnSkin.getWeights(dagpathOutputShape, itGeom.component(), rgfWeights, cInfs);

						int a = rgdagpathInfluences.length();
						int b = rgfWeights.length();
						int c = itGeom.count();

						assert(rgdagpathInfluences.length() == rgfWeights.length());
						assert(rgfWeights.length() == cInfs);

						rgcNonZeros[iVertex] = 0;


						float fWeightSum = 0.0f;

						for (int iBone = 0; iBone < cBones; iBone++)
							fWeightSum += rgfWeights[iBone];

						assert(fWeightSum > 0.00001f);

						for (iBone = 0; iBone < cBones; iBone++) 
						{
							rgbNonZeroFlagTable[iBone * cVertices + iVertex]	= false;

							rgfWeights[iBone] = rgfWeights[iBone] / fWeightSum;		// normalize the weight

							if (rgfWeights[iBone] != 0.0f) 
							{
								rgcNonZeros[iVertex]++;

								rgBones[iBone].m_cReps += rgReps[iVertex].m_cReps;
		
								rgBones[iBone].m_rgiVertices[rgBones[iBone].m_cWeights]	= iVertex;							
								rgBones[iBone].m_rgfWeights[rgBones[iBone].m_cWeights]	= rgfWeights[iBone];

								rgbNonZeroFlagTable[iBone * cVertices + iVertex]	= true;

								rgBones[iBone].m_cWeights++;
							}
						}


						if (rgcNonZeros[iVertex] > cMaxBonesPerVertex)
							cMaxBonesPerVertex = rgcNonZeros[iVertex];

						iVertex++;
					}



					// calculate max number of bones per vertex

					cMaxBonesPerFace	= 0;

					for (int iFace = 0; iFace < cFaces; iFace++) 
					{
						int	cBonesPerFace	= 0;

						for (int iBone = 0; iBone < cBones; iBone++) 
						{
							for (int iIndex = 0; iIndex < rgFaces[iFace].m_cIndices; iIndex++) 
							{
								if (rgbNonZeroFlagTable[iBone * cVertices + rgReps[rgFaces[iFace].m_rgIndices[iIndex]].m_iFirst]) 
								{
									cBonesPerFace++;

									break;
								}
							}
						}

						if (cBonesPerFace > cMaxBonesPerFace)
							cMaxBonesPerFace = cBonesPerFace;
					}




					objInput = rgInputs[iInput];

					bFoundSmoothSkin = true;

					break;
				}
			}

			if (bFoundSmoothSkin)
				break;
		}
	}


	delete[] rgcNonZeros;
	delete[] rgbNonZeroFlagTable;



















	// rigid skinning

	rgbNonZeroFlagTable	= NULL;

	bool	bFoundRigidSkin	= false;

	if (!bFoundSmoothSkin) 	
	{
		cBones			= 1;						// zero'th bone is the extra "fake" bone
		int cBonesMax	= 64;
		rgBones			= new Bone[cBonesMax];

		ASSERT(rgBones,
					"Could not allocate memory for bone array");

		rgbNonZeroFlagTable	= new bool[cBonesMax * cVertices];

		ASSERT(rgbNonZeroFlagTable,
					"Could not allocate memory for non-zero flag table");

		// fill non zero table with 0's
		memset(rgbNonZeroFlagTable, 0, cBonesMax * cVertices * sizeof(bool));

		// initialize "fake" iBone
		// WARNING: not checking for new failure
		rgBones[0].m_szName			= new char[256];
		rgBones[0].m_cReps			= 0;
		rgBones[0].m_cWeights		= 0;
		rgBones[0].m_rgfWeights		= new float[cVertices];
		rgBones[0].m_rgiVertices	= new int[cVertices];

		g_Strings.add(rgBones[0].m_szName);							// housekeeping

		strcpy(rgBones[0].m_szName, SCENE_ROOT);					// bone name
	
		matMeshWorldTransform.get(rgBones[0].m_matOffset);			// "fake" bone has identity matrix


		// loop through joint clusters
		for (MItDependencyNodes itCluster(MFn::kJointCluster); !itCluster.isDone(); itCluster.next()) 
		{
			MFnWeightGeometryFilter fnCluster(itCluster.item());

			// load input and output geometries
			MObjectArray	rgInputs;
			MObjectArray	rgOutputs;

			fnCluster.getInputGeometry(rgInputs);
			fnCluster.getOutputGeometry(rgOutputs);

			assert(rgInputs.length() == rgOutputs.length());	// ensure input geometry count equals 
																// output geometry count

			int	cInputs, cOutputs;

			cInputs	= cOutputs	
				= (int)rgOutputs.length();

			// loop through the output geometries
			for (int iOutput = 0, iInput = 0; iOutput < cOutputs; iOutput++, iInput++) 
			{
				assert(iOutput == iInput);
				
				if (rgOutputs[iOutput] == objShape) 	// our shape is one of the output geometries
				{
					bFoundRigidSkin	= true;
		
					assert(rgInputs[iInput] == fnCluster.inputShapeAtIndex(iInput));	// sanity check

					objInput	= rgInputs[iInput];

					// get bone
					MPlug		plgMatrix	= fnCluster.findPlug("matrix", &mStat);

					MPlugArray	rgplgMatrixConnections;

					plgMatrix.connectedTo(rgplgMatrixConnections, true, false);			// get source plugs
					assert(rgplgMatrixConnections.length() == 1);

					MObject	objBone	= rgplgMatrixConnections[0].node();

					assert(objBone.hasFn(MFn::kJoint));

					MFnIkJoint fnBone(objBone);

					char	szBone[64];

					strcpy(szBone, fnBone.name().asChar());

					// find bone's index in current bone list
					for (int iBone = 1; iBone < cBones;	iBone++) 
					{
						if (!strcmp(rgBones[iBone].m_szName, szBone))
							break;
					}
	
					if (iBone == cBones) 	// bone was not found in current bone list
					{
						// add bone
						if (cBones >= cBonesMax) 
						{
							// double array size
							cBonesMax  += cBonesMax;

							Bone*	rgNewBones	= new Bone[cBonesMax];

							ASSERT(rgNewBones, 
										"Could not allocate memory for new bone array");

							memcpy(rgNewBones, rgBones, cBones * sizeof(Bone));

							delete[] rgBones;

							rgBones	= rgNewBones;


							bool*	rgbNewNonZeroFlagTable	= new bool[cBonesMax * cVertices];

							ASSERT(rgbNewNonZeroFlagTable, 
										"Could not allocate memory for new non-zero flag table");

							memset(rgbNewNonZeroFlagTable, 0, cBonesMax * cVertices * sizeof(bool));
							memcpy(rgbNewNonZeroFlagTable, rgbNonZeroFlagTable, cBones * cVertices * sizeof(bool));

							delete[] rgbNonZeroFlagTable;

							rgbNonZeroFlagTable	= rgbNewNonZeroFlagTable;
						}
		
						// initialize iBone
						// WARNING: not checking for new failure
						rgBones[iBone].m_szName			= new char[256];
						rgBones[iBone].m_cReps			= 0;
						rgBones[iBone].m_cWeights		= 0;
						rgBones[iBone].m_rgiVertices	= new int[cVertices];
						rgBones[iBone].m_rgfWeights		= new float[cVertices];

						g_Strings.add(rgBones[iBone].m_szName);							// housekeeping

						strcpy(rgBones[iBone].m_szName, szBone);						// bone name
	
						// matrix info
						MObject objBindPose;

						fnBone.findPlug("bindPose").getValue(objBindPose);

						MFnMatrixData fnBindPose(objBindPose);

						(matMeshWorldTransform * fnBindPose.matrix().inverse()).get(rgBones[iBone].m_matOffset);


						rgobjBones.append(objBone);

						cBones++;
					}



					char	szParent[64];

					bool	bFoundParent	= false;
					MObject	objParent; 

					for (int iParent = 0; iParent < (int)fnBone.parentCount(); iParent++) 
					{
						objParent	= fnBone.parent(iParent);

						MFnDagNode	fnParent(objParent);
						
						strcpy(szParent, fnParent.name().asChar());		// parent's name

						for (int iShape_ = 0; iShape_ < DtShapeGetCount(); iShape_++) 
						{
							char*	szShape;

							DT_ATTEMPT(DtShapeGetName(iShape_, &szShape));

							if (!strcmp(szParent, szShape)) 
							{
								bFoundParent	= true;

								break;
							}
						}

						if (bFoundParent)
							break;
					}
  
					iParent	= 0;

					if (bFoundParent) 	// parent shape found
					{
						// find parent bone's index in current bone list
						for (iParent = 1; iParent < cBones;	iParent++) 
						{
							if (!strcmp(rgBones[iParent].m_szName, szParent)) 
							{
								break;
							}
						}


						if (iParent == cBones) 		// parent bone was not found in current bone list
						{
							// add parent bone
							if (cBones >= cBonesMax) 
							{
								// double array size
								cBonesMax  += cBonesMax;

								Bone*	rgNewBones	= new Bone[cBonesMax];

								ASSERT(rgNewBones, 
											"Could not allocate memory for new bone array");
	
								memcpy(rgNewBones, rgBones, cBones * sizeof(Bone));
	
								delete[] rgBones;

								rgBones	= rgNewBones;

								
								bool*	rgbNewNonZeroFlagTable	= new bool[cBonesMax * cVertices];

								ASSERT(rgbNewNonZeroFlagTable, 
											"Could not allocate memory for new non-zero flag table");

								memset(rgbNewNonZeroFlagTable, 0, cBonesMax * cVertices * sizeof(bool));
								memcpy(rgbNewNonZeroFlagTable, rgbNonZeroFlagTable, cBones * cVertices * sizeof(bool));

								delete[] rgbNonZeroFlagTable;

								rgbNonZeroFlagTable	= rgbNewNonZeroFlagTable;
							}
			
							// initialize iBone
							// WARNING: not checking for new failure
							rgBones[iParent].m_szName		= new char[256];
							rgBones[iParent].m_cReps		= 0;
							rgBones[iParent].m_cWeights		= 0;
							rgBones[iParent].m_rgiVertices	= new int[cVertices];
							rgBones[iParent].m_rgfWeights	= new float[cVertices];
	
							g_Strings.add(rgBones[iParent].m_szName);			// housekeeping
	
							strcpy(rgBones[iParent].m_szName, szParent);		// bone name

							// matrix info
							MObject	objBindPose;
	
							assert(objParent.hasFn(MFn::kJoint));

							MFnIkJoint(objParent).findPlug("bindPose").getValue(objBindPose);
	
							MFnMatrixData fnBindPose(objBindPose);
	
							(matMeshWorldTransform * fnBindPose.matrix().inverse()).get(rgBones[iParent].m_matOffset);


							rgobjBones.append(objParent);

							cBones++;
						}
					}


					// load weights
					MPlug		plgMessage	= fnCluster.findPlug("message");

					MPlugArray	rgplgMessageConnections;

					plgMessage.connectedTo(rgplgMessageConnections, false, true);	// get destination plugs

					assert(rgplgMessageConnections.length() == 1);
					assert(rgplgMessageConnections[0].node().hasFn(MFn::kSet));

					MFnSet fnSet(rgplgMessageConnections[0].node());
				
					MSelectionList list;

					fnSet.getMembers(list, false);

					assert(list.length() == 1);

					MDagPath	path;
					MObject		objComponents;

					list.getDagPath(0, path, objComponents);

					MFloatArray	rgWeights;

					fnCluster.getWeights(path, objComponents, rgWeights);

					assert(objComponents.hasFn(MFn::kDoubleIndexedComponent));


					MFnDoubleIndexedComponent fnComponent(objComponents);

					assert(fnComponent.elementCount() == (int)rgWeights.length());

					// loop through the weights
					for (int iWeight = 0; iWeight < (int)rgWeights.length(); iWeight++) 
					{
						assert(rgWeights[iWeight] <= 1.0f);

						int	iU, iV;

						fnComponent.getElement(iWeight, iU, iV);

						// WARNING: check calculation of iVertex
						int	iVertex	= iU * cCVsInV + iV;
						
						rgBones[iBone].m_rgfWeights[rgBones[iBone].m_cWeights]	= rgWeights[iWeight];
						rgBones[iBone].m_rgiVertices[rgBones[iBone].m_cWeights]	= iVertex;

						rgBones[iBone].m_cReps	 += rgReps[iVertex].m_cReps;
						rgBones[iBone].m_cWeights++;

						rgbNonZeroFlagTable[iBone * cVertices + iVertex]	= true;

						if (rgWeights[iWeight] != 1.0f) 
						{
							rgBones[iParent].m_rgfWeights[rgBones[iParent].m_cWeights]	= 1.0f - rgWeights[iWeight];
							rgBones[iParent].m_rgiVertices[rgBones[iParent].m_cWeights]	= iVertex;

							rgBones[iParent].m_cReps   += rgReps[iVertex].m_cReps;
							rgBones[iParent].m_cWeights++;				// IMPORTANT: Don't change line position

							rgbNonZeroFlagTable[iParent * cVertices + iVertex]	= true;
						}
					}

					break;
				}	// if found our mesh
			}	// loop thru geom's
		}	// loop thru joint clusters


		if (cBones == 1) 		// no rigid skinning found
		{
			delete[] rgBones[0].m_rgfWeights;
			delete[] rgBones[0].m_rgiVertices;

			cBones	= 0;
		}
		else 
		{
			// at most 2 bones per vertex in rigid skinning (i.e. bone + parent)
			cMaxBonesPerVertex	= 2;

			// calculate max number of bones per vertex
			cMaxBonesPerFace	= 0;

			for (int iFace = 0; iFace < cFaces; iFace++) 
			{
				int	cBonesPerFace	= 0;

				for (int iBone = 0; iBone < cBones; iBone++) 
				{
					for (int iIndex = 0; iIndex < rgFaces[iFace].m_cIndices; iIndex++) 
					{
						if (rgbNonZeroFlagTable[iBone * cVertices + rgReps[rgFaces[iFace].m_rgIndices[iIndex]].m_iFirst]) 
						{
							cBonesPerFace++;

							break;
						}
					}
				}

				if (cBonesPerFace > cMaxBonesPerFace)
					cMaxBonesPerFace = cBonesPerFace;
			}
			
		}
	}
				
				
	delete[] rgbNonZeroFlagTable;



















	// reload control vertices if skinning info was found

	if (bFoundSmoothSkin || bFoundRigidSkin)
	{
		delete[]	rgVertices;

		MyDtShapeGetControlPoints(objInput, objShape, &cVertices, &rgVertices);
	}





	// mesh type
	pShape->m_kType			= Mesh::PATCH_MESH;


	EXIT;

	return hr;	
}










HRESULT	LoadPolyMesh
		(
			int		iShape, 
			Mesh*	pShape
		) 
{
	HRESULT	hr		= S_OK;
	MStatus	mStat	= MStatus::kSuccess;


	// set up references

	Mesh::ShapeType&	kType		= pShape->m_kType;

	int&		cReps				= pShape->m_cReps;
	Rep*&		rgReps				= pShape->m_rgReps;

	int&		cVertices			= pShape->m_cVertices;
	DtVec3f*&	rgVertices			= pShape->m_rgVertices;

	int&		cNormals			= pShape->m_cNormals;
	DtVec3f*&	rgNormals			= pShape->m_rgNormals;

	int&		cTexCoords			= pShape->m_cTexCoords;
	DtVec2f*&	rgTexCoords			= pShape->m_rgTexCoords;

	int&		cVertexColors		= pShape->m_cVertexColors;
	DtRGBA*&	rgVertexColors		= pShape->m_rgVertexColors;


	int&		cFaces				= pShape->m_cFaces;
	Face*&		rgFaces				= pShape->m_rgFaces;

	int&		cFaceIndices		= pShape->m_cFaceIndices;

	int&		cGroups				= pShape->m_cGroups;
	Group*&		rgGroups			= pShape->m_rgGroups;


	int&		cBones				= pShape->m_cBones;
	Bone*&		rgBones				= pShape->m_rgBones;

	int&		cMaxBonesPerVertex	= pShape->m_cMaxBonesPerVertex;
	int&		cMaxBonesPerFace	= pShape->m_cMaxBonesPerFace;




	INIT;




	cGroups		= DtGroupGetCount(iShape);
	rgGroups	= new Group[cGroups];

	ASSERT(rgGroups,
				"Could not allocate memory for group array");

	DT_ATTEMPT(DtShapeGetVertices(iShape, &cVertices, &rgVertices));

	DT_ATTEMPT(DtShapeGetNormals(iShape, &cNormals, &rgNormals));

	DT_ATTEMPT(DtShapeGetTextureVertices(iShape, &cTexCoords, &rgTexCoords));
	
	DT_ATTEMPT(DtShapeGetVerticesColor(iShape, &cVertexColors, &rgVertexColors));	
	
	ASSERT(cVertexColors == cVertices,
				"Vertex color count does not match vertex count");


	int	cRepsMax	= cReps	
					= cVertices;
	rgReps			= new Rep[cRepsMax];

	ASSERT(rgReps,
				"Could not allocate memory for rep array");
	
	// initialize reps
	for (int iRep = 0; iRep < cReps; iRep++) 
	{
		rgReps[iRep].m_iTexCoordIdx	= -1;						// signifies "unvisited"
		rgReps[iRep].m_iNormalIdx	= -1;						// signifies "unvisited"
		rgReps[iRep].m_iNext		= iRep;
		rgReps[iRep].m_iFirst		= iRep;

		rgReps[iRep].m_cReps		= 1;
	}


	int	cFacesMax	= cFaces
					= 0;
	rgFaces			= new Face[cFacesMax];

	ASSERT(rgFaces,
				"Could not allocate memory for face array");

	cFaceIndices	= 0;				// total number of indices over all faces


	// go through each group of polygons (grouped by material)
	for (int iGroup = 0; iGroup < cGroups; iGroup++) 
	{
		// material name
		DT_ATTEMPT(DtMtlGetName(iShape, iGroup, &rgGroups[iGroup].m_szMaterial));

		// texture file name

		DT_ATTEMPT(MyDtTextureGetFileName(rgGroups[iGroup].m_szMaterial, &rgGroups[iGroup].m_szTextureFile));


		// diffuse color 
		if (!rgGroups[iGroup].m_szTextureFile)
		{
			DT_ATTEMPT(DtMtlGetDiffuseClr(rgGroups[iGroup].m_szMaterial, 0, 
									   &rgGroups[iGroup].m_fDiffuseRed, 
									   &rgGroups[iGroup].m_fDiffuseGreen, 
									   &rgGroups[iGroup].m_fDiffuseBlue));
		}
		else 
		{	// if the material has a texture then load the diffuse factor into the diffuse components
			int		iMaterial;

			DT_ATTEMPT(DtMtlGetID(iShape, iGroup, &iMaterial));

			MObject	objShader;

			DT_ATTEMPT(DtExt_MtlGetShader(iMaterial, objShader));

			MFnLambertShader	fnShader(objShader);

			float	fDiffuseFactor	= fnShader.diffuseCoeff();

			rgGroups[iGroup].m_fDiffuseRed		= fDiffuseFactor;
			rgGroups[iGroup].m_fDiffuseGreen	= fDiffuseFactor;
			rgGroups[iGroup].m_fDiffuseBlue		= fDiffuseFactor;
		}

		// specular color
		DT_ATTEMPT(DtMtlGetSpecularClr(rgGroups[iGroup].m_szMaterial, 0, 
										&rgGroups[iGroup].m_fSpecularRed, 
										&rgGroups[iGroup].m_fSpecularGreen, 
										&rgGroups[iGroup].m_fSpecularBlue));

		// emissive color
		DT_ATTEMPT(DtMtlGetEmissiveClr(rgGroups[iGroup].m_szMaterial, 0, 
										&rgGroups[iGroup].m_fEmissiveRed, 
										&rgGroups[iGroup].m_fEmissiveGreen, 
										&rgGroups[iGroup].m_fEmissiveBlue));

		// power / shininess
		DT_ATTEMPT(DtMtlGetShininess(rgGroups[iGroup].m_szMaterial, 0, &rgGroups[iGroup].m_fShininess));

		// transparency / alpha
		DT_ATTEMPT(DtMtlGetTransparency(rgGroups[iGroup].m_szMaterial, 0, &rgGroups[iGroup].m_fTransparency));


		int	cPolygons;

		DT_ATTEMPT(DtPolygonGetCount(iShape, iGroup, &cPolygons));


		// increase array size
		cFacesMax  += cPolygons;

		Face*	rgNewFaces	= new Face[cFacesMax];
		
		ASSERT(rgNewFaces,
					"Could not allocate memory for new face array");

		memcpy(rgNewFaces, rgFaces, cFaces * sizeof(Face));

		delete[] rgFaces;

		rgFaces	= rgNewFaces;

		// loop through the polygons in this shape
		for (int iPolygon = 0; iPolygon < cPolygons; iPolygon++) 
		{
			int		cIndices;

			long*	rglVertexIndices;
			long*	rglNormalIndices;
			long*	rglTexCoordIndices;

			DT_ATTEMPT(DtPolygonGetIndices(iPolygon, &cIndices, &rglVertexIndices, &rglNormalIndices, &rglTexCoordIndices));

			cFaceIndices	+=	cIndices;

			// initialize face
			rgFaces[cFaces].m_cIndices	= cIndices;
			rgFaces[cFaces].m_rgIndices	= new int[cIndices];

			ASSERT(rgFaces[cFaces].m_rgIndices,
						"Could not allocate memory for face indices array");
			
			rgFaces[cFaces].m_iGroup	= iGroup;

			// no need for the following 2 lines
////		memcpy(rgFaces[cFaces].m_rgNormalIndices, rgNormalIndices, cIndices * sizeof(long));
//			memcpy(rgFaces[cFaces].m_rgIndices, rgVertexIndices, cIndices * sizeof(long));

			// create repetition if texture coords differ
			for (int iIndex = 0; iIndex < cIndices; iIndex++) 
			{
				int iRep	= rglVertexIndices[iIndex];
				int iLastRep;

				bool bFound = false;

				do 
				{
					if (rglTexCoordIndices[iIndex] == rgReps[iRep].m_iTexCoordIdx && rglNormalIndices[iIndex] == rgReps[iRep].m_iNormalIdx)
						bFound = true;

					iLastRep	= iRep;
					iRep		= rgReps[iRep].m_iNext;
				} while (!bFound && rgReps[iRep].m_iNext != rgReps[iRep].m_iFirst);


				if (bFound) 
				{
					rgFaces[cFaces].m_rgIndices[iIndex]	= iLastRep;	// update face indices
				}
				else 
				{
					if (rgReps[rgReps[iRep].m_iFirst].m_iTexCoordIdx == -1) 	// if first time through this rep
					{
						// initialize index into lump of texture coordinates
						rgReps[rgReps[iRep].m_iFirst].m_iTexCoordIdx	= rglTexCoordIndices[iIndex];
						rgReps[rgReps[iRep].m_iFirst].m_iNormalIdx		= rglNormalIndices[iIndex];

						// update face indices
						rgFaces[cFaces].m_rgIndices[iIndex] = rgReps[iRep].m_iFirst;
					}
					else 
					{
						// append new rep 

						if (cReps >= cRepsMax) 
						{
							// double array size
							cRepsMax += cRepsMax;

							Rep*	rgNewReps	= new Rep[cRepsMax];

							ASSERT(rgNewReps,
										"Could not allocate memory for new rep array");

							memcpy(rgNewReps, rgReps, cReps * sizeof(Rep));

							delete[] rgReps;

							rgReps	  = rgNewReps;
						}

						// create new rep at the end of the array
						rgReps[cReps].m_iTexCoordIdx	= rglTexCoordIndices[iIndex];
						rgReps[cReps].m_iNormalIdx		= rglNormalIndices[iIndex];
						rgReps[cReps].m_iFirst			= rgReps[iRep].m_iFirst;
						rgReps[cReps].m_iNext			= rgReps[iRep].m_iFirst;

						rgReps[iRep].m_iNext			= cReps;

						// increment rep count at the first rep
						rgReps[rgReps[iRep].m_iFirst].m_cReps++;


						// update face indices
						rgFaces[cFaces].m_rgIndices[iIndex] = cReps;	

						cReps++;
					}
				}
			}

			cFaces++;
		}
	}







			

	
	// skinning info
			

	MObject	objShape;
	MObject objTransform;
	MObject	objInput;

	DT_ATTEMPT(DtExt_ShapeGetShapeNode(iShape, objShape));
	DT_ATTEMPT(DtExt_ShapeGetTransform(iShape, objTransform));




	// load the mesh's world transform (needed if skinning info is found)
	MDagPath	pathTransform;

	MFnDagNode(objTransform).getPath(pathTransform);

	MMatrix		matMeshWorldTransform	= pathTransform.inclusiveMatrix();





	cBones				= 0;
	rgBones				= NULL;

	cMaxBonesPerVertex	= 0;
	cMaxBonesPerFace	= 0;


	MObjectArray	rgobjBones;







	// smooth skinning

	bool*	rgbNonZeroFlagTable	= NULL;		// table of influences vs. vertices
	int*	rgcNonZeros			= NULL;		// array of influence counts 

	bool bFoundSmoothSkin	= false;

	if (objShape.hasFn(MFn::kMesh)) 		// if this shape is a mesh
	{
		// loop through skin clusters
		for (MItDependencyNodes itSkin(MFn::kSkinClusterFilter); !itSkin.isDone(); itSkin.next()) 
		{
			MFnSkinCluster fnSkin(itSkin.item());

			// load input and output geometries
			MObjectArray	rgInputs;
			MObjectArray	rgOutputs;

			fnSkin.getInputGeometry(rgInputs);
			fnSkin.getOutputGeometry(rgOutputs);

			assert(rgInputs.length() == rgOutputs.length());		// ensure that input geometry count 
																	// equals output geometry count

			int	cInputs, cOutputs;

			cInputs	= cOutputs	= (int)rgOutputs.length();

			// loop through the output geometries
			for (int iOutput = 0, iInput = 0; iOutput < cOutputs; iOutput++, iInput++) 
			{
				assert(iOutput == iInput);		// sanity check

				
				if (rgOutputs[iOutput] == objShape) 		// if our shape is one of the output geometries
				{
					MDagPathArray	rgdagpathInfluences;
					
					cBones	= (int)fnSkin.influenceObjects(rgdagpathInfluences, &mStat);

					rgBones	= new Bone[cBones];

					ASSERT(rgBones,
								"Could not allocate memory for bone array");


					// initialize bones
					for (int iBone = 0; iBone < cBones; iBone++) 
					{	// WARNING: not checking for new failure
						rgBones[iBone].m_szName			= new char[256];
						rgBones[iBone].m_cReps			= 0;
						rgBones[iBone].m_cWeights		= 0;
						rgBones[iBone].m_rgiVertices	= new int[cVertices];
						rgBones[iBone].m_rgfWeights		= new float[cVertices];

						g_Strings.add(rgBones[iBone].m_szName);		// housekeeping

						// bone name
						strcpy(rgBones[iBone].m_szName, rgdagpathInfluences[iBone].partialPathName().asChar());

						// matrix offset
						MFnIkJoint fnBone(rgdagpathInfluences[iBone]);

						MObject objBindPose;

						fnBone.findPlug("bindPose").getValue(objBindPose);

						MFnMatrixData fnBindPose(objBindPose);

						(matMeshWorldTransform * fnBindPose.matrix().inverse()).get(rgBones[iBone].m_matOffset);



						rgobjBones.append(rgdagpathInfluences[iBone].node());
					}

					rgcNonZeros			= new int[cVertices];

					ASSERT(rgcNonZeros,
								"Could not allocate memory for non zero count array");

					rgbNonZeroFlagTable	= new bool[cVertices * cBones];

					ASSERT(rgbNonZeroFlagTable,
								"Could not allocate memory for non zero table");

					// bone info; calculate max number of bones per vertex
					cMaxBonesPerVertex = 0;

					int iVertex = 0;

					MFnMesh fnOutput(rgOutputs[iOutput]);

					MDagPath dagpathOutputShape;
				
					fnOutput.getPath(dagpathOutputShape);

					// loop through the vertices
					for (MItGeometry itGeom(rgOutputs[iOutput]); !itGeom.isDone(); itGeom.next()) 
					{
						MFloatArray rgfWeights;

						unsigned cInfs;

						fnSkin.getWeights(dagpathOutputShape, itGeom.component(), rgfWeights, cInfs);

						assert(rgdagpathInfluences.length() == rgfWeights.length());
						assert(rgfWeights.length() == cInfs);

						rgcNonZeros[iVertex] = 0;


						float fWeightSum = 0.0f;

						for (int iBone = 0; iBone < cBones; iBone++)
							fWeightSum += rgfWeights[iBone];

						assert(fWeightSum > 0.00001f);

						for (iBone = 0; iBone < cBones; iBone++) 
						{
							rgbNonZeroFlagTable[iBone * cVertices + iVertex]	= false;

							rgfWeights[iBone] = rgfWeights[iBone] / fWeightSum;		// normalize the weight

							if (rgfWeights[iBone] != 0.0f) 
							{
								rgcNonZeros[iVertex]++;

								rgBones[iBone].m_cReps += rgReps[iVertex].m_cReps;
		
								rgBones[iBone].m_rgiVertices[rgBones[iBone].m_cWeights]	= iVertex;							
								rgBones[iBone].m_rgfWeights[rgBones[iBone].m_cWeights]	= rgfWeights[iBone];

								rgbNonZeroFlagTable[iBone * cVertices + iVertex]	= true;

								rgBones[iBone].m_cWeights++;
							}
						}


						if (rgcNonZeros[iVertex] > cMaxBonesPerVertex)
							cMaxBonesPerVertex = rgcNonZeros[iVertex];

						iVertex++;
					}



					// calculate max number of bones per vertex

					cMaxBonesPerFace	= 0;

					for (int iFace = 0; iFace < cFaces; iFace++) 
					{
						int	cBonesPerFace	= 0;

						for (int iBone = 0; iBone < cBones; iBone++) 
						{
							for (int iIndex = 0; iIndex < rgFaces[iFace].m_cIndices; iIndex++) 
							{
								if (rgbNonZeroFlagTable[iBone * cVertices + rgReps[rgFaces[iFace].m_rgIndices[iIndex]].m_iFirst]) 
								{
									cBonesPerFace++;

									break;
								}
							}
						}

						if (cBonesPerFace > cMaxBonesPerFace)
							cMaxBonesPerFace = cBonesPerFace;
					}





					objInput = rgInputs[iInput];

					bFoundSmoothSkin = true;

					break;
				}
			}

			if (bFoundSmoothSkin)
				break;
		}
	}


	delete[] rgcNonZeros;
	delete[] rgbNonZeroFlagTable;

















	// rigid skinning

	rgbNonZeroFlagTable	= NULL;

	bool	bFoundRigidSkin	= false;

	if (!bFoundSmoothSkin && objShape.hasFn(MFn::kMesh)) 	// shape is a mesh 
	{
		cBones			= 1;						// zero'th bone is the extra "fake" bone
		int cBonesMax	= 64;
		rgBones			= new Bone[cBonesMax];

		ASSERT(rgBones,
					"Could not allocate memory for bone array");

		rgbNonZeroFlagTable	= new bool[cBonesMax * cVertices];

		ASSERT(rgbNonZeroFlagTable,
					"Could not allocate memory for non-zero flag table");

		// fill non zero table with 0's
		memset(rgbNonZeroFlagTable, 0, cBonesMax * cVertices * sizeof(bool));

		// initialize "fake" iBone
		// WARNING: not checking for new failure
		rgBones[0].m_szName			= new char[256];
		rgBones[0].m_cReps			= 0;
		rgBones[0].m_cWeights		= 0;
		rgBones[0].m_rgfWeights		= new float[cVertices];
		rgBones[0].m_rgiVertices	= new int[cVertices];

		g_Strings.add(rgBones[0].m_szName);							// housekeeping

		strcpy(rgBones[0].m_szName, SCENE_ROOT);					// bone name
	
		matMeshWorldTransform.get(rgBones[0].m_matOffset);			// "fake" bone has identity matrix


		// loop through joint clusters
		for (MItDependencyNodes itCluster(MFn::kJointCluster); !itCluster.isDone(); itCluster.next()) 
		{
			MFnWeightGeometryFilter fnCluster(itCluster.item());

			// load input and output geometries
			MObjectArray	rgInputs;
			MObjectArray	rgOutputs;

			fnCluster.getInputGeometry(rgInputs);
			fnCluster.getOutputGeometry(rgOutputs);

			assert(rgInputs.length() == rgOutputs.length());	// ensure input geometry count equals 
																// output geometry count

			int	cInputs, cOutputs;

			cInputs	= cOutputs	
				= (int)rgOutputs.length();

			// loop through the output geometries
			for (int iOutput = 0, iInput = 0; iOutput < cOutputs; iOutput++, iInput++) 
			{
				assert(iOutput == iInput);
				
				if (rgOutputs[iOutput] == objShape) 	// our shape is one of the output geometries
				{
					bFoundRigidSkin	= true;
		
					assert(rgInputs[iInput] == fnCluster.inputShapeAtIndex(iInput));	// sanity check

					objInput	= rgInputs[iInput];

					// get bone
					MPlug		plgMatrix	= fnCluster.findPlug("matrix", &mStat);

					MPlugArray	rgplgMatrixConnections;

					plgMatrix.connectedTo(rgplgMatrixConnections, true, false);			// get source plugs
					assert(rgplgMatrixConnections.length() == 1);

					MObject	objBone	= rgplgMatrixConnections[0].node();

					assert(objBone.hasFn(MFn::kJoint));

					MFnIkJoint fnBone(objBone);

					char	szBone[64];

					strcpy(szBone, fnBone.name().asChar());

					// find bone's index in current bone list
					for (int iBone = 1; iBone < cBones;	iBone++) 
					{
						if (!strcmp(rgBones[iBone].m_szName, szBone))
							break;
					}
	
					if (iBone == cBones) 	// bone was not found in current bone list
					{
						// add bone
						if (cBones >= cBonesMax) 
						{
							// double array size
							cBonesMax  += cBonesMax;

							Bone*	rgNewBones	= new Bone[cBonesMax];

							ASSERT(rgNewBones, 
										"Could not allocate memory for new bone array");

							memcpy(rgNewBones, rgBones, cBones * sizeof(Bone));

							delete[] rgBones;

							rgBones	= rgNewBones;


							bool*	rgbNewNonZeroFlagTable	= new bool[cBonesMax * cVertices];

							ASSERT(rgbNewNonZeroFlagTable, 
										"Could not allocate memory for new non-zero flag table");

							memset(rgbNewNonZeroFlagTable, 0, cBonesMax * cVertices * sizeof(bool));
							memcpy(rgbNewNonZeroFlagTable, rgbNonZeroFlagTable, cBones * cVertices * sizeof(bool));

							delete[] rgbNonZeroFlagTable;

							rgbNonZeroFlagTable	= rgbNewNonZeroFlagTable;
						}
		
						// initialize iBone
						// WARNING: not checking for new failure
						rgBones[iBone].m_szName			= new char[256];
						rgBones[iBone].m_cReps			= 0;
						rgBones[iBone].m_cWeights		= 0;
						rgBones[iBone].m_rgiVertices	= new int[cVertices];
						rgBones[iBone].m_rgfWeights		= new float[cVertices];

						g_Strings.add(rgBones[iBone].m_szName);							// housekeeping

						strcpy(rgBones[iBone].m_szName, szBone);						// bone name
	
						// matrix info
						MObject objBindPose;

						fnBone.findPlug("bindPose").getValue(objBindPose);

						MFnMatrixData fnBindPose(objBindPose);

						(matMeshWorldTransform * fnBindPose.matrix().inverse()).get(rgBones[iBone].m_matOffset);


						rgobjBones.append(objBone);

						cBones++;
					}



					char	szParent[64];

					bool	bFoundParent	= false;
					MObject	objParent;

					for (int iParent = 0; iParent < (int)fnBone.parentCount(); iParent++) 
					{
						objParent	= fnBone.parent(iParent);

						MFnDagNode	fnParent(objParent);
						
						strcpy(szParent, fnParent.name().asChar());		// parent's name

						for (int iShape_ = 0; iShape_ < DtShapeGetCount(); iShape_++) 
						{
							char*	szShape;

							DT_ATTEMPT(DtShapeGetName(iShape_, &szShape));

							if (!strcmp(szParent, szShape)) 
							{
								bFoundParent	= true;

								break;
							}
						}

						if (bFoundParent)
							break;
					}

					iParent	= 0;

					if (bFoundParent) 	// parent shape found
					{
						// find parent bone's index in current bone list
						for (iParent = 1; iParent < cBones;	iParent++) 
						{
							if (!strcmp(rgBones[iParent].m_szName, szParent)) 
							{
								break;
							}
						}


						if (iParent == cBones) 		// parent bone was not found in current bone list
						{
							// add parent bone
							if (cBones >= cBonesMax) 
							{
								// double array size
								cBonesMax  += cBonesMax;

								Bone*	rgNewBones	= new Bone[cBonesMax];

								ASSERT(rgNewBones, 
											"Could not allocate memory for new bone array");
	
								memcpy(rgNewBones, rgBones, cBones * sizeof(Bone));
	
								delete[] rgBones;

								rgBones	= rgNewBones;

								
								bool*	rgbNewNonZeroFlagTable	= new bool[cBonesMax * cVertices];

								ASSERT(rgbNewNonZeroFlagTable, 
											"Could not allocate memory for new non-zero flag table");

								memset(rgbNewNonZeroFlagTable, 0, cBonesMax * cVertices * sizeof(bool));
								memcpy(rgbNewNonZeroFlagTable, rgbNonZeroFlagTable, cBones * cVertices * sizeof(bool));

								delete[] rgbNonZeroFlagTable;

								rgbNonZeroFlagTable	= rgbNewNonZeroFlagTable;
							}
			
							// initialize iBone
							// WARNING: not checking for new failure
							rgBones[iParent].m_szName		= new char[256];
							rgBones[iParent].m_cReps		= 0;
							rgBones[iParent].m_cWeights		= 0;
							rgBones[iParent].m_rgiVertices	= new int[cVertices];
							rgBones[iParent].m_rgfWeights	= new float[cVertices];
	
							g_Strings.add(rgBones[iParent].m_szName);						// housekeeping
	
							strcpy(rgBones[iParent].m_szName, szParent);		// bone name

							// matrix info
							MObject	objBindPose;
	
							assert(objParent.hasFn(MFn::kJoint));

							MFnIkJoint(objParent).findPlug("bindPose").getValue(objBindPose);
	
							MFnMatrixData fnBindPose(objBindPose);
	
							(matMeshWorldTransform * fnBindPose.matrix().inverse()).get(rgBones[iParent].m_matOffset);


							rgobjBones.append(objParent);

							cBones++;
						}
					}


					// load weights
					MPlug		plgMessage	= fnCluster.findPlug("message");

					MPlugArray	rgplgMessageConnections;

					plgMessage.connectedTo(rgplgMessageConnections, false, true);	// get destination plugs

					assert(rgplgMessageConnections.length() == 1);
					assert(rgplgMessageConnections[0].node().hasFn(MFn::kSet));

					MFnSet fnSet(rgplgMessageConnections[0].node());
				
					MSelectionList list;

					fnSet.getMembers(list, false);

					assert(list.length() == 1);

					MDagPath	path;
					MObject		objComponents;

					list.getDagPath(0, path, objComponents);

					MFloatArray	rgWeights;

					fnCluster.getWeights(path, objComponents, rgWeights);

					MFnSingleIndexedComponent fnComponent(objComponents);

					assert (fnComponent.elementCount() == (int)rgWeights.length());

					// loop through the weights
					for (int iWeight = 0; iWeight < (int)rgWeights.length(); iWeight++) 
					{
						assert(rgWeights[iWeight] <= 1.0f);

						int	iVertex	= fnComponent.element(iWeight);
						
						rgBones[iBone].m_rgfWeights[rgBones[iBone].m_cWeights]	= rgWeights[iWeight];
						rgBones[iBone].m_rgiVertices[rgBones[iBone].m_cWeights]	= iVertex;

						rgBones[iBone].m_cReps	 += rgReps[iVertex].m_cReps;
						rgBones[iBone].m_cWeights++;

						rgbNonZeroFlagTable[iBone * cVertices + iVertex]	= true;

						if (rgWeights[iWeight] != 1.0f) 
						{
							rgBones[iParent].m_rgfWeights[rgBones[iParent].m_cWeights]	= 1.0f - rgWeights[iWeight];
							rgBones[iParent].m_rgiVertices[rgBones[iParent].m_cWeights]	= iVertex;

							rgBones[iParent].m_cReps   += rgReps[iVertex].m_cReps;
							rgBones[iParent].m_cWeights++;				// IMPORTANT: Don't change line position

							rgbNonZeroFlagTable[iParent * cVertices + iVertex]	= true;
						}
					}

					break;
				}	// if found our mesh
			}	// loop thru geom's
		}	// loop thru joint clusters


		if (cBones == 1) 		// no rigid skinning found
		{
			delete[] rgBones[0].m_rgfWeights;
			delete[] rgBones[0].m_rgiVertices;

			cBones	= 0;
		}
		else 
		{
			// at most 2 bones per vertex in rigid skinning (i.e. bone + parent)
			cMaxBonesPerVertex	= 2;

			// calculate max number of bones per vertex
			cMaxBonesPerFace	= 0;

			for (int iFace = 0; iFace < cFaces; iFace++) 
			{
				int	cBonesPerFace	= 0;

				for (int iBone = 0; iBone < cBones; iBone++) 
				{
					for (int iIndex = 0; iIndex < rgFaces[iFace].m_cIndices; iIndex++) 
					{
						if (rgbNonZeroFlagTable[iBone * cVertices + rgReps[rgFaces[iFace].m_rgIndices[iIndex]].m_iFirst]) 
						{
							cBonesPerFace++;

							break;
						}
					}
				}

				if (cBonesPerFace > cMaxBonesPerFace)
					cMaxBonesPerFace = cBonesPerFace;
			}



			
			
			
			
		}
	}
				
				
	delete[] rgbNonZeroFlagTable;



	// load lumps of control vertex data

	if (cBones == 0)		// no skinning found
	{
		DT_ATTEMPT(MyDtShapeGetVertices(iShape, &cVertices, &rgVertices));				// lump of vertices
		DT_ATTEMPT(MyDtShapeGetNormals(iShape, &cNormals, &rgNormals));					// lump of normals
	}
	else					// skinning found
	{
		DT_ATTEMPT(MyDtShapeGetVertices(objInput, objShape, &cVertices, &rgVertices));	// lump of vertices
		DT_ATTEMPT(MyDtShapeGetNormals(objInput, objShape, &cNormals, &rgNormals));		// lump of normals
	}

	DT_ATTEMPT(MyDtShapeGetTextureVertices(iShape, &cTexCoords, &rgTexCoords));			// lump of texture coords
	DT_ATTEMPT(MyDtShapeGetVerticesColor(iShape, &cVertexColors, &rgVertexColors));		// lump of vertex colors



	// mesh type

	pShape->m_kType				= Mesh::POLY_MESH;


	EXIT;


	return	hr;
}
















HRESULT	LoadShape
		(
			int		iShape, 
			Mesh*	pShape
		)
{
	HRESULT	hr	= S_OK;

	INIT;

	if (MyDtShapeIsJoint(iShape)) 
	{
		pShape->m_kType	= Mesh::BONE;
	}
	else if (g_bExportPatches && MyDtShapeIsPatchMesh(iShape)) 
	{
		HR_ATTEMPT(LoadPatchMesh(iShape, pShape),
			"Could not load patch-mesh");
	}
	else 
	{
		HR_ATTEMPT(LoadPolyMesh(iShape, pShape),
			"Could not load poly-mesh");
	}

	EXIT;

	return	hr;
}
























HRESULT	AddSkin
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pShapeDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{
	HRESULT	hr	= S_OK;


	LPDIRECTXFILEDATA	pSkinDataObject	= NULL;


	PBYTE	pbSkinData	= NULL;



	INIT;



	int		cbSkinSize	= sizeof(WORD)		// nMaxSkinWeightsPerVertex
						+ sizeof(WORD)		// nMaxSkinWeightsPerFace
						+ sizeof(WORD);		// nBones

	PBYTE	pbSkinCurr	= pbSkinData	= new BYTE[cbSkinSize];

	ASSERT(pbSkinData,
				"Could not allocate memory for pbSkinData");


	// nMaxSkinWeightsPerVertex
	WRITE_WORD(pbSkinCurr, ((WORD)pShape->m_cMaxBonesPerVertex));

	// nMaxSkinWeightsPerFace
	WRITE_WORD(pbSkinCurr, ((WORD)pShape->m_cMaxBonesPerFace));

	// nBones
	WRITE_WORD(pbSkinCurr, ((WORD)pShape->m_cBones));


	HR_ATTEMPT(pxofSave->CreateDataObject(DXFILEOBJ_XSkinMeshHeader, NULL, NULL, cbSkinSize, pbSkinData, &pSkinDataObject),
				"Could not create pSkinDataObject");


	HR_ATTEMPT(pShapeDataObject->AddDataObject(pSkinDataObject),
				"Could not add pSkinDataObject to pShapeDataObject");



	EXIT;



	delete[] pbSkinData;

	if (pSkinDataObject)
		pSkinDataObject->Release();


	if (FAILED(hr))
		return hr;


	// SkinWeights
	for (int iBone = 0; iBone < pShape->m_cBones; iBone++) 
	{
		LPDIRECTXFILEDATA	pBoneDataObject	= NULL;

		PBYTE	pbBoneData	= NULL;


		INIT;

		int		cbBoneSize	= sizeof(char*)									// transformNodeName
							+ sizeof(DWORD)									// nWeights
							+ sizeof(DWORD) * pShape->m_rgBones[iBone].m_cReps	// vertexIndices[nWeights]
							+ sizeof(float) * pShape->m_rgBones[iBone].m_cReps	// weights[nWeights]
							+ sizeof(float) * 16;							// matrixOffset

		PBYTE	pbBoneCurr	= pbBoneData	= new BYTE[cbBoneSize];

		ASSERT(pbBoneData,
					"Could not allocate memory for pbBoneData.");


		// transformNodeName
		WRITE_PCHAR(pbBoneCurr, ((char*)pShape->m_rgBones[iBone].m_szName));

		// nWeights
		WRITE_DWORD(pbBoneCurr, ((DWORD)pShape->m_rgBones[iBone].m_cReps));

		// vertexIndices[nWeights]
		for (int iVertex = 0; iVertex < pShape->m_rgBones[iBone].m_cWeights; iVertex++) 
		{
			int iRep = pShape->m_rgBones[iBone].m_rgiVertices[iVertex];

			do 
			{
				WRITE_DWORD(pbBoneCurr, ((DWORD)iRep));

				iRep = pShape->m_rgReps[iRep].m_iNext;
			} while (iRep != pShape->m_rgReps[iRep].m_iFirst);
		}

		// weights[nWeights]
		for (iVertex = 0; iVertex < pShape->m_rgBones[iBone].m_cWeights; iVertex++)
		{
			for (int iRep = 0; iRep < pShape->m_rgReps[pShape->m_rgBones[iBone].m_rgiVertices[iVertex]].m_cReps; iRep++)
			{
				WRITE_FLOAT(pbBoneCurr, pShape->m_rgBones[iBone].m_rgfWeights[iVertex]);
			}
		}

		// matrixOffset
		for (int iRow = 0; iRow < 4; iRow++)
		{
			for (int iCol = 0; iCol < 4; iCol++)
			{
				WRITE_FLOAT(pbBoneCurr, pShape->m_rgBones[iBone].m_matOffset[iRow][iCol]);
			}
		}


		HR_ATTEMPT(pxofSave->CreateDataObject(DXFILEOBJ_SkinWeights, NULL, NULL, cbBoneSize, pbBoneData, &pBoneDataObject),
					"Could not create pBoneDataObject");


		HR_ATTEMPT(pShapeDataObject->AddDataObject(pBoneDataObject),
					"Could not add pBoneDataObject to pShapeDataObject");



		EXIT;



		delete[] pbBoneData;

		if (pBoneDataObject)
			pBoneDataObject->Release();


		if (FAILED(hr))
			return hr;
	}


	return hr;
}










HRESULT	AddNormals
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pShapeDataObject, 
			LPDIRECTXFILESAVEOBJECT pxofSave
		) 
{
	HRESULT	hr	= S_OK;

	LPDIRECTXFILEDATA	pNormalsDataObject	= NULL;

	PBYTE	pbNormalsData	= NULL;

	INIT;
	
	int		cbNormalsSize	= sizeof(DWORD)													// nNormals
							+ pShape->m_cReps * (3 * sizeof(float))							// normals
							+ sizeof(DWORD)													// nFaceNormals
							+ (pShape->m_cFaces + pShape->m_cFaceIndices) * sizeof(DWORD);	// faceNormals

	PBYTE	pbNormalsCurr	= pbNormalsData	
							= new BYTE[cbNormalsSize];

	ASSERT(pbNormalsCurr, "Could not allocate memory for pbNormalsData");


	// nNormals
	WRITE_DWORD(pbNormalsCurr, ((DWORD)pShape->m_cReps));

	// normals
	int iRep;

	for (iRep = 0; iRep < pShape->m_cReps; iRep++) 
	{
		if (pShape->m_rgReps[iRep].m_iNormalIdx == -1)		// no normal index found
        {
			WRITE_FLOAT(pbNormalsCurr, 1.0f);
			WRITE_FLOAT(pbNormalsCurr, 0.0f);
			WRITE_FLOAT(pbNormalsCurr, 0.0f);
		}
		else 
        {
			WRITE_FLOAT(pbNormalsCurr, pShape->m_rgNormals[pShape->m_rgReps[iRep].m_iNormalIdx].vec[0]);
			WRITE_FLOAT(pbNormalsCurr, pShape->m_rgNormals[pShape->m_rgReps[iRep].m_iNormalIdx].vec[1]);
			WRITE_FLOAT(pbNormalsCurr, pShape->m_rgNormals[pShape->m_rgReps[iRep].m_iNormalIdx].vec[2]);
		}
	}

	// nFaceNormals
	WRITE_DWORD(pbNormalsCurr, ((DWORD)pShape->m_cFaces));

	// faceNormals
	int iFace;

	for (iFace = 0; iFace < pShape->m_cFaces; iFace++) 
	{
		WRITE_DWORD(pbNormalsCurr, ((DWORD)pShape->m_rgFaces[iFace].m_cIndices));

		for (int iIndex = 0; iIndex < pShape->m_rgFaces[iFace].m_cIndices; iIndex++)
			WRITE_DWORD(pbNormalsCurr, ((DWORD)pShape->m_rgFaces[iFace].m_rgIndices[iIndex]));
	}


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMMeshNormals, NULL, NULL, cbNormalsSize, pbNormalsData, &pNormalsDataObject),
				"Could not create normals data object")


	HR_ATTEMPT(pShapeDataObject->AddDataObject(pNormalsDataObject),
				"Could not add pNormalsDataObject to pShapeDataObject")



	EXIT;

	// clean up
	delete[] pbNormalsData;

	if (pNormalsDataObject)
		pNormalsDataObject->Release();

	return hr;
}










HRESULT	AddTexCoords
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pShapeDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{
	HRESULT	hr	= S_OK;

	LPDIRECTXFILEDATA	pTexCoordsDataObject	= NULL;

	PBYTE	pbTexCoordsData	= NULL;


	INIT;


	int		cbTexCoordsSize	= sizeof(DWORD)							// nTextureCoords
							+ pShape->m_cReps * (2 * sizeof(float));	// textureCoords

	PBYTE	pbTexCoordsCurr	= pbTexCoordsData	= new BYTE[cbTexCoordsSize];

	ASSERT(pbTexCoordsData,
				"Could not allocate memory for pbTexCoordsData");


	// nTextureCoords
	WRITE_DWORD(pbTexCoordsCurr, ((DWORD)pShape->m_cReps));

	// textureCoords
	for (int iRep = 0; iRep < pShape->m_cReps; iRep++) 
	{
		if (pShape->m_rgReps[iRep].m_iTexCoordIdx == -1)
		{
			WRITE_FLOAT(pbTexCoordsCurr, 0.0f);
			WRITE_FLOAT(pbTexCoordsCurr, 0.0f);
		}
		else 
		{
			WRITE_FLOAT(pbTexCoordsCurr, g_iFlipU * pShape->m_rgTexCoords[pShape->m_rgReps[iRep].m_iTexCoordIdx].vec[0]);
			WRITE_FLOAT(pbTexCoordsCurr, g_iFlipV * pShape->m_rgTexCoords[pShape->m_rgReps[iRep].m_iTexCoordIdx].vec[1]);
		}
	}

	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMMeshTextureCoords, NULL, NULL, cbTexCoordsSize, pbTexCoordsData, &pTexCoordsDataObject),
				"Could not create pTexCoordsDataObject");


	HR_ATTEMPT(pShapeDataObject->AddDataObject(pTexCoordsDataObject),
				"Could not add data object");


	EXIT;


	delete[] pbTexCoordsData;

	if (pTexCoordsDataObject)
		pTexCoordsDataObject->Release();

	return hr;
}







HRESULT	AddMaterialList
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pShapeDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{
	HRESULT				hr						= S_OK;

	LPDIRECTXFILEDATA	pMaterialsDataObject	= NULL;

	PBYTE				pbMaterialsData			= NULL;
	
	INIT;

	int		cbMaterialsSize	= sizeof(DWORD)						// nMaterials
							+ sizeof(DWORD)						// nFaceIndexes
							+ pShape->m_cFaces * sizeof(DWORD);	// FaceIndexes

	PBYTE	pbMaterialsCurr	= pbMaterialsData	= new BYTE[cbMaterialsSize];

	ASSERT(pbMaterialsCurr, 
				"Could not allocate memory for pbMaterialsData");


	// nMaterials
	WRITE_DWORD(pbMaterialsCurr, ((DWORD)pShape->m_cGroups));

	// nFaceIndexes
	WRITE_DWORD(pbMaterialsCurr, ((DWORD)pShape->m_cFaces));

	// FaceIndexes
	for (int iFace = 0; iFace < pShape->m_cFaces; iFace++)
		WRITE_DWORD(pbMaterialsCurr, pShape->m_rgFaces[iFace].m_iGroup);


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMMeshMaterialList, NULL, NULL, cbMaterialsSize, pbMaterialsData, &pMaterialsDataObject),
				"Could not create pMaterialsDataObject");

	// material data
	for (int iGroup = 0; iGroup < pShape->m_cGroups; iGroup++) 
	{
		LPDIRECTXFILEDATA	pMaterialDataObject	= NULL;
		LPDIRECTXFILEDATA	pTextureDataObject	= NULL;

		PBYTE				pbMaterialData		= NULL;

		INIT;

		int		cbMaterialSize	= 4 * sizeof(float)		// faceColor
								+ sizeof(float)			// power
								+ 3 * sizeof(float)		// specularColor
								+ 3 * sizeof(float);	// emissiveColor

		PBYTE	pbMaterialCurr	= pbMaterialData	= new BYTE[cbMaterialSize];

		ASSERT(pbMaterialCurr,
					"Could not allocate memory for pbMaterialData");


		// faceColor
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fDiffuseRed);
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fDiffuseGreen);
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fDiffuseBlue);
		WRITE_FLOAT(pbMaterialCurr, (1.0f - pShape->m_rgGroups[iGroup].m_fTransparency));

		// power
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fShininess);
		
		// specularColor
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fSpecularRed);
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fSpecularGreen);
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fSpecularBlue);

		// emissiveColor
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fEmissiveRed);
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fEmissiveGreen);
		WRITE_FLOAT(pbMaterialCurr, pShape->m_rgGroups[iGroup].m_fEmissiveBlue);


		HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMMaterial, NULL, NULL, cbMaterialSize, pbMaterialData, &pMaterialDataObject),
					"Could not create pMaterialDataObject");


		// TextureFilename		
		if (pShape->m_rgGroups[iGroup].m_szTextureFile) 
		{
			int		cbTextureSize	= sizeof(char**);

			HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMTextureFilename, NULL, NULL, cbTextureSize, &pShape->m_rgGroups[iGroup].m_szTextureFile, &pTextureDataObject),
						"Could not create pMaterialDataObject");

			HR_ATTEMPT(pMaterialDataObject->AddDataObject(pTextureDataObject),
						"Could not add pTextureDataObject to pMaterialDataObject");
		}


	    HR_ATTEMPT(pMaterialsDataObject->AddDataObject(pMaterialDataObject),
					"Could not add pMaterialDataObject to pMaterialsDataObject");


		EXIT;


		delete[] pbMaterialData;

		if (pMaterialDataObject)
			pMaterialDataObject->Release();

		if (pTextureDataObject)
			pTextureDataObject->Release();


		ASSERT(SUCCEEDED(hr),	
					"Error occured while adding materials");
	}


	HR_ATTEMPT(pShapeDataObject->AddDataObject(pMaterialsDataObject),
				"Could not add pMaterialsDataObject to pShapeDataObject");


	EXIT;


	delete[] pbMaterialsData;

	if (pMaterialsDataObject)
		pMaterialsDataObject->Release();	
	
		
	return hr;
}








HRESULT	AddVertexColors
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pShapeDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{
	HRESULT	hr	= S_OK;

	LPDIRECTXFILEDATA	pColorsDataObject	= NULL;

	PBYTE	pbColorsData	= NULL;
	

	INIT;

	int		cbColorsSize	= sizeof(DWORD)												// nVertexColors
							+ pShape->m_cReps * (sizeof(DWORD) + 4 * sizeof(float));		// vertexColors

	PBYTE	pbColorsCurr	= pbColorsData	= new BYTE[cbColorsSize];

	ASSERT(pbColorsData,
				"Could not allocate memory for pbColorsData");


	// nVertexColors
	WRITE_DWORD(pbColorsCurr, ((DWORD)pShape->m_cReps));

	// vertexColors
	for (int iRep = 0; iRep < pShape->m_cReps; iRep++) 
	{
		// index
		WRITE_DWORD(pbColorsCurr, ((DWORD)iRep));

		// indexedColor
		WRITE_FLOAT(pbColorsCurr, pShape->m_rgVertexColors[pShape->m_rgReps[iRep].m_iFirst].r);	// red
		WRITE_FLOAT(pbColorsCurr, pShape->m_rgVertexColors[pShape->m_rgReps[iRep].m_iFirst].g);	// green
		WRITE_FLOAT(pbColorsCurr, pShape->m_rgVertexColors[pShape->m_rgReps[iRep].m_iFirst].b);	// blue
		WRITE_FLOAT(pbColorsCurr, pShape->m_rgVertexColors[pShape->m_rgReps[iRep].m_iFirst].a);	// alpha
	}


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMMeshVertexColors, NULL, NULL, cbColorsSize, pbColorsData, &pColorsDataObject),
				"Could not create pColorsDataObject");


	HR_ATTEMPT(pShapeDataObject->AddDataObject(pColorsDataObject),
				"Could not add pColorsDataObject to pShapeDataObject");


	EXIT;


	delete[] pbColorsData;

	if (pColorsDataObject)
		pColorsDataObject->Release();


	return hr;
}











HRESULT	AddRepInfo
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pShapeDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{
	HRESULT	hr	= S_OK;


	LPDIRECTXFILEDATA	pRepsDataObject	= NULL;


	PBYTE	pbRepsData	= NULL;
	
	INIT;

	int		cbRepsSize	= sizeof(DWORD)						// nIndices
						+ sizeof(DWORD)						// nOriginalVertices
						+ pShape->m_cReps * sizeof(DWORD);	// indices

	PBYTE	pbRepsCurr	= pbRepsData	= new BYTE[cbRepsSize];

	ASSERT(pbRepsData,
				"Could not allocate memory for pbRepsData");


	// nIndices
	WRITE_DWORD(pbRepsCurr, ((DWORD)pShape->m_cReps));

	// nOriginalVertices
	WRITE_DWORD(pbRepsCurr, ((DWORD)pShape->m_cVertices));

	// indices
	for (int iRep = 0; iRep < pShape->m_cReps; iRep++)
		WRITE_DWORD(pbRepsCurr, ((DWORD)pShape->m_rgReps[iRep].m_iFirst));


	HR_ATTEMPT(pxofSave->CreateDataObject(DXFILEOBJ_VertexDuplicationIndices, NULL, NULL, cbRepsSize, pbRepsData, &pRepsDataObject),
				"Could not create pRepsDataObject");


	HR_ATTEMPT(pShapeDataObject->AddDataObject(pRepsDataObject),
				"Could not add pRepsDataObject to pShapeDataObject");


	EXIT;


	delete[] pbRepsData;

	if (pRepsDataObject)
		pRepsDataObject->Release();


	return hr;
}













HRESULT	AddPatchMesh
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pFrameDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{

	HRESULT	hr	= S_OK;

	LPDIRECTXFILEDATA	pShapeDataObject	= NULL;

	PBYTE	pbShapeData	= NULL;


	INIT;


	int		cbShapeSize	= sizeof(DWORD)													// nVertices
						+ pShape->m_cReps * (3 * sizeof(float))							// vertices
						+ sizeof(DWORD)													// nPatches
						+ (pShape->m_cFaces + pShape->m_cFaceIndices) * sizeof(DWORD);	// patches

	PBYTE	pbShapeCurr	= pbShapeData	= new BYTE[cbShapeSize];

	ASSERT(pbShapeData,
				"Could not allocate memory for pbpShapeData");
	

	// nVertices
	WRITE_DWORD(pbShapeCurr, ((DWORD)pShape->m_cVertices));

	// vertices
	for (int iRep = 0; iRep < pShape->m_cReps; iRep++) 
	{
		WRITE_FLOAT(pbShapeCurr, pShape->m_rgVertices[pShape->m_rgReps[iRep].m_iFirst].vec[0]);
		WRITE_FLOAT(pbShapeCurr, pShape->m_rgVertices[pShape->m_rgReps[iRep].m_iFirst].vec[1]);
		WRITE_FLOAT(pbShapeCurr, pShape->m_rgVertices[pShape->m_rgReps[iRep].m_iFirst].vec[2]);
	}

	// nPatches
	WRITE_DWORD(pbShapeCurr, ((DWORD)pShape->m_cFaces));

	// faces
	for (int iFace = 0; iFace < pShape->m_cFaces; iFace++) 
	{
		WRITE_DWORD(pbShapeCurr, ((DWORD)16));

		for (int iIndex = 0; iIndex < 16; iIndex++)
			WRITE_DWORD(pbShapeCurr, pShape->m_rgFaces[iFace].m_rgIndices[iIndex]);
	}


	HR_ATTEMPT(pxofSave->CreateDataObject(DXFILEOBJ_PatchMesh, NULL, NULL, cbShapeSize, pbShapeData, &pShapeDataObject),
				"Could not create pShapeDataObject");



	// MeshTextureCoords
	if (pShape->m_cTexCoords > 0) 
	{
		HR_ATTEMPT(AddTexCoords(pShape, pShapeDataObject, pxofSave),
					"Could not add texture coordinate info");
	}

	// MeshVertexColors
//	HR_ATTEMPT(AddVertexColors(pShape, pShapeDataObject, pxofSave),
//				"Could not add vertex color info");
	
	// MeshMaterialList
	HR_ATTEMPT(AddMaterialList(pShape, pShapeDataObject, pxofSave),
				"Could not add materials info");

	// VertexDuplicationIndices
	HR_ATTEMPT(AddRepInfo(pShape, pShapeDataObject, pxofSave),
				"Could not add rep info");

	// XSkinMeshHeader
	if (pShape->m_cBones > 0) 
	{
		HR_ATTEMPT(AddSkin(pShape, pShapeDataObject, pxofSave),
					"Could not add skin info");
	}



	HR_ATTEMPT(pFrameDataObject->AddDataObject(pShapeDataObject),
				"Could not add pShapeDataObject to pFrameDataObject");


	EXIT;


	delete[] pbShapeData;

	if (pShapeDataObject)
		pShapeDataObject->Release();


	return hr;
}
















HRESULT	AddPolyMesh
		(
			Mesh*					pShape, 
			LPDIRECTXFILEDATA		pFrameDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{

	HRESULT				hr				= S_OK;

	LPDIRECTXFILEDATA	pShapeDataObject	= NULL;

	PBYTE				pbMeshData		= NULL;

	INIT;

	int		cbMeshSize	= sizeof(DWORD)													// nVertices
						+ pShape->m_cReps * (3 * sizeof(float))							// vertices
						+ sizeof(DWORD)													// nFaces
						+ (pShape->m_cFaces + pShape->m_cFaceIndices) * sizeof(DWORD);	// faces

	PBYTE	pbMeshCurr	= pbMeshData	= new BYTE[cbMeshSize];

	ASSERT(pbMeshData,
				"Could not allocate memory for pbMeshData");
	

	// nVertices
	WRITE_DWORD(pbMeshCurr, ((DWORD)pShape->m_cReps));

	// vertices
	for (int iRep = 0; iRep < pShape->m_cReps; iRep++) 
	{
		WRITE_FLOAT(pbMeshCurr, pShape->m_rgVertices[pShape->m_rgReps[iRep].m_iFirst].vec[0]);
		WRITE_FLOAT(pbMeshCurr, pShape->m_rgVertices[pShape->m_rgReps[iRep].m_iFirst].vec[1]);
		WRITE_FLOAT(pbMeshCurr, pShape->m_rgVertices[pShape->m_rgReps[iRep].m_iFirst].vec[2]);
	}

	// nFaces
	WRITE_DWORD(pbMeshCurr, ((DWORD)pShape->m_cFaces));

	// faces
	for (int iFace = 0; iFace < pShape->m_cFaces; iFace++) 
	{
		WRITE_DWORD(pbMeshCurr, ((DWORD)pShape->m_rgFaces[iFace].m_cIndices));

		for (int iIndex = 0; iIndex < pShape->m_rgFaces[iFace].m_cIndices; iIndex++)
			WRITE_DWORD(pbMeshCurr, ((DWORD)pShape->m_rgFaces[iFace].m_rgIndices[iIndex]));
	}


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMMesh, NULL, NULL, cbMeshSize, pbMeshData, &pShapeDataObject),
				"Could not create pShapeDataObject");


	// MeshNormals
	if (pShape->m_cNormals > 0) 
	{
		HR_ATTEMPT(AddNormals(pShape, pShapeDataObject, pxofSave),
					"Could not add normal info");
	}


	// MeshTextureCoords
	if (pShape->m_cTexCoords > 0) 
	{
		HR_ATTEMPT(AddTexCoords(pShape, pShapeDataObject, pxofSave),
					"Could not add texture coordinate info");
	}

	// MeshVertexColors
//	HR_ATTEMPT(AddVertexColors(pShape, pShapeDataObject, pxofSave),
//				"Could not add vertex color info");

	
	// MeshMaterialList
	HR_ATTEMPT(AddMaterialList(pShape, pShapeDataObject, pxofSave),
				"Could not add materials info");


	// VertexDuplicationIndices
	HR_ATTEMPT(AddRepInfo(pShape, pShapeDataObject, pxofSave),
				"Could not add rep info");


	// XSkinMeshHeader
	if (pShape->m_cBones > 0) 
	{
		HR_ATTEMPT(AddSkin(pShape, pShapeDataObject, pxofSave),
					"Could not add skin info");
	}


	HR_ATTEMPT(pFrameDataObject->AddDataObject(pShapeDataObject),
				"Could not add pShapeDataObject to pFrameDataObject");



	EXIT;



	delete[] pbMeshData;

	if (pShapeDataObject)
		pShapeDataObject->Release();


	return hr;
}









HRESULT	AddShape
		(
			int						iShape, 
			LPDIRECTXFILEDATA		pParentFrameDataObject, 
			LPDIRECTXFILESAVEOBJECT	pxofSave
		) 
{

	HRESULT				hr					= S_OK;

    LPDIRECTXFILEDATA	pFrameDataObject	= NULL;
	LPDIRECTXFILEDATA	pMatrixDataObject	= NULL;


	INIT;


	// shape name
	char*	szName;

	DT_ATTEMPT(DtShapeGetName(iShape, &szName));


	cout << "\treading " << szName << endl;


	// local transform
	float*	rgfLocalTransform;

	DT_ATTEMPT(DtShapeGetMatrix(iShape, &rgfLocalTransform));


	// Frame
	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMFrame, szName, NULL, 0, NULL, &pFrameDataObject),
				"Could not create pFrameDataObject");

	// FrameTransformMatrix
	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMFrameTransformMatrix, NULL, NULL, 16 * sizeof(float), rgfLocalTransform, &pMatrixDataObject),
				"Could not create pMatrixDataObject");



	HR_ATTEMPT(pFrameDataObject->AddDataObject(pMatrixDataObject),
				"Could not add pMatrixDataObject to pFrameDataObject");


	// the reason for the braces here is to place Mesh in a local scope so that will be deleted quickly 
	{	
		Mesh	mesh;

		LoadShape(iShape, &mesh);

		switch (mesh.m_kType) 
		{
			case Mesh::PATCH_MESH:
				HR_ATTEMPT(AddPatchMesh(&mesh, pFrameDataObject, pxofSave),
							"Could not add patch mesh");
				break;
			case Mesh::POLY_MESH:
				// DtShapeGetVertexCount returns an error code if cVertices == 0
				HR_ATTEMPT(AddPolyMesh(&mesh, pFrameDataObject, pxofSave),
							"Could not add mesh");
				break;
			case Mesh::BONE:
				break;
			default:
				ASSERT(false, "Unknown shape type");
				break;
		};
	}	

	// add children
	int		cChildren;
	int*	rgiChildren;

	DT_ATTEMPT(MyDtShapeGetChildren(iShape, &cChildren, &rgiChildren));

	for (int iChild = 0; iChild < cChildren; iChild++) 
	{
		HR_ATTEMPT(AddShape(rgiChildren[iChild], pFrameDataObject, pxofSave),
					"Could not add shape");
	}

	delete[] rgiChildren;

	HR_ATTEMPT(pParentFrameDataObject->AddDataObject(pFrameDataObject),
				"Could not add pFrameDataObject to pParentFrameDataObject");

	EXIT;

	
	if (pMatrixDataObject)
		pMatrixDataObject->Release();

	if (pFrameDataObject)
		pFrameDataObject->Release();
	

	return hr;
}






HRESULT	AddScene
		(
			const char*	szFile
		) 
{
	HRESULT	hr	= S_OK;


    LPDIRECTXFILE			pxofApi					= NULL;
    LPDIRECTXFILESAVEOBJECT	pxofSave				= NULL; 

	LPDIRECTXFILEDATA		pAnimSetObject			= NULL;
	LPDIRECTXFILEDATA		pRootFrameObject		= NULL;
	LPDIRECTXFILEDATA		pRootTransformObject	= NULL;

	INIT;


	// Initialize the Dt database 
	DtExt_SceneInit("scene");

	DtExt_setJointHierarchy(true);
	DtExt_setParents(true);
	DtExt_setOutputTransforms(kTRANSFORMALL);
	DtExt_setTesselate(kTESSTRI);
	DtExt_setWalkMode(0);
	DtExt_setInlineTextures(0);			    // jimn; 9/25/00; Don't convert textures
	DtExt_setOriginalTexture(1);			// jimn; 9/25/00; Use original textures.
//    DtExt_setSoftTextures(1);
    DtExt_setOutputCameras(0);

	DtExt_dbInit();


	cout << "Exporting to " << szFile << " ..." << endl;


	// create xofapi object.
	HR_ATTEMPT(DirectXFileCreate(&pxofApi),
				"Could not create xofapi object");


	// register templates for d3drm.
	HR_ATTEMPT(pxofApi->RegisterTemplates((LPVOID)D3DRM_XTEMPLATES, D3DRM_XTEMPLATE_BYTES),
				"Could not register D3D templates");


	// register extra templates for skinning info and vertex duplication
	HR_ATTEMPT(pxofApi->RegisterTemplates((LPVOID)XSKINEXP_TEMPLATES, strlen(XSKINEXP_TEMPLATES)),
				"Could not register Skinning and/or Vertex Duplication templates");


	// create save object.
	HR_ATTEMPT(pxofApi->CreateSaveObject(szFile, g_FileFormat, &pxofSave),
				"Could not create save object");


	// save templates
	HR_ATTEMPT(pxofSave->SaveTemplates(3, aIds),
				"Could not save templates.");


	// save file data to the file

	// first create the SCENE_ROOT Frame
	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMFrame, SCENE_ROOT, NULL, 0, NULL, &pRootFrameObject),
				"Could not create pRootFrameObject");


	// next create the SCENE_ROOT FrameTransformMatrix as the Identity 
	float rgfIdentity[16] = {1.0f, 0.0f, 0.0f, 0.0f,
							 0.0f, 1.0f, 0.0f, 0.0f,
							 0.0f, 0.0f, 1.0f, 0.0f,
							 0.0f, 0.0f, 0.0f, 1.0f};


	HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMFrameTransformMatrix, NULL, NULL, 16 * sizeof(float), rgfIdentity, &pRootTransformObject),
				"Could not create pRootTransformObject");


	HR_ATTEMPT(pRootFrameObject->AddDataObject(pRootTransformObject),
				"Could not add pRootTransformObject to pRootFrameObject");


	cout << endl << "Loading scene data..." << endl;

	int cShapes = DtShapeGetCount();

	// add all shapes which have no parents
	for (int iShape = 0; iShape < cShapes; iShape++) 
	{
		if (MyDtShapeGetParentID(iShape) == -1) 
		{
			HR_ATTEMPT(AddShape(iShape, pRootFrameObject, pxofSave),
						"Could not add top level shape");
		}
	}


	cout << "Writing scene data..." << endl;

	HR_ATTEMPT(pxofSave->SaveData(pRootFrameObject),
				"Could not save scene data to file");




	if (g_bExportAnimation) 
	{
		HR_ATTEMPT(pxofSave->CreateDataObject(TID_D3DRMAnimationSet, NULL, NULL, 0, NULL, &pAnimSetObject),
					"Could not create pAnimSetObject");

	
		cout << endl << "Loading animation data..." << endl;

		bool	bAnimDataFound	= false;

		if (g_bKeyframeAnimation) 
		{
			for (iShape = 0; iShape < cShapes; iShape++) 
			{
				Anim	anim;

				loadAnim(iShape, &anim);

				if (anim.m_cKeys > 0) 
				{
					hr = AddAnim(&anim, pAnimSetObject, pxofSave);

					if (FAILED(hr))
						break;

					bAnimDataFound	= true;
				}


				freeAnim(&anim);

				ASSERT(SUCCEEDED(hr), "Could not add animation data");
			}
		}
		else 		// regular animation
		{
			Anim*	rgAnims	= new Anim[cShapes];

			ASSERT(rgAnims,
						"Could not allocate memory for large animation array");

			loadAllAnims(rgAnims);

			for (int iShape = 0; iShape < cShapes; iShape++) 
			{
				if (rgAnims[iShape].m_cKeys > 0) 
				{
					hr = AddAnim(&rgAnims[iShape], pAnimSetObject, pxofSave);

					if (FAILED(hr))
						break; 

					bAnimDataFound	= true;
				}
			}


			freeAllAnims(rgAnims);

			delete[] rgAnims;

			ASSERT(SUCCEEDED(hr), "Could not add animation data");
		}

		if (bAnimDataFound) 
		{
			cout << "Writing animation data..." << endl;

			HR_ATTEMPT(pxofSave->SaveData(pAnimSetObject),
						"Could not save animation data to file");
		}
		else 
		{
			cout << "Writing skipped (no animation data found)..." << endl;
		}
	}
	else 
	{
		cout << endl << "Ignoring animation..." << endl;
	}

	EXIT;


	if (pRootFrameObject)
		pRootFrameObject->Release();

	if (pRootTransformObject)
		pRootTransformObject->Release();

	if (pAnimSetObject)
		pAnimSetObject->Release();


	if (pxofSave) 
		pxofSave->Release();

	if (pxofApi)
		pxofApi->Release();



	cout << endl;

	if (FAILED(hr))
		cout << "There were errors.";
	else 
		cout << "Completed successfully.";

	cout << endl << "...................................................." << endl << endl;


	cout.flush();

	// Clean up the allocated memory and internal storage
	DtExt_CleanUp();

	return hr;
}





void	ParseOptions
		(
			MString	sOptions
		) 
{
	if (sOptions.length() > 0) 
	{
		MStringArray	optionList;

		sOptions.split(';', optionList);

		// break out all the options.
		for (int iOption = 0; iOption < (int)optionList.length(); iOption++) 
		{
			MStringArray    theOption;

			optionList[iOption].split('=', theOption);

			if (theOption.length() > 1) 
			{
				if (theOption[0] == "fileFormat") 
				{
					if (theOption[1] == "binary") 
					{
						g_FileFormat	= DXFILEFORMAT_BINARY;
					}
					else if (theOption[1] == "compressed") 
					{
						g_FileFormat	= DXFILEFORMAT_COMPRESSED;
					}
					else	// "text" 
					{	
						g_FileFormat	= DXFILEFORMAT_TEXT;
					}
				}
				else if (theOption[0] == "exportAnimation") 
				{
					if (theOption[1] == "false") 
					{
						g_bExportAnimation	= false;
					}
					else 	// "true"
					{
						g_bExportAnimation	= true;
					}
				}
				else if (theOption[0] == "keyframeAnimation") 
				{
					if (theOption[1] == "false") 
					{
						g_bKeyframeAnimation	= false;
					}
					else 	// "true"
					{
						g_bKeyframeAnimation	= true;
					}
				}
				else if (theOption[0] == "animateEverything") 
				{
					if (theOption[1] == "false") 
					{
						g_bAnimateEverything	= false;
					}
					else 	// "true"
					{
						g_bAnimateEverything	= true;
					}
				}
				else if (theOption[0] == "frameStep") 
				{
					g_iFrameStep	= theOption[1].asInt();
				}
				else if (theOption[0] == "flipU") 
				{
					if (theOption[1] == "true") 
					{
						g_iFlipU	= -1;
					}
					else 	// "false"
					{
						g_iFlipU	= 1;
					}
				}
				else if (theOption[0] == "flipV") 
				{
					if (theOption[1] == "true") 
					{
						g_iFlipV	= 1;
					}
					else 	// "false"
					{
						g_iFlipV	= -1;
					}
				}
				else if (theOption[0] == "exportPatches") 
				{
					if (theOption[1] == "true") 
					{
						g_bExportPatches	= true;
					}
					else 	// "false"
					{
						g_bExportPatches	= false;
					}
				}
				else if (theOption[0] == "relTexFilename")
				{
					if (theOption[1] == "true") 
					{
						g_bRelativeTexFile	= true;
					}
					else 	// "false"
					{
						g_bRelativeTexFile	= false;
					}
				}
			}
		}
	}
}



MStatus	xfileTranslator::writer
		(	// parameters
			const MFileObject& file, 
			const MString& sOptions, 
			MPxFileTranslator::FileAccessMode mode
		) 
{
	g_Strings.reset();

	ParseOptions(sOptions);

	MString	sFile	= file.fullName();

	int		iExt	= sFile.rindex('.');
	MString	sExt	= sFile.substring(iExt, sFile.length() - 1);

	sFile	= (sExt == ".x" || sExt == ".X") ? sFile : (sFile + ".x");

	AddScene(sFile.asChar());

	g_Strings.clear();

	return MS::kSuccess;
}





MStatus	initializePlugin 
		(	
			MObject	obj
		) 
{
	MStatus         status;
	char			version[256];

	strcpy(version, "0.3");				// plug-in version
	strcat(version, ".");
	strcat(version, DtAPIVersion());
	
	MFnPlugin       plugin(obj, "XFile Translator for Maya", version, "Any");

	// register the translator
	status = plugin.registerFileTranslator("XFile", "xfileTranslator.rgb", xfileTranslator::creator, "xfileTranslatorOpts", "", true);

	if (!status)
		status.perror("registerFileTranslator");

	return status;
}


MStatus	uninitializePlugin
		(	
			MObject obj
		) 
{
	MStatus         status;
	MFnPlugin       plugin(obj);

	status = plugin.deregisterFileTranslator("XFile");

	if (!status)
		status.perror("deregisterFileTranslator");

	return status;
}





/*** TOOLS

	// print out the attributes of a dependency node
	for (unsigned iAttr = 0; iAttr < fnNode.attributeCount(); iAttr++) 
	{
		MFnAttribute fnAttr(fnNode.attribute(iAttr));

		cout << fnNode.name() << "." << fnAttr.name() << ": " << fnNode.attribute(iAttr).apiTypeStr() << endl;
	}





	// print the node containing the corresponging plug to 'plug'
	MPlugArray rgPlugs;

	plug.connectedTo(rgPlugs, true, true);

	for (int i = 0; i < (int)rgPlugs.length(); i++) 
	{
		MFnDependencyNode fnNode(rgPlugs[i].node());

		cout << fnNode.name() << "\t" << rgPlugs[i].name() << endl;
	}
 ***/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\shape\fmath.h ===
#pragma once

#ifndef _FMATH_H
#define _FMATH_H

/*///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:       fmath.h
//  Content:    C++ header to define standard float-valued math entry points
//              with the same names. This leverages function overloading in
//              C++ to 1) get more efficient implementations of the math
//              runtime if floats are being used, and 2) avoid thorny build
//              problems caused by downcasting the double-valued returns from
//              the standard math lib.
//
///////////////////////////////////////////////////////////////////////////*/

_inline void
sincos( float fRadians, float *pfSin, float *pfCos )
{
#ifdef _X86_
    _asm
    {
        mov eax,pfSin
        mov edx,pfCos
        fld fRadians
        // fsincos
        _emit 0xd9
        _emit 0xfb
        fstp dword ptr [edx]
        fstp dword ptr [eax]
    }
#else
    *pfSin = sinf( fRadians );
    *pfCos = cosf( fRadians );
#endif
}


// These overloaded functions are available only for c++
_inline float
hypot( float x, float y )
{
    return (float) _hypot(x, y);
}

_inline float
acos(float f)
{
    return acosf(f);
}

_inline float
asin(float f)
{
    return asinf(f);
}

_inline float
atan(float f)
{
    return atanf(f);
}

_inline float
atan2(float f1, float f2)
{
    return atan2f(f1, f2);
}

_inline float
cos(float f)
{
    return cosf(f);
}

_inline float
cosh(float f)
{
    return coshf(f);
}

_inline float
exp(float f)
{
    return expf(f);
}


_inline float
fabs(float f)
{
    return fabsf(f);
}

_inline float
fmod(float f1, float f2)
{
    return fmod(f1, f2);
}

_inline float
log(float f)
{
    return logf(f);
}

_inline float
log10(float f)
{
    return log10f(f);
}


_inline float
pow(float f1, float f2)
{
    return powf(f1, f2);
}

_inline float
sin(float f)
{
    return sinf(f);
}

_inline float
sinh(float f)
{
    return sinhf(f);
}

_inline float
tan(float f)
{
    return tanf(f);
}

_inline float
tanh(float f)
{
    return tanhf(f);
}

_inline float
sqrt(float f)
{
    return sqrtf(f);
}

_inline float
ceil(float f)
{
    return ceilf(f);
}

_inline float
floor(float f)
{
    return floorf(f);
}

_inline float
modf(float f, float *pf)
{
    return modff(f, pf);
}

//
//----------------------------------------------------------------------------
// Function: InvSqrt
//     Compute inverse square root - full precision
//----------------------------------------------------------------------------
//
_inline float
InvSqrt(float f)
{
    return 1.f / (float)sqrt( (double)f );
}

//
//----------------------------------------------------------------------------
//   The IEEE single precision floating point format is:
// 
//   SEEEEEEEEMMMMMMM MMMMMMMMMMMMMMMM
// 
//   S = Sign bit for whole number
//   E = Exponent bit (exponent in excess 127 form)
//   M = Mantissa bit
//----------------------------------------------------------------------------
//
#define _nEXPBIAS   127
#define _nEXPSHIFTS 23
#define _nEXPLSB    (1 << _nEXPSHIFTS)

//
//----------------------------------------------------------------------------
// Macro:       FloatToFixed
// Purpose:     Compute the 16.16 fixed point from the float
// Notes:       Relies on IEEE bit representation of floating point numbers
//----------------------------------------------------------------------------
//
#define FloatToFixed(__nDst, __fSrc) do { \
    float fTmp = __fSrc; \
    UINT nRaw = *((UINT *) &(fTmp)); \
    if (nRaw < ((_nEXPBIAS + 15 - 31) << _nEXPSHIFTS)) \
        __nDst = 0; \
    else \
    __nDst = (((nRaw | _nEXPLSB) << 8) >> ((_nEXPBIAS + 15) - (nRaw >> _nEXPSHIFTS))); \
} while (0)

//
//----------------------------------------------------------------------------
// Macro:       FloatToFixedNoScale
// Purpose:     Compute the 16.16 fixed point from the float, divides by 2^16
// Notes:       Relies on IEEE bit representation of floating point numbers
//----------------------------------------------------------------------------
//
#define FloatToFixedNoScale(nDst, fSrc) do { \
    float fTmp = fSrc; \
    UINT nRaw = *((UINT *) &(fTmp)); \
    if (nRaw < (_nEXPBIAS << _nEXPSHIFTS)) \
        nDst = 0; \
    else \
        nDst = (((nRaw | _nEXPLSB) << 8) >> ((_nEXPBIAS + 31) - (nRaw >> _nEXPSHIFTS))); \
} while (0)

//
//----------------------------------------------------------------------------
// Function:    FloatEquals
// Purpose:     Perform a "fuzzy" compare of two floating point numbers
// Notes:       Relies on IEEE bit representation of floating point numbers
//----------------------------------------------------------------------------
//
_inline BOOL __cdecl
FloatEquals(float x1, float x2)
{
#define maskEXP         0x7f800000
#define nBITSOFPREC     19
#define nMANTBITS       23
#define nEXPOFFSET      (nBITSOFPREC << nMANTBITS)
#define fZEROEPS        3.8E-6F
#define fTINYEPS        1.E-35F

    float fEps;
    unsigned int uExp;
    
    // compute epsilon
    if ((x1 == 0.0f) || (x2 == 0.0f)) {
        fEps = fZEROEPS;
    } else {
        float fMaxX;
        
        if (x1 > x2) 
            fMaxX = x1;
        else 
            fMaxX = x2;
        
        // grab the exponent of the larger number
        uExp = (*((unsigned int *) &fMaxX) & maskEXP);

        if (uExp < nEXPOFFSET) {
            // near zero
            fEps = fTINYEPS;
        } else {
            uExp -= nEXPOFFSET;
            fEps = *((float *) &uExp);
        }
    }
    return (((x1 + fEps) >= x2) && ((x1 - fEps) <= x2));
#undef maskEXP
#undef nBITSOFPREC
#undef nMANTBITS
#undef nEXPOFFSET
#undef fZEROEPS
#undef fTINYEPS
}

#endif // _FMATH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\shape\pchshape.h ===
#include <d3dx8seg.h>
#include <xtl.h>
#include "d3dx8dbg.h"
#include "malloc.h"

#define RELEASE(x) \
    do { if(x) { x->Release(); x = NULL; } } while(0)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\shape\local.h ===
/******************************Module*Header*******************************\
* Module Name: local.h                                                     *
*                                                                          *
* Definitions needed for client side objects and attribute caching.        *
*                                                                          *
* Modified: 3-Aug-1992 22:35:30 by Gerrit van Wingerden [gerritv]          *
*   Added client side transform support.                                   *
*                                                                          *
* Created: 30-May-1991 21:55:01                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1993 Microsoft Corporation                                 *
\**************************************************************************/

/**************************************************************************\
 *
 * Local handle macros
 *
\**************************************************************************/

// Handle uniqueness is nice to check but an unnecesary performance cost in
// a free build.

// To match the uniqness field:  If the handle uniqness == 0, let it through
// anyway.  This is a method for WOW to only keep track of the low 16 bits but
// still get reasonable performance.  Even if a 32 bit app does this, all it
// can do is hose it self, not the system or another app.

#define INDEX_MASK  0xFFFF
#define UNIQ_SHIFT  16
#define UNIQ_MASK   0xFFFF
#define HIPART(x) *(((USHORT *) &(x))+1)
#define MATCHUNIQ(plhe,h) ((USHORT) plhe->iUniq == HIPART(h))
#define MASKINDEX(h) ((UINT)((UINT_PTR)h & INDEX_MASK))
#define LHANDLE(i)  (i+((ULONG)pLocalTable[i].iUniq<<UNIQ_SHIFT))

//!!!XXX -- Do we really need typing?  Not really, but we may add more
//!!!XXX    later.  So eventually we might take it out, but its nice for now.

// Define the types of local objects.

enum LO_TYPE
{
    LO_NULL,
    LO_RC,
    LO_LAST
};

#define INVALID_INDEX 0xFFFFFFFFL
#define COMMIT_COUNT  (4096/sizeof(LHE))
#define MAX_HANDLES (16384/COMMIT_COUNT)*COMMIT_COUNT

// Define a Local Handle Entry.  Our Local Handle Table, pLocalTable, is an
// array of these.

typedef struct _LHE
{
    ULONG_PTR hgre;     // GRE Handle.
    USHORT cRef;        // Reference count of the object.
    BYTE   iType;       // Object type.
    BYTE   iUniq;       // Handle uniqueness field.  Always non-zero.
    PVOID  pv;          // Pointer to local object.
    ULONG  metalink;    // Non-zero if object is a "metafile friend".
                        // Points to a metafile DC object if it's a metafile.
                        // Also links the free list.
    DWORD  tidOwner;    // Per-thread lock owner.
    LONG   cLock;       // Lock count.
} LHE,*PLHE;

extern LHE                  *pLocalTable;   // Points to handle table.
extern ULONG                 iFreeLhe;      // Identifies a free handle index.
extern ULONG                 cLheCommitted; // Count of LHEs with committed RAM.
extern CRITICAL_SECTION      semLocal;      // Semaphore for handle allocation.
extern CRITICAL_SECTION      wfo_cs;        // Semaphore for wglUseFontOutlines


// Semaphore utilities

#define INITIALIZECRITICALSECTION(psem) InitializeCriticalSection((psem))
#define ENTERCRITICALSECTION(hsem)      EnterCriticalSection((hsem))
#define LEAVECRITICALSECTION(hsem)      LeaveCriticalSection((hsem))
#define DELETECRITICALSECTION(psem)     DeleteCriticalSection((psem))

// Local data structures

// Maximum OpenGL driver name

#define MAX_GLDRIVER_NAME   MAX_PATH

// GetCurrentThreadID will never return this value

#define INVALID_THREAD_ID   0

// Driver context function prototypes

typedef BOOL            (APIENTRY *PFN_DRVVALIDATEVERSION) (ULONG);
typedef VOID            (APIENTRY *PFN_DRVSETCALLBACKPROCS)(INT, PROC *);

// Driver flags.

// Driver wants buffer calls sent to ICD DLL rather than the display
// driver.  This is required on Win95.
#define GLDRIVER_CLIENT_BUFFER_CALLS    0x00000001

// Driver does not want glFinish called during swap.  Only
// applies to client swap calls.
#define GLDRIVER_NO_FINISH_ON_SWAP      0x00000002

// Driver had registry key rather than just registry value.
// This provides a way to check for new-style registry information.
#define GLDRIVER_FULL_REGISTRY          0x80000000

// Driver data

typedef struct _GLDRIVER {
    HINSTANCE             hModule;             // Module handle
    DWORD                 dwFlags;

    // Driver function pointers

    // Required
    DHGLRC          (APIENTRY *pfnDrvCreateContext)(HDC);
    BOOL            (APIENTRY *pfnDrvDeleteContext)(DHGLRC);
    PGLCLTPROCTABLE (APIENTRY *pfnDrvSetContext)(HDC, DHGLRC,
                                                 PFN_SETPROCTABLE);
    BOOL            (APIENTRY *pfnDrvReleaseContext)(DHGLRC);

    // Optional
    BOOL            (APIENTRY *pfnDrvCopyContext)(DHGLRC, DHGLRC, UINT);
    DHGLRC          (APIENTRY *pfnDrvCreateLayerContext)(HDC, int);
    BOOL            (APIENTRY *pfnDrvShareLists)(DHGLRC, DHGLRC);
    PROC            (APIENTRY *pfnDrvGetProcAddress)(LPCSTR);
    BOOL            (APIENTRY *pfnDrvDescribeLayerPlane)(HDC, INT, INT, UINT,
                                                      LPLAYERPLANEDESCRIPTOR);
    INT             (APIENTRY *pfnDrvSetLayerPaletteEntries)(HDC, INT, INT,
                                                             INT,
                                                             CONST COLORREF *);
    INT             (APIENTRY *pfnDrvGetLayerPaletteEntries)(HDC, INT, INT,
                                                             INT, COLORREF *);
    BOOL            (APIENTRY *pfnDrvRealizeLayerPalette)(HDC, INT, BOOL);
    BOOL            (APIENTRY *pfnDrvSwapLayerBuffers)(HDC, UINT);
    DHGLRC          (APIENTRY *pfnDrvCreateDirectDrawContext)
        (HDC, LPDIRECTDRAWSURFACE, int);
    int             (APIENTRY *pfnDrvEnumTextureFormats)(int, DDSURFACEDESC *);
    BOOL            (APIENTRY *pfnDrvBindDirectDrawTexture)
        (LPDIRECTDRAWSURFACE);
    DWORD           (APIENTRY *pfnDrvSwapMultipleBuffers)(UINT,
                                                          CONST WGLSWAP *);
    
    // The following functions are only called if driver asks for them.
    // This is required on Win95.
    LONG            (APIENTRY *pfnDrvDescribePixelFormat)(HDC, LONG, ULONG,
                                                      PIXELFORMATDESCRIPTOR *);
    BOOL            (APIENTRY *pfnDrvSetPixelFormat)(HDC, LONG);
    BOOL            (APIENTRY *pfnDrvSwapBuffers)(HDC);

    struct _GLDRIVER    *pGLDriver;            // Next loaded GL driver
    TCHAR tszDllName[MAX_GLDRIVER_NAME+1];     // Null terminated DLL name
} GLDRIVER, *PGLDRIVER;

extern PGLDRIVER APIENTRY pgldrvLoadInstalledDriver(HDC hdc);


/****************************************************************************/

void APIENTRY glDrawRangeElementsWIN( GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

void APIENTRY glAddSwapHintRectWIN(IN GLint, IN GLint, IN GLint, IN GLint);

void glColorTableEXT( GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *data);
void glColorSubTableEXT( GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
void glGetColorTableEXT( GLenum target, GLenum format, GLenum type, GLvoid *data);
void glGetColorTableParameterivEXT( GLenum target, GLenum pname, GLint *params);
void glGetColorTableParameterfvEXT( GLenum target, GLenum pname, GLfloat *params);
void APIENTRY glColorTableParameterivEXT(GLenum target,
                                         GLenum pname,
                                         const GLint *params);
void APIENTRY glColorTableParameterfvEXT(GLenum target,
                                         GLenum pname,
                                         const GLfloat *params);

#ifdef GL_WIN_multiple_textures
void APIENTRY glCurrentTextureIndexWIN
    (GLuint index);
void APIENTRY glMultiTexCoord1dWIN
    (GLbitfield mask, GLdouble s);
void APIENTRY glMultiTexCoord1dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glMultiTexCoord1fWIN
    (GLbitfield mask, GLfloat s);
void APIENTRY glMultiTexCoord1fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glMultiTexCoord1iWIN
    (GLbitfield mask, GLint s);
void APIENTRY glMultiTexCoord1ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glMultiTexCoord1sWIN
    (GLbitfield mask, GLshort s);
void APIENTRY glMultiTexCoord1svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glMultiTexCoord2dWIN
    (GLbitfield mask, GLdouble s, GLdouble t);
void APIENTRY glMultiTexCoord2dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glMultiTexCoord2fWIN
    (GLbitfield mask, GLfloat s, GLfloat t);
void APIENTRY glMultiTexCoord2fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glMultiTexCoord2iWIN
    (GLbitfield mask, GLint s, GLint t);
void APIENTRY glMultiTexCoord2ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glMultiTexCoord2sWIN
    (GLbitfield mask, GLshort s, GLshort t);
void APIENTRY glMultiTexCoord2svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glMultiTexCoord3dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r);
void APIENTRY glMultiTexCoord3dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glMultiTexCoord3fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r);
void APIENTRY glMultiTexCoord3fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glMultiTexCoord3iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r);
void APIENTRY glMultiTexCoord3ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glMultiTexCoord3sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r);
void APIENTRY glMultiTexCoord3svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glMultiTexCoord4dWIN
    (GLbitfield mask, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
void APIENTRY glMultiTexCoord4dvWIN
    (GLbitfield mask, const GLdouble *v);
void APIENTRY glMultiTexCoord4fWIN
    (GLbitfield mask, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
void APIENTRY glMultiTexCoord4fvWIN
    (GLbitfield mask, const GLfloat *v);
void APIENTRY glMultiTexCoord4iWIN
    (GLbitfield mask, GLint s, GLint t, GLint r, GLint q);
void APIENTRY glMultiTexCoord4ivWIN
    (GLbitfield mask, const GLint *v);
void APIENTRY glMultiTexCoord4sWIN
    (GLbitfield mask, GLshort s, GLshort t, GLshort r, GLshort q);
void APIENTRY glMultiTexCoord4svWIN
    (GLbitfield mask, const GLshort *v);
void APIENTRY glBindNthTextureWIN
    (GLuint index, GLenum target, GLuint texture);
void APIENTRY glNthTexCombineFuncWIN
    (GLuint index,
     GLenum leftColorFactor, GLenum colorOp, GLenum rightColorFactor,
     GLenum leftAlphaFactor, GLenum alphaOp, GLenum rightAlphaFactor);
#endif // GL_WIN_multiple_textures

/****************************************************************************/

// Local RC object

#define LRC_IDENTIFIER    0x2043524C    /* 'LRC ' */

typedef struct _LRC {
    DHGLRC    dhrc;             // Driver handle
    HGLRC     hrc;              // Client handle
    int       iPixelFormat;     // Pixel format index
    DWORD     ident;            // LRC_IDENTIFIER
    DWORD     tidCurrent;       // Thread id if the DC is current,
                                //   INVALID_THREAD_ID otherwise
    PGLDRIVER pGLDriver;        // Driver data
    GLWINDOWID gwidCurrent;     // Current surface ID
    GLWINDOWID gwidCreate;      // Creation surface ID

#ifdef GL_METAFILE
    GLuint    uiGlsCaptureContext;  // GLS capturing context for metafile RC's
    GLuint    uiGlsPlaybackContext; // GLS context for playback
    BOOL      fCapturing;       // GLS is in BeginCapture
    
    // GLS playback scaling factors
    int iGlsSubtractX;
    int iGlsSubtractY;
    int iGlsNumeratorX;
    int iGlsNumeratorY;
    int iGlsDenominatorX;
    int iGlsDenominatorY;
    int iGlsAddX;
    int iGlsAddY;
    GLfloat fGlsScaleX;
    GLfloat fGlsScaleY;
#endif

    GLubyte *pszExtensions;

#ifdef GL_METAFILE
    XFORM xformMeta;            // World transform storage during GLS blocks
    LPRECTL prclGlsBounds;      // Bounds during GLS recording
#endif
    
    struct _DDSURFACEDESC *pddsdTexFormats;
    int nDdTexFormats;
} LRC, *PLRC;

// Various dispatch tables available
extern GLCLTPROCTABLE glNullCltProcTable;
extern GLCLTPROCTABLE glCltRGBAProcTable;
extern GLCLTPROCTABLE glCltCIProcTable;
extern GLEXTPROCTABLE glNullExtProcTable;
extern GLEXTPROCTABLE glExtProcTable;
#ifdef GL_METAFILE
extern GLCLTPROCTABLE gcptGlsProcTable;
extern GLEXTPROCTABLE geptGlsExtProcTable;
#endif

// Declare support functions.

ULONG   iAllocHandle(ULONG iType,ULONG hgre,PVOID pv);
VOID    vFreeHandle(ULONG_PTR h);
LONG    cLockHandle(ULONG_PTR h);
VOID    vUnlockHandle(ULONG_PTR h);
VOID    vCleanupAllLRC(VOID);
VOID    vFreeLRC(PLRC plrc);

BOOL    bMakeNoCurrent(void);

VOID GLInitializeThread(ULONG ulReason);

// Macro to call glFlush only if a RC is current.
#define GLFLUSH()          if (GLTEB_CLTCURRENTRC()) glFlush()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\shape\vbwrap.h ===
#ifndef __VBWRAP_H__
#define __VBWRAP_H__

typedef enum _D3DXVERTEXCOMPONENT 
{
    D3DXVC_XYZ, 
    D3DXVC_XYZRHW, 
    D3DXVC_NORMAL,
    D3DXVC_DIFFUSE,
    D3DXVC_SPECULAR,
    D3DXVC_TEX2 
} D3DXVERTEXCOMPONENT;

class CVertexArray
{
public:
    CVertexArray();
    ~CVertexArray();

    void Init( LPDIRECT3D8 pD3D,
               LPDIRECT3DDEVICE8 pD3DDev,
               DWORD dwMaxVertexCount, 
               D3DXVERTEXCOMPONENT*, DWORD dwNumComponents, 
               DWORD dwFlags);

    void Begin();
    void End();

#ifdef __HAVE_DRAWING_MEMBERS
    void Draw(D3DPRIMITIVETYPE, DWORD dwFirstVertexIndex, 
                            DWORD dwNumVertices);
    void DrawIndexed(D3DPRIMITIVETYPE, LPWORD pwIndices, 
                            DWORD dwNumIndices);
#endif //__HAVE_DRAWING_MEMBERS

    void  SetCurrentVertex(DWORD dwIndex);
    DWORD GetCurrentVertexIndex();
    DWORD GetNumVertices();
    void  CopyVertex(DWORD dwSrcIndex, DWORD dwDestIndex);

    void Vertex(float x, float y, float z);
    void Vertex4(float x, float y, float z, float rhw);
    void Normal(float x, float y, float z);
    void Diffuse(DWORD color);
    void Specular(DWORD color);
    void Diffuse( float r, float g, float b );
    void Specular( float r, float g, float b );
    void Diffuse( float r, float g, float b, float a );
    void Specular( float r, float g, float b, float a );

    DWORD GetVertex(float*);
    void  GetNormal(float*);
    DWORD GetDiffuse();
    DWORD GetSpecular();

    void  GetTexture( int index, float*);
    void  GetTexture0(float*);
    void  GetTexture1(float*);
    void  GetTexture2(float*);
    void  GetTexture3(float*);
    void  GetTexture4(float*);
    void  GetTexture5(float*);
    void  GetTexture6(float*);
    void  GetTexture7(float*);

    void Texture2( int index, float, float);
    void Texture0_2(float, float);
    void Texture1_2(float, float);
    void Texture2_2(float, float);
    void Texture3_2(float, float);
    void Texture4_2(float, float);
    void Texture5_2(float, float);
    void Texture6_2(float, float);
    void Texture7_2(float, float);

    LPDIRECT3DVERTEXBUFFER8 m_vb;
protected:
    DWORD   m_FVF;
    DWORD   m_dwGrowSize;
    DWORD   m_dwMaxNumVertices;
    LPBYTE  m_pVertices;
    LPBYTE  m_pCurrentVertex;
    DWORD   m_dwVertexSize;
    DWORD   m_dwCurrentVertexIndex;
    DWORD   m_dwNormalOffset;
    DWORD   m_dwDiffuseOffset;
    DWORD   m_dwSpecularOffset;
    DWORD   m_dwNumTexCoord;
    DWORD   m_dwTextureOffset[8];
    BYTE    m_TextureSize[8];
    D3DVERTEXBUFFER_DESC m_vbDesc;

    LPDIRECT3D8 m_pD3D;
    LPDIRECT3DDEVICE8 m_pDevice;
};

#endif //__VBWRAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\shape\vbwrap.cpp ===
#include "pchshape.h"

CVertexArray::CVertexArray()
{
    m_vb = NULL;
    memset(&m_vbDesc, 0, sizeof(D3DVERTEXBUFFER_DESC));
    m_dwGrowSize = 128;     // Number of vertices to grow

    m_pDevice = NULL;
}

CVertexArray::~CVertexArray()
{
    if( m_pDevice )
        m_pDevice->Release();

    if( m_pD3D )
        m_pD3D->Release();

    if (m_vb)
        m_vb->Release();
}

void
CVertexArray::Init( LPDIRECT3D8 pD3D,
                    LPDIRECT3DDEVICE8 pD3DDev,
                    DWORD dwMaxVertexCount,
                    D3DXVERTEXCOMPONENT* pComponent, DWORD dwNumComponents,
                    DWORD dwFlags )
{
    HRESULT hr = S_OK;
    m_pDevice = pD3DDev;
    if( m_pDevice == NULL )
    {
        hr = D3DERR_INVALIDCALL;
        throw CD3DXException( hr,
                             "CVertexArray::Init - m_pDevice is NULL",
                             __LINE__);
    }
    m_pDevice->AddRef();

    if(pD3D)
    {
        m_pD3D = pD3D;
        m_pD3D->AddRef();
    }
    else if(pD3DDev)
    {
        if(FAILED(hr = pD3DDev->GetDirect3D(&m_pD3D)))
        {
            throw CD3DXException( hr,
                                 "CVertexArray::Init - Could not get D3D from device",
                                 __LINE__);
        }
    }
    else
    {
        //hr = D3DERR_INVALIDCALL;
        hr = D3DERR_INVALIDCALL;
        throw CD3DXException( hr,
                             "CVertexArray::Init - pD3D is NULL",
                             __LINE__);
    }

    m_dwMaxNumVertices = dwMaxVertexCount;
    m_dwNumTexCoord = 0;
    m_dwVertexSize = 0;
    memset(m_TextureSize, 0, sizeof(m_TextureSize));
    m_FVF = 0;
    for (DWORD i=0; i < dwNumComponents; i++)
    {
        switch (*pComponent++)
        {
        case D3DXVC_XYZ  :
            m_FVF |= D3DFVF_XYZ;
            m_dwVertexSize += 3*sizeof(D3DVALUE);
            break;
        case D3DXVC_XYZRHW  :
            m_FVF |= D3DFVF_XYZRHW;
            m_dwVertexSize += 4*sizeof(D3DVALUE);
            break;
        case D3DXVC_NORMAL:
            m_FVF |= D3DFVF_NORMAL;
            m_dwVertexSize += 3*sizeof(D3DVALUE);
            break;
        case D3DXVC_DIFFUSE:
            m_FVF |= D3DFVF_DIFFUSE;
            m_dwVertexSize += sizeof(DWORD);
            break;
        case D3DXVC_SPECULAR:
            m_FVF |= D3DFVF_SPECULAR;
            m_dwVertexSize += sizeof(DWORD);
            break;
        case D3DXVC_TEX2:
            m_TextureSize[m_dwNumTexCoord] = 2*sizeof(D3DVALUE);
            m_dwNumTexCoord++;
            m_dwVertexSize += 2*sizeof(D3DVALUE);
            break;
#ifdef __DX7_TEXTURES
        case D3DXVC_TEX1:
            m_TextureSize[m_dwNumTexCoord] = sizeof(D3DVALUE);
            m_dwNumTexCoord++;
            m_dwVertexSize += sizeof(D3DVALUE);
            break;
        case D3DXVC_TEX3:
            m_TextureSize[m_dwNumTexCoord] = 3*sizeof(D3DVALUE);
            m_dwNumTexCoord++;
            m_dwVertexSize += 3*sizeof(D3DVALUE);
            break;
        case D3DXVC_TEX4:
            m_TextureSize[m_dwNumTexCoord] = 4*sizeof(D3DVALUE);
            m_dwNumTexCoord++;
            m_dwVertexSize += 4*sizeof(D3DVALUE);
            break;
#endif //__DX7_TEXTURES
        default:
            throw CD3DXException( hr,
                                 "CVertexArray::Init - "\
                                 "invalid vtx component",
                                 __LINE__);
        }
    }

    m_FVF |= m_dwNumTexCoord << 8;

    DWORD dwOffset;
    if (m_FVF & D3DFVF_XYZ)
        dwOffset = 3*sizeof(D3DVALUE);
    else
        dwOffset = 4*sizeof(D3DVALUE);
    if (m_FVF & D3DFVF_NORMAL)
    {
        m_dwNormalOffset = dwOffset;
        dwOffset += 3*sizeof(D3DVALUE);
    }

    if (m_FVF & D3DFVF_DIFFUSE)
    {
        m_dwDiffuseOffset = dwOffset;
        dwOffset += sizeof(DWORD);
    }

    if (m_FVF & D3DFVF_SPECULAR)
    {
        m_dwSpecularOffset = dwOffset;
        dwOffset += sizeof(DWORD);
    }

    for (DWORD j=0; j < m_dwNumTexCoord; j++)
    {
        if (m_TextureSize[j] == 0)
            m_TextureSize[j] = 2*sizeof(D3DVALUE);
        m_dwTextureOffset[j] = dwOffset;
        dwOffset += m_TextureSize[j];
    }

    // need to create a vertex buffer
    hr = m_pDevice->CreateVertexBuffer(m_dwMaxNumVertices * dwOffset, D3DUSAGE_SOFTWAREPROCESSING, m_FVF, D3DPOOL_DEFAULT, &m_vb);
    if( FAILED( hr ) )
    {
        throw CD3DXException( hr,
                             "CVertexArray::Init - error creating VB",
                             __LINE__);
    }
}

void
CVertexArray::SetCurrentVertex( DWORD dwIndex )
{
    m_dwCurrentVertexIndex = dwIndex;

    DWORD dwVertexOffset = dwIndex * m_dwVertexSize;
    if (m_dwCurrentVertexIndex > m_dwMaxNumVertices)
    {
        throw CD3DXException(E_FAIL, "CVertexArray::SetCurrentVertex - Tried adding too many vertices",
                            __LINE__);
    }
}

void
CVertexArray::Begin()
{
    m_dwCurrentVertexIndex = 0;
    if (m_vb)
    {
        HRESULT hr = m_vb->Lock(0,0, &m_pVertices, D3DLOCK_NOSYSLOCK);
        if( FAILED( hr ) )
            throw CD3DXException(hr, "CVertexArray::Begin - error in Lock",
                                __LINE__);
        m_pCurrentVertex = m_pVertices;
    }
}

void
CVertexArray::End()
{
    m_vb->Unlock();
}

void
CVertexArray::Vertex(D3DVALUE x, D3DVALUE y, D3DVALUE z)
{
    if (!(m_FVF & D3DFVF_XYZ))
    {
        throw CD3DXException( D3DERR_INVALIDCALL,
                             "CVertexArray::Vertex - invalid vertex type",
                             __LINE__);
    }

    if (m_dwCurrentVertexIndex > m_dwMaxNumVertices)
    {
        throw CD3DXException(E_FAIL, "CVertexArray::SetCurrentVertex - Tried adding too many vertices",
                            __LINE__);
    }

    ((D3DVALUE*)m_pCurrentVertex)[0] = x;
    ((D3DVALUE*)m_pCurrentVertex)[1] = y;
    ((D3DVALUE*)m_pCurrentVertex)[2] = z;

    m_dwCurrentVertexIndex++;
    m_pCurrentVertex += m_dwVertexSize;
}

void
CVertexArray::Vertex4(D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE rhw)
{
    if (!(m_FVF & D3DFVF_XYZRHW))
    {
        throw CD3DXException(D3DERR_INVALIDCALL, "CVertexArray::Vertex - "\
                                        "Invalid vertex type", __LINE__);
    }

    if (m_dwCurrentVertexIndex > m_dwMaxNumVertices)
    {
        throw CD3DXException(E_FAIL, "CVertexArray::SetCurrentVertex - Tried adding too many vertices",
                            __LINE__);
    }

    ((D3DVALUE*)m_pCurrentVertex)[0] = x;
    ((D3DVALUE*)m_pCurrentVertex)[1] = y;
    ((D3DVALUE*)m_pCurrentVertex)[2] = z;
    ((D3DVALUE*)m_pCurrentVertex)[3] = rhw;

    m_dwCurrentVertexIndex++;
    m_pCurrentVertex += m_dwVertexSize;
}

void
CVertexArray::Normal(D3DVALUE x, D3DVALUE y, D3DVALUE z)
{
    if (!(m_FVF & D3DFVF_NORMAL))
    {
        throw CD3DXException(D3DERR_INVALIDCALL, "CVertexArray::Normal - "\
                                        "Normal is not allowed", __LINE__);
    }

    *(D3DVALUE*)&m_pCurrentVertex[m_dwNormalOffset] = x;
    *(D3DVALUE*)&m_pCurrentVertex[m_dwNormalOffset+sizeof(D3DVALUE)] = y;
    *(D3DVALUE*)&m_pCurrentVertex[m_dwNormalOffset+2*sizeof(D3DVALUE)] = z;
}

void
CVertexArray::Diffuse(DWORD color)
{
    if (!(m_FVF & D3DFVF_DIFFUSE))
    {
        throw CD3DXException(D3DERR_INVALIDCALL, "CVertexArray::Diffuse - "\
                                        "Diffuse is not allowed", __LINE__);
    }

    *(DWORD*)&m_pCurrentVertex[m_dwDiffuseOffset] = color;
}

void
CVertexArray::Specular(DWORD color)
{
    if (!(m_FVF & D3DFVF_SPECULAR))
    {
        throw CD3DXException(D3DERR_INVALIDCALL, "CVertexArray::Specular - "\
                                        "Specular is not allowed", __LINE__);
    }

    *(DWORD*)&m_pCurrentVertex[m_dwSpecularOffset] = color;
}


void
CVertexArray::Texture2( int index, float s, float t)
{
    switch( index )
    {
    case 0:
        Texture0_2(s, t);
        return;
    case 1:
        Texture1_2(s, t);
        return;
    case 2:
        Texture2_2(s, t);
        return;
    case 3:
        Texture3_2(s, t);
        return;
    case 4:
        Texture4_2(s, t);
        return;
    case 5:
        Texture5_2(s, t);
        return;
    case 6:
        Texture6_2(s, t);
        return;
    case 7:
        Texture7_2(s, t);
        return;
    default:
        throw CD3DXException( D3DERR_INVALIDCALL,
                             "CVertexArray::Texture2 - bad tex-coord index",
                             __LINE__);
    }
}


#define TEXTURE1(Name, TextureIndex)                            \
void CVertexArray::Name(D3DVALUE v)                             \
{                                                               \
    if (m_TextureSize[TextureIndex] != sizeof(D3DVALUE))    \
    {                                                       \
        throw CD3DXException(D3DERR_INVALIDCALL,            \
                            "CVertexArray::Name - invalid texture size", \
                             __LINE__);                     \
    }                                                       \
    ((D3DVALUE*)&m_pCurrentVertex[m_dwTextureOffset[TextureIndex]])[0] = v; \
                                                                \
}

#define TEXTURE2(Name, TextureIndex)                            \
void CVertexArray::Name(D3DVALUE v1, D3DVALUE v2)               \
{                                                               \
    if (m_TextureSize[TextureIndex] != 2*sizeof(D3DVALUE))  \
    {                                                       \
        throw CD3DXException(D3DERR_INVALIDCALL,            \
                            "CVertexArray::Name - invalid texture size", \
                             __LINE__);                     \
    }                                                       \
    ((D3DVALUE*)&m_pCurrentVertex[m_dwTextureOffset[TextureIndex]])[0] = v1; \
    ((D3DVALUE*)&m_pCurrentVertex[m_dwTextureOffset[TextureIndex]])[1] = v2; \
}

#define TEXTURE3(Name, TextureIndex)                            \
void CVertexArray::Name(D3DVALUE v1, D3DVALUE v2, D3DVALUE v3)  \
{                                                               \
    if (m_TextureSize[TextureIndex] != 3*sizeof(D3DVALUE))  \
    {                                                       \
        throw CD3DXException(D3DERR_INVALIDCALL,            \
                            "CVertexArray::Name - invalid texture size", \
                             __LINE__);                     \
    }                                                       \
    ((D3DVALUE*)&m_pCurrentVertex[m_dwTextureOffset[TextureIndex]])[0] = v1; \
    ((D3DVALUE*)&m_pCurrentVertex[m_dwTextureOffset[TextureIndex]])[1] = v2; \
    ((D3DVALUE*)&m_pCurrentVertex[m_dwTextureOffset[TextureIndex]])[2] = v3; \
}

#define TEXTURE4(Name, TextureIndex)                            \
void CVertexArray::Name(D3DVALUE v1, D3DVALUE v2, D3DVALUE v3, D3DVALUE v4) \
{                                                               \
    if (m_TextureSize[TextureIndex] != 4*sizeof(D3DVALUE))  \
    {                                                       \
        throw CD3DXException(D3DERR_INVALIDCALL,            \
                            "CVertexArray::Name - invalid texture size", \
                             __LINE__);                     \
    }                                                       \
    ((D3DVALUE*)&m_pCurrentVertex[m_dwTextureOffset[TextureIndex]])[0] = v1; \
    ((D3DVALUE*)&m_pCurrentVertex[m_dwTextureOffset[TextureIndex]])[1] = v2; \
    ((D3DVALUE*)&m_pCurrentVertex[m_dwTextureOffset[TextureIndex]])[2] = v3; \
    ((D3DVALUE*)&m_pCurrentVertex[m_dwTextureOffset[TextureIndex]])[3] = v4; \
}


TEXTURE2(Texture0_2, 0)
TEXTURE2(Texture1_2, 1)
TEXTURE2(Texture2_2, 2)
TEXTURE2(Texture3_2, 3)
TEXTURE2(Texture4_2, 4)
TEXTURE2(Texture5_2, 5)
TEXTURE2(Texture6_2, 6)
TEXTURE2(Texture7_2, 7)

#ifdef __DX7_TEXTURES
TEXTURE1(Texture0_1, 0)
TEXTURE1(Texture1_1, 1)
TEXTURE1(Texture2_1, 2)
TEXTURE1(Texture3_1, 3)
TEXTURE1(Texture4_1, 4)
TEXTURE1(Texture5_1, 5)
TEXTURE1(Texture6_1, 6)
TEXTURE1(Texture7_1, 7)

TEXTURE3(Texture0_3, 0)
TEXTURE3(Texture1_3, 1)
TEXTURE3(Texture2_3, 2)
TEXTURE3(Texture3_3, 3)
TEXTURE3(Texture4_3, 4)
TEXTURE3(Texture5_3, 5)
TEXTURE3(Texture6_3, 6)
TEXTURE3(Texture7_3, 7)

TEXTURE4(Texture0_4, 0)
TEXTURE4(Texture1_4, 1)
TEXTURE4(Texture2_4, 2)
TEXTURE4(Texture3_4, 3)
TEXTURE4(Texture4_4, 4)
TEXTURE4(Texture5_4, 5)
TEXTURE4(Texture6_4, 6)
TEXTURE4(Texture7_4, 7)
#endif //__DX7_TEXTURES

#ifdef __HAVE_DRAWING_MEMBERS
void CVertexArray::Draw(D3DPRIMITIVETYPE  primType,
                        DWORD dwFirstVertexIndex, DWORD dwNumVertices)
{
    HRESULT hr = S_OK;

    m_vb->Unlock();
    hr = m_pDevice->DrawPrimitiveVB(primType, m_vb, dwFirstVertexIndex,
                                    dwNumVertices, 0);
    if ( hr != D3D_OK)
    {
        throw CD3DXException( hr, "CVertexArrayIM::Draw", __LINE__);
    }
    hr = m_vb->Lock(DDLOCK_WAIT, (LPVOID*)&m_pVertices, 0);
    if ( hr != D3D_OK)
        throw CD3DXException( hr, "CVertexArray::Vertex - error in Lock",
                            __LINE__);
    m_pCurrentVertex = m_pVertices;
}

void CVertexArray::DrawIndexed(D3DPRIMITIVETYPE primType,
                               WORD * pwIndices,
                               DWORD dwNumIndices)
{
    HRESULT hr = S_OK;

    m_vb->Unlock();
     hr = m_pDevice->DrawIndexedPrimitiveVB(primType,
                                            m_vb,
                                            0,
                                            m_dwMaxNumVertices,
                                            pwIndices,
                                            dwNumIndices,
                                            0);
    if ( hr != D3D_OK)
    {
        throw CD3DXException( hr, "CVertexArrayIM::Draw", __LINE__);
    }
    hr = m_vb->Lock(DDLOCK_WAIT, (LPVOID*)&m_pVertices, 0);
    if ( hr != D3D_OK)
        throw CD3DXException( hr, "CVertexArray::Vertex - "\
                                  "Error in Lock", __LINE__);
    m_pCurrentVertex = m_pVertices;
}
#endif //__HAVE_DRAWING_MEMBERS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\shape\teapot.cpp ===
// TEAPOT.CPP
// Static vertex data for teapot object

// Disable "Truncating double to float" warning
#pragma warning(disable : 4305)

#define NUMTEAPOTVERTICES 1178
#define NUMTEAPOTINDICES 6768

static float teapotPositionsFloats[NUMTEAPOTVERTICES*3] = 
{
    0.678873, 0.330678, 0.000000,
    0.669556, 0.358022, 0.000000,
    0.671003, 0.374428, 0.000000,
    0.680435, 0.379897, 0.000000,
    0.695077, 0.374428, 0.000000,
    0.712148, 0.358022, 0.000000,
    0.728873, 0.330678, 0.000000,
    0.654243, 0.330678, 0.187963,
    0.645254, 0.358022, 0.185461,
    0.646650, 0.374428, 0.185850,
    0.655751, 0.379897, 0.188383,
    0.669877, 0.374428, 0.192314,
    0.686348, 0.358022, 0.196898,
    0.702484, 0.330678, 0.201389,
    0.584502, 0.330678, 0.355704,
    0.576441, 0.358022, 0.350969,
    0.577693, 0.374428, 0.351704,
    0.585854, 0.379897, 0.356498,
    0.598522, 0.374428, 0.363938,
    0.613292, 0.358022, 0.372613,
    0.627762, 0.330678, 0.381111,
    0.475873, 0.330678, 0.497000,
    0.469258, 0.358022, 0.490385,
    0.470285, 0.374428, 0.491412,
    0.476982, 0.379897, 0.498109,
    0.487377, 0.374428, 0.508505,
    0.499498, 0.358022, 0.520626,
    0.511373, 0.330678, 0.532500,
    0.334576, 0.330678, 0.605630,
    0.329842, 0.358022, 0.597569,
    0.330577, 0.374428, 0.598820,
    0.335370, 0.379897, 0.606982,
    0.342810, 0.374428, 0.619649,
    0.351485, 0.358022, 0.634419,
    0.359984, 0.330678, 0.648889,
    0.166836, 0.330678, 0.675370,
    0.164334, 0.358022, 0.666381,
    0.164722, 0.374428, 0.667777,
    0.167255, 0.379897, 0.676878,
    0.171187, 0.374428, 0.691004,
    0.175771, 0.358022, 0.707475,
    0.180262, 0.330678, 0.723611,
    -0.021127, 0.330678, 0.700000,
    -0.021127, 0.358022, 0.690683,
    -0.021127, 0.374428, 0.692130,
    -0.021127, 0.379897, 0.701563,
    -0.021127, 0.374428, 0.716204,
    -0.021127, 0.358022, 0.733276,
    -0.021127, 0.330678, 0.750000,
    -0.224715, 0.330678, 0.675370,
    -0.215631, 0.358022, 0.666381,
    -0.211606, 0.374428, 0.667777,
    -0.211463, 0.379897, 0.676878,
    -0.214020, 0.374428, 0.691004,
    -0.218098, 0.358022, 0.707475,
    -0.222516, 0.330678, 0.723611,
    -0.396831, 0.330678, 0.605630,
    -0.383671, 0.358022, 0.597569,
    -0.378758, 0.374428, 0.598820,
    -0.380125, 0.379897, 0.606982,
    -0.385806, 0.374428, 0.619649,
    -0.393832, 0.358022, 0.634419,
    -0.402238, 0.330678, 0.648889,
    -0.535002, 0.330678, 0.497000,
    -0.521278, 0.358022, 0.490385,
    -0.517539, 0.374428, 0.491412,
    -0.521346, 0.379897, 0.498109,
    -0.530257, 0.374428, 0.508505,
    -0.541831, 0.358022, 0.520626,
    -0.553627, 0.330678, 0.532500,
    -0.636757, 0.330678, 0.355704,
    -0.624483, 0.358022, 0.350969,
    -0.622910, 0.374428, 0.351704,
    -0.629359, 0.379897, 0.356498,
    -0.641146, 0.374428, 0.363938,
    -0.655593, 0.358022, 0.372613,
    -0.670016, 0.330678, 0.381111,
    -0.699623, 0.330678, 0.187963,
    -0.689317, 0.358022, 0.185461,
    -0.689830, 0.374428, 0.185850,
    -0.698396, 0.379897, 0.188382,
    -0.712247, 0.374428, 0.192314,
    -0.728617, 0.358022, 0.196898,
    -0.744738, 0.330678, 0.201389,
    -0.721127, 0.330678, 0.000000,
    -0.711810, 0.358022, 0.000000,
    -0.713257, 0.374428, 0.000000,
    -0.722690, 0.379897, 0.000000,
    -0.737331, 0.374428, 0.000000,
    -0.754403, 0.358022, 0.000000,
    -0.771127, 0.330678, 0.000000,
    -0.696498, 0.330678, -0.187963,
    -0.687508, 0.358022, -0.185461,
    -0.688904, 0.374428, -0.185850,
    -0.698005, 0.379897, -0.188383,
    -0.712131, 0.374428, -0.192314,
    -0.728602, 0.358022, -0.196898,
    -0.744738, 0.330678, -0.201389,
    -0.626757, 0.330678, -0.355704,
    -0.618696, 0.358022, -0.350969,
    -0.619948, 0.374428, -0.351704,
    -0.628109, 0.379897, -0.356498,
    -0.640776, 0.374428, -0.363938,
    -0.655546, 0.358022, -0.372613,
    -0.670016, 0.330678, -0.381111,
    -0.518127, 0.330678, -0.497000,
    -0.511512, 0.358022, -0.490385,
    -0.512539, 0.374428, -0.491412,
    -0.519237, 0.379897, -0.498109,
    -0.529632, 0.374428, -0.508505,
    -0.541753, 0.358022, -0.520626,
    -0.553627, 0.330678, -0.532500,
    -0.376831, 0.330678, -0.605630,
    -0.372096, 0.358022, -0.597569,
    -0.372832, 0.374428, -0.598820,
    -0.377625, 0.379897, -0.606982,
    -0.385065, 0.374428, -0.619649,
    -0.393740, 0.358022, -0.634419,
    -0.402238, 0.330678, -0.648889,
    -0.209090, 0.330678, -0.675370,
    -0.206588, 0.358022, -0.666381,
    -0.206977, 0.374428, -0.667777,
    -0.209510, 0.379897, -0.676878,
    -0.213441, 0.374428, -0.691004,
    -0.218025, 0.358022, -0.707475,
    -0.222516, 0.330678, -0.723611,
    -0.021127, 0.330678, -0.700000,
    -0.021127, 0.358022, -0.690683,
    -0.021127, 0.374428, -0.692130,
    -0.021127, 0.379897, -0.701563,
    -0.021127, 0.374428, -0.716204,
    -0.021127, 0.358022, -0.733276,
    -0.021127, 0.330678, -0.750000,
    0.166836, 0.330678, -0.675370,
    0.164334, 0.358022, -0.666381,
    0.164722, 0.374428, -0.667777,
    0.167255, 0.379897, -0.676878,
    0.171187, 0.374428, -0.691004,
    0.175771, 0.358022, -0.707475,
    0.180262, 0.330678, -0.723611,
    0.334576, 0.330678, -0.605630,
    0.329842, 0.358022, -0.597569,
    0.330577, 0.374428, -0.598820,
    0.335370, 0.379897, -0.606982,
    0.342810, 0.374428, -0.619649,
    0.351485, 0.358022, -0.634419,
    0.359984, 0.330678, -0.648889,
    0.475873, 0.330678, -0.497000,
    0.469258, 0.358022, -0.490385,
    0.470285, 0.374428, -0.491412,
    0.476982, 0.379897, -0.498109,
    0.487377, 0.374428, -0.508505,
    0.499498, 0.358022, -0.520626,
    0.511373, 0.330678, -0.532500,
    0.584502, 0.330678, -0.355704,
    0.576441, 0.358022, -0.350969,
    0.577693, 0.374428, -0.351704,
    0.585854, 0.379897, -0.356498,
    0.598522, 0.374428, -0.363938,
    0.613292, 0.358022, -0.372613,
    0.627762, 0.330678, -0.381111,
    0.654243, 0.330678, -0.187963,
    0.645254, 0.358022, -0.185461,
    0.646650, 0.374428, -0.185850,
    0.655751, 0.379897, -0.188382,
    0.669877, 0.374428, -0.192314,
    0.686348, 0.358022, -0.196898,
    0.702484, 0.330678, -0.201389,
    0.790794, 0.199602, 0.000000,
    0.849243, 0.069567, 0.000000,
    0.900748, -0.058384, 0.000000,
    0.941836, -0.183211, 0.000000,
    0.969035, -0.303870, 0.000000,
    0.978873, -0.419322, 0.000000,
    0.762227, 0.199602, 0.218016,
    0.818619, 0.069567, 0.233711,
    0.868312, -0.058384, 0.247541,
    0.907954, -0.183211, 0.258573,
    0.934196, -0.303870, 0.265877,
    0.943688, -0.419322, 0.268519,
    0.681335, 0.199602, 0.412576,
    0.731904, 0.069567, 0.442277,
    0.776465, -0.058384, 0.468449,
    0.812014, -0.183211, 0.489328,
    0.835546, -0.303870, 0.503149,
    0.844058, -0.419322, 0.508148,
    0.555337, 0.199602, 0.576464,
    0.596836, 0.069567, 0.617963,
    0.633404, -0.058384, 0.654531,
    0.662577, -0.183211, 0.683704,
    0.681888, -0.303870, 0.703015,
    0.688873, -0.419322, 0.710000,
    0.391449, 0.199602, 0.702462,
    0.421150, 0.069567, 0.753032,
    0.447322, -0.058384, 0.797593,
    0.468201, -0.183211, 0.833141,
    0.482022, -0.303870, 0.856674,
    0.487021, -0.419322, 0.865185,
    0.196889, 0.199602, 0.783354,
    0.212583, 0.069567, 0.839746,
    0.226413, -0.058384, 0.889439,
    0.237446, -0.183211, 0.929081,
    0.244750, -0.303870, 0.955323,
    0.247391, -0.419322, 0.964815,
    -0.021127, 0.199602, 0.811921,
    -0.021127, 0.069567, 0.870370,
    -0.021127, -0.058384, 0.921875,
    -0.021127, -0.183211, 0.962963,
    -0.021127, -0.303870, 0.990162,
    -0.021127, -0.419322, 1.000000,
    -0.239143, 0.199602, 0.783354,
    -0.254838, 0.069567, 0.839746,
    -0.268668, -0.058384, 0.889439,
    -0.279701, -0.183211, 0.929081,
    -0.287004, -0.303870, 0.955323,
    -0.289646, -0.419322, 0.964815,
    -0.433704, 0.199602, 0.702462,
    -0.463404, 0.069567, 0.753032,
    -0.489576, -0.058384, 0.797593,
    -0.510455, -0.183211, 0.833141,
    -0.524276, -0.303870, 0.856674,
    -0.529275, -0.419322, 0.865185,
    -0.597591, 0.199602, 0.576464,
    -0.639090, 0.069567, 0.617963,
    -0.675658, -0.058384, 0.654531,
    -0.704831, -0.183211, 0.683704,
    -0.724142, -0.303870, 0.703015,
    -0.731127, -0.419322, 0.710000,
    -0.723589, 0.199602, 0.412576,
    -0.774159, 0.069567, 0.442277,
    -0.818720, -0.058384, 0.468449,
    -0.854269, -0.183211, 0.489328,
    -0.877801, -0.303870, 0.503149,
    -0.886312, -0.419322, 0.508148,
    -0.804481, 0.199602, 0.218016,
    -0.860873, 0.069567, 0.233711,
    -0.910566, -0.058384, 0.247540,
    -0.950208, -0.183211, 0.258573,
    -0.976450, -0.303870, 0.265877,
    -0.985942, -0.419322, 0.268518,
    -0.833049, 0.199602, 0.000000,
    -0.891498, 0.069567, 0.000000,
    -0.943002, -0.058384, 0.000000,
    -0.984090, -0.183211, 0.000000,
    -1.011289, -0.303870, 0.000000,
    -1.021127, -0.419322, 0.000000,
    -0.804481, 0.199602, -0.218016,
    -0.860873, 0.069567, -0.233711,
    -0.910566, -0.058384, -0.247541,
    -0.950208, -0.183211, -0.258573,
    -0.976450, -0.303870, -0.265877,
    -0.985942, -0.419322, -0.268519,
    -0.723589, 0.199602, -0.412576,
    -0.774159, 0.069567, -0.442277,
    -0.818720, -0.058384, -0.468449,
    -0.854269, -0.183211, -0.489328,
    -0.877801, -0.303870, -0.503149,
    -0.886312, -0.419322, -0.508148,
    -0.597591, 0.199602, -0.576464,
    -0.639090, 0.069567, -0.617963,
    -0.675658, -0.058384, -0.654531,
    -0.704831, -0.183211, -0.683704,
    -0.724142, -0.303870, -0.703015,
    -0.731127, -0.419322, -0.710000,
    -0.433704, 0.199602, -0.702462,
    -0.463404, 0.069567, -0.753032,
    -0.489576, -0.058384, -0.797593,
    -0.510455, -0.183211, -0.833141,
    -0.524276, -0.303870, -0.856674,
    -0.529275, -0.419322, -0.865185,
    -0.239143, 0.199602, -0.783354,
    -0.254838, 0.069567, -0.839746,
    -0.268668, -0.058384, -0.889439,
    -0.279701, -0.183211, -0.929081,
    -0.287004, -0.303870, -0.955323,
    -0.289646, -0.419322, -0.964815,
    -0.021127, 0.199602, -0.811921,
    -0.021127, 0.069567, -0.870370,
    -0.021127, -0.058384, -0.921875,
    -0.021127, -0.183211, -0.962963,
    -0.021127, -0.303870, -0.990162,
    -0.021127, -0.419322, -1.000000,
    0.196889, 0.199602, -0.783354,
    0.212583, 0.069567, -0.839746,
    0.226413, -0.058384, -0.889439,
    0.237446, -0.183211, -0.929081,
    0.244750, -0.303870, -0.955323,
    0.247391, -0.419322, -0.964815,
    0.391449, 0.199602, -0.702462,
    0.421150, 0.069567, -0.753032,
    0.447322, -0.058384, -0.797593,
    0.468201, -0.183211, -0.833141,
    0.482022, -0.303870, -0.856674,
    0.487021, -0.419322, -0.865185,
    0.555337, 0.199602, -0.576464,
    0.596836, 0.069567, -0.617963,
    0.633404, -0.058384, -0.654531,
    0.662577, -0.183211, -0.683704,
    0.681888, -0.303870, -0.703015,
    0.688873, -0.419322, -0.710000,
    0.681335, 0.199602, -0.412576,
    0.731904, 0.069567, -0.442277,
    0.776465, -0.058384, -0.468449,
    0.812014, -0.183211, -0.489328,
    0.835546, -0.303870, -0.503149,
    0.844058, -0.419322, -0.508148,
    0.762227, 0.199602, -0.218016,
    0.818619, 0.069567, -0.233711,
    0.868312, -0.058384, -0.247540,
    0.907954, -0.183211, -0.258573,
    0.934196, -0.303870, -0.265877,
    0.943688, -0.419322, -0.268518,
    0.960354, -0.522620, 0.000000,
    0.914058, -0.608211, 0.000000,
    0.853873, -0.677134, 0.000000,
    0.793688, -0.730433, 0.000000,
    0.747391, -0.769148, 0.000000,
    0.728873, -0.794322, 0.000000,
    0.925821, -0.522620, 0.263546,
    0.881153, -0.608211, 0.251115,
    0.823086, -0.677134, 0.234954,
    0.765018, -0.730433, 0.218793,
    0.720351, -0.769148, 0.206361,
    0.702484, -0.794322, 0.201389,
    0.828036, -0.522620, 0.498738,
    0.787981, -0.608211, 0.475213,
    0.735910, -0.677134, 0.444630,
    0.683839, -0.730433, 0.414047,
    0.643784, -0.769148, 0.390521,
    0.627762, -0.794322, 0.381111,
    0.675725, -0.522620, 0.696852,
    0.642854, -0.608211, 0.663981,
    0.600123, -0.677134, 0.621250,
    0.557391, -0.730433, 0.578519,
    0.524521, -0.769148, 0.545648,
    0.511373, -0.794322, 0.532500,
    0.477611, -0.522620, 0.849163,
    0.454085, -0.608211, 0.809108,
    0.423502, -0.677134, 0.757037,
    0.392919, -0.730433, 0.704966,
    0.369394, -0.769148, 0.664911,
    0.359984, -0.794322, 0.648889,
    0.242419, -0.522620, 0.946948,
    0.229987, -0.608211, 0.902281,
    0.213826, -0.677134, 0.844213,
    0.197666, -0.730433, 0.786145,
    0.185234, -0.769148, 0.741478,
    0.180262, -0.794322, 0.723611,
    -0.021127, -0.522620, 0.981482,
    -0.021127, -0.608211, 0.935185,
    -0.021127, -0.677134, 0.875000,
    -0.021127, -0.730433, 0.814815,
    -0.021127, -0.769148, 0.768519,
    -0.021127, -0.794322, 0.750000,
    -0.284673, -0.522620, 0.946948,
    -0.272242, -0.608211, 0.902281,
    -0.256081, -0.677134, 0.844213,
    -0.239920, -0.730433, 0.786145,
    -0.227489, -0.769148, 0.741478,
    -0.222516, -0.794322, 0.723611,
    -0.519865, -0.522620, 0.849163,
    -0.496340, -0.608211, 0.809108,
    -0.465757, -0.677134, 0.757037,
    -0.435174, -0.730433, 0.704966,
    -0.411649, -0.769148, 0.664911,
    -0.402238, -0.794322, 0.648889,
    -0.717979, -0.522620, 0.696852,
    -0.685109, -0.608211, 0.663981,
    -0.642377, -0.677134, 0.621250,
    -0.599646, -0.730433, 0.578519,
    -0.566775, -0.769148, 0.545648,
    -0.553627, -0.794322, 0.532500,
    -0.870290, -0.522620, 0.498738,
    -0.830236, -0.608211, 0.475213,
    -0.778164, -0.677134, 0.444630,
    -0.726093, -0.730433, 0.414047,
    -0.686038, -0.769148, 0.390521,
    -0.670016, -0.794322, 0.381111,
    -0.968075, -0.522620, 0.263546,
    -0.923408, -0.608211, 0.251115,
    -0.865340, -0.677134, 0.234954,
    -0.807273, -0.730433, 0.218793,
    -0.762605, -0.769148, 0.206361,
    -0.744738, -0.794322, 0.201389,
    -1.002609, -0.522620, 0.000000,
    -0.956312, -0.608211, 0.000000,
    -0.896127, -0.677134, 0.000000,
    -0.835942, -0.730433, 0.000000,
    -0.789646, -0.769148, 0.000000,
    -0.771127, -0.794322, 0.000000,
    -0.968075, -0.522620, -0.263546,
    -0.923408, -0.608211, -0.251115,
    -0.865340, -0.677134, -0.234954,
    -0.807273, -0.730433, -0.218793,
    -0.762605, -0.769148, -0.206361,
    -0.744738, -0.794322, -0.201389,
    -0.870290, -0.522620, -0.498738,
    -0.830236, -0.608211, -0.475213,
    -0.778164, -0.677134, -0.444630,
    -0.726093, -0.730433, -0.414047,
    -0.686038, -0.769148, -0.390521,
    -0.670016, -0.794322, -0.381111,
    -0.717979, -0.522620, -0.696852,
    -0.685109, -0.608211, -0.663981,
    -0.642377, -0.677134, -0.621250,
    -0.599646, -0.730433, -0.578519,
    -0.566775, -0.769148, -0.545648,
    -0.553627, -0.794322, -0.532500,
    -0.519865, -0.522620, -0.849163,
    -0.496340, -0.608211, -0.809108,
    -0.465757, -0.677134, -0.757037,
    -0.435174, -0.730433, -0.704966,
    -0.411648, -0.769148, -0.664911,
    -0.402238, -0.794322, -0.648889,
    -0.284673, -0.522620, -0.946948,
    -0.272242, -0.608211, -0.902281,
    -0.256081, -0.677134, -0.844213,
    -0.239920, -0.730433, -0.786145,
    -0.227489, -0.769148, -0.741478,
    -0.222516, -0.794322, -0.723611,
    -0.021127, -0.522620, -0.981482,
    -0.021127, -0.608211, -0.935185,
    -0.021127, -0.677134, -0.875000,
    -0.021127, -0.730433, -0.814815,
    -0.021127, -0.769148, -0.768519,
    -0.021127, -0.794322, -0.750000,
    0.242419, -0.522620, -0.946948,
    0.229987, -0.608211, -0.902281,
    0.213827, -0.677134, -0.844213,
    0.197666, -0.730433, -0.786145,
    0.185234, -0.769148, -0.741478,
    0.180262, -0.794322, -0.723611,
    0.477611, -0.522620, -0.849163,
    0.454085, -0.608211, -0.809108,
    0.423502, -0.677134, -0.757037,
    0.392919, -0.730433, -0.704966,
    0.369394, -0.769148, -0.664911,
    0.359984, -0.794322, -0.648889,
    0.675725, -0.522620, -0.696852,
    0.642854, -0.608211, -0.663981,
    0.600123, -0.677134, -0.621250,
    0.557391, -0.730433, -0.578519,
    0.524521, -0.769148, -0.545648,
    0.511373, -0.794322, -0.532500,
    0.828036, -0.522620, -0.498738,
    0.787981, -0.608211, -0.475213,
    0.735910, -0.677134, -0.444630,
    0.683839, -0.730433, -0.414047,
    0.643784, -0.769148, -0.390521,
    0.627762, -0.794322, -0.381111,
    0.925821, -0.522620, -0.263546,
    0.881153, -0.608211, -0.251115,
    0.823086, -0.677134, -0.234954,
    0.765018, -0.730433, -0.218793,
    0.720351, -0.769148, -0.206361,
    0.702484, -0.794322, -0.201389,
    0.722796, -0.812898, 0.000000,
    0.692762, -0.830433, 0.000000,
    0.621060, -0.845884, 0.000000,
    0.489984, -0.858211, 0.000000,
    0.281824, -0.866370, 0.000000,
    -0.021127, -0.869322, 0.000000,
    0.696621, -0.812898, 0.199757,
    0.667643, -0.830433, 0.191692,
    0.598465, -0.845884, 0.172439,
    0.472000, -0.858211, 0.137243,
    0.271165, -0.866370, 0.081348,
    0.622505, -0.812898, 0.378023,
    0.596519, -0.830433, 0.362761,
    0.534484, -0.845884, 0.326326,
    0.421079, -0.858211, 0.259720,
    0.240982, -0.866370, 0.153944,
    0.507059, -0.812898, 0.528186,
    0.485734, -0.830433, 0.506861,
    0.434826, -0.845884, 0.455953,
    0.341762, -0.858211, 0.362889,
    0.193968, -0.866370, 0.215095,
    0.356896, -0.812898, 0.643632,
    0.341634, -0.830433, 0.617646,
    0.305199, -0.845884, 0.555611,
    0.238593, -0.858211, 0.442206,
    0.132817, -0.866370, 0.262109,
    0.178630, -0.812898, 0.717749,
    0.170565, -0.830433, 0.688771,
    0.151312, -0.845884, 0.619592,
    0.116116, -0.858211, 0.493128,
    0.060221, -0.866370, 0.292292,
    -0.021127, -0.812898, 0.743924,
    -0.021127, -0.830433, 0.713889,
    -0.021127, -0.845884, 0.642188,
    -0.021127, -0.858211, 0.511111,
    -0.021127, -0.866370, 0.302951,
    -0.220884, -0.812898, 0.717749,
    -0.212820, -0.830433, 0.688771,
    -0.193566, -0.845884, 0.619592,
    -0.158370, -0.858211, 0.493128,
    -0.102475, -0.866370, 0.292292,
    -0.399151, -0.812898, 0.643632,
    -0.383889, -0.830433, 0.617646,
    -0.347454, -0.845884, 0.555611,
    -0.280847, -0.858211, 0.442206,
    -0.175071, -0.866370, 0.262109,
    -0.549313, -0.812898, 0.528186,
    -0.527988, -0.830433, 0.506861,
    -0.477080, -0.845884, 0.455953,
    -0.384016, -0.858211, 0.362889,
    -0.236223, -0.866370, 0.215095,
    -0.664759, -0.812898, 0.378023,
    -0.638773, -0.830433, 0.362761,
    -0.576738, -0.845884, 0.326326,
    -0.463333, -0.858211, 0.259720,
    -0.283236, -0.866370, 0.153944,
    -0.738876, -0.812898, 0.199757,
    -0.709898, -0.830433, 0.191692,
    -0.640719, -0.845884, 0.172439,
    -0.514255, -0.858211, 0.137243,
    -0.313419, -0.866370, 0.081348,
    -0.765051, -0.812898, 0.000000,
    -0.735016, -0.830433, 0.000000,
    -0.663315, -0.845884, 0.000000,
    -0.532238, -0.858211, 0.000000,
    -0.324079, -0.866370, 0.000000,
    -0.738876, -0.812898, -0.199757,
    -0.709898, -0.830433, -0.191692,
    -0.640719, -0.845884, -0.172439,
    -0.514255, -0.858211, -0.137243,
    -0.313419, -0.866370, -0.081348,
    -0.664759, -0.812898, -0.378023,
    -0.638773, -0.830433, -0.362761,
    -0.576738, -0.845884, -0.326326,
    -0.463333, -0.858211, -0.259720,
    -0.283236, -0.866370, -0.153944,
    -0.549313, -0.812898, -0.528186,
    -0.527988, -0.830433, -0.506861,
    -0.477080, -0.845884, -0.455953,
    -0.384016, -0.858211, -0.362889,
    -0.236223, -0.866370, -0.215095,
    -0.399151, -0.812898, -0.643632,
    -0.383889, -0.830433, -0.617646,
    -0.347454, -0.845884, -0.555611,
    -0.280847, -0.858211, -0.442206,
    -0.175071, -0.866370, -0.262109,
    -0.220884, -0.812898, -0.717749,
    -0.212820, -0.830433, -0.688771,
    -0.193566, -0.845884, -0.619592,
    -0.158370, -0.858211, -0.493128,
    -0.102475, -0.866370, -0.292292,
    -0.021127, -0.812898, -0.743924,
    -0.021127, -0.830433, -0.713889,
    -0.021127, -0.845884, -0.642188,
    -0.021127, -0.858211, -0.511111,
    -0.021127, -0.866370, -0.302951,
    0.178630, -0.812898, -0.717749,
    0.170565, -0.830433, -0.688771,
    0.151312, -0.845884, -0.619592,
    0.116116, -0.858211, -0.493128,
    0.060221, -0.866370, -0.292292,
    0.356896, -0.812898, -0.643632,
    0.341634, -0.830433, -0.617646,
    0.305199, -0.845884, -0.555611,
    0.238593, -0.858211, -0.442206,
    0.132817, -0.866370, -0.262109,
    0.507059, -0.812898, -0.528186,
    0.485734, -0.830433, -0.506861,
    0.434826, -0.845884, -0.455953,
    0.341762, -0.858211, -0.362889,
    0.193968, -0.866370, -0.215095,
    0.622505, -0.812898, -0.378023,
    0.596519, -0.830433, -0.362761,
    0.534484, -0.845884, -0.326326,
    0.421079, -0.858211, -0.259720,
    0.240982, -0.866370, -0.153944,
    0.696621, -0.812898, -0.199757,
    0.667643, -0.830433, -0.191692,
    0.598465, -0.845884, -0.172439,
    0.472000, -0.858211, -0.137243,
    0.271165, -0.866370, -0.081348,
    -0.821127, 0.143178, 0.000000,
    -0.983396, 0.142657, 0.000000,
    -1.119275, 0.139012, 0.000000,
    -1.227377, 0.129116, 0.000000,
    -1.306313, 0.109845, 0.000000,
    -1.354692, 0.078074, 0.000000,
    -1.371127, 0.030678, 0.000000,
    -0.817424, 0.151512, 0.062500,
    -0.984648, 0.150952, 0.062500,
    -1.124351, 0.147036, 0.062500,
    -1.235248, 0.136407, 0.062500,
    -1.316052, 0.115709, 0.062500,
    -1.365477, 0.081585, 0.062500,
    -1.382239, 0.030678, 0.062500,
    -0.808164, 0.172345, 0.100000,
    -0.987777, 0.171689, 0.100000,
    -1.137040, 0.167098, 0.100000,
    -1.254924, 0.154637, 0.100000,
    -1.340400, 0.130370, 0.100000,
    -1.392441, 0.090362, 0.100000,
    -1.410016, 0.030678, 0.100000,
    -0.796127, 0.199428, 0.112500,
    -0.991845, 0.198647, 0.112500,
    -1.153535, 0.193178, 0.112500,
    -1.280502, 0.178335, 0.112500,
    -1.372053, 0.149428, 0.112500,
    -1.427493, 0.101772, 0.112500,
    -1.446127, 0.030678, 0.112500,
    -0.784090, 0.226511, 0.100000,
    -0.995913, 0.225605, 0.100000,
    -1.170030, 0.219258, 0.100000,
    -1.306081, 0.202032, 0.100000,
    -1.403706, 0.168487, 0.100000,
    -1.462545, 0.113182, 0.100000,
    -1.482238, 0.030678, 0.100000,
    -0.774831, 0.247345, 0.062500,
    -0.999042, 0.246342, 0.062500,
    -1.182719, 0.239320, 0.062500,
    -1.325757, 0.220261, 0.062500,
    -1.428054, 0.183147, 0.062500,
    -1.489509, 0.121959, 0.062500,
    -1.510016, 0.030678, 0.062500,
    -0.771127, 0.255678, 0.000000,
    -1.000294, 0.254636, 0.000000,
    -1.187794, 0.247345, 0.000000,
    -1.333627, 0.227553, 0.000000,
    -1.437794, 0.189011, 0.000000,
    -1.500294, 0.125470, 0.000000,
    -1.521127, 0.030678, 0.000000,
    -0.774831, 0.247345, -0.062500,
    -0.999042, 0.246342, -0.062500,
    -1.182719, 0.239320, -0.062500,
    -1.325757, 0.220261, -0.062500,
    -1.428054, 0.183147, -0.062500,
    -1.489509, 0.121959, -0.062500,
    -1.510016, 0.030678, -0.062500,
    -0.784090, 0.226511, -0.100000,
    -0.995913, 0.225605, -0.100000,
    -1.170030, 0.219258, -0.100000,
    -1.306081, 0.202032, -0.100000,
    -1.403706, 0.168487, -0.100000,
    -1.462545, 0.113182, -0.100000,
    -1.482238, 0.030678, -0.100000,
    -0.796127, 0.199428, -0.112500,
    -0.991845, 0.198647, -0.112500,
    -1.153535, 0.193178, -0.112500,
    -1.280502, 0.178335, -0.112500,
    -1.372053, 0.149428, -0.112500,
    -1.427493, 0.101772, -0.112500,
    -1.446127, 0.030678, -0.112500,
    -0.808164, 0.172345, -0.100000,
    -0.987777, 0.171689, -0.100000,
    -1.137040, 0.167098, -0.100000,
    -1.254924, 0.154637, -0.100000,
    -1.340400, 0.130370, -0.100000,
    -1.392441, 0.090362, -0.100000,
    -1.410016, 0.030678, -0.100000,
    -0.817424, 0.151512, -0.062500,
    -0.984648, 0.150952, -0.062500,
    -1.124351, 0.147036, -0.062500,
    -1.235248, 0.136407, -0.062500,
    -1.316052, 0.115709, -0.062500,
    -1.365477, 0.081585, -0.062500,
    -1.382239, 0.030678, -0.062500,
    -1.362563, -0.033905, 0.000000,
    -1.335942, -0.110988, 0.000000,
    -1.289877, -0.194322, 0.000000,
    -1.222979, -0.277655, 0.000000,
    -1.133859, -0.354739, 0.000000,
    -1.021127, -0.419322, 0.000000,
    -1.373219, -0.037332, 0.062500,
    -1.345270, -0.116647, 0.062500,
    -1.297053, -0.201440, 0.062500,
    -1.227232, -0.285886, 0.062500,
    -1.134467, -0.364159, 0.062500,
    -1.017424, -0.430433, 0.062500,
    -1.399861, -0.045900, 0.100000,
    -1.368590, -0.130793, 0.100000,
    -1.314993, -0.219235, 0.100000,
    -1.237862, -0.306462, 0.100000,
    -1.135989, -0.387709, 0.100000,
    -1.008164, -0.458211, 0.100000,
    -1.434495, -0.057039, 0.112500,
    -1.398905, -0.149183, 0.112500,
    -1.338315, -0.242369, 0.112500,
    -1.251683, -0.333211, 0.112500,
    -1.137967, -0.418324, 0.112500,
    -0.996127, -0.494322, 0.112500,
    -1.469130, -0.068177, 0.100000,
    -1.429221, -0.167573, 0.100000,
    -1.361637, -0.265502, 0.100000,
    -1.265503, -0.359960, 0.100000,
    -1.139946, -0.448939, 0.100000,
    -0.984090, -0.530433, 0.100000,
    -1.495772, -0.076745, 0.062500,
    -1.452540, -0.181719, 0.062500,
    -1.379576, -0.283298, 0.062500,
    -1.276134, -0.380536, 0.062500,
    -1.141468, -0.472489, 0.062500,
    -0.974831, -0.558211, 0.062500,
    -1.506428, -0.080173, 0.000000,
    -1.461868, -0.187377, 0.000000,
    -1.386752, -0.290416, 0.000000,
    -1.280387, -0.388766, 0.000000,
    -1.142076, -0.481909, 0.000000,
    -0.971127, -0.569322, 0.000000,
    -1.495772, -0.076745, -0.062500,
    -1.452540, -0.181719, -0.062500,
    -1.379576, -0.283298, -0.062500,
    -1.276134, -0.380536, -0.062500,
    -1.141468, -0.472489, -0.062500,
    -0.974831, -0.558211, -0.062500,
    -1.469130, -0.068177, -0.100000,
    -1.429221, -0.167573, -0.100000,
    -1.361637, -0.265502, -0.100000,
    -1.265503, -0.359960, -0.100000,
    -1.139946, -0.448939, -0.100000,
    -0.984090, -0.530433, -0.100000,
    -1.434495, -0.057039, -0.112500,
    -1.398905, -0.149183, -0.112500,
    -1.338315, -0.242369, -0.112500,
    -1.251683, -0.333211, -0.112500,
    -1.137967, -0.418324, -0.112500,
    -0.996127, -0.494322, -0.112500,
    -1.399861, -0.045900, -0.100000,
    -1.368590, -0.130793, -0.100000,
    -1.314993, -0.219235, -0.100000,
    -1.237862, -0.306462, -0.100000,
    -1.135989, -0.387709, -0.100000,
    -1.008164, -0.458211, -0.100000,
    -1.373219, -0.037332, -0.062500,
    -1.345270, -0.116647, -0.062500,
    -1.297053, -0.201440, -0.062500,
    -1.227232, -0.285886, -0.062500,
    -1.134467, -0.364159, -0.062500,
    -1.017424, -0.430433, -0.062500,
    0.828873, -0.156822, 0.000000,
    1.008271, -0.131127, 0.000000,
    1.114058, -0.063766, 0.000000,
    1.172623, 0.030678, 0.000000,
    1.210354, 0.137623, 0.000000,
    1.253641, 0.242484, 0.000000,
    1.328873, 0.330678, 0.000000,
    0.828873, -0.187377, 0.137500,
    1.015061, -0.156719, 0.131173,
    1.123935, -0.083314, 0.115355,
    1.183734, 0.017484, 0.094792,
    1.222700, 0.130318, 0.074228,
    1.269073, 0.239835, 0.058411,
    1.351095, 0.330678, 0.052083,
    0.828873, -0.263766, 0.220000,
    1.032036, -0.220698, 0.209877,
    1.148626, -0.132182, 0.184568,
    1.211512, -0.015502, 0.151667,
    1.253564, 0.112057, 0.118765,
    1.307654, 0.233212, 0.093457,
    1.406651, 0.330678, 0.083333,
    0.828873, -0.363072, 0.247500,
    1.054104, -0.303870, 0.236111,
    1.180725, -0.195711, 0.207639,
    1.247623, -0.058384, 0.170625,
    1.293688, 0.088317, 0.133611,
    1.357808, 0.224602, 0.105139,
    1.478873, 0.330678, 0.093750,
    0.828873, -0.462377, 0.220000,
    1.076172, -0.387043, 0.209877,
    1.212823, -0.259240, 0.184568,
    1.283734, -0.101266, 0.151667,
    1.333811, 0.064577, 0.118765,
    1.407962, 0.215992, 0.093457,
    1.551095, 0.330678, 0.083333,
    0.828873, -0.538766, 0.137500,
    1.093148, -0.451022, 0.131173,
    1.237515, -0.308108, 0.115355,
    1.311512, -0.134252, 0.094792,
    1.364675, 0.046316, 0.074228,
    1.446543, 0.209369, 0.058410,
    1.606651, 0.330678, 0.052083,
    0.828873, -0.569322, 0.000000,
    1.099938, -0.476614, 0.000000,
    1.247391, -0.327655, 0.000000,
    1.322623, -0.147447, 0.000000,
    1.377021, 0.039012, 0.000000,
    1.461975, 0.206720, 0.000000,
    1.628873, 0.330678, 0.000000,
    0.828873, -0.538766, -0.137500,
    1.093148, -0.451022, -0.131173,
    1.237515, -0.308108, -0.115355,
    1.311512, -0.134252, -0.094792,
    1.364675, 0.046316, -0.074228,
    1.446543, 0.209369, -0.058410,
    1.606651, 0.330678, -0.052083,
    0.828873, -0.462377, -0.220000,
    1.076172, -0.387043, -0.209877,
    1.212823, -0.259240, -0.184568,
    1.283734, -0.101266, -0.151667,
    1.333811, 0.064577, -0.118765,
    1.407962, 0.215992, -0.093457,
    1.551095, 0.330678, -0.083333,
    0.828873, -0.363072, -0.247500,
    1.054104, -0.303870, -0.236111,
    1.180725, -0.195711, -0.207639,
    1.247623, -0.058384, -0.170625,
    1.293688, 0.088317, -0.133611,
    1.357808, 0.224602, -0.105139,
    1.478873, 0.330678, -0.093750,
    0.828873, -0.263766, -0.220000,
    1.032036, -0.220698, -0.209877,
    1.148626, -0.132182, -0.184568,
    1.211512, -0.015502, -0.151667,
    1.253564, 0.112057, -0.118765,
    1.307654, 0.233212, -0.093457,
    1.406651, 0.330678, -0.083333,
    0.828873, -0.187377, -0.137500,
    1.015061, -0.156719, -0.131173,
    1.123935, -0.083314, -0.115355,
    1.183734, 0.017484, -0.094792,
    1.222700, 0.130318, -0.074228,
    1.269073, 0.239835, -0.058410,
    1.351095, 0.330678, -0.052083,
    1.353410, 0.346303, 0.000000,
    1.375169, 0.355678, 0.000000,
    1.391373, 0.358803, 0.000000,
    1.399243, 0.355678, 0.000000,
    1.396003, 0.346303, 0.000000,
    1.378873, 0.330678, 0.000000,
    1.377077, 0.346641, 0.050540,
    1.398763, 0.356295, 0.046682,
    1.413711, 0.359584, 0.041667,
    1.419477, 0.356450, 0.036651,
    1.413617, 0.346834, 0.032793,
    1.393688, 0.330678, 0.031250,
    1.436244, 0.347485, 0.080864,
    1.457748, 0.357839, 0.074691,
    1.469556, 0.361538, 0.066667,
    1.470060, 0.358379, 0.058642,
    1.457652, 0.348160, 0.052469,
    1.430725, 0.330678, 0.050000,
    1.513161, 0.348582, 0.090972,
    1.534428, 0.359845, 0.084028,
    1.542154, 0.364077, 0.075000,
    1.535817, 0.360886, 0.065972,
    1.514897, 0.349884, 0.059028,
    1.478873, 0.330678, 0.056250,
    1.590078, 0.349679, 0.080864,
    1.611109, 0.361851, 0.074691,
    1.614753, 0.366616, 0.066667,
    1.601575, 0.363394, 0.058642,
    1.572143, 0.351608, 0.052469,
    1.527021, 0.330678, 0.050000,
    1.649245, 0.350523, 0.050540,
    1.670094, 0.363394, 0.046682,
    1.670597, 0.368569, 0.041667,
    1.652158, 0.365323, 0.036651,
    1.616178, 0.352934, 0.032793,
    1.564058, 0.330678, 0.031250,
    1.672912, 0.350860, 0.000000,
    1.693688, 0.364011, 0.000000,
    1.692935, 0.369350, 0.000000,
    1.672391, 0.366095, 0.000000,
    1.633792, 0.353465, 0.000000,
    1.578873, 0.330678, 0.000000,
    1.649245, 0.350523, -0.050540,
    1.670094, 0.363394, -0.046682,
    1.670597, 0.368569, -0.041667,
    1.652158, 0.365323, -0.036651,
    1.616178, 0.352934, -0.032793,
    1.564058, 0.330678, -0.031250,
    1.590078, 0.349679, -0.080864,
    1.611109, 0.361851, -0.074691,
    1.614753, 0.366616, -0.066667,
    1.601575, 0.363394, -0.058642,
    1.572143, 0.351608, -0.052469,
    1.527021, 0.330678, -0.050000,
    1.513161, 0.348582, -0.090972,
    1.534428, 0.359845, -0.084028,
    1.542154, 0.364077, -0.075000,
    1.535817, 0.360886, -0.065972,
    1.514897, 0.349884, -0.059028,
    1.478873, 0.330678, -0.056250,
    1.436244, 0.347485, -0.080864,
    1.457748, 0.357839, -0.074691,
    1.469556, 0.361538, -0.066667,
    1.470060, 0.358379, -0.058642,
    1.457652, 0.348160, -0.052469,
    1.430725, 0.330678, -0.050000,
    1.377077, 0.346641, -0.050540,
    1.398763, 0.356295, -0.046682,
    1.413711, 0.359584, -0.041667,
    1.419477, 0.356450, -0.036651,
    1.413617, 0.346834, -0.032793,
    1.393688, 0.330678, -0.031250,
    -0.021127, 0.705678, 0.000000,
    0.118225, 0.694220, 0.000000,
    0.160354, 0.664011, 0.000000,
    0.141373, 0.621303, 0.000000,
    0.097391, 0.572345, 0.000000,
    0.064521, 0.523386, 0.000000,
    0.078873, 0.480678, 0.000000,
    0.113346, 0.694220, 0.037539,
    0.154000, 0.664011, 0.048885,
    0.135681, 0.621303, 0.043764,
    0.093237, 0.572345, 0.031902,
    0.061512, 0.523386, 0.023022,
    0.075354, 0.480678, 0.026852,
    0.099515, 0.694220, 0.070966,
    0.135987, 0.664011, 0.092417,
    0.119549, 0.621303, 0.082741,
    0.081463, 0.572345, 0.060324,
    0.052990, 0.523386, 0.043553,
    0.065391, 0.480678, 0.050815,
    0.077943, 0.694220, 0.099070,
    0.107891, 0.664011, 0.129019,
    0.094388, 0.621303, 0.115516,
    0.063104, 0.572345, 0.084231,
    0.039709, 0.523386, 0.060836,
    0.049873, 0.480678, 0.071000,
    0.049838, 0.694220, 0.120642,
    0.071290, 0.664011, 0.157114,
    0.061614, 0.621303, 0.140676,
    0.039197, 0.572345, 0.102590,
    0.022426, 0.523386, 0.074117,
    0.029688, 0.480678, 0.086519,
    0.016412, 0.694220, 0.134473,
    0.027758, 0.664011, 0.175127,
    0.022637, 0.621303, 0.156808,
    0.010774, 0.572345, 0.114364,
    0.001895, 0.523386, 0.082639,
    0.005725, 0.480678, 0.096482,
    -0.021127, 0.694220, 0.139352,
    -0.021127, 0.664011, 0.181482,
    -0.021127, 0.621303, 0.162500,
    -0.021127, 0.572345, 0.118519,
    -0.021127, 0.523386, 0.085648,
    -0.021127, 0.480678, 0.100000,
    -0.058666, 0.694220, 0.134473,
    -0.070013, 0.664011, 0.175127,
    -0.064892, 0.621303, 0.156808,
    -0.053029, 0.572345, 0.114364,
    -0.044149, 0.523386, 0.082639,
    -0.047979, 0.480678, 0.096481,
    -0.092093, 0.694220, 0.120642,
    -0.113544, 0.664011, 0.157114,
    -0.103868, 0.621303, 0.140676,
    -0.081451, 0.572345, 0.102590,
    -0.064680, 0.523386, 0.074117,
    -0.071942, 0.480678, 0.086519,
    -0.120197, 0.694220, 0.099070,
    -0.150146, 0.664011, 0.129019,
    -0.136643, 0.621303, 0.115516,
    -0.105359, 0.572345, 0.084231,
    -0.081963, 0.523386, 0.060836,
    -0.092127, 0.480678, 0.071000,
    -0.141770, 0.694220, 0.070966,
    -0.178241, 0.664011, 0.092417,
    -0.161803, 0.621303, 0.082741,
    -0.123717, 0.572345, 0.060324,
    -0.095244, 0.523386, 0.043553,
    -0.107646, 0.480678, 0.050815,
    -0.155600, 0.694220, 0.037539,
    -0.196254, 0.664011, 0.048885,
    -0.177936, 0.621303, 0.043764,
    -0.135491, 0.572345, 0.031902,
    -0.103767, 0.523386, 0.023022,
    -0.117609, 0.480678, 0.026852,
    -0.160479, 0.694220, 0.000000,
    -0.202609, 0.664011, 0.000000,
    -0.183627, 0.621303, 0.000000,
    -0.139646, 0.572345, 0.000000,
    -0.106775, 0.523386, 0.000000,
    -0.121127, 0.480678, 0.000000,
    -0.155600, 0.694220, -0.037539,
    -0.196254, 0.664011, -0.048885,
    -0.177936, 0.621303, -0.043764,
    -0.135491, 0.572345, -0.031902,
    -0.103767, 0.523386, -0.023022,
    -0.117609, 0.480678, -0.026852,
    -0.141770, 0.694220, -0.070966,
    -0.178241, 0.664011, -0.092417,
    -0.161803, 0.621303, -0.082741,
    -0.123717, 0.572345, -0.060324,
    -0.095244, 0.523386, -0.043553,
    -0.107646, 0.480678, -0.050815,
    -0.120197, 0.694220, -0.099070,
    -0.150146, 0.664011, -0.129019,
    -0.136643, 0.621303, -0.115516,
    -0.105359, 0.572345, -0.084231,
    -0.081963, 0.523386, -0.060836,
    -0.092127, 0.480678, -0.071000,
    -0.092093, 0.694220, -0.120642,
    -0.113544, 0.664011, -0.157114,
    -0.103868, 0.621303, -0.140676,
    -0.081451, 0.572345, -0.102590,
    -0.064680, 0.523386, -0.074117,
    -0.071942, 0.480678, -0.086519,
    -0.058666, 0.694220, -0.134473,
    -0.070013, 0.664011, -0.175127,
    -0.064892, 0.621303, -0.156808,
    -0.053029, 0.572345, -0.114364,
    -0.044149, 0.523386, -0.082639,
    -0.047979, 0.480678, -0.096482,
    -0.021127, 0.694220, -0.139352,
    -0.021127, 0.664011, -0.181482,
    -0.021127, 0.621303, -0.162500,
    -0.021127, 0.572345, -0.118519,
    -0.021127, 0.523386, -0.085648,
    -0.021127, 0.480678, -0.100000,
    0.016412, 0.694220, -0.134473,
    0.027758, 0.664011, -0.175127,
    0.022637, 0.621303, -0.156808,
    0.010774, 0.572345, -0.114364,
    0.001895, 0.523386, -0.082639,
    0.005725, 0.480678, -0.096481,
    0.049838, 0.694220, -0.120642,
    0.071290, 0.664011, -0.157114,
    0.061614, 0.621303, -0.140676,
    0.039197, 0.572345, -0.102590,
    0.022426, 0.523386, -0.074117,
    0.029688, 0.480678, -0.086519,
    0.077943, 0.694220, -0.099070,
    0.107891, 0.664011, -0.129019,
    0.094388, 0.621303, -0.115516,
    0.063104, 0.572345, -0.084231,
    0.039709, 0.523386, -0.060836,
    0.049873, 0.480678, -0.071000,
    0.099515, 0.694220, -0.070966,
    0.135987, 0.664011, -0.092417,
    0.119549, 0.621303, -0.082741,
    0.081463, 0.572345, -0.060324,
    0.052990, 0.523386, -0.043553,
    0.065391, 0.480678, -0.050815,
    0.113346, 0.694220, -0.037539,
    0.154000, 0.664011, -0.048885,
    0.135681, 0.621303, -0.043764,
    0.093237, 0.572345, -0.031902,
    0.061512, 0.523386, -0.023022,
    0.075354, 0.480678, -0.026852,
    0.154336, 0.448734, 0.000000,
    0.265910, 0.425123, 0.000000,
    0.391373, 0.405678, 0.000000,
    0.508502, 0.386234, 0.000000,
    0.595077, 0.362623, 0.000000,
    0.628873, 0.330678, 0.000000,
    0.148162, 0.448734, 0.047115,
    0.255810, 0.425123, 0.077075,
    0.376859, 0.405678, 0.110764,
    0.489867, 0.386234, 0.142215,
    0.573395, 0.362623, 0.165462,
    0.606002, 0.330678, 0.174537,
    0.130681, 0.448734, 0.089161,
    0.227213, 0.425123, 0.145857,
    0.335762, 0.405678, 0.209611,
    0.437101, 0.386234, 0.269130,
    0.512003, 0.362623, 0.313123,
    0.541243, 0.330678, 0.330296,
    0.103451, 0.448734, 0.124579,
    0.182669, 0.425123, 0.203796,
    0.271748, 0.405678, 0.292875,
    0.354910, 0.386234, 0.376037,
    0.416377, 0.362623, 0.437505,
    0.440373, 0.330678, 0.461500,
    0.068034, 0.448734, 0.151808,
    0.124730, 0.425123, 0.248340,
    0.188484, 0.405678, 0.356889,
    0.248003, 0.386234, 0.458228,
    0.291995, 0.362623, 0.533130,
    0.309169, 0.330678, 0.562370,
    0.025988, 0.448734, 0.169289,
    0.055948, 0.425123, 0.276938,
    0.089637, 0.405678, 0.397986,
    0.121088, 0.386234, 0.510995,
    0.144335, 0.362623, 0.594523,
    0.153410, 0.330678, 0.627130,
    -0.021127, 0.448734, 0.175463,
    -0.021127, 0.425123, 0.287037,
    -0.021127, 0.405678, 0.412500,
    -0.021127, 0.386234, 0.529630,
    -0.021127, 0.362623, 0.616204,
    -0.021127, 0.330678, 0.650000,
    -0.068242, 0.448734, 0.169289,
    -0.098202, 0.425123, 0.276938,
    -0.131891, 0.405678, 0.397986,
    -0.163343, 0.386234, 0.510995,
    -0.186589, 0.362623, 0.594523,
    -0.195664, 0.330678, 0.627130,
    -0.110288, 0.448734, 0.151808,
    -0.166985, 0.425123, 0.248340,
    -0.230738, 0.405678, 0.356889,
    -0.290258, 0.386234, 0.458228,
    -0.334250, 0.362623, 0.533130,
    -0.351424, 0.330678, 0.562370,
    -0.145706, 0.448734, 0.124579,
    -0.224924, 0.425123, 0.203796,
    -0.314002, 0.405678, 0.292875,
    -0.397164, 0.386234, 0.376037,
    -0.458632, 0.362623, 0.437505,
    -0.482627, 0.330678, 0.461500,
    -0.172935, 0.448734, 0.089161,
    -0.269467, 0.425123, 0.145857,
    -0.378016, 0.405678, 0.209611,
    -0.479355, 0.386234, 0.269130,
    -0.554258, 0.362623, 0.313123,
    -0.583498, 0.330678, 0.330296,
    -0.190416, 0.448734, 0.047115,
    -0.298065, 0.425123, 0.077075,
    -0.419113, 0.405678, 0.110764,
    -0.532122, 0.386234, 0.142215,
    -0.615650, 0.362623, 0.165462,
    -0.648257, 0.330678, 0.174537,
    -0.196590, 0.448734, 0.000000,
    -0.308164, 0.425123, 0.000000,
    -0.433627, 0.405678, 0.000000,
    -0.550757, 0.386234, 0.000000,
    -0.637331, 0.362623, 0.000000,
    -0.671127, 0.330678, 0.000000,
    -0.190416, 0.448734, -0.047115,
    -0.298065, 0.425123, -0.077075,
    -0.419113, 0.405678, -0.110764,
    -0.532122, 0.386234, -0.142215,
    -0.615650, 0.362623, -0.165462,
    -0.648257, 0.330678, -0.174537,
    -0.172935, 0.448734, -0.089161,
    -0.269467, 0.425123, -0.145857,
    -0.378016, 0.405678, -0.209611,
    -0.479355, 0.386234, -0.269130,
    -0.554258, 0.362623, -0.313123,
    -0.583498, 0.330678, -0.330296,
    -0.145706, 0.448734, -0.124579,
    -0.224924, 0.425123, -0.203796,
    -0.314002, 0.405678, -0.292875,
    -0.397164, 0.386234, -0.376037,
    -0.458632, 0.362623, -0.437505,
    -0.482627, 0.330678, -0.461500,
    -0.110288, 0.448734, -0.151808,
    -0.166985, 0.425123, -0.248340,
    -0.230738, 0.405678, -0.356889,
    -0.290258, 0.386234, -0.458228,
    -0.334250, 0.362623, -0.533130,
    -0.351424, 0.330678, -0.562370,
    -0.068242, 0.448734, -0.169289,
    -0.098202, 0.425123, -0.276938,
    -0.131891, 0.405678, -0.397986,
    -0.163343, 0.386234, -0.510995,
    -0.186589, 0.362623, -0.594523,
    -0.195664, 0.330678, -0.627130,
    -0.021127, 0.448734, -0.175463,
    -0.021127, 0.425123, -0.287037,
    -0.021127, 0.405678, -0.412500,
    -0.021127, 0.386234, -0.529630,
    -0.021127, 0.362623, -0.616204,
    -0.021127, 0.330678, -0.650000,
    0.025988, 0.448734, -0.169289,
    0.055948, 0.425123, -0.276938,
    0.089637, 0.405678, -0.397986,
    0.121088, 0.386234, -0.510995,
    0.144335, 0.362623, -0.594523,
    0.153410, 0.330678, -0.627130,
    0.068034, 0.448734, -0.151808,
    0.124730, 0.425123, -0.248340,
    0.188484, 0.405678, -0.356889,
    0.248003, 0.386234, -0.458228,
    0.291996, 0.362623, -0.533130,
    0.309169, 0.330678, -0.562370,
    0.103451, 0.448734, -0.124579,
    0.182669, 0.425123, -0.203796,
    0.271748, 0.405678, -0.292875,
    0.354910, 0.386234, -0.376037,
    0.416377, 0.362623, -0.437505,
    0.440373, 0.330678, -0.461500,
    0.130681, 0.448734, -0.089161,
    0.227213, 0.425123, -0.145857,
    0.335762, 0.405678, -0.209611,
    0.437101, 0.386234, -0.269130,
    0.512003, 0.362623, -0.313123,
    0.541243, 0.330678, -0.330296,
    0.148162, 0.448734, -0.047115,
    0.255810, 0.425123, -0.077075,
    0.376859, 0.405678, -0.110764,
    0.489867, 0.386234, -0.142215,
    0.573395, 0.362623, -0.165462,
    0.606002, 0.330678, -0.174537,
};
static D3DXVECTOR3 *teapotPositions = (D3DXVECTOR3*)teapotPositionsFloats;

static float teapotNormalsFloats[NUMTEAPOTVERTICES*3] = 
{
    -0.945751, -0.322256, -0.041309,
    -0.992771, -0.120019, -0.001089,
    -0.842751, 0.538169, 0.012052,
    -0.083588, 0.996288, 0.020560,
    0.532170, 0.846603, 0.007614,
    0.779300, 0.626641, 0.003491,
    0.879896, 0.475165, 0.001103,
    -0.902413, -0.322783, -0.285416,
    -0.958558, -0.120097, -0.258348,
    -0.816875, 0.538579, -0.206514,
    -0.086190, 0.996277, -0.001604,
    0.511484, 0.846942, 0.145167,
    0.751363, 0.627164, 0.205227,
    0.849281, 0.475682, 0.229015,
    -0.797449, -0.323303, -0.509461,
    -0.858625, -0.120328, -0.498282,
    -0.735017, 0.538957, -0.411431,
    -0.082580, 0.996294, -0.024043,
    0.455735, 0.847352, 0.272581,
    0.671856, 0.627868, 0.392927,
    0.760399, 0.476384, 0.441420,
    -0.639341, -0.323439, -0.697589,
    -0.701183, -0.120461, -0.702731,
    -0.604040, 0.539064, -0.586980,
    -0.073399, 0.996309, -0.044511,
    0.369925, 0.847499, 0.380659,
    0.547722, 0.628143, 0.552663,
    0.620826, 0.476660, 0.622391,
    -0.437782, -0.323142, -0.839003,
    -0.496373, -0.120437, -0.859715,
    -0.432443, 0.538876, -0.722914,
    -0.059523, 0.996312, -0.061801,
    0.259388, 0.847326, 0.463418,
    0.386844, 0.627880, 0.675366,
    0.439492, 0.476398, 0.761506,
    -0.204681, -0.322547, -0.924159,
    -0.256209, -0.120257, -0.959112,
    -0.230122, 0.538458, -0.810621,
    -0.041668, 0.996304, -0.075119,
    0.130300, 0.846904, 0.515534,
    0.198391, 0.627182, 0.753183,
    0.226852, 0.475703, 0.849850,
    0.035941, -0.330214, -0.943221,
    -0.001376, -0.125569, -0.992084,
    -0.012701, 0.535792, -0.844254,
    -0.020672, 0.996343, -0.082901,
    -0.007571, 0.846427, 0.532451,
    -0.003482, 0.626608, 0.779327,
    -0.001103, 0.475165, 0.879896,
    0.269574, -0.386954, -0.881814,
    0.249993, -0.181783, -0.951030,
    0.211872, 0.499984, -0.839718,
    0.002768, 0.995768, -0.091859,
    -0.146446, 0.844150, 0.515718,
    -0.205497, 0.625909, 0.752335,
    -0.229034, 0.475536, 0.849358,
    0.482854, -0.445924, -0.753661,
    0.483883, -0.261599, -0.835118,
    0.442338, 0.434016, -0.784836,
    0.036680, 0.993502, -0.107746,
    -0.278510, 0.839949, 0.465746,
    -0.394390, 0.624142, 0.674465,
    -0.441541, 0.475913, 0.760624,
    0.669165, -0.453044, -0.589041,
    0.686401, -0.287530, -0.667967,
    0.643212, 0.404496, -0.650124,
    0.074604, 0.991460, -0.106959,
    -0.391289, 0.837987, 0.380356,
    -0.555484, 0.623132, 0.550586,
    -0.622636, 0.476008, 0.621080,
    0.821788, -0.407716, -0.398036,
    0.849894, -0.244430, -0.466834,
    0.778095, 0.435804, -0.452374,
    0.095458, 0.992115, -0.081218,
    -0.473659, 0.839871, 0.265074,
    -0.678265, 0.623724, 0.388490,
    -0.761768, 0.475842, 0.439641,
    0.919150, -0.348512, -0.183583,
    0.956218, -0.171139, -0.237398,
    0.838823, 0.493898, -0.229000,
    0.094322, 0.994404, -0.047578,
    -0.520640, 0.843596, 0.131452,
    -0.754753, 0.625180, 0.198741,
    -0.849997, 0.475426, 0.226882,
    0.945537, -0.322183, 0.046446,
    0.991881, -0.126966, 0.007216,
    0.847572, 0.530605, -0.008996,
    0.087879, 0.995918, -0.020615,
    -0.533063, 0.846041, -0.007711,
    -0.779612, 0.626253, -0.003532,
    -0.879926, 0.475109, -0.001109,
    0.902413, -0.322783, 0.285416,
    0.958558, -0.120097, 0.258348,
    0.816875, 0.538579, 0.206514,
    0.086190, 0.996277, 0.001604,
    -0.511484, 0.846942, -0.145167,
    -0.751363, 0.627164, -0.205227,
    -0.849281, 0.475682, -0.229015,
    0.797449, -0.323303, 0.509461,
    0.858625, -0.120328, 0.498282,
    0.735017, 0.538957, 0.411431,
    0.082580, 0.996294, 0.024043,
    -0.455735, 0.847352, -0.272581,
    -0.671856, 0.627868, -0.392927,
    -0.760399, 0.476384, -0.441420,
    0.639341, -0.323439, 0.697589,
    0.701183, -0.120461, 0.702731,
    0.604040, 0.539064, 0.586980,
    0.073399, 0.996309, 0.044511,
    -0.369925, 0.847499, -0.380659,
    -0.547722, 0.628143, -0.552663,
    -0.620826, 0.476660, -0.622391,
    0.437782, -0.323142, 0.839003,
    0.496373, -0.120437, 0.859715,
    0.432443, 0.538876, 0.722914,
    0.059523, 0.996312, 0.061801,
    -0.259388, 0.847326, -0.463418,
    -0.386844, 0.627880, -0.675366,
    -0.439492, 0.476398, -0.761506,
    0.204681, -0.322547, 0.924159,
    0.256209, -0.120257, 0.959112,
    0.230122, 0.538458, 0.810621,
    0.041668, 0.996304, 0.075119,
    -0.130300, 0.846904, -0.515534,
    -0.198391, 0.627182, -0.753183,
    -0.226852, 0.475703, -0.849850,
    -0.041309, -0.322256, 0.945751,
    -0.001089, -0.120019, 0.992771,
    0.012052, 0.538169, 0.842751,
    0.020560, 0.996288, 0.083588,
    0.007614, 0.846603, -0.532170,
    0.003491, 0.626641, -0.779300,
    0.001103, 0.475165, -0.879896,
    -0.285416, -0.322783, 0.902413,
    -0.258348, -0.120097, 0.958558,
    -0.206514, 0.538579, 0.816875,
    -0.001604, 0.996277, 0.086190,
    0.145167, 0.846942, -0.511484,
    0.205227, 0.627164, -0.751363,
    0.229015, 0.475682, -0.849281,
    -0.509461, -0.323303, 0.797449,
    -0.498282, -0.120328, 0.858625,
    -0.411431, 0.538957, 0.735017,
    -0.024043, 0.996294, 0.082580,
    0.272581, 0.847352, -0.455735,
    0.392927, 0.627868, -0.671856,
    0.441420, 0.476384, -0.760399,
    -0.697589, -0.323439, 0.639341,
    -0.702731, -0.120461, 0.701183,
    -0.586980, 0.539064, 0.604040,
    -0.044511, 0.996309, 0.073399,
    0.380659, 0.847499, -0.369925,
    0.552663, 0.628143, -0.547722,
    0.622391, 0.476660, -0.620826,
    -0.839003, -0.323142, 0.437782,
    -0.859715, -0.120437, 0.496373,
    -0.722914, 0.538876, 0.432443,
    -0.061801, 0.996312, 0.059523,
    0.463418, 0.847326, -0.259388,
    0.675366, 0.627880, -0.386844,
    0.761506, 0.476398, -0.439492,
    -0.924159, -0.322547, 0.204681,
    -0.959112, -0.120257, 0.256209,
    -0.810621, 0.538458, 0.230122,
    -0.075119, 0.996304, 0.041668,
    0.515534, 0.846904, -0.130300,
    0.753183, 0.627182, -0.198391,
    0.849850, 0.475703, -0.226852,
    0.908180, 0.418579, 0.000170,
    0.920061, 0.391776, 0.000335,
    0.939254, 0.343222, 0.000478,
    0.963807, 0.266599, 0.000552,
    0.988261, 0.152772, 0.000449,
    0.998933, -0.046187, -0.000262,
    0.876892, 0.419073, 0.235451,
    0.888349, 0.392247, 0.238702,
    0.906891, 0.343648, 0.243832,
    0.930644, 0.266938, 0.250291,
    0.954351, 0.152959, 0.256551,
    0.964867, -0.046304, 0.258627,
    0.785456, 0.419734, 0.454843,
    0.795707, 0.392883, 0.460971,
    0.812334, 0.344228, 0.470766,
    0.833667, 0.267414, 0.483207,
    0.855012, 0.153250, 0.495448,
    0.864663, -0.046372, 0.500207,
    0.641599, 0.419990, 0.641841,
    0.649935, 0.393130, 0.650410,
    0.663494, 0.344457, 0.664173,
    0.680925, 0.267607, 0.681710,
    0.698421, 0.153377, 0.699059,
    0.706532, -0.046369, 0.706160,
    0.454545, 0.419737, 0.785627,
    0.460384, 0.392890, 0.796043,
    0.469929, 0.344241, 0.812813,
    0.482239, 0.267436, 0.834220,
    0.494660, 0.153286, 0.855462,
    0.500666, -0.046300, 0.864402,
    0.235117, 0.419078, 0.876980,
    0.238044, 0.392258, 0.888521,
    0.242894, 0.343667, 0.907136,
    0.249206, 0.266970, 0.930926,
    0.255668, 0.153012, 0.954579,
    0.259142, -0.046198, 0.964734,
    -0.000170, 0.418579, 0.908181,
    -0.000335, 0.391776, 0.920061,
    -0.000478, 0.343222, 0.939254,
    -0.000552, 0.266599, 0.963807,
    -0.000449, 0.152772, 0.988261,
    0.000262, -0.046187, 0.998933,
    -0.235451, 0.419073, 0.876892,
    -0.238702, 0.392247, 0.888349,
    -0.243832, 0.343648, 0.906891,
    -0.250291, 0.266938, 0.930644,
    -0.256551, 0.152959, 0.954351,
    -0.258627, -0.046304, 0.964867,
    -0.454843, 0.419734, 0.785456,
    -0.460971, 0.392883, 0.795707,
    -0.470766, 0.344228, 0.812334,
    -0.483207, 0.267414, 0.833667,
    -0.495448, 0.153250, 0.855012,
    -0.500207, -0.046372, 0.864663,
    -0.641841, 0.419990, 0.641599,
    -0.650410, 0.393130, 0.649935,
    -0.664173, 0.344457, 0.663494,
    -0.681710, 0.267607, 0.680925,
    -0.699059, 0.153377, 0.698421,
    -0.706160, -0.046369, 0.706532,
    -0.785627, 0.419737, 0.454545,
    -0.796043, 0.392890, 0.460384,
    -0.812813, 0.344241, 0.469929,
    -0.834220, 0.267436, 0.482239,
    -0.855462, 0.153286, 0.494660,
    -0.864402, -0.046300, 0.500666,
    -0.876980, 0.419078, 0.235117,
    -0.888521, 0.392258, 0.238044,
    -0.907136, 0.343667, 0.242894,
    -0.930926, 0.266970, 0.249206,
    -0.954579, 0.153012, 0.255668,
    -0.964734, -0.046198, 0.259142,
    -0.908181, 0.418579, -0.000170,
    -0.920061, 0.391776, -0.000335,
    -0.939254, 0.343222, -0.000478,
    -0.963807, 0.266599, -0.000552,
    -0.988261, 0.152772, -0.000449,
    -0.998933, -0.046187, 0.000262,
    -0.876892, 0.419073, -0.235451,
    -0.888349, 0.392247, -0.238702,
    -0.906891, 0.343648, -0.243832,
    -0.930644, 0.266938, -0.250291,
    -0.954351, 0.152959, -0.256551,
    -0.964867, -0.046304, -0.258627,
    -0.785456, 0.419734, -0.454843,
    -0.795707, 0.392883, -0.460971,
    -0.812334, 0.344228, -0.470766,
    -0.833667, 0.267414, -0.483207,
    -0.855012, 0.153250, -0.495448,
    -0.864663, -0.046372, -0.500207,
    -0.641599, 0.419990, -0.641841,
    -0.649935, 0.393130, -0.650410,
    -0.663494, 0.344457, -0.664173,
    -0.680925, 0.267607, -0.681710,
    -0.698421, 0.153377, -0.699059,
    -0.706532, -0.046369, -0.706160,
    -0.454545, 0.419737, -0.785627,
    -0.460384, 0.392890, -0.796043,
    -0.469929, 0.344241, -0.812813,
    -0.482239, 0.267436, -0.834220,
    -0.494660, 0.153286, -0.855462,
    -0.500666, -0.046300, -0.864402,
    -0.235117, 0.419078, -0.876980,
    -0.238044, 0.392258, -0.888521,
    -0.242894, 0.343667, -0.907136,
    -0.249206, 0.266970, -0.930926,
    -0.255668, 0.153012, -0.954579,
    -0.259142, -0.046198, -0.964734,
    0.000170, 0.418579, -0.908181,
    0.000335, 0.391776, -0.920061,
    0.000478, 0.343222, -0.939254,
    0.000552, 0.266599, -0.963807,
    0.000449, 0.152772, -0.988261,
    -0.000262, -0.046187, -0.998933,
    0.235451, 0.419073, -0.876892,
    0.238702, 0.392247, -0.888349,
    0.243832, 0.343648, -0.906891,
    0.250291, 0.266938, -0.930644,
    0.256551, 0.152959, -0.954351,
    0.258627, -0.046304, -0.964867,
    0.454843, 0.419734, -0.785456,
    0.460971, 0.392883, -0.795707,
    0.470766, 0.344228, -0.812334,
    0.483207, 0.267414, -0.833667,
    0.495448, 0.153250, -0.855012,
    0.500207, -0.046372, -0.864663,
    0.641841, 0.419990, -0.641599,
    0.650410, 0.393130, -0.649935,
    0.664173, 0.344457, -0.663494,
    0.681710, 0.267607, -0.680925,
    0.699059, 0.153377, -0.698421,
    0.706160, -0.046369, -0.706532,
    0.785627, 0.419737, -0.454545,
    0.796043, 0.392890, -0.460384,
    0.812813, 0.344241, -0.469929,
    0.834220, 0.267436, -0.482239,
    0.855462, 0.153286, -0.494660,
    0.864402, -0.046300, -0.500666,
    0.876980, 0.419078, -0.235117,
    0.888521, 0.392258, -0.238044,
    0.907136, 0.343667, -0.242894,
    0.930926, 0.266970, -0.249206,
    0.954579, 0.153012, -0.255668,
    0.964734, -0.046198, -0.259142,
    0.943833, -0.330414, -0.002283,
    0.821403, -0.570341, -0.002745,
    0.709541, -0.704661, -0.001958,
    0.652305, -0.757957, -0.000466,
    0.728669, -0.684856, 0.003576,
    0.889124, -0.457656, 0.003164,
    0.912037, -0.330868, 0.242313,
    0.793697, -0.570897, 0.210051,
    0.685340, -0.705168, 0.181787,
    0.629635, -0.758420, 0.168401,
    0.702387, -0.685364, 0.192168,
    0.857690, -0.458122, 0.233435,
    0.817716, -0.331385, 0.470664,
    0.711528, -0.571608, 0.408646,
    0.614071, -0.705839, 0.353140,
    0.563713, -0.759034, 0.325721,
    0.627891, -0.686037, 0.367569,
    0.767411, -0.458787, 0.447879,
    0.668728, -0.331557, 0.665486,
    0.582010, -0.571874, 0.578122,
    0.502096, -0.706097, 0.499327,
    0.460496, -0.759271, 0.459838,
    0.511760, -0.686297, 0.516816,
    0.625950, -0.459060, 0.630437,
    0.474660, -0.331321, 0.815429,
    0.413434, -0.571590, 0.708771,
    0.356547, -0.705839, 0.612100,
    0.326530, -0.759035, 0.563244,
    0.361346, -0.686040, 0.631489,
    0.442349, -0.458832, 0.770585,
    0.246794, -0.330773, 0.910869,
    0.215429, -0.570870, 0.792274,
    0.185619, -0.705168, 0.684313,
    0.169311, -0.758421, 0.629390,
    0.185170, -0.685368, 0.704260,
    0.227231, -0.458188, 0.859319,
    0.002283, -0.330414, 0.943833,
    0.002745, -0.570341, 0.821403,
    0.001958, -0.704661, 0.709541,
    0.000466, -0.757957, 0.652305,
    -0.003576, -0.684856, 0.728669,
    -0.003164, -0.457656, 0.889124,
    -0.242313, -0.330868, 0.912037,
    -0.210051, -0.570897, 0.793697,
    -0.181787, -0.705168, 0.685340,
    -0.168401, -0.758420, 0.629635,
    -0.192168, -0.685364, 0.702387,
    -0.233435, -0.458122, 0.857690,
    -0.470664, -0.331385, 0.817716,
    -0.408646, -0.571608, 0.711528,
    -0.353140, -0.705839, 0.614071,
    -0.325721, -0.759034, 0.563713,
    -0.367569, -0.686037, 0.627891,
    -0.447879, -0.458787, 0.767411,
    -0.665486, -0.331557, 0.668728,
    -0.578122, -0.571874, 0.582010,
    -0.499327, -0.706097, 0.502096,
    -0.459838, -0.759271, 0.460496,
    -0.516816, -0.686297, 0.511760,
    -0.630437, -0.459060, 0.625950,
    -0.815429, -0.331321, 0.474660,
    -0.708771, -0.571590, 0.413434,
    -0.612100, -0.705839, 0.356547,
    -0.563244, -0.759035, 0.326530,
    -0.631489, -0.686040, 0.361346,
    -0.770585, -0.458832, 0.442349,
    -0.910869, -0.330773, 0.246794,
    -0.792274, -0.570870, 0.215429,
    -0.684313, -0.705168, 0.185619,
    -0.629390, -0.758421, 0.169311,
    -0.704260, -0.685368, 0.185170,
    -0.859319, -0.458188, 0.227231,
    -0.943833, -0.330414, 0.002283,
    -0.821403, -0.570341, 0.002745,
    -0.709541, -0.704661, 0.001958,
    -0.652305, -0.757957, 0.000466,
    -0.728669, -0.684856, -0.003576,
    -0.889124, -0.457656, -0.003164,
    -0.912037, -0.330868, -0.242313,
    -0.793697, -0.570897, -0.210051,
    -0.685340, -0.705168, -0.181787,
    -0.629635, -0.758420, -0.168401,
    -0.702387, -0.685364, -0.192168,
    -0.857690, -0.458122, -0.233435,
    -0.817716, -0.331385, -0.470664,
    -0.711528, -0.571608, -0.408646,
    -0.614071, -0.705839, -0.353140,
    -0.563713, -0.759034, -0.325721,
    -0.627891, -0.686037, -0.367569,
    -0.767411, -0.458787, -0.447879,
    -0.668728, -0.331557, -0.665486,
    -0.582010, -0.571874, -0.578122,
    -0.502096, -0.706097, -0.499327,
    -0.460496, -0.759271, -0.459838,
    -0.511760, -0.686297, -0.516816,
    -0.625950, -0.459060, -0.630437,
    -0.474660, -0.331321, -0.815429,
    -0.413434, -0.571590, -0.708771,
    -0.356547, -0.705839, -0.612100,
    -0.326530, -0.759035, -0.563244,
    -0.361346, -0.686040, -0.631489,
    -0.442349, -0.458832, -0.770585,
    -0.246794, -0.330773, -0.910869,
    -0.215429, -0.570870, -0.792274,
    -0.185619, -0.705168, -0.684313,
    -0.169311, -0.758421, -0.629390,
    -0.185170, -0.685368, -0.704260,
    -0.227231, -0.458188, -0.859319,
    -0.002283, -0.330414, -0.943833,
    -0.002745, -0.570341, -0.821403,
    -0.001958, -0.704661, -0.709541,
    -0.000466, -0.757957, -0.652305,
    0.003576, -0.684856, -0.728669,
    0.003164, -0.457656, -0.889124,
    0.242313, -0.330868, -0.912037,
    0.210051, -0.570897, -0.793697,
    0.181787, -0.705168, -0.685340,
    0.168401, -0.758420, -0.629635,
    0.192168, -0.685364, -0.702387,
    0.233435, -0.458122, -0.857690,
    0.470664, -0.331385, -0.817716,
    0.408646, -0.571608, -0.711528,
    0.353140, -0.705839, -0.614071,
    0.325721, -0.759034, -0.563713,
    0.367569, -0.686037, -0.627891,
    0.447879, -0.458787, -0.767411,
    0.665486, -0.331557, -0.668728,
    0.578122, -0.571874, -0.582010,
    0.499327, -0.706097, -0.502096,
    0.459838, -0.759271, -0.460496,
    0.516816, -0.686297, -0.511760,
    0.630437, -0.459060, -0.625950,
    0.815429, -0.331321, -0.474660,
    0.708771, -0.571590, -0.413434,
    0.612100, -0.705839, -0.356547,
    0.563244, -0.759035, -0.326530,
    0.631489, -0.686040, -0.361346,
    0.770585, -0.458832, -0.442349,
    0.910869, -0.330773, -0.246794,
    0.792274, -0.570870, -0.215429,
    0.684313, -0.705168, -0.185619,
    0.629390, -0.758421, -0.169311,
    0.704260, -0.685368, -0.185170,
    0.859319, -0.458188, -0.227231,
    0.777345, -0.628990, -0.010332,
    0.361793, -0.932236, -0.006477,
    0.152402, -0.988315, -0.002559,
    0.066422, -0.997791, -0.001190,
    0.027401, -0.999624, -0.001027,
    0.000000, -1.000000, 0.000000,
    0.753154, -0.629440, 0.191218,
    0.350766, -0.932386, 0.087291,
    0.147688, -0.988344, 0.036926,
    0.064386, -0.997796, 0.016021,
    0.026706, -0.999625, 0.006087,
    0.677297, -0.629962, 0.380023,
    0.315543, -0.932612, 0.175124,
    0.132774, -0.988389, 0.073881,
    0.057900, -0.997805, 0.032133,
    0.024157, -0.999626, 0.012794,
    0.556310, -0.630147, 0.541695,
    0.259523, -0.932707, 0.250409,
    0.109137, -0.988408, 0.105540,
    0.047613, -0.997809, 0.045941,
    0.020018, -0.999627, 0.018575,
    0.398014, -0.629932, 0.666911,
    0.186318, -0.932635, 0.308995,
    0.078296, -0.988394, 0.130182,
    0.034185, -0.997806, 0.056696,
    0.014564, -0.999627, 0.023117,
    0.211443, -0.629395, 0.747766,
    0.099921, -0.932420, 0.347287,
    0.041912, -0.988352, 0.146303,
    0.018338, -0.997798, 0.063741,
    0.008087, -0.999625, 0.026150,
    0.010332, -0.628990, 0.777345,
    0.006477, -0.932236, 0.361793,
    0.002559, -0.988315, 0.152402,
    0.001190, -0.997791, 0.066422,
    0.001027, -0.999624, 0.027401,
    -0.191218, -0.629440, 0.753154,
    -0.087291, -0.932386, 0.350766,
    -0.036926, -0.988344, 0.147688,
    -0.016021, -0.997796, 0.064386,
    -0.006087, -0.999625, 0.026706,
    -0.380023, -0.629962, 0.677297,
    -0.175124, -0.932612, 0.315543,
    -0.073881, -0.988389, 0.132774,
    -0.032133, -0.997805, 0.057900,
    -0.012794, -0.999626, 0.024157,
    -0.541695, -0.630147, 0.556310,
    -0.250409, -0.932707, 0.259523,
    -0.105540, -0.988408, 0.109137,
    -0.045941, -0.997809, 0.047613,
    -0.018575, -0.999627, 0.020018,
    -0.666911, -0.629932, 0.398014,
    -0.308995, -0.932635, 0.186318,
    -0.130182, -0.988394, 0.078296,
    -0.056696, -0.997806, 0.034185,
    -0.023117, -0.999627, 0.014564,
    -0.747766, -0.629395, 0.211443,
    -0.347287, -0.932420, 0.099921,
    -0.146303, -0.988352, 0.041912,
    -0.063741, -0.997798, 0.018338,
    -0.026150, -0.999625, 0.008087,
    -0.777345, -0.628990, 0.010332,
    -0.361793, -0.932236, 0.006477,
    -0.152402, -0.988315, 0.002559,
    -0.066422, -0.997791, 0.001190,
    -0.027401, -0.999624, 0.001027,
    -0.753154, -0.629440, -0.191218,
    -0.350766, -0.932386, -0.087291,
    -0.147688, -0.988344, -0.036926,
    -0.064386, -0.997796, -0.016021,
    -0.026706, -0.999625, -0.006087,
    -0.677297, -0.629962, -0.380023,
    -0.315543, -0.932612, -0.175124,
    -0.132774, -0.988389, -0.073881,
    -0.057900, -0.997805, -0.032133,
    -0.024157, -0.999626, -0.012794,
    -0.556310, -0.630147, -0.541695,
    -0.259523, -0.932707, -0.250409,
    -0.109137, -0.988408, -0.105540,
    -0.047613, -0.997809, -0.045941,
    -0.020018, -0.999627, -0.018575,
    -0.398014, -0.629932, -0.666911,
    -0.186318, -0.932635, -0.308995,
    -0.078296, -0.988394, -0.130182,
    -0.034185, -0.997806, -0.056696,
    -0.014564, -0.999627, -0.023117,
    -0.211443, -0.629395, -0.747766,
    -0.099921, -0.932420, -0.347287,
    -0.041912, -0.988352, -0.146303,
    -0.018338, -0.997798, -0.063741,
    -0.008087, -0.999625, -0.026150,
    -0.010332, -0.628990, -0.777345,
    -0.006477, -0.932236, -0.361793,
    -0.002559, -0.988315, -0.152402,
    -0.001190, -0.997791, -0.066422,
    -0.001027, -0.999624, -0.027401,
    0.191218, -0.629440, -0.753154,
    0.087291, -0.932386, -0.350766,
    0.036926, -0.988344, -0.147688,
    0.016021, -0.997796, -0.064386,
    0.006087, -0.999625, -0.026706,
    0.380023, -0.629962, -0.677297,
    0.175124, -0.932612, -0.315543,
    0.073881, -0.988389, -0.132774,
    0.032133, -0.997805, -0.057900,
    0.012794, -0.999626, -0.024157,
    0.541695, -0.630147, -0.556310,
    0.250409, -0.932707, -0.259523,
    0.105540, -0.988408, -0.109137,
    0.045941, -0.997809, -0.047613,
    0.018575, -0.999627, -0.020018,
    0.666911, -0.629932, -0.398014,
    0.308995, -0.932635, -0.186318,
    0.130182, -0.988394, -0.078296,
    0.056696, -0.997806, -0.034185,
    0.023117, -0.999627, -0.014564,
    0.747766, -0.629395, -0.211443,
    0.347287, -0.932420, -0.099921,
    0.146303, -0.988352, -0.041912,
    0.063741, -0.997798, -0.018338,
    0.026150, -0.999625, -0.008087,
    0.003252, -0.999017, 0.044215,
    0.015240, -0.999884, -0.000426,
    0.059928, -0.998202, -0.000876,
    0.167134, -0.985934, -0.001083,
    0.403838, -0.914830, -0.000203,
    0.792445, -0.609943, 0.000242,
    0.995161, -0.098254, -0.001013,
    0.003195, -0.927908, 0.372795,
    0.015041, -0.949764, 0.312606,
    0.059227, -0.948266, 0.311904,
    0.164453, -0.933549, 0.318499,
    0.388162, -0.854219, 0.345890,
    0.729394, -0.561905, 0.390189,
    0.912351, -0.095332, 0.398156,
    0.002232, -0.597680, 0.801731,
    0.010830, -0.681497, 0.731741,
    0.043613, -0.679614, 0.732272,
    0.120047, -0.660320, 0.741327,
    0.267930, -0.580441, 0.768962,
    0.467285, -0.367107, 0.804287,
    0.584006, -0.067606, 0.808929,
    -0.000653, 0.152635, 0.988282,
    -0.002559, 0.000905, 0.999996,
    -0.007405, 0.000384, 0.999972,
    -0.016090, -0.004746, 0.999859,
    -0.025703, -0.019620, 0.999477,
    -0.020936, -0.035053, 0.999166,
    -0.002824, -0.023899, 0.999710,
    -0.003296, 0.756255, 0.654269,
    -0.015405, 0.681251, 0.731887,
    -0.059217, 0.676283, 0.734258,
    -0.158438, 0.643792, 0.748619,
    -0.334170, 0.526967, 0.781432,
    -0.518177, 0.278028, 0.808822,
    -0.588929, 0.016391, 0.808019,
    -0.004352, 0.967350, 0.253408,
    -0.020677, 0.949300, 0.313691,
    -0.081844, 0.945117, 0.316317,
    -0.226175, 0.916097, 0.331076,
    -0.500500, 0.784289, 0.366594,
    -0.804374, 0.439635, 0.399630,
    -0.916460, 0.037237, 0.398390,
    -0.004517, 0.999011, -0.044228,
    -0.021584, 0.999767, 0.000265,
    -0.086245, 0.996274, 0.000157,
    -0.240673, 0.970606, -0.000608,
    -0.540280, 0.841484, -0.001597,
    -0.877811, 0.479008, 0.000390,
    -0.999074, 0.043021, 0.000686,
    -0.004094, 0.927919, -0.372759,
    -0.019687, 0.949518, -0.313093,
    -0.079023, 0.945545, -0.315752,
    -0.219600, 0.917458, -0.331734,
    -0.488715, 0.790534, -0.369071,
    -0.797673, 0.452036, -0.399226,
    -0.916555, 0.045675, -0.397293,
    -0.002516, 0.597699, -0.801716,
    -0.012433, 0.681272, -0.731925,
    -0.050950, 0.677183, -0.734048,
    -0.140298, 0.648898, -0.747829,
    -0.303501, 0.546934, -0.780224,
    -0.495541, 0.315794, -0.809143,
    -0.586888, 0.043544, -0.808497,
    0.000557, -0.152599, -0.988288,
    0.002074, -0.000969, -0.999997,
    0.005499, -0.001410, -0.999984,
    0.011569, 0.000546, -0.999933,
    0.019331, 0.010342, -0.999760,
    0.017294, 0.025347, -0.999529,
    0.002733, 0.020710, -0.999782,
    0.002668, -0.756195, -0.654340,
    0.012416, -0.681586, -0.731633,
    0.047946, -0.679845, -0.731787,
    0.130533, -0.659594, -0.740200,
    0.293034, -0.569168, -0.768231,
    0.500213, -0.318883, -0.805047,
    0.587808, -0.026599, -0.808563,
    0.003191, -0.967332, -0.253494,
    0.014981, -0.949482, -0.313464,
    0.058954, -0.947784, -0.313417,
    0.164056, -0.933187, -0.319761,
    0.391212, -0.853217, -0.344925,
    0.743675, -0.542841, -0.390219,
    0.913602, -0.073956, -0.399828,
    0.972925, 0.231121, -0.000918,
    0.912330, 0.409438, -0.003849,
    0.828029, 0.560649, -0.006408,
    0.716807, 0.697239, -0.006712,
    0.575989, 0.817451, -0.003302,
    0.495133, 0.867633, -0.045350,
    0.893985, 0.213142, 0.394158,
    0.840605, 0.383895, 0.382108,
    0.768860, 0.531454, 0.355543,
    0.672509, 0.665677, 0.323426,
    0.545610, 0.779633, 0.307380,
    0.479303, 0.843050, 0.244000,
    0.576388, 0.133958, 0.806122,
    0.544470, 0.253746, 0.799478,
    0.508754, 0.364144, 0.780108,
    0.461180, 0.471780, 0.751490,
    0.387281, 0.561166, 0.731509,
    0.371347, 0.666129, 0.646818,
    0.002410, -0.014515, 0.999892,
    0.001301, -0.016411, 0.999865,
    0.000720, -0.020201, 0.999796,
    0.003256, -0.021359, 0.999767,
    0.008876, -0.013337, 0.999872,
    0.072759, 0.131709, 0.988615,
    -0.569088, -0.161451, 0.806271,
    -0.524317, -0.294841, 0.798850,
    -0.472635, -0.410610, 0.779754,
    -0.415783, -0.508606, 0.753953,
    -0.349674, -0.579676, 0.736006,
    -0.279208, -0.530698, 0.800252,
    -0.885693, -0.241406, 0.396574,
    -0.803204, -0.449996, 0.390343,
    -0.697513, -0.613444, 0.370354,
    -0.588462, -0.732277, 0.342757,
    -0.485206, -0.813008, 0.321860,
    -0.425879, -0.823534, 0.374725,
    -0.965787, -0.259335, 0.000592,
    -0.872611, -0.488406, 0.003010,
    -0.748651, -0.662945, 0.005037,
    -0.622443, -0.782648, 0.005056,
    -0.509112, -0.860697, 0.002551,
    -0.455515, -0.889038, 0.046023,
    -0.888605, -0.232245, -0.395529,
    -0.809378, -0.443445, -0.385051,
    -0.704052, -0.611598, -0.360913,
    -0.592713, -0.733528, -0.332607,
    -0.486334, -0.814293, -0.316868,
    -0.441890, -0.860789, -0.252538,
    -0.574477, -0.139332, -0.806575,
    -0.532235, -0.275661, -0.800460,
    -0.480844, -0.396171, -0.782201,
    -0.423172, -0.499323, -0.756044,
    -0.355443, -0.574187, -0.737543,
    -0.348424, -0.670745, -0.654753,
    -0.001891, 0.012937, -0.999915,
    0.001397, 0.011921, -0.999928,
    0.005089, 0.014178, -0.999887,
    0.004896, 0.016722, -0.999848,
    -0.002003, 0.012285, -0.999922,
    -0.068183, -0.130578, -0.989091,
    0.573387, 0.149188, -0.805587,
    0.541227, 0.266714, -0.797456,
    0.503525, 0.377270, -0.777258,
    0.451452, 0.484144, -0.749530,
    0.372386, 0.571022, -0.731616,
    0.289707, 0.529053, -0.797604,
    0.892654, 0.216131, -0.395546,
    0.837234, 0.384836, -0.388510,
    0.763231, 0.531640, -0.367202,
    0.665469, 0.666102, -0.336837,
    0.537995, 0.781974, -0.314766,
    0.455324, 0.810920, -0.367545,
    -0.145927, 0.987044, 0.066705,
    -0.350253, 0.936641, -0.005157,
    -0.710995, 0.703191, -0.003047,
    -0.899400, 0.437101, 0.004678,
    -0.930238, 0.366579, 0.016656,
    -0.845840, 0.533040, 0.020564,
    -0.646372, 0.763018, 0.002776,
    -0.128906, 0.841567, 0.524546,
    -0.292019, 0.852082, 0.434375,
    -0.615355, 0.675119, 0.406882,
    -0.799678, 0.453205, 0.393853,
    -0.814130, 0.384381, 0.435251,
    -0.711742, 0.496654, 0.496746,
    -0.538718, 0.683956, 0.491922,
    -0.054328, 0.445430, 0.893667,
    -0.120328, 0.535740, 0.835765,
    -0.285367, 0.495269, 0.820533,
    -0.427214, 0.405516, 0.808112,
    -0.455262, 0.354182, 0.816880,
    -0.386518, 0.375163, 0.842530,
    -0.289150, 0.468105, 0.835027,
    0.075157, -0.092491, 0.992873,
    0.130249, 0.040179, 0.990667,
    0.205304, 0.124938, 0.970691,
    0.176764, 0.184322, 0.966840,
    0.082193, 0.182483, 0.979767,
    0.009842, 0.124532, 0.992167,
    -0.004171, 0.105296, 0.994432,
    0.213849, -0.587755, 0.780264,
    0.361728, -0.447069, 0.818097,
    0.601635, -0.258541, 0.755772,
    0.672221, -0.099063, 0.733693,
    0.583247, -0.084870, 0.807849,
    0.409251, -0.235708, 0.881451,
    0.284284, -0.385654, 0.877755,
    0.302637, -0.880762, 0.364237,
    0.496428, -0.756105, 0.426456,
    0.790450, -0.487110, 0.371365,
    0.895860, -0.277360, 0.347141,
    0.865262, -0.295907, 0.404673,
    0.690272, -0.542643, 0.478606,
    0.467747, -0.753579, 0.461879,
    0.321563, -0.944505, -0.067141,
    0.531566, -0.847002, 0.005046,
    0.833505, -0.552508, 0.002163,
    0.944185, -0.329343, -0.006880,
    0.932318, -0.361245, -0.016874,
    0.768639, -0.639601, -0.010215,
    0.513002, -0.858387, 0.000964,
    0.278331, -0.809595, -0.516806,
    0.491568, -0.763636, -0.418594,
    0.788478, -0.493107, -0.367624,
    0.891089, -0.275271, -0.360815,
    0.856479, -0.282922, -0.431739,
    0.692218, -0.527331, -0.492704,
    0.473487, -0.749262, -0.463052,
    0.166654, -0.429938, -0.887344,
    0.339768, -0.458348, -0.821264,
    0.590160, -0.276240, -0.758553,
    0.668115, -0.103914, -0.736766,
    0.590009, -0.076740, -0.803741,
    0.433287, -0.219357, -0.874154,
    0.299036, -0.368898, -0.880052,
    0.027869, 0.102187, -0.994375,
    0.088152, 0.031815, -0.995599,
    0.174456, 0.096185, -0.979956,
    0.188708, 0.161291, -0.968697,
    0.127686, 0.175774, -0.976115,
    0.054509, 0.130986, -0.989885,
    0.015877, 0.116730, -0.993037,
    -0.081072, 0.607187, -0.790412,
    -0.164116, 0.522469, -0.836715,
    -0.319626, 0.463405, -0.826495,
    -0.422971, 0.383450, -0.821013,
    -0.424534, 0.353597, -0.833511,
    -0.351612, 0.388106, -0.851905,
    -0.270475, 0.475063, -0.837352,
    -0.133739, 0.917541, -0.374476,
    -0.316043, 0.839490, -0.442011,
    -0.631181, 0.656649, -0.412823,
    -0.807405, 0.443017, -0.389658,
    -0.821659, 0.386229, -0.419171,
    -0.707748, 0.517393, -0.481037,
    -0.526814, 0.693790, -0.491043,
    -0.461017, 0.887371, -0.005987,
    -0.290675, 0.956710, -0.014601,
    0.085518, 0.995086, -0.049913,
    0.887713, 0.456166, -0.062285,
    0.822992, -0.567263, 0.029937,
    0.659878, -0.743158, 0.110798,
    -0.391094, 0.831360, 0.394824,
    -0.253310, 0.936825, 0.241231,
    0.015366, 0.995010, -0.098588,
    0.520185, 0.549881, -0.653482,
    0.628856, -0.382376, -0.677000,
    0.578948, -0.646092, -0.497378,
    -0.223422, 0.660928, 0.716420,
    -0.156131, 0.874986, 0.458282,
    -0.036467, 0.998264, -0.046261,
    0.156637, 0.682491, -0.713913,
    0.263632, 0.005571, -0.964607,
    0.312409, -0.324778, -0.892704,
    -0.001751, 0.339383, 0.940647,
    -0.021119, 0.759902, 0.649695,
    -0.044404, 0.998121, 0.042219,
    -0.032529, 0.802862, -0.595277,
    -0.008745, 0.371564, -0.928366,
    0.042529, 0.077913, -0.996053,
    0.280020, -0.238192, 0.929975,
    0.227305, 0.491486, 0.840699,
    -0.003105, 0.987407, 0.158172,
    -0.143918, 0.895866, -0.420370,
    -0.200177, 0.683872, -0.701604,
    -0.187188, 0.500198, -0.845437,
    0.453673, -0.746835, 0.486229,
    0.692158, -0.080062, 0.717291,
    0.185758, 0.942536, 0.277704,
    -0.211188, 0.955274, -0.207004,
    -0.312961, 0.881061, -0.354665,
    -0.336331, 0.811345, -0.478122,
    0.482445, -0.875816, -0.013906,
    0.913013, -0.405572, -0.043811,
    0.506909, 0.853920, 0.117742,
    -0.234033, 0.972124, 0.014295,
    -0.348033, 0.937468, 0.005277,
    -0.384064, 0.921073, -0.064185,
    0.457762, -0.717668, -0.524792,
    0.683347, -0.063014, -0.727369,
    0.357361, 0.898186, -0.256038,
    -0.207010, 0.947863, 0.242287,
    -0.314387, 0.872357, 0.374372,
    -0.361040, 0.872819, 0.328385,
    0.280225, -0.218552, -0.934724,
    0.261124, 0.434074, -0.862203,
    0.060553, 0.978577, -0.196775,
    -0.131809, 0.881094, 0.454203,
    -0.195016, 0.658858, 0.726550,
    -0.247824, 0.630359, 0.735684,
    0.008860, 0.321862, -0.946745,
    0.001382, 0.733189, -0.680023,
    -0.012720, 0.997949, -0.062734,
    -0.011656, 0.785221, 0.619106,
    0.000967, 0.344022, 0.938961,
    -0.037360, 0.214324, 0.976048,
    -0.213360, 0.648838, -0.730401,
    -0.140052, 0.865891, -0.480227,
    -0.000809, 0.999500, 0.031611,
    0.194529, 0.659081, 0.726478,
    0.266832, -0.005234, 0.963729,
    0.219380, -0.217247, 0.951145,
    -0.384886, 0.827121, -0.409553,
    -0.240915, 0.932642, -0.268588,
    0.065830, 0.996786, 0.045658,
    0.597011, 0.507703, 0.621141,
    0.613004, -0.369418, 0.698395,
    0.486873, -0.566787, 0.664610,
    0.000000, 1.000000, 0.000000,
    0.395791, 0.918207, 0.015676,
    0.964544, 0.263762, 0.009177,
    0.839041, -0.544056, -0.003654,
    0.788969, -0.614430, 0.001943,
    0.991025, -0.133647, 0.002953,
    0.732531, 0.680606, -0.013206,
    0.377669, 0.918491, 0.117221,
    0.929557, 0.263662, 0.257694,
    0.811158, -0.544801, 0.212638,
    0.761156, -0.615195, 0.205370,
    0.956515, -0.133833, 0.259168,
    0.710689, 0.680955, 0.176694,
    0.333696, 0.918791, 0.210878,
    0.830713, 0.263784, 0.490239,
    0.727549, -0.545809, 0.415650,
    0.681011, -0.616288, 0.395491,
    0.856413, -0.134443, 0.498480,
    0.640176, 0.681271, 0.355027,
    0.267591, 0.918878, 0.289928,
    0.675416, 0.263955, 0.688579,
    0.594970, -0.546203, 0.589638,
    0.555330, -0.616730, 0.557901,
    0.698694, -0.134804, 0.702606,
    0.526898, 0.681345, 0.508082,
    0.183499, 0.918711, 0.349712,
    0.474031, 0.264098, 0.839969,
    0.422194, -0.545768, 0.723802,
    0.392296, -0.616276, 0.682867,
    0.493598, -0.134679, 0.859199,
    0.378184, 0.681197, 0.626856,
    0.086498, 0.918378, 0.386136,
    0.239605, 0.264096, 0.934261,
    0.219887, -0.544743, 0.809262,
    0.201667, -0.615183, 0.762155,
    0.253529, -0.134173, 0.957977,
    0.202631, 0.680866, 0.703820,
    -0.015676, 0.918207, 0.395791,
    -0.009177, 0.263762, 0.964544,
    0.003654, -0.544057, 0.839041,
    -0.001943, -0.614430, 0.788969,
    -0.002953, -0.133647, 0.991025,
    0.013206, 0.680606, 0.732531,
    -0.117221, 0.918491, 0.377669,
    -0.257694, 0.263662, 0.929557,
    -0.212638, -0.544801, 0.811158,
    -0.205370, -0.615195, 0.761156,
    -0.259168, -0.133833, 0.956515,
    -0.176694, 0.680955, 0.710689,
    -0.210878, 0.918791, 0.333696,
    -0.490239, 0.263784, 0.830713,
    -0.415650, -0.545809, 0.727549,
    -0.395491, -0.616288, 0.681011,
    -0.498480, -0.134443, 0.856413,
    -0.355027, 0.681271, 0.640176,
    -0.289928, 0.918878, 0.267591,
    -0.688579, 0.263955, 0.675416,
    -0.589638, -0.546203, 0.594970,
    -0.557901, -0.616730, 0.555330,
    -0.702606, -0.134804, 0.698694,
    -0.508082, 0.681345, 0.526898,
    -0.349712, 0.918711, 0.183499,
    -0.839969, 0.264098, 0.474031,
    -0.723802, -0.545768, 0.422194,
    -0.682867, -0.616276, 0.392296,
    -0.859199, -0.134679, 0.493598,
    -0.626856, 0.681197, 0.378184,
    -0.386136, 0.918378, 0.086498,
    -0.934261, 0.264096, 0.239605,
    -0.809262, -0.544743, 0.219887,
    -0.762155, -0.615183, 0.201667,
    -0.957977, -0.134173, 0.253529,
    -0.703820, 0.680866, 0.202631,
    -0.395791, 0.918207, -0.015676,
    -0.964544, 0.263762, -0.009177,
    -0.839041, -0.544057, 0.003654,
    -0.788969, -0.614430, -0.001943,
    -0.991025, -0.133647, -0.002953,
    -0.732531, 0.680606, 0.013206,
    -0.377669, 0.918491, -0.117221,
    -0.929557, 0.263662, -0.257694,
    -0.811158, -0.544801, -0.212638,
    -0.761156, -0.615195, -0.205370,
    -0.956515, -0.133833, -0.259168,
    -0.710689, 0.680955, -0.176694,
    -0.333696, 0.918791, -0.210878,
    -0.830713, 0.263784, -0.490239,
    -0.727549, -0.545809, -0.415650,
    -0.681011, -0.616288, -0.395491,
    -0.856413, -0.134443, -0.498480,
    -0.640176, 0.681271, -0.355027,
    -0.267591, 0.918878, -0.289928,
    -0.675416, 0.263955, -0.688579,
    -0.594970, -0.546203, -0.589638,
    -0.555330, -0.616730, -0.557901,
    -0.698694, -0.134804, -0.702606,
    -0.526898, 0.681345, -0.508082,
    -0.183499, 0.918711, -0.349712,
    -0.474031, 0.264098, -0.839969,
    -0.422194, -0.545768, -0.723802,
    -0.392296, -0.616276, -0.682867,
    -0.493598, -0.134679, -0.859199,
    -0.378184, 0.681197, -0.626856,
    -0.086498, 0.918378, -0.386136,
    -0.239605, 0.264096, -0.934261,
    -0.219887, -0.544743, -0.809262,
    -0.201667, -0.615183, -0.762155,
    -0.253529, -0.134173, -0.957977,
    -0.202631, 0.680866, -0.703820,
    0.015676, 0.918207, -0.395791,
    0.009177, 0.263762, -0.964544,
    -0.003654, -0.544057, -0.839041,
    0.001943, -0.614430, -0.788969,
    0.002953, -0.133647, -0.991025,
    -0.013206, 0.680606, -0.732531,
    0.117221, 0.918491, -0.377669,
    0.257694, 0.263662, -0.929557,
    0.212638, -0.544801, -0.811158,
    0.205370, -0.615195, -0.761156,
    0.259168, -0.133833, -0.956515,
    0.176694, 0.680955, -0.710689,
    0.210878, 0.918791, -0.333696,
    0.490239, 0.263784, -0.830713,
    0.415650, -0.545809, -0.727549,
    0.395491, -0.616288, -0.681011,
    0.498480, -0.134443, -0.856413,
    0.355027, 0.681271, -0.640176,
    0.289928, 0.918878, -0.267591,
    0.688579, 0.263955, -0.675416,
    0.589638, -0.546203, -0.594970,
    0.557901, -0.616730, -0.555330,
    0.702606, -0.134804, -0.698694,
    0.508082, 0.681345, -0.526898,
    0.349712, 0.918711, -0.183499,
    0.839969, 0.264098, -0.474031,
    0.723802, -0.545768, -0.422194,
    0.682867, -0.616276, -0.392296,
    0.859199, -0.134679, -0.493598,
    0.626856, 0.681197, -0.378184,
    0.386136, 0.918378, -0.086498,
    0.934261, 0.264096, -0.239605,
    0.809262, -0.544743, -0.219887,
    0.762155, -0.615183, -0.201667,
    0.957977, -0.134173, -0.253529,
    0.703820, 0.680866, -0.202631,
    0.299763, 0.954005, -0.004004,
    0.180158, 0.983637, -0.001176,
    0.158462, 0.987365, 0.000232,
    0.213709, 0.976895, 0.002171,
    0.489301, 0.872063, 0.009504,
    0.686607, 0.726410, -0.029990,
    0.290238, 0.954117, 0.073644,
    0.174086, 0.983681, 0.045452,
    0.152777, 0.987401, 0.041212,
    0.205547, 0.976963, 0.057393,
    0.469598, 0.872357, 0.135911,
    0.670656, 0.726754, 0.148493,
    0.260698, 0.954280, 0.146242,
    0.156021, 0.983742, 0.088932,
    0.136587, 0.987448, 0.079312,
    0.183282, 0.977046, 0.108577,
    0.417739, 0.872696, 0.252776,
    0.608331, 0.727460, 0.317389,
    0.214008, 0.954348, 0.208377,
    0.127716, 0.983767, 0.126063,
    0.111442, 0.987466, 0.111767,
    0.149005, 0.977076, 0.152056,
    0.338347, 0.872812, 0.351738,
    0.505565, 0.727811, 0.463351,
    0.153158, 0.954293, 0.256647,
    0.090962, 0.983745, 0.154830,
    0.078913, 0.987448, 0.136822,
    0.104831, 0.977040, 0.185479,
    0.236319, 0.872663, 0.427333,
    0.369272, 0.727651, 0.578067,
    0.081449, 0.954136, 0.288080,
    0.047744, 0.983685, 0.173450,
    0.040760, 0.987400, 0.152903,
    0.053164, 0.976955, 0.206721,
    0.117360, 0.872307, 0.474665,
    0.207008, 0.727038, 0.654648,
    0.004004, 0.954005, 0.299763,
    0.001176, 0.983637, 0.180158,
    -0.000232, 0.987365, 0.158462,
    -0.002171, 0.976895, 0.213709,
    -0.009504, 0.872063, 0.489301,
    0.029990, 0.726410, 0.686607,
    -0.073644, 0.954117, 0.290238,
    -0.045452, 0.983681, 0.174086,
    -0.041212, 0.987401, 0.152777,
    -0.057393, 0.976963, 0.205547,
    -0.135911, 0.872357, 0.469598,
    -0.148493, 0.726754, 0.670656,
    -0.146242, 0.954280, 0.260698,
    -0.088932, 0.983742, 0.156021,
    -0.079312, 0.987448, 0.136587,
    -0.108577, 0.977046, 0.183282,
    -0.252776, 0.872696, 0.417739,
    -0.317389, 0.727460, 0.608331,
    -0.208377, 0.954348, 0.214008,
    -0.126063, 0.983767, 0.127716,
    -0.111767, 0.987466, 0.111442,
    -0.152056, 0.977076, 0.149005,
    -0.351738, 0.872812, 0.338347,
    -0.463351, 0.727811, 0.505565,
    -0.256647, 0.954293, 0.153158,
    -0.154830, 0.983745, 0.090962,
    -0.136822, 0.987448, 0.078913,
    -0.185479, 0.977040, 0.104831,
    -0.427333, 0.872663, 0.236319,
    -0.578067, 0.727651, 0.369272,
    -0.288080, 0.954136, 0.081449,
    -0.173450, 0.983685, 0.047744,
    -0.152903, 0.987400, 0.040760,
    -0.206721, 0.976955, 0.053164,
    -0.474665, 0.872307, 0.117360,
    -0.654648, 0.727038, 0.207008,
    -0.299763, 0.954005, 0.004004,
    -0.180158, 0.983637, 0.001176,
    -0.158462, 0.987365, -0.000232,
    -0.213709, 0.976895, -0.002171,
    -0.489301, 0.872063, -0.009504,
    -0.686607, 0.726410, 0.029990,
    -0.290238, 0.954117, -0.073644,
    -0.174086, 0.983681, -0.045452,
    -0.152777, 0.987401, -0.041212,
    -0.205547, 0.976963, -0.057393,
    -0.469598, 0.872357, -0.135911,
    -0.670656, 0.726754, -0.148493,
    -0.260698, 0.954280, -0.146242,
    -0.156021, 0.983742, -0.088932,
    -0.136587, 0.987448, -0.079312,
    -0.183282, 0.977046, -0.108577,
    -0.417739, 0.872696, -0.252776,
    -0.608331, 0.727460, -0.317389,
    -0.214008, 0.954348, -0.208377,
    -0.127716, 0.983767, -0.126063,
    -0.111442, 0.987466, -0.111767,
    -0.149005, 0.977076, -0.152056,
    -0.338347, 0.872812, -0.351738,
    -0.505565, 0.727811, -0.463351,
    -0.153158, 0.954293, -0.256647,
    -0.090962, 0.983745, -0.154830,
    -0.078913, 0.987448, -0.136822,
    -0.104831, 0.977040, -0.185479,
    -0.236319, 0.872663, -0.427333,
    -0.369272, 0.727651, -0.578067,
    -0.081449, 0.954136, -0.288080,
    -0.047744, 0.983685, -0.173450,
    -0.040760, 0.987400, -0.152903,
    -0.053164, 0.976955, -0.206721,
    -0.117360, 0.872307, -0.474665,
    -0.207008, 0.727038, -0.654648,
    -0.004004, 0.954005, -0.299763,
    -0.001176, 0.983637, -0.180158,
    0.000232, 0.987365, -0.158462,
    0.002171, 0.976895, -0.213709,
    0.009504, 0.872063, -0.489301,
    -0.029990, 0.726410, -0.686607,
    0.073644, 0.954117, -0.290238,
    0.045452, 0.983681, -0.174086,
    0.041212, 0.987401, -0.152777,
    0.057393, 0.976963, -0.205547,
    0.135911, 0.872357, -0.469598,
    0.148493, 0.726754, -0.670656,
    0.146242, 0.954280, -0.260698,
    0.088932, 0.983742, -0.156021,
    0.079312, 0.987448, -0.136587,
    0.108577, 0.977046, -0.183282,
    0.252776, 0.872696, -0.417739,
    0.317389, 0.727460, -0.608331,
    0.208377, 0.954348, -0.214008,
    0.126063, 0.983767, -0.127716,
    0.111767, 0.987466, -0.111442,
    0.152056, 0.977076, -0.149005,
    0.351738, 0.872812, -0.338347,
    0.463351, 0.727811, -0.505565,
    0.256647, 0.954293, -0.153158,
    0.154830, 0.983745, -0.090962,
    0.136822, 0.987448, -0.078913,
    0.185479, 0.977040, -0.104831,
    0.427333, 0.872663, -0.236319,
    0.578067, 0.727651, -0.369272,
    0.288080, 0.954136, -0.081449,
    0.173450, 0.983685, -0.047744,
    0.152903, 0.987400, -0.040760,
    0.206721, 0.976955, -0.053164,
    0.474665, 0.872307, -0.117360,
    0.654648, 0.727038, -0.207008,
};
static D3DXVECTOR3 *teapotNormals = (D3DXVECTOR3*)teapotNormalsFloats;

static WORD teapotIndices[NUMTEAPOTINDICES] = 
{
    0, 7, 8,
    8, 1, 0,
    1, 8, 9,
    9, 2, 1,
    2, 9, 10,
    10, 3, 2,
    3, 10, 11,
    11, 4, 3,
    4, 11, 12,
    12, 5, 4,
    5, 12, 13,
    13, 6, 5,
    7, 14, 15,
    15, 8, 7,
    8, 15, 16,
    16, 9, 8,
    9, 16, 17,
    17, 10, 9,
    10, 17, 18,
    18, 11, 10,
    11, 18, 19,
    19, 12, 11,
    12, 19, 20,
    20, 13, 12,
    14, 21, 22,
    22, 15, 14,
    15, 22, 23,
    23, 16, 15,
    16, 23, 24,
    24, 17, 16,
    17, 24, 25,
    25, 18, 17,
    18, 25, 26,
    26, 19, 18,
    19, 26, 27,
    27, 20, 19,
    21, 28, 29,
    29, 22, 21,
    22, 29, 30,
    30, 23, 22,
    23, 30, 31,
    31, 24, 23,
    24, 31, 32,
    32, 25, 24,
    25, 32, 33,
    33, 26, 25,
    26, 33, 34,
    34, 27, 26,
    28, 35, 36,
    36, 29, 28,
    29, 36, 37,
    37, 30, 29,
    30, 37, 38,
    38, 31, 30,
    31, 38, 39,
    39, 32, 31,
    32, 39, 40,
    40, 33, 32,
    33, 40, 41,
    41, 34, 33,
    35, 42, 43,
    43, 36, 35,
    36, 43, 44,
    44, 37, 36,
    37, 44, 45,
    45, 38, 37,
    38, 45, 46,
    46, 39, 38,
    39, 46, 47,
    47, 40, 39,
    40, 47, 48,
    48, 41, 40,
    42, 49, 50,
    50, 43, 42,
    43, 50, 51,
    51, 44, 43,
    44, 51, 52,
    52, 45, 44,
    45, 52, 53,
    53, 46, 45,
    46, 53, 54,
    54, 47, 46,
    47, 54, 55,
    55, 48, 47,
    49, 56, 57,
    57, 50, 49,
    50, 57, 58,
    58, 51, 50,
    51, 58, 59,
    59, 52, 51,
    52, 59, 60,
    60, 53, 52,
    53, 60, 61,
    61, 54, 53,
    54, 61, 62,
    62, 55, 54,
    56, 63, 64,
    64, 57, 56,
    57, 64, 65,
    65, 58, 57,
    58, 65, 66,
    66, 59, 58,
    59, 66, 67,
    67, 60, 59,
    60, 67, 68,
    68, 61, 60,
    61, 68, 69,
    69, 62, 61,
    63, 70, 71,
    71, 64, 63,
    64, 71, 72,
    72, 65, 64,
    65, 72, 73,
    73, 66, 65,
    66, 73, 74,
    74, 67, 66,
    67, 74, 75,
    75, 68, 67,
    68, 75, 76,
    76, 69, 68,
    70, 77, 78,
    78, 71, 70,
    71, 78, 79,
    79, 72, 71,
    72, 79, 80,
    80, 73, 72,
    73, 80, 81,
    81, 74, 73,
    74, 81, 82,
    82, 75, 74,
    75, 82, 83,
    83, 76, 75,
    77, 84, 85,
    85, 78, 77,
    78, 85, 86,
    86, 79, 78,
    79, 86, 87,
    87, 80, 79,
    80, 87, 88,
    88, 81, 80,
    81, 88, 89,
    89, 82, 81,
    82, 89, 90,
    90, 83, 82,
    84, 91, 92,
    92, 85, 84,
    85, 92, 93,
    93, 86, 85,
    86, 93, 94,
    94, 87, 86,
    87, 94, 95,
    95, 88, 87,
    88, 95, 96,
    96, 89, 88,
    89, 96, 97,
    97, 90, 89,
    91, 98, 99,
    99, 92, 91,
    92, 99, 100,
    100, 93, 92,
    93, 100, 101,
    101, 94, 93,
    94, 101, 102,
    102, 95, 94,
    95, 102, 103,
    103, 96, 95,
    96, 103, 104,
    104, 97, 96,
    98, 105, 106,
    106, 99, 98,
    99, 106, 107,
    107, 100, 99,
    100, 107, 108,
    108, 101, 100,
    101, 108, 109,
    109, 102, 101,
    102, 109, 110,
    110, 103, 102,
    103, 110, 111,
    111, 104, 103,
    105, 112, 113,
    113, 106, 105,
    106, 113, 114,
    114, 107, 106,
    107, 114, 115,
    115, 108, 107,
    108, 115, 116,
    116, 109, 108,
    109, 116, 117,
    117, 110, 109,
    110, 117, 118,
    118, 111, 110,
    112, 119, 120,
    120, 113, 112,
    113, 120, 121,
    121, 114, 113,
    114, 121, 122,
    122, 115, 114,
    115, 122, 123,
    123, 116, 115,
    116, 123, 124,
    124, 117, 116,
    117, 124, 125,
    125, 118, 117,
    119, 126, 127,
    127, 120, 119,
    120, 127, 128,
    128, 121, 120,
    121, 128, 129,
    129, 122, 121,
    122, 129, 130,
    130, 123, 122,
    123, 130, 131,
    131, 124, 123,
    124, 131, 132,
    132, 125, 124,
    126, 133, 134,
    134, 127, 126,
    127, 134, 135,
    135, 128, 127,
    128, 135, 136,
    136, 129, 128,
    129, 136, 137,
    137, 130, 129,
    130, 137, 138,
    138, 131, 130,
    131, 138, 139,
    139, 132, 131,
    133, 140, 141,
    141, 134, 133,
    134, 141, 142,
    142, 135, 134,
    135, 142, 143,
    143, 136, 135,
    136, 143, 144,
    144, 137, 136,
    137, 144, 145,
    145, 138, 137,
    138, 145, 146,
    146, 139, 138,
    140, 147, 148,
    148, 141, 140,
    141, 148, 149,
    149, 142, 141,
    142, 149, 150,
    150, 143, 142,
    143, 150, 151,
    151, 144, 143,
    144, 151, 152,
    152, 145, 144,
    145, 152, 153,
    153, 146, 145,
    147, 154, 155,
    155, 148, 147,
    148, 155, 156,
    156, 149, 148,
    149, 156, 157,
    157, 150, 149,
    150, 157, 158,
    158, 151, 150,
    151, 158, 159,
    159, 152, 151,
    152, 159, 160,
    160, 153, 152,
    154, 161, 162,
    162, 155, 154,
    155, 162, 163,
    163, 156, 155,
    156, 163, 164,
    164, 157, 156,
    157, 164, 165,
    165, 158, 157,
    158, 165, 166,
    166, 159, 158,
    159, 166, 167,
    167, 160, 159,
    161, 0, 1,
    1, 162, 161,
    162, 1, 2,
    2, 163, 162,
    163, 2, 3,
    3, 164, 163,
    164, 3, 4,
    4, 165, 164,
    165, 4, 5,
    5, 166, 165,
    166, 5, 6,
    6, 167, 166,
    6, 13, 174,
    174, 168, 6,
    168, 174, 175,
    175, 169, 168,
    169, 175, 176,
    176, 170, 169,
    170, 176, 177,
    177, 171, 170,
    171, 177, 178,
    178, 172, 171,
    172, 178, 179,
    179, 173, 172,
    13, 20, 180,
    180, 174, 13,
    174, 180, 181,
    181, 175, 174,
    175, 181, 182,
    182, 176, 175,
    176, 182, 183,
    183, 177, 176,
    177, 183, 184,
    184, 178, 177,
    178, 184, 185,
    185, 179, 178,
    20, 27, 186,
    186, 180, 20,
    180, 186, 187,
    187, 181, 180,
    181, 187, 188,
    188, 182, 181,
    182, 188, 189,
    189, 183, 182,
    183, 189, 190,
    190, 184, 183,
    184, 190, 191,
    191, 185, 184,
    27, 34, 192,
    192, 186, 27,
    186, 192, 193,
    193, 187, 186,
    187, 193, 194,
    194, 188, 187,
    188, 194, 195,
    195, 189, 188,
    189, 195, 196,
    196, 190, 189,
    190, 196, 197,
    197, 191, 190,
    34, 41, 198,
    198, 192, 34,
    192, 198, 199,
    199, 193, 192,
    193, 199, 200,
    200, 194, 193,
    194, 200, 201,
    201, 195, 194,
    195, 201, 202,
    202, 196, 195,
    196, 202, 203,
    203, 197, 196,
    41, 48, 204,
    204, 198, 41,
    198, 204, 205,
    205, 199, 198,
    199, 205, 206,
    206, 200, 199,
    200, 206, 207,
    207, 201, 200,
    201, 207, 208,
    208, 202, 201,
    202, 208, 209,
    209, 203, 202,
    48, 55, 210,
    210, 204, 48,
    204, 210, 211,
    211, 205, 204,
    205, 211, 212,
    212, 206, 205,
    206, 212, 213,
    213, 207, 206,
    207, 213, 214,
    214, 208, 207,
    208, 214, 215,
    215, 209, 208,
    55, 62, 216,
    216, 210, 55,
    210, 216, 217,
    217, 211, 210,
    211, 217, 218,
    218, 212, 211,
    212, 218, 219,
    219, 213, 212,
    213, 219, 220,
    220, 214, 213,
    214, 220, 221,
    221, 215, 214,
    62, 69, 222,
    222, 216, 62,
    216, 222, 223,
    223, 217, 216,
    217, 223, 224,
    224, 218, 217,
    218, 224, 225,
    225, 219, 218,
    219, 225, 226,
    226, 220, 219,
    220, 226, 227,
    227, 221, 220,
    69, 76, 228,
    228, 222, 69,
    222, 228, 229,
    229, 223, 222,
    223, 229, 230,
    230, 224, 223,
    224, 230, 231,
    231, 225, 224,
    225, 231, 232,
    232, 226, 225,
    226, 232, 233,
    233, 227, 226,
    76, 83, 234,
    234, 228, 76,
    228, 234, 235,
    235, 229, 228,
    229, 235, 236,
    236, 230, 229,
    230, 236, 237,
    237, 231, 230,
    231, 237, 238,
    238, 232, 231,
    232, 238, 239,
    239, 233, 232,
    83, 90, 240,
    240, 234, 83,
    234, 240, 241,
    241, 235, 234,
    235, 241, 242,
    242, 236, 235,
    236, 242, 243,
    243, 237, 236,
    237, 243, 244,
    244, 238, 237,
    238, 244, 245,
    245, 239, 238,
    90, 97, 246,
    246, 240, 90,
    240, 246, 247,
    247, 241, 240,
    241, 247, 248,
    248, 242, 241,
    242, 248, 249,
    249, 243, 242,
    243, 249, 250,
    250, 244, 243,
    244, 250, 251,
    251, 245, 244,
    97, 104, 252,
    252, 246, 97,
    246, 252, 253,
    253, 247, 246,
    247, 253, 254,
    254, 248, 247,
    248, 254, 255,
    255, 249, 248,
    249, 255, 256,
    256, 250, 249,
    250, 256, 257,
    257, 251, 250,
    104, 111, 258,
    258, 252, 104,
    252, 258, 259,
    259, 253, 252,
    253, 259, 260,
    260, 254, 253,
    254, 260, 261,
    261, 255, 254,
    255, 261, 262,
    262, 256, 255,
    256, 262, 263,
    263, 257, 256,
    111, 118, 264,
    264, 258, 111,
    258, 264, 265,
    265, 259, 258,
    259, 265, 266,
    266, 260, 259,
    260, 266, 267,
    267, 261, 260,
    261, 267, 268,
    268, 262, 261,
    262, 268, 269,
    269, 263, 262,
    118, 125, 270,
    270, 264, 118,
    264, 270, 271,
    271, 265, 264,
    265, 271, 272,
    272, 266, 265,
    266, 272, 273,
    273, 267, 266,
    267, 273, 274,
    274, 268, 267,
    268, 274, 275,
    275, 269, 268,
    125, 132, 276,
    276, 270, 125,
    270, 276, 277,
    277, 271, 270,
    271, 277, 278,
    278, 272, 271,
    272, 278, 279,
    279, 273, 272,
    273, 279, 280,
    280, 274, 273,
    274, 280, 281,
    281, 275, 274,
    132, 139, 282,
    282, 276, 132,
    276, 282, 283,
    283, 277, 276,
    277, 283, 284,
    284, 278, 277,
    278, 284, 285,
    285, 279, 278,
    279, 285, 286,
    286, 280, 279,
    280, 286, 287,
    287, 281, 280,
    139, 146, 288,
    288, 282, 139,
    282, 288, 289,
    289, 283, 282,
    283, 289, 290,
    290, 284, 283,
    284, 290, 291,
    291, 285, 284,
    285, 291, 292,
    292, 286, 285,
    286, 292, 293,
    293, 287, 286,
    146, 153, 294,
    294, 288, 146,
    288, 294, 295,
    295, 289, 288,
    289, 295, 296,
    296, 290, 289,
    290, 296, 297,
    297, 291, 290,
    291, 297, 298,
    298, 292, 291,
    292, 298, 299,
    299, 293, 292,
    153, 160, 300,
    300, 294, 153,
    294, 300, 301,
    301, 295, 294,
    295, 301, 302,
    302, 296, 295,
    296, 302, 303,
    303, 297, 296,
    297, 303, 304,
    304, 298, 297,
    298, 304, 305,
    305, 299, 298,
    160, 167, 306,
    306, 300, 160,
    300, 306, 307,
    307, 301, 300,
    301, 307, 308,
    308, 302, 301,
    302, 308, 309,
    309, 303, 302,
    303, 309, 310,
    310, 304, 303,
    304, 310, 311,
    311, 305, 304,
    167, 6, 168,
    168, 306, 167,
    306, 168, 169,
    169, 307, 306,
    307, 169, 170,
    170, 308, 307,
    308, 170, 171,
    171, 309, 308,
    309, 171, 172,
    172, 310, 309,
    310, 172, 173,
    173, 311, 310,
    173, 179, 318,
    318, 312, 173,
    312, 318, 319,
    319, 313, 312,
    313, 319, 320,
    320, 314, 313,
    314, 320, 321,
    321, 315, 314,
    315, 321, 322,
    322, 316, 315,
    316, 322, 323,
    323, 317, 316,
    179, 185, 324,
    324, 318, 179,
    318, 324, 325,
    325, 319, 318,
    319, 325, 326,
    326, 320, 319,
    320, 326, 327,
    327, 321, 320,
    321, 327, 328,
    328, 322, 321,
    322, 328, 329,
    329, 323, 322,
    185, 191, 330,
    330, 324, 185,
    324, 330, 331,
    331, 325, 324,
    325, 331, 332,
    332, 326, 325,
    326, 332, 333,
    333, 327, 326,
    327, 333, 334,
    334, 328, 327,
    328, 334, 335,
    335, 329, 328,
    191, 197, 336,
    336, 330, 191,
    330, 336, 337,
    337, 331, 330,
    331, 337, 338,
    338, 332, 331,
    332, 338, 339,
    339, 333, 332,
    333, 339, 340,
    340, 334, 333,
    334, 340, 341,
    341, 335, 334,
    197, 203, 342,
    342, 336, 197,
    336, 342, 343,
    343, 337, 336,
    337, 343, 344,
    344, 338, 337,
    338, 344, 345,
    345, 339, 338,
    339, 345, 346,
    346, 340, 339,
    340, 346, 347,
    347, 341, 340,
    203, 209, 348,
    348, 342, 203,
    342, 348, 349,
    349, 343, 342,
    343, 349, 350,
    350, 344, 343,
    344, 350, 351,
    351, 345, 344,
    345, 351, 352,
    352, 346, 345,
    346, 352, 353,
    353, 347, 346,
    209, 215, 354,
    354, 348, 209,
    348, 354, 355,
    355, 349, 348,
    349, 355, 356,
    356, 350, 349,
    350, 356, 357,
    357, 351, 350,
    351, 357, 358,
    358, 352, 351,
    352, 358, 359,
    359, 353, 352,
    215, 221, 360,
    360, 354, 215,
    354, 360, 361,
    361, 355, 354,
    355, 361, 362,
    362, 356, 355,
    356, 362, 363,
    363, 357, 356,
    357, 363, 364,
    364, 358, 357,
    358, 364, 365,
    365, 359, 358,
    221, 227, 366,
    366, 360, 221,
    360, 366, 367,
    367, 361, 360,
    361, 367, 368,
    368, 362, 361,
    362, 368, 369,
    369, 363, 362,
    363, 369, 370,
    370, 364, 363,
    364, 370, 371,
    371, 365, 364,
    227, 233, 372,
    372, 366, 227,
    366, 372, 373,
    373, 367, 366,
    367, 373, 374,
    374, 368, 367,
    368, 374, 375,
    375, 369, 368,
    369, 375, 376,
    376, 370, 369,
    370, 376, 377,
    377, 371, 370,
    233, 239, 378,
    378, 372, 233,
    372, 378, 379,
    379, 373, 372,
    373, 379, 380,
    380, 374, 373,
    374, 380, 381,
    381, 375, 374,
    375, 381, 382,
    382, 376, 375,
    376, 382, 383,
    383, 377, 376,
    239, 245, 384,
    384, 378, 239,
    378, 384, 385,
    385, 379, 378,
    379, 385, 386,
    386, 380, 379,
    380, 386, 387,
    387, 381, 380,
    381, 387, 388,
    388, 382, 381,
    382, 388, 389,
    389, 383, 382,
    245, 251, 390,
    390, 384, 245,
    384, 390, 391,
    391, 385, 384,
    385, 391, 392,
    392, 386, 385,
    386, 392, 393,
    393, 387, 386,
    387, 393, 394,
    394, 388, 387,
    388, 394, 395,
    395, 389, 388,
    251, 257, 396,
    396, 390, 251,
    390, 396, 397,
    397, 391, 390,
    391, 397, 398,
    398, 392, 391,
    392, 398, 399,
    399, 393, 392,
    393, 399, 400,
    400, 394, 393,
    394, 400, 401,
    401, 395, 394,
    257, 263, 402,
    402, 396, 257,
    396, 402, 403,
    403, 397, 396,
    397, 403, 404,
    404, 398, 397,
    398, 404, 405,
    405, 399, 398,
    399, 405, 406,
    406, 400, 399,
    400, 406, 407,
    407, 401, 400,
    263, 269, 408,
    408, 402, 263,
    402, 408, 409,
    409, 403, 402,
    403, 409, 410,
    410, 404, 403,
    404, 410, 411,
    411, 405, 404,
    405, 411, 412,
    412, 406, 405,
    406, 412, 413,
    413, 407, 406,
    269, 275, 414,
    414, 408, 269,
    408, 414, 415,
    415, 409, 408,
    409, 415, 416,
    416, 410, 409,
    410, 416, 417,
    417, 411, 410,
    411, 417, 418,
    418, 412, 411,
    412, 418, 419,
    419, 413, 412,
    275, 281, 420,
    420, 414, 275,
    414, 420, 421,
    421, 415, 414,
    415, 421, 422,
    422, 416, 415,
    416, 422, 423,
    423, 417, 416,
    417, 423, 424,
    424, 418, 417,
    418, 424, 425,
    425, 419, 418,
    281, 287, 426,
    426, 420, 281,
    420, 426, 427,
    427, 421, 420,
    421, 427, 428,
    428, 422, 421,
    422, 428, 429,
    429, 423, 422,
    423, 429, 430,
    430, 424, 423,
    424, 430, 431,
    431, 425, 424,
    287, 293, 432,
    432, 426, 287,
    426, 432, 433,
    433, 427, 426,
    427, 433, 434,
    434, 428, 427,
    428, 434, 435,
    435, 429, 428,
    429, 435, 436,
    436, 430, 429,
    430, 436, 437,
    437, 431, 430,
    293, 299, 438,
    438, 432, 293,
    432, 438, 439,
    439, 433, 432,
    433, 439, 440,
    440, 434, 433,
    434, 440, 441,
    441, 435, 434,
    435, 441, 442,
    442, 436, 435,
    436, 442, 443,
    443, 437, 436,
    299, 305, 444,
    444, 438, 299,
    438, 444, 445,
    445, 439, 438,
    439, 445, 446,
    446, 440, 439,
    440, 446, 447,
    447, 441, 440,
    441, 447, 448,
    448, 442, 441,
    442, 448, 449,
    449, 443, 442,
    305, 311, 450,
    450, 444, 305,
    444, 450, 451,
    451, 445, 444,
    445, 451, 452,
    452, 446, 445,
    446, 452, 453,
    453, 447, 446,
    447, 453, 454,
    454, 448, 447,
    448, 454, 455,
    455, 449, 448,
    311, 173, 312,
    312, 450, 311,
    450, 312, 313,
    313, 451, 450,
    451, 313, 314,
    314, 452, 451,
    452, 314, 315,
    315, 453, 452,
    453, 315, 316,
    316, 454, 453,
    454, 316, 317,
    317, 455, 454,
    317, 323, 462,
    462, 456, 317,
    456, 462, 463,
    463, 457, 456,
    457, 463, 464,
    464, 458, 457,
    458, 464, 465,
    465, 459, 458,
    459, 465, 466,
    466, 460, 459,
    460, 466, 461,
    323, 329, 467,
    467, 462, 323,
    462, 467, 468,
    468, 463, 462,
    463, 468, 469,
    469, 464, 463,
    464, 469, 470,
    470, 465, 464,
    465, 470, 471,
    471, 466, 465,
    466, 471, 461,
    329, 335, 472,
    472, 467, 329,
    467, 472, 473,
    473, 468, 467,
    468, 473, 474,
    474, 469, 468,
    469, 474, 475,
    475, 470, 469,
    470, 475, 476,
    476, 471, 470,
    471, 476, 461,
    335, 341, 477,
    477, 472, 335,
    472, 477, 478,
    478, 473, 472,
    473, 478, 479,
    479, 474, 473,
    474, 479, 480,
    480, 475, 474,
    475, 480, 481,
    481, 476, 475,
    476, 481, 461,
    341, 347, 482,
    482, 477, 341,
    477, 482, 483,
    483, 478, 477,
    478, 483, 484,
    484, 479, 478,
    479, 484, 485,
    485, 480, 479,
    480, 485, 486,
    486, 481, 480,
    481, 486, 461,
    347, 353, 487,
    487, 482, 347,
    482, 487, 488,
    488, 483, 482,
    483, 488, 489,
    489, 484, 483,
    484, 489, 490,
    490, 485, 484,
    485, 490, 491,
    491, 486, 485,
    486, 491, 461,
    353, 359, 492,
    492, 487, 353,
    487, 492, 493,
    493, 488, 487,
    488, 493, 494,
    494, 489, 488,
    489, 494, 495,
    495, 490, 489,
    490, 495, 496,
    496, 491, 490,
    491, 496, 461,
    359, 365, 497,
    497, 492, 359,
    492, 497, 498,
    498, 493, 492,
    493, 498, 499,
    499, 494, 493,
    494, 499, 500,
    500, 495, 494,
    495, 500, 501,
    501, 496, 495,
    496, 501, 461,
    365, 371, 502,
    502, 497, 365,
    497, 502, 503,
    503, 498, 497,
    498, 503, 504,
    504, 499, 498,
    499, 504, 505,
    505, 500, 499,
    500, 505, 506,
    506, 501, 500,
    501, 506, 461,
    371, 377, 507,
    507, 502, 371,
    502, 507, 508,
    508, 503, 502,
    503, 508, 509,
    509, 504, 503,
    504, 509, 510,
    510, 505, 504,
    505, 510, 511,
    511, 506, 505,
    506, 511, 461,
    377, 383, 512,
    512, 507, 377,
    507, 512, 513,
    513, 508, 507,
    508, 513, 514,
    514, 509, 508,
    509, 514, 515,
    515, 510, 509,
    510, 515, 516,
    516, 511, 510,
    511, 516, 461,
    383, 389, 517,
    517, 512, 383,
    512, 517, 518,
    518, 513, 512,
    513, 518, 519,
    519, 514, 513,
    514, 519, 520,
    520, 515, 514,
    515, 520, 521,
    521, 516, 515,
    516, 521, 461,
    389, 395, 522,
    522, 517, 389,
    517, 522, 523,
    523, 518, 517,
    518, 523, 524,
    524, 519, 518,
    519, 524, 525,
    525, 520, 519,
    520, 525, 526,
    526, 521, 520,
    521, 526, 461,
    395, 401, 527,
    527, 522, 395,
    522, 527, 528,
    528, 523, 522,
    523, 528, 529,
    529, 524, 523,
    524, 529, 530,
    530, 525, 524,
    525, 530, 531,
    531, 526, 525,
    526, 531, 461,
    401, 407, 532,
    532, 527, 401,
    527, 532, 533,
    533, 528, 527,
    528, 533, 534,
    534, 529, 528,
    529, 534, 535,
    535, 530, 529,
    530, 535, 536,
    536, 531, 530,
    531, 536, 461,
    407, 413, 537,
    537, 532, 407,
    532, 537, 538,
    538, 533, 532,
    533, 538, 539,
    539, 534, 533,
    534, 539, 540,
    540, 535, 534,
    535, 540, 541,
    541, 536, 535,
    536, 541, 461,
    413, 419, 542,
    542, 537, 413,
    537, 542, 543,
    543, 538, 537,
    538, 543, 544,
    544, 539, 538,
    539, 544, 545,
    545, 540, 539,
    540, 545, 546,
    546, 541, 540,
    541, 546, 461,
    419, 425, 547,
    547, 542, 419,
    542, 547, 548,
    548, 543, 542,
    543, 548, 549,
    549, 544, 543,
    544, 549, 550,
    550, 545, 544,
    545, 550, 551,
    551, 546, 545,
    546, 551, 461,
    425, 431, 552,
    552, 547, 425,
    547, 552, 553,
    553, 548, 547,
    548, 553, 554,
    554, 549, 548,
    549, 554, 555,
    555, 550, 549,
    550, 555, 556,
    556, 551, 550,
    551, 556, 461,
    431, 437, 557,
    557, 552, 431,
    552, 557, 558,
    558, 553, 552,
    553, 558, 559,
    559, 554, 553,
    554, 559, 560,
    560, 555, 554,
    555, 560, 561,
    561, 556, 555,
    556, 561, 461,
    437, 443, 562,
    562, 557, 437,
    557, 562, 563,
    563, 558, 557,
    558, 563, 564,
    564, 559, 558,
    559, 564, 565,
    565, 560, 559,
    560, 565, 566,
    566, 561, 560,
    561, 566, 461,
    443, 449, 567,
    567, 562, 443,
    562, 567, 568,
    568, 563, 562,
    563, 568, 569,
    569, 564, 563,
    564, 569, 570,
    570, 565, 564,
    565, 570, 571,
    571, 566, 565,
    566, 571, 461,
    449, 455, 572,
    572, 567, 449,
    567, 572, 573,
    573, 568, 567,
    568, 573, 574,
    574, 569, 568,
    569, 574, 575,
    575, 570, 569,
    570, 575, 576,
    576, 571, 570,
    571, 576, 461,
    455, 317, 456,
    456, 572, 455,
    572, 456, 457,
    457, 573, 572,
    573, 457, 458,
    458, 574, 573,
    574, 458, 459,
    459, 575, 574,
    575, 459, 460,
    460, 576, 575,
    576, 460, 461,
    577, 584, 585,
    585, 578, 577,
    578, 585, 586,
    586, 579, 578,
    579, 586, 587,
    587, 580, 579,
    580, 587, 588,
    588, 581, 580,
    581, 588, 589,
    589, 582, 581,
    582, 589, 590,
    590, 583, 582,
    584, 591, 592,
    592, 585, 584,
    585, 592, 593,
    593, 586, 585,
    586, 593, 594,
    594, 587, 586,
    587, 594, 595,
    595, 588, 587,
    588, 595, 596,
    596, 589, 588,
    589, 596, 597,
    597, 590, 589,
    591, 598, 599,
    599, 592, 591,
    592, 599, 600,
    600, 593, 592,
    593, 600, 601,
    601, 594, 593,
    594, 601, 602,
    602, 595, 594,
    595, 602, 603,
    603, 596, 595,
    596, 603, 604,
    604, 597, 596,
    598, 605, 606,
    606, 599, 598,
    599, 606, 607,
    607, 600, 599,
    600, 607, 608,
    608, 601, 600,
    601, 608, 609,
    609, 602, 601,
    602, 609, 610,
    610, 603, 602,
    603, 610, 611,
    611, 604, 603,
    605, 612, 613,
    613, 606, 605,
    606, 613, 614,
    614, 607, 606,
    607, 614, 615,
    615, 608, 607,
    608, 615, 616,
    616, 609, 608,
    609, 616, 617,
    617, 610, 609,
    610, 617, 618,
    618, 611, 610,
    612, 619, 620,
    620, 613, 612,
    613, 620, 621,
    621, 614, 613,
    614, 621, 622,
    622, 615, 614,
    615, 622, 623,
    623, 616, 615,
    616, 623, 624,
    624, 617, 616,
    617, 624, 625,
    625, 618, 617,
    619, 626, 627,
    627, 620, 619,
    620, 627, 628,
    628, 621, 620,
    621, 628, 629,
    629, 622, 621,
    622, 629, 630,
    630, 623, 622,
    623, 630, 631,
    631, 624, 623,
    624, 631, 632,
    632, 625, 624,
    626, 633, 634,
    634, 627, 626,
    627, 634, 635,
    635, 628, 627,
    628, 635, 636,
    636, 629, 628,
    629, 636, 637,
    637, 630, 629,
    630, 637, 638,
    638, 631, 630,
    631, 638, 639,
    639, 632, 631,
    633, 640, 641,
    641, 634, 633,
    634, 641, 642,
    642, 635, 634,
    635, 642, 643,
    643, 636, 635,
    636, 643, 644,
    644, 637, 636,
    637, 644, 645,
    645, 638, 637,
    638, 645, 646,
    646, 639, 638,
    640, 647, 648,
    648, 641, 640,
    641, 648, 649,
    649, 642, 641,
    642, 649, 650,
    650, 643, 642,
    643, 650, 651,
    651, 644, 643,
    644, 651, 652,
    652, 645, 644,
    645, 652, 653,
    653, 646, 645,
    647, 654, 655,
    655, 648, 647,
    648, 655, 656,
    656, 649, 648,
    649, 656, 657,
    657, 650, 649,
    650, 657, 658,
    658, 651, 650,
    651, 658, 659,
    659, 652, 651,
    652, 659, 660,
    660, 653, 652,
    654, 577, 578,
    578, 655, 654,
    655, 578, 579,
    579, 656, 655,
    656, 579, 580,
    580, 657, 656,
    657, 580, 581,
    581, 658, 657,
    658, 581, 582,
    582, 659, 658,
    659, 582, 583,
    583, 660, 659,
    583, 590, 667,
    667, 661, 583,
    661, 667, 668,
    668, 662, 661,
    662, 668, 669,
    669, 663, 662,
    663, 669, 670,
    670, 664, 663,
    664, 670, 671,
    671, 665, 664,
    665, 671, 672,
    672, 666, 665,
    590, 597, 673,
    673, 667, 590,
    667, 673, 674,
    674, 668, 667,
    668, 674, 675,
    675, 669, 668,
    669, 675, 676,
    676, 670, 669,
    670, 676, 677,
    677, 671, 670,
    671, 677, 678,
    678, 672, 671,
    597, 604, 679,
    679, 673, 597,
    673, 679, 680,
    680, 674, 673,
    674, 680, 681,
    681, 675, 674,
    675, 681, 682,
    682, 676, 675,
    676, 682, 683,
    683, 677, 676,
    677, 683, 684,
    684, 678, 677,
    604, 611, 685,
    685, 679, 604,
    679, 685, 686,
    686, 680, 679,
    680, 686, 687,
    687, 681, 680,
    681, 687, 688,
    688, 682, 681,
    682, 688, 689,
    689, 683, 682,
    683, 689, 690,
    690, 684, 683,
    611, 618, 691,
    691, 685, 611,
    685, 691, 692,
    692, 686, 685,
    686, 692, 693,
    693, 687, 686,
    687, 693, 694,
    694, 688, 687,
    688, 694, 695,
    695, 689, 688,
    689, 695, 696,
    696, 690, 689,
    618, 625, 697,
    697, 691, 618,
    691, 697, 698,
    698, 692, 691,
    692, 698, 699,
    699, 693, 692,
    693, 699, 700,
    700, 694, 693,
    694, 700, 701,
    701, 695, 694,
    695, 701, 702,
    702, 696, 695,
    625, 632, 703,
    703, 697, 625,
    697, 703, 704,
    704, 698, 697,
    698, 704, 705,
    705, 699, 698,
    699, 705, 706,
    706, 700, 699,
    700, 706, 707,
    707, 701, 700,
    701, 707, 708,
    708, 702, 701,
    632, 639, 709,
    709, 703, 632,
    703, 709, 710,
    710, 704, 703,
    704, 710, 711,
    711, 705, 704,
    705, 711, 712,
    712, 706, 705,
    706, 712, 713,
    713, 707, 706,
    707, 713, 714,
    714, 708, 707,
    639, 646, 715,
    715, 709, 639,
    709, 715, 716,
    716, 710, 709,
    710, 716, 717,
    717, 711, 710,
    711, 717, 718,
    718, 712, 711,
    712, 718, 719,
    719, 713, 712,
    713, 719, 720,
    720, 714, 713,
    646, 653, 721,
    721, 715, 646,
    715, 721, 722,
    722, 716, 715,
    716, 722, 723,
    723, 717, 716,
    717, 723, 724,
    724, 718, 717,
    718, 724, 725,
    725, 719, 718,
    719, 725, 726,
    726, 720, 719,
    653, 660, 727,
    727, 721, 653,
    721, 727, 728,
    728, 722, 721,
    722, 728, 729,
    729, 723, 722,
    723, 729, 730,
    730, 724, 723,
    724, 730, 731,
    731, 725, 724,
    725, 731, 732,
    732, 726, 725,
    660, 583, 661,
    661, 727, 660,
    727, 661, 662,
    662, 728, 727,
    728, 662, 663,
    663, 729, 728,
    729, 663, 664,
    664, 730, 729,
    730, 664, 665,
    665, 731, 730,
    731, 665, 666,
    666, 732, 731,
    733, 740, 741,
    741, 734, 733,
    734, 741, 742,
    742, 735, 734,
    735, 742, 743,
    743, 736, 735,
    736, 743, 744,
    744, 737, 736,
    737, 744, 745,
    745, 738, 737,
    738, 745, 746,
    746, 739, 738,
    740, 747, 748,
    748, 741, 740,
    741, 748, 749,
    749, 742, 741,
    742, 749, 750,
    750, 743, 742,
    743, 750, 751,
    751, 744, 743,
    744, 751, 752,
    752, 745, 744,
    745, 752, 753,
    753, 746, 745,
    747, 754, 755,
    755, 748, 747,
    748, 755, 756,
    756, 749, 748,
    749, 756, 757,
    757, 750, 749,
    750, 757, 758,
    758, 751, 750,
    751, 758, 759,
    759, 752, 751,
    752, 759, 760,
    760, 753, 752,
    754, 761, 762,
    762, 755, 754,
    755, 762, 763,
    763, 756, 755,
    756, 763, 764,
    764, 757, 756,
    757, 764, 765,
    765, 758, 757,
    758, 765, 766,
    766, 759, 758,
    759, 766, 767,
    767, 760, 759,
    761, 768, 769,
    769, 762, 761,
    762, 769, 770,
    770, 763, 762,
    763, 770, 771,
    771, 764, 763,
    764, 771, 772,
    772, 765, 764,
    765, 772, 773,
    773, 766, 765,
    766, 773, 774,
    774, 767, 766,
    768, 775, 776,
    776, 769, 768,
    769, 776, 777,
    777, 770, 769,
    770, 777, 778,
    778, 771, 770,
    771, 778, 779,
    779, 772, 771,
    772, 779, 780,
    780, 773, 772,
    773, 780, 781,
    781, 774, 773,
    775, 782, 783,
    783, 776, 775,
    776, 783, 784,
    784, 777, 776,
    777, 784, 785,
    785, 778, 777,
    778, 785, 786,
    786, 779, 778,
    779, 786, 787,
    787, 780, 779,
    780, 787, 788,
    788, 781, 780,
    782, 789, 790,
    790, 783, 782,
    783, 790, 791,
    791, 784, 783,
    784, 791, 792,
    792, 785, 784,
    785, 792, 793,
    793, 786, 785,
    786, 793, 794,
    794, 787, 786,
    787, 794, 795,
    795, 788, 787,
    789, 796, 797,
    797, 790, 789,
    790, 797, 798,
    798, 791, 790,
    791, 798, 799,
    799, 792, 791,
    792, 799, 800,
    800, 793, 792,
    793, 800, 801,
    801, 794, 793,
    794, 801, 802,
    802, 795, 794,
    796, 803, 804,
    804, 797, 796,
    797, 804, 805,
    805, 798, 797,
    798, 805, 806,
    806, 799, 798,
    799, 806, 807,
    807, 800, 799,
    800, 807, 808,
    808, 801, 800,
    801, 808, 809,
    809, 802, 801,
    803, 810, 811,
    811, 804, 803,
    804, 811, 812,
    812, 805, 804,
    805, 812, 813,
    813, 806, 805,
    806, 813, 814,
    814, 807, 806,
    807, 814, 815,
    815, 808, 807,
    808, 815, 816,
    816, 809, 808,
    810, 733, 734,
    734, 811, 810,
    811, 734, 735,
    735, 812, 811,
    812, 735, 736,
    736, 813, 812,
    813, 736, 737,
    737, 814, 813,
    814, 737, 738,
    738, 815, 814,
    815, 738, 739,
    739, 816, 815,
    739, 746, 823,
    823, 817, 739,
    817, 823, 824,
    824, 818, 817,
    818, 824, 825,
    825, 819, 818,
    819, 825, 826,
    826, 820, 819,
    820, 826, 827,
    827, 821, 820,
    821, 827, 828,
    828, 822, 821,
    746, 753, 829,
    829, 823, 746,
    823, 829, 830,
    830, 824, 823,
    824, 830, 831,
    831, 825, 824,
    825, 831, 832,
    832, 826, 825,
    826, 832, 833,
    833, 827, 826,
    827, 833, 834,
    834, 828, 827,
    753, 760, 835,
    835, 829, 753,
    829, 835, 836,
    836, 830, 829,
    830, 836, 837,
    837, 831, 830,
    831, 837, 838,
    838, 832, 831,
    832, 838, 839,
    839, 833, 832,
    833, 839, 840,
    840, 834, 833,
    760, 767, 841,
    841, 835, 760,
    835, 841, 842,
    842, 836, 835,
    836, 842, 843,
    843, 837, 836,
    837, 843, 844,
    844, 838, 837,
    838, 844, 845,
    845, 839, 838,
    839, 845, 846,
    846, 840, 839,
    767, 774, 847,
    847, 841, 767,
    841, 847, 848,
    848, 842, 841,
    842, 848, 849,
    849, 843, 842,
    843, 849, 850,
    850, 844, 843,
    844, 850, 851,
    851, 845, 844,
    845, 851, 852,
    852, 846, 845,
    774, 781, 853,
    853, 847, 774,
    847, 853, 854,
    854, 848, 847,
    848, 854, 855,
    855, 849, 848,
    849, 855, 856,
    856, 850, 849,
    850, 856, 857,
    857, 851, 850,
    851, 857, 858,
    858, 852, 851,
    781, 788, 859,
    859, 853, 781,
    853, 859, 860,
    860, 854, 853,
    854, 860, 861,
    861, 855, 854,
    855, 861, 862,
    862, 856, 855,
    856, 862, 863,
    863, 857, 856,
    857, 863, 864,
    864, 858, 857,
    788, 795, 865,
    865, 859, 788,
    859, 865, 866,
    866, 860, 859,
    860, 866, 867,
    867, 861, 860,
    861, 867, 868,
    868, 862, 861,
    862, 868, 869,
    869, 863, 862,
    863, 869, 870,
    870, 864, 863,
    795, 802, 871,
    871, 865, 795,
    865, 871, 872,
    872, 866, 865,
    866, 872, 873,
    873, 867, 866,
    867, 873, 874,
    874, 868, 867,
    868, 874, 875,
    875, 869, 868,
    869, 875, 876,
    876, 870, 869,
    802, 809, 877,
    877, 871, 802,
    871, 877, 878,
    878, 872, 871,
    872, 878, 879,
    879, 873, 872,
    873, 879, 880,
    880, 874, 873,
    874, 880, 881,
    881, 875, 874,
    875, 881, 882,
    882, 876, 875,
    809, 816, 883,
    883, 877, 809,
    877, 883, 884,
    884, 878, 877,
    878, 884, 885,
    885, 879, 878,
    879, 885, 886,
    886, 880, 879,
    880, 886, 887,
    887, 881, 880,
    881, 887, 888,
    888, 882, 881,
    816, 739, 817,
    817, 883, 816,
    883, 817, 818,
    818, 884, 883,
    884, 818, 819,
    819, 885, 884,
    885, 819, 820,
    820, 886, 885,
    886, 820, 821,
    821, 887, 886,
    887, 821, 822,
    822, 888, 887,
    896, 890, 889,
    890, 896, 897,
    897, 891, 890,
    891, 897, 898,
    898, 892, 891,
    892, 898, 899,
    899, 893, 892,
    893, 899, 900,
    900, 894, 893,
    894, 900, 901,
    901, 895, 894,
    902, 896, 889,
    896, 902, 903,
    903, 897, 896,
    897, 903, 904,
    904, 898, 897,
    898, 904, 905,
    905, 899, 898,
    899, 905, 906,
    906, 900, 899,
    900, 906, 907,
    907, 901, 900,
    908, 902, 889,
    902, 908, 909,
    909, 903, 902,
    903, 909, 910,
    910, 904, 903,
    904, 910, 911,
    911, 905, 904,
    905, 911, 912,
    912, 906, 905,
    906, 912, 913,
    913, 907, 906,
    914, 908, 889,
    908, 914, 915,
    915, 909, 908,
    909, 915, 916,
    916, 910, 909,
    910, 916, 917,
    917, 911, 910,
    911, 917, 918,
    918, 912, 911,
    912, 918, 919,
    919, 913, 912,
    920, 914, 889,
    914, 920, 921,
    921, 915, 914,
    915, 921, 922,
    922, 916, 915,
    916, 922, 923,
    923, 917, 916,
    917, 923, 924,
    924, 918, 917,
    918, 924, 925,
    925, 919, 918,
    926, 920, 889,
    920, 926, 927,
    927, 921, 920,
    921, 927, 928,
    928, 922, 921,
    922, 928, 929,
    929, 923, 922,
    923, 929, 930,
    930, 924, 923,
    924, 930, 931,
    931, 925, 924,
    932, 926, 889,
    926, 932, 933,
    933, 927, 926,
    927, 933, 934,
    934, 928, 927,
    928, 934, 935,
    935, 929, 928,
    929, 935, 936,
    936, 930, 929,
    930, 936, 937,
    937, 931, 930,
    938, 932, 889,
    932, 938, 939,
    939, 933, 932,
    933, 939, 940,
    940, 934, 933,
    934, 940, 941,
    941, 935, 934,
    935, 941, 942,
    942, 936, 935,
    936, 942, 943,
    943, 937, 936,
    944, 938, 889,
    938, 944, 945,
    945, 939, 938,
    939, 945, 946,
    946, 940, 939,
    940, 946, 947,
    947, 941, 940,
    941, 947, 948,
    948, 942, 941,
    942, 948, 949,
    949, 943, 942,
    950, 944, 889,
    944, 950, 951,
    951, 945, 944,
    945, 951, 952,
    952, 946, 945,
    946, 952, 953,
    953, 947, 946,
    947, 953, 954,
    954, 948, 947,
    948, 954, 955,
    955, 949, 948,
    956, 950, 889,
    950, 956, 957,
    957, 951, 950,
    951, 957, 958,
    958, 952, 951,
    952, 958, 959,
    959, 953, 952,
    953, 959, 960,
    960, 954, 953,
    954, 960, 961,
    961, 955, 954,
    962, 956, 889,
    956, 962, 963,
    963, 957, 956,
    957, 963, 964,
    964, 958, 957,
    958, 964, 965,
    965, 959, 958,
    959, 965, 966,
    966, 960, 959,
    960, 966, 967,
    967, 961, 960,
    968, 962, 889,
    962, 968, 969,
    969, 963, 962,
    963, 969, 970,
    970, 964, 963,
    964, 970, 971,
    971, 965, 964,
    965, 971, 972,
    972, 966, 965,
    966, 972, 973,
    973, 967, 966,
    974, 968, 889,
    968, 974, 975,
    975, 969, 968,
    969, 975, 976,
    976, 970, 969,
    970, 976, 977,
    977, 971, 970,
    971, 977, 978,
    978, 972, 971,
    972, 978, 979,
    979, 973, 972,
    980, 974, 889,
    974, 980, 981,
    981, 975, 974,
    975, 981, 982,
    982, 976, 975,
    976, 982, 983,
    983, 977, 976,
    977, 983, 984,
    984, 978, 977,
    978, 984, 985,
    985, 979, 978,
    986, 980, 889,
    980, 986, 987,
    987, 981, 980,
    981, 987, 988,
    988, 982, 981,
    982, 988, 989,
    989, 983, 982,
    983, 989, 990,
    990, 984, 983,
    984, 990, 991,
    991, 985, 984,
    992, 986, 889,
    986, 992, 993,
    993, 987, 986,
    987, 993, 994,
    994, 988, 987,
    988, 994, 995,
    995, 989, 988,
    989, 995, 996,
    996, 990, 989,
    990, 996, 997,
    997, 991, 990,
    998, 992, 889,
    992, 998, 999,
    999, 993, 992,
    993, 999, 1000,
    1000, 994, 993,
    994, 1000, 1001,
    1001, 995, 994,
    995, 1001, 1002,
    1002, 996, 995,
    996, 1002, 1003,
    1003, 997, 996,
    1004, 998, 889,
    998, 1004, 1005,
    1005, 999, 998,
    999, 1005, 1006,
    1006, 1000, 999,
    1000, 1006, 1007,
    1007, 1001, 1000,
    1001, 1007, 1008,
    1008, 1002, 1001,
    1002, 1008, 1009,
    1009, 1003, 1002,
    1010, 1004, 889,
    1004, 1010, 1011,
    1011, 1005, 1004,
    1005, 1011, 1012,
    1012, 1006, 1005,
    1006, 1012, 1013,
    1013, 1007, 1006,
    1007, 1013, 1014,
    1014, 1008, 1007,
    1008, 1014, 1015,
    1015, 1009, 1008,
    1016, 1010, 889,
    1010, 1016, 1017,
    1017, 1011, 1010,
    1011, 1017, 1018,
    1018, 1012, 1011,
    1012, 1018, 1019,
    1019, 1013, 1012,
    1013, 1019, 1020,
    1020, 1014, 1013,
    1014, 1020, 1021,
    1021, 1015, 1014,
    1022, 1016, 889,
    1016, 1022, 1023,
    1023, 1017, 1016,
    1017, 1023, 1024,
    1024, 1018, 1017,
    1018, 1024, 1025,
    1025, 1019, 1018,
    1019, 1025, 1026,
    1026, 1020, 1019,
    1020, 1026, 1027,
    1027, 1021, 1020,
    1028, 1022, 889,
    1022, 1028, 1029,
    1029, 1023, 1022,
    1023, 1029, 1030,
    1030, 1024, 1023,
    1024, 1030, 1031,
    1031, 1025, 1024,
    1025, 1031, 1032,
    1032, 1026, 1025,
    1026, 1032, 1033,
    1033, 1027, 1026,
    890, 1028, 889,
    1028, 890, 891,
    891, 1029, 1028,
    1029, 891, 892,
    892, 1030, 1029,
    1030, 892, 893,
    893, 1031, 1030,
    1031, 893, 894,
    894, 1032, 1031,
    1032, 894, 895,
    895, 1033, 1032,
    895, 901, 1040,
    1040, 1034, 895,
    1034, 1040, 1041,
    1041, 1035, 1034,
    1035, 1041, 1042,
    1042, 1036, 1035,
    1036, 1042, 1043,
    1043, 1037, 1036,
    1037, 1043, 1044,
    1044, 1038, 1037,
    1038, 1044, 1045,
    1045, 1039, 1038,
    901, 907, 1046,
    1046, 1040, 901,
    1040, 1046, 1047,
    1047, 1041, 1040,
    1041, 1047, 1048,
    1048, 1042, 1041,
    1042, 1048, 1049,
    1049, 1043, 1042,
    1043, 1049, 1050,
    1050, 1044, 1043,
    1044, 1050, 1051,
    1051, 1045, 1044,
    907, 913, 1052,
    1052, 1046, 907,
    1046, 1052, 1053,
    1053, 1047, 1046,
    1047, 1053, 1054,
    1054, 1048, 1047,
    1048, 1054, 1055,
    1055, 1049, 1048,
    1049, 1055, 1056,
    1056, 1050, 1049,
    1050, 1056, 1057,
    1057, 1051, 1050,
    913, 919, 1058,
    1058, 1052, 913,
    1052, 1058, 1059,
    1059, 1053, 1052,
    1053, 1059, 1060,
    1060, 1054, 1053,
    1054, 1060, 1061,
    1061, 1055, 1054,
    1055, 1061, 1062,
    1062, 1056, 1055,
    1056, 1062, 1063,
    1063, 1057, 1056,
    919, 925, 1064,
    1064, 1058, 919,
    1058, 1064, 1065,
    1065, 1059, 1058,
    1059, 1065, 1066,
    1066, 1060, 1059,
    1060, 1066, 1067,
    1067, 1061, 1060,
    1061, 1067, 1068,
    1068, 1062, 1061,
    1062, 1068, 1069,
    1069, 1063, 1062,
    925, 931, 1070,
    1070, 1064, 925,
    1064, 1070, 1071,
    1071, 1065, 1064,
    1065, 1071, 1072,
    1072, 1066, 1065,
    1066, 1072, 1073,
    1073, 1067, 1066,
    1067, 1073, 1074,
    1074, 1068, 1067,
    1068, 1074, 1075,
    1075, 1069, 1068,
    931, 937, 1076,
    1076, 1070, 931,
    1070, 1076, 1077,
    1077, 1071, 1070,
    1071, 1077, 1078,
    1078, 1072, 1071,
    1072, 1078, 1079,
    1079, 1073, 1072,
    1073, 1079, 1080,
    1080, 1074, 1073,
    1074, 1080, 1081,
    1081, 1075, 1074,
    937, 943, 1082,
    1082, 1076, 937,
    1076, 1082, 1083,
    1083, 1077, 1076,
    1077, 1083, 1084,
    1084, 1078, 1077,
    1078, 1084, 1085,
    1085, 1079, 1078,
    1079, 1085, 1086,
    1086, 1080, 1079,
    1080, 1086, 1087,
    1087, 1081, 1080,
    943, 949, 1088,
    1088, 1082, 943,
    1082, 1088, 1089,
    1089, 1083, 1082,
    1083, 1089, 1090,
    1090, 1084, 1083,
    1084, 1090, 1091,
    1091, 1085, 1084,
    1085, 1091, 1092,
    1092, 1086, 1085,
    1086, 1092, 1093,
    1093, 1087, 1086,
    949, 955, 1094,
    1094, 1088, 949,
    1088, 1094, 1095,
    1095, 1089, 1088,
    1089, 1095, 1096,
    1096, 1090, 1089,
    1090, 1096, 1097,
    1097, 1091, 1090,
    1091, 1097, 1098,
    1098, 1092, 1091,
    1092, 1098, 1099,
    1099, 1093, 1092,
    955, 961, 1100,
    1100, 1094, 955,
    1094, 1100, 1101,
    1101, 1095, 1094,
    1095, 1101, 1102,
    1102, 1096, 1095,
    1096, 1102, 1103,
    1103, 1097, 1096,
    1097, 1103, 1104,
    1104, 1098, 1097,
    1098, 1104, 1105,
    1105, 1099, 1098,
    961, 967, 1106,
    1106, 1100, 961,
    1100, 1106, 1107,
    1107, 1101, 1100,
    1101, 1107, 1108,
    1108, 1102, 1101,
    1102, 1108, 1109,
    1109, 1103, 1102,
    1103, 1109, 1110,
    1110, 1104, 1103,
    1104, 1110, 1111,
    1111, 1105, 1104,
    967, 973, 1112,
    1112, 1106, 967,
    1106, 1112, 1113,
    1113, 1107, 1106,
    1107, 1113, 1114,
    1114, 1108, 1107,
    1108, 1114, 1115,
    1115, 1109, 1108,
    1109, 1115, 1116,
    1116, 1110, 1109,
    1110, 1116, 1117,
    1117, 1111, 1110,
    973, 979, 1118,
    1118, 1112, 973,
    1112, 1118, 1119,
    1119, 1113, 1112,
    1113, 1119, 1120,
    1120, 1114, 1113,
    1114, 1120, 1121,
    1121, 1115, 1114,
    1115, 1121, 1122,
    1122, 1116, 1115,
    1116, 1122, 1123,
    1123, 1117, 1116,
    979, 985, 1124,
    1124, 1118, 979,
    1118, 1124, 1125,
    1125, 1119, 1118,
    1119, 1125, 1126,
    1126, 1120, 1119,
    1120, 1126, 1127,
    1127, 1121, 1120,
    1121, 1127, 1128,
    1128, 1122, 1121,
    1122, 1128, 1129,
    1129, 1123, 1122,
    985, 991, 1130,
    1130, 1124, 985,
    1124, 1130, 1131,
    1131, 1125, 1124,
    1125, 1131, 1132,
    1132, 1126, 1125,
    1126, 1132, 1133,
    1133, 1127, 1126,
    1127, 1133, 1134,
    1134, 1128, 1127,
    1128, 1134, 1135,
    1135, 1129, 1128,
    991, 997, 1136,
    1136, 1130, 991,
    1130, 1136, 1137,
    1137, 1131, 1130,
    1131, 1137, 1138,
    1138, 1132, 1131,
    1132, 1138, 1139,
    1139, 1133, 1132,
    1133, 1139, 1140,
    1140, 1134, 1133,
    1134, 1140, 1141,
    1141, 1135, 1134,
    997, 1003, 1142,
    1142, 1136, 997,
    1136, 1142, 1143,
    1143, 1137, 1136,
    1137, 1143, 1144,
    1144, 1138, 1137,
    1138, 1144, 1145,
    1145, 1139, 1138,
    1139, 1145, 1146,
    1146, 1140, 1139,
    1140, 1146, 1147,
    1147, 1141, 1140,
    1003, 1009, 1148,
    1148, 1142, 1003,
    1142, 1148, 1149,
    1149, 1143, 1142,
    1143, 1149, 1150,
    1150, 1144, 1143,
    1144, 1150, 1151,
    1151, 1145, 1144,
    1145, 1151, 1152,
    1152, 1146, 1145,
    1146, 1152, 1153,
    1153, 1147, 1146,
    1009, 1015, 1154,
    1154, 1148, 1009,
    1148, 1154, 1155,
    1155, 1149, 1148,
    1149, 1155, 1156,
    1156, 1150, 1149,
    1150, 1156, 1157,
    1157, 1151, 1150,
    1151, 1157, 1158,
    1158, 1152, 1151,
    1152, 1158, 1159,
    1159, 1153, 1152,
    1015, 1021, 1160,
    1160, 1154, 1015,
    1154, 1160, 1161,
    1161, 1155, 1154,
    1155, 1161, 1162,
    1162, 1156, 1155,
    1156, 1162, 1163,
    1163, 1157, 1156,
    1157, 1163, 1164,
    1164, 1158, 1157,
    1158, 1164, 1165,
    1165, 1159, 1158,
    1021, 1027, 1166,
    1166, 1160, 1021,
    1160, 1166, 1167,
    1167, 1161, 1160,
    1161, 1167, 1168,
    1168, 1162, 1161,
    1162, 1168, 1169,
    1169, 1163, 1162,
    1163, 1169, 1170,
    1170, 1164, 1163,
    1164, 1170, 1171,
    1171, 1165, 1164,
    1027, 1033, 1172,
    1172, 1166, 1027,
    1166, 1172, 1173,
    1173, 1167, 1166,
    1167, 1173, 1174,
    1174, 1168, 1167,
    1168, 1174, 1175,
    1175, 1169, 1168,
    1169, 1175, 1176,
    1176, 1170, 1169,
    1170, 1176, 1177,
    1177, 1171, 1170,
    1033, 895, 1034,
    1034, 1172, 1033,
    1172, 1034, 1035,
    1035, 1173, 1172,
    1173, 1035, 1036,
    1036, 1174, 1173,
    1174, 1036, 1037,
    1037, 1175, 1174,
    1175, 1037, 1038,
    1038, 1176, 1175,
    1176, 1038, 1039,
    1039, 1177, 1176,
};

// Default "Truncating double to float" warning
#pragma warning(default: 4305)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\tex\CD3DXBlt.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXBlt.cpp
//  Content:    Blitter
//
///////////////////////////////////////////////////////////////////////////

#include "pchtex.h"


///////////////////////////////////////////////////////////////////////////
// CD3DXBlt ///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

CD3DXBlt::CD3DXBlt()
{
    m_pDest = NULL;
    m_pSrc  = NULL;
}


CD3DXBlt::~CD3DXBlt()
{
    if(m_pDest)
        delete m_pDest;

    if(m_pSrc)
        delete m_pSrc;
}

HRESULT CD3DXBlt::Blt(D3DX_BLT* pDestBlt, D3DX_BLT* pSrcBlt, DWORD dwFilter)
{
    HRESULT hr;

    m_pDest = NULL;
    m_pSrc  = NULL;
    m_dwFilter = dwFilter;


    // Validate filter
    switch(dwFilter & 0xffff)
    {
    case D3DX_FILTER_NONE:
    case D3DX_FILTER_POINT:
    case D3DX_FILTER_LINEAR:
    case D3DX_FILTER_TRIANGLE:
    case D3DX_FILTER_BOX:
        break;

    default:
        DPF(0, "Invalid image filter");
        return D3DERR_INVALIDCALL;
    }

    if(dwFilter & (0xffff0000 & ~(D3DX_FILTER_MIRROR | D3DX_FILTER_DITHER)))
    {
        DPF(0, "Invalid image filter");
        return D3DERR_INVALIDCALL;
    }

    pDestBlt->bDither = (dwFilter & D3DX_FILTER_DITHER);


    // Find codecs
    if(!(m_pDest = CD3DXCodec::Create(pDestBlt)) ||
       !(m_pSrc  = CD3DXCodec::Create(pSrcBlt)))
    {
        DPF(0, "Unsupported image format");
        hr = E_FAIL;
        goto LDone;
    }


    // Make sure compatible image types
    if(m_pDest->m_dwType != m_pSrc->m_dwType)
    {
        DPF(0, "No conversion exists between source and destination image formats");
        hr = E_FAIL;
        goto LDone;
    }


    // Find blitter
    if(FAILED(BltSame()) &&
       FAILED(BltCopy()) &&
       FAILED(BltNone()) &&
       FAILED(BltPoint()) &&
       FAILED(BltBox2D()) &&
       FAILED(BltBox3D()) &&
       FAILED(BltLinear2D()) &&
       FAILED(BltLinear3D()) &&
       FAILED(BltTriangle2D()) &&
       FAILED(BltTriangle3D()))
    {
        DPF(0, "No suitable image filter found");
        hr = E_FAIL;
        goto LDone;
    }

    hr = S_OK;
    goto LDone;

LDone:
    if(m_pDest)
    {
        delete m_pDest;
        m_pDest = NULL;
    }

    if(m_pSrc)
    {
        delete m_pSrc;
        m_pSrc = NULL;
    }

    return hr;
}



HRESULT CD3DXBlt::BltSame()
{
    if(m_pDest->m_Format != m_pSrc->m_Format)
        return E_FAIL;

    if(m_pSrc->m_bColorKey)
        return E_FAIL;

    if(m_pDest->m_uWidth  != m_pSrc->m_uWidth || 
       m_pDest->m_uHeight != m_pSrc->m_uHeight ||
       m_pDest->m_uDepth  != m_pSrc->m_uDepth)
    {
        return E_FAIL;
    }

    if(!m_pDest->m_bLinear)
        return BltSame_DXTn();

    if(m_pDest->m_bPalettized && m_pDest->m_pPalette != m_pSrc->m_pPalette && 
        memcmp(m_pDest->m_pPalette, m_pSrc->m_pPalette, 256 * sizeof(PALETTEENTRY)))
    {
        return E_FAIL;
    }



    for(UINT uZ = 0; uZ < m_pDest->m_uDepth; uZ++)
    {
        BYTE *pbDest = m_pDest->m_pbData + uZ * m_pDest->m_uSlice;
        BYTE *pbSrc  = m_pSrc ->m_pbData + uZ * m_pSrc ->m_uSlice;

        for(UINT uY = 0; uY < m_pDest->m_uHeight; uY++)
        {
            memcpy(pbDest, pbSrc, m_pDest->m_uWidthBytes);

            pbDest += m_pDest->m_uPitch;
            pbSrc  += m_pSrc ->m_uPitch;
        }
    }

    return S_OK;
}


HRESULT CD3DXBlt::BltCopy()
{
    D3DXCOLOR *pColor;

    if(m_pDest->m_uWidth  != m_pSrc->m_uWidth || 
       m_pDest->m_uHeight != m_pSrc->m_uHeight ||
       m_pDest->m_uDepth  != m_pSrc->m_uDepth)
    {
        return E_FAIL;
    }

    if(!(pColor = new D3DXCOLOR[m_pDest->m_uWidth]))
        return E_FAIL;

//  DPF(0, "blt copy %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    for(UINT uZ = 0; uZ < m_pDest->m_uDepth; uZ++)
    {
        for(UINT uY = 0; uY < m_pDest->m_uHeight; uY++)
        {
            m_pSrc ->Decode(uY, uZ, pColor);
            m_pDest->Encode(uY, uZ, pColor);
        }
    }

    delete [] pColor;
    return S_OK;
}


HRESULT CD3DXBlt::BltNone()
{
    UINT uWidthMax, uWidthMin, uHeightMin, uDepthMin, uX, uY, uZ;

    D3DXCOLOR *pColor;
    D3DXCOLOR *pBlack;

    if((m_dwFilter & 0xff) != D3DX_FILTER_NONE)
        return E_FAIL;

//  DPF(0, "blt none %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    uWidthMax  = (m_pDest->m_uWidth  > m_pSrc->m_uWidth)  ? m_pDest->m_uWidth  : m_pSrc->m_uWidth;
    uWidthMin  = (m_pDest->m_uWidth  < m_pSrc->m_uWidth)  ? m_pDest->m_uWidth  : m_pSrc->m_uWidth;
    uHeightMin = (m_pDest->m_uHeight < m_pSrc->m_uHeight) ? m_pDest->m_uHeight : m_pSrc->m_uHeight;
    uDepthMin  = (m_pDest->m_uDepth  < m_pSrc->m_uDepth)  ? m_pDest->m_uDepth  : m_pSrc->m_uDepth;

    if(!(pColor = new D3DXCOLOR[uWidthMax]))
        return E_FAIL;

    if(!(pBlack = new D3DXCOLOR[m_pDest->m_uWidth]))
    {
        delete [] pColor;
        return E_FAIL;
    }

    memset(pColor, 0x00, uWidthMax * sizeof(D3DXCOLOR));
    memset(pBlack, 0x00, m_pDest->m_uWidth * sizeof(D3DXCOLOR));


    for(uZ = 0; uZ < uDepthMin; uZ++)
    {
        for(uY = 0; uY < uHeightMin; uY++)
        {
            m_pSrc ->Decode(uY, uZ, pColor);
            m_pDest->Encode(uY, uZ, pColor);
        }

        for(uY = uHeightMin; uY < m_pDest->m_uHeight; uY++)
            m_pDest->Encode(uY, uZ, pBlack);
    }

    for(uZ = uDepthMin; uZ < m_pDest->m_uDepth; uZ++)
    {
        for(uY = 0; uY < m_pDest->m_uHeight; uY++)
            m_pDest->Encode(uY, uZ, pBlack);
    }

    delete [] pColor;
    delete [] pBlack;
    return S_OK;
}


HRESULT CD3DXBlt::BltPoint()
{
    D3DXCOLOR *pSrc;
    D3DXCOLOR *pDest;

    if((m_dwFilter & 0xff) != D3DX_FILTER_POINT)
        return E_FAIL;

    if(!(pSrc = new D3DXCOLOR[m_pSrc->m_uWidth]))
        return E_OUTOFMEMORY;

    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
    {
        delete []pSrc;
        return E_OUTOFMEMORY;
    }


//  DPF(0, "blt point %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    UINT uSrcXInc = (m_pSrc->m_uWidth  << 16) / m_pDest->m_uWidth;
    UINT uSrcYInc = (m_pSrc->m_uHeight << 16) / m_pDest->m_uHeight;
    UINT uSrcZInc = (m_pSrc->m_uDepth  << 16) / m_pDest->m_uDepth;

    UINT uSrcZ  = 0;
    UINT uDestZ = 0;

    while(uDestZ < m_pDest->m_uDepth)
    {
        UINT uSrcY  = 0;
        UINT uDestY = 0;
        UINT uSrcYLast = (UINT) -1;

        while(uDestY < m_pDest->m_uHeight)
        {
            UINT uSrcX  = 0;
            UINT uDestX = 0;

            if((uSrcYLast ^ uSrcY) >> 16)
            {
                m_pSrc->Decode(uSrcY >> 16, uSrcZ >> 16, pSrc);
                uSrcYLast = uSrcY;
            }

            while(uDestX < m_pDest->m_uWidth)
            {
                pDest[uDestX] = pSrc[uSrcX >> 16];

                uSrcX += uSrcXInc;
                uDestX++;
            }

            m_pDest->Encode(uDestY, uDestZ, pDest);

            uSrcY += uSrcYInc;
            uDestY++;
        }

        uSrcZ += uSrcZInc;
        uDestZ++;
    }

    delete [] pSrc;
    delete [] pDest;

    return S_OK;
}


HRESULT CD3DXBlt::BltBox2D()
{
    HRESULT hr;

    D3DXCOLOR *pxyz, *pxYz, *pXyz, *pXYz;
    D3DXCOLOR *pSrc, *pDest;

    if((m_dwFilter & 0xff) != D3DX_FILTER_BOX)
        return E_FAIL;

    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if(!(m_pDest->m_uWidth == (m_pSrc->m_uWidth >> 1)) && 
       !(1 == m_pDest->m_uWidth && 1 == m_pSrc->m_uWidth))
    {
        return E_FAIL;
    }

    if(!(m_pDest->m_uHeight == (m_pSrc->m_uHeight >> 1)) && 
       !(1 == m_pDest->m_uHeight && 1 == m_pSrc->m_uHeight))
    {
        return E_FAIL;
    }

    if(!(1 == m_pDest->m_uDepth && 1 == m_pSrc->m_uDepth))
        return E_FAIL;

//  DPF(0, "blt box %d->%d", m_pSrc->m_Format, m_pDest->m_Format);



    // Optimized filters
    if(!(m_dwFilter & D3DX_FILTER_DITHER) && (m_pSrc->m_Format == m_pDest->m_Format) && 
        (m_pSrc->m_uWidth >= 2) && (m_pSrc->m_uHeight >= 2))
    {
        hr = E_NOTIMPL;

        switch(m_pSrc->m_Format)
        {
#if 0
        case D3DFMT_R8G8B8:   hr = BltBox2D_R8G8B8();   break;
        case D3DFMT_R3G3B2:   hr = BltBox2D_R3G3B2();   break;
        case D3DFMT_A8R3G3B2: hr = BltBox2D_A8R3G3B2(); break;
        case D3DFMT_X4R4G4B4: hr = BltBox2D_X4R4G4B4(); break;
        case D3DFMT_A8P8:     hr = BltBox2D_A8P8();     break;
        case D3DFMT_A4L4:     hr = BltBox2D_A4L4();     break;
#endif
        case D3DFMT_A8R8G8B8: hr = BltBox2D_A8R8G8B8(); break;
        case D3DFMT_X8R8G8B8: hr = BltBox2D_X8R8G8B8(); break;
        case D3DFMT_R5G6B5:   hr = BltBox2D_R5G6B5();   break;
        case D3DFMT_X1R5G5B5: hr = BltBox2D_X1R5G5B5(); break;
        case D3DFMT_A1R5G5B5: hr = BltBox2D_A1R5G5B5(); break;
        case D3DFMT_A4R4G4B4: hr = BltBox2D_A4R4G4B4(); break;
        case D3DFMT_A8:       hr = BltBox2D_A8();       break;
        case D3DFMT_P8:       hr = BltBox2D_P8();       break;
        case D3DFMT_L8:       hr = BltBox2D_A8();       break;
        case D3DFMT_A8L8:     hr = BltBox2D_A8L8();     break;
        }

        if(SUCCEEDED(hr))
            return S_OK;
    }


    // Generic filter
    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
        return E_OUTOFMEMORY;

    if(1 == m_pSrc->m_uHeight)
    {
        pSrc = new D3DXCOLOR[m_pSrc->m_uWidth];

        pxyz = pSrc;
        pxYz = pxyz;
    }
    else
    {
        pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 2];

        pxyz = pSrc + m_pSrc->m_uWidth * 0;
        pxYz = pSrc + m_pSrc->m_uWidth * 1;
    }

    if(!pSrc)
    {
        delete [] pDest;
        return E_OUTOFMEMORY;
    }

    if(1 == m_pSrc->m_uWidth)
    {
        pXyz = pxyz;
        pXYz = pxYz;
    }
    else
    {
        pXyz = pxyz + 1;
        pXYz = pxYz + 1;
    }


    for(UINT uY = 0; uY < m_pDest->m_uHeight; uY++)
    {
        UINT uY2 = uY << 1;

        m_pSrc->Decode(uY2 + 0, 0, pxyz);

        if(pxYz != pxyz)
            m_pSrc->Decode(uY2 + 1, 0, pxYz);


        for(UINT uX = 0; uX < m_pDest->m_uWidth; uX++)
        {
            UINT uX2 = uX << 1;
            pDest[uX] = (pxyz[uX2] + pXyz[uX2] + pxYz[uX2] + pXYz[uX2]) * 0.25f;
        }

        m_pDest->Encode(uY, 0, pDest);
    }


    delete [] pSrc;
    delete [] pDest;

    return S_OK;
}



HRESULT CD3DXBlt::BltBox3D()
{
    D3DXCOLOR *pxyz, *pxyZ, *pxYz, *pxYZ, *pXyz, *pXyZ, *pXYz, *pXYZ;
    D3DXCOLOR *pSrc, *pDest;

    if((m_dwFilter & 0xff) != D3DX_FILTER_BOX)
        return E_FAIL;

    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if(!(m_pDest->m_uWidth == (m_pSrc->m_uWidth >> 1)) && 
       !(1 == m_pDest->m_uWidth && 1 == m_pSrc->m_uWidth))
    {
        return E_FAIL;
    }

    if(!(m_pDest->m_uHeight == (m_pSrc->m_uHeight >> 1)) && 
       !(1 == m_pDest->m_uHeight && 1 == m_pSrc->m_uHeight))
    {
        return E_FAIL;
    }

    if(!(m_pDest->m_uDepth == (m_pSrc->m_uDepth >> 1)))
        return E_FAIL;

//  DPF(0, "blt box %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
        return E_OUTOFMEMORY;

    if(1 == m_pSrc->m_uHeight)
    {
        pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 2];

        pxyz = pSrc + m_pSrc->m_uWidth * 0;
        pxyZ = pSrc + m_pSrc->m_uWidth * 1;
        pxYz = pxyz;
        pxYZ = pxyZ;
    }
    else
    {
        pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 4];

        pxyz = pSrc + m_pSrc->m_uWidth * 0;
        pxyZ = pSrc + m_pSrc->m_uWidth * 1;
        pxYz = pSrc + m_pSrc->m_uWidth * 2;
        pxYZ = pSrc + m_pSrc->m_uWidth * 3;
    }

    if(!pSrc)
    {
        delete [] pDest;
        return E_OUTOFMEMORY;
    }

    if(1 == m_pSrc->m_uWidth)
    {
        pXyz = pxyz;
        pXyZ = pxyZ;
        pXYz = pxYz;
        pXYZ = pxYZ;
    }
    else
    {
        pXyz = pxyz + 1;
        pXyZ = pxyZ + 1;
        pXYz = pxYz + 1;
        pXYZ = pxYZ + 1;
    }



    for(UINT uZ = 0; uZ < m_pDest->m_uDepth; uZ++)
    {
        UINT uZ2 = uZ << 1;

        for(UINT uY = 0; uY < m_pDest->m_uHeight; uY++)
        {
            UINT uY2 = uY << 1;

            m_pSrc->Decode(uY2 + 0, uZ2 + 0, pxyz);

            if(pxyZ != pxyz)
                m_pSrc->Decode(uY2 + 0, uZ2 + 1, pxyZ);

            if(pxYz != pxyz)
                m_pSrc->Decode(uY2 + 1, uZ2 + 0, pxYz);

            if(pxYZ != pxyZ && pxYZ != pxYz)
                m_pSrc->Decode(uY2 + 1, uZ2 + 1, pxYZ);


            for(UINT uX = 0; uX < m_pDest->m_uWidth; uX++)
            {
                UINT uX2 = uX << 1;

                pDest[uX] = (pxyz[uX2] + pXyz[uX2] + pxyZ[uX2] + pXyZ[uX2] +
                             pxYz[uX2] + pXYz[uX2] + pxYZ[uX2] + pXYZ[uX2]) * 0.125f;
            }

            m_pDest->Encode(uY, uZ, pDest);
        }
    }

    delete [] pSrc;
    delete [] pDest;

    return S_OK;
}



// ---------------------------------------------------------------------------
//
// LF - Linear filter
//
// This section of the code defines a bunch of structures, macros, and
// functions which are used for the linear filter.
//
// ---------------------------------------------------------------------------

struct LF_From
{
    UINT uFrom;
    float fWeight;
};

struct LF_To
{
    LF_From pFrom[2];
};


static UINT8 *
LF_SetupLinear(UINT uSrcLim, UINT uDstLim, BOOL bRepeat)
{
    LF_To *pTo;
    UINT8 *pbFilter;
    
    if(!(pTo = new LF_To[uDstLim]))
        return NULL;

    pbFilter = (UINT8 *) pTo;
    float fScale = (float) uSrcLim / (float) uDstLim;

    F2IBegin();

    for(UINT u = 0; u < uDstLim; u++)
    {
        float fSrc = (float) u * fScale - 0.5f;
        float fSrcFloor = floorf(fSrc);

        int iSrcA = F2I(fSrcFloor);
        int iSrcB = iSrcA + 1;

        if(iSrcA < 0)
            iSrcA = bRepeat ? uSrcLim - 1 : 0;

        if((UINT) iSrcB >= uSrcLim)
            iSrcB = bRepeat ? 0 : uSrcLim - 1;

        pTo->pFrom[0].uFrom   = (UINT) iSrcA;
        pTo->pFrom[0].fWeight = 1.0f - (fSrc - fSrcFloor);

        pTo->pFrom[1].uFrom   = (UINT) iSrcB;
        pTo->pFrom[1].fWeight = 1.0f - pTo->pFrom[0].fWeight;

        pTo++;
    }

    F2IEnd();

    return pbFilter;
}


HRESULT CD3DXBlt::BltLinear2D()
{
    HRESULT hr;

    BOOL bRepeatX;
    BOOL bRepeatY;

    BYTE *pbXFilter = NULL;
    BYTE *pbYFilter = NULL;

    LF_To *pToX;
    LF_To *pToY;

    D3DXCOLOR *pDest = NULL;
    D3DXCOLOR *pSrc  = NULL;
    D3DXCOLOR *pSrcT;
    D3DXCOLOR *pxyz, *pxYz;

    UINT uX;
    UINT uY;
    UINT uFrom0;
    UINT uFrom1;


    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if((m_dwFilter & 0xff) != D3DX_FILTER_LINEAR)
        return E_FAIL;

//  DPF(0, "blt linear %d->%d", m_pSrc->m_Format, m_pDest->m_Format);


    // Create linear filters
    bRepeatX = !(m_dwFilter & D3DX_FILTER_MIRROR_U);
    bRepeatY = !(m_dwFilter & D3DX_FILTER_MIRROR_V);

    pbXFilter = LF_SetupLinear(m_pSrc->m_uWidth,  m_pDest->m_uWidth,  bRepeatX);
    pbYFilter = LF_SetupLinear(m_pSrc->m_uHeight, m_pDest->m_uHeight, bRepeatY);

    if(!pbXFilter || !pbYFilter)
        goto LOutOfMemory;


    // Create temp color space
    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
        goto LOutOfMemory;

    if(!(pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 2]))
        goto LOutOfMemory;

    pxyz = pSrc + m_pSrc->m_uWidth * 0;
    pxYz = pSrc + m_pSrc->m_uWidth * 1;



    uY = 0;
    pToY = (LF_To *) pbYFilter;

    uFrom0 = (UINT) -1;
    uFrom1 = (UINT) -1;

    while(uY < m_pDest->m_uHeight)
    {
        uX = 0;
        pToX = (LF_To *) pbXFilter;

        if(pToY->pFrom[0].uFrom != uFrom0)
        {
            if(pToY->pFrom[0].uFrom != uFrom1)
            {
                uFrom0 = pToY->pFrom[0].uFrom;
                m_pSrc->Decode(uFrom0, 0, pxyz);
            }
            else
            {
                uFrom0 = uFrom1;
                uFrom1 = (UINT) -1;

                pSrcT = pxyz; pxyz = pxYz; pxYz = pSrcT;
            }
        }

        if(pToY->pFrom[1].uFrom != uFrom1)
        {
            uFrom1 = pToY->pFrom[1].uFrom;
            m_pSrc->Decode(uFrom1, 0, pxYz);
        }

        while(uX < m_pDest->m_uWidth)
        {
            pDest[uX] = ((pxyz[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                          pxyz[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[0].fWeight +
                         (pxYz[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                          pxYz[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[1].fWeight);

            pToX++;
            uX++;
        }

        m_pDest->Encode(uY, 0, pDest);

        pToY++;
        uY++;
    }


    hr = S_OK;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    delete [] pbXFilter;
    delete [] pbYFilter;

    delete [] pDest;
    delete [] pSrc;

    return hr;
}




HRESULT CD3DXBlt::BltLinear3D()
{
    HRESULT hr;

    BOOL bRepeatX;
    BOOL bRepeatY;
    BOOL bRepeatZ;

    BYTE *pbXFilter = NULL;
    BYTE *pbYFilter = NULL;
    BYTE *pbZFilter = NULL;

    LF_To *pToX;
    LF_To *pToY;
    LF_To *pToZ;

    D3DXCOLOR *pDest = NULL;
    D3DXCOLOR *pSrc  = NULL;
    D3DXCOLOR *pSrcT;
    D3DXCOLOR *pxyz, *pxYz, *pxyZ, *pxYZ;

    UINT uX;
    UINT uY;
    UINT uZ;
    UINT uFrom0;
    UINT uFrom1;


    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if((m_dwFilter & 0xff) != D3DX_FILTER_LINEAR)
        return E_FAIL;

//  DPF(0, "blt linear %d->%d", m_pSrc->m_Format, m_pDest->m_Format);


    // Create linear filters
    bRepeatX = !(m_dwFilter & D3DX_FILTER_MIRROR_U);
    bRepeatY = !(m_dwFilter & D3DX_FILTER_MIRROR_V);
    bRepeatZ = !(m_dwFilter & D3DX_FILTER_MIRROR_W);

    pbXFilter = LF_SetupLinear(m_pSrc->m_uWidth,  m_pDest->m_uWidth,  bRepeatX);
    pbYFilter = LF_SetupLinear(m_pSrc->m_uHeight, m_pDest->m_uHeight, bRepeatY);
    pbZFilter = LF_SetupLinear(m_pSrc->m_uDepth,  m_pDest->m_uDepth,  bRepeatZ);

    if(!pbXFilter || !pbYFilter || !pbZFilter)
        goto LOutOfMemory;


    // Create temp color space
    if(!(pDest = new D3DXCOLOR[m_pDest->m_uWidth]))
        goto LOutOfMemory;

    if(!(pSrc = new D3DXCOLOR[m_pSrc->m_uWidth * 4]))
        goto LOutOfMemory;

    pxyz = pSrc + m_pSrc->m_uWidth * 0;
    pxYz = pSrc + m_pSrc->m_uWidth * 1;
    pxyZ = pSrc + m_pSrc->m_uWidth * 2;
    pxYZ = pSrc + m_pSrc->m_uWidth * 3;



    uZ = 0;
    pToZ = (LF_To *) pbZFilter;

    while(uZ < m_pDest->m_uDepth)
    {
        uY = 0;
        pToY = (LF_To *) pbYFilter;
        uFrom0 = (UINT) -1;
        uFrom1 = (UINT) -1;


        while(uY < m_pDest->m_uHeight)
        {
            uX = 0;
            pToX = (LF_To *) pbXFilter;

            if(pToY->pFrom[0].uFrom != uFrom0)
            {
                if(pToY->pFrom[0].uFrom != uFrom1)
                {
                    uFrom0 = pToY->pFrom[0].uFrom;

                    m_pSrc->Decode(uFrom0, pToZ->pFrom[0].uFrom, pxyz);
                    m_pSrc->Decode(uFrom0, pToZ->pFrom[1].uFrom, pxyZ);
                }
                else
                {
                    uFrom0 = uFrom1;
                    uFrom1 = (UINT) -1;

                    pSrcT = pxyz; pxyz = pxYz; pxYz = pSrcT;
                    pSrcT = pxyZ; pxyZ = pxYZ; pxYZ = pSrcT;
                }
            }

            if(pToY->pFrom[1].uFrom != uFrom1)
            {
                uFrom1 = pToY->pFrom[1].uFrom;

                m_pSrc->Decode(uFrom1, pToZ->pFrom[0].uFrom, pxYz);
                m_pSrc->Decode(uFrom1, pToZ->pFrom[1].uFrom, pxYZ);
            }


            while(uX < m_pDest->m_uWidth)
            {
                pDest[uX] = ((pxyz[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                              pxyz[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[0].fWeight +
                             (pxYz[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                              pxYz[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[1].fWeight) * pToZ->pFrom[0].fWeight +

                            ((pxyZ[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                              pxyZ[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[0].fWeight +
                             (pxYZ[pToX->pFrom[0].uFrom] * pToX->pFrom[0].fWeight + 
                              pxYZ[pToX->pFrom[1].uFrom] * pToX->pFrom[1].fWeight) * pToY->pFrom[1].fWeight) * pToZ->pFrom[1].fWeight;

                pToX++;
                uX++;
            }

            m_pDest->Encode(uY, uZ, pDest);

            pToY++;
            uY++;
        }

        pToZ++;
        uZ++;
    }


    hr = S_OK;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    delete [] pbXFilter;
    delete [] pbYFilter;
    delete [] pbZFilter;

    delete [] pDest;
    delete [] pSrc;

    return hr;
}




// ---------------------------------------------------------------------------
//
// TF - Triangle filter
//
// This section of the code defines a bunch of structures, macros, and
// functions which are used for the triangle filter.
//
// ---------------------------------------------------------------------------

#define TF_EPSILON 0.00001f

struct TF_To
{
    UINT uTo;           // mapping
    FLOAT fWeight;      // mapping weight
};

struct TF_From
{
    UINT uSize;         // size, in bytes
    TF_To pTo[1];       // may continue past 1
};

struct TF_Filter
{
    UINT uSize;         // size, in bytes
    TF_From pFrom[1];   // may continue past 1
};

struct TF_Row
{
    D3DXCOLOR *pclr;    // row data
    FLOAT fWeight;
    TF_Row *pNext;

    ~TF_Row() {
        delete [] pclr;
        delete pNext;
    }
};


static const UINT TF_uFilterSize = sizeof(TF_Filter) - sizeof(TF_From);
static const UINT TF_uFromSize   = sizeof(TF_From) - sizeof(TF_To);
static const UINT TF_uToSize     = sizeof(TF_To);


//
// Setup a triangle filter.  Each source pixel contriubtes equally to the
// destination image.
//

static UINT8 *
TF_SetupTriangle(UINT uSrcLim, UINT uDstLim, BOOL bRepeat)
{
    if(!uSrcLim || !uDstLim)
        return NULL;


    // Compute scale
    FLOAT fScale = (FLOAT) uDstLim / (FLOAT) uSrcLim;
    FLOAT f2ScaleInv = 0.5f / fScale;



    // Allocate memory needed to describe the filter.
    UINT uSizeMax = TF_uFilterSize + TF_uFromSize + TF_uToSize;
    UINT uRepeat = bRepeat ? 1 : 0;

    for(UINT uSrc = 0; uSrc < uSrcLim; uSrc++)
    {
        FLOAT fSrc = (FLOAT) uSrc - 0.5f;
        FLOAT fDstMin = fSrc * fScale;
        FLOAT fDstLim = fDstMin + fScale;

        uSizeMax += TF_uFromSize + TF_uToSize +
            (UINT) (fDstLim - fDstMin + uRepeat + 1) * TF_uToSize * 2;
    }

    UINT8 *pbFilter = new UINT8[uSizeMax];

    if(!pbFilter)
        return NULL;


    // Initialize filter
    UINT uSize = TF_uFilterSize;

    // Initialize accumulators
    UINT uAccumDst = 0;
    FLOAT fAccumWeight = 0.0f;



    for(uSrc = 0; uSrc < uSrcLim; uSrc++)
    {
        // Initialize TF_From block
        UINT uSizeFrom = uSize;
        TF_From *pFrom = (TF_From *) (pbFilter + uSize);
        uSize += TF_uFromSize;
        D3DXASSERT(uSize <= uSizeMax);


        // For each source pixel, we perform two passes.  During the first
        // pass, we record the influences due to this source pixel as we
        // approach it.  During the second pass, we record the influences
        // as we move away from it.

        for(UINT uPass = 0; uPass < 2; uPass++)
        {
            FLOAT fSrc = ((FLOAT) uSrc + uPass) - 0.5f;

            // Start and end of source pixel, in destination coordinates
            FLOAT fDstMin = fSrc * fScale;
            FLOAT fDstLim = fDstMin + fScale;


            // Clamp source pixel to destination image.
            if(!bRepeat)
            {
                if(fDstMin < 0.0f)
                    fDstMin = 0.0f;
                if(fDstLim > (FLOAT) uDstLim)
                    fDstLim = (FLOAT) uDstLim;
            }

            // Start of first destination pixel
            INT nDst = (INT) floorf(fDstMin);



            while((FLOAT) nDst < fDstLim)
            {
                FLOAT fDst0 = (FLOAT) nDst;
                FLOAT fDst1 = fDst0 + 1.0f;

                UINT uDst;
                if(nDst < 0)
                    uDst = (UINT) nDst + uDstLim;
                else if(nDst >= (INT) uDstLim)
                    uDst = (UINT) nDst - uDstLim;
                else
                    uDst = (UINT) nDst;


                // Save the accumulated weight from uAccumDst if we have moved
                // on to accumulating for the next pixel.

                if(uDst != uAccumDst)
                {
                    if(fAccumWeight > TF_EPSILON)
                    {
                        TF_To *pTo  = (TF_To *) (pbFilter + uSize);
                        uSize += TF_uToSize;

                        D3DXASSERT(uSize <= uSizeMax);

                        pTo->uTo = uAccumDst;
                        pTo->fWeight = fAccumWeight;

                    }

                    fAccumWeight = 0.0f;
                    uAccumDst = uDst;
                }


                // Clip destination pixel to source pixel.
                if(fDst0 < fDstMin)
                    fDst0 = fDstMin;
                if(fDst1 > fDstLim)
                    fDst1 = fDstLim;


                // Calculate average weight over destination pixel.  Since the
                // weight varies linearly, when the average weight is
                // multiplied by the size of the destination pixel, the result
                // is equal to the integral of the weight over this portion of
                // the pixel.

                FLOAT fWeight;
                if(!bRepeat && fSrc < 0.0f)
                    fWeight = 1.0f;
                else if(!bRepeat && fSrc + 1.0f >= (FLOAT) uSrcLim)
                    fWeight = 0.0f;
                else
                    fWeight = (fDst0 + fDst1) * f2ScaleInv - fSrc;

                fAccumWeight += (fDst1 - fDst0) * (uPass ? 1.0f - fWeight : fWeight);
                nDst++;
            }
        }


        // If there is a valid value still in the accumulator, it needs to be
        // written out.

        if(fAccumWeight > TF_EPSILON)
        {
            TF_To *pTo = (TF_To *) (pbFilter + uSize);
            uSize += TF_uToSize;

            D3DXASSERT(uSize <= uSizeMax);

            pTo->uTo = uAccumDst;
            pTo->fWeight = fAccumWeight;
        }

        fAccumWeight = 0.0f;


        // Record TF_From's size
        pFrom->uSize = uSize - uSizeFrom;
    }


    // Record TF_Filter's size
    ((TF_Filter *) pbFilter)->uSize = uSize;

    return pbFilter;
}




HRESULT
CD3DXBlt::BltTriangle2D()
{
    HRESULT hr;
    UINT8 *pbXFilter, *pbYFilter;
    TF_Filter *pXFilter, *pYFilter;
    TF_From *pXFrom, *pYFrom, *pXFromLim, *pYFromLim;
    TF_To *pXTo, *pYTo, *pXToLim, *pYToLim;
    TF_Row *pRow, **ppRowActive, *pRowFree;
    BOOL bRepeatX, bRepeatY;
    UINT uRowsActive;
    UINT uSrcRow;
    D3DXCOLOR *pclrSrc;
    D3DXCOLOR *pclrPal;


    pbXFilter   = NULL;
    pbYFilter   = NULL;
    ppRowActive = NULL;
    pRowFree    = NULL;
    pclrSrc     = NULL;
    pclrPal     = NULL;


//  DPF(0, "blt triangle %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    // Create filters for each axis
    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    if(m_pDest->m_uDepth != 1 || m_pSrc->m_uDepth != 1)
        return E_FAIL;

    bRepeatX = !(m_dwFilter & D3DX_FILTER_MIRROR_U);
    bRepeatY = !(m_dwFilter & D3DX_FILTER_MIRROR_V);

    if(!(pbXFilter = TF_SetupTriangle(m_pSrc->m_uWidth,  m_pDest->m_uWidth,  bRepeatX)) ||
       !(pbYFilter = TF_SetupTriangle(m_pSrc->m_uHeight, m_pDest->m_uHeight, bRepeatY)))
    {
        hr = E_FAIL;
        goto LDone;
    }



    pXFilter = (TF_Filter *) pbXFilter;
    pYFilter = (TF_Filter *) pbYFilter;

    pXFromLim = (TF_From *) ((UINT8 *) pXFilter + pXFilter->uSize);
    pYFromLim = (TF_From *) ((UINT8 *) pYFilter + pYFilter->uSize);


    // Initialize accumulation rows
    if(!(ppRowActive = new TF_Row* [m_pDest->m_uHeight]))
        goto LOutOfMemory;

    memset(ppRowActive, 0, m_pDest->m_uHeight * sizeof(TF_Row *));
    uRowsActive = 0;

    if(!(pclrSrc = new D3DXCOLOR[m_pSrc->m_uWidth]))
        goto LOutOfMemory;



    // Filter image
    uSrcRow = 0;

    for(pYFrom = pYFilter->pFrom; pYFrom < pYFromLim; pYFrom = (TF_From *) pYToLim)
    {
        D3DXCOLOR *pclrSrcX;

        pYToLim = (TF_To *) ((UINT8 *) pYFrom + pYFrom->uSize);

        if(pYFrom->pTo < pYToLim)
        {

            // Create necessary accumulation rows
            for(pYTo = pYFrom->pTo; pYTo < pYToLim; pYTo++)
            {
                if(!(pRow = ppRowActive[pYTo->uTo]))
                {
                    if(pRowFree)
                    {
                        // Reuse a row
                        pRow = pRowFree;
                        pRowFree = pRow->pNext;
                    }
                    else
                    {
                        // Allocate a new row
                        if(!(pRow = new TF_Row))
                            goto LOutOfMemory;

                        if(!(pRow->pclr = new D3DXCOLOR[m_pDest->m_uWidth]))
                        {
                            delete pRow;
                            goto LOutOfMemory;
                        }
                    }

                    memset(pRow->pclr, 0, m_pDest->m_uWidth * sizeof(D3DXCOLOR));
                    pRow->fWeight = 0.0f;
                    pRow->pNext = NULL;

                    ppRowActive[pYTo->uTo] = pRow;
                    uRowsActive++;
                }
            }


            // Read source pixels
            m_pSrc->Decode(uSrcRow, 0, pclrSrc);


            // Process a row from the source image
            pclrSrcX = pclrSrc;
            for(pXFrom = pXFilter->pFrom; pXFrom < pXFromLim; pXFrom = (TF_From *) pXToLim)
            {
                pXToLim = (TF_To *) ((UINT8 *) pXFrom + pXFrom->uSize);

                for(pYTo = pYFrom->pTo; pYTo < pYToLim; pYTo++)
                {
                    pRow = ppRowActive[pYTo->uTo];

                    for(pXTo = pXFrom->pTo; pXTo < pXToLim; pXTo++)
                    {
                        FLOAT fWeight =  pYTo->fWeight * pXTo->fWeight;

                        pRow->pclr[pXTo->uTo].r += pclrSrcX->r * fWeight;
                        pRow->pclr[pXTo->uTo].g += pclrSrcX->g * fWeight;
                        pRow->pclr[pXTo->uTo].b += pclrSrcX->b * fWeight;
                        pRow->pclr[pXTo->uTo].a += pclrSrcX->a * fWeight;
                    }
                }

                pclrSrcX++;
            }


            // Write completed accumulation rows
            for(pYTo = pYFrom->pTo; pYTo < pYToLim; pYTo++)
            {
                pRow = ppRowActive[pYTo->uTo];
                pRow->fWeight += pYTo->fWeight;

                if(pRow->fWeight + TF_EPSILON >= 1.0f)
                {
                    // Write and free row
                    m_pDest->Encode(pYTo->uTo, 0, pRow->pclr);

                    ppRowActive[pYTo->uTo] = NULL;
                    pRow->pNext = pRowFree;
                    pRowFree = pRow;

                    uRowsActive--;
                }
            }
        }

        uSrcRow++;
    }


    // Make sure that all accumulation rows have been written out.  This should
    // only happen if the filter was not constructed correctly.
    if(uRowsActive)
    {
        for(UINT uRow = 0; uRow < m_pDest->m_uHeight; uRow++)
        {
            if(ppRowActive[uRow])
            {
                // Write and delete row
                m_pDest->Encode(uRow, 0, ppRowActive[uRow]->pclr);
                delete ppRowActive[uRow];

                if(--uRowsActive == 0)
                    break;
            }
        }
    }


    hr = S_OK;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    // Clean up
    delete[] ppRowActive;
    delete pRowFree;

    delete [] pbYFilter;
    delete [] pbXFilter;
    delete [] pclrSrc;
    delete [] pclrPal;

    return hr;
}



HRESULT
CD3DXBlt::BltTriangle3D()
{
    HRESULT hr;
    UINT8 *pbXFilter, *pbYFilter, *pbZFilter;
    TF_Filter *pXFilter, *pYFilter, *pZFilter;
    TF_From *pXFrom, *pYFrom, *pZFrom, *pXFromLim, *pYFromLim, *pZFromLim;
    TF_To *pXTo, *pYTo, *pZTo, *pXToLim, *pYToLim, *pZToLim;
    TF_Row *pSlice, **ppSliceActive, *pSliceFree;
    BOOL bRepeatX, bRepeatY, bRepeatZ;
    UINT uSlicesActive;
    UINT uSrcRow, uSrcSlice;
    D3DXCOLOR *pclrSrc;
    D3DXCOLOR *pclrPal;


    pbXFilter     = NULL;
    pbYFilter     = NULL;
    pbZFilter     = NULL;
    ppSliceActive = NULL;
    pSliceFree    = NULL;
    pclrSrc       = NULL;
    pclrPal       = NULL;


//  DPF(0, "blt triangle %d->%d", m_pSrc->m_Format, m_pDest->m_Format);

    // Create filters for each axis
    if(m_pDest->m_dwType != CODEC_RGB || m_pSrc->m_dwType != CODEC_RGB)
        return E_FAIL;

    bRepeatX = !(m_dwFilter & D3DX_FILTER_MIRROR_U);
    bRepeatY = !(m_dwFilter & D3DX_FILTER_MIRROR_V);
    bRepeatZ = !(m_dwFilter & D3DX_FILTER_MIRROR_W);

    if(!(pbXFilter = TF_SetupTriangle(m_pSrc->m_uWidth,  m_pDest->m_uWidth,  bRepeatX)) ||
       !(pbYFilter = TF_SetupTriangle(m_pSrc->m_uHeight, m_pDest->m_uHeight, bRepeatY)) ||
       !(pbZFilter = TF_SetupTriangle(m_pSrc->m_uDepth,  m_pDest->m_uDepth,  bRepeatZ)))
    {
        hr = E_FAIL;
        goto LDone;
    }



    pXFilter = (TF_Filter *) pbXFilter;
    pYFilter = (TF_Filter *) pbYFilter;
    pZFilter = (TF_Filter *) pbZFilter;

    pXFromLim = (TF_From *) ((UINT8 *) pXFilter + pXFilter->uSize);
    pYFromLim = (TF_From *) ((UINT8 *) pYFilter + pYFilter->uSize);
    pZFromLim = (TF_From *) ((UINT8 *) pZFilter + pZFilter->uSize);


    // Initialize accumulation slices
    if(!(ppSliceActive = new TF_Row* [m_pDest->m_uDepth]))
        goto LOutOfMemory;

    memset(ppSliceActive, 0, m_pDest->m_uDepth * sizeof(TF_Row *));
    uSlicesActive = 0;

    if(!(pclrSrc = new D3DXCOLOR[m_pSrc->m_uWidth]))
        goto LOutOfMemory;



    // Filter image
    uSrcSlice = 0;
    for(pZFrom = pZFilter->pFrom; pZFrom < pZFromLim; pZFrom = (TF_From *) pZToLim)
    {
        pZToLim = (TF_To *) ((UINT8 *) pZFrom + pZFrom->uSize);

        // Create necessary accumulation slices
        for(pZTo = pZFrom->pTo; pZTo < pZToLim; pZTo++)
        {
            if(!(pSlice = ppSliceActive[pZTo->uTo]))
            {
                if(pSliceFree)
                {
                    // Reuse a row
                    pSlice = pSliceFree;
                    pSliceFree = pSlice->pNext;
                }
                else
                {
                    // Allocate a new row
                    if(!(pSlice = new TF_Row))
                        goto LOutOfMemory;

                    if(!(pSlice->pclr = new D3DXCOLOR[m_pDest->m_uWidth * m_pDest->m_uHeight]))
                    {
                        delete pSlice;
                        goto LOutOfMemory;
                    }
                }

                memset(pSlice->pclr, 0, m_pDest->m_uWidth * m_pDest->m_uHeight * sizeof(D3DXCOLOR));
                pSlice->fWeight = 0.0f;
                pSlice->pNext = NULL;

                ppSliceActive[pZTo->uTo] = pSlice;
                uSlicesActive++;
            }
        }

        uSrcRow = 0;
        for(pYFrom = pYFilter->pFrom; pYFrom < pYFromLim; pYFrom = (TF_From *) pYToLim)
        {

            pYToLim = (TF_To *) ((UINT8 *) pYFrom + pYFrom->uSize);

            // Read source pixels
            m_pSrc->Decode(uSrcRow, uSrcSlice, pclrSrc);


            // Process a row from the source image
            D3DXCOLOR *pclrSrcX, *pclrDest;
            pclrSrcX = pclrSrc;

            for(pXFrom = pXFilter->pFrom; pXFrom < pXFromLim; pXFrom = (TF_From *) pXToLim)
            {
                pXToLim = (TF_To *) ((UINT8 *) pXFrom + pXFrom->uSize);

                for(pZTo = pZFrom->pTo; pZTo < pZToLim; pZTo++)
                {
                    for(pYTo = pYFrom->pTo; pYTo < pYToLim; pYTo++)
                    {
                        pclrDest = ppSliceActive[pZTo->uTo]->pclr + pYTo->uTo * m_pDest->m_uWidth;

                        for(pXTo = pXFrom->pTo; pXTo < pXToLim; pXTo++)
                        {
                            FLOAT fWeight = pZTo->fWeight * pYTo->fWeight * pXTo->fWeight;

                            pclrDest[pXTo->uTo].r += pclrSrcX->r * fWeight;
                            pclrDest[pXTo->uTo].g += pclrSrcX->g * fWeight;
                            pclrDest[pXTo->uTo].b += pclrSrcX->b * fWeight;
                            pclrDest[pXTo->uTo].a += pclrSrcX->a * fWeight;
                        }
                    }
                }

                pclrSrcX++;
            }

            uSrcRow++;
        }


        // Write completed accumulation slices
        for(pZTo = pZFrom->pTo; pZTo < pZToLim; pZTo++)
        {
            pSlice = ppSliceActive[pZTo->uTo];
            pSlice->fWeight += pZTo->fWeight;

            if(pSlice->fWeight + TF_EPSILON >= 1.0f)
            {
                // Write and free slice                
                for(UINT uRow = 0; uRow < m_pDest->m_uHeight; uRow++)
                    m_pDest->Encode(uRow, pZTo->uTo, pSlice->pclr + uRow * m_pDest->m_uWidth);

                ppSliceActive[pZTo->uTo] = NULL;
                pSlice->pNext = pSliceFree;
                pSliceFree = pSlice;

                uSlicesActive--;
            }
        }

        uSrcSlice++;
    }


    // Make sure that all accumulation slices have been written out.  This should
    // only happen if the filter was not constructed correctly.
    if(uSlicesActive)
    {
        for(UINT uSlice = 0; uSlice < m_pDest->m_uDepth; uSlice++)
        {
            if(ppSliceActive[uSlice])
            {
                // Write and delete slice
                for(UINT uRow = 0; uRow < m_pDest->m_uHeight; uRow++)
                    m_pDest->Encode(uRow, uSlice, pSlice->pclr + uRow * m_pDest->m_uWidth);

                delete ppSliceActive[uSlice];

                if(--uSlicesActive == 0)
                    break;
            }
        }
    }


    hr = S_OK;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    // Clean up
    delete[] ppSliceActive;
    delete pSliceFree;

    delete [] pbZFilter;
    delete [] pbYFilter;
    delete [] pbXFilter;
    delete [] pclrSrc;
    delete [] pclrPal;

    return hr;
}




// ---------------------------------------------------------------------------
//
// Optimized filters
//
// ---------------------------------------------------------------------------


HRESULT CD3DXBlt::BltSame_DXTn()
{
    if((m_pSrc->m_Box.Left  | m_pSrc->m_Box.Top  | m_pSrc->m_Box.Right  | m_pSrc->m_Box.Bottom)  & 3)
        return E_FAIL;

    if((m_pDest->m_Box.Left | m_pDest->m_Box.Top | m_pDest->m_Box.Right | m_pDest->m_Box.Bottom) & 3)
        return E_FAIL;


    // Calculate block size and width
    UINT cbBlock, cbWidth;

    switch(m_pDest->m_Format)
    {
    case D3DFMT_DXT1:
        cbBlock = sizeof(S3TCBlockRGB);
        break;

    case D3DFMT_DXT2:
#if 0
    case D3DFMT_DXT3:
#endif
        cbBlock = sizeof(S3TCBlockAlpha4);
        break;

    case D3DFMT_DXT4:
#if 0
    case D3DFMT_DXT5:
#endif
        cbBlock = sizeof(S3TCBlockAlpha3);
        break;

    default:
        return E_FAIL;
    }


    cbWidth = (m_pDest->m_uWidth >> 2) * cbBlock;


    // Copy DXTn blocks
    BYTE *pbSliceDest = m_pDest->m_pbData + (m_pDest->m_Box.Left >> 2) * cbBlock + 
        (m_pDest->m_Box.Top >> 2) * m_pDest->m_uPitch + m_pDest->m_Box.Front * m_pDest->m_uSlice;

    BYTE *pbSliceSrc = m_pSrc->m_pbData + (m_pSrc->m_Box.Left >> 2) * cbBlock + 
        (m_pSrc->m_Box.Top >> 2) * m_pSrc->m_uPitch + m_pSrc->m_Box.Front * m_pSrc->m_uSlice;


    for(UINT uZ = 0; uZ < m_pDest->m_uDepth; uZ++)
    {
        BYTE *pbDest = pbSliceDest;
        BYTE *pbSrc  = pbSliceSrc;

        for(UINT uY = 0; uY < m_pDest->m_uHeight; uY += 4)
        {
            memcpy(pbDest, pbSrc, cbWidth);

            pbDest += m_pDest->m_uPitch;
            pbSrc  += m_pSrc ->m_uPitch;
        }

        pbSliceDest += m_pDest->m_uSlice;
        pbSliceDest += m_pSrc ->m_uSlice;
    }

    return S_OK;
}



HRESULT 
CD3DXBlt::BltBox2D_R8G8B8()
{
    return E_NOTIMPL;
}


HRESULT 
CD3DXBlt::BltBox2D_A8R8G8B8()
{
    UINT32 *pulDest   = (UINT32 *) m_pDest->m_pbData;
    UINT32 *pulSrc    = (UINT32 *) m_pSrc->m_pbData;
    UINT32 *pulSrcLim = (UINT32 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pulSrc < pulSrcLim)
    {
        UINT32 *pul     = pulDest;
        UINT32 *pulA    = pulSrc;
        UINT32 *pulB    = (UINT32 *) ((BYTE *) pulA + m_pSrc->m_uPitch);
        UINT32 *pulALim = pulA + m_pSrc->m_uWidth;

        while(pulA < pulALim)
        {
            *pul++ = (((((pulA[0] & 0x00ff00ff) + (pulA[1] & 0x00ff00ff) + 
                         (pulB[0] & 0x00ff00ff) + (pulB[1] & 0x00ff00ff)) + 0x00020002) >> 2) & 0x00ff00ff) |

                     (((((pulA[0] & 0xff00ff00) >> 2) + ((pulA[1] & 0xff00ff00) >> 2) +
                        ((pulB[0] & 0xff00ff00) >> 2) + ((pulB[1] & 0xff00ff00) >> 2)) + (0x02000200 >> 2)) & 0xff00ff00);

            pulA += 2;
            pulB += 2;
        }

        pulDest = (UINT32 *) ((BYTE *) pulDest + m_pDest->m_uPitch);
        pulSrc  = (UINT32 *) ((BYTE *) pulSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CD3DXBlt::BltBox2D_X8R8G8B8()
{
    UINT32 *pulDest   = (UINT32 *) m_pDest->m_pbData;
    UINT32 *pulSrc    = (UINT32 *) m_pSrc->m_pbData;
    UINT32 *pulSrcLim = (UINT32 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pulSrc < pulSrcLim)
    {
        UINT32 *pul     = pulDest;
        UINT32 *pulA    = pulSrc;
        UINT32 *pulB    = (UINT32 *) ((BYTE *) pulA + m_pSrc->m_uPitch);
        UINT32 *pulALim = pulA + m_pSrc->m_uWidth;

        while(pulA < pulALim)
        {
            *pul++ = ((((pulA[0] & 0x00ff00ff) + (pulA[1] & 0x00ff00ff) + 
                        (pulB[0] & 0x00ff00ff) + (pulB[1] & 0x00ff00ff) + 0x00020002) & (0x00ff00ff << 2)) |

                      (((pulA[0] & 0x0000ff00) + (pulA[1] & 0x0000ff00) +
                        (pulB[0] & 0x0000ff00) + (pulB[1] & 0x0000ff00) + 0x00000200) & (0x0000ff00 << 2))) >> 2;

            pulA += 2;
            pulB += 2;
        }

        pulDest = (UINT32 *) ((BYTE *) pulDest + m_pDest->m_uPitch);
        pulSrc  = (UINT32 *) ((BYTE *) pulSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CD3DXBlt::BltBox2D_R5G6B5()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0xf81f) + ((UINT32) pusA[1] & 0xf81f) + 
                                  ((UINT32) pusB[0] & 0xf81f) + ((UINT32) pusB[1] & 0xf81f) + 0x1002) & (0xf81f << 2)) |

                                ((((UINT32) pusA[0] & 0x07e0) + ((UINT32) pusA[1] & 0x07e0) + 
                                  ((UINT32) pusB[0] & 0x07e0) + ((UINT32) pusB[1] & 0x07e0) + 0x0040) & (0x07e0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CD3DXBlt::BltBox2D_X1R5G5B5()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x7c1f) + ((UINT32) pusA[1] & 0x7c1f) + 
                                  ((UINT32) pusB[0] & 0x7c1f) + ((UINT32) pusB[1] & 0x7c1f) + 0x0802) & (0x7c1f << 2)) |

                                ((((UINT32) pusA[0] & 0x03e0) + ((UINT32) pusA[1] & 0x03e0) + 
                                  ((UINT32) pusB[0] & 0x03e0) + ((UINT32) pusB[1] & 0x03e0) + 0x0040) & (0x03e0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CD3DXBlt::BltBox2D_A1R5G5B5()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x7c1f) + ((UINT32) pusA[1] & 0x7c1f) + 
                                  ((UINT32) pusB[0] & 0x7c1f) + ((UINT32) pusB[1] & 0x7c1f) + 0x0802) & (0x7c1f << 2)) |

                                ((((UINT32) pusA[0] & 0x83e0) + ((UINT32) pusA[1] & 0x83e0) + 
                                  ((UINT32) pusB[0] & 0x83e0) + ((UINT32) pusB[1] & 0x83e0) + 0x10040) & (0x83e0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CD3DXBlt::BltBox2D_A4R4G4B4()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x0f0f) + ((UINT32) pusA[1] & 0x0f0f) + 
                                  ((UINT32) pusB[0] & 0x0f0f) + ((UINT32) pusB[1] & 0x0f0f) + 0x0202) & (0x0f0f << 2)) |

                                ((((UINT32) pusA[0] & 0xf0f0) + ((UINT32) pusA[1] & 0xf0f0) + 
                                  ((UINT32) pusB[0] & 0xf0f0) + ((UINT32) pusB[1] & 0xf0f0) + 0x2020) & (0xf0f0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CD3DXBlt::BltBox2D_R3G3B2() 
{
#if 0
    UINT8 *pubDest   = (UINT8 *) m_pDest->m_pbData;
    UINT8 *pubSrc    = (UINT8 *) m_pSrc->m_pbData;
    UINT8 *pubSrcLim = (UINT8 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pubSrc < pubSrcLim)
    {
        UINT8 *pub     = pubDest;
        UINT8 *pubA    = pubSrc;
        UINT8 *pubB    = (UINT8 *) ((BYTE *) pubA + m_pSrc->m_uPitch);
        UINT8 *pubALim = pubA + m_pSrc->m_uWidth;

        while(pubA < pubALim)
        {
            *pub++ = (UINT8) ((((((UINT32) pubA[0] & 0xe3) + ((UINT32) pubA[1] & 0xe3) + 
                                 ((UINT32) pubB[0] & 0xe3) + ((UINT32) pubB[1] & 0xe3) + 0x42) & (0xe3 << 2)) |

                               ((((UINT32) pubA[0] & 0x1c) + ((UINT32) pubA[1] & 0x1c) + 
                                 ((UINT32) pubB[0] & 0x1c) + ((UINT32) pubB[1] & 0x1c) + 0x08) & (0x1c << 2))) >> 2);

            pubA += 2;
            pubB += 2;
        }

        pubDest = (UINT8 *) ((BYTE *) pubDest + m_pDest->m_uPitch);
        pubSrc  = (UINT8 *) ((BYTE *) pubSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }
    return S_OK;
#endif
    return E_NOTIMPL;
}


HRESULT 
CD3DXBlt::BltBox2D_A8()
{
    UINT8 *pubDest   = (UINT8 *) m_pDest->m_pbData;
    UINT8 *pubSrc    = (UINT8 *) m_pSrc->m_pbData;
    UINT8 *pubSrcLim = (UINT8 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pubSrc < pubSrcLim)
    {
        UINT8 *pub     = pubDest;
        UINT8 *pubA    = pubSrc;
        UINT8 *pubB    = (UINT8 *) ((BYTE *) pubA + m_pSrc->m_uPitch);
        UINT8 *pubALim = pubA + m_pSrc->m_uWidth;

        while(pubA < pubALim)
        {
            *pub++ = (UINT8) (((UINT32) pubA[0] + (UINT32) pubA[1] + 
                               (UINT32) pubB[0] + (UINT32) pubB[1] + 0x02) >> 2);

            pubA += 2;
            pubB += 2;
        }

        pubDest = (UINT8 *) ((BYTE *) pubDest + m_pDest->m_uPitch);
        pubSrc  = (UINT8 *) ((BYTE *) pubSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CD3DXBlt::BltBox2D_A8R3G3B2()
{
#if 0
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x00e3) + ((UINT32) pusA[1] & 0x00e3) + 
                                  ((UINT32) pusB[0] & 0x00e3) + ((UINT32) pusB[1] & 0x00e3) + 0x0042) & (0x00e3 << 2)) |

                                ((((UINT32) pusA[0] & 0xff1c) + ((UINT32) pusA[1] & 0xff1c) + 
                                  ((UINT32) pusB[0] & 0xff1c) + ((UINT32) pusB[1] & 0xff1c) + 0x0208) & (0xff1c << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }
    return S_OK;
#endif
    return E_NOTIMPL;
}


HRESULT 
CD3DXBlt::BltBox2D_X4R4G4B4()
{
#if 0
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x0f0f) + ((UINT32) pusA[1] & 0x0f0f) + 
                                  ((UINT32) pusB[0] & 0x0f0f) + ((UINT32) pusB[1] & 0x0f0f) + 0x0202) & (0x0f0f << 2)) |

                                ((((UINT32) pusA[0] & 0x00f0) + ((UINT32) pusA[1] & 0x00f0) + 
                                  ((UINT32) pusB[0] & 0x00f0) + ((UINT32) pusB[1] & 0x00f0) + 0x0020) & (0x00f0 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }
    return S_OK;
#endif
    return E_NOTIMPL;
}


HRESULT 
CD3DXBlt::BltBox2D_A8P8()
{
    return E_NOTIMPL;
}


HRESULT 
CD3DXBlt::BltBox2D_P8()
{
    return E_NOTIMPL;
}


HRESULT 
CD3DXBlt::BltBox2D_A8L8()
{
    UINT16 *pusDest   = (UINT16 *) m_pDest->m_pbData;
    UINT16 *pusSrc    = (UINT16 *) m_pSrc->m_pbData;
    UINT16 *pusSrcLim = (UINT16 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pusSrc < pusSrcLim)
    {
        UINT16 *pus     = pusDest;
        UINT16 *pusA    = pusSrc;
        UINT16 *pusB    = (UINT16 *) ((BYTE *) pusA + m_pSrc->m_uPitch);
        UINT16 *pusALim = pusA + m_pSrc->m_uWidth;

        while(pusA < pusALim)
        {
            *pus++ = (UINT16) ((((((UINT32) pusA[0] & 0x00ff) + ((UINT32) pusA[1] & 0x00ff) + 
                                  ((UINT32) pusB[0] & 0x00ff) + ((UINT32) pusB[1] & 0x00ff) + 0x0002) & (0x00ff << 2)) |

                                ((((UINT32) pusA[0] & 0xff00) + ((UINT32) pusA[1] & 0xff00) + 
                                  ((UINT32) pusB[0] & 0xff00) + ((UINT32) pusB[1] & 0xff00) + 0x0200) & (0xff00 << 2))) >> 2);

            pusA += 2;
            pusB += 2;
        }

        pusDest = (UINT16 *) ((BYTE *) pusDest + m_pDest->m_uPitch);
        pusSrc  = (UINT16 *) ((BYTE *) pusSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }

    return S_OK;
}


HRESULT 
CD3DXBlt::BltBox2D_A4L4()
{
#if 0
    UINT8 *pubDest   = (UINT8 *) m_pDest->m_pbData;
    UINT8 *pubSrc    = (UINT8 *) m_pSrc->m_pbData;
    UINT8 *pubSrcLim = (UINT8 *) (m_pSrc->m_pbData + m_pSrc->m_uPitch * m_pSrc->m_uHeight);

    while(pubSrc < pubSrcLim)
    {
        UINT8 *pub     = pubDest;
        UINT8 *pubA    = pubSrc;
        UINT8 *pubB    = (UINT8 *) ((BYTE *) pubA + m_pSrc->m_uPitch);
        UINT8 *pubALim = pubA + m_pSrc->m_uWidth;

        while(pubA < pubALim)
        {
            *pub++ = (UINT8) ((((((UINT32) pubA[0] & 0x0f) + ((UINT32) pubA[1] & 0x0f) + 
                                 ((UINT32) pubB[0] & 0x0f) + ((UINT32) pubB[1] & 0x0f) + 0x02) & (0x0f << 2)) |

                               ((((UINT32) pubA[0] & 0xf0) + ((UINT32) pubA[1] & 0xf0) + 
                                 ((UINT32) pubB[0] & 0xf0) + ((UINT32) pubB[1] & 0xf0) + 0x20) & (0xf0 << 2))) >> 2);

            pubA += 2;
            pubB += 2;
        }

        pubDest = (UINT8 *) ((BYTE *) pubDest + m_pDest->m_uPitch);
        pubSrc  = (UINT8 *) ((BYTE *) pubSrc + m_pSrc->m_uPitch + m_pSrc->m_uPitch);
    }
    return S_OK;
#endif
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\shape\shapes.cpp ===
#include "pchshape.h"


struct VERTEX
{
    D3DXVECTOR3 pos;
    D3DXVECTOR3 norm;
};

#define VERTEX_FVF (D3DFVF_XYZ | D3DFVF_NORMAL)



//
// sincosf - Compute the sin and cos of an angle at the same time
//

static inline void
sincosf(float angle, float *psin, float *pcos)
{
#ifdef _X86_
#define fsincos __asm _emit 0xd9 __asm _emit 0xfb
    __asm {
        mov eax, psin
        mov edx, pcos
        fld angle
        fsincos
        fstp DWORD ptr [edx]
        fstp DWORD ptr [eax]
    }
#undef fsincos
#else //!_X86_
    *psin = sinf(angle);
    *pcos = cosf(angle);
#endif //!_X86_
}



//----------------------------------------------------------------------------
// D3DXCreatePolygon
//----------------------------------------------------------------------------
static void
    MakePolygon(
        VERTEX*             pVertices, 
        WORD*               pwIndices, 
        float               fLength, 
        UINT                uSides)
{
    // Calculate the radius
    float radius = fLength * 0.5f / sinf( D3DX_PI / (float) uSides );
    float angle  = (float) (2.0f * D3DX_PI / (float) uSides);

    // Fill in vertices
    VERTEX *pVertex = pVertices;

    pVertex->pos  = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    pVertex->norm = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
    pVertex++;

    for(UINT j=0; j < uSides; j++)
    {
        float s, c;
        sincosf(angle * j, &s, &c);

        pVertex->pos  = D3DXVECTOR3( c * radius, s * radius, 0.0f );
        pVertex->norm = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
        pVertex++;
    }

    // Fill in indices
    WORD *pwFace = pwIndices;

    for(UINT iFace = 0; iFace < uSides - 1; iFace++)
    {
        pwFace[0] = 0;
        pwFace[1] = iFace + 1;
        pwFace[2] = iFace + 2;

        pwFace += 3;
    }

    // handle the wrapping of the last case
    pwFace[0] = 0;
    pwFace[1] = iFace + 1;
    pwFace[2] = 1;
}


HRESULT WINAPI
    D3DXCreatePolygon( 
        LPDIRECT3DDEVICE8   pDevice, 
        float               fLength, 
        UINT                uSides, 
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency)
{
    HRESULT hr;

    LPD3DXMESH pMesh  = NULL;
    WORD *pwIndices   = NULL;
    VERTEX *pVertices = NULL;


    // Set up the defaults
    if(D3DX_DEFAULT == uSides)
        uSides = 3;
    if(D3DX_DEFAULT_FLOAT == fLength)
        fLength = 1.0f;


    // Validate parameters
    if(!pDevice) 
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!ppMesh)
    {
        DPF(0, "ppMesh pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(fLength < 0.0f)
    {
        DPF(0, "fLength must be >= 0.0f");
        return D3DERR_INVALIDCALL;
    }
    if(uSides < 3)
    {
        DPF(0, "uSides must be >= 3");
        return D3DERR_INVALIDCALL;
    }


    // Create the mesh
    UINT  cFaces    = uSides;
    UINT  cVertices = uSides + 1;

    if(FAILED(hr = D3DXCreateMeshFVF(cFaces, cVertices, D3DXMESH_MANAGED, VERTEX_FVF, pDevice, &pMesh)))
        return hr;

    pMesh->LockVertexBuffer(0, (LPBYTE *) &pVertices);
    pMesh->LockIndexBuffer (0, (LPBYTE *) &pwIndices);

    MakePolygon(pVertices, pwIndices, fLength, uSides);

    pMesh->UnlockVertexBuffer();
    pMesh->UnlockIndexBuffer();   
    
    if (ppAdjacency != NULL)
    {
        hr = D3DXCreateBuffer(cFaces * 3 * sizeof(DWORD), ppAdjacency);
        if (FAILED(hr))
        {
            RELEASE(pMesh);
            return hr;
        }

        hr = pMesh->ConvertPointRepsToAdjacency(NULL, (DWORD*)(*ppAdjacency)->GetBufferPointer());
        if (FAILED(hr))
        {
            RELEASE(pMesh);
            return hr;
        }
    }

    *ppMesh = pMesh;
    return S_OK;
}



//----------------------------------------------------------------------------
// D3DXCreateBox
//----------------------------------------------------------------------------
static float cubeN[6][3] = 
{
    {-1.0f, 0.0f, 0.0f}, {0.0f, 1.0f, 0.0f}, {1.0f, 0.0f, 0.0f},
    {0.0f, -1.0f, 0.0f}, {0.0f, 0.0f, 1.0f}, {0.0f, 0.0f, -1.0f}
};

static WORD cubeF[6][4] = 
{
    { 0, 1, 5, 4 }, { 4, 5, 6, 7 }, { 7, 6, 2, 3 },
    { 1, 0, 3, 2 }, { 1, 2, 6, 5 }, { 0, 4, 7, 3 }
};

static float cubeV[8][3] = 
{
    // Lower tier (lower in y)
    {-.5f, -.5f, -.5f}, 
    {-.5f, -.5f,  .5f}, 
    { .5f, -.5f,  .5f}, 
    { .5f, -.5f, -.5f}, 
    
    // Upper tier
    {-.5f, .5f, -.5f}, 
    {-.5f, .5f,  .5f}, 
    { .5f, .5f,  .5f}, 
    { .5f, .5f, -.5f}, 
};

static float cubeT[4][2] = 
{
    // Lower tier (lower in y)
    {0.0f, 0.0f},
    {0.0f, 1.0f},
    {1.0f, 1.0f},
    {1.0f, 0.0f}
};

static WORD cubeFT[6][4] = 
{
    { 3, 0, 1, 2 }, { 0, 1, 2, 3 }, { 1, 2, 3, 0 },
    { 0, 1, 2, 3 }, { 3, 0, 1, 2 }, { 0, 1, 2, 3 }
};


static void
    MakeBox(
        VERTEX*             pVertices, 
        DWORD*              pPointRep,
        WORD*               pwIndices, 
        float               fWidth, 
        float               fHeight, 
        float               fDepth)
{
    // Fill in the data
    VERTEX *pVertex = pVertices;
    WORD   *pwFace  = pwIndices;
    UINT    iVertex = 0;

    // i iterates over the faces, 2 triangles per face
    for (int i=0; i<6; i++)
    {
        for (int j=0; j<4; j++)
        {
            pVertex->pos.x = cubeV[cubeF[i][j]][0] * fWidth;
            pVertex->pos.y = cubeV[cubeF[i][j]][1] * fHeight;
            pVertex->pos.z = cubeV[cubeF[i][j]][2] * fDepth;

            pVertex->norm.x = cubeN[i][0];
            pVertex->norm.y = cubeN[i][1];
            pVertex->norm.z = cubeN[i][2];

            if (pPointRep != NULL)
            {
                *pPointRep = cubeF[i][j];
                pPointRep++;
            }

            pVertex++;
        }

        pwFace[0] = (WORD) (iVertex);
        pwFace[1] = (WORD) (iVertex + 1);
        pwFace[2] = (WORD) (iVertex + 2);
        pwFace += 3;

        pwFace[0] = (WORD) (iVertex + 2);
        pwFace[1] = (WORD) (iVertex + 3);
        pwFace[2] = (WORD) (iVertex);
        pwFace += 3;

        iVertex += 4;
    }
}


HRESULT WINAPI
    D3DXCreateBox(
        LPDIRECT3DDEVICE8   pDevice, 
        float               fWidth, 
        float               fHeight, 
        float               fDepth, 
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency)
{
    HRESULT hr = S_OK;

    LPD3DXMESH pMesh  = NULL;
    WORD *pwIndices   = NULL;
    VERTEX *pVertices = NULL;
    DWORD *pPointReps = NULL;

    // Set up the defaults
    if(D3DX_DEFAULT_FLOAT == fWidth)
        fWidth = 1.0f;
    if(D3DX_DEFAULT_FLOAT == fHeight)
        fHeight = 1.0f;
    if(D3DX_DEFAULT_FLOAT == fDepth)
        fDepth = 1.0f;


    // Validate parameters
    if(!pDevice) 
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!ppMesh)
    {
        DPF(0, "ppMesh pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(fWidth < 0.0f)
    {
        DPF(0, "fWidth must be >= 0.0f");
        return D3DERR_INVALIDCALL;
    }
    if(fHeight < 0.0f)
    {
        DPF(0, "fHeight must be >= 0.0f");
        return D3DERR_INVALIDCALL;
    }
    if(fDepth < 0.0f)
    {
        DPF(0, "fDepth must be >= 0.0f");
        return D3DERR_INVALIDCALL;
    }


    // Create the mesh
    UINT  cFaces    = 12;
    UINT  cVertices = 24;

    if(FAILED(hr = D3DXCreateMeshFVF(cFaces, cVertices, D3DXMESH_MANAGED, VERTEX_FVF, pDevice, &pMesh)))
        goto e_Exit;

    pMesh->LockVertexBuffer(0, (LPBYTE *) &pVertices);
    pMesh->LockIndexBuffer (0, (LPBYTE *) &pwIndices);

    if (ppAdjacency != NULL)
    {
        pPointReps = new DWORD[cVertices];
        if (pPointReps == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }
    }

    MakeBox(pVertices, pPointReps, pwIndices, fWidth, fHeight, fDepth);

    pMesh->UnlockVertexBuffer();
    pMesh->UnlockIndexBuffer();

    if (ppAdjacency != NULL)
    {
        hr = D3DXCreateBuffer(cFaces * 3 * sizeof(DWORD), ppAdjacency);
        if (FAILED(hr))
            goto e_Exit;

        hr = pMesh->ConvertPointRepsToAdjacency(pPointReps, (DWORD*)(*ppAdjacency)->GetBufferPointer());
        if (FAILED(hr))
            goto e_Exit;
    }

    *ppMesh = pMesh;
    pMesh = NULL;

e_Exit:
    delete []pPointReps;
    RELEASE(pMesh);
    return hr;
}


//----------------------------------------------------------------------------
// D3DXCreateCylinder
//----------------------------------------------------------------------------
#define CACHE_SIZE    240

static void
    MakeCylinder(
        VERTEX*             pVertices, 
        DWORD*              pPointReps,
        WORD*               pwIndices, 
        float               fRadius1, 
        float               fRadius2, 
        float               fLength, 
        UINT                uSlices, 
        UINT                uStacks)
{
    UINT i, j;

    // Sin/Cos caches
    float sinI[CACHE_SIZE], cosI[CACHE_SIZE];

    for(i = 0; i < uSlices; i++) 
        sincosf(2.0f * D3DX_PI * i / uSlices, sinI + i, cosI + i);


    // Compute side normal angle
    float fDeltaRadius = fRadius2 - fRadius1;
    float fSideLength = sqrtf(fDeltaRadius * fDeltaRadius + fLength * fLength);

    float fNormalXY = (fSideLength > 0.00001f) ? (fLength / fSideLength)       : 1.0f;
    float fNormalZ  = (fSideLength > 0.00001f) ? (-fDeltaRadius / fSideLength) : 0.0f;



    // Generate vertices
    VERTEX *pVertex = pVertices;
    float fZ, fRadius;
    DWORD iVertex;

    // Base cap (uSlices + 1)
    fZ = fLength * -0.5f;
    fRadius = fRadius1;
    iVertex = 0;

    pVertex->pos  = D3DXVECTOR3(0.0f, 0.0f, fZ);
    pVertex->norm = D3DXVECTOR3(0.0f, 0.0f, -1.0f);
    pVertex++;
    if (pPointReps != NULL)
        pPointReps[iVertex] = iVertex;
    iVertex++;

    for(i = 0; i < uSlices; i++)
    {
        pVertex->pos  = D3DXVECTOR3(fRadius * sinI[i], fRadius * cosI[i], fZ);
        pVertex->norm = D3DXVECTOR3(0.0f, 0.0f, -1.0f);
        pVertex++;
        
        // link into stack vertices, which follow
        if (pPointReps != NULL)
            pPointReps[iVertex] = iVertex + uSlices;
        iVertex++;
    }

    // Stacks ((uStacks + 1)*uSlices)
    for(j = 0; j <= uStacks; j++)
    {
        float f = (float) j / (float) uStacks;

        fZ = fLength * (f - 0.5f);
        fRadius = fRadius1 + f * fDeltaRadius;

        for(i = 0; i < uSlices; i++)
        {
            pVertex->pos  = D3DXVECTOR3(fRadius * sinI[i], fRadius * cosI[i], fZ);
            pVertex->norm = D3DXVECTOR3(fNormalXY * sinI[i], fNormalXY * cosI[i], fNormalZ);
            pVertex++;
            if (pPointReps != NULL)
                pPointReps[iVertex] = iVertex;
            iVertex++;
        }
    }

    // Top cap (uSlices + 1)
    fZ = fLength * 0.5f;
    fRadius = fRadius2;

    for(i = 0; i < uSlices; i++)
    {
        pVertex->pos  = D3DXVECTOR3(fRadius * sinI[i], fRadius * cosI[i], fZ);
        pVertex->norm = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
        pVertex++;

        // link into stack vertices, which precede
        if (pPointReps != NULL)
            pPointReps[iVertex] = iVertex - uSlices;
        iVertex++;
    }

    pVertex->pos  = D3DXVECTOR3(0.0f, 0.0f, fZ);
    pVertex->norm = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
    pVertex++;
    if (pPointReps != NULL)
        pPointReps[iVertex] = iVertex;
    iVertex++;



    // Generate indices
    WORD *pwFace = pwIndices;
    UINT uRowA, uRowB;

    // Z+ pole (uSlices)
    uRowA = 0;
    uRowB = 1;

    for(i = 0; i < uSlices - 1; i++)
    {
        pwFace[0] = (WORD) (uRowA);
        pwFace[1] = (WORD) (uRowB + i);
        pwFace[2] = (WORD) (uRowB + i + 1);
        pwFace += 3;
    }

    pwFace[0] = (WORD) (uRowA);
    pwFace[1] = (WORD) (uRowB + i);
    pwFace[2] = (WORD) (uRowB);
    pwFace += 3;

    // Interior stacks (uStacks * uSlices * 2)
    for(j = 0; j < uStacks; j++)
    {
        uRowA = 1 + (j + 1) * uSlices;
        uRowB = uRowA + uSlices;

        for(i = 0; i < uSlices - 1; i++)
        {
            pwFace[0] = (WORD) (uRowA + i);
            pwFace[1] = (WORD) (uRowB + i);
            pwFace[2] = (WORD) (uRowA + i + 1);
            pwFace += 3;

            pwFace[0] = (WORD) (uRowA + i + 1);
            pwFace[1] = (WORD) (uRowB + i);
            pwFace[2] = (WORD) (uRowB + i + 1);
            pwFace += 3;
        }

        pwFace[0] = (WORD) (uRowA + i);
        pwFace[1] = (WORD) (uRowB + i);
        pwFace[2] = (WORD) (uRowA);
        pwFace += 3;

        pwFace[0] = (WORD) (uRowA);
        pwFace[1] = (WORD) (uRowB + i);
        pwFace[2] = (WORD) (uRowB);
        pwFace += 3;
    }

    // Z- pole (uSlices)
    uRowA = 1 + (uStacks + 2) * uSlices;
    uRowB = uRowA + uSlices;

    for(i = 0; i < uSlices - 1; i++)
    {
        pwFace[0] = (WORD) (uRowA + i);
        pwFace[1] = (WORD) (uRowB);
        pwFace[2] = (WORD) (uRowA + i + 1);
        pwFace += 3;
    }

    pwFace[0] = (WORD) (uRowA + i);
    pwFace[1] = (WORD) (uRowB);
    pwFace[2] = (WORD) (uRowA);
    pwFace += 3;
}
        

HRESULT WINAPI
    D3DXCreateCylinder(
        LPDIRECT3DDEVICE8   pDevice, 
        float               fRadius1, 
        float               fRadius2, 
        float               fLength, 
        UINT                uSlices, 
        UINT                uStacks,   
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency)
{
    HRESULT hr;

    LPD3DXMESH pMesh  = NULL;
    WORD *pwIndices   = NULL;
    VERTEX *pVertices = NULL;
    DWORD *pPointReps = NULL;

    // Set up the defaults
    if(D3DX_DEFAULT_FLOAT == fRadius1)
        fRadius1 = 1.0f;
    if(D3DX_DEFAULT_FLOAT == fRadius2)
        fRadius2 = 1.0f;
    if(D3DX_DEFAULT_FLOAT == fLength)
        fLength = 1.0f;
    if(D3DX_DEFAULT == uSlices)
        uSlices = 8;
    if(D3DX_DEFAULT == uStacks)
        uStacks = 8;


    // Validate parameters
    if(!pDevice) 
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!ppMesh)
    {
        DPF(0, "ppMesh pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(fRadius1 < 0.0f)
    {
        DPF(0, "fRadius1 must be >= 0.0f");
        return D3DERR_INVALIDCALL;
    }
    if(fRadius2 < 0.0f)
    {
        DPF(0, "fRadius2 must be >= 0.0f");
        return D3DERR_INVALIDCALL;
    }
    if(fLength < 0.0f)
    {
        DPF(0, "fLength must be >= 0.0f");
        return D3DERR_INVALIDCALL;
    }
    if(uSlices < 2)
    {
        DPF(0, "uSlices must be >= 2");
        return D3DERR_INVALIDCALL;
    }
    if(uStacks < 1)
    {
        DPF(0, "uStacks must be >= 1");
        return D3DERR_INVALIDCALL;
    }
    if(uSlices >= CACHE_SIZE) 
        uSlices = CACHE_SIZE-1;



    // Create the mesh
    UINT  cFaces    = (uStacks + 1) * uSlices * 2;
    UINT  cVertices = 2 + (uStacks + 3) * uSlices;

    if(FAILED(hr = D3DXCreateMeshFVF(cFaces, cVertices, D3DXMESH_MANAGED, VERTEX_FVF, pDevice, &pMesh)))
        return hr;

    pMesh->LockVertexBuffer(0, (LPBYTE *) &pVertices);
    pMesh->LockIndexBuffer (0, (LPBYTE *) &pwIndices);

    if (ppAdjacency != NULL)
    {
        pPointReps = new DWORD[cVertices];
        if (pPointReps == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }
    }

    MakeCylinder(pVertices, pPointReps, pwIndices, fRadius1, fRadius2,
        fLength, uSlices, uStacks);

    pMesh->UnlockVertexBuffer();
    pMesh->UnlockIndexBuffer();

    if (ppAdjacency != NULL)
    {
        hr = D3DXCreateBuffer(cFaces * 3 * sizeof(DWORD), ppAdjacency);
        if (FAILED(hr))
            goto e_Exit;

        hr = pMesh->ConvertPointRepsToAdjacency(pPointReps, (DWORD*)(*ppAdjacency)->GetBufferPointer());
        if (FAILED(hr))
            goto e_Exit;
    }

    *ppMesh = pMesh;
    pMesh = NULL;

e_Exit:
    RELEASE(pMesh);
    delete []pPointReps;
    return hr;
}



//---------------------------------------------------------------------
// D3DXCreateSphere
//---------------------------------------------------------------------
static void
    MakeSphere( 
        VERTEX*             pVertices, 
        WORD*               pwIndices, 
        float               fRadius, 
        UINT                uSlices,
        UINT                uStacks)
{
    UINT i,j;


    // Sin/Cos caches
    float sinI[CACHE_SIZE], cosI[CACHE_SIZE];
    float sinJ[CACHE_SIZE], cosJ[CACHE_SIZE];

    for(i = 0; i < uSlices; i++) 
        sincosf(2.0f * D3DX_PI * i / uSlices, sinI + i, cosI + i);

    for(j = 0; j < uStacks; j++) 
        sincosf(D3DX_PI * j / uStacks, sinJ + j, cosJ + j);



    // Generate vertices
    VERTEX *pVertex = pVertices;

    // +Z pole
    pVertex->pos  = D3DXVECTOR3(0.0f, 0.0f, fRadius);
    pVertex->norm = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
    pVertex++;

    // Stacks
    for(j = 1; j < uStacks; j++) 
    {
        for(i = 0; i < uSlices; i++)
        {
            D3DXVECTOR3 norm(sinI[i] * sinJ[j], cosI[i] * sinJ[j], cosJ[j]);

            pVertex->pos  = norm * fRadius;
            pVertex->norm = norm;

            pVertex++;
        }
    }

    // Z- pole
    pVertex->pos  = D3DXVECTOR3(0.0f, 0.0f, -fRadius);
    pVertex->norm = D3DXVECTOR3(0.0f, 0.0f, -1.0f);
    pVertex++;



    // Generate indices
    WORD *pwFace = pwIndices;
    UINT uRowA, uRowB;

    // Z+ pole
    uRowA = 0;
    uRowB = 1;

    for(i = 0; i < uSlices - 1; i++)
    {
        pwFace[0] = (WORD) (uRowA);
        pwFace[1] = (WORD) (uRowB + i + 1);
        pwFace[2] = (WORD) (uRowB + i);
        pwFace += 3;
    }

    pwFace[0] = (WORD) (uRowA);
    pwFace[1] = (WORD) (uRowB);
    pwFace[2] = (WORD) (uRowB + i);
    pwFace += 3;

    // Interior stacks
    for(j = 1; j < uStacks - 1; j++)
    {
        uRowA = 1 + (j - 1) * uSlices;
        uRowB = uRowA + uSlices;

        for(i = 0; i < uSlices - 1; i++)
        {
            pwFace[0] = (WORD) (uRowA + i);
            pwFace[1] = (WORD) (uRowA + i + 1);
            pwFace[2] = (WORD) (uRowB + i);
            pwFace += 3;

            pwFace[0] = (WORD) (uRowA + i + 1);
            pwFace[1] = (WORD) (uRowB + i + 1);
            pwFace[2] = (WORD) (uRowB + i);
            pwFace += 3;
        }

        pwFace[0] = (WORD) (uRowA + i);
        pwFace[1] = (WORD) (uRowA);
        pwFace[2] = (WORD) (uRowB + i);
        pwFace += 3;

        pwFace[0] = (WORD) (uRowA);
        pwFace[1] = (WORD) (uRowB);
        pwFace[2] = (WORD) (uRowB + i);
        pwFace += 3;
    }

    // Z- pole
    uRowA = 1 + (uStacks - 2) * uSlices;
    uRowB = uRowA + uSlices;

    for(i = 0; i < uSlices - 1; i++)
    {
        pwFace[0] = (WORD) (uRowA + i);
        pwFace[1] = (WORD) (uRowA + i + 1);
        pwFace[2] = (WORD) (uRowB);
        pwFace += 3;
    }

    pwFace[0] = (WORD) (uRowA + i);
    pwFace[1] = (WORD) (uRowA);
    pwFace[2] = (WORD) (uRowB);
    pwFace += 3;
}


HRESULT WINAPI
    D3DXCreateSphere(
        LPDIRECT3DDEVICE8   pDevice, 
        float               fRadius, 
        UINT                uSlices, 
        UINT                uStacks,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency)
{
    HRESULT hr;

    LPD3DXMESH pMesh  = NULL;
    WORD *pwIndices   = NULL;
    VERTEX *pVertices = NULL;

    // Set up the defaults
    if(D3DX_DEFAULT_FLOAT == fRadius)
        fRadius = 1.0f;
    if(D3DX_DEFAULT == uSlices)
        uSlices = 8;
    if(D3DX_DEFAULT == uStacks)
        uStacks = 8;

    // Validate parameters
    if(!pDevice) 
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!ppMesh)
    {
        DPF(0, "ppMesh pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(fRadius < 0.0f)
    {
        DPF(0, "fRadius must be >= 0.0f");
        return D3DERR_INVALIDCALL;
    }
    if(uSlices < 2)
    {
        DPF(0, "uSlices must be >= 2");
        return D3DERR_INVALIDCALL;
    }
    if(uStacks < 2)
    {
        DPF(0, "uStacks must be >= 2");
        return D3DERR_INVALIDCALL;
    }

    if(uSlices > CACHE_SIZE)
        uSlices = CACHE_SIZE;
    if(uStacks > CACHE_SIZE)
        uStacks = CACHE_SIZE;


    // Create the mesh
    UINT  cFaces    = 2 * (uStacks - 1) * uSlices;
    UINT  cVertices = (uStacks - 1) * uSlices + 2;

    if(FAILED(hr = D3DXCreateMeshFVF(cFaces, cVertices, D3DXMESH_MANAGED, VERTEX_FVF, pDevice, &pMesh)))
        return hr;

    pMesh->LockVertexBuffer(0, (LPBYTE *) &pVertices);
    pMesh->LockIndexBuffer (0, (LPBYTE *) &pwIndices);

    MakeSphere(pVertices, pwIndices, fRadius, uSlices, uStacks);

    pMesh->UnlockVertexBuffer();
    pMesh->UnlockIndexBuffer();

    if (ppAdjacency != NULL)
    {
        hr = D3DXCreateBuffer(cFaces * 3 * sizeof(DWORD), ppAdjacency);
        if (FAILED(hr))
        {
            RELEASE(pMesh);
            return hr;
        }

        hr = pMesh->ConvertPointRepsToAdjacency(NULL, (DWORD*)(*ppAdjacency)->GetBufferPointer());
        if (FAILED(hr))
        {
            RELEASE(pMesh);
            return hr;
        }
    }

    *ppMesh = pMesh;
    return S_OK;
}



//---------------------------------------------------------------------
// D3DXCreateTorus
//---------------------------------------------------------------------
static void
    MakeTorus( 
        VERTEX*             pVertices, 
        WORD*               pwIndices, 
        float               fInnerRadius, 
        float               fOuterRadius, 
        UINT                uSides, 
        UINT                uRings)
{
    UINT i, j;

    //
    // Compute the vertices
    //

    VERTEX *pVertex = pVertices;

    for (i = 0; i < uRings; i++) 
    {
        float theta = (float) i * 2.0f * D3DX_PI / (float)uRings;
        float st, ct;

        sincosf(theta, &st, &ct);

        for (j = 0; j < uSides; j++) 
        {
            float phi = (float) j * 2.0f * D3DX_PI / uSides;
            float sp, cp;

            sincosf(phi, &sp, &cp);

            pVertex->pos.x  =  ct * (fOuterRadius + fInnerRadius * cp);
            pVertex->pos.y  = -st * (fOuterRadius + fInnerRadius * cp);
            pVertex->pos.z  =  sp * fInnerRadius;

            pVertex->norm.x =  ct * cp;
            pVertex->norm.y = -st * cp;
            pVertex->norm.z =  sp;

            pVertex++;
        }
    }

    //
    // Compute the indices: 
    // There are uRings * uSides faces
    // Each face has 2 triangles (6 indices)
    //

    // Tube i has indices:  
    //        Left Edge: i*(uSides+1) -- i*(uSides+1)+uSides
    //        Right Edge: (i+1)*(uSides+1) -- (i+1)*(uSides+1)+uSides
    //
    // Face j on tube i has the 4 indices:
    //        Left Edge: i*(uSides+1)+j -- i*(uSides+1)+j+1
    //        Right Edge: (i+1)*(uSides+1)+j -- (i+1)*(uSides+1)+j+1
    //
    WORD *pwFace = pwIndices;

    for (i = 0; i < uRings - 1; i++) 
    {
        for (j = 0; j < uSides - 1; j++) 
        {                                

            // Tri 1 (Top-Left tri, CCW)
            pwFace[0] = (WORD) (i * uSides + j);
            pwFace[1] = (WORD) (i * uSides + j + 1);
            pwFace[2] = (WORD) ((i + 1) * uSides + j);
            pwFace += 3;

            // Tri 2 (Bottom-Right tri, CCW)
            pwFace[0] = (WORD) ((i + 1) * uSides + j);
            pwFace[1] = (WORD) (i * uSides + j + 1);
            pwFace[2] = (WORD) ((i + 1) * uSides + j + 1);
            pwFace += 3;
        }

        // Tri 1 (Top-Left tri, CCW)
        pwFace[0] = (WORD) (i * uSides + j);
        pwFace[1] = (WORD) (i * uSides);
        pwFace[2] = (WORD) ((i + 1) * uSides + j);
        pwFace += 3;

        // Tri 2 (Bottom-Right tri, CCW)
        pwFace[0] = (WORD) ((i + 1) * uSides + j);
        pwFace[1] = (WORD) (i * uSides + 0);
        pwFace[2] = (WORD) ((i + 1) * uSides + 0);
        pwFace += 3;
    }


    // join the two ends of the tube
    for (j = 0; j < uSides - 1; j++) 
    {
        // Tri 1 (Top-Left tri, CCW)
        pwFace[0] = (WORD) (i * uSides + j);
        pwFace[1] = (WORD) (i * uSides + j + 1);
        pwFace[2] = (WORD) (j);
        pwFace += 3;

        // Tri 2 (Bottom-Right tri, CCW)
        pwFace[0] = (WORD) (j);
        pwFace[1] = (WORD) (i * uSides + j + 1);
        pwFace[2] = (WORD) (j + 1);
        pwFace += 3;
    }

    // Tri 1 (Top-Left tri, CCW)
    pwFace[0] = (WORD) (i * uSides + j);
    pwFace[1] = (WORD) (i * uSides);
    pwFace[2] = (WORD) (j);
    pwFace += 3;

    // Tri 2 (Bottom-Right tri, CCW)
    pwFace[0] = (WORD) (j);
    pwFace[1] = (WORD) (i * uSides);
    pwFace[2] = (WORD) (0);
    pwFace += 3;
}


HRESULT WINAPI
    D3DXCreateTorus(
        LPDIRECT3DDEVICE8   pDevice,
        float               fInnerRadius, 
        float               fOuterRadius, 
        UINT                uSides, 
        UINT                uRings, 
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency)
{
    HRESULT hr;

    LPD3DXMESH pMesh  = NULL;
    WORD *pwIndices   = NULL;
    VERTEX *pVertices = NULL;


    // Set up the defaults
    if(D3DX_DEFAULT_FLOAT == fInnerRadius)
        fInnerRadius = 1.0f;
    if(D3DX_DEFAULT_FLOAT == fOuterRadius)
        fOuterRadius = 2.0f;
    if(D3DX_DEFAULT == uSides)
        uSides = 8;
    if(D3DX_DEFAULT == uRings)
        uRings = 15;

    // Validate parameters
    if(!pDevice) 
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!ppMesh)
    {
        DPF(0, "ppMesh pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(fInnerRadius < 0.0f)
    {
        DPF(0, "fInnerRadius must be >= 0.0f");
        return D3DERR_INVALIDCALL;
    }
    if(fOuterRadius < 0.0f)
    {
        DPF(0, "fOuterRadius must be >= 0.0f");
        return D3DERR_INVALIDCALL;
    }
    if(uSides < 3)
    {
        DPF(0, "uSides must be >= 3");
        return D3DERR_INVALIDCALL;
    }
    if(uRings < 3)
    {
        DPF(0, "uRings must be >= 3");
        return D3DERR_INVALIDCALL;
    }


    // Create the mesh
    UINT  cFaces    = 2 * uSides * uRings;
    UINT  cVertices = uRings * uSides;

    if(FAILED(hr = D3DXCreateMeshFVF(cFaces, cVertices, D3DXMESH_MANAGED, VERTEX_FVF, pDevice, &pMesh)))
        return hr;

    pMesh->LockVertexBuffer(0, (LPBYTE *) &pVertices);
    pMesh->LockIndexBuffer (0, (LPBYTE *) &pwIndices);

    MakeTorus(pVertices, pwIndices, fInnerRadius, fOuterRadius,
        uSides, uRings);

    pMesh->UnlockVertexBuffer();
    pMesh->UnlockIndexBuffer();

    if (ppAdjacency != NULL)
    {
        hr = D3DXCreateBuffer(cFaces * 3 * sizeof(DWORD), ppAdjacency);
        if (FAILED(hr))
        {
            RELEASE(pMesh);
            return hr;
        }

        hr = pMesh->ConvertPointRepsToAdjacency(NULL, (DWORD*)(*ppAdjacency)->GetBufferPointer());
        if (FAILED(hr))
        {
            RELEASE(pMesh);
            return hr;
        }
    }

    *ppMesh = pMesh;
    return S_OK;
}



//----------------------------------------------------------------------------
// D3DXCreateTeapot
//----------------------------------------------------------------------------
#include "teapot.cpp"


static void
    MakeTeapot(
        VERTEX*             pVertices,
        WORD*               pwIndices)
{
    DWORD iVertex; 

    // Copy vertices
    for (iVertex = 0; iVertex < NUMTEAPOTVERTICES; iVertex++)
    {
        pVertices[iVertex].pos = teapotPositions[iVertex];
        pVertices[iVertex].norm = teapotNormals[iVertex];
    }

    // Copy face indices
    WORD *pwFace = pwIndices;
    WORD *pwFaceLim = pwFace + NUMTEAPOTINDICES;
    WORD *pwTeapotFace = teapotIndices;

    while(pwFace < pwFaceLim)
    {
        pwFace[0] = pwTeapotFace[0];
        pwFace[1] = pwTeapotFace[1];
        pwFace[2] = pwTeapotFace[2];

        pwFace += 3;
        pwTeapotFace += 3;
    }
}


HRESULT WINAPI
    D3DXCreateTeapot(
        LPDIRECT3DDEVICE8   pDevice,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency)
{
    HRESULT hr;

    LPD3DXMESH pMesh  = NULL;
    WORD *pwIndices   = NULL;
    VERTEX *pVertices = NULL;


    // Validate parameters
    if(!pDevice) 
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!ppMesh)
    {
        DPF(0, "ppMesh pointer is invalid");
        return D3DERR_INVALIDCALL;
    }


    // Create the mesh
    UINT  cFaces    = NUMTEAPOTINDICES / 3;
    UINT  cVertices = NUMTEAPOTVERTICES;

    if(FAILED(hr = D3DXCreateMeshFVF(cFaces, cVertices, D3DXMESH_MANAGED, VERTEX_FVF, pDevice, &pMesh)))
        return hr;

    pMesh->LockVertexBuffer(0, (LPBYTE *) &pVertices);
    pMesh->LockIndexBuffer (0, (LPBYTE *) &pwIndices);

    MakeTeapot(pVertices, pwIndices);

    pMesh->UnlockVertexBuffer();
    pMesh->UnlockIndexBuffer();

    if (ppAdjacency != NULL)
    {
        hr = D3DXCreateBuffer(cFaces * 3 * sizeof(DWORD), ppAdjacency);
        if (FAILED(hr))
        {
            RELEASE(pMesh);
            return hr;
        }

        hr = pMesh->ConvertPointRepsToAdjacency(NULL, (DWORD*)(*ppAdjacency)->GetBufferPointer());
        if (FAILED(hr))
        {
            RELEASE(pMesh);
            return hr;
        }
    }

    *ppMesh = pMesh;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\tex\CD3DXBlt.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXBlt.h
//  Content:    Blitter
//
///////////////////////////////////////////////////////////////////////////

#ifndef __CD3DXBlt_H__
#define __CD3DXBlt_H__


///////////////////////////////////////////////////////////////////////////
// CD3DXBlt ///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CD3DXBlt
{
public:
    CD3DXBlt();
   ~CD3DXBlt();

    HRESULT Blt(D3DX_BLT* pDestBlt, D3DX_BLT* pSrcBlt, DWORD dwFilter);

protected:
    // Generic filters
    HRESULT BltSame();
    HRESULT BltCopy();
    HRESULT BltNone();
    HRESULT BltPoint();
    HRESULT BltBox2D();
    HRESULT BltBox3D();
    HRESULT BltLinear2D();
    HRESULT BltLinear3D();
    HRESULT BltTriangle2D();
    HRESULT BltTriangle3D();

    // Optimized filters
    HRESULT BltSame_DXTn();
    HRESULT BltBox2D_R8G8B8();  
    HRESULT BltBox2D_A8R8G8B8();
    HRESULT BltBox2D_X8R8G8B8();
    HRESULT BltBox2D_R5G6B5();  
    HRESULT BltBox2D_X1R5G5B5();
    HRESULT BltBox2D_A1R5G5B5();
    HRESULT BltBox2D_A4R4G4B4();
    HRESULT BltBox2D_R3G3B2();  
    HRESULT BltBox2D_A8();      
    HRESULT BltBox2D_A8R3G3B2();
    HRESULT BltBox2D_X4R4G4B4();
    HRESULT BltBox2D_A8P8();    
    HRESULT BltBox2D_P8();      
    HRESULT BltBox2D_A8L8();    
    HRESULT BltBox2D_A4L4();    

    // Codecs and Filter Type
    CD3DXCodec *m_pSrc;
    CD3DXCodec *m_pDest;

    DWORD m_dwFilter;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\tex\CD3DXCodec.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXCodec.h
//  Content:    Pixel format codecs
//
///////////////////////////////////////////////////////////////////////////

#ifndef __CD3DXCodec_H__
#define __CD3DXCodec_H__


#define CODEC_RGB 0x01
#define CODEC_P   0x02
#define CODEC_UV  0x03
#define CODEC_ZS  0x04

struct D3DX_BLT
{
    VOID*               pData;
    D3DFORMAT           Format;

    UINT                RowPitch;
    UINT                SlicePitch;

    D3DBOX              Region;
    D3DBOX              SubRegion;

    BOOL                bDither;

    D3DCOLOR            ColorKey;
    CONST PALETTEENTRY* pPalette;
};


///////////////////////////////////////////////////////////////////////////
// CD3DXCodec /////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CD3DXCodec
{
public:
    D3DFORMAT  m_Format;
    DWORD      m_dwType;
    BOOL       m_bLinear;
    BOOL       m_bColorKey;
    BOOL       m_bPalettized;

    BYTE*      m_pbData;
    D3DXCOLOR  m_ColorKey;
    FLOAT*     m_pfDither;
    D3DXCOLOR  m_pPalette[256];
    D3DBOX     m_Box;

    UINT       m_uPitch;
    UINT       m_uSlice;
    UINT       m_uWidth;
    UINT       m_uHeight;
    UINT       m_uDepth;
    UINT       m_uWidthBytes;
    UINT       m_uBytesPerPixel;

public:
    static CD3DXCodec* Create(D3DX_BLT *pBlt);

    virtual ~CD3DXCodec();

    virtual void Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);
    virtual void Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);

protected:
    static D3DCOLOR s_pPalette[256];

    void ColorKey(D3DXCOLOR *pColors);

    CD3DXCodec(D3DX_BLT *pBlt, UINT uBPP, DWORD dwType);
};


///////////////////////////////////////////////////////////////////////////
// CD3DXCodecYUV //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CD3DXCodecYUV : public CD3DXCodec
{
public: 
    CD3DXCodecYUV(D3DX_BLT *pBlt);
    virtual ~CD3DXCodecYUV();

    HRESULT Commit();
    HRESULT Fetch(UINT uRow, UINT uSlice, BOOL bRead);

    virtual void Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);
    virtual void Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);

protected:
    D3DXCOLOR *m_pCache;
    D3DBOX     m_CacheBox;
    UINT       m_uCacheWidth;
    BOOL       m_bCacheDirty;
    BOOL       m_bCacheAllocated;
    UINT       m_uYShift;
    UINT       m_uUVShift;
};



///////////////////////////////////////////////////////////////////////////
// CD3DXCodecDXT //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CD3DXCodecDXT : public CD3DXCodec
{
public: 
    CD3DXCodecDXT(D3DX_BLT *pBlt);
    virtual ~CD3DXCodecDXT();

    HRESULT Commit();
    HRESULT Fetch(UINT uRow, UINT uSlice, BOOL bRead);

    virtual void Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);
    virtual void Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors);

protected:
    D3DXCOLOR *m_ppCache[4];
    D3DBOX     m_CacheBox;
    UINT       m_uCacheWidth;
    BOOL       m_bCacheDirty;
    BOOL       m_bCacheAllocated;

    BOOL       m_bRepeat;
    UINT       m_uXRepeat;
    UINT       m_uYRepeat;
    UINT       m_uTopMax;
};



///////////////////////////////////////////////////////////////////////////
// Specific CD3DXCodecs ///////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define DECLARE_CODEC(name, bits, type) \
    class CD3DXCodec_##name : public CD3DXCodec \
    { \
    public: \
        CD3DXCodec_##name(D3DX_BLT *pBlt) \
            : CD3DXCodec(pBlt, (bits), (type)) {} \
    \
        virtual void Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors); \
        virtual void Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors); \
    }


#define DECLARE_CODEC_YUV(name) \
    class CD3DXCodec_##name : public CD3DXCodecYUV \
    { \
    public: \
        CD3DXCodec_##name(D3DX_BLT *pBlt) \
            : CD3DXCodecYUV(pBlt) {} \
    }


#define DECLARE_CODEC_DXT(name) \
    class CD3DXCodec_##name : public CD3DXCodecDXT \
    { \
    public: \
        CD3DXCodec_##name(D3DX_BLT *pBlt) \
            : CD3DXCodecDXT(pBlt) {} \
    }


DECLARE_CODEC(R8G8B8,    24, CODEC_RGB);
DECLARE_CODEC(A8R8G8B8,  32, CODEC_RGB);
DECLARE_CODEC(X8R8G8B8,  32, CODEC_RGB);
DECLARE_CODEC(R5G6B5,    16, CODEC_RGB);
DECLARE_CODEC(X1R5G5B5,  16, CODEC_RGB);
DECLARE_CODEC(A1R5G5B5,  16, CODEC_RGB);
DECLARE_CODEC(A4R4G4B4,  16, CODEC_RGB);
DECLARE_CODEC(R3G3B2,     8, CODEC_RGB);
DECLARE_CODEC(A8,         8, CODEC_RGB);
DECLARE_CODEC(A8R3G3B2,  16, CODEC_RGB);
DECLARE_CODEC(X4R4G4B4,  16, CODEC_RGB);
DECLARE_CODEC(A8P8,      16, CODEC_P);
DECLARE_CODEC(P8,         8, CODEC_P);
DECLARE_CODEC(L8,         8, CODEC_RGB);
DECLARE_CODEC(A8L8,      16, CODEC_RGB);
DECLARE_CODEC(A4L4,       8, CODEC_RGB);

DECLARE_CODEC(V8U8,      16, CODEC_UV);
DECLARE_CODEC(L6V5U5,    16, CODEC_UV);
DECLARE_CODEC(X8L8V8U8,  32, CODEC_UV);
DECLARE_CODEC(Q8W8V8U8,  32, CODEC_UV);
DECLARE_CODEC(V16U16,    32, CODEC_UV);
DECLARE_CODEC(W11V11U10, 32, CODEC_UV);

DECLARE_CODEC_YUV(UYVY);
DECLARE_CODEC_YUV(YUY2);
DECLARE_CODEC_DXT(DXT1);
DECLARE_CODEC_DXT(DXT2);
DECLARE_CODEC_DXT(DXT3);
DECLARE_CODEC_DXT(DXT4);
DECLARE_CODEC_DXT(DXT5);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\tex\CD3DXCodec.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXCodec.cpp
//  Content:    Pixel format codecs
//
///////////////////////////////////////////////////////////////////////////

#include "pchtex.h"

extern BOOL D3DX__Premult;

static FLOAT g_fDitherOff[] =
{
    0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,
    0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,
    0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,
    0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f
};

static FLOAT g_fDitherOn[] =
{
    0.96875f, 0.46875f, 0.84375f, 0.34375f, 0.96875f, 0.46875f, 0.84375f, 0.34375f,
    0.21875f, 0.71875f, 0.09375f, 0.59375f, 0.21875f, 0.71875f, 0.09375f, 0.59375f,
    0.78125f, 0.28125f, 0.90625f, 0.40625f, 0.78125f, 0.28125f, 0.90625f, 0.40625f,
    0.03125f, 0.53125f, 0.15625f, 0.65625f, 0.03125f, 0.53125f, 0.15625f, 0.65625f
};



///////////////////////////////////////////////////////////////////////////
// CD3DXCodec /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


CD3DXCodec* CD3DXCodec::Create(D3DX_BLT *pBlt)
{

#define CASE_LFORMAT(format) \
    case D3DFMT_LIN_##format: \
    case D3DFMT_##format : \
        return new CD3DXCodec_##format(pBlt)

#define CASE_FORMAT(format) \
    case D3DFMT_##format : \
        return new CD3DXCodec_##format(pBlt)


    switch(pBlt->Format)
    {
    CASE_FORMAT(R8G8B8);
#if 0
    CASE_FORMAT(R3G3B2);
    CASE_FORMAT(A8R3G3B2);
    CASE_FORMAT(X4R4G4B4);
    CASE_FORMAT(A8P8);
    CASE_FORMAT(A4L4);
    CASE_FORMAT(X8L8V8U8);
    CASE_FORMAT(W11V11U10);
    CASE_FORMAT(DXT3);
    CASE_FORMAT(DXT5);
#endif
    CASE_LFORMAT(A8R8G8B8);
    CASE_LFORMAT(X8R8G8B8);
    CASE_LFORMAT(R5G6B5);
    CASE_LFORMAT(X1R5G5B5);
    CASE_LFORMAT(A1R5G5B5);
    CASE_LFORMAT(A4R4G4B4);
    CASE_LFORMAT(A8);
    CASE_FORMAT(P8);
    CASE_LFORMAT(L8);
    CASE_LFORMAT(A8L8);

    CASE_LFORMAT(V8U8);
    CASE_FORMAT(L6V5U5);
    CASE_FORMAT(Q8W8V8U8);
    CASE_FORMAT(V16U16);

    CASE_FORMAT(UYVY);
    CASE_FORMAT(YUY2);
    CASE_FORMAT(DXT1);
    CASE_FORMAT(DXT2);
    CASE_FORMAT(DXT4);
    }

    return NULL;
}

CD3DXCodec::CD3DXCodec(D3DX_BLT *pBlt, UINT uBPP, DWORD dwType)
{
    m_pbData = (BYTE *) pBlt->pData;
    m_Format = pBlt->Format;
    m_uPitch = pBlt->RowPitch;
    m_uSlice = pBlt->SlicePitch;
    m_Box = pBlt->SubRegion;
    m_ColorKey = pBlt->ColorKey;
    m_bColorKey = pBlt->ColorKey != 0;
    m_pfDither = pBlt->bDither ? g_fDitherOn : g_fDitherOff;
    m_uBytesPerPixel = uBPP >> 3;
    m_bLinear = uBPP != 0;
    m_dwType = dwType;

    if(CODEC_P == m_dwType)
    {
        m_dwType = CODEC_RGB;
        m_bPalettized = TRUE;

        if(pBlt->pPalette)
        {
            for(UINT i = 0; i < 256; i++)
            {
                m_pPalette[i].r = (FLOAT) pBlt->pPalette[i].peRed   * (1.0f / 255.0f);
                m_pPalette[i].g = (FLOAT) pBlt->pPalette[i].peGreen * (1.0f / 255.0f);
                m_pPalette[i].b = (FLOAT) pBlt->pPalette[i].peBlue  * (1.0f / 255.0f);
                m_pPalette[i].a = (FLOAT) pBlt->pPalette[i].peFlags * (1.0f / 255.0f);
            }
        }
        else
        {
            for(UINT i = 0; i < 256; i++)
            {
                m_pPalette[i].r = m_pPalette[i].g = m_pPalette[i].b = m_pPalette[i].a = 1.0f;
            }
        }
    }
    else
    {
        m_bPalettized = FALSE;
    }


    m_uWidth  = (UINT) (m_Box.Right - m_Box.Left);
    m_uHeight = (UINT) (m_Box.Bottom - m_Box.Top);
    m_uDepth  = (UINT) (m_Box.Back - m_Box.Front);
    m_uWidthBytes = m_uWidth * m_uBytesPerPixel;

    if(m_bLinear)
    {
        m_pbData += m_Box.Front * m_uSlice + m_Box.Top * m_uPitch + m_Box.Left * m_uBytesPerPixel;

        m_Box.Left   = 0;
        m_Box.Top    = 0;
        m_Box.Front  = 0;
        m_Box.Right  = m_uWidth;
        m_Box.Bottom = m_uHeight;
        m_Box.Back   = m_uDepth;
    }
}

CD3DXCodec::~CD3DXCodec()
{
    // Do nothing
}

void CD3DXCodec::Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    // Do nothing
}

void CD3DXCodec::Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    // Do nothing
}

void CD3DXCodec::ColorKey(D3DXCOLOR *pColors)
{
    D3DXCOLOR *pColor;
    D3DXCOLOR *pColorLim = pColors + m_uWidth;

    for(pColor = pColors; pColor < pColorLim; pColor++)
    {
        if(*pColor == m_ColorKey)
            pColor->r = pColor->g = pColor->b = pColor->a = 0.0f;
    }
}


///////////////////////////////////////////////////////////////////////////
// Specific codecs ////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#define ENCODE(format) \
    void CD3DXCodec_##format::Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)


ENCODE(R8G8B8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        pub[0] = (UINT8) F2I(pColors[i].b * 255.0f + fDither);
        pub[1] = (UINT8) F2I(pColors[i].g * 255.0f + fDither);
        pub[2] = (UINT8) F2I(pColors[i].r * 255.0f + fDither);

        pub += 3;
    }

    F2IEnd();
}


ENCODE(A8R8G8B8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 255.0f + fDither) << 16) |
                         (F2I(pColors[i].g * 255.0f + fDither) <<  8) |
                         (F2I(pColors[i].b * 255.0f + fDither) <<  0) |
                         (F2I(pColors[i].a * 255.0f + fDither) << 24));

        pul++;
    }

    F2IEnd();
}


ENCODE(X8R8G8B8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 255.0f + fDither) << 16) |
                         (F2I(pColors[i].g * 255.0f + fDither) <<  8) |
                         (F2I(pColors[i].b * 255.0f + fDither) <<  0));

        pul++;
    }

    F2IEnd();
}


ENCODE(R5G6B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 31.0f + fDither) << 11) |
                         (F2I(pColors[i].g * 63.0f + fDither) <<  5) |
                         (F2I(pColors[i].b * 31.0f + fDither) <<  0));

        pus++;
    }

    F2IEnd();
}


ENCODE(X1R5G5B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 31.0f + fDither) << 10) |
                         (F2I(pColors[i].g * 31.0f + fDither) <<  5) |
                         (F2I(pColors[i].b * 31.0f + fDither) <<  0));

        pus++;
    }

    F2IEnd();
}


ENCODE(A1R5G5B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 31.0f + fDither) << 10) |
                         (F2I(pColors[i].g * 31.0f + fDither) <<  5) |
                         (F2I(pColors[i].b * 31.0f + fDither) <<  0) |
                         (F2I(pColors[i].a *  1.0f + fDither) << 15));

        pus++;
    }

    F2IEnd();
}


ENCODE(A4R4G4B4)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 15.0f + fDither) <<  8) |
                         (F2I(pColors[i].g * 15.0f + fDither) <<  4) |
                         (F2I(pColors[i].b * 15.0f + fDither) <<  0) |
                         (F2I(pColors[i].a * 15.0f + fDither) << 12));

        pus++;
    }

    F2IEnd();
}


ENCODE(R3G3B2)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pub = (UINT8) ((F2I(pColors[i].r * 7.0f + fDither) <<  5) |
                        (F2I(pColors[i].g * 7.0f + fDither) <<  2) |
                        (F2I(pColors[i].b * 3.0f + fDither) <<  0));

        pub++;
    }

    F2IEnd();
}


ENCODE(A8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pub = (UINT8) F2I(pColors[i].a * 255.0f + fDither);

        pub++;
    }

    F2IEnd();
}


ENCODE(A8R3G3B2)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r *   7.0f + fDither) <<  5) |
                         (F2I(pColors[i].g *   7.0f + fDither) <<  2) |
                         (F2I(pColors[i].b *   3.0f + fDither) <<  0) |
                         (F2I(pColors[i].a * 255.0f + fDither) <<  8));

        pus++;
    }

    F2IEnd();
}


ENCODE(X4R4G4B4)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 15.0f + fDither) <<  8) |
                         (F2I(pColors[i].g * 15.0f + fDither) <<  4) |
                         (F2I(pColors[i].b * 15.0f + fDither) <<  0));

        pus++;
    }

    F2IEnd();
}


ENCODE(A8P8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        UINT uMin = 0;
        FLOAT fDistMin = FLT_MAX;

        for(UINT u = 0; u < 256; u++)
        {
            D3DXCOLOR color = *pColors - m_pPalette[u];
            FLOAT fDist = color.r * color.r + color.g * color.g + color.b * color.b;

            if(fDist < fDistMin)
                uMin = u;
        }

        *pus = (UINT16) (uMin | (F2I(pColors[i].a * 255.0f + fDither) << 8));

        pus++;
    }

    F2IEnd();
}


ENCODE(P8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);


    for(UINT i = 0; i < m_uWidth; i++)
    {
        UINT uMin = 0;
        FLOAT fDistMin = FLT_MAX;

        for(UINT u = 0; u < 256; u++)
        {
            D3DXCOLOR color = pColors[i] - m_pPalette[u];
            FLOAT fDist = color.r * color.r + color.g * color.g + color.b * color.b + color.a * color.a;

            if(fDist < fDistMin)
            {
                uMin = u;
                fDistMin = fDist;
            }
        }

        *pub = (UINT8) uMin;

        pub++;
    }
}


ENCODE(L8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pub = (UINT8) F2I((pColors[i].r * 0.2125f +
                            pColors[i].g * 0.7154f +
                            pColors[i].b * 0.0721f) * 255.0f + fDither);

        pub++;
    }

    F2IEnd();
}


ENCODE(A8L8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I((pColors[i].r * 0.2125f +
                               pColors[i].g * 0.7154f +
                               pColors[i].b * 0.0721f) * 255.0f + fDither) << 0) |

                         (F2I(pColors[i].a * 255.0f + fDither) << 8));

        pus++;
    }

    F2IEnd();
}


ENCODE(A4L4)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pub = (UINT8) ((F2I((pColors[i].r * 0.2125f +
                              pColors[i].g * 0.7154f +
                              pColors[i].b * 0.0721f) * 15.0f + fDither) << 0) |

                        (F2I(pColors[i].a * 15.0f + fDither) << 4));

        pub++;
    }

    F2IEnd();
}


ENCODE(V8U8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT16) ((F2I(pColors[i].r * 128.0f + fDither) & 255) << 0) |
                        ((F2I(pColors[i].g * 128.0f + fDither) & 255) << 8);
                      
        pus++;
    }

    F2IEnd();
}


ENCODE(L6V5U5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pus = (UINT32) ((F2I(pColors[i].r * 16.0f + fDither) & 31) <<  0) |
                        ((F2I(pColors[i].g * 16.0f + fDither) & 31) <<  5) |
                        ((F2I(pColors[i].a * 63.0f + fDither) & 63) << 10);

        pus++;
    }

    F2IEnd();
}


ENCODE(X8L8V8U8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 128.0f + fDither) & 255) <<  0) |
                        ((F2I(pColors[i].g * 128.0f + fDither) & 255) <<  8) |
                        ((F2I(pColors[i].a * 255.0f + fDither) & 255) << 16);

        pul++;
    }

    F2IEnd();
}


ENCODE(Q8W8V8U8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 128.0f + fDither) & 255) <<  0) |
                        ((F2I(pColors[i].g * 128.0f + fDither) & 255) <<  8) |
                        ((F2I(pColors[i].b * 128.0f + fDither) & 255) << 16) |
                        ((F2I(pColors[i].a * 128.0f + fDither) & 255) << 24);

        pul++;
    }

    F2IEnd();
}


ENCODE(V16U16)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r * 32768.0f + fDither) & 65535) <<  0) |
                        ((F2I(pColors[i].g * 32768.0f + fDither) & 65535) << 16);

        pul++;
    }

    F2IEnd();
}


ENCODE(W11V11U10)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    FLOAT *pfDither = m_pfDither + (uSlice & 3) + ((uRow & 3) * 8);

    F2IBegin();

    for(UINT i = 0; i < m_uWidth; i++)
    {
        FLOAT fDither = pfDither[i & 3];

        *pul = (UINT32) ((F2I(pColors[i].r *  512.0f + fDither) & 1023) <<  0) |
                        ((F2I(pColors[i].g * 1024.0f + fDither) & 2047) << 10) |
                        ((F2I(pColors[i].b * 1024.0f + fDither) & 2046) << 21);

        pul++;
    }

    F2IEnd();
}




#define DECODE(format) \
    void CD3DXCodec_##format::Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)


DECODE(R8G8B8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidthBytes;

    while(pub < pubLim)
    {
        pColors->r = (FLOAT) pub[2] * (1.0f / 255.0f);
        pColors->g = (FLOAT) pub[1] * (1.0f / 255.0f);
        pColors->b = (FLOAT) pub[0] * (1.0f / 255.0f);
        pColors->a = 1.0f;

        pub += 3;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8R8G8B8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) ((*pul >> 16) & 255) * (1.0f / 255.0f);
        pColors->g = (FLOAT) ((*pul >>  8) & 255) * (1.0f / 255.0f);
        pColors->b = (FLOAT) ((*pul >>  0) & 255) * (1.0f / 255.0f);
        pColors->a = (FLOAT) ((*pul >> 24) & 255) * (1.0f / 255.0f);

        pul++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(X8R8G8B8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) ((*pul >> 16) & 255) * (1.0f / 255.0f);
        pColors->g = (FLOAT) ((*pul >>  8) & 255) * (1.0f / 255.0f);
        pColors->b = (FLOAT) ((*pul >>  0) & 255) * (1.0f / 255.0f);
        pColors->a = 1.0f;

        pul++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(R5G6B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >> 11) & 31) * (1.0f / 31.0f);
        pColors->g = (FLOAT) ((*pus >>  5) & 63) * (1.0f / 63.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 31) * (1.0f / 31.0f);
        pColors->a = 1.0f;

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(X1R5G5B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >> 10) & 31) * (1.0f / 31.0f);
        pColors->g = (FLOAT) ((*pus >>  5) & 31) * (1.0f / 31.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 31) * (1.0f / 31.0f);
        pColors->a = 1.0f;

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A1R5G5B5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >> 10) & 31) * (1.0f / 31.0f);
        pColors->g = (FLOAT) ((*pus >>  5) & 31) * (1.0f / 31.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 31) * (1.0f / 31.0f);
        pColors->a = (FLOAT) ((*pus >> 15) &  1) * (1.0f /  1.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A4R4G4B4)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >>  8) & 15) * (1.0f / 15.0f);
        pColors->g = (FLOAT) ((*pus >>  4) & 15) * (1.0f / 15.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 15) * (1.0f / 15.0f);
        pColors->a = (FLOAT) ((*pus >> 12) & 15) * (1.0f / 15.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(R3G3B2)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        pColors->r = (FLOAT) ((*pub >>  5) & 7) * (1.0f / 7.0f);
        pColors->g = (FLOAT) ((*pub >>  2) & 7) * (1.0f / 7.0f);
        pColors->b = (FLOAT) ((*pub >>  0) & 3) * (1.0f / 3.0f);
        pColors->a = 1.0f;

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        pColors->r = 1.0f;
        pColors->g = 1.0f;
        pColors->b = 1.0f;
        pColors->a = (FLOAT) *pub * (1.0f / 255.0f);

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8R3G3B2)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >>  5) &   7) * (1.0f /   7.0f);
        pColors->g = (FLOAT) ((*pus >>  2) &   7) * (1.0f /   7.0f);
        pColors->b = (FLOAT) ((*pus >>  0) &   3) * (1.0f /   3.0f);
        pColors->a = (FLOAT) ((*pus >>  8) & 255) * (1.0f / 255.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(X4R4G4B4)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) ((*pus >>  8) & 15) * (1.0f / 15.0f);
        pColors->g = (FLOAT) ((*pus >>  4) & 15) * (1.0f / 15.0f);
        pColors->b = (FLOAT) ((*pus >>  0) & 15) * (1.0f / 15.0f);
        pColors->a = 1.0f;

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8P8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        *pColors = m_pPalette[*pus & 255];
        pColors->a = (FLOAT) ((*pus >>  8) & 255) * (1.0f / 255.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(P8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        *pColors = m_pPalette[*pub];

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(L8)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        pColors->r = pColors->g = pColors->b = (FLOAT) *pub * (1.0f / 255.0f);
        pColors->a = 1.0f;

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A8L8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = pColors->g = pColors->b = (FLOAT) ((*pus >>  0) & 255) * (1.0f / 255.0f);
        pColors->a = (FLOAT) ((*pus >> 8) & 255) * (1.0f / 255.0f);

        pus++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}


DECODE(A4L4)
{
    UINT8 *pub = (UINT8 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT8 *pubLim = pub + m_uWidth;

    while(pub < pubLim)
    {
        pColors->r = pColors->g = pColors->b = (FLOAT) ((*pub >>  0) & 15) * (1.0f / 15.0f);
        pColors->a = (FLOAT) ((*pub >> 4) & 15) * (1.0f / 15.0f);

        pub++;
        pColors++;
    }

    if(m_bColorKey)
        ColorKey(pColors - m_uWidth);
}

DECODE(V8U8)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        pColors->r = (FLOAT) (INT8) ((*pus >> 0) & 255) * (1.0f / 128.0f);
        pColors->g = (FLOAT) (INT8) ((*pus >> 8) & 255) * (1.0f / 128.0f);
        pColors->b = 0.0f;
        pColors->a = 1.0f;

        pus++;
        pColors++;
    }
}


DECODE(L6V5U5)
{
    UINT16 *pus = (UINT16 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT16 *pusLim = pus + m_uWidth;

    while(pus < pusLim)
    {
        INT8 iU = (INT8) ((*pus >>  0) & 31);
        INT8 iV = (INT8) ((*pus >>  5) & 31);

        // Sign extension
        iU <<= 3; iU >>= 3;
        iV <<= 3; iV >>= 3; 

        pColors->r = (FLOAT) iU * (1.0f / 16.0f);
        pColors->g = (FLOAT) iV * (1.0f / 16.0f);
        pColors->b = 0.0f;
        pColors->a = (FLOAT) ((*pus >> 10) & 63) * (1.0f / 63.0f);

        pus++;
        pColors++;
    }
}


DECODE(X8L8V8U8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) (INT8) ((*pul >>  0) & 255) * (1.0f / 128.0f);
        pColors->g = (FLOAT) (INT8) ((*pul >>  8) & 255) * (1.0f / 128.0f);
        pColors->b = 0.0f;
        pColors->a = (FLOAT) ((*pul >> 16) & 255) * (1.0f / 255.0f);

        pul++;
        pColors++;
    }
}


DECODE(Q8W8V8U8)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) (INT8) ((*pul >>  0) & 255) * (1.0f / 128.0f);
        pColors->g = (FLOAT) (INT8) ((*pul >>  8) & 255) * (1.0f / 128.0f);
        pColors->b = (FLOAT) (INT8) ((*pul >> 16) & 255) * (1.0f / 128.0f);
        pColors->a = (FLOAT) (INT8) ((*pul >> 24) & 255) * (1.0f / 128.0f);

        pul++;
        pColors++;
    }
}


DECODE(V16U16)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        pColors->r = (FLOAT) (INT16) ((*pul >>  0) & 65535) * (1.0f / 32768.0f);
        pColors->g = (FLOAT) (INT16) ((*pul >> 16) & 65535) * (1.0f / 32768.0f);
        pColors->b = 0.0f;
        pColors->a = 1.0f;

        pul++;
        pColors++;
    }
}


DECODE(W11V11U10)
{
    UINT32 *pul = (UINT32 *) (m_pbData + uRow * m_uPitch + uSlice * m_uSlice);
    UINT32 *pulLim = pul + m_uWidth;

    while(pul < pulLim)
    {
        INT16 iU = (INT16) ((*pul >>  0) & 1023);
        INT16 iV = (INT16) ((*pul >> 10) & 2047);
        INT16 iW = (INT16) ((*pul >> 21) & 2047);

        // Sign extension
        iU <<= 6; iU >>= 6;
        iV <<= 5; iV >>= 5;
        iW <<= 5; iW >>= 5;

        pColors->r = (FLOAT) iU * (1.0f /  512.0f);
        pColors->g = (FLOAT) iV * (1.0f / 1024.0f);
        pColors->b = (FLOAT) iW * (1.0f / 1024.0f);
        pColors->a = 1.0f;

        pul++;
        pColors++;
    }
}





///////////////////////////////////////////////////////////////////////////
// CD3DXCodecYUV //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

CD3DXCodecYUV::CD3DXCodecYUV(D3DX_BLT *pBlt)
    : CD3DXCodec(pBlt, 0, CODEC_RGB)
{
    m_CacheBox.Left   = m_Box.Left & ~1;
    m_CacheBox.Top    = 0;
    m_CacheBox.Front  = 0;
    m_CacheBox.Right  = (m_Box.Right + 1) & ~1;
    m_CacheBox.Bottom = 0;
    m_CacheBox.Back   = 0;

    m_uCacheWidth = m_CacheBox.Right - m_CacheBox.Left;

    m_bCacheDirty     = FALSE;
    m_bCacheAllocated = TRUE;

    if(!(m_pCache = new D3DXCOLOR[m_uCacheWidth]))
        m_bCacheAllocated = FALSE;

    if(D3DFMT_UYVY == pBlt->Format)
    {
        m_uYShift  = 8;
        m_uUVShift = 0;
    }
    else
    {
        m_uYShift  = 0;
        m_uUVShift = 8;
    }
}


CD3DXCodecYUV::~CD3DXCodecYUV()
{
    Commit();

    if(m_pCache)
        delete [] m_pCache;
}


HRESULT CD3DXCodecYUV::Commit()
{
    if(!m_bCacheDirty || !m_bCacheAllocated)
        return S_OK;


    // Write data
    UINT16 *pus = (UINT16 *) (m_pbData + m_CacheBox.Left * 2 + m_CacheBox.Top * m_uPitch + m_CacheBox.Front * m_uSlice);
    D3DXCOLOR *pCache = m_pCache;

    for(UINT uLeft = m_CacheBox.Left; uLeft < m_CacheBox.Right; uLeft += 2)
    {
        FLOAT fY0 =  65.481f * pCache[0].r + 128.553f * pCache[0].g +  24.966f * pCache[0].b;
        FLOAT fY1 =  65.481f * pCache[1].r + 128.553f * pCache[1].g +  24.966f * pCache[1].b;

        FLOAT fU  = -37.797f * pCache[0].r + -74.203f * pCache[0].g + 112.000f * pCache[0].b;
        FLOAT fV  = 112.000f * pCache[0].r + -93.786f * pCache[0].g + -18.214f * pCache[0].b;

        int nY0 = F2I(fY0 + 0.5f) + 16;
        int nY1 = F2I(fY1 + 0.5f) + 16;
        int nU  = F2I(fU + 0.5f) + 128;
        int nV  = F2I(fV + 0.5f) + 128;

        nY0 = (nY0 < 0) ? 0 : ((nY0 > 0xff) ? 0xff : nY0);
        nY1 = (nY1 < 0) ? 0 : ((nY1 > 0xff) ? 0xff : nY1);
        nU  = (nU  < 0) ? 0 : ((nU  > 0xff) ? 0xff : nU );
        nV  = (nV  < 0) ? 0 : ((nV  > 0xff) ? 0xff : nV );

        pus[0] = (UINT16) ((nY0 << m_uYShift) | (nU << m_uUVShift));
        pus[1] = (UINT16) ((nY1 << m_uYShift) | (nV << m_uUVShift));

        pCache += 2;
        pus += 2;
    }

    m_bCacheDirty = FALSE;
    return S_OK;
}


HRESULT CD3DXCodecYUV::Fetch(UINT uRow, UINT uSlice, BOOL bRead)
{
    HRESULT hr;

    if(!m_bCacheAllocated)
        return E_OUTOFMEMORY;

    if(uRow   >= m_CacheBox.Top   && uRow   < m_CacheBox.Bottom &&
       uSlice >= m_CacheBox.Front && uSlice < m_CacheBox.Back)
    {
        return S_OK;
    }

    // Flush dirty data in cache, if any
    if(FAILED(hr = Commit()))
        return hr;

    // Update cache rect
    m_CacheBox.Top    = uRow;
    m_CacheBox.Bottom = uRow + 1;
    m_CacheBox.Front  = uSlice;
    m_CacheBox.Back   = uSlice + 1;

    if(!bRead)
        return S_OK;


    // Read data
    UINT16 *pus = (UINT16 *) (m_pbData + m_CacheBox.Left * 2 + m_CacheBox.Top * m_uPitch + m_CacheBox.Front * m_uSlice);
    D3DXCOLOR *pCache = m_pCache;

    for(UINT uLeft = m_CacheBox.Left; uLeft < m_CacheBox.Right; uLeft += 2)
    {
        FLOAT fY0 = (FLOAT) ((pus[0] >> m_uYShift)  & 0xff) -  16.0f;
        FLOAT fU  = (FLOAT) ((pus[0] >> m_uUVShift) & 0xff) - 128.0f;

        FLOAT fY1 = (FLOAT) ((pus[1] >> m_uYShift)  & 0xff) -  16.0f;
        FLOAT fV  = (FLOAT) ((pus[1] >> m_uUVShift) & 0xff) - 128.0f;

        pCache[0].r = 0.00456621f * fY0                    + 0.00625893f * fV;
        pCache[0].g = 0.00456621f * fY0 - 0.00153632f * fU - 0.00318811f * fV;
        pCache[0].b = 0.00456621f * fY0 + 0.00791071f * fU;
        pCache[0].a = 1.0f;

        pCache[0].r = (pCache[0].r < 0.0f) ? 0.0f : ((pCache[0].r > 1.0f) ? 1.0f : pCache[0].r);
        pCache[0].g = (pCache[0].g < 0.0f) ? 0.0f : ((pCache[0].g > 1.0f) ? 1.0f : pCache[0].g);
        pCache[0].b = (pCache[0].b < 0.0f) ? 0.0f : ((pCache[0].b > 1.0f) ? 1.0f : pCache[0].b);

        pCache[1].r = 0.00456621f * fY1                    + 0.00625893f * fV;
        pCache[1].g = 0.00456621f * fY1 - 0.00153632f * fU - 0.00318811f * fV;
        pCache[1].b = 0.00456621f * fY1 + 0.00791071f * fU;
        pCache[1].a = 1.0f;

        pCache[1].r = (pCache[1].r < 0.0f) ? 0.0f : ((pCache[1].r > 1.0f) ? 1.0f : pCache[1].r);
        pCache[1].g = (pCache[1].g < 0.0f) ? 0.0f : ((pCache[1].g > 1.0f) ? 1.0f : pCache[1].g);
        pCache[1].b = (pCache[1].b < 0.0f) ? 0.0f : ((pCache[1].b > 1.0f) ? 1.0f : pCache[1].b);

        pCache += 2;
        pus += 2;
    }

    return S_OK;
}


void CD3DXCodecYUV::Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    uRow += m_Box.Top;
    uSlice += m_Box.Front;

    if(FAILED(Fetch(uRow, uSlice, m_uCacheWidth != m_uWidth)))
        return;

    memcpy(m_pCache + m_Box.Left - m_CacheBox.Left, pColors, m_uWidth * sizeof(D3DXCOLOR));
    m_bCacheDirty = TRUE;
}


void CD3DXCodecYUV::Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    uRow += m_Box.Top;
    uSlice += m_Box.Front;

    if(FAILED(Fetch(uRow, uSlice, TRUE)))
        return;

    memcpy(pColors, m_pCache + m_Box.Left - m_CacheBox.Left, m_uWidth * sizeof(D3DXCOLOR));

    if(m_bColorKey)
        ColorKey(pColors);
}



///////////////////////////////////////////////////////////////////////////
// CD3DXCodecDXT //////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


CD3DXCodecDXT::CD3DXCodecDXT(D3DX_BLT *pBlt)
    : CD3DXCodec(pBlt, 0, CODEC_RGB)
{
    m_bRepeat = FALSE;

    switch(pBlt->Region.Right)
    {
    case 1:
        m_uXRepeat = 0;
        m_bRepeat = TRUE;
        break;

    case 2:
        m_uXRepeat = 1;
        m_bRepeat = TRUE;
        break;

    default:
        m_uXRepeat = 3;
        break;
    }


    switch(pBlt->Region.Bottom)
    {
    case 1:
        m_uYRepeat = 0;
        m_bRepeat = TRUE;
        break;

    case 2:
        m_uYRepeat = 1;
        m_bRepeat = TRUE;
        break;

    default:
        m_uYRepeat = 3;
        break;
    }


    m_CacheBox.Left   = m_Box.Left & ~3;
    m_CacheBox.Top    = 0;
    m_CacheBox.Front  = 0;
    m_CacheBox.Right  = (m_Box.Right + 3) & ~3;
    m_CacheBox.Bottom = 0;
    m_CacheBox.Back   = 0;

    m_uTopMax     = 0;
    m_uCacheWidth = m_CacheBox.Right - m_CacheBox.Left;

    m_bCacheDirty     = FALSE;
    m_bCacheAllocated = TRUE;

    for(UINT i = 0; i < 4; i++)
    {
        if(!(m_ppCache[i] = new D3DXCOLOR[m_uCacheWidth]))
            m_bCacheAllocated = FALSE;
    }
}


CD3DXCodecDXT::~CD3DXCodecDXT()
{
    Commit();

    for(UINT i = 0; i < 4; i++)
    {
        if(m_ppCache[i])
            delete [] m_ppCache[i];
    }
}


HRESULT CD3DXCodecDXT::Commit()
{
    if(!m_bCacheDirty || !m_bCacheAllocated)
        return S_OK;

    BOOL bPremult = D3DX__Premult;

    for(UINT uLeft = m_CacheBox.Left; uLeft < (UINT) m_CacheBox.Right; uLeft += 4)
    {
        UINT32 ulBlock[16];
        LPBYTE pCell;

        // Copy cache data into block
        F2IBegin();
        UINT32 *pul = &ulBlock[0];

        if(bPremult)
        {
            for(UINT uY = 0; uY < 4; uY++)
            {
                D3DXCOLOR *pColor = m_ppCache[uY] + uLeft - m_CacheBox.Left;

                for(UINT uX = 0; uX < 4; uX++)
                {
                    *pul = (UINT32) ((F2I(pColor->r * pColor->a * 255.0f + 0.5f) << 16) |
                                     (F2I(pColor->g * pColor->a * 255.0f + 0.5f) <<  8) |
                                     (F2I(pColor->b * pColor->a * 255.0f + 0.5f) <<  0) |
                                     (F2I(pColor->a             * 255.0f + 0.5f) << 24));

                    pColor++;
                    pul++;
                }
            }
        }
        else
        {
            for(UINT uY = 0; uY < 4; uY++)
            {
                D3DXCOLOR *pColor = m_ppCache[uY] + uLeft - m_CacheBox.Left;

                for(UINT uX = 0; uX < 4; uX++)
                {
                    *pul = (UINT32) ((F2I(pColor->r * 255.0f + 0.5f) << 16) |
                                     (F2I(pColor->g * 255.0f + 0.5f) <<  8) |
                                     (F2I(pColor->b * 255.0f + 0.5f) <<  0) |
                                     (F2I(pColor->a * 255.0f + 0.5f) << 24));


                    pColor++;
                    pul++;
                }
            }
        }

        F2IEnd();


        // Repeat data for degenerate case
        if(m_bRepeat)
        {
            for(UINT uY = 0; uY < 4; uY++)
            {
                for(UINT uX = 0; uX < 4; uX++)
                {
                    ulBlock[(uY << 2) + uX] = ulBlock[((uY & m_uYRepeat) << 2) + (uX & m_uXRepeat)];
                }
            }
        }


        // Encode DXT block
        switch (m_Format)
        {
        case D3DFMT_DXT1:
            pCell = m_pbData + m_CacheBox.Front * m_uSlice + (m_CacheBox.Top >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockRGB);
            XXEncodeBlockRGB((S3TC_COLOR *) &ulBlock[0], (S3TCBlockRGB *) pCell);
            break;

        case D3DFMT_DXT2:
#if 0
        case D3DFMT_DXT3:
#endif
            pCell = m_pbData + m_CacheBox.Front * m_uSlice + (m_CacheBox.Top >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockAlpha4);
            EncodeBlockAlpha4((S3TC_COLOR *) &ulBlock[0], (S3TCBlockAlpha4 *) pCell);
            break;

        case D3DFMT_DXT4:
#if 0
        case D3DFMT_DXT5:
#endif
            pCell = m_pbData + m_CacheBox.Front * m_uSlice + (m_CacheBox.Top >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockAlpha3);
            EncodeBlockAlpha3((S3TC_COLOR *) &ulBlock[0], (S3TCBlockAlpha3 *) pCell);
            pCell = pCell;
            break;
        }
    }

    m_bCacheDirty = FALSE;
    return S_OK;
}


HRESULT CD3DXCodecDXT::Fetch(UINT uRow, UINT uSlice, BOOL bRead)
{
    HRESULT hr;

    if(!m_bCacheAllocated)
        return E_OUTOFMEMORY;

    if(uRow   >= m_CacheBox.Top   && uRow   < m_CacheBox.Bottom &&
       uSlice >= m_CacheBox.Front && uSlice < m_CacheBox.Back)
    {
        return S_OK;
    }

    // Flush dirty data in cache, if any
    if(FAILED(hr = Commit()))
        return hr;



    // Update cache rect
    m_CacheBox.Top    = uRow & ~3;
    m_CacheBox.Bottom = m_CacheBox.Top + 4;
    m_CacheBox.Front  = uSlice;
    m_CacheBox.Back   = uSlice + 1;

    if(m_uTopMax <= m_CacheBox.Top)
    {
        m_uTopMax = m_CacheBox.Top;

        if(!bRead)
            return S_OK;
    }



    // Read data
    BOOL bPremult = D3DX__Premult;

    for(UINT uLeft = m_CacheBox.Left; uLeft < (UINT) m_CacheBox.Right; uLeft += 4)
    {
        UINT32 ulBlock[16];
        LPBYTE pCell;

        // Decode DXT block
        switch (m_Format)
        {
        case D3DFMT_DXT1:
            pCell = m_pbData + uSlice * m_uSlice + (uRow >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockRGB);
            XXDecodeBlockRGB((S3TCBlockRGB *) pCell, (S3TC_COLOR *) &ulBlock[0]);
            break;

        case D3DFMT_DXT2:
#if 0
        case D3DFMT_DXT3:
#endif
            pCell = m_pbData + uSlice * m_uSlice + (uRow >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockAlpha4);
            DecodeBlockAlpha4((S3TCBlockAlpha4 *) pCell, (S3TC_COLOR *) &ulBlock[0]);
            break;

        case D3DFMT_DXT4:
#if 0
        case D3DFMT_DXT5:
#endif
            pCell = m_pbData + uSlice * m_uSlice + (uRow >> 2) * m_uPitch + (uLeft >> 2) * sizeof(S3TCBlockAlpha3);
            DecodeBlockAlpha3((S3TCBlockAlpha3 *) pCell, (S3TC_COLOR *) &ulBlock[0]);
            break;
        }


        // Copy block data into cache
        UINT32 *pul = &ulBlock[0];

        for(UINT uY = 0; uY < 4; uY++)
        {
            D3DXCOLOR *pColor = m_ppCache[uY] + uLeft - m_CacheBox.Left;

            for(UINT uX = 0; uX < 4; uX++)
            {
                pColor->a = (FLOAT) ((*pul >> 24) & 255) * (1.0f / 255.0f);
                pColor->r = (FLOAT) ((*pul >> 16) & 255) * (1.0f / 255.0f);
                pColor->g = (FLOAT) ((*pul >>  8) & 255) * (1.0f / 255.0f);
                pColor->b = (FLOAT) ((*pul >>  0) & 255) * (1.0f / 255.0f);

                if(bPremult)
                {
                    if(0.0f == pColor->a)
                    {
                        pColor->r = 0.0f;
                        pColor->g = 0.0f;
                        pColor->b = 0.0f;
                    }
                    else if(1.0f > pColor->a)
                    {
                        pColor->r = (pColor->r < pColor->a) ? (pColor->r / pColor->a) : 1.0f;
                        pColor->g = (pColor->g < pColor->a) ? (pColor->g / pColor->a) : 1.0f;
                        pColor->b = (pColor->b < pColor->a) ? (pColor->b / pColor->a) : 1.0f;
                    }
                }

                pColor++;
                pul++;
            }
        }
    }

    return S_OK;
}


void CD3DXCodecDXT::Encode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    uRow += m_Box.Top;
    uSlice += m_Box.Front;

    if(FAILED(Fetch(uRow, uSlice, m_uCacheWidth != m_uWidth)))
        return;

    memcpy(m_ppCache[uRow - m_CacheBox.Top] + m_Box.Left - m_CacheBox.Left, pColors, m_uWidth * sizeof(D3DXCOLOR));
    m_bCacheDirty = TRUE;
}


void CD3DXCodecDXT::Decode(UINT uRow, UINT uSlice, D3DXCOLOR *pColors)
{
    uRow += m_Box.Top;
    uSlice += m_Box.Front;

    if(FAILED(Fetch(uRow, uSlice, TRUE)))
        return;

    memcpy(pColors, m_ppCache[uRow - m_CacheBox.Top] + m_Box.Left - m_CacheBox.Left, m_uWidth * sizeof(D3DXCOLOR));

    if(m_bColorKey)
        ColorKey(pColors);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\tex\CD3DXImage.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXImage.cpp
//  Content:    Image loader
//
///////////////////////////////////////////////////////////////////////////

#include "pchtex.h"
///////////////////////////////////////////////////////////////////////////
// From wingdi.h
///////////////////////////////////////////////////////////////////////////

typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER, FAR *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;

#include <pshpack2.h>
typedef struct tagBITMAPFILEHEADER {
        WORD    bfType;
        DWORD   bfSize;
        WORD    bfReserved1;
        WORD    bfReserved2;
        DWORD   bfOffBits;
} BITMAPFILEHEADER, FAR *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;
#include <poppack.h>

// The following two structures are used for defining RGB's in terms of CIEXYZ.
typedef long            FXPT2DOT30, FAR *LPFXPT2DOT30;

typedef struct tagCIEXYZ
{
        FXPT2DOT30 ciexyzX;
        FXPT2DOT30 ciexyzY;
        FXPT2DOT30 ciexyzZ;
} CIEXYZ;
typedef CIEXYZ  FAR *LPCIEXYZ;

typedef struct tagICEXYZTRIPLE
{
        CIEXYZ  ciexyzRed;
        CIEXYZ  ciexyzGreen;
        CIEXYZ  ciexyzBlue;
} CIEXYZTRIPLE;
typedef CIEXYZTRIPLE    FAR *LPCIEXYZTRIPLE;

typedef struct {
        DWORD        bV4Size;
        LONG         bV4Width;
        LONG         bV4Height;
        WORD         bV4Planes;
        WORD         bV4BitCount;
        DWORD        bV4V4Compression;
        DWORD        bV4SizeImage;
        LONG         bV4XPelsPerMeter;
        LONG         bV4YPelsPerMeter;
        DWORD        bV4ClrUsed;
        DWORD        bV4ClrImportant;
        DWORD        bV4RedMask;
        DWORD        bV4GreenMask;
        DWORD        bV4BlueMask;
        DWORD        bV4AlphaMask;
        DWORD        bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD        bV4GammaRed;
        DWORD        bV4GammaGreen;
        DWORD        bV4GammaBlue;
} BITMAPV4HEADER, FAR *LPBITMAPV4HEADER, *PBITMAPV4HEADER;

/* constants for the biCompression field */
#define BI_RGB        0L
#define BI_RLE8       1L
#define BI_RLE4       2L
#ifndef BI_BITFIELDS
#define BI_BITFIELDS  3L
#endif  // BI_BITFIELDS
#define BI_JPEG       4L
#define BI_PNG        5L

typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

///////////////////////////////////////////////////////////////////////////
// CD3DXImage /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


CD3DXImage::CD3DXImage()
{
    m_Format         = D3DFMT_UNKNOWN;
    m_pvData         = NULL;
    m_pPalette       = NULL;
    m_bDeleteData    = FALSE;
    m_bDeletePalette = FALSE;
    m_pMip           = NULL;
    m_pFace          = NULL;
}


CD3DXImage::~CD3DXImage()
{
    if(m_pvData && m_bDeleteData)
        delete [] m_pvData;

    if(m_pPalette && m_bDeletePalette)
        delete [] m_pPalette;

    if(m_pMip)
        delete m_pMip;

    if(m_pFace)
        delete m_pFace;
}


HRESULT CD3DXImage::Load(LPCVOID pvData, DWORD cbData, D3DXIMAGE_INFO *pInfo)
{
    HRESULT hr;

    for(int i = 0; i < 7; i++)
    {
        switch(i)
        {
        case 0: hr = LoadBMP(pvData, cbData); break;
        case 1: hr = LoadPPM(pvData, cbData); break;
        case 2: hr = LoadDDS(pvData, cbData); break;
        case 3: hr = LoadJPG(pvData, cbData); break;
        case 4: hr = LoadPNG(pvData, cbData); break;
        case 5: hr = LoadTGA(pvData, cbData); break;
        case 6: hr = LoadDIB(pvData, cbData); break;
        }

        if(SUCCEEDED(hr))
            break;

        if(m_pvData && m_bDeleteData)
            delete [] m_pvData;

        if(m_pPalette && m_bDeletePalette)
            delete [] m_pPalette;

        if(m_pMip)
            delete m_pMip;

        if(m_pFace)
            delete m_pFace;

        m_pvData         = NULL;
        m_pPalette       = NULL;
        m_bDeleteData    = FALSE;
        m_bDeletePalette = FALSE;
        m_pMip           = NULL;
        m_pFace          = NULL;
    }

    if(7 == i)
    {
        DPF(0, "Unsupported file format");
        return D3DXERR_INVALIDDATA;
    }


    // Fill in info struct
    if(pInfo)
    {
        memset(pInfo, 0x00, sizeof(D3DXIMAGE_INFO));

        pInfo->Width     = (UINT) m_Rect.right;
        pInfo->Height    = (UINT) m_Rect.bottom;
        pInfo->Depth     = 1;
        pInfo->MipLevels = 1;
        pInfo->Format    = m_Format;

        for(CD3DXImage *pImage = this; pImage->m_pMip; pImage = pImage->m_pMip)
            pInfo->MipLevels++;
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// LoadBMP ///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


HRESULT CD3DXImage::LoadBMP(LPCVOID pvData, DWORD cbData)
{
    // Examine header
    if(cbData < sizeof(BITMAPFILEHEADER))
        return E_FAIL;

    BITMAPFILEHEADER *pFH = (BITMAPFILEHEADER *) pvData;

    if(pFH->bfType != (('B') | ('M' << 8)) || pFH->bfSize > cbData)
        return E_FAIL;

    return LoadDIB((BYTE *) pvData + sizeof(BITMAPFILEHEADER), cbData - sizeof(BITMAPFILEHEADER));
}


HRESULT CD3DXImage::LoadDIB(LPCVOID pvData, DWORD cbData)
{
    UNALIGNED BITMAPINFOHEADER *pIH;
    DWORD_PTR dwWidth, dwHeight, dwOffset, dwClrUsed;

    if(cbData < sizeof(BITMAPINFOHEADER))
        return E_FAIL;

    pIH = (BITMAPINFOHEADER *) pvData;

    if(pIH->biSize < sizeof(BITMAPINFOHEADER))
        return E_FAIL;

    dwWidth   = (DWORD_PTR) (pIH->biWidth);
    dwHeight  = (DWORD_PTR) (pIH->biHeight > 0 ? pIH->biHeight : -pIH->biHeight);
    dwClrUsed = (DWORD_PTR) (pIH->biClrUsed);

    if((pIH->biBitCount <= 8) && (0 == dwClrUsed))
        dwClrUsed = (DWORD_PTR) (1 << pIH->biBitCount);

    dwOffset  = (DWORD_PTR) pIH->biSize + dwClrUsed * sizeof(DWORD);

    if(dwOffset > (DWORD_PTR) cbData)
        return E_FAIL;

    if(pIH->biPlanes != 1)
        return E_FAIL;


    // Only RGB and BITFIELD bitmaps can be inverted
    if(pIH->biHeight < 0 && pIH->biCompression != BI_RGB && pIH->biCompression != BI_BITFIELDS)
        return E_FAIL;


    // Compute format
    DWORD dwB, dwG, dwR, dwA;
    D3DFORMAT Format = D3DFMT_UNKNOWN;

    switch(pIH->biCompression)
    {
    case BI_RGB:
    case BI_RLE4:
    case BI_RLE8:

        switch(pIH->biBitCount)
        {
        case 1:
        case 4:
        case 8:
            Format = D3DFMT_P8;
            break;

        case 16:
            Format = D3DFMT_X1R5G5B5;
            break;

        case 24:
#if 0
            Format = D3DFMT_R8G8B8;
            break;
#endif
        case 32:
            Format = D3DFMT_X8R8G8B8;
            break;

        default:
            return E_FAIL;
        }
        break;

    case BI_BITFIELDS:
        if(pIH->biSize < sizeof(BITMAPV4HEADER))
            return E_FAIL;

        dwB = ((BITMAPV4HEADER *) pIH)->bV4BlueMask;
        dwG = ((BITMAPV4HEADER *) pIH)->bV4GreenMask;
        dwR = ((BITMAPV4HEADER *) pIH)->bV4RedMask;
        dwA = ((BITMAPV4HEADER *) pIH)->bV4AlphaMask;

        switch(pIH->biBitCount)
        {
        case 16:
            if(dwB == 0x00ff && dwG == 0x00ff && dwR == 0x00ff && dwA == 0xff00)
                Format = D3DFMT_A8L8;

            else if(dwB == 0x001f && dwG == 0x07e0 && dwR == 0xf800 && dwA == 0x0000)
                Format = D3DFMT_R5G6B5;

            else if(dwB == 0x001f && dwG == 0x03e0 && dwR == 0x7c00 && dwA == 0x0000)
                Format = D3DFMT_X1R5G5B5;

            else if(dwB == 0x001f && dwG == 0x03e0 && dwR == 0x7c00 && dwA == 0x8000)
                Format = D3DFMT_A1R5G5B5;

            else if(dwB == 0x000f && dwG == 0x00f0 && dwR == 0x0f00 && dwA == 0xf000)
                Format = D3DFMT_A4R4G4B4;
#if 0
            else if(dwB == 0x0003 && dwG == 0x001c && dwR == 0x00e0 && dwA == 0xff00)
                Format = D3DFMT_A8R3G3B2;
#endif
            break;

        case 24:
            if(dwB == 0x0000ff && dwG == 0x00ff00 && dwR == 0xff0000 && dwA == 0x000000)
#if 0                
                Format = D3DFMT_R8G8B8;
#else
                Format = D3DFMT_X8R8G8B8;
#endif
            break;

        case 32:
            if(dwB == 0x000000ff && dwG == 0x0000ff00 && dwR == 0x00ff0000 && dwA == 0x00000000)
                Format = D3DFMT_X8R8G8B8;

            else if(dwB == 0x000000ff && dwG == 0x0000ff00 && dwR == 0x00ff0000 && dwA == 0xff000000)
                Format = D3DFMT_A8R8G8B8;

            break;
        }

        break;

    default:
        DPF(0, "LoadBMP: JPEG compression not supported");
        return E_NOTIMPL;
    }


    if(D3DFMT_UNKNOWN == Format)
    {
        return E_FAIL;
    }


    if(D3DFMT_P8 == Format)
    {
        DWORD dwClrUsed = pIH->biClrUsed;

        if(!dwClrUsed)
            dwClrUsed = 1 << pIH->biBitCount;

        m_bDeletePalette = TRUE;

        if(!(m_pPalette = new PALETTEENTRY[256]))
            return E_OUTOFMEMORY;

        DWORD dw;
        RGBQUAD* prgb = (RGBQUAD*) (((BYTE *) pIH) + pIH->biSize);

        for(dw = 0; dw < dwClrUsed; dw++, prgb++)
        {
            m_pPalette[dw].peRed   = prgb->rgbRed;
            m_pPalette[dw].peGreen = prgb->rgbGreen;
            m_pPalette[dw].peBlue  = prgb->rgbBlue;
            m_pPalette[dw].peFlags = 0xff;
        }

        for(dw = dwClrUsed; dw < 256; dw++)
        {
            m_pPalette[dw].peRed   = 0xff;
            m_pPalette[dw].peGreen = 0xff;
            m_pPalette[dw].peBlue  = 0xff;
            m_pPalette[dw].peFlags = 0xff;
        }
    }



    DWORD_PTR dwWidthBytes;
    DWORD_PTR dwSrcInc, dwDstInc;

    switch(pIH->biBitCount)
    {
    case 1:
        dwWidthBytes = dwWidth;
        dwSrcInc = ((dwWidth >> 3) + 3) & ~3;
        break;

    case 4:
        dwWidthBytes = dwWidth;
        dwSrcInc = ((dwWidth >> 1) + 3) & ~3;
        break;

    default:
        dwWidthBytes = (dwWidth * (pIH->biBitCount >> 3));
        dwSrcInc = (dwWidthBytes + 3) & ~3;
        break;
    }

    m_Format  = Format;
    m_cbPitch = (DWORD)((dwWidthBytes + 3) & ~3);

    m_Rect.left   = 0;
    m_Rect.top    = 0;
    m_Rect.right  = (DWORD)dwWidth;
    m_Rect.bottom = (DWORD)dwHeight;
#if 1
    if (pIH->biBitCount == 24 && Format == D3DFMT_X8R8G8B8)
    {
        UNALIGNED BYTE* pbSrc;
        DWORD*          pdwDst;
        int             nStrideDst;
        UINT            i, j;
        UINT            nAdjustSrc;
        
        nAdjustSrc = dwSrcInc - dwWidthBytes;

        dwWidthBytes = (dwWidth * (32 >> 3));
        m_cbPitch = (DWORD)((dwWidthBytes + 3) & ~3);

        m_bDeleteData = TRUE;

        m_pvData = new BYTE[dwHeight * m_cbPitch];
        if (!m_pvData)
            return E_OUTOFMEMORY;

        pbSrc = ((BYTE*)pvData) + dwOffset;
        if (pIH->biHeight < 0)
        {
            pdwDst = (DWORD*)m_pvData;
            nStrideDst = m_cbPitch >> 2;
        }
        else
        {
            pdwDst = (DWORD*)((BYTE*)m_pvData + m_cbPitch * (dwHeight - 1));
            nStrideDst = -(int)(m_cbPitch >> 2);
        }

        for (i = 0; i < dwHeight; i++)
        {
            for (j = 0; j < dwWidth; j++)
            {
                pdwDst[j] = pbSrc[2] << 16 | pbSrc[1] << 8 | *pbSrc;
                pbSrc += 3;
            }

            pbSrc += nAdjustSrc;
            pdwDst += nStrideDst;
        }

        return S_OK;
    }
#endif
    if(pIH->biHeight < 0 && pIH->biBitCount >= 8)
    {
        // The data is in the correct format already in the file..
        // just return a pointer to the data in the file without
        // copying it.  (This is valid since this object will be
        // destroyed before the API function returns to the user.)

        m_bDeleteData = FALSE;
        m_pvData = ((BYTE *) pvData) + dwOffset;

        return S_OK;
    }


    // Data in file needs to be converted.. so lets allocate the destination
    // buffer which will contain the image..

    m_bDeleteData = TRUE;
    m_pvData  = new BYTE[dwHeight * m_cbPitch];

    if(!m_pvData)
        return E_OUTOFMEMORY;

    UNALIGNED BYTE *pbSrc, *pbDest, *pbDestMin, *pbDestLim, *pbDestLine;

    pbSrc = ((BYTE *) pvData) + dwOffset;

    if(pIH->biHeight < 0)
    {
        dwDstInc = m_cbPitch;
        pbDest = (BYTE *) m_pvData;
    }
    else
    {
        dwDstInc = 0 - (DWORD_PTR)m_cbPitch;
        pbDest = (BYTE *) m_pvData + (dwHeight - 1) * m_cbPitch;
    }

    pbDestLine = pbDest;
    pbDestMin = (BYTE *) m_pvData;
    pbDestLim = (BYTE *) m_pvData + dwHeight * m_cbPitch;



    if(BI_RLE4 == pIH->biCompression)
    {
        // RLE4. Always encoded upsidedown.

        while(pbDest >= pbDestMin)
        {
            if(0 == pbSrc[0])
            {
                switch(pbSrc[1])
                {
                case 0:
                    D3DXASSERT(pbDest == pbDestLine + dwWidth);
                    pbDestLine -= m_cbPitch;
                    pbDest = pbDestLine;
                    break;

                case 1:
                    pbDest = pbDestMin - m_cbPitch;
                    break;

                case 2:
                    pbDest += pbSrc[2] - pbSrc[3] * m_cbPitch;
                    pbSrc += 2;
                    break;

                default:
                    for(int i = 0; i < pbSrc[1]; i++)
                        pbDest[i] = (i & 1) ?  (pbSrc[2 + (i >> 1)] & 0x0f) : (pbSrc[2 + (i >> 1)] >> 4);

                    pbDest += pbSrc[1];
                    pbSrc += ((pbSrc[1] >> 1) + 1) & ~1;
                    break;
                }
            }
            else
            {
                for(int i = 0; i < pbSrc[0]; i++)
                    pbDest[i] = (i & 1) ? (pbSrc[1] & 0x0f) : (pbSrc[1] >> 4);

                pbDest += pbSrc[0];
            }

            pbSrc += 2;
        }

        return S_OK;
    }

    if(pIH->biCompression == BI_RLE8)
    {
        // RLE8. Always encoded upsidedown.

        while(pbDest >= pbDestMin)
        {
            if(0 == pbSrc[0])
            {
                switch(pbSrc[1])
                {
                case 0:
                    D3DXASSERT(pbDest == pbDestLine + dwWidth);
                    pbDestLine -= m_cbPitch;
                    pbDest = pbDestLine;
                    break;

                case 1:
                    pbDest = pbDestMin - m_cbPitch;
                    break;

                case 2:
                    pbDest += pbSrc[2] - pbSrc[3] * m_cbPitch;
                    pbSrc += 2;
                    break;

                default:
                    memcpy(pbDest, pbSrc + 2, pbSrc[1]);
                    pbDest += pbSrc[1];
                    pbSrc += (pbSrc[1] + 1) & ~1;
                    break;
                }
            }
            else
            {
                memset(pbDest, pbSrc[1], pbSrc[0]);
                pbDest += pbSrc[0];
            }

            pbSrc += 2;
        }

        return S_OK;
    }


    if(1 == pIH->biBitCount)
    {
        while(pbDest >= pbDestMin && pbDest < pbDestLim)
        {
            for(UINT i = 0; i < dwWidth; i++)
                pbDest[i] = (pbSrc[i >> 3] >> (7 - (i & 7))) & 1;

            pbDest += dwDstInc;
            pbSrc  += dwSrcInc;
        }

        return S_OK;
    }

    if(4 == pIH->biBitCount)
    {
        while(pbDest >= pbDestMin && pbDest < pbDestLim)
        {
            for(UINT i = 0; i < dwWidth; i++)
                pbDest[i] = (i & 1) ? pbSrc[i >> 1] & 0x0f : (pbSrc[i >> 1] >> 4);

            pbDest += dwDstInc;
            pbSrc  += dwSrcInc;
        }

        return S_OK;
    }


    while(pbDest >= pbDestMin && pbDest < pbDestLim)
    {
        memcpy(pbDest, pbSrc, dwWidthBytes);

        pbDest += dwDstInc;
        pbSrc  += dwSrcInc;
    }

    return S_OK;
}



//////////////////////////////////////////////////////////////////////////////
// LoadJPG ///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

struct d3dx_jpeg_error_mgr : public D3DX::jpeg_error_mgr
{
    jmp_buf setjmp_buffer;
};

struct d3dx_jpeg_source_mgr : public D3DX::jpeg_source_mgr
{
    LPCVOID pvData;
    DWORD   cbData;
};



static void
d3dx_jpeg_error_exit (D3DX::j_common_ptr cinfo)
{
    (*cinfo->err->output_message) (cinfo);
    longjmp(((d3dx_jpeg_error_mgr *) cinfo->err)->setjmp_buffer, 1);
}

static void
d3dx_jpeg_ignore_message (D3DX::j_common_ptr cinfo)
{
}

static void
d3dx_jpeg_output_message (D3DX::j_common_ptr cinfo)
{
  char sz[JMSG_LENGTH_MAX];

  (*cinfo->err->format_message) (cinfo, sz);
  DPF(0, "LoadJPG: %s", sz);
}

static void
d3dx_jpeg_init_source(D3DX::j_decompress_ptr cinfo)
{
}

static boolean
d3dx_jpeg_fill_input_buffer(D3DX::j_decompress_ptr cinfo)
{
    d3dx_jpeg_source_mgr *psrc = (d3dx_jpeg_source_mgr *) cinfo->src;

    psrc->next_input_byte = (BYTE *) psrc->pvData;
    psrc->bytes_in_buffer = psrc->cbData;

    return TRUE;
}

static void
d3dx_jpeg_skip_input_data(D3DX::j_decompress_ptr cinfo, long num_bytes)
{
    d3dx_jpeg_source_mgr *psrc = (d3dx_jpeg_source_mgr *) cinfo->src;

    psrc->next_input_byte += (size_t) num_bytes;
    psrc->bytes_in_buffer -= (size_t) num_bytes;
}


static void
d3dx_jpeg_term_source(D3DX::j_decompress_ptr cinfo)
{
}


HRESULT CD3DXImage::LoadJPG(LPCVOID pvData, DWORD cbData)
{
    HRESULT hr;

    D3DX::jpeg_decompress_struct cinfo;
    d3dx_jpeg_source_mgr *psrc;
    d3dx_jpeg_error_mgr err;

    D3DX::JSAMPARRAY pBuffer;

    cinfo.err = D3DX::jpeg_std_error(&err);
    err.error_exit = d3dx_jpeg_error_exit;
    err.output_message = d3dx_jpeg_ignore_message;

    if(setjmp(err.setjmp_buffer))
    {
        hr = E_FAIL;
        goto LDone;
    }

    D3DX::jpeg_CreateDecompress(&cinfo, JPEG_LIB_VERSION, sizeof(cinfo));



    cinfo.src = (struct D3DX::jpeg_source_mgr *)
      (*cinfo.mem->alloc_small) ((D3DX::j_common_ptr) &cinfo, JPOOL_PERMANENT, sizeof(d3dx_jpeg_source_mgr));

    psrc = (d3dx_jpeg_source_mgr *) cinfo.src;
    psrc->init_source       = d3dx_jpeg_init_source;
    psrc->fill_input_buffer = d3dx_jpeg_fill_input_buffer;
    psrc->skip_input_data   = d3dx_jpeg_skip_input_data;
    psrc->resync_to_restart = D3DX::jpeg_resync_to_restart;
    psrc->term_source       = d3dx_jpeg_term_source;
    psrc->bytes_in_buffer   = 0;
    psrc->next_input_byte   = NULL;
    psrc->cbData            = cbData;
    psrc->pvData            = pvData;


    D3DX::jpeg_read_header(&cinfo, TRUE);
    err.output_message = d3dx_jpeg_output_message;
    D3DX::jpeg_start_decompress(&cinfo);


    switch(cinfo.output_components)
    {
    case 1:
        m_Format = D3DFMT_L8;
        m_cbPitch = cinfo.output_width;
        break;

    case 3:
        m_Format = D3DFMT_X8R8G8B8;
        m_cbPitch = cinfo.output_width * sizeof(DWORD);
        break;

    default:
        hr = E_FAIL;
        goto LDone;
    }


    m_bDeleteData = TRUE;

    m_Rect.left = 0;
    m_Rect.top = 0;
    m_Rect.right = cinfo.output_width;
    m_Rect.bottom = cinfo.output_height;

    if(!(m_pvData = new BYTE[cinfo.output_height * m_cbPitch]))
    {
        hr = E_OUTOFMEMORY;
        goto LDone;
    }

    if(!(pBuffer = (*cinfo.mem->alloc_sarray)((D3DX::j_common_ptr) &cinfo, 
        JPOOL_IMAGE, cinfo.output_width * cinfo.output_components, 1)))
    {
        hr = E_OUTOFMEMORY;
        goto LDone;
    }


    if(D3DFMT_L8 == m_Format)
    {
        UINT8 *pubDest;
        pubDest = (UINT8 *) m_pvData;

        while(cinfo.output_scanline < cinfo.output_height)
        {
            D3DX::jpeg_read_scanlines(&cinfo, pBuffer, 1);
            memcpy(pubDest, pBuffer[0], cinfo.output_width);
            pubDest += cinfo.output_width;
        }
    }
    else if(D3DFMT_X8R8G8B8 == m_Format)
    {
        UINT8 *pubSrc;
        UINT32 *pulDest, *pulDestLine;
        pulDest = (UINT32 *) m_pvData;

        while(cinfo.output_scanline < cinfo.output_height)
        {
            D3DX::jpeg_read_scanlines(&cinfo, pBuffer, 1);

            pubSrc = (UINT8 *) pBuffer[0];
            pulDestLine = pulDest + cinfo.output_width;

            while(pulDest < pulDestLine)
            {
                *pulDest = ((UINT32) pubSrc[0] << 16) |
                           ((UINT32) pubSrc[1] << 8) |
                           ((UINT32) pubSrc[2]);

                pulDest++;
                pubSrc += 3;
            }
        }
    }


    D3DX::jpeg_finish_decompress(&cinfo);

    hr = S_OK;
    goto LDone;


LDone:
    D3DX::jpeg_destroy_decompress(&cinfo);
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// LoadTGA ///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#pragma pack(1)
struct d3dx_tga_header
{
    BYTE cbId;
    BYTE bColorMap;
    BYTE bImageType;

    WORD wColorMapIndex;
    WORD wColorMapLength;
    BYTE bColorMapBits;

    WORD wXOrigin;
    WORD wYOrigin;
    WORD wWidth;
    WORD wHeight;
    BYTE bBits;
    BYTE bFlags;
};
#pragma pack()


HRESULT CD3DXImage::LoadTGA(LPCVOID pvData, DWORD cbData)
{
    // Validate header.  TGA files don't seem to have any sort of magic number
    // to identify them.  Therefore, we will proceed as if this is a real TGA
    // file, until we see something we don't understand.

    BYTE *pbData = (BYTE *) pvData;
    d3dx_tga_header *pFH = (d3dx_tga_header *) pbData;

    if(cbData < sizeof(d3dx_tga_header))
        return E_FAIL;

    if(pFH->bColorMap & ~0x01)
        return E_FAIL;

    if(pFH->bImageType & ~0x0B)
        return E_FAIL;

    if(!pFH->wWidth || !pFH->wHeight)
        return E_FAIL;



    // Colormap size and format
    UINT uColorMapBytes = ((UINT) pFH->bColorMapBits + 7) >> 3;
    D3DFORMAT ColorMapFormat = D3DFMT_UNKNOWN;

    if(pFH->bColorMap)
    {
        switch(pFH->bColorMapBits)
        {
        case 15: ColorMapFormat = D3DFMT_X1R5G5B5; break;
        case 16: ColorMapFormat = D3DFMT_A1R5G5B5; break;
        case 24: ColorMapFormat = D3DFMT_R8G8B8;   break;
        case 32: ColorMapFormat = D3DFMT_A8R8G8B8; break;
        default: return E_FAIL;
        }
    }


    // Image size and format
    UINT uBytes = ((UINT) pFH->bBits + 7) >> 3;
    D3DFORMAT Format = D3DFMT_UNKNOWN;

    switch(pFH->bImageType & 0x03)
    {
    case 1:
        if(!pFH->bColorMap)
            return E_FAIL;

        switch(pFH->bBits)
        {
        case 8: Format = D3DFMT_P8; break;
        default: return E_FAIL;
        }
        break;

    case 2:
        switch(pFH->bBits)
        {
        case 15: Format = D3DFMT_X1R5G5B5; break;
        case 16: Format = D3DFMT_A1R5G5B5; break;
        case 24: Format = D3DFMT_R8G8B8;   break;
        case 32: Format = D3DFMT_A8R8G8B8; break;
        default: return E_FAIL;
        }
        break;

    case 3:
        switch(pFH->bBits)
        {
        case 8: Format = D3DFMT_L8; break;
        default: return E_FAIL;
        }
        break;

    default:
        return E_FAIL;
    }

    BOOL bRLE         = pFH->bImageType & 0x08;
    BOOL bTopToBottom = 0x20 == (pFH->bFlags & 0x20);
    BOOL bLeftToRight = 0x10 != (pFH->bFlags & 0x10);

    pbData += sizeof(d3dx_tga_header);
    cbData -= sizeof(d3dx_tga_header);


    // Skip ID
    if(cbData < pFH->cbId)
        return E_FAIL;

    pbData += pFH->cbId;
    cbData -= pFH->cbId;


    // Color map
    UINT cbColorMap = (UINT) pFH->wColorMapLength * uColorMapBytes;

    if(cbData < cbColorMap)
        return E_FAIL;

    if(D3DFMT_P8 == Format)
    {
        if(pFH->wColorMapIndex + pFH->wColorMapLength > 256)
            return E_FAIL;

        if(!(m_pPalette = new PALETTEENTRY[256]))
            return E_OUTOFMEMORY;

        m_bDeletePalette = TRUE;
        memset(m_pPalette, 0xff, 256 * sizeof(PALETTEENTRY));

        BYTE *pb = pbData;
        PALETTEENTRY *pColor = m_pPalette + pFH->wColorMapIndex;
        PALETTEENTRY *pColorLim = pColor + pFH->wColorMapLength;

        while(pColor < pColorLim)
        {
            UINT u, uA, uR, uG, uB;

            switch(ColorMapFormat)
            {
            case D3DFMT_X1R5G5B5:
                u = *((WORD *) pb);

                uA = 0xff;
                uR = (u >> 10) & 0x1f;
                uG = (u >>  5) & 0x1f;
                uB = (u >>  0) & 0x1f;

                uR = (uR << 3) | (uR >> 2);
                uG = (uG << 3) | (uG >> 2);
                uB = (uB << 3) | (uB >> 2);

                pb += 2;
                break;

            case D3DFMT_A1R5G5B5:
                u = *((WORD *) pb);

                uA = (u >> 15) * 0xff;
                uR = (u >> 10) & 0x1f;
                uG = (u >>  5) & 0x1f;
                uB = (u >>  0) & 0x1f;

                uR = (uR << 3) | (uR >> 2);
                uG = (uG << 3) | (uG >> 2);
                uB = (uB << 3) | (uB >> 2);

                pb += 2;
                break;

            case D3DFMT_R8G8B8:
                uA = 0xff;
                uR = pb[2];
                uG = pb[1];
                uB = pb[0];

                pb += 3;
                break;

            case D3DFMT_A8R8G8B8:
                u = *((DWORD *) pb);

                uA = (u >> 24) & 0xff;
                uR = (u >> 16) & 0xff;
                uG = (u >>  8) & 0xff;
                uB = (u >>  0) & 0xff;

                pb += 4;
                break;
            }
            
            pColor->peRed   = (BYTE) uR;
            pColor->peGreen = (BYTE) uG;
            pColor->peBlue  = (BYTE) uB;
            pColor->peFlags = (BYTE) uA;

            pColor++;
        }
    }

    pbData += cbColorMap;
    cbData -= cbColorMap;


    // Image data
    UINT cbImage = (UINT) pFH->wWidth * (UINT) pFH->wHeight * uBytes;

    m_Format  = Format;
    m_pvData  = pbData;
    m_cbPitch = (UINT) pFH->wWidth * uBytes;

    m_Rect.left   = 0;
    m_Rect.top    = 0;
    m_Rect.right  = pFH->wWidth;
    m_Rect.bottom = pFH->wHeight;


    if(!bRLE && bTopToBottom && bLeftToRight)
    {
        // Data is already in a format usable to D3D.. no conversion is necessary
        if(cbData < cbImage)
            return E_FAIL;

        m_pvData = pbData;
        m_bDeleteData = FALSE;

        pbData += cbImage;
        cbData -= cbImage;
    }
    else
    {
        // Image data is compressed, or does not have origin at top-left
        if(!(m_pvData = new BYTE[cbImage]))
            return E_OUTOFMEMORY;

        m_bDeleteData = TRUE;


        BYTE *pbDestY = bTopToBottom ? (BYTE *) m_pvData : ((BYTE *) m_pvData + (pFH->wHeight - 1) * m_cbPitch);

        for(UINT uY = 0; uY < pFH->wHeight; uY++)
        {
            BYTE *pbDestX = bLeftToRight ? pbDestY : (pbDestY + m_cbPitch - uBytes);

            for(UINT uX = 0; uX < pFH->wWidth; )
            {
                BOOL bRunLength;
                UINT uCount;

                if(bRLE)
                {
                    if(cbData < 1)
                        return E_FAIL;

                    bRunLength = *pbData & 0x80;
                    uCount = (*pbData & 0x7f) + 1;

                    pbData++;
                    cbData--;
                }
                else
                {
                    bRunLength = FALSE;
                    uCount = pFH->wWidth;
                }

                uX += uCount;

                while(uCount--)
                {
                    if(cbData < uBytes)
                        return E_FAIL;

                    memcpy(pbDestX, pbData, uBytes);

                    if(!bRunLength)
                    {
                        pbData += uBytes;
                        cbData -= uBytes;
                    }

                    pbDestX = bLeftToRight ? (pbDestX + uBytes) : (pbDestX - uBytes);
                }

                if(bRunLength)
                {
                    pbData += uBytes;
                    cbData -= uBytes;
                }
            }

            pbDestY = bTopToBottom ? (pbDestY + m_cbPitch) : (pbDestY - m_cbPitch);
        }
    }

    return S_OK;
}





//////////////////////////////////////////////////////////////////////////////
// LoadPPM ///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

enum
{
    PPM_WIDTH, PPM_HEIGHT, PPM_MAX, PPM_DATA_R, PPM_DATA_G, PPM_DATA_B
};

HRESULT CD3DXImage::LoadPPM(LPCVOID pvData, DWORD cbData)
{

    BYTE *pbData = (BYTE *) pvData;

    // Check header
    BOOL bAscii;

    if(cbData < 2)
        return E_FAIL;

    if('P' == pbData[0] && '3' == pbData[1])
        bAscii = TRUE;
    else if('P' == pbData[0] && '6' == pbData[1])
        bAscii = FALSE;
    else
        return E_FAIL;

    pbData += 2;
    cbData -= 2;


    // Image data
    UINT uMode   = PPM_WIDTH;
    UINT uWidth  = 0;
    UINT uHeight = 0;
    UINT uMax    = 255;

    DWORD *pdw, *pdwLim;


    while(cbData)
    {
        if(!bAscii && PPM_DATA_R == uMode)
        {
            // Binary image data
            if(uMax > 255)
                return E_FAIL;

            if(cbData > 1 && '\r' == *pbData)
            {
                pbData++;
                cbData--;
            }

            pbData++;
            cbData--;

            while(cbData && pdw < pdwLim)
            {
                *pdw++ = ((255 * pbData[0] / uMax) << 16) |
                         ((255 * pbData[1] / uMax) <<  8) |
                         ((255 * pbData[2] / uMax) <<  0) | 0xff000000;

                pbData += 3;
                cbData -= 3;
            }

            if(pdw != pdwLim)
                return E_FAIL;

            return S_OK;
        }
        if(isspace(*pbData))
        {
            // Whitespace
            pbData++;
            cbData--;
        }
        else if('#' == *pbData)
        {
            // Comment
            while(cbData && '\n' != *pbData)
            {
                pbData++;
                cbData--;
            }

            pbData++;
            cbData--;
        }
        else
        {
            // Number
            UINT u = 0;

            while(cbData && !isspace(*pbData))
            {
                if(!isdigit(*pbData))
                    return E_FAIL;

                u = u * 10 + (*pbData - '0');

                pbData++;
                cbData--;
            }

            switch(uMode)
            {
            case PPM_WIDTH:
                uWidth = u;

                if(0 == uWidth)
                    return E_FAIL;

                break;

            case PPM_HEIGHT:
                uHeight = u;

                if(0 == uHeight)
                    return E_FAIL;

                if(!(m_pvData = new BYTE[uWidth * uHeight * sizeof(DWORD)]))
                    return E_OUTOFMEMORY;

                m_bDeleteData = TRUE;

                pdw = (DWORD *) m_pvData;
                pdwLim = pdw + uWidth * uHeight;

                m_Format  = D3DFMT_X8R8G8B8;
                m_cbPitch = uWidth * sizeof(DWORD);

                m_Rect.left   = 0;
                m_Rect.top    = 0;
                m_Rect.right  = uWidth;
                m_Rect.bottom = uHeight;
                break;

            case PPM_MAX:
                uMax = u;

                if(0 == uMax)
                    return E_FAIL;

                break;

            case PPM_DATA_R:
                if(pdw >= pdwLim)
                    return E_FAIL;

                *pdw  = ((u * 255 / uMax) << 16) | 0xff000000;
                break;

            case PPM_DATA_G:
                *pdw |= ((u * 255 / uMax) <<  8);
                break;

            case PPM_DATA_B:
                *pdw |= ((u * 255 / uMax) <<  0);

                if(++pdw == pdwLim)
                    return S_OK;

                uMode = PPM_DATA_R - 1;
                break;
            }

            uMode++;
        }
    }

    return E_FAIL;
}




//////////////////////////////////////////////////////////////////////////////
// LoadPNG ///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

struct d3dx_png_io
{
    LPCVOID pv;
    SIZE_T  cb;
};

static void __cdecl
d3dx_png_read_fn(D3DX::png_structp png_ptr, D3DX::png_bytep data, png_size_t length)
{
    d3dx_png_io *pio = (d3dx_png_io *) png_ptr->io_ptr;

    if(length > pio->cb)
        D3DX::png_error(png_ptr, "read error");

    memcpy(data, pio->pv, length);

    pio->pv = (BYTE *) pio->pv + length;
    pio->cb -= length;
}

static void __cdecl
d3dx_png_error_fn(D3DX::png_structp png_ptr, D3DX::png_const_charp error_msg)
{
    DPF(0, "LoadPNG: %s", error_msg);
    longjmp(png_ptr->jmpbuf, TRUE);
}

static void __cdecl
d3dx_png_warning_fn(D3DX::png_structp png_ptr, D3DX::png_const_charp warning_msg)
{
    DPF(0, "LoadPNG: %s", warning_msg);
}


HRESULT CD3DXImage::LoadPNG(LPCVOID pvData, DWORD cbData)
{
    HRESULT hr;

    unsigned long width, height, row;
    int bit_depth, color_type, intent;
    double image_gamma;
    D3DX::png_color_16p image_background;
    d3dx_png_io io;

    D3DX::png_structp png_ptr = NULL;
    D3DX::png_infop info_ptr  = NULL;
    BYTE** row_pointers = NULL;


    // Check header
    if(D3DX::png_sig_cmp((BYTE *) pvData, 0, cbData))
        return E_FAIL;

    // Create read and info structs
    if(!(png_ptr = D3DX::png_create_read_struct(PNG_LIBPNG_VER_STRING,
      NULL, d3dx_png_error_fn, d3dx_png_warning_fn)))
    {
        goto LOutOfMemory;
    }

    if(!(info_ptr = D3DX::png_create_info_struct(png_ptr)))
        goto LOutOfMemory;

    if(setjmp(png_ptr->jmpbuf))
        goto LFail;


    // Setup read func
    io.pv = pvData;
    io.cb = cbData;

    D3DX::png_set_read_fn(png_ptr, (void *) &io, d3dx_png_read_fn);


    // Read header
    D3DX::png_read_info(png_ptr, info_ptr);
    D3DX::png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, NULL, NULL, NULL);

    switch(color_type)
    {
    case PNG_COLOR_TYPE_GRAY:       m_Format = D3DFMT_L8;       break;
    case PNG_COLOR_TYPE_GRAY_ALPHA: m_Format = D3DFMT_A8L8;     break;
    case PNG_COLOR_TYPE_PALETTE:    m_Format = D3DFMT_P8;       break;
    case PNG_COLOR_TYPE_RGB:        m_Format = D3DFMT_R8G8B8;   break;
    case PNG_COLOR_TYPE_RGB_ALPHA:  m_Format = D3DFMT_A8R8G8B8; break;
    }

    // Force byte-sized components
    if (bit_depth == 16)
        D3DX::png_set_strip_16(png_ptr);

    if (bit_depth < 8)
        D3DX::png_set_packing(png_ptr);

    if(color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
        D3DX::png_set_gray_1_2_4_to_8(png_ptr);


    // Setup gamma
    if(D3DX::png_get_sRGB(png_ptr, info_ptr, &intent))
        D3DX::png_set_sRGB(png_ptr, info_ptr, intent);
    else if(D3DX::png_get_gAMA(png_ptr, info_ptr, &image_gamma))
        D3DX::png_set_gamma(png_ptr, 2.2, image_gamma);


    // Convert colorkey to alpha
    if(D3DFMT_P8 != m_Format &&
       D3DX::png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
    {
        D3DX::png_set_tRNS_to_alpha(png_ptr);

        switch(m_Format)
        {
        case D3DFMT_L8:     m_Format = D3DFMT_A8L8;     break;
        case D3DFMT_R8G8B8: m_Format = D3DFMT_A8R8G8B8; break;
        }
    }

    // Use BGR or BGRA
    if(
       D3DFMT_R8G8B8 == m_Format || 
       D3DFMT_A8R8G8B8 == m_Format)
        D3DX::png_set_bgr(png_ptr);

    // Expand RGB to XRGB
    if(D3DFMT_R8G8B8 == m_Format)
    {
        D3DX::png_set_filler(png_ptr, 0xff, PNG_FILLER_AFTER);
        m_Format = D3DFMT_X8R8G8B8;
    }


    // Update info
    D3DX::png_read_update_info(png_ptr, info_ptr);

    int nComp;
    switch(m_Format)
    {
    case D3DFMT_L8:       nComp = 1; break;
    case D3DFMT_A8L8:     nComp = 2; break;
    case D3DFMT_P8:       nComp = 1; break;
    case D3DFMT_R8G8B8:   nComp = 3; break;
    case D3DFMT_X8R8G8B8: nComp = 4; break;
    case D3DFMT_A8R8G8B8: nComp = 4; break;
    }

    if(nComp != D3DX::png_get_channels(png_ptr, info_ptr))
        goto LFail;

    m_Rect.left   = 0;
    m_Rect.top    = 0;
    m_Rect.right  = width;
    m_Rect.bottom = height;

    m_cbPitch = D3DX::png_get_rowbytes(png_ptr, info_ptr);


    // Read image
    if(!(m_pvData = new BYTE[height * m_cbPitch]))
        goto LOutOfMemory;

    m_bDeleteData = TRUE;

    if(!(row_pointers = new BYTE*[height]))
        goto LOutOfMemory;

    for(row = 0; row < height; row++)
        row_pointers[row] = (BYTE *) m_pvData + row * m_cbPitch;

    D3DX::png_read_image(png_ptr, row_pointers);



    // Read palette (palette should have been gamma-corrected during read)
    if(D3DFMT_P8 == m_Format)
    {
        D3DX::png_bytep trans;
        D3DX::png_colorp palette;
        int num_trans   = 0;
        int num_palette = 0;

        if(D3DX::png_get_valid(png_ptr, info_ptr, PNG_INFO_PLTE))
            D3DX::png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette);

        if(D3DX::png_get_valid(png_ptr, info_ptr, PNG_INFO_tRNS))
            D3DX::png_get_tRNS(png_ptr, info_ptr, &trans, &num_trans, NULL);


        // build gamma table
        BYTE gamma[256];

        if((png_ptr->gamma > .000001) && (png_ptr->screen_gamma > .000001))
        {
            double g = 1.0 / (png_ptr->gamma * png_ptr->screen_gamma);

            for(int i = 0; i < 256; i++)
                gamma[i] = (BYTE)(pow((double)i / 255.0, g) * 255.0 + .5);
        }
        else
        {
            for(int i = 0; i < 256; i++)
                gamma[i] = static_cast<BYTE>(i);
        }



        // Allocate palettte
        if(!(m_pPalette = new PALETTEENTRY[256]))
            goto LOutOfMemory;

        m_bDeletePalette = TRUE;


        // Fill palette
        int i = 0;

        for(; i < num_trans; i++)
        {
            m_pPalette[i].peRed   = gamma[palette[i].red];
            m_pPalette[i].peGreen = gamma[palette[i].green];
            m_pPalette[i].peBlue  = gamma[palette[i].blue];
            m_pPalette[i].peFlags = trans[i];
        }

        for(; i < num_palette; i++)
        {
            m_pPalette[i].peRed   = gamma[palette[i].red];
            m_pPalette[i].peGreen = gamma[palette[i].green];
            m_pPalette[i].peBlue  = gamma[palette[i].blue];
            m_pPalette[i].peFlags = 0xff;
        }

        for(; i < 256; i++)
        {
            m_pPalette[i].peRed   = 0xff;
            m_pPalette[i].peGreen = 0xff;
            m_pPalette[i].peBlue  = 0xff;
            m_pPalette[i].peFlags = 0xff;
        }
    }


    hr = S_OK;
    goto LDone;

LFail:
    hr = E_FAIL;
    goto LDone;

LOutOfMemory:
    hr = E_OUTOFMEMORY;
    goto LDone;

LDone:
    if (png_ptr != NULL)
        D3DX::png_destroy_read_struct(&png_ptr, &info_ptr, NULL);

    if(row_pointers)
        delete [] row_pointers;

    return hr;
}





//////////////////////////////////////////////////////////////////////////////
// LoadDDS ///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#define DDS_RGB              0x00000040
#define DDS_RGBA             0x00000041
#define DDS_CUBEMAP_ALLFACES 0x0000fc00


struct DDS_PIXELFORMAT
{
	DWORD dwSize;
	DWORD dwFlags;
	DWORD dwFourCC;
	DWORD dwRGBBitCount;
	DWORD dwRBitMask;
	DWORD dwGBitMask;
	DWORD dwBBitMask;
	DWORD dwABitMask;
};


struct DDS_HEADER
{
	DWORD dwSize;
	DWORD dwReserved1;
	DWORD dwHeight;
	DWORD dwWidth;
	DWORD dwLinearSize;
	DWORD dwReserved2;
	DWORD dwMipMapCount;
	DWORD dwReserved3[11];
	DDS_PIXELFORMAT ddspf;
	DWORD dwFlags;
	DWORD dwCubemapFlags;
	DWORD dwReserved4[3];
};


HRESULT CD3DXImage::LoadDDS(LPCVOID pvData, DWORD cbData)
{
    BYTE *pbData = (BYTE *) pvData;


    // Check magic number
    if(cbData < sizeof(DWORD))
        return E_FAIL;

    if(*((DWORD *) pbData) != MAKEFOURCC('D', 'D', 'S', ' '))
        return E_FAIL;

    pbData += sizeof(DWORD);
    cbData -= sizeof(DWORD);


    // Read header
    DDS_HEADER *pHeader;

    if(cbData < sizeof(DDS_HEADER))
        return E_FAIL;

    pHeader = (DDS_HEADER *) pbData;

    pbData += sizeof(DDS_HEADER);
    cbData -= sizeof(DDS_HEADER);


    // Grok dimensions
    m_Rect.left   = 0;
    m_Rect.top    = 0;
    m_Rect.right  = (LONG) pHeader->dwWidth;
    m_Rect.bottom = (LONG) pHeader->dwHeight;


    // Grok faces
    DWORD dwCubemapFlags;
    dwCubemapFlags = (pHeader->dwCubemapFlags & DDS_CUBEMAP_ALLFACES);

    UINT cSides;
    if(DDS_CUBEMAP_ALLFACES == dwCubemapFlags)
        cSides = 6;
    else if(0 == dwCubemapFlags)
        cSides = 1;
    else
    {
        DPF(0, "LoadDDS: Partial cubemaps not supported.");
        return E_FAIL;
    }


    // Grok levels
    UINT cMipLevels;
    cMipLevels = (UINT) pHeader->dwMipMapCount;

    if(0 == cMipLevels)
        cMipLevels = 1;


    // Grok pixel format
    D3DFORMAT Format;

  	if(pHeader->ddspf.dwFourCC == MAKEFOURCC('D', 'X', 'T', '1') ||
            pHeader->ddspf.dwFourCC == D3DFMT_DXT1) {
		Format = D3DFMT_DXT1;
	} else if(pHeader->ddspf.dwFourCC == MAKEFOURCC('D', 'X', 'T', '2') ||
            pHeader->ddspf.dwFourCC == D3DFMT_DXT2) {
		Format = D3DFMT_DXT2;
	} else if(pHeader->ddspf.dwFourCC == MAKEFOURCC('D', 'X', 'T', '3') ||
            pHeader->ddspf.dwFourCC == D3DFMT_DXT3) {
		Format = D3DFMT_DXT3;
	} else if(pHeader->ddspf.dwFourCC == MAKEFOURCC('D', 'X', 'T', '4') ||
            pHeader->ddspf.dwFourCC == D3DFMT_DXT4) {
		Format = D3DFMT_DXT4;
	} else if(pHeader->ddspf.dwFourCC == MAKEFOURCC('D', 'X', 'T', '5') ||
            pHeader->ddspf.dwFourCC == D3DFMT_DXT5) {
		Format = D3DFMT_DXT5;
	} else if(pHeader->ddspf.dwFlags == DDS_RGBA && pHeader->ddspf.dwRGBBitCount == 32 && pHeader->ddspf.dwABitMask == 0xff000000) {
		Format = D3DFMT_A8R8G8B8;
	} else if(pHeader->ddspf.dwFlags == DDS_RGB  && pHeader->ddspf.dwRGBBitCount == 32) {
		Format = D3DFMT_X8R8G8B8;
	} else if(pHeader->ddspf.dwFlags == DDS_RGB  && pHeader->ddspf.dwRGBBitCount == 16 && pHeader->ddspf.dwGBitMask == 0x000007e0) {
		Format = D3DFMT_R5G6B5;
	} else if(pHeader->ddspf.dwFlags == DDS_RGB  && pHeader->ddspf.dwRGBBitCount == 16 && pHeader->ddspf.dwGBitMask == 0x000003e0) {
		Format = D3DFMT_X1R5G5B5;
	} else if(pHeader->ddspf.dwFlags == DDS_RGBA && pHeader->ddspf.dwRGBBitCount == 16 && pHeader->ddspf.dwABitMask == 0x00008000) {
		Format = D3DFMT_A1R5G5B5;
	} else if(pHeader->ddspf.dwFlags == DDS_RGBA && pHeader->ddspf.dwRGBBitCount == 16 && pHeader->ddspf.dwABitMask == 0x0000f000) {
		Format = D3DFMT_A4R4G4B4;
	} else
    {
        DPF(0, "LoadDDS: Unsupported pixel format");
		return E_FAIL;
    }


    // Load images
    for(UINT uSide = 0; uSide < cSides; uSide++)
    {
        RECT Rect;
        Rect = m_Rect;


        // Allocate face
        CD3DXImage *pImage;
        CD3DXImage *pImageSide;

        if(0 == uSide)
        {
            pImageSide = this;
        }
        else
        {
            if(!(pImage = new CD3DXImage))
                return E_OUTOFMEMORY;

            pImageSide->m_pFace = pImage;
            pImageSide = pImage;
        }


        for(UINT uMipLevel = 0; uMipLevel < cMipLevels; uMipLevel++)
        {
            // Allocate mip level
            CD3DXImage *pImageMip;

            if(0 == uMipLevel)
            {
                pImageMip = pImageSide;
            }
            else
            {
                if(!(pImage = new CD3DXImage))
                    return E_OUTOFMEMORY;

                pImageMip->m_pMip = pImage;
                pImageMip = pImage;
            }

            // Compute pitch and area
            UINT cbPitch;
            UINT cbArea;

            switch(Format)
            {
		    case D3DFMT_DXT1:
                cbPitch = ((Rect.right + 3) >> 2) * 8;
                cbArea = cbPitch * ((Rect.bottom + 3) >> 2);
                break;

		    case D3DFMT_DXT2:
		    case D3DFMT_DXT4:
#if 0
		    case D3DFMT_DXT3:
		    case D3DFMT_DXT5:
#endif
                cbPitch = ((Rect.right + 3) >> 2) * 16;
                cbArea = cbPitch * ((Rect.bottom + 3) >> 2);
                break;

		    case D3DFMT_A8R8G8B8:
		    case D3DFMT_X8R8G8B8:
                cbPitch = Rect.right * sizeof(DWORD);
                cbArea = cbPitch * Rect.bottom;
                break;

		    case D3DFMT_R5G6B5:
		    case D3DFMT_X1R5G5B5:
		    case D3DFMT_A1R5G5B5:
		    case D3DFMT_A4R4G4B4:
                cbPitch = Rect.right * sizeof(WORD);
                cbArea = cbPitch * Rect.bottom;
                break;
            }


            // Set data
            pImageMip->m_Format         = Format;
            pImageMip->m_pvData         = pbData;
            pImageMip->m_cbPitch        = cbPitch;
            pImageMip->m_Rect           = Rect;
            pImageMip->m_pPalette       = NULL;
            pImageMip->m_bDeleteData    = FALSE;
            pImageMip->m_bDeletePalette = FALSE;

            if(cbData < cbArea)
                return E_FAIL;

            pbData += cbArea;
            cbData -= cbArea;

            Rect.right   = (Rect.right  == 1) ? 1 : (Rect.right  >> 1);
            Rect.bottom  = (Rect.bottom == 1) ? 1 : (Rect.bottom >> 1);
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\tex\CD3DXImage.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       CD3DXImage.h
//  Content:    Image file class
//
///////////////////////////////////////////////////////////////////////////

#ifndef __CD3DXImage_H__
#define __CD3DXImage_H__


///////////////////////////////////////////////////////////////////////////
// CD3DXImage /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

class CD3DXImage
{
public:
    D3DFORMAT       m_Format;
    LPVOID          m_pvData;
    DWORD           m_cbPitch;
    RECT            m_Rect;
    PALETTEENTRY*   m_pPalette;

    BOOL            m_bDeleteData;
    BOOL            m_bDeletePalette;

    CD3DXImage*     m_pMip;
    CD3DXImage*     m_pFace;


public:
    CD3DXImage();
    ~CD3DXImage();

    HRESULT Load(LPCVOID pvData, DWORD cbData, D3DXIMAGE_INFO *pInfo);

private:
    HRESULT LoadBMP(LPCVOID pvData, DWORD cbData);
    HRESULT LoadDIB(LPCVOID pvData, DWORD cbData);
    HRESULT LoadJPG(LPCVOID pvData, DWORD cbData);
    HRESULT LoadTGA(LPCVOID pvData, DWORD cbData);
    HRESULT LoadPPM(LPCVOID pvData, DWORD cbData);
    HRESULT LoadDDS(LPCVOID pvData, DWORD cbData);
    HRESULT LoadPNG(LPCVOID pvData, DWORD cbData);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\tex\s3tc.cpp ===
/*
 *   Copyright (c) 1997-8  S3 Inc.  All Rights Reserved.
 *
 *   Module Name:  s3tc.c
 *
 *   Purpose:  S3 linear interpolation encoding and decoding
 *             mechanism for texture map compression.
 *
 *   Author:  Konstantine Iourcha, Dan McCabe
 *
 *   Revision History:
 *       lthompso 98Jan05 Code beautification.
 */

//***************************************************************************
// Includes
//***************************************************************************

#include "pchtex.h"

//***************************************************************************
// Definitions
//***************************************************************************

// Primary color components (use DirextX byte ordering)
#undef BLU
#define BLU   0
#undef GRN
#define GRN   1
#undef RED
#define RED   2
#undef ALFA
#define ALFA 3

typedef	struct	{
	float		rgba[4];
} FCOLOR;	// internal color format

//
// Processing all primaries is such a common idiom
// that we define a macro for this action.
// Any self-respecting C compiler should easily optimize
// this by unrolling the loop!
//
#define	ForAllPrimaries		for( primary = 0; primary < NUM_PRIMARIES; ++primary)

// Similarly, processing all pixels in a block is a common idiom.
#define	ForAllPixels		for(pixel=0; pixel < S3TC_BLOCK_PIXELS; ++pixel)

#define NUM_PRIMARIES	3
#define	NUM_COMPONENTS	4
//
// Quantization constants for RGB565
//
#define	PRIMARY_BITS	8

#define	RED_BITS	5
#define	GRN_BITS	6
#define	BLU_BITS	5

#define	RED_SHIFT	(PRIMARY_BITS-RED_BITS)
#define	GRN_SHIFT	(PRIMARY_BITS-GRN_BITS)
#define	BLU_SHIFT	(PRIMARY_BITS-BLU_BITS)

#if 0
#define	RED_MASK	0xf8
#define	GRN_MASK	0xfc
#define	BLU_MASK	0xf8
#endif

// Weighting for each primary based on NTSC luminance
static	float	wtPrimary[NUM_PRIMARIES] = {
	0.0820f,	// blue
	0.6094f,	// green
	0.3086f		// red
};


//***************************************************************************
// Data
//***************************************************************************
// Look up table to map linear RGB indices to hardware indices.
// (Hardware expects extrema in indices 0 and 1 and interpolants in 2 and 3.)
static	int	mapRGB4[4] = {
	0,	// 0 => 0
	2,	// 1 => 2
	3,	// 2 => 3
	1	// 3 => 1
};

static	int	mapRGB3[4] = {
	0,	// 0 => 0
	2,	// 1 => 2
	1,	// 2 => 1
	3	// 3 => 3
};

//***************************************************************************
// Code
//***************************************************************************
// convert a fixed point color to a floating point color
static	void	ColorToFcolor(S3TC_COLOR *pcolor, FCOLOR *pfcolor)
{
	int	primary;

	ForAllPrimaries
		pfcolor->rgba[primary] = ((float) pcolor->rgba[primary]) * wtPrimary[primary] / 255.0f;
}

// convert a floating point color to a fixed point color
static	void	FcolorToColor(FCOLOR *pfcolor, S3TC_COLOR *pcolor)
{
	int	primary;

	ForAllPrimaries
		pcolor->rgba[primary] = (int) (pfcolor->rgba[primary] * 255.0f / wtPrimary[primary]);
}

// pack a fixed point color
static	void	ColorToRGB (S3TC_COLOR *pcolor, RGB565 *prgb)
{
	WORD	rgb;
	WORD	pri;

	pri  = pcolor->rgba[RED];
	pri >>= RED_SHIFT;
	rgb  = (BYTE) pri;

	pri  = pcolor->rgba[GRN];
	pri >>= GRN_SHIFT;
	rgb <<= GRN_BITS;
	rgb |= (BYTE) pri;

	pri  = pcolor->rgba[BLU];
	pri >>= BLU_SHIFT;
	rgb <<= BLU_BITS;
	rgb |= (BYTE) pri;

	*prgb = *((RGB565 *) &rgb);
}

// unpack a fixed point color
static	void	RGBToColor (RGB565 *prgb, S3TC_COLOR *pcolor)
{
	WORD	rgb;
	S3TC_COLOR	color;

	rgb = *((WORD *)prgb);

	// pick off bits in groups of 5, 6, and 5
	color.rgba[BLU] = (unsigned char) rgb;
	rgb >>= BLU_BITS;
	color.rgba[GRN] = (unsigned char) rgb;
	rgb >>= GRN_BITS;
	color.rgba[RED] = (unsigned char) rgb;

	// shift primaries into the appropriate LSBs
	color.rgba[BLU] <<= BLU_SHIFT;
	color.rgba[GRN] <<= GRN_SHIFT;
	color.rgba[RED] <<= RED_SHIFT;

	// replicate primaries MSBs into LSBs
	color.rgba[BLU] |= color.rgba[BLU] >> BLU_BITS;
	color.rgba[GRN] |= color.rgba[GRN] >> GRN_BITS;
	color.rgba[RED] |= color.rgba[RED] >> RED_BITS;

	*pcolor = color;
}

// Square a symmetric 3x3 matrix and store the result in another 3x3 matrix.
static	void Square3x3(
	float m[NUM_PRIMARIES][NUM_PRIMARIES],
	float m2[NUM_PRIMARIES][NUM_PRIMARIES])
{
    // It will be symmetric, so we'll only do the upper diagonal.
    // Note:  Using symmetry on the entries to be multiplied, also.

    m2[0][0] = m[0][0] * m[0][0] + m[0][1] * m[0][1] + m[0][2] * m[0][2];
    m2[0][1] = m[0][0] * m[0][1] + m[0][1] * m[1][1] + m[0][2] * m[1][2];
    m2[0][2] = m[0][0] * m[0][2] + m[0][1] * m[1][2] + m[0][2] * m[2][2];
    m2[1][1] = m[0][1] * m[0][1] + m[1][1] * m[1][1] + m[1][2] * m[1][2];
    m2[1][2] = m[0][1] * m[0][2] + m[1][1] * m[1][2] + m[1][2] * m[2][2];
    m2[2][2] = m[0][2] * m[0][2] + m[1][2] * m[1][2] + m[2][2] * m[2][2];
}

// Convert floating point extrema colors into fixed point, quantized, RGB565
// colors and store in block structure.
static	void	Quantize(FCOLOR *pfcolor0, FCOLOR *pfcolor1, S3TCBlockRGB *pblock, int cOpaque)
{
	S3TC_COLOR	color;	// intermediate color

	// Convert clipped floating point extrema to fixed point block colors.
	FcolorToColor(pfcolor0, &color);
	ColorToRGB(&color, &pblock->rgb0);

	FcolorToColor(pfcolor1, &color);
	ColorToRGB(&color, &pblock->rgb1);

	// order extrema so that rgb0 > rgb1 to encode non-transparent block
	if ((cOpaque == 16) ^ (pblock->rgb0 > pblock->rgb1)) {
		RGB565	rgbSwap;

		rgbSwap = pblock->rgb0;
		pblock->rgb0 = pblock->rgb1;
		pblock->rgb1 = rgbSwap;
	}

	// and capture quantized extrema
	RGBToColor(&pblock->rgb0, &color);
	ColorToFcolor(&color, pfcolor0);
	
	RGBToColor(&pblock->rgb1, &color);
	ColorToFcolor(&color, pfcolor1);
}

// Find if extrema straddle any limits and if so, adjust accordingly.
static	void ClipExtrema(FCOLOR *plower, FCOLOR *pupper)
{
	float	w;		// weight at intersection of line and limit
	FCOLOR	*pfcolorOut;	// pointer to which extrema was outside limit
	int	primary;

	// For each primary color component, check upper and lower limits.
	ForAllPrimaries {
		// Do extrema straddle the lower limit?
		if ((plower->rgba[primary] < 0.0f)
		^   (pupper->rgba[primary] < 0.0f)) {
			// Compute intersection with upper limit.
			w = -plower->rgba[primary] / (pupper->rgba[primary] - plower->rgba[primary]);

			// Was the lower extreme outside?
			if (plower->rgba[primary] < 0.0f) {
				// Recompute lower extreme to lie on upper limit.
				pfcolorOut = plower;
			}
			else { // The upper extreme must have been outside.
				// Restate linear interpolation as starting from upper.
				w -= 1.0f;

				// Recompute upper extreme to lie on upper limit.
				pfcolorOut = pupper;
			}

			// Readjust the extrema which was outside the upper limit.
			pfcolorOut->rgba[RED] += w * (pupper->rgba[RED] - plower->rgba[RED]);
			pfcolorOut->rgba[GRN] += w * (pupper->rgba[GRN] - plower->rgba[GRN]);
			pfcolorOut->rgba[BLU] += w * (pupper->rgba[BLU] - plower->rgba[BLU]);
		}

		// Do extrema straddle the upper limit?
		if ((plower->rgba[primary] > wtPrimary[primary])
		^   (pupper->rgba[primary] > wtPrimary[primary])) {
			// Compute intersection with lower limit.
			w = (wtPrimary[primary] - plower->rgba[primary])
			  / (pupper->rgba[primary] - plower->rgba[primary]);

			// Was the lower limit outside?
			if (plower->rgba[primary] > wtPrimary[primary]) {
				// Recompute lower extreme to lie on lower limit.
				pfcolorOut = plower;
			}
			else { // The upper extreme must have been outside.
				// Restate linear interpolation as starting from upper.
				w -= 1.0f;

				// Recompute upper extreme to lie on lower limit.
				pfcolorOut = pupper;
			}

			// Readjust the extrema which was outside the upper limit.
			pfcolorOut->rgba[RED] += w * (pupper->rgba[RED] - plower->rgba[RED]);
			pfcolorOut->rgba[GRN] += w * (pupper->rgba[GRN] - plower->rgba[GRN]);
			pfcolorOut->rgba[BLU] += w * (pupper->rgba[BLU] - plower->rgba[BLU]);
		}
	}
}

// fill in a constant color block
static	void	AllSame (S3TC_COLOR *pcolor, S3TCBlockRGB *pblock, WORD wAlpha)
{
	int i;
	WORD wMask;
	DWORD dwMask;
        S3TC_COLOR color = *pcolor;

	// place color into extrema colors
	ColorToRGB(pcolor, &pblock->rgb0);
	pblock->rgb1 = pblock->rgb0;

	// use all indices of 0
	pblock->pixbm = 0;

	if (wAlpha == 0xffff)
	{
    	    return;   // all 16 pixels are opaque
	}

	// not all pixels are opaque, but all opaque pixels are same color
	for (i = 0, wMask = 1, dwMask = 3; i < 16; ++i, wMask <<= 1, dwMask <<= 2)
	{
    	    if (!(wAlpha & wMask))
	    {
		// transparent pixel -- set pixel index to 3
		pblock->pixbm |= dwMask;
	    }
	    else
	    {
    		color = pcolor[i];   // opaque pixel
	    }
	}
	ColorToRGB(&color, &pblock->rgb0);
	pblock->rgb1 = pblock->rgb0;
}

//***************************************************************************
// EncodeBlockRGB - compress a color block
//***************************************************************************
void EncodeBlockRGB (S3TC_COLOR colorSrc[S3TC_BLOCK_PIXELS], S3TCBlockRGB *pblockDst) {
	S3TC_COLOR	colorLo;
	S3TC_COLOR	colorHi;

	// force no valid transparent pixels
	colorLo.rgba[RED] =
	colorLo.rgba[GRN] =
	colorLo.rgba[BLU] = 255;

	colorHi.rgba[RED] =
	colorHi.rgba[GRN] =
	colorHi.rgba[BLU] = 0;

	EncodeBlockRGBColorKey(colorSrc, pblockDst, colorLo, colorHi);
}
//***************************************************************************
// EncodeBlockRGBColorKey - compress a color block with color key transparency
//***************************************************************************
void EncodeBlockRGBColorKey (
	S3TC_COLOR colorSrc[S3TC_BLOCK_PIXELS],
	S3TCBlockRGB *pblockDst,
	S3TC_COLOR colorLo,
	S3TC_COLOR colorHi
) {
	float	eigenvalue;	// approximated eigenvalue
	int	j, k;		// random Fortranesque loop indices
	int	primary;	// primary iteration index
	int	pixel;		// pixel iteration index
	int	pow;		// power iteration index
	int	lev=3;
	int	allsame;	// All the entries are equal.
	float	w;		// weight of color along axis
	float	wMin, wMax;     // extreme values
	float	axis2;          // axis squared
	WORD	wAlpha = 0;	// alpha at 1 BPP
	WORD	wMask;		// pick off bits of alpha mask
	int	cOpaque;
	FCOLOR	axis;           // dominant color axis
	FCOLOR	mean;		// average color
	FCOLOR  fcolor0;	// lower extreme color
	FCOLOR  fcolor1;	// upper extreme color
	FCOLOR	c[S3TC_BLOCK_PIXELS];// normalized and weighted colors
	float	t[NUM_PRIMARIES][NUM_PRIMARIES]; // moment of inertia tensor

	// if destination pointer is invalid, ...
	if (pblockDst == NULL)
		return;

	// count opaque pixels and mark them in bm
	cOpaque = 0;
	for (pixel = S3TC_BLOCK_PIXELS - 1; pixel >= 0; --pixel) {
		wAlpha <<= 1;

		// set bit if pixel is opaque
		if (colorLo.rgba[RED] <= colorSrc[pixel].rgba[RED]
		&&  colorSrc[pixel].rgba[RED] <= colorHi.rgba[RED]
		&&  colorLo.rgba[GRN] <= colorSrc[pixel].rgba[GRN]
		&&  colorSrc[pixel].rgba[GRN] <= colorHi.rgba[GRN]
		&&  colorLo.rgba[BLU] <= colorSrc[pixel].rgba[BLU]
		&&  colorSrc[pixel].rgba[BLU] <= colorHi.rgba[BLU]) {
			// pixel is transparent
			wAlpha &= ~1;
		}
		else { // pixel is opaque
			wAlpha |= 1;
			++cOpaque;
		}
	}

	// if there were no opaque pixels, ...
	if (cOpaque == 0) {
		// mark as having transparency
		pblockDst->rgb0 = 0;
		pblockDst->rgb1 = 0xffff;
		pblockDst->pixbm = 0xffffffff;

		return;
	}

	// detect a constant color block
	allsame = 1;
	ForAllPixels {
		// If we're all the same, nothing for us to do, so let's check to
		// see if we need to do all the work or can make a quick exit.
		if ((allsame) && (pixel > 0))
			if (colorSrc[pixel].rgba[RED] != colorSrc[pixel - 1].rgba[RED]
			||  colorSrc[pixel].rgba[GRN] != colorSrc[pixel - 1].rgba[GRN]
			||  colorSrc[pixel].rgba[BLU] != colorSrc[pixel - 1].rgba[BLU]) {
				allsame = 0;  // Found a different color, not all the same.
		}
	}

	// If the entries were all the same, there is only 1 color, so there's
	// no work for us to do.  Just unweight the colors and we're done.
	if (allsame) {
		AllSame(&colorSrc[0], pblockDst, wAlpha);

		return;  // We're done.
	}

	// Normalize each color entry in the block to the range [0..wtPrimary].
	ForAllPixels
		ColorToFcolor(&colorSrc[pixel], &c[pixel]);

	// Compute mean color
	ForAllPrimaries {
		mean.rgba[primary] = 0.0f;
		wMask = 1;
		ForAllPixels {
			if (wAlpha & wMask)
				mean.rgba[primary] += c[pixel].rgba[primary];
			wMask <<= 1;
		}
		mean.rgba[primary] /= (float) cOpaque;
	}

	// Relocate the mean for each primary color component (R,G,B)
	// to zero by subtracting it from each entry.
	ForAllPrimaries
		ForAllPixels
			c[pixel].rgba[primary] -= mean.rgba[primary];

	// Compute the moment of inertia tensor from the centered color values.
	// This will be t = [ sum(R^2), sum(R*G), sum(R*B) ]
	//                  [ sum(G*R), sum(G^2), sum(G*B) ]
	//                  [ sum(B*R), sum(B*G), sum(B^2) ].
	// Note that it is symmetric, so we only need to get the upper diagonal.
	ForAllPrimaries
		for (k = primary; k < NUM_PRIMARIES; k++) {
			t[primary][k] = 0.0f;
			wMask = 1;
			ForAllPixels {
				if (wAlpha & wMask) {
					t[primary][k] += c[pixel].rgba[primary] * c[pixel].rgba[k];
				}
				wMask <<= 1;
			}
		}

	// Compute principal eigenvalue and its eigen vector using the power method.
	// Rescale every iteration to avoid overflow.
	// Note:   Since the tensor matrix is symmetric, we only need to compute
	// from the diagonal up.
	// FIXME: optimization opportunity: stop looping if converged
	for (pow = 0; pow < 9; pow++) {
		float	scale;		// indicates magnitude of matrix
		float	tt[NUM_PRIMARIES][NUM_PRIMARIES]; // squared inertia tensor

		// Square the scaled matrix and store in tt.
		Square3x3(t, tt);

		// Square result again and store in t.
		Square3x3(tt, t);

		// rescale matrix to avoid overflow
		scale = t[0][0] + t[1][1] + t[2][2];
		
		// trace is positive definite. If it vanishes, moment of
		// inertia can't be diagonalized
		if (scale == 0.0f) {
			AllSame(&colorSrc[0], pblockDst, wAlpha);

			return;  // We're done.
		}
		else {
			scale = 3.0f / scale;

			// Rescale the matrix.
			ForAllPrimaries
				for (k = primary; k < NUM_PRIMARIES; k++)
					t[primary][k] *= scale;
		}
	}

	// Fill in below the diagonal for symmetric inertia tensor matrix
	t[1][0] = t[0][1];
	t[2][0] = t[0][2];
	t[2][1] = t[1][2];

	// Walk the diagonal of the power matrix to find the maximum entry.
	// This will give us the dominant eigenvalue.
	eigenvalue = 0.0f;
	ForAllPrimaries
		if (t[primary][primary] > eigenvalue) {
			eigenvalue = t[primary][primary];
			j = primary;
		}
	eigenvalue = (float) sqrt(eigenvalue);
	eigenvalue = 1.0f / eigenvalue;

	// Now get the color space axis.
	ForAllPrimaries
		axis.rgba[primary] = t[primary][j] * eigenvalue;

	// Compute the square of the magnitude of the axis vector
	axis2 = 0.0f;
	ForAllPrimaries
		axis2 += axis.rgba[primary] * axis.rgba[primary];

	// If the axis is 0, there is only 1 color, so no need for calculating
	// the extrema.  Just unweight the colors and exit.
	if (axis2 == 0.0f) {
		AllSame(&colorSrc[0], pblockDst, wAlpha);

		return;  // We're done.
	}

	// There must be more than 1 color, so let's go find the extrema.
	wMask = 1;
	// FIXME: this is really kludgy
	wMax = -99999.0f;
	wMin =  99999.0f;
	ForAllPixels {
		if (wAlpha & wMask) {
			// Compute weight along ray as w = ((c - mean) . axis)/(axis . axis)
			// Note:  c already holds c-mean
			w = 0.0f;
			ForAllPrimaries
				w += c[pixel].rgba[primary] * axis.rgba[primary];
			w /= axis2;
	
			if (w < wMin)		// If below minimum extreme,
				wMin = w;	//  capture new minimum.
			if (w > wMax)		// If above maximum extreme,
				wMax = w;	//  capture new maximum.
		}
		wMask <<= 1;
	}

	// Compute actual colors of extrema for each primary color component.
	ForAllPrimaries {
		fcolor0.rgba[primary] = mean.rgba[primary] + wMin * axis.rgba[primary];
		fcolor1.rgba[primary] = mean.rgba[primary] + wMax * axis.rgba[primary];
	}

#ifdef	DEBUG
	// fprintf(stderr, "Extrema before RGB clipping:\n");
	// fprintf(stderr, "(%g, %g, %g) - (%g, %g, %g)\n",
        //     fcolor0[RED], fcolor0[GRN], fcolor0[BLU],
        //     fcolor1[RED], fcolor1[GRN], fcolor1[BLU]);
#endif

	// Clip extrema to unit color cube.
	ClipExtrema(&fcolor0, &fcolor1);

#ifdef  DEBUG
	// fprintf(stderr, "Extrema after RGB clipping:\n");
	// fprintf(stderr, "(%g, %g, %g) - (%g, %g, %g)\n",
        //     fcolor0[RED], fcolor0[GRN], fcolor0[BLU],
        //     fcolor1[RED], fcolor1[GRN], fcolor1[BLU]);
#endif

	// Quantize extrema to fixed point RGB565.
	Quantize(&fcolor0, &fcolor1, pblockDst, cOpaque);

#ifdef  DEBUG
	// fprintf(stderr, "Extrema after quantizing:\n");
	// fprintf(stderr, "(%g, %g, %g) - (%g, %g, %g)\n",
        //     fcolor0[RED], fcolor0[GRN], fcolor0[BLU],
        //     fcolor1[RED], fcolor1[GRN], fcolor1[BLU]);
#endif

	// axis2 = sum of the squares of the differences in the two extrema.
	axis2 = 0.0f;
	ForAllPrimaries
		axis2 += (fcolor1.rgba[primary] - fcolor0.rgba[primary]) *
			 (fcolor1.rgba[primary] - fcolor0.rgba[primary]);

	// if we quantized to same color, ...
	if (axis2 == 0.0f && cOpaque == 16) {
		AllSame(&colorSrc[0], pblockDst, wAlpha);
		return;
	}

	// For all pixels in block, calculate and store the index to use.
	wMask = 0x8000;
	for (pixel = S3TC_BLOCK_PIXELS - 1; pixel >= 0; --pixel) {
		if (wAlpha & wMask) {
			// Compute weight along ray connecting extrema.
			w = 0.0f;
			ForAllPrimaries {
				// restore mean to color
				c[pixel].rgba[primary] += mean.rgba[primary];

				w += (c[pixel].rgba[primary] - fcolor0.rgba[primary]) *
				     (fcolor1.rgba[primary] - fcolor0.rgba[primary]);
			}
			w /= axis2;

			// if no transparent pixels, ...
			if (cOpaque == S3TC_BLOCK_PIXELS) {
				// Convert pixels weight from floating point to 2 bit fixed point.
				w *= 4.0f;

				// Clamp indices to valid values.
				if (w < 0.0f) {
					w = 0.0f;
				}
				else if (w >= 4.0f) {
					w = 3.0f;
				}

				// Record index in compressed block.
				pblockDst->pixbm <<= 2;
				pblockDst->pixbm |= mapRGB4[(int) w];
			}
			else {
				// Convert pixels weight from floating point to 2 bit fixed point.
				w *= 3.0f;

				// Clamp indices to valid values.
				if (w < 0.0f)
					w = 0.0f;
				else if (w >= 3.0f)
					w = 2.0f;

				// Record index in compressed block.
				pblockDst->pixbm <<= 2;
				pblockDst->pixbm |= mapRGB3[(int) w];
			}
		}
		else {	// transparent pixel
			pblockDst->pixbm <<= 2;
			pblockDst->pixbm |= 3;
		}

		wMask >>= 1;
	}
}



//***************************************************************************
// DecodeBlockRGB - decompress a color block
//***************************************************************************
void DecodeBlockRGB (S3TCBlockRGB *pblockSrc, S3TC_COLOR colorDst[S3TC_BLOCK_PIXELS])
{
	int	lev;
	S3TC_COLOR	clut[4];
	PIXBM	pixbm;
	int	pixel;
	int	primary;

	// if source block is invalid, ...
	if (pblockSrc == NULL)
    {
        memset(colorDst, 0, sizeof(S3TC_COLOR) * S3TC_BLOCK_PIXELS);
		return;
    }

	// determine the number of color levels in the block
	lev = (pblockSrc->rgb0 <= pblockSrc->rgb1) ? 2 : 3;

	// Fill extrema values into pixel code lookup table.
	RGBToColor(&pblockSrc->rgb0, &clut[0]);
	RGBToColor(&pblockSrc->rgb1, &clut[1]);
	
	clut[0].rgba[ALFA] =
	clut[1].rgba[ALFA] =
	clut[2].rgba[ALFA] = 255;

	// Calculate linear interpolant values.
	if (lev == 3) {	// No transparency info present, all color info.
		ForAllPrimaries {
			WORD temp0 = clut[0].rgba[primary];   // jvanaken fixed overflow bug
			WORD temp1 = clut[1].rgba[primary];
			clut[2].rgba[primary] = (BYTE)((2*temp0 + temp1 + 1)/3);
			clut[3].rgba[primary] = (BYTE)((temp0 + 2*temp1 + 1)/3);
		}
		clut[3].rgba[ALFA] = 255;
	}
	else {	// transparency info.
		ForAllPrimaries {
			WORD temp0 = clut[0].rgba[primary];   // jvanaken fixed overflow bug
			WORD temp1 = clut[1].rgba[primary];
			clut[2].rgba[primary] = (BYTE)((temp0 + temp1)/2);
			clut[3].rgba[primary] = 0;     // jvanaken added this
		}
		clut[3].rgba[ALFA] = 0;
	}

	// munge a local copy
	pixbm = pblockSrc->pixbm;

	// Look up the actual pixel color in the table.
	ForAllPixels {
		// lookup color from pixel bitmap
		ForAllPrimaries
			colorDst[pixel].rgba[primary] = clut[pixbm & 3].rgba[primary];

		colorDst[pixel].rgba[ALFA] = clut[pixbm & 3].rgba[ALFA];

		// prepare to extract next index
		pixbm >>= 2;
	}
}

// EncodeBlockAlpha4 - compress a block with alpha at 4 BPP
void EncodeBlockAlpha4(S3TC_COLOR colorSrc[S3TC_BLOCK_PIXELS], S3TCBlockAlpha4 *pblockDst)
{
	int	row, col;
	WORD	*palpha;

	for (row = 0; row < 4; ++row) {
		palpha = &pblockDst->alphabm[row];

		for (col = 3; col >= 0; --col) {
			*palpha <<= 4;
			*palpha |= (colorSrc[4 * row + col].rgba[ALFA] >> 4) & 0xf;
		}
	}

	EncodeBlockRGB(colorSrc, &pblockDst->rgb);
}

// DecodeBlockAlpha4 - decompress a block with alpha at 4 BPP
void DecodeBlockAlpha4(S3TCBlockAlpha4 *pblockSrc, S3TC_COLOR colorDst[S3TC_BLOCK_PIXELS])
{
	int	row, col;
	WORD	alpha;

	DecodeBlockRGB(&pblockSrc->rgb, colorDst);

	for (row = 0; row < 4; ++row) {
		alpha = pblockSrc->alphabm[row];

		for (col = 0; col < 4; ++col) {
			colorDst[4 * row + col].rgba[ALFA] =
				  ((alpha & 0xf) << 4)
				| (alpha & 0xf);
			alpha >>= 4;
		}
	}
}

// EncodeBlockAlpha3 - compress a block with alpha at 3 BPP
void EncodeBlockAlpha3(S3TC_COLOR colorSrc[S3TC_BLOCK_PIXELS], S3TCBlockAlpha3 *pblockDst)
{
    int	pixel;
    BYTE	alpha0;
    BYTE	alpha1;
    DWORD	dwBM = 0;
    BOOL    b6Alpha;
    // compute extreme alpha values in block
    alpha0 =
    alpha1 = colorSrc[0].rgba[ALFA];	
    for (pixel = 1; pixel < S3TC_BLOCK_PIXELS; ++pixel) 
    {
        if (colorSrc[pixel].rgba[ALFA] > alpha0)
            alpha0 = colorSrc[pixel].rgba[ALFA];
        if (colorSrc[pixel].rgba[ALFA] < alpha1)
            alpha1 = colorSrc[pixel].rgba[ALFA];
    }
    if ( 255 == alpha0 && 0 == alpha1)
    {
        for (pixel = 0; pixel < S3TC_BLOCK_PIXELS; ++pixel) 
        {
            if ((colorSrc[pixel].rgba[ALFA] < alpha0) 
                && (0 != colorSrc[pixel].rgba[ALFA])
               )
                alpha0 = colorSrc[pixel].rgba[ALFA];
            if ((colorSrc[pixel].rgba[ALFA] > alpha1)
                && (255 != colorSrc[pixel].rgba[ALFA])
               )
                alpha1 = colorSrc[pixel].rgba[ALFA];
        }
        if ( alpha0 < alpha1)
        {
            // result always alpha0 < alpha1
            // which is the order for 6 alpha ramp
            b6Alpha = TRUE;	
        }
        else
        {
            // result always alpha0 >= alpha1
            // which is the order for 8 alpha ramp
            b6Alpha = FALSE;
            alpha0 = 255;   //restore for 8 alpha ramp
            alpha1 = 0;
        }
    }
    else
    {
        // result always alpha0 >= alpha1
        // which is the order for 8 alpha ramp
        b6Alpha = FALSE;
    }
  
    // write extreme alphas to block
    pblockDst->alpha0 = alpha0;
    pblockDst->alpha1 = alpha1;

    if (alpha0 != alpha1) 
    {
        int dist = ((int)alpha0 - (int)alpha1);
        int dist2 = dist >> 1;
        int scale = b6Alpha ? 5 : 7;

        for (pixel = S3TC_BLOCK_PIXELS - 1; pixel >= 0; --pixel) 
        {
            // pack 3 bits at a time
            dwBM <<= 3;
            if (b6Alpha && 0 == colorSrc[pixel].rgba[ALFA])
            {
                dwBM |= 6;
            }
            else
            if (b6Alpha && 255 == colorSrc[pixel].rgba[ALFA])
            {
                dwBM |= 7;
            }
            else
            {
                // compute relative distance from extrema
                int	w = ((int)alpha0 - (int)colorSrc[pixel].rgba[ALFA]);

                // scale to 3 bits when comverted to fixed point
                w = (w * scale + dist2) / dist;

                if(w >= scale)
                    dwBM |= 1;
                else if(w > 0)
                    dwBM |= w + 1;
            }
 
            // flush alphabm every 8 pixels (every 3 bytes)
            if ((pixel & 7) == 0) 
            {
                if (pixel == 8) 
                {
                    // unpack 8 bits at a time
                    pblockDst->alphabm[3] = (BYTE) dwBM;
                    dwBM >>= 8;
                    pblockDst->alphabm[4] = (BYTE) dwBM;
                    dwBM >>= 8;
                    pblockDst->alphabm[5] = (BYTE) dwBM;
                }
                else 
                { // pixel == 0
                    // unpack 8 bits at a time
                    pblockDst->alphabm[0] = (BYTE) dwBM;
                    dwBM >>= 8;
                    pblockDst->alphabm[1] = (BYTE) dwBM;
                    dwBM >>= 8;
                    pblockDst->alphabm[2] = (BYTE) dwBM;
                }
            }
        }
    }
    else 
    {	// only one distinct alpha
        pblockDst->alphabm[0] =
        pblockDst->alphabm[1] =
        pblockDst->alphabm[2] =
        pblockDst->alphabm[3] =
        pblockDst->alphabm[4] =
        pblockDst->alphabm[5] = 0;
    }

    EncodeBlockRGB(colorSrc, &pblockDst->rgb);
}

// DecodeBlockAlpha3 - decompress a block with alpha at 3 BPP
void DecodeBlockAlpha3(S3TCBlockAlpha3 *pblockSrc, S3TC_COLOR colorDst[S3TC_BLOCK_PIXELS])
{
    int	pixel;
    int	alpha[8];	// alpha lookup table
    DWORD	dwBM = 0;	// alpha bitmap in DWORD cache

    DecodeBlockRGB(&pblockSrc->rgb, colorDst);

    alpha[0] = pblockSrc->alpha0;
    alpha[1] = pblockSrc->alpha1;

    // if 8 alpha ramp, ...
    if (alpha[0] > alpha[1]) 
    {
        // interpolate intermediate colors with rounding
        alpha[2] = (6 * alpha[0] +     alpha[1]) / 7;
        alpha[3] = (5 * alpha[0] + 2 * alpha[1]) / 7;
        alpha[4] = (4 * alpha[0] + 3 * alpha[1]) / 7;
        alpha[5] = (3 * alpha[0] + 4 * alpha[1]) / 7;
        alpha[6] = (2 * alpha[0] + 5 * alpha[1]) / 7;
        alpha[7] = (    alpha[0] + 6 * alpha[1]) / 7;
    }
    else 
    { // else 6 alpha ramp with 0 and 255
        // interpolate intermediate colors with rounding
        alpha[2] = (4 * alpha[0] +     alpha[1]) / 5;
        alpha[3] = (3 * alpha[0] + 2 * alpha[1]) / 5;
        alpha[4] = (2 * alpha[0] + 3 * alpha[1]) / 5;
        alpha[5] = (    alpha[0] + 4 * alpha[1]) / 5;
        alpha[6] = 0;
        alpha[7] = 255;
    }

    ForAllPixels {
        // reload bitmap dword cache every 8 pixels
        if ((pixel & 7) == 0) {
            if (pixel == 0) {
                // pack 3 bytes into dword
                dwBM  = pblockSrc->alphabm[2];
                dwBM <<= 8;
                dwBM |= pblockSrc->alphabm[1];
                dwBM <<= 8;
                dwBM |= pblockSrc->alphabm[0];
            }
            else {	// pixel == 8
                // pack 3 bytes into dword
                dwBM  = pblockSrc->alphabm[5];
                dwBM <<= 8;
                dwBM |= pblockSrc->alphabm[4];
                dwBM <<= 8;
                dwBM |= pblockSrc->alphabm[3];
            }
        }

        // unpack bitmap dword 3 bits at a time
        colorDst[pixel].rgba[ALFA] = (BYTE)(alpha[(dwBM & 7)]);
        dwBM >>= 3;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\tex\s3tc.h ===
/*
 *   Copyright (c) 1997-8  S3 Inc.  All Rights Reserved.
 *
 *   Module Name:  s3tc.h
 *
 *   Purpose:  Constant, structure, and prototype definitions for S3TC
 *           texture map compression.
 *
 *   Author:  Konstantine Iourcha, Dan McCabe
 *
 *   Revision History:
 *       lthompso 98Jan05 Code beautification.
 *
 */

#ifndef    _S3TC_H_
#define    _S3TC_H_


// number of pixels in block
#define S3TC_BLOCK_PIXELS    16

typedef    struct    {
    BYTE    rgba[4];
} S3TC_COLOR;

typedef    WORD        RGB565;        // packed color
typedef    DWORD        PIXBM;        // 2 BPP bitmap


typedef struct    {
    RGB565        rgb0;        // color for index 0
    RGB565        rgb1;        // color for index 1
    PIXBM        pixbm;        // pixel bitmap
} S3TCBlockRGB;

typedef    struct    {
    WORD        alphabm[4];    // alpha bitmap at 4 BPP
    S3TCBlockRGB    rgb;        // color block
} S3TCBlockAlpha4;

typedef    struct    {
    BYTE        alpha0;        // alpha for index 0
    BYTE        alpha1;        // alpha for index 1
    BYTE        alphabm[6];    // alpha bitmap at 3 BPP
    S3TCBlockRGB    rgb;        // color block
} S3TCBlockAlpha3;


// prototypes for encoders and decoders
void EncodeBlockRGB(S3TC_COLOR colorSrc[S3TC_BLOCK_PIXELS], S3TCBlockRGB *pblockDst);
void DecodeBlockRGB(S3TCBlockRGB *pblockSrc, S3TC_COLOR colorDst[S3TC_BLOCK_PIXELS]);

void EncodeBlockRGBColorKey(S3TC_COLOR colorSrc[S3TC_BLOCK_PIXELS], S3TCBlockRGB *pblockDst, S3TC_COLOR colorLo, S3TC_COLOR colorHi);

void EncodeBlockAlpha4(S3TC_COLOR colorSrc[S3TC_BLOCK_PIXELS], S3TCBlockAlpha4 *pblockDst);
void DecodeBlockAlpha4(S3TCBlockAlpha4 *pblockSrc, S3TC_COLOR colorDst[S3TC_BLOCK_PIXELS]);

void EncodeBlockAlpha3(S3TC_COLOR colorSrc[S3TC_BLOCK_PIXELS], S3TCBlockAlpha3 *pblockDst);
void DecodeBlockAlpha3(S3TCBlockAlpha3 *pblockSrc, S3TC_COLOR colorDst[S3TC_BLOCK_PIXELS]);


#endif    _S3TC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\tex\pchtex.h ===
//
// D3DX texture precompiled header
//

#ifndef __PCHTEX_H__
#define __PCHTEX_H__

#define D3DFMT_R8G8B8 (D3DFORMAT)0x999

#include <d3dx8seg.h>

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <setjmp.h>
#include <xtl.h>
#include <xgraphics.h>

#include "png.h"
#include "jpeglib.h"
#include "s3tc.h"
#include "s3tchelp.h"

#include "d3dx8.h"
#include "d3dx8dbg.h"

typedef signed char  INT8;
typedef short INT16;

typedef unsigned char  UINT8;
typedef unsigned short UINT16;

#include "CD3DXFile.h"
#include "CD3DXImage.h"
#include "CD3DXCodec.h"
#include "CD3DXBlt.h"

#define RELEASE(x) \
    do { if(x) { x->Release(); x = NULL; } } while(0)



//----------------------------------------------------------------------------
//
// F2IBegin, F2I, F2IEnd
//
// Fast FLOAT->INT conversion.  F2IBegin sets and F2IEnd restores the FPU
// rounding mode.  F2I converts a float to an int.  You need to be careful of
// what other floating point code resides between F2IBegin and F2IEnd:  If
// something messes with the rounding mode, you could get unpredicted results.
//
//----------------------------------------------------------------------------

#ifdef _X86_

static UINT32 g_ulFPU;

static VOID
F2IBegin() {
    UINT32 ulFPU, ul;

    __asm {
        fnstcw WORD PTR [ulFPU]        // Get FPU control word
        mov    eax, DWORD PTR [ulFPU]
        or     eax, 0x0C00             // Rounding mode = CLAMP
        mov    DWORD PTR [ul], eax
        fldcw  WORD PTR [ul]           // Set FPU control word
    }

    // Save old FPU control word in thread-local storage
    g_ulFPU = ulFPU;
}


static inline INT
F2I(FLOAT f)
{
    volatile INT n;

    __asm {
        fld   f   // Load fload
        fistp n   // Store integer (and pop)
    }

    return n;
}

static VOID
F2IEnd() {
    // Get old FPU control word from thread-local storage
    UINT32 ulFPU = g_ulFPU;

    __asm {
        fldcw WORD PTR [ulFPU]    // Set FPU control word
    }
}

#else // !_X86_

static VOID
F2IBegin()
{
    // Do nothing
}

static inline INT
F2I(float f)
{
    return (INT) f;
}

static VOID
F2IEnd()
{
    // Do nothing
}

#endif // !_X86_

#endif //__PCHTEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\tex\s3tchelp.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       s3tchelp.cpp
//  Content:    S3 texture compression helpper functions
//
///////////////////////////////////////////////////////////////////////////

#include "pchtex.h"

//-----------------------------------------------------------------------------
// This band-aid is here temporarily (we hope) until S3 fixes their
// EncodeBlockRGB function to stop ignoring the transparency/opacity
// info in the alpha components of the 4x4 block of source pixels.
// For now, if any pixels are transparent, we have to define a color-
// key value and set the transparent pixels to the color-key value.
// Because this encoding format can store only a single bit of alpha
// for each pixel, we just look at the MSB of the pixel's 8-bit alpha.
// Hence, alpha values in the range 0 to 127 are transparent.

void 
XXEncodeBlockRGB(S3TC_COLOR colorSrc[S3TC_BLOCK_PIXELS], S3TCBlockRGB *blockdst)
{
    int i;
    DWORD colorKey;
    UINT32 *pargb = (UINT32 *)colorSrc;

    // Determine if any of the pixels in the 4x4 block are transparent.
    // Transparency is determined by the MSB of the 8-bit alpha value,
    // which is the sign bit if we treat the 32-bit pixel as a "long."
    for (i = 0; i < 16; ++i)
    {
        if (*(long *)&pargb[i] >= 0)
        {
            // Yes, this pixel is transparent.
            break;
        }
    }

    // Are any of the pixels transparent?
    if (i == 16)
    {
        // No, none of the 16 pixels is transparent.
        EncodeBlockRGB(colorSrc, blockdst);
        return;
    }

    // One or more pixels is transparent.  We need to find a color-key
    // value that does not match any of the opaque pixels in the block.
    for (colorKey = 0; ; ++colorKey)
    {
        for (i = 0; i < 16; ++i)
        {
            if (*(long *)&pargb[i] >= 0)
            {
                // This pixel is not opaque, so skip to next pixel.
                continue;
            }
            if ((pargb[i] & 0x00ffffff) == colorKey)
            {
                // This is not a good color-key value because it matches
                // one of the opaque pixels in the block.  Try again.
                break;
            }
        }
        // Did we find a good color-key value?
        if (i == 16)
        {
            // Yes, we've got a good color-key value.
            break;    
        }
    }

    // Replace any transparent pixels with the color-key value.
    for (i = 0; i < 16; ++i)
    {
        // Is this pixel transparent?
        if (*(long *)&pargb[i] >= 0)
        {
            // Yes, replace transparent pixel with color-key value.
            pargb[i] = colorKey;
        }
    }
    EncodeBlockRGBColorKey(colorSrc, blockdst,
                *(S3TC_COLOR *)&colorKey, *(S3TC_COLOR *)&colorKey);
}  


//-----------------------------------------------------------------------------
// This band-aid is here temporarily (we hope) until S3 fixes their
// DecodeBlockRGB function to zero the color components of any pixels
// whose alpha components are zero.

void 
XXDecodeBlockRGB(S3TCBlockRGB *blocksrc, S3TC_COLOR colordst[S3TC_BLOCK_PIXELS])
{
    int i;
    UINT32 *pargb = (UINT32 *)colordst;

    DecodeBlockRGB(blocksrc, colordst);
    for (i = 0; i < 16; ++i)
    {
        if ((pargb[i] >> 24) == 0)
        {
            pargb[i] = 0;   // zero RGB components
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\tex\s3tchelp.h ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       s3tchelp.h
//  Content:    S3 texture compression helpper functions
//
///////////////////////////////////////////////////////////////////////////

void XXEncodeBlockRGB(S3TC_COLOR colorSrc[S3TC_BLOCK_PIXELS], S3TCBlockRGB *blockdst);
void XXDecodeBlockRGB(S3TCBlockRGB *blocksrc, S3TC_COLOR colordst[S3TC_BLOCK_PIXELS]);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\tex\d3dx8tex.cpp ===
///////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dx8tex.cpp
//  Content:    D3DX texturing APIs
//
///////////////////////////////////////////////////////////////////////////

#include "pchtex.h"

#ifdef DBG

// This is a hack so that users get a reasonable error message when they
// link with D3D8X and don't link with XGraphics. It could be defined
// in any source file that's included in the XGraphics library.

#define XGRAPHICS_SYMBOL you_must_also_link_with_xgraphicsd_lib
extern "C" {
    extern DWORD XGRAPHICS_SYMBOL;
};

#define DBG_LINKWITHXGRAPHICS ((void) (XGRAPHICS_SYMBOL = 0))

#else

#define DBG_LINKWITHXGRAPHICS ((void) 0)

#endif

BOOL D3DX__Premult = TRUE;

void WINAPI D3DXSetDXT3DXT5(BOOL Set)
{
    if (Set)
    {
        D3DX__Premult = FALSE;
    }
    else
    {
        D3DX__Premult = TRUE;
    }
}

BOOL WINAPI D3DXGetDXT3DXT5(void)
{
    return (D3DX__Premult == FALSE);
}

BOOL IsUvl(D3DFORMAT format)
{
    switch (format) {
    case D3DFMT_LIN_V16U16: 
    case D3DFMT_LIN_V8U8: 
    case D3DFMT_LIN_L6V5U5: 
    case D3DFMT_LIN_X8L8V8U8: 
    case D3DFMT_LIN_Q8W8V8U8: 
    case D3DFMT_V16U16: 
    case D3DFMT_V8U8: 
    case D3DFMT_L6V5U5: 
    case D3DFMT_X8L8V8U8: 
    case D3DFMT_Q8W8V8U8: 
        return TRUE;
    default: 
        return FALSE;
    }
}

static HRESULT
    CheckTextureRequirements(
        LPDIRECT3DDEVICE8     pDevice,
        UINT*                 pWidth,
        UINT*                 pHeight,
        UINT*                 pDepth,
        UINT*                 pMipLevels,
        DWORD                 Usage,
        D3DFORMAT*            pFormat,
        D3DPOOL               Pool,
        UINT                  uType)
{
    HRESULT hr;

    // Validate arguments
    if(!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(D3DX_DEFAULT == Usage)
        Usage = 0;

    if(Usage != (Usage & (D3DUSAGE_RENDERTARGET | D3DUSAGE_DEPTHSTENCIL)))
    {
        DPF(0, "Usage parameter is invalid");
        return D3DERR_INVALIDCALL;
    }
    if((2 == uType) && (Usage & (D3DUSAGE_RENDERTARGET | D3DUSAGE_DEPTHSTENCIL)))
    {
        DPF(0, "Usage parameter is invalid");
        return D3DERR_INVALIDCALL;
    }
    if((D3DPOOL_DEFAULT != Pool) && (D3DPOOL_MANAGED != Pool) && (D3DPOOL_SYSTEMMEM != Pool))
    {
        DPF(0, "Pool parameter is invalid");
        return D3DERR_INVALIDCALL;
    }

    // Get caps
    LPDIRECT3D8 pD3D;
    D3DCAPS8 Caps;
    D3DDISPLAYMODE Mode;

    pDevice->GetDirect3D(&pD3D);
    pDevice->GetDeviceCaps(&Caps);
    pDevice->GetDisplayMode(&Mode);


    // cpWidth and cpHeight
    UINT cpWidth  = pWidth  ? *pWidth  : D3DX_DEFAULT;
    UINT cpHeight = pHeight ? *pHeight : D3DX_DEFAULT;
    UINT cpDepth  = pDepth  ? *pDepth  : D3DX_DEFAULT;

    if(D3DX_DEFAULT == cpWidth && D3DX_DEFAULT == cpHeight)
        cpWidth = cpHeight = 256;
    else if(D3DX_DEFAULT == cpWidth)
        cpWidth = cpHeight;
    else if(D3DX_DEFAULT == cpHeight)
        cpHeight = cpWidth;

    if(0 == cpWidth)
        cpWidth = 1;
    if(0 == cpHeight)
        cpHeight = 1;

    if(uType == 1)
        cpWidth = cpHeight = ((cpWidth > cpHeight) ? cpWidth : cpHeight);

    if(D3DX_DEFAULT == cpDepth || 0 == cpDepth)
        cpDepth = 1;

    if(uType == 2)
    {
        if(cpDepth > Caps.MaxVolumeExtent)
            cpDepth = Caps.MaxVolumeExtent;

        if(cpWidth > Caps.MaxVolumeExtent)
            cpWidth = Caps.MaxVolumeExtent;

        if(cpHeight > Caps.MaxVolumeExtent)
            cpHeight = Caps.MaxVolumeExtent;
    }
    else
    {
        if(cpWidth > Caps.MaxTextureWidth)
            cpWidth = Caps.MaxTextureWidth;

        if(cpHeight > Caps.MaxTextureHeight)
            cpHeight = Caps.MaxTextureHeight;

    }


    if(uType == 0)
    {
        if(Caps.TextureCaps & D3DPTEXTURECAPS_SQUAREONLY)
            Caps.MaxTextureAspectRatio = 1;

        if(Caps.MaxTextureAspectRatio)
        {
            if(cpWidth > cpHeight * Caps.MaxTextureAspectRatio)
                cpWidth = cpHeight * Caps.MaxTextureAspectRatio;

            if(cpHeight > cpWidth * Caps.MaxTextureAspectRatio)
                cpHeight = cpWidth * Caps.MaxTextureAspectRatio;
        }
    }

    CONST DWORD dwPow2[] =
    {
        D3DPTEXTURECAPS_POW2,
        D3DPTEXTURECAPS_CUBEMAP_POW2,
        D3DPTEXTURECAPS_VOLUMEMAP_POW2
    };

    if(Caps.TextureCaps & dwPow2[uType])
    {
        DWORD dw;

        for(dw = cpWidth,  cpWidth  = 1; cpWidth  < dw; cpWidth  <<= 1);
        for(dw = cpHeight, cpHeight = 1; cpHeight < dw; cpHeight <<= 1);
        for(dw = cpDepth,  cpDepth  = 1; cpDepth  < dw; cpDepth  <<= 1);
    }

    if(pFormat)
    {
        switch(*pFormat)
        {
        case D3DFMT_DXT1:
        case D3DFMT_DXT2:
        case D3DFMT_DXT4:
#if 0
        case D3DFMT_DXT3:
        case D3DFMT_DXT5:
#endif
            cpWidth  = (cpWidth  + 3) & ~3;
            cpHeight = (cpHeight + 3) & ~3;
            break;
        }
    }



    // MipLevels
    CONST DWORD dwMipmap[] =
    {
        D3DPTEXTURECAPS_MIPMAP,
        D3DPTEXTURECAPS_MIPCUBEMAP,
        D3DPTEXTURECAPS_MIPVOLUMEMAP
    };

    UINT cMipLevels = pMipLevels ? *pMipLevels : D3DX_DEFAULT;

    if((Caps.TextureCaps & dwMipmap[uType]) && !(cpWidth & (cpWidth - 1)) &&
        !(cpHeight & (cpHeight - 1)) && !(cpDepth & (cpDepth - 1)))
    {
        UINT dw, dwW, dwH, dwD;

        for(dw = cpWidth,  dwW = 1; dw && !(dw & 1); dw >>= 1, dwW++);
        for(dw = cpHeight, dwH = 1; dw && !(dw & 1); dw >>= 1, dwH++);
        for(dw = cpDepth,  dwD = 1; dw && !(dw & 1); dw >>= 1, dwD++);

        dw = (dwW > dwH) ? dwW : dwH;

        if(uType == 2)
            dw = (dwD > dw) ? dwD : dw;

        if(cMipLevels > dw || cMipLevels == 0)
            cMipLevels = dw;
    }
    else
    {
        cMipLevels = 1;
    }

    pD3D->Release();

    if(pWidth)
        *pWidth = cpWidth;
    if(pHeight)
        *pHeight = cpHeight;
    if(pDepth)
        *pDepth = cpDepth;
    if(pMipLevels)
        *pMipLevels = cMipLevels;

    return S_OK;
}







///////////////////////////////////////////////////////////////////////////
// Surface APIs ///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
    D3DXLoadSurfaceFromFileA(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCSTR                pSrcFile,
        CONST RECT*           pSrcRect,
        DWORD                 dwFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo)
{
    HRESULT hr;
    CD3DXFile fm;

    if(FAILED(hr = fm.Open(pSrcFile, FALSE)))
        return hr;

    return D3DXLoadSurfaceFromFileInMemory(pDestSurface, pDestPalette,
        pDestRect, fm.m_pvData, fm.m_cbData, pSrcRect, dwFilter, ColorKey, 
        pSrcInfo);
}

#if 0
HRESULT WINAPI
    D3DXLoadSurfaceFromFileW(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCWSTR               pSrcFile,
        CONST RECT*           pSrcRect,
        DWORD                 dwFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo)
{
    HRESULT hr;
    CD3DXFile fm;

    if(FAILED(hr = fm.Open(pSrcFile, TRUE)))
        return hr;

    return D3DXLoadSurfaceFromFileInMemory(pDestSurface, pDestPalette,
        pDestRect, fm.m_pvData, fm.m_cbData, pSrcRect, dwFilter, ColorKey,
        pSrcInfo);
}
#endif
#if 0
HRESULT WINAPI
    D3DXLoadSurfaceFromResourceA(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        HMODULE               hSrcModule,
        LPCSTR                pSrcResource,
        CONST RECT*           pSrcRect,
        DWORD                 dwFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo)
{
    HRESULT hr;
    CD3DXResource res;

    if(FAILED(hr = res.Open(hSrcModule, pSrcResource, FALSE)))
        return hr;

    return D3DXLoadSurfaceFromFileInMemory(pDestSurface, pDestPalette,
        pDestRect, res.m_pvData, res.m_cbData, pSrcRect, dwFilter, ColorKey,
        pSrcInfo);
}


HRESULT WINAPI
    D3DXLoadSurfaceFromResourceW(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        HMODULE               hSrcModule,
        LPCWSTR               pSrcResource,
        CONST RECT*           pSrcRect,
        DWORD                 dwFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo)
{
    HRESULT hr;
    CD3DXResource res;

    if(FAILED(hr = res.Open(hSrcModule, pSrcResource, TRUE)))
        return hr;

    return D3DXLoadSurfaceFromFileInMemory(pDestSurface, pDestPalette,
        pDestRect, res.m_pvData, res.m_cbData, pSrcRect, dwFilter, ColorKey,
        pSrcInfo);
}
#endif

HRESULT WINAPI
    D3DXLoadSurfaceFromFileInMemory(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCVOID               pvSrcData,
        UINT                  cbSrcData,
        CONST RECT*           pSrcRect,
        DWORD                 dwFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo)
{
    HRESULT hr;
    CD3DXImage Image;
    RECT SrcRect;

    // Validate args
    if(!pDestSurface)
    {
        DPF(0, "pDestSurface pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!pvSrcData || !cbSrcData)
    {
        DPF(0, "Source surface data (pvSrcData or cbSrcData) is invalid");
        return D3DERR_INVALIDCALL;
    }

    // Pick file loader
    if(FAILED(hr = Image.Load(pvSrcData, cbSrcData, pSrcInfo)))
        return hr;

    if(pSrcRect)
    {
        SrcRect = *pSrcRect;

        if(SrcRect.left < 0 || SrcRect.right  > Image.m_Rect.right  || SrcRect.left > SrcRect.right ||
           SrcRect.top  < 0 || SrcRect.bottom > Image.m_Rect.bottom || SrcRect.top  > SrcRect.bottom)
        {
            DPF(0, "Invalid source rect");
            return D3DERR_INVALIDCALL;
        }
    }
    else
    {
        SrcRect = Image.m_Rect;
    }

    // Load image data into surface
    if(FAILED(hr = D3DXLoadSurfaceFromMemory(pDestSurface, pDestPalette,
        pDestRect, Image.m_pvData, Image.m_Format, Image.m_cbPitch, Image.m_pPalette,
        &SrcRect, dwFilter, ColorKey)))
    {
        return hr;
    }

    return S_OK;
}


HRESULT WINAPI
    D3DXLoadSurfaceFromSurface(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPDIRECT3DSURFACE8    pSrcSurface,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST RECT*           pSrcRect,
        DWORD                 dwFilter,
        D3DCOLOR              ColorKey)
{
    D3DSURFACE_DESC SrcDesc;
    D3DSURFACE_DESC DstDesc;
    D3DLOCKED_RECT SrcLock;
    RECT SrcRect;
    PBYTE pSrcBits = NULL;
    HRESULT hr;


    // Validate args
    if(!pDestSurface)
    {
        DPF(0, "pDestSurface pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!pSrcSurface)
    {
        DPF(0, "pSrcSurface pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    pSrcSurface->GetDesc(&SrcDesc);

    if(pSrcRect)
    {
        SrcRect = *pSrcRect;

        if(SrcRect.left < 0 || (DWORD) SrcRect.right  > SrcDesc.Width  || SrcRect.left > SrcRect.right ||
           SrcRect.top  < 0 || (DWORD) SrcRect.bottom > SrcDesc.Height || SrcRect.top  > SrcRect.bottom)
        {
            DPF(0, "Invalid source rect");
            return D3DERR_INVALIDCALL;
        }
    }
    else
    {
        SrcRect.left   = 0;
        SrcRect.top    = 0;
        SrcRect.right  = SrcDesc.Width;
        SrcRect.bottom = SrcDesc.Height;
    }


    // Get source surface data
    if(FAILED(hr = pSrcSurface->LockRect(&SrcLock, NULL, D3DLOCK_READONLY | D3DLOCK_TILED)))
    {
        DPF(0, "Could not lock source surface");
        return hr;
    }

    DBG_LINKWITHXGRAPHICS;

    if (XGIsSwizzledFormat(SrcDesc.Format))
    {
        DWORD dx, dy;

        pSrcBits = (PBYTE)LocalAlloc(0, SrcDesc.Size);

        if (pSrcBits == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto LDone;
        }

        POINT point = { SrcRect.left, SrcRect.top };

        XGUnswizzleRect(
                SrcLock.pBits,
                SrcDesc.Width,
                SrcDesc.Height,
                &SrcRect,
                pSrcBits,
                SrcLock.Pitch,
                &point,
                XGBytesPerPixelFromFormat(SrcDesc.Format));
    }
    else 
    {
        pSrcBits = (PBYTE)SrcLock.pBits;
    }

    if(FAILED(hr = D3DXLoadSurfaceFromMemory(pDestSurface, pDestPalette,
        pDestRect, pSrcBits, SrcDesc.Format, SrcLock.Pitch, pSrcPalette,
        &SrcRect, dwFilter, ColorKey)))
    {
        goto LDone;
    }

    hr = S_OK;
    goto LDone;

LDone:

    if (pSrcBits != SrcLock.pBits && pSrcBits != NULL)
    {
        LocalFree(pSrcBits);
    }

    pSrcSurface->UnlockRect();
    return hr;
}


HRESULT WINAPI
    D3DXLoadSurfaceFromMemory(
        LPDIRECT3DSURFACE8    pDestSurface,
        CONST PALETTEENTRY*   pDestPalette,
        CONST RECT*           pDestRect,
        LPCVOID               pSrcMemory,
        D3DFORMAT             SrcFormat,
        UINT                  cbSrcPitch,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST RECT*           pSrcRect,
        DWORD                 dwFilter,
        D3DCOLOR              ColorKey)
{
    D3DSURFACE_DESC DestDesc;
    D3DLOCKED_RECT DestLock;
    RECT DestRect;
    HRESULT hr;
    CD3DXBlt Blt;
    PBYTE pDestBits = NULL;
    DWORD dx, dy;
    BOOL bSwizzled;

    SURFACE_PORT_WARNING();

    // Validate args
    if(!pDestSurface)
    {
        DPF(0, "pDestSurface pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!pSrcMemory)
    {
        DPF(0, "pSrcMemory pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!pSrcRect)
    {
        DPF(0, "pSrcRect pointer is invalid");
        return D3DERR_INVALIDCALL;
    }




    if(D3DX_DEFAULT == dwFilter)
    {
        if(IsUvl(SrcFormat))
            dwFilter = D3DX_FILTER_POINT | D3DX_FILTER_DITHER;
        else
            dwFilter = D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER;
    }


    pDestSurface->GetDesc(&DestDesc);

    if(pDestRect)
    {
        DestRect = *pDestRect;

        if(DestRect.left < 0 || (DWORD) DestRect.right  > DestDesc.Width  || DestRect.left > DestRect.right ||
           DestRect.top  < 0 || (DWORD) DestRect.bottom > DestDesc.Height || DestRect.top  > DestRect.bottom)
        {
            DPF(0, "Invalid destination rect");
            return D3DERR_INVALIDCALL;
        }
    }
    else
    {
        DestRect.left   = 0;
        DestRect.top    = 0;
        DestRect.right  = DestDesc.Width;
        DestRect.bottom = DestDesc.Height;
    }


    // Get dest surface data
    if(FAILED(hr = pDestSurface->LockRect(&DestLock, NULL, D3DLOCK_TILED)))
    {
        DPF(0, "Could not lock destination surface");
        return hr;
    }

    DBG_LINKWITHXGRAPHICS;

    bSwizzled = XGIsSwizzledFormat(DestDesc.Format);

    if (bSwizzled)
    {
        pDestBits = (PBYTE)LocalAlloc(0, DestDesc.Size);

        if (pDestBits == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto LDone;
        }
    }
    else 
    {
        pDestBits = (PBYTE)DestLock.pBits;
    }

    // Blt using specified filter
    D3DX_BLT DestBlt, SrcBlt;

    DestBlt.pData            = pDestBits;
    DestBlt.RowPitch         = DestLock.Pitch;
    DestBlt.SlicePitch       = 0;
    DestBlt.Format           = DestDesc.Format;
    DestBlt.ColorKey         = 0;
    DestBlt.pPalette         = pDestPalette;

    DestBlt.Region.Left      = 0;
    DestBlt.Region.Right     = (UINT) DestDesc.Width;
    DestBlt.Region.Top       = 0;
    DestBlt.Region.Bottom    = (UINT) DestDesc.Height;
    DestBlt.Region.Front     = 0;
    DestBlt.Region.Back      = 1;

    DestBlt.SubRegion.Left   = (UINT) DestRect.left;
    DestBlt.SubRegion.Top    = (UINT) DestRect.top;
    DestBlt.SubRegion.Right  = (UINT) DestRect.right;
    DestBlt.SubRegion.Bottom = (UINT) DestRect.bottom;
    DestBlt.SubRegion.Front  = 0;
    DestBlt.SubRegion.Back   = 1;


    SrcBlt.pData             = (LPVOID) pSrcMemory;
    SrcBlt.RowPitch          = cbSrcPitch;
    SrcBlt.SlicePitch        = 0;
    SrcBlt.Format            = SrcFormat;
    SrcBlt.ColorKey          = ColorKey;
    SrcBlt.pPalette          = pSrcPalette;

    SrcBlt.SubRegion.Left    = (UINT) pSrcRect->left;
    SrcBlt.SubRegion.Top     = (UINT) pSrcRect->top;
    SrcBlt.SubRegion.Right   = (UINT) pSrcRect->right;
    SrcBlt.SubRegion.Bottom  = (UINT) pSrcRect->bottom;
    SrcBlt.SubRegion.Front   = 0;
    SrcBlt.SubRegion.Back    = 1;


    if(FAILED(hr = Blt.Blt(&DestBlt, &SrcBlt, dwFilter)))
        goto LDone;

    if (bSwizzled)
    {
        POINT point = { DestRect.left, DestRect.top };

        DBG_LINKWITHXGRAPHICS;

        XGSwizzleRect(
                pDestBits,
                DestLock.Pitch,
                &DestRect,
                DestLock.pBits,
                DestDesc.Width,
                DestDesc.Height,
                &point,
                XGBytesPerPixelFromFormat(DestDesc.Format));
    }

    hr = S_OK;
    goto LDone;

LDone:

    if (bSwizzled && pDestBits != NULL)
    {
        LocalFree(pDestBits);
    }

    pDestSurface->UnlockRect();
    return hr;
}



///////////////////////////////////////////////////////////////////////////
// Volume APIs ////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


HRESULT WINAPI
    D3DXLoadVolumeFromVolume(
        LPDIRECT3DVOLUME8     pDestVolume,
        CONST PALETTEENTRY*   pDestPalette,
        CONST D3DBOX*         pDestBox,
        LPDIRECT3DVOLUME8     pSrcVolume,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST D3DBOX*         pSrcBox,
        DWORD                 dwFilter,
        D3DCOLOR              ColorKey)
{
    D3DVOLUME_DESC SrcDesc;
    D3DLOCKED_BOX  SrcLock;
    D3DBOX SrcBox;
    HRESULT hr;
    PBYTE pSrcBits = NULL;


    // Validate args
    if(!pDestVolume)
    {
        DPF(0, "pDestVolume pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!pSrcVolume)
    {
        DPF(0, "pSrcVolume pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    pSrcVolume->GetDesc(&SrcDesc);

    if(pSrcBox)
    {
        SrcBox = *pSrcBox;

        if((DWORD) SrcBox.Right  > SrcDesc.Width  || SrcBox.Left  > SrcBox.Right ||
           (DWORD) SrcBox.Bottom > SrcDesc.Height || SrcBox.Top   > SrcBox.Bottom ||
           (DWORD) SrcBox.Back   > SrcDesc.Depth  || SrcBox.Front > SrcBox.Back)
        {
            DPF(0, "Invalid source box");
            return D3DERR_INVALIDCALL;
        }
    }
    else
    {
        SrcBox.Left   = 0;
        SrcBox.Top    = 0;
        SrcBox.Front  = 0;
        SrcBox.Right  = SrcDesc.Width;
        SrcBox.Bottom = SrcDesc.Height;
        SrcBox.Back   = SrcDesc.Depth;
    }


    if(FAILED(hr = pSrcVolume->LockBox(&SrcLock, NULL, D3DLOCK_READONLY | D3DLOCK_TILED)))
    {
        DPF(0, "Could not lock source volume");
        return hr;
    }

    DBG_LINKWITHXGRAPHICS;

    if (XGIsSwizzledFormat(SrcDesc.Format))
    {
        pSrcBits = (PBYTE)LocalAlloc(0, SrcDesc.Size);

        if (pSrcBits == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto LDone;
        }

        XGPOINT3D point = { SrcBox.Left, SrcBox.Top, SrcBox.Front };

        XGUnswizzleBox(
                SrcLock.pBits,
                SrcDesc.Width,
                SrcDesc.Height,
                SrcDesc.Depth,
                &SrcBox,
                pSrcBits,
                SrcLock.RowPitch,
                SrcLock.SlicePitch,
                &point,
                XGBytesPerPixelFromFormat(SrcDesc.Format));
    }
    else 
    {
        pSrcBits = (PBYTE)SrcLock.pBits;
    }

    if(FAILED(hr = D3DXLoadVolumeFromMemory(pDestVolume, pDestPalette,
        pDestBox, pSrcBits, SrcDesc.Format, SrcLock.RowPitch, SrcLock.SlicePitch,
        pSrcPalette, &SrcBox, dwFilter, ColorKey)))
    {
        goto LDone;
    }

    hr = S_OK;
    goto LDone;

LDone:

    if (pSrcBits != SrcLock.pBits && pSrcBits != NULL)
    {
        LocalFree(pSrcBits);
    }

    pSrcVolume->UnlockBox();
    return hr;
}


HRESULT WINAPI
    D3DXLoadVolumeFromMemory(
        LPDIRECT3DVOLUME8     pDestVolume,
        CONST PALETTEENTRY*   pDestPalette,
        CONST D3DBOX*         pDestBox,
        LPCVOID               pSrcMemory,
        D3DFORMAT             SrcFormat,
        UINT                  cbSrcRowPitch,
        UINT                  cbSrcSlicePitch,
        CONST PALETTEENTRY*   pSrcPalette,
        CONST D3DBOX*         pSrcBox,
        DWORD                 dwFilter,
        D3DCOLOR              ColorKey)
{
    D3DVOLUME_DESC DestDesc;
    D3DLOCKED_BOX DestLock;
    D3DBOX DestBox;
    HRESULT hr;
    CD3DXBlt Blt;
    PBYTE pDestBits = NULL;
    BOOL bSwizzled;

    SURFACE_PORT_WARNING();

    // Validate args
    if(!pDestVolume)
    {
        DPF(0, "pDestVolume pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!pSrcMemory)
    {
        DPF(0, "pSrcMemory pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!pSrcBox)
    {
        DPF(0, "pSrcBox pointer is invalid");
        return D3DERR_INVALIDCALL;
    }


    if(D3DX_DEFAULT == dwFilter)
    {
        if(IsUvl(SrcFormat))
            dwFilter = D3DX_FILTER_POINT | D3DX_FILTER_DITHER;
        else
            dwFilter = D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER;
    }


    pDestVolume->GetDesc(&DestDesc);

    if(pDestBox)
    {
        DestBox = *pDestBox;

        if((DWORD) DestBox.Right  > DestDesc.Width  || DestBox.Left  > DestBox.Right ||
           (DWORD) DestBox.Bottom > DestDesc.Height || DestBox.Top   > DestBox.Bottom ||
           (DWORD) DestBox.Back   > DestDesc.Depth  || DestBox.Front > DestBox.Back)
        {
            DPF(0, "Invalid destination box");
            return D3DERR_INVALIDCALL;
        }
    }
    else
    {
        DestBox.Left   = 0;
        DestBox.Top    = 0;
        DestBox.Front  = 0;
        DestBox.Right  = DestDesc.Width;
        DestBox.Bottom = DestDesc.Height;
        DestBox.Back   = DestDesc.Depth;
    }


    // Get dest Volume data
    if(FAILED(hr = pDestVolume->LockBox(&DestLock, NULL, D3DLOCK_TILED)))
    {
        DPF(0, "Could not lock destination volume");
        return hr;
    }

    DBG_LINKWITHXGRAPHICS;

    bSwizzled = XGIsSwizzledFormat(DestDesc.Format);

    if (bSwizzled)
    {
        pDestBits = (PBYTE)LocalAlloc(0, DestDesc.Size);

        if (pDestBits == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto LDone;
        }
    }
    else 
    {
        pDestBits = (PBYTE)DestLock.pBits;
    }

    // Blt using specified filter
    D3DX_BLT DestBlt, SrcBlt;

    DestBlt.pData       = pDestBits;
    DestBlt.RowPitch    = DestLock.RowPitch;
    DestBlt.SlicePitch  = DestLock.SlicePitch;
    DestBlt.SubRegion   = DestBox;
    DestBlt.Format      = DestDesc.Format;
    DestBlt.ColorKey    = 0;
    DestBlt.pPalette    = pDestPalette;

    DestBlt.Region.Left      = 0;
    DestBlt.Region.Right     = (UINT) DestDesc.Width;
    DestBlt.Region.Top       = 0;
    DestBlt.Region.Bottom    = (UINT) DestDesc.Height;
    DestBlt.Region.Front     = 0;
    DestBlt.Region.Back      = (UINT) DestDesc.Depth;

    SrcBlt.pData        = (LPVOID) pSrcMemory;
    SrcBlt.RowPitch     = cbSrcRowPitch;
    SrcBlt.SlicePitch   = cbSrcSlicePitch;
    SrcBlt.SubRegion    = *pSrcBox;
    SrcBlt.Format       = SrcFormat;
    SrcBlt.ColorKey     = ColorKey;
    SrcBlt.pPalette     = pSrcPalette;


    if(FAILED(hr = Blt.Blt(&DestBlt, &SrcBlt, dwFilter)))
        goto LDone;

    if (bSwizzled)
    {
        XGPOINT3D point = { DestBox.Left, DestBox.Top, DestBox.Front };

        DBG_LINKWITHXGRAPHICS;

        XGSwizzleBox(
                pDestBits,
                DestLock.RowPitch,
                DestLock.SlicePitch,
                &DestBox,
                DestLock.pBits,
                DestDesc.Width,
                DestDesc.Height,
                DestDesc.Depth,
                &point,
                XGBytesPerPixelFromFormat(DestDesc.Format));
    }

    hr = S_OK;
    goto LDone;

LDone:

    if (bSwizzled && pDestBits != NULL)
    {
        LocalFree(pDestBits);
    }

    pDestVolume->UnlockBox();
    return hr;
}






///////////////////////////////////////////////////////////////////////////
// Texture APIs ///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
    D3DXCheckTextureRequirements(
        LPDIRECT3DDEVICE8     pDevice,
        UINT*                 pWidth,
        UINT*                 pHeight,
        UINT*                 pNumMipLevels,
        DWORD                 Usage,
        D3DFORMAT*            pFormat,
        D3DPOOL               Pool)
{
    return CheckTextureRequirements(pDevice, pWidth, pHeight, NULL,
        pNumMipLevels, Usage, pFormat, Pool, 0);
}


HRESULT WINAPI
    D3DXCreateTexture(
        LPDIRECT3DDEVICE8     pDevice,
        UINT                  cpWidth,
        UINT                  cpHeight,
        UINT                  cMipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        LPDIRECT3DTEXTURE8*   ppTexture)
{
    HRESULT hr;

    // Validate arguments
    if(!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!ppTexture)
    {
        DPF(0, "ppTexture pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(D3DX_DEFAULT == Usage)
        Usage = 0;

    // Check texture requirements
    if(FAILED(hr = D3DXCheckTextureRequirements(pDevice, &cpWidth, &cpHeight,
        &cMipLevels, Usage, &Format, Pool)))
    {
        return hr;
    }

    // Create texture
    if(FAILED(hr = pDevice->CreateTexture(cpWidth, cpHeight, cMipLevels,
        Usage, Format, Pool, ppTexture)))
    {
        DPF(0, "CreateTexture failed");
        return hr;
    }

    return S_OK;
}


HRESULT WINAPI
    D3DXCreateTextureFromFileA(
        LPDIRECT3DDEVICE8     pDevice,
        LPCSTR                pSrcFile,
        LPDIRECT3DTEXTURE8*   ppTexture)
{
    return D3DXCreateTextureFromFileExA(pDevice, pSrcFile, D3DX_DEFAULT,
        D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED,
        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture);
}

#if 0
HRESULT WINAPI
    D3DXCreateTextureFromFileW(
        LPDIRECT3DDEVICE8     pDevice,
        LPCWSTR               pSrcFile,
        LPDIRECT3DTEXTURE8*   ppTexture)
{
    return D3DXCreateTextureFromFileExW(pDevice, pSrcFile, D3DX_DEFAULT,
        D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED,
        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture);
}
#endif
#if 0
HRESULT WINAPI
    D3DXCreateTextureFromResourceA(
        LPDIRECT3DDEVICE8     pDevice,
        HMODULE               hSrcModule,
        LPCSTR                pSrcResource,
        LPDIRECT3DTEXTURE8*   ppTexture)
{
    return D3DXCreateTextureFromResourceExA(pDevice, hSrcModule, pSrcResource,
        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN,
        D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture);
}


HRESULT WINAPI
    D3DXCreateTextureFromResourceW(
        LPDIRECT3DDEVICE8     pDevice,
        HMODULE               hSrcModule,
        LPCWSTR               pSrcResource,
        LPDIRECT3DTEXTURE8*   ppTexture)
{
    return D3DXCreateTextureFromResourceExW(pDevice, hSrcModule, pSrcResource,
        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN,
        D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture);
}
#endif

HRESULT WINAPI
    D3DXCreateTextureFromFileExA(
        LPDIRECT3DDEVICE8     pDevice,
        LPCSTR                pSrcFile,
        UINT                  cpWidth,
        UINT                  cpHeight,
        UINT                  cMipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 dwFilter,
        DWORD                 dwMipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture)
{
    HRESULT hr;
    CD3DXFile fm;

    if(FAILED(hr = fm.Open(pSrcFile, FALSE)))
        return hr;

    return D3DXCreateTextureFromFileInMemoryEx(pDevice, fm.m_pvData,
        fm.m_cbData, cpWidth, cpHeight, cMipLevels, Usage, Format,
        Pool, dwFilter, dwMipFilter, ColorKey, pSrcInfo, pPalette, 
        ppTexture);
}

#if 0
HRESULT WINAPI
    D3DXCreateTextureFromFileExW(
        LPDIRECT3DDEVICE8     pDevice,
        LPCWSTR               pSrcFile,
        UINT                  cpWidth,
        UINT                  cpHeight,
        UINT                  cMipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 dwFilter,
        DWORD                 dwMipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture)
{
    HRESULT hr;
    CD3DXFile fm;

    if(FAILED(hr = fm.Open(pSrcFile, TRUE)))
        return hr;

    return D3DXCreateTextureFromFileInMemoryEx(pDevice, fm.m_pvData,
        fm.m_cbData, cpWidth, cpHeight, cMipLevels, Usage, Format,
        Pool, dwFilter, dwMipFilter, ColorKey, pSrcInfo, pPalette, 
        ppTexture);
}
#endif
#if 0
HRESULT WINAPI
    D3DXCreateTextureFromResourceExA(
        LPDIRECT3DDEVICE8     pDevice,
        HMODULE               hSrcModule,
        LPCSTR                pSrcResource,
        UINT                  cpWidth,
        UINT                  cpHeight,
        UINT                  cMipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 dwFilter,
        DWORD                 dwMipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture)
{
    HRESULT hr;
    CD3DXResource res;

    if(FAILED(hr = res.Open(hSrcModule, pSrcResource, FALSE)))
        return hr;

    return D3DXCreateTextureFromFileInMemoryEx(pDevice, res.m_pvData,
        res.m_cbData, cpWidth, cpHeight, cMipLevels, Usage, Format,
        Pool, dwFilter, dwMipFilter, ColorKey, pSrcInfo, pPalette, 
        ppTexture);
}


HRESULT WINAPI
    D3DXCreateTextureFromResourceExW(
        LPDIRECT3DDEVICE8     pDevice,
        HMODULE               hSrcModule,
        LPCWSTR               pSrcResource,
        UINT                  cpWidth,
        UINT                  cpHeight,
        UINT                  cMipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 dwFilter,
        DWORD                 dwMipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture)
{
    HRESULT hr;
    CD3DXResource res;

    if(FAILED(hr = res.Open(hSrcModule, pSrcResource, TRUE)))
        return hr;

    return D3DXCreateTextureFromFileInMemoryEx(pDevice, res.m_pvData,
        res.m_cbData, cpWidth, cpHeight, cMipLevels, Usage, Format,
        Pool, dwFilter, dwMipFilter, ColorKey, pSrcInfo, pPalette, 
        ppTexture);
}
#endif

HRESULT WINAPI
    D3DXCreateTextureFromFileInMemory(
        LPDIRECT3DDEVICE8     pDevice,
        LPCVOID               pvSrcData,
        UINT                  cbSrcData,
        LPDIRECT3DTEXTURE8*   ppTexture)
{
    return D3DXCreateTextureFromFileInMemoryEx(pDevice, pvSrcData, cbSrcData,
        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN,
        D3DPOOL_MANAGED, D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppTexture);
}


HRESULT WINAPI
    D3DXCreateTextureFromFileInMemoryEx(
        LPDIRECT3DDEVICE8     pDevice,
        LPCVOID               pvSrcData,
        UINT                  cbSrcData,
        UINT                  cpWidth,
        UINT                  cpHeight,
        UINT                  cMipLevels,
        DWORD                 Usage,
        D3DFORMAT             Format,
        D3DPOOL               Pool,
        DWORD                 dwFilter,
        DWORD                 dwMipFilter,
        D3DCOLOR              ColorKey,
        D3DXIMAGE_INFO*       pSrcInfo,
        PALETTEENTRY*         pPalette,
        LPDIRECT3DTEXTURE8*   ppTexture)
{
    HRESULT hr;
    UINT iLevel;
    CD3DXImage Image;
    CD3DXImage *pImage;
    UINT cImageLevels;
    PALETTEENTRY Palette[256];
    BOOL bUpdate;
    BOOL bCascade;

    LPDIRECT3DSURFACE8 pSrc        = NULL;
    LPDIRECT3DSURFACE8 pDest       = NULL;
    LPDIRECT3DTEXTURE8 pTexture    = NULL;
    LPDIRECT3DTEXTURE8 pTextureVid = NULL;
    LPDIRECT3DTEXTURE8 pTextureSys = NULL;



    // Validate args
    if(!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!pvSrcData)
    {
        DPF(0, "pvSrcData pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if (!cbSrcData)
    {
        DPF(0, "cbSrcData value is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!ppTexture)
    {
        DPF(0, "ppTexture pointer is invalid");
        return D3DERR_INVALIDCALL;
    }


    // Load file, and figure out how many mip-levels were loaded
    if(FAILED(hr = Image.Load(pvSrcData, cbSrcData, pSrcInfo)))
        return hr;

    cImageLevels = 1;
    pImage = Image.m_pMip;

    while(pImage)
    {
        cImageLevels++;
        pImage = pImage->m_pMip;
    }


    // Default values
    if(0 == cpWidth || D3DX_DEFAULT == cpWidth)
        cpWidth = Image.m_Rect.right;

    if(0 == cpHeight || D3DX_DEFAULT == cpHeight)
        cpHeight = Image.m_Rect.bottom;


    if(D3DFMT_UNKNOWN == Format)
    {
        if(ColorKey)
        {
            // If we are using colorkey, try to pick a format with alpha.
            switch(Image.m_Format)
            {
            case D3DFMT_R8G8B8:
            case D3DFMT_X8R8G8B8:
            case D3DFMT_R5G6B5:
                Format = D3DFMT_A8R8G8B8;
                break;

            case D3DFMT_X1R5G5B5:
#if 0
            case D3DFMT_R3G3B2:
            case D3DFMT_X4R4G4B4:
#endif
                Format = D3DFMT_A1R5G5B5;
                break;

            case D3DFMT_L8:
                Format = D3DFMT_A8L8;
                break;

            default:
                Format = Image.m_Format;
                break;
            }
        }
        else
        {
            // Avoid strange things, like 24 bit formats
            Format = (D3DFMT_R8G8B8 == Image.m_Format) ? D3DFMT_X8R8G8B8 : Image.m_Format;
        }
    }

    if(D3DX_DEFAULT == dwFilter)
    {
        if(IsUvl(Image.m_Format))
            dwFilter = D3DX_FILTER_POINT | D3DX_FILTER_DITHER;
        else
            dwFilter = D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER;
    }

    if(D3DX_DEFAULT == dwMipFilter)
    {
        if(IsUvl(Image.m_Format))
            dwMipFilter = D3DX_FILTER_POINT;
        else
            dwMipFilter = D3DX_FILTER_BOX;
    }

    bCascade = 
        ((dwFilter    & 0xff) == D3DX_FILTER_NONE)  ||
        ((dwMipFilter & 0xff) == D3DX_FILTER_POINT) || 
        ((dwMipFilter & 0xff) == D3DX_FILTER_BOX);


    // Compute palette
    if(Image.m_pPalette)
    {
        // Convert colorkey from ARGB to ABGR
        ColorKey = (ColorKey & 0xff00ff00) | ((ColorKey >> 16) & 0x000000ff) | ((ColorKey << 16) & 0x00ff0000);

        // Apply colorkey to palette.  This needs to be done here, since it might
        // influence how we choose image formats later.
        for(UINT i = 0; i < 256; i++)
        {
            if(*((DWORD*) &Image.m_pPalette[i]) == (DWORD) ColorKey)
                *((DWORD*) &Palette[i]) = 0;
            else
                *((DWORD*) &Palette[i]) = *((DWORD*) &Image.m_pPalette[i]);
        }

        ColorKey = 0;
    }
    else
    {
        // Image was not paletteized.. using opaque-white default palette
        memset(Palette, 0xff, 256 * sizeof(PALETTEENTRY));
    }

    if(pPalette)
    {
        // Copy palette into user's buffer
        memcpy(pPalette, Palette, 256 * sizeof(PALETTEENTRY));
    }
    else
    {
        // Since user did not provice us any memory to return a palette, we
        // need to depalattize the image.. but to what format?  Will try for
        // A8R8G8B8 if image contains alpha.  X8R8G8B8 if not.
#if 0
        if(D3DFMT_A8P8 == Format)
        {
            Format = D3DFMT_A8R8G8B8;
        }
        else 
#endif            
        if(D3DFMT_P8 == Format)
        {
            Format = D3DFMT_X8R8G8B8;

            for(UINT i = 0; i < 256; i++)
            {
                if(0xff != Image.m_pPalette[i].peFlags)
                {
                    Format = D3DFMT_A8R8G8B8;
                    break;
                }
            }
        }
    }



    // Create texture
    if(FAILED(hr = D3DXCheckTextureRequirements(pDevice, &cpWidth, &cpHeight,
        &cMipLevels, Usage, &Format, Pool)))
    {
        goto LDone;
    }

    if(FAILED(hr = pDevice->CreateTexture(cpWidth, cpHeight, cMipLevels,
        Usage, Format, Pool, &pTextureVid)))
    {
        DPF(0, "CreateTexture failed");
        goto LDone;
    }

    pTexture = pTextureVid;

#if 0
    // Create dummy system texture, if needed.
    bUpdate = (D3DPOOL_DEFAULT == Pool);

    if(bUpdate)
    {
        if(FAILED(hr = pDevice->CreateTexture(cpWidth, cpHeight, cMipLevels,
            0, Format, D3DPOOL_SYSTEMMEM, &pTextureSys)))
        {
            DPF(0, "CreateTexture failed");
            goto LDone;
        }

        pTexture = pTextureSys;
    }
#else
    bUpdate = FALSE;
#endif

    // Load image data
    iLevel = 0;
    pImage = &Image;

    while((iLevel < cImageLevels) && (iLevel < cMipLevels))
    {
        if(FAILED(hr = pTexture->GetSurfaceLevel(iLevel, &pDest)))
            goto LDone;

        hr = D3DXLoadSurfaceFromMemory(pDest, pPalette, NULL,
            pImage->m_pvData, pImage->m_Format, pImage->m_cbPitch, Palette,
            &pImage->m_Rect, dwFilter, ColorKey);

        RELEASE(pDest);

        if(FAILED(hr))
            goto LDone;

        iLevel++;

        if(iLevel < cImageLevels)
            pImage = pImage->m_pMip;
    }


    // Filter mipmaps
    if(!bCascade)
    {
        while(iLevel < cMipLevels)
        {
            if(FAILED(hr = pTexture->GetSurfaceLevel(iLevel, &pDest)))
                goto LDone;

            hr = D3DXLoadSurfaceFromMemory(pDest, pPalette, NULL,
                pImage->m_pvData, pImage->m_Format, pImage->m_cbPitch, Palette,
                &pImage->m_Rect, dwMipFilter, ColorKey);

            RELEASE(pDest);

            if(FAILED(hr))
                goto LDone;

            iLevel++;
        }
    }
    else 
    {
        if(cImageLevels < cMipLevels)
        {
            if(FAILED(hr = D3DXFilterTexture(pTexture, Palette, cImageLevels - 1, dwMipFilter)))
                goto LDone;
        }
    }


    // Update or Copy result to texture, if needed
#if 0
    if(bUpdate)
    {
        if(FAILED(hr = pDevice->UpdateTexture(pTextureSys, pTextureVid)))
            goto LDone;
    }
#endif

    *ppTexture = pTextureVid;
    pTextureVid = NULL;

    hr = S_OK;
    goto LDone;

LDone:
    RELEASE(pDest);
    RELEASE(pSrc);
    RELEASE(pTextureVid);
    RELEASE(pTextureSys);
    return hr;
}


HRESULT WINAPI
    D3DXFilterTexture(
        LPDIRECT3DTEXTURE8    pTexture,
        CONST PALETTEENTRY*   pPalette,
        UINT                  uSrcLevel,
        DWORD                 dwFilter)
{
    HRESULT hr;

    // Validate arguments
    if(!pTexture)
    {
        DPF(0, "pTexture pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(D3DX_DEFAULT == dwFilter)
    {
        D3DSURFACE_DESC desc;
        pTexture->GetLevelDesc(0, &desc);

        if(IsUvl(desc.Format))
            dwFilter = D3DX_FILTER_POINT;
        else
            dwFilter = D3DX_FILTER_BOX;
    }

    UINT uMipLevel;
    UINT cMipLevels = pTexture->GetLevelCount();

    if(D3DX_DEFAULT == uSrcLevel)
        uSrcLevel = 0;

    if(uSrcLevel >= cMipLevels)
    {
        DPF(0, "uSrcLevel larger than num Mip level in the texture");
        return D3DERR_INVALIDCALL;
    }


    // For each level, filter it down
    LPDIRECT3DSURFACE8 pSrc  = NULL;
    LPDIRECT3DSURFACE8 pDest = NULL;

    BOOL bCascade = ((dwFilter & 0xff) == D3DX_FILTER_POINT) ||
                    ((dwFilter & 0xff) == D3DX_FILTER_BOX);

    if(FAILED(hr = pTexture->GetSurfaceLevel(uSrcLevel, &pSrc)))
        goto LDone;

    for(uMipLevel = uSrcLevel + 1; uMipLevel < cMipLevels; uMipLevel++)
    {
        if(FAILED(hr = pTexture->GetSurfaceLevel(uMipLevel, &pDest)))
            goto LDone;

        if(FAILED(hr = D3DXLoadSurfaceFromSurface(pDest,
            pPalette, NULL, pSrc, pPalette, NULL, dwFilter, 0)))
        {
            goto LDone;
        }


        if(bCascade)
        {
            RELEASE(pSrc);

            pSrc  = pDest;
            pDest = NULL;
        }
        else
        {
            RELEASE(pDest);
        }
    }

    hr = S_OK;
    goto LDone;

LDone:
    RELEASE(pSrc);
    RELEASE(pDest);

    return hr;
}



///////////////////////////////////////////////////////////////////////////
// CubeTexture APIs ///////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
    D3DXCheckCubeTextureRequirements(
        LPDIRECT3DDEVICE8       pDevice,
        UINT*                   pSize,
        UINT*                   pNumMipLevels,
        DWORD                   Usage,
        D3DFORMAT*              pFormat,
        D3DPOOL                 Pool)
{
    return CheckTextureRequirements(pDevice, pSize, pSize, NULL,
        pNumMipLevels, Usage, pFormat, Pool, 1);
}


HRESULT WINAPI
    D3DXCreateCubeTexture(
        LPDIRECT3DDEVICE8       pDevice,
        UINT                    cpSize,
        UINT                    cMipLevels,
        DWORD                   Usage,
        D3DFORMAT               Format,
        D3DPOOL                 Pool,
        LPDIRECT3DCUBETEXTURE8* ppCubeTexture)
{
    HRESULT hr;

    // Validate arguments
    if(!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!ppCubeTexture)
    {
        DPF(0, "ppCubeTexture pointer is invalid");
        return D3DERR_INVALIDCALL;
    }

    if(D3DX_DEFAULT == Usage)
        Usage = 0;

    // Check cube texture requirements
    if(FAILED(hr = D3DXCheckCubeTextureRequirements(pDevice, &cpSize,
        &cMipLevels, Usage, &Format, Pool)))
    {
        return hr;
    }

    // Create cube texture
    if(FAILED(hr = pDevice->CreateCubeTexture(cpSize, cMipLevels,
        Usage, Format, Pool, ppCubeTexture)))
    {
        DPF(0, "CreateCubeTexture failed");
        return hr;
    }

    return S_OK;
}


HRESULT WINAPI
    D3DXCreateCubeTextureFromFileA(
        LPDIRECT3DDEVICE8       pDevice,
        LPCSTR                  pSrcFile,
        LPDIRECT3DCUBETEXTURE8* ppCubeTexture)
{
    return D3DXCreateCubeTextureFromFileExA(pDevice, pSrcFile, D3DX_DEFAULT,
        D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT,
        D3DX_DEFAULT, 0, NULL, NULL, ppCubeTexture);
}

#if 0
HRESULT WINAPI
    D3DXCreateCubeTextureFromFileW(
        LPDIRECT3DDEVICE8       pDevice,
        LPCWSTR                 pSrcFile,
        LPDIRECT3DCUBETEXTURE8* ppCubeTexture)
{
    return D3DXCreateCubeTextureFromFileExW(pDevice, pSrcFile, D3DX_DEFAULT,
        D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED, D3DX_DEFAULT,
        D3DX_DEFAULT, 0, NULL, NULL, ppCubeTexture);
}
#endif

HRESULT WINAPI
    D3DXCreateCubeTextureFromFileExA(
        LPDIRECT3DDEVICE8       pDevice,
        LPCSTR                  pSrcFile,
        UINT                    cpSize,
        UINT                    cMipLevels,
        DWORD                   Usage,
        D3DFORMAT               Format,
        D3DPOOL                 Pool,
        DWORD                   dwFilter,
        DWORD                   dwMipFilter,
        D3DCOLOR                ColorKey,
        D3DXIMAGE_INFO*         pSrcInfo,
        PALETTEENTRY*           pPalette,
        LPDIRECT3DCUBETEXTURE8* ppCubeTexture)
{
    HRESULT hr;
    CD3DXFile fm;

    if(FAILED(hr = fm.Open(pSrcFile, FALSE)))
        return hr;

    return D3DXCreateCubeTextureFromFileInMemoryEx(pDevice, fm.m_pvData,
        fm.m_cbData, cpSize, cMipLevels, Usage, Format, Pool, dwFilter,
        dwMipFilter, ColorKey, pSrcInfo, pPalette, ppCubeTexture);
}

#if 0
HRESULT WINAPI
    D3DXCreateCubeTextureFromFileExW(
        LPDIRECT3DDEVICE8       pDevice,
        LPCWSTR                 pSrcFile,
        UINT                    cpSize,
        UINT                    cMipLevels,
        DWORD                   Usage,
        D3DFORMAT               Format,
        D3DPOOL                 Pool,
        DWORD                   dwFilter,
        DWORD                   dwMipFilter,
        D3DCOLOR                ColorKey,
        D3DXIMAGE_INFO*         pSrcInfo,
        PALETTEENTRY*           pPalette,
        LPDIRECT3DCUBETEXTURE8* ppCubeTexture)
{
    HRESULT hr;
    CD3DXFile fm;

    if(FAILED(hr = fm.Open(pSrcFile, TRUE)))
        return hr;

    return D3DXCreateCubeTextureFromFileInMemoryEx(pDevice, fm.m_pvData,
        fm.m_cbData, cpSize, cMipLevels, Usage, Format,
        Pool, dwFilter, dwMipFilter, ColorKey, pSrcInfo, pPalette, 
        ppCubeTexture);
}
#endif

HRESULT WINAPI
    D3DXCreateCubeTextureFromFileInMemory(
        LPDIRECT3DDEVICE8       pDevice,
        LPCVOID                 pvSrcData,
        UINT                    cbSrcData,
        LPDIRECT3DCUBETEXTURE8* ppCubeTexture)
{
    return D3DXCreateCubeTextureFromFileInMemoryEx(pDevice, pvSrcData, cbSrcData,
        D3DX_DEFAULT, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED,
        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, ppCubeTexture);
}


HRESULT WINAPI
    D3DXCreateCubeTextureFromFileInMemoryEx(
        LPDIRECT3DDEVICE8       pDevice,
        LPCVOID                 pvSrcData,
        UINT                    cbSrcData,
        UINT                    cpSize,
        UINT                    cMipLevels,
        DWORD                   Usage,
        D3DFORMAT               Format,
        D3DPOOL                 Pool,
        DWORD                   dwFilter,
        DWORD                   dwMipFilter,
        D3DCOLOR                ColorKey,
        D3DXIMAGE_INFO*         pSrcInfo,
        PALETTEENTRY*           pPalette,
        LPDIRECT3DCUBETEXTURE8* ppCubeTexture)
{
    HRESULT hr;
    UINT iLevel;
    UINT iFace;
    CD3DXImage Image;
    CD3DXImage *pImage;
    CD3DXImage *pImageFace;
    UINT cImageFaces;
    UINT cImageLevels;
    PALETTEENTRY Palette[256];
    BOOL bUpdate;
    BOOL bCascade;

    LPDIRECT3DSURFACE8 pSrc  = NULL;
    LPDIRECT3DSURFACE8 pDest = NULL;
    LPDIRECT3DCUBETEXTURE8 pCubeTexture    = NULL;
    LPDIRECT3DCUBETEXTURE8 pCubeTextureVid = NULL;
    LPDIRECT3DCUBETEXTURE8 pCubeTextureSys = NULL;



    // Validate args
    if(!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!pvSrcData)
    {
        DPF(0, "pvSrcData pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if (!cbSrcData)
    {
        DPF(0, "cbSrcData value is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!ppCubeTexture)
    {
        DPF(0, "ppCubeTexture pointer is invalid");
        return D3DERR_INVALIDCALL;
    }


    // Load file, and figure out how many faces and mip-levels were loaded
    if(FAILED(hr = Image.Load(pvSrcData, cbSrcData, pSrcInfo)))
        return hr;

    cImageFaces = 1;
    pImage = Image.m_pFace;

    while(pImage)
    {
        cImageFaces++;
        pImage = pImage->m_pFace;
    }

    if(cImageFaces != 6)
    {
        DPF(0, "File does not contain a cube texture");
        return E_FAIL;
    }

    cImageLevels = 1;
    pImage = Image.m_pMip;

    while(pImage)
    {
        cImageLevels++;
        pImage = pImage->m_pMip;
    }


    // Default values
    if(0 == cpSize || D3DX_DEFAULT == cpSize)
        cpSize = Image.m_Rect.right > Image.m_Rect.bottom ? Image.m_Rect.right : Image.m_Rect.bottom;

    if(D3DX_DEFAULT == dwFilter)
    {
        if(IsUvl(Image.m_Format))
            dwFilter = D3DX_FILTER_POINT | D3DX_FILTER_DITHER;
        else
            dwFilter = D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER;
    }

    if(D3DX_DEFAULT == dwMipFilter)
    {
        if(IsUvl(Image.m_Format))
            dwMipFilter = D3DX_FILTER_POINT;
        else
            dwMipFilter = D3DX_FILTER_BOX;
    }

    dwFilter |= D3DX_FILTER_MIRROR;
    dwMipFilter |= D3DX_FILTER_MIRROR;

    bCascade = 
        ((dwFilter    & 0xff) == D3DX_FILTER_NONE)  ||
        ((dwMipFilter & 0xff) == D3DX_FILTER_POINT) || 
        ((dwMipFilter & 0xff) == D3DX_FILTER_BOX);



    if(D3DFMT_UNKNOWN == Format)
    {
        if(ColorKey)
        {
            // If we are using colorkey, try to pick a format with alpha.
            switch(Image.m_Format)
            {
#if 0
            case D3DFMT_R8G8B8:
#endif
            case D3DFMT_X8R8G8B8:
            case D3DFMT_R5G6B5:
                Format = D3DFMT_A8R8G8B8;
                break;

            case D3DFMT_X1R5G5B5:
#if 0
            case D3DFMT_R3G3B2:
            case D3DFMT_X4R4G4B4:
#endif
                Format = D3DFMT_A1R5G5B5;
                break;

            case D3DFMT_L8:
                Format = D3DFMT_A8L8;
                break;

            default:
                Format = Image.m_Format;
                break;
            }
        }
        else
        {
            // Avoid strange things, like 24 bit formats
#if 0
            Format = (D3DFMT_R8G8B8 == Image.m_Format) ? D3DFMT_X8R8G8B8 : Image.m_Format;
#else
            Format = Image.m_Format;
#endif
        }
    }


    // Compute palette
    if(Image.m_pPalette)
    {
        // Convert colorkey from ARGB to ABGR
        ColorKey = (ColorKey & 0xff00ff00) | ((ColorKey >> 16) & 0x000000ff) | ((ColorKey << 16) & 0x00ff0000);

        // Apply colorkey to palette.  This needs to be done here, since it might
        // influence how we choose image formats later.
        for(UINT i = 0; i < 256; i++)
        {
            if(*((DWORD*) &Image.m_pPalette[i]) == (DWORD) ColorKey)
                *((DWORD*) &Palette[i]) = 0;
            else
                *((DWORD*) &Palette[i]) = *((DWORD*) &Image.m_pPalette[i]);
        }

        ColorKey = 0;
    }
    else
    {
        // Image was not paletteized.. using opaque-white default palette
        memset(Palette, 0xff, 256 * sizeof(PALETTEENTRY));
    }

    if(pPalette)
    {
        // Copy palette into user's buffer
        memcpy(pPalette, Palette, 256 * sizeof(PALETTEENTRY));
    }
    else
    {
        // Since user did not provice us any memory to return a palette, we
        // need to depalattize the image.. but to what format?  Will try for
        // A8R8G8B8 if image contains alpha.  X8R8G8B8 if not.
#if 0
        if(D3DFMT_A8P8 == Format)
        {
            Format = D3DFMT_A8R8G8B8;
        }
        else
#endif            
        if(D3DFMT_P8 == Format)
        {
            Format = D3DFMT_X8R8G8B8;

            for(UINT i = 0; i < 256; i++)
            {
                if(0xff != Image.m_pPalette[i].peFlags)
                {
                    Format = D3DFMT_A8R8G8B8;
                    break;
                }
            }
        }
    }



    // Create texture
    if(FAILED(hr = D3DXCheckCubeTextureRequirements(pDevice, &cpSize,
        &cMipLevels, Usage, &Format, Pool)))
    {
        goto LDone;
    }

    if(FAILED(hr = pDevice->CreateCubeTexture(cpSize, cMipLevels,
        Usage, Format, Pool, &pCubeTextureVid)))
    {
        DPF(0, "CreateCubeTexture failed");
        goto LDone;
    }

    pCubeTexture = pCubeTextureVid;

#if 0
    // Create dummy system texture, if needed.
    bUpdate = (D3DPOOL_DEFAULT == Pool);

    if(bUpdate)
    {
        if(FAILED(hr = pDevice->CreateCubeTexture(cpSize, cMipLevels,
            0, Format, D3DPOOL_SYSTEMMEM, &pCubeTextureSys)))
        {
            DPF(0, "CreateCubeTexture failed");
            goto LDone;
        }

        pCubeTexture = pCubeTextureSys;
    }
#else
    bUpdate = FALSE;
#endif

    // Load image data
    pImageFace = &Image;

    for(iFace = 0; iFace < 6; iFace++)
    {
        iLevel = 0;
        pImage = pImageFace;

        while((iLevel < cImageLevels) && (iLevel < cMipLevels))
        {
            if(FAILED(hr = pCubeTexture->GetCubeMapSurface((D3DCUBEMAP_FACES) iFace, iLevel, &pDest)))
                goto LDone;

            if(FAILED(hr = D3DXLoadSurfaceFromMemory(pDest, pPalette, NULL,
                pImage->m_pvData, pImage->m_Format, pImage->m_cbPitch, Palette,
                &pImage->m_Rect, dwFilter, ColorKey)))
            {
                goto LDone;
            }

            RELEASE(pDest);

            iLevel++;

            if(iLevel < cImageLevels)
                pImage = pImage->m_pMip;
        }

        // Filter non-cascaded mipmaps
        if(!bCascade)
        {
            while(iLevel < cMipLevels)
            {
                if(FAILED(hr = pCubeTexture->GetCubeMapSurface((D3DCUBEMAP_FACES) iFace, iLevel, &pDest)))
                    goto LDone;

                if(FAILED(hr = D3DXLoadSurfaceFromMemory(pDest, pPalette, NULL,
                    pImage->m_pvData, pImage->m_Format, pImage->m_cbPitch, Palette,
                    &pImage->m_Rect, dwMipFilter, ColorKey)))
                {
                    goto LDone;
                }

                RELEASE(pDest);
                iLevel++;
            }
        }

        pImageFace = pImageFace->m_pFace;
    }


    // Filter cascaded mipmaps
    if(bCascade && (cImageLevels < cMipLevels))
    {
        if(FAILED(hr = D3DXFilterCubeTexture(pCubeTexture, Palette, cImageLevels - 1, dwMipFilter)))
            goto LDone;
    }


    // Update or Copy result to texture, if needed
#if 0
    if(bUpdate)
    {
        if(FAILED(hr = pDevice->UpdateTexture(pCubeTextureSys, pCubeTextureVid)))
            goto LDone;
    }
#endif

    *ppCubeTexture = pCubeTextureVid;
    pCubeTextureVid = NULL;

    hr = S_OK;
    goto LDone;

LDone:
    RELEASE(pDest);
    RELEASE(pSrc);
    RELEASE(pCubeTextureVid);
    RELEASE(pCubeTextureSys);
    return hr;
}


HRESULT WINAPI
    D3DXFilterCubeTexture(
        LPDIRECT3DCUBETEXTURE8  pCubeTexture,
        CONST PALETTEENTRY*     pPalette,
        UINT                    uSrcLevel,
        DWORD                   dwFilter)
{
    HRESULT hr;

    // Validate arguments
    if(!pCubeTexture)
    {
        DPF(0, "pCubeTexture pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(D3DX_DEFAULT == dwFilter)
    {
        D3DSURFACE_DESC desc;
        pCubeTexture->GetLevelDesc(0, &desc);

        if(IsUvl(desc.Format))
            dwFilter = D3DX_FILTER_POINT;
        else
            dwFilter = D3DX_FILTER_BOX;
    }

    dwFilter |= D3DX_FILTER_MIRROR;

    UINT iMipLevel;
    UINT cMipLevels = pCubeTexture->GetLevelCount();

    if(D3DX_DEFAULT == uSrcLevel)
        uSrcLevel = 0;

    if(uSrcLevel >= cMipLevels)
    {
        DPF(0, "uSrcLevel larger than num Mip level in the texture");
        return D3DERR_INVALIDCALL;
    }



    // For each level, filter it down
    LPDIRECT3DSURFACE8 pSrc  = NULL;
    LPDIRECT3DSURFACE8 pDest = NULL;

    BOOL bCascade = ((dwFilter & 0xff) == D3DX_FILTER_POINT) ||
                    ((dwFilter & 0xff) == D3DX_FILTER_BOX);


    for(UINT iFace = 0; iFace < 6; iFace++)
    {
        if(FAILED(hr = pCubeTexture->GetCubeMapSurface(
            (D3DCUBEMAP_FACES) iFace, uSrcLevel, &pSrc)))
        {
            goto LDone;
        }

        for(iMipLevel = uSrcLevel + 1; iMipLevel < cMipLevels; iMipLevel++)
        {
            if(FAILED(hr = pCubeTexture->GetCubeMapSurface(
                (D3DCUBEMAP_FACES) iFace, iMipLevel, &pDest)))
            {
                goto LDone;
            }

            if(FAILED(hr = D3DXLoadSurfaceFromSurface(pDest,
                pPalette, NULL, pSrc, pPalette, NULL, dwFilter, 0)))
            {
                goto LDone;
            }


            if(bCascade)
            {
                RELEASE(pSrc);

                pSrc  = pDest;
                pDest = NULL;
            }
            else
            {
                RELEASE(pDest);
            }
        }

        RELEASE(pSrc);
    }

    hr = S_OK;
    goto LDone;

LDone:
    RELEASE(pSrc);
    RELEASE(pDest);

    return hr;
}


///////////////////////////////////////////////////////////////////////////
// VolumeTexture APIs /////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

HRESULT WINAPI
    D3DXCheckVolumeTextureRequirements(
        LPDIRECT3DDEVICE8     pDevice,
        UINT*                 pWidth,
        UINT*                 pHeight,
        UINT*                 pDepth,
        UINT*                 pNumMipLevels,
        DWORD                 Usage,
        D3DFORMAT*            pFormat,
        D3DPOOL               Pool)
{
    return CheckTextureRequirements(pDevice, pWidth, pHeight, pDepth,
        pNumMipLevels, Usage, pFormat, Pool, 2);
}


HRESULT WINAPI
    D3DXCreateVolumeTexture(
        LPDIRECT3DDEVICE8         pDevice,
        UINT                      cpWidth,
        UINT                      cpHeight,
        UINT                      cpDepth,
        UINT                      cMipLevels,
        DWORD                     Usage,
        D3DFORMAT                 Format,
        D3DPOOL                   Pool,
       LPDIRECT3DVOLUMETEXTURE8*  ppVolumeTexture)
{
    HRESULT hr;

    // Validate arguments
    if(!pDevice)
    {
        DPF(0, "pDevice pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(!ppVolumeTexture)
    {
        DPF(0, "ppVolumeTexture pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(D3DX_DEFAULT == Usage)
        Usage = 0;

    // Check volume texture requirements
    if(FAILED(hr = D3DXCheckVolumeTextureRequirements(pDevice, &cpWidth,
        &cpHeight, &cpDepth, &cMipLevels, Usage, &Format, Pool)))
    {
        return hr;
    }

    // Create volume texture
    if(FAILED(hr = pDevice->CreateVolumeTexture(cpWidth, cpHeight, cpDepth,
        cMipLevels, Usage, Format, Pool, ppVolumeTexture)))
    {
        DPF(0, "CreateVolumeTexture failed");
        return hr;
    }

    return S_OK;
}


HRESULT WINAPI
    D3DXFilterVolumeTexture(
        LPDIRECT3DVOLUMETEXTURE8  pVolumeTexture,
        CONST PALETTEENTRY*       pPalette,
        UINT                      uSrcLevel,
        DWORD                     dwFilter)
{
    HRESULT hr;

    // Validate arguments
    if(!pVolumeTexture)
    {
        DPF(0, "pVolumeTexture pointer is invalid");
        return D3DERR_INVALIDCALL;
    }
    if(D3DX_DEFAULT == dwFilter)
    {
        D3DVOLUME_DESC desc;
        pVolumeTexture->GetLevelDesc(0, &desc);

        if(IsUvl(desc.Format))
            dwFilter = D3DX_FILTER_POINT;
        else
            dwFilter = D3DX_FILTER_BOX;
    }


    UINT iMipLevel;
    UINT cMipLevels = pVolumeTexture->GetLevelCount();

    if(D3DX_DEFAULT == uSrcLevel)
        uSrcLevel = 0;

    if(uSrcLevel >= cMipLevels)
    {
        DPF(0, "uSrcLevel larger than num Mip level in the volume");
        return D3DERR_INVALIDCALL;
    }


    // For each level, filter it down
    LPDIRECT3DVOLUME8 pSrc  = NULL;
    LPDIRECT3DVOLUME8 pDest = NULL;

    BOOL bCascade = ((dwFilter & 0xff) == D3DX_FILTER_POINT) ||
                    ((dwFilter & 0xff) == D3DX_FILTER_BOX);


    if(FAILED(hr = pVolumeTexture->GetVolumeLevel(uSrcLevel, &pSrc)))
        goto LDone;

    for(iMipLevel = uSrcLevel + 1; iMipLevel < cMipLevels; iMipLevel++)
    {
        if(FAILED(hr = pVolumeTexture->GetVolumeLevel(iMipLevel, &pDest)))
            goto LDone;

        if(FAILED(hr = D3DXLoadVolumeFromVolume(pDest,
            pPalette, NULL, pSrc, pPalette, NULL, dwFilter, 0)))
        {
            goto LDone;
        }


        if(bCascade)
        {
            RELEASE(pSrc);

            pSrc  = pDest;
            pDest = NULL;
        }
        else
        {
            RELEASE(pDest);
        }
    }

    RELEASE(pSrc);

    hr = S_OK;
    goto LDone;

LDone:
    RELEASE(pSrc);
    RELEASE(pDest);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\nfmcomp.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1993,1994,1996
 *  All Rights Reserved.
 *
 *  NFMCOMP.H -- definitions for NFMCOMP.C
 *
 *  History:
 *      13-Feb-1994     msliger     revised type names, ie, UINT16 -> UINT.
 *                                  normalized MCI_MEMORY type.
 *      23-Feb-1994     msliger     changed how LGM defines work
 *      24-Feb-1994     msliger     Changed MCI_MEMORY to MI_MEMORY.
 *      15-Mar-1994     msliger     Changes for 32 bits.
 *      22-Mar-1994     msliger     Changed !INT32 to BIT16.
 *                                  Changed interface USHORT -> UINT.
 *      12-May-1994     msliger     ifdef'd 1's complement LARGE_STORED_BLOCKS.
 *      26-Sep-1994     msliger     Changed pcbResult to a FAR pointer.
 *      12-Jun-1995     msliger     Found cases to increase MAX_GROWTH.
 *      10-Sep-1996     jhiggins    Added support for multiple contexts.
 */

#ifndef NO_LGM
#define LGM
#endif

/* --- types -------------------------------------------------------------- */

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif

#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef unsigned char  BYTE;
#endif

#ifndef _UINT_DEFINED
#define _UINT_DEFINED
typedef unsigned int UINT;
#endif

#ifndef _ULONG_DEFINED
#define _ULONG_DEFINED
typedef unsigned long  ULONG;
#endif

#ifndef FAR
#ifdef BIT16
#define FAR far
#else
#define FAR
#endif
#endif

#ifndef HUGE
#ifdef BIT16
#define HUGE huge
#else
#define HUGE
#endif
#endif

#ifndef _MI_MEMORY_DEFINED
#define _MI_MEMORY_DEFINED
typedef void HUGE *  MI_MEMORY;
#endif


/***    PFNALLOC - Memory allocation function for MCI
 *
 *  Entry:
 *      cb - Size in bytes of memory block to allocate
 *
 *  Exit-Success:
 *      Returns !NULL pointer to memory block
 *
 *  Exit-Failure:
 *      Returns NULL; insufficient memory
 */
#ifndef _PFNALLOC_DEFINED
#define _PFNALLOC_DEFINED
typedef MI_MEMORY (__cdecl FAR DIAMONDAPI *PFNALLOC)(ULONG cb);       /* pfnma */
#endif


/***    PFNFREE - Free memory function for MCI
 *
 *  Entry:
 *      pv - Memory block allocated by matching PFNALLOC function
 *
 *  Exit:
 *      Memory block freed.
 */
#ifndef _PFNFREE_DEFINED
#define _PFNFREE_DEFINED
typedef void (__cdecl FAR DIAMONDAPI *PFNFREE)(MI_MEMORY pv);          /* pfnmf */
#endif

/* --- warnings ----------------------------------------------------------- */

/* ATTENTION   There is a known problem where the compressor may become unstable
 *          if cbDest is too small.  (last_lit will not be reset, amongst
 *          others.)  If the current block fails because it would exceed
 *          cbDest, additional blocks are likely to be mis-compresssed, and
 *          likely to fault in the compressor.
 */

/* --- prototypes --------------------------------------------------------- */

extern int NFMcompress_init(void FAR *ctx, MI_MEMORY buf1,MI_MEMORY buf2);

extern int NFMcompress(void FAR *ctx, BYTE FAR *bfSrc, UINT cbSrc,
        BYTE FAR *bfDest, UINT cbDest,
        MI_MEMORY bfWrk1, MI_MEMORY bfWrk2,
#ifdef LGM
        MI_MEMORY bfWrk3, MI_MEMORY bfWrk4,
#endif
        char fhistory, UINT FAR *pcbDestRet);

extern void FAR *NFMcomp_create(PFNALLOC NFMalloc);

extern void NFMcomp_destroy(void FAR *ctx, PFNFREE NFMfree);

/* --- constants ---------------------------------------------------------- */

/* return codes */

#define     NFMsuccess      0       /* successful completion */
#define     NFMdestsmall    1       /* destination buffer is too small */
#define     NFMoutofmem     2       /* alloc returned an error (NULL) */
#define     NFMinvalid      3       /* source buffer invalid for operation */


#ifdef LARGE_STORED_BLOCKS
#define     MAX_GROWTH      12      /* maximum growth of a block */
#else
#define     MAX_GROWTH      8       /* maximum growth of a block */
#endif

#define     LIT_BUFSIZE     0x8000  /* literal buffer */
#define     DIST_BUFSIZE    0x8000  /* distance buffer */

/* ------------------------------------------------------------------------ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\nfmcomp.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1992,1993,1994,1996
 *  Copyright (C) Jean-loup Gailly 1992,1993
 *  All Rights Reserved.
 *
 *  NFMCOMP.C -- memory-based compressor
 *
 *  History:
 *      13-Feb-1994     msliger     revised type names, ie, UINT16 -> UINT.
 *                                  normalized MCI_MEMORY type.
 *      23-Feb-1994     msliger     major scrub
 *      24-Feb-1994     msliger     Changed MCI_MEMORY to MI_MEMORY.
 *      17-Mar-1994     msliger     Updates for 32 bits.
 *      22-Mar-1994     msliger     Changed interface USHORT -> UINT.
 *      06-Apr-1994     msliger     Removed pack(1) for RISC; comp. bug avoided
 *      12-Apr-1994     msliger     Removed 1's complement from stored blocks.
 *      12-May-1994     msliger     ifdef'd 1's complement LARGE_STORED_BLOCKS.
 *      26-Sep-1994     msliger     Conserve DGROUP size in DRVSPACE app:
 *                                  Every pointer now explicitly FAR, and if
 *                                  compiled with -DDRVSPACE, larger private
 *                                  objects are created in far segments.
 *      29-Sep-1994     msliger     Eliminated NFM_SIG from DRVSPACE use;
 *                                  DRVSPACE has it's own signature.  Cleaned
 *                                  up function declarations, trying to avoid
 *                                  "internal compiler errors".
 *      16-Apr-1996     msliger     Endian-independent block signature.
 *      10-Sep-1996     jhiggins    Added support for multiple contexts.
 *      18-Feb-1997     msliger     Eliminated use of setjmp/longjmp.
 *      22-Mar-1997     msliger     Limit chain length in NO_LAZY (fast) build.
 */

/* ATTENTION 07-Nov-1996 msliger NFMCOMP uses a number of buffers, some of which
 *          are 64k.  Internally, NFMCOMP treats these as FAR allocations,
 *          not HUGE, and thus will overwrite unallocated memory if these
 *          allocations do not have small offsets.  For example, enabling
 *          MEMCHK in ENCODE.C causes allocations to be grown by 16 bytes,
 *          and the buffers typically have addresses of the form xxxx:0010.
 *          These buffers will have xxxx:0000 through xxxx:000F overwritten.
 *          Such buffer allocations have also been seen to have a slight
 *          adverse effect on compression quality.  Thus, allocations should
 *          have offsets <= 10000h-allocationSize.
 *          This problem is unique to 16-bit compilations of the NFMcomp code,
 *          and does not apply to NFMdeco or 32-bit compilations.
 *          (This code has behaved this way since The Beginning.)
 */

/* --- compilation options ------------------------------------------------ */

/*  LGM     Don't using hashing search. */

/* --- commentary --------------------------------------------------------- */

/*
    The "deflation" process depends on being able to identify portions
    of the input text which are identical to earlier input (within a
    sliding window trailing behind the input currently being processed).

    The most straightforward technique turns out to be the fastest for
    most input files: try all possible matches and select the longest.
    The key feature of this algorithm is that insertions into the string
    dictionary are very simple and thus fast, and deletions are avoided
    completely. Insertions are performed at each input character, whereas
    string matches are performed only when the previous match ends. So it
    is preferable to spend more time in matches to allow very fast string
    insertions and avoid deletions. The matching algorithm for small
    strings is inspired from that of Rabin & Karp. A brute force approach
    is used to find longer strings when a small match has been found.
    A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
    (by Leonid Broukhis).

    A previous version of this file used a more sophisticated algorithm
    (by Fiala and Greene) which is guaranteed to run in linear amortized
    time, but has a larger average cost, uses more memory and is patented.
    However the F&G algorithm may be faster for some highly redundant
    files if the parameter max_chain_length (described below) is too large.
*/

/* --- preprocessor ------------------------------------------------------- */
#include <d3dx8seg.h>
#include <stdio.h>
#include <string.h>     /* for memcpy() */

#include "nfmcomp.h"

#pragma warning(disable:4001)           /* no single-line comment balking */

#ifndef _USHORT_DEFINED
#define _USHORT_DEFINED
typedef unsigned short USHORT;
#endif

/* --- compression-related definitions ------------------------------------ */

#define NFM_SIG0    'C'     /* signature in a block = "CK" */
#define NFM_SIG1    'K'
#define NFM_SIG_LEN 2

#ifndef WSIZE
#define WSIZE 0x8000        /* window size--must be a power of two, and */
#endif                      /*  at least 32K for zip's deflate method */

/* Tail of hash chains */
#define NIL 0

#ifdef LGM

/* we're not hashing here, but we'll use these same defines so we don't */
/* have to rewrite the entire program.                                  */

#define HASH_BITS 16    /* the two bytes */
#define HASH_SIZE 256   /* table size for one-byte match heads */

#else /* ifndef LGM: */

#define HASH_BITS  15                       /* hash index size in bits */
#define HASH_SIZE (USHORT)(1 << HASH_BITS)  /* # entries in hash table */
#define HASH_MASK (HASH_SIZE-1)             /* mask for indexing hash */

#endif /* LGM */

#define WMASK     (WSIZE-1)                 /* mask for indexing window */

/* The minimum and maximum match lengths */
#define MIN_MATCH  3
#define MAX_MATCH  258

/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
 * It is easy to get rid of this optimization if necessary.
 */

#if (HASH_BITS < 8) || (MAX_MATCH != 258)
    error: Code too clever
#endif

/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
#define TOO_FAR 4096

#ifdef LGM
#define REAL_MIN 2
#else
#define REAL_MIN (MIN_MATCH)
#endif

/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */
#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)

/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */
#define MAX_DIST  (WSIZE-MIN_LOOKAHEAD)

/* All codes must not exceed MAX_BITS bits */
#define MAX_BITS 15

/* Bit length codes must not exceed MAX_BL_BITS bits */
#define MAX_BL_BITS 7

/* number of length codes, not counting the special END_BLOCK code */
#define LENGTH_CODES 29

/* number of literal bytes 0..255 */
#define LITERALS  256

/* end of block literal code */
#define END_BLOCK 256

/* number of Literal or Length codes, including the END_BLOCK code */
#define L_CODES (LITERALS+1+LENGTH_CODES)

/* number of distance codes */
#define D_CODES   30

/* number of codes used to transfer the bit lengths */
#define BL_CODES  19

/* --- compressor definitions --------------------------------------------- */

#define put_byte(context,c)                                             \
{                                                                       \
    if (context->outcnt >= context->outsize)                            \
    {                                                                   \
        context->fError = 1;                                            \
    }                                                                   \
    else                                                                \
    {                                                                   \
        context->outbuf[context->outcnt++] = (BYTE) (c);                \
    }                                                                   \
}

/* Output a 16 bit value, lsb first */
#define put_short(context,w)                                            \
{                                                                       \
    if (context->outcnt < context->outsize-2)                           \
    {                                                                   \
        context->outbuf[context->outcnt++] = (BYTE) ((w) & 0xff);       \
        context->outbuf[context->outcnt++] = (BYTE) ((USHORT)(w) >> 8); \
    }                                                                   \
    else                                                                \
    {                                                                   \
        put_byte(context,(BYTE) ((w) & 0xff));                          \
        put_byte(context,(BYTE) ((USHORT)(w) >> 8));                    \
    }                                                                   \
}

/*
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 * Since we go from 32768 to 65536, strstart wraps around,
 *   so have to check it if does
 */
#define FLUSH_BLOCK(context,eof)                                        \
    flush_block(context,                                                \
        (context->block_start >= 0L) ?                                  \
            (char FAR *) &context->window[(USHORT) context->block_start] \
        :                                                               \
            NULL,                                                       \
        (context->strstart == 0) ?                                      \
            (65536L - context->block_start)                             \
        :                                                               \
            (long) context->strstart - context->block_start,            \
        (eof)                                                           \
        )

/*
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */
#ifndef LGM
#define UPDATE_HASH(h,c) (h = (((h)<<H_SHIFT) ^ (c)) & HASH_MASK)
#endif

/*
 * Insert string s in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of s are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */
#ifdef LGM
#define INSERT_STRING(context, s, match_head)  ins_str(context,s,&match_head)
#else
#define INSERT_STRING(context, s, match_head)                       \
    (                                                               \
        UPDATE_HASH(context->ins_h,                                 \
            context->window[(s) + REAL_MIN - 1]),                   \
            *(context->prev + ((s) & WMASK)) = match_head =         \
                    *(context->head + context->ins_h),              \
            *(context->head + context->ins_h) = (s)                 \
    )
#endif

/* Diagnostic functions */
#ifdef DEBUG
#  define isgraph(c) (((c) < 0x20) || ((c) > 0x7F))
#  define Assert(context,cond,msg) {if(!(cond)) context->fError=1,printf(msg);}
#  define Trace(x) fprintf x
#  define Tracev(x) {if (context->verbose) fprintf x ;}
#  define Tracevv(x) {if (context->verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (context->verbose && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (context->verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(context,cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif

/* --- local data --------------------------------------------------------- */

/* Number of bits used within bi_buf. (bi_buf might be implemented on
 * more than 16 bits on some systems.)
 */
#define Buf_size (8 * 2*(int)sizeof(char))

/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */
typedef USHORT Pos;
typedef USHORT IPos;

#define window_size (2L * WSIZE)

/* Number of bits by which ins_h and del_h must be shifted at each
 * input step. It must be such that after MIN_MATCH steps, the oldest
 * byte no longer takes part in the hash key, that is:
 *   H_SHIFT * MIN_MATCH >= HASH_BITS
 */
#define H_SHIFT  ((HASH_BITS + MIN_MATCH - 1) / MIN_MATCH)

/* To speed up deflation, hash chains are never searched beyond this length.
 * A higher limit improves compression ratio but degrades the speed.
 */
#ifdef NO_LAZY
#define max_chain_length (32)
#else
#define max_chain_length (4096)
#endif

/* Attempt to find a better match only when the current match is strictly
 * smaller than this value.
 */
#define max_lazy_match (32)

/* Use a faster search when the previous match is longer than this */
#define good_match (258)

/* Stop searching when current match exceeds this: */
#define nice_match (258)

/* Note: the current code requires max_lazy >= MIN_MATCH and max_chain >= 4
 * but these restrictions can easily be removed at a small cost.
 */

/* result of memcmp for equal strings */
#define EQUAL 0

static const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};

static const int extra_dbits[D_CODES] /* extra bits for each distance code */
   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

static const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */
static const BYTE bl_order[BL_CODES]
   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};

/* The three kinds of block type */
#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2

/* comment about LIT_BUFSIZE and DIST_BUFSIZE */
/* Sizes of match buffers for literals/lengths and distances.  There are
 * 4 reasons for limiting LIT_BUFSIZE to 64K:
 *   - frequencies can be kept in 16 bit counters
 *   - if compression is not successful for the first block, all input data is
 *     still in the window so we can still emit a stored block even when input
 *     comes from standard input.  (This can also be done for all blocks if
 *     LIT_BUFSIZE is not greater than 32K.)
 *   - if compression is not successful for a file smaller than 64K, we can
 *     even emit a stored file instead of a stored block (saving 5 bytes).
 *   - creating new Huffman trees less frequently may not provide fast
 *     adaptation to changes in the input data statistics. (Take for
 *     example a binary file with poorly compressible code followed by
 *     a highly compressible string table.) Smaller buffer sizes give
 *     fast adaptation but have of course the overhead of transmitting trees
 *     more frequently.
 *   - I can't count above 4
 * The current code is general and allows DIST_BUFSIZE < LIT_BUFSIZE (to save
 * memory at the expense of compression). Some optimizations would be possible
 * if we rely on DIST_BUFSIZE == LIT_BUFSIZE.
 */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* Data structure describing a single value and its code string. */

typedef struct ct_data
{
    union
    {
        USHORT freq;       /* frequency count */
        USHORT code;       /* bit string */
    } fc;
    union
    {
        USHORT dad;        /* father node in Huffman tree */
        USHORT len;        /* length of bit string */
    } dl;
} ct_data;

#define Freq fc.freq
#define Code fc.code
#define Dad  dl.dad
#define Len  dl.len

/* maximum heap size */
#define HEAP_SIZE (2*L_CODES+1)

typedef struct tree_desc
{
    ct_data FAR *dyn_tree;         /* the dynamic tree */
    ct_data FAR *static_tree;      /* corresponding static tree or NULL */
    int     const FAR *extra_bits; /* extra bits for each code or NULL */
    int     extra_base;     /* base index for extra_bits */
    int     elems;          /* max number of elements in the tree */
    int     max_length;     /* max bit length for the codes */
    int     max_code;       /* largest code with non zero frequency */
} tree_desc;


typedef struct _MSZIP_COMPRESS_CONTEXT
{
    BYTE FAR *l_buf;        /* buffer for literals */
    BYTE FAR *outbuf;       /* output buffer */
    USHORT FAR *d_buf;      /* buffer for distances */
    USHORT outcnt;          /* bytes in output buffer */
    UINT outsize;           /* size of output buffer */

#ifdef LGM
    USHORT FAR *h1;         /* one-byte match chains */
    USHORT FAR *h2;         /* two-byte match chains */
#endif

    BYTE FAR *window;       /* 2*WSIZE (iow, 64K) */

    USHORT FAR * head;      /* LGM: 1/2 K else: 128K */
                            /* LGM: 256-entry lookup of the */
                            /* head of each 1-byte chain */

    USHORT FAR * prev;      /* 64K */
                            /* LGM: three-byte match chains */

    int ins_h;              /* hash index of string to be inserted */

    int lookahead;

    int fError;             /* NZ if output buffer overflows */

    /* Local data used by the "bit string" routines. */

    USHORT bi_buf;          /* Output buffer. bits are inserted starting    */
                            /* at the bottom (least significant bits).      */

    int bi_valid;           /* Number of valid bits in bi_buf.  All bits    */
                            /* above the last valid bit are always zero.    */

#ifdef DEBUG
    ULONG bits_sent;        /* bit length of the compressed data */
    int verbose;            /* level of Trace(): set to 0, 1, or 2 */
#endif

    long block_start;       /* window position at the beginning of the      */
                            /* current output block. Gets negative when     */
                            /* the window is moved backwards.               */

    int prev_length;        /* Length of the best match at previous step.   */
                            /* Matches not greater than this are discarded. */
                            /* This is used in the lazy match evaluation.   */

    USHORT strstart;        /* start of string to insert */

    USHORT match_start;     /* start of matching string */

    int heap_len;           /* number of elements in the heap */
    int heap_max;           /* element of largest frequency */

    USHORT last_lit;        /* running index in l_buf */
    USHORT last_dist;       /* running index in d_buf */
    USHORT last_flags;      /* running index in flag_buf */

    /* bits are filled in flags starting at bit 0 (least significant).
     * Note: these flags are overkill in the current code since we don't
     * take advantage of DIST_BUFSIZE == LIT_BUFSIZE.
     */
    BYTE flags;             /* current flags not yet saved in flag_buf */
    BYTE flag_bit;          /* current bit used in flags */

    ULONG opt_len;          /* bit length of current block with optimal trees */
    ULONG static_len;       /* bit length of current block with static trees */
    ULONG compressed_len;   /* total bit length of compressed file */

    tree_desc l_desc;       /* descriptor for ltree */
    tree_desc d_desc;       /* descriptor for dtree */
    tree_desc bl_desc;      /* descriptor for bltree */

    ct_data dyn_ltree[HEAP_SIZE];   /* literal and length tree */
    ct_data dyn_dtree[2*D_CODES+1]; /* distance tree */

    /* The static literal tree. Since the bit lengths are imposed, there is no
    * need for the L_CODES extra codes used during heap construction. However
    * The codes 286 and 287 are needed to build a canonical tree (see ct_init
    * below).
    */
    ct_data static_ltree[L_CODES+2];

    /* The static distance tree. (Actually a trivial tree since all codes use
     * 5 bits.)
     */
    ct_data static_dtree[D_CODES];

    /* Huffman tree for the bit lengths */
    ct_data bl_tree[2*BL_CODES+1];

    /* number of codes at each bit length for an optimal tree */
    USHORT bl_count[MAX_BITS+1];

    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */
    int heap[2*L_CODES+1]; /* heap used to build the Huffman trees */

    /* Depth of each subtree used as tie breaker for trees of equal frequency */
    BYTE depth[2*L_CODES+1];

    /* length code for each normalized match length (0 == MIN_MATCH) */
    BYTE length_code[MAX_MATCH-MIN_MATCH+1];

    /* distance codes. The first 256 values correspond to the distances
    * 3 .. 258, the last 256 values correspond to the top 8 bits of
    * the 15 bit distances.
    */
    BYTE dist_code[512];

    /* First normalized length for each code (0 = MIN_MATCH) */
    int base_length[LENGTH_CODES];

    /* First normalized distance for each code (0 = distance of 1) */
    int base_dist[D_CODES];

    /* flag_buf is a bit array distinguishing literals from lengths in
    * l_buf, thus indicating the presence or absence of a distance.
    */
    BYTE flag_buf[(LIT_BUFSIZE/8)];

} MSZIP_COMPRESS_CONTEXT, FAR *PMSZIP_COMPRESS_CONTEXT;


/* Send a code of the given tree. c and tree must not have side effects */

#ifndef DEBUG
#define send_code(context, c, tree) \
    send_bits(context, tree[c].Code, tree[c].Len)
#else /* DEBUG */
#define send_code(context, c, tree)                         \
    {                                                       \
        if (context->verbose > 1)                           \
        {                                                   \
            fprintf(stderr,"\ncd %3d ",(c));                \
        }                                                   \
        send_bits(context, tree[c].Code, tree[c].Len);      \
    }
#endif

/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. dist_code[256] and dist_code[257] are never
 * used.
 */
#define d_code(context, dist) \
   ((dist) < 256 ? context->dist_code[dist] : context->dist_code[256+((dist)>>7)])

/* the arguments must not have side effects */
#define MAX(a,b) (a >= b ? a : b)

/* --- local function prototypes ------------------------------------------ */

static void lm_init_clear_tables(PMSZIP_COMPRESS_CONTEXT context);
static void lm_init_use_tables(PMSZIP_COMPRESS_CONTEXT context);
static void lm_init(PMSZIP_COMPRESS_CONTEXT context);
static ULONG deflate(PMSZIP_COMPRESS_CONTEXT context);
static void ct_init(PMSZIP_COMPRESS_CONTEXT context);
static int ct_tally(PMSZIP_COMPRESS_CONTEXT context,int dist, int lc);
static ULONG flush_block(PMSZIP_COMPRESS_CONTEXT context,
        char FAR *buf, ULONG stored_len, int eof);
static void bi_init(PMSZIP_COMPRESS_CONTEXT context);
static void send_bits(PMSZIP_COMPRESS_CONTEXT context,int value, int length);
static USHORT bi_reverse(int value, int length);
static void bi_windup(PMSZIP_COMPRESS_CONTEXT context);
static void copy_block(PMSZIP_COMPRESS_CONTEXT context,
        char FAR *buf, USHORT len, int header);

#ifdef DEBUG
static void check_match(PMSZIP_COMPRESS_CONTEXT context,
        IPos start, IPos match, int length);
#else
#define check_match(context, start, match, length)  /* as nothing */
#endif

static void init_block(PMSZIP_COMPRESS_CONTEXT context);
static void pqdownheap(PMSZIP_COMPRESS_CONTEXT context,
        ct_data FAR *tree, int k);
static void gen_bitlen(PMSZIP_COMPRESS_CONTEXT context, tree_desc FAR *desc);
static void gen_codes(PMSZIP_COMPRESS_CONTEXT context,
        ct_data FAR *tree, int max_code);
static void build_tree(PMSZIP_COMPRESS_CONTEXT context, tree_desc FAR *desc);
static void scan_tree(PMSZIP_COMPRESS_CONTEXT context,
        ct_data FAR *tree, int max_code);
static void send_tree(PMSZIP_COMPRESS_CONTEXT context,
        ct_data FAR *tree, int max_code);
static int  build_bl_tree(PMSZIP_COMPRESS_CONTEXT context);
static void send_all_trees(PMSZIP_COMPRESS_CONTEXT context,
        int lcodes, int dcodes, int blcodes);
static void compress_block(PMSZIP_COMPRESS_CONTEXT context,
        ct_data FAR *ltree, ct_data FAR *dtree);
static void ins_str(PMSZIP_COMPRESS_CONTEXT context,
        USHORT s, IPos FAR *match_head);
static int longest_match(PMSZIP_COMPRESS_CONTEXT context,IPos cur_match);

#ifdef ASMV
extern void match_init(void);    /* asm code initialization */
#endif

/* --- NFMcomp_create() --------------------------------------------------- */

void FAR *NFMcomp_create(PFNALLOC NFMalloc)
{
    PMSZIP_COMPRESS_CONTEXT p;

    p = NFMalloc(sizeof(MSZIP_COMPRESS_CONTEXT));

    if (p != NULL)
    {
        memset(p,0,sizeof(MSZIP_COMPRESS_CONTEXT));

        /* initialize members */

        p->l_desc.dyn_tree = p->dyn_ltree;
        p->l_desc.static_tree = p->static_ltree;
        p->l_desc.extra_bits = extra_lbits;
        p->l_desc.extra_base = LITERALS+1;
        p->l_desc.elems = L_CODES;
        p->l_desc.max_length = MAX_BITS;
        p->l_desc.max_code = 0;

        p->d_desc.dyn_tree = p->dyn_dtree;
        p->d_desc.static_tree = p->static_dtree;
        p->d_desc.extra_bits = extra_dbits;
        p->d_desc.extra_base = 0;
        p->d_desc.elems = D_CODES;
        p->d_desc.max_length = MAX_BITS;
        p->d_desc.max_code = 0;

        p->bl_desc.dyn_tree = p->bl_tree;
        p->bl_desc.static_tree = (ct_data FAR *)0;
        p->bl_desc.extra_bits = extra_blbits;
        p->bl_desc.extra_base = 0;
        p->bl_desc.elems = BL_CODES;
        p->bl_desc.max_length = MAX_BL_BITS;
        p->bl_desc.max_code = 0;
    }

    return(p);
}

/* --- NFMcomp_destroy() -------------------------------------------------- */

void NFMcomp_destroy(void FAR *ctx,PFNFREE NFMfree)
{
    NFMfree(ctx);
}

/* --- NFMcompress_init() ------------------------------------------------- */

int NFMcompress_init(void FAR *ctx,void FAR *buf1,void FAR *buf2)
{
    PMSZIP_COMPRESS_CONTEXT context = ctx;

    context->l_buf = buf1;
    context->d_buf = buf2;
    if ((context->l_buf == NULL) || (context->d_buf == NULL))
    {
        return(-1);
    }
    else
    {
        return(0);
    }
}

/* --- NFMcompress() ------------------------------------------------------ */

int NFMcompress(void FAR *ctx,BYTE FAR *bfSrc, UINT cbSrc,
        BYTE FAR *bfDest, UINT cbDest,
        MI_MEMORY bfWrk1, MI_MEMORY bfWrk2,
#ifdef LGM
        MI_MEMORY bfWrk3, MI_MEMORY bfWrk4,
#endif
        char fhistory, UINT FAR *pcbDestRet)
{
    PMSZIP_COMPRESS_CONTEXT context = ctx;

#ifdef LGM
    context->head = bfWrk1;
    context->prev = bfWrk2;
    context->h1 = bfWrk3;
    context->h2 = bfWrk4;
#else
    context->head = bfWrk2;
    context->prev = bfWrk1;
#endif

    context->outbuf = bfDest;
    context->outcnt = 0;
    context->outsize = cbDest;

    context->window = bfSrc;
    context->lookahead = cbSrc;

    context->fError = 0;

    if (!fhistory)
    {
#ifndef BIT16
        memcpy(context->window+32768U,context->window,32768U);
#else
        _fmemcpy(context->window+32768U,context->window,32768U);
#endif
    }

    bi_init(context);
    ct_init(context);
    lm_init(context);

    if (fhistory)
    {
        lm_init_use_tables(context);
    }
    else
    {
        lm_init_clear_tables(context);
    }

#ifndef DRVSPACE
    send_bits(context,NFM_SIG0,8);      /* put in signature */
    send_bits(context,NFM_SIG1,8);

    *pcbDestRet = (USHORT) (NFM_SIG_LEN + deflate(context));
#else
    *pcbDestRet = (USHORT) deflate(context);
#endif

    if (fhistory)
    {
#ifndef BIT16
        memcpy(context->window,context->window+32768U,32768U);
#else
        _fmemcpy(context->window,context->window+32768U,32768U);
#endif
    }

    if (context->fError)
    {
        return(NFMinvalid);
    }

    return NFMsuccess;
}

/*
 *  PURPOSE
 *
 *      Output variable-length bit strings. Compression can be done
 *      to a file or to memory. (The latter is not supported in this version.)
 *
 *  DISCUSSION
 *
 *      The PKZIP "deflate" file format interprets compressed file data
 *      as a sequence of bits.  Multi-bit strings in the file may cross
 *      byte boundaries without restriction.
 *
 *      The first bit of each byte is the low-order bit.
 *
 *      The routines in this file allow a variable-length bit value to
 *      be output right-to-left (useful for literal values). For
 *      left-to-right output (useful for code strings from the tree routines),
 *      the bits must have been reversed first with bi_reverse().
 *
 *      For in-memory compression, the compressed bit stream goes directly
 *      into the requested output buffer. The input data is read in blocks
 *      by the mem_read() function. The buffer is limited to 64K on 16 bit
 *      machines.
 *
 *  INTERFACE
 *
 *      void bi_init (FILE *zipfile)
 *          Initialize the bit string routines.
 *
 *      void send_bits (int value, int length)
 *          Write out a bit string, taking the source bits right to
 *          left.
 *
 *      int bi_reverse (int value, int length)
 *          Reverse the bits of a bit string, taking the source bits left to
 *          right and emitting them right to left.
 *
 *      void bi_windup (void)
 *          Write out any remaining bits in an incomplete byte.
 *
 *      void copy_block(char *buf, USHORT len, int header)
 *          Copy a stored block to the zip file, storing first the length and
 *          its one's complement if requested.
 *
 */

/* --- bi_init() ---------------------------------------------------------- */

/*
 * Initialize the bit string routines.
 */

static void bi_init(PMSZIP_COMPRESS_CONTEXT context)
{
    context->bi_buf = 0;
    context->bi_valid = 0;
#ifdef DEBUG
    context->bits_sent = 0L;
#endif
}

/* --- send_bits() -------------------------------------------------------- */

/*
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */

static void send_bits(PMSZIP_COMPRESS_CONTEXT context,int value, int length)
{
#ifdef DEBUG
    Tracev((stderr," l %2d v %4x ", length, value));
    Assert(context,length > 0 && length <= 15, "invalid length");
    context->bits_sent += (ULONG)length;
#endif
    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if (context->bi_valid > Buf_size - length) {
        context->bi_buf |= (value << context->bi_valid);
        put_short(context,context->bi_buf);
        context->bi_buf = (USHORT) (value >> (Buf_size - context->bi_valid));
        context->bi_valid += length - Buf_size;
    } else {
        context->bi_buf |= value << context->bi_valid;
        context->bi_valid += length;
    }
}

/* --- bi_reverse() ------------------------------------------------------- */

/*
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
static USHORT bi_reverse(int code, int len)
/*    USHORT code;    the value to invert */
/*    int len;        its bit length */
{
    register USHORT res = 0;
    do {
        res |= code & 1;
        code >>= 1, res <<= 1;
    } while (--len > 0);
    return((USHORT)(res >> 1));
}

/* --- bi_windup() -------------------------------------------------------- */

/*
 * Write out any remaining bits in an incomplete byte.
 */
static void bi_windup(PMSZIP_COMPRESS_CONTEXT context)
{
    if (context->bi_valid > 8) {
        put_short(context,context->bi_buf);
    } else if (context->bi_valid > 0) {
        put_byte(context,context->bi_buf);
    }
    context->bi_buf = 0;
    context->bi_valid = 0;
#ifdef DEBUG
    context->bits_sent = (context->bits_sent+7) & ~7;
#endif
}

/* --- copy_block() ------------------------------------------------------- */

/*
 * Copy a stored block to the zip file, storing first the length and its
 * one's complement if requested.
 */
static void copy_block(PMSZIP_COMPRESS_CONTEXT context,
        char FAR *buf, USHORT len, int header)
/*    char     *buf;     the input data */
/*    USHORT   len;      its length */
/*    int      header;   true if block header must be written */
{
    bi_windup(context);              /* align on byte boundary */

    if (header) {
        put_short(context,(USHORT)len);
#ifdef DEBUG
        context->bits_sent += 16;
#endif
#ifdef LARGE_STORED_BLOCKS
        put_short(context,(USHORT)~len);
#ifdef DEBUG
        context->bits_sent += 16;
#endif
#endif
    }
#ifdef DEBUG
    context->bits_sent += (ULONG)len<<3;
#endif
    while (len--) {
        put_byte(context,*buf++);
    }
}

/*
 *  PURPOSE
 *
 *      Encode various sets of source values using variable-length
 *      binary code trees.
 *
 *  DISCUSSION
 *
 *      The PKZIP "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in the ZIP file in a compressed form
 *      which is itself a Huffman encoding of the lengths of
 *      all the code strings (in ascending order by source values).
 *      The actual code strings are reconstructed from the lengths in
 *      the UNZIP process, as described in the "application note"
 *      (APPNOTE.TXT) distributed as part of PKWARE's PKZIP program.
 *
 *  REFERENCES
 *
 *      Lynch, Thomas J.
 *          Data Compression:  Techniques and Applications, pp. 53-55.
 *          Lifetime Learning Publications, 1985.  ISBN 0-534-03418-7.
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 *
 *  INTERFACE
 *
 *      void ct_init (USHORT *attr, int *methodp)
 *          Allocate the match buffer, initialize the various tables and save
 *          the location of the internal file attribute (ascii/binary) and
 *          method (DEFLATE/STORE)
 *
 *      void ct_tally (int dist, int lc);
 *          Save the match info and tally the frequency counts.
 *
 *      long flush_block (char *buf, ULONG stored_len, int eof)
 *          Determine the best encoding for the current block: dynamic trees,
 *          static trees or store, and output the encoded block to the zip
 *          file. Returns the total compressed length for the file so far.
 *
 */

/*
 * Allocate the match buffer, initialize the various tables and save the
 * location of the internal file attribute (ascii/binary) and method
 * (DEFLATE/STORE).
 */
static void ct_init(PMSZIP_COMPRESS_CONTEXT context)
{
    int n;        /* iterates over tree elements */
    int bits;     /* bit counter */
    int length;   /* length value */
    int code;     /* code value */
    int dist;     /* distance index */

    context->compressed_len = 0L;

    if (context->static_dtree[0].Len != 0)
    {
        return;     /* ct_init already called */
    }

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    length = 0;
    for (code = 0; code < LENGTH_CODES-1; code++) {
        context->base_length[code] = length;
        for (n = 0; n < (1<<extra_lbits[code]); n++) {
            context->length_code[length++] = (BYTE)code;
        }
    }
    Assert(context,length == 256, "ct_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    context->length_code[length-1] = (BYTE)code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code = 0 ; code < 16; code++) {
        context->base_dist[code] = dist;
        for (n = 0; n < (1<<extra_dbits[code]); n++) {
            context->dist_code[dist++] = (BYTE)code;
        }
    }
    Assert(context,dist == 256, "ct_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */
    for ( ; code < D_CODES; code++) {
        context->base_dist[code] = dist << 7;
        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
            context->dist_code[256 + dist++] = (BYTE)code;
        }
    }
    Assert(context,dist == 256, "ct_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */
    for (bits = 0; bits <= MAX_BITS; bits++) {
        context->bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143)
    {
        context->static_ltree[n++].Len = 8;
        context->bl_count[8]++;
    }
    while (n <= 255)
    {
        context->static_ltree[n++].Len = 9;
        context->bl_count[9]++;
    }
    while (n <= 279)
    {
        context->static_ltree[n++].Len = 7;
        context->bl_count[7]++;
    }
    while (n <= 287)
    {
        context->static_ltree[n++].Len = 8;
        context->bl_count[8]++;
    }

    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    gen_codes(context, (ct_data FAR *)(context->static_ltree), L_CODES+1);

    /* The static distance tree is trivial: */
    for (n = 0; n < D_CODES; n++) {
        context->static_dtree[n].Len = 5;
        context->static_dtree[n].Code = bi_reverse(n, 5);
    }

    /* Initialize the first block of the first file: */
    init_block(context);
}

/*
 * Initialize a new block.
 */
static void init_block(PMSZIP_COMPRESS_CONTEXT context)
{
    int n; /* iterates over tree elements */

    /* Initialize the trees. */
    for (n = 0; n < L_CODES;  n++)
    {
        context->dyn_ltree[n].Freq = 0;
    }
    for (n = 0; n < D_CODES;  n++)
    {
        context->dyn_dtree[n].Freq = 0;
    }
    for (n = 0; n < BL_CODES; n++)
    {
        context->bl_tree[n].Freq = 0;
    }

    context->dyn_ltree[END_BLOCK].Freq = 1;
    context->opt_len = context->static_len = 0L;
    context->last_lit = context->last_dist = context->last_flags = 0;
    context->flags = 0;
    context->flag_bit = 1;
}

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/*
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */
#define pqremove(context, tree, top)                                    \
    {                                                                   \
        top = context->heap[SMALLEST];                                  \
        context->heap[SMALLEST] = context->heap[context->heap_len--];   \
        pqdownheap(context, tree, SMALLEST);                            \
    }

/*
 * Compares two subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define smaller(context, tree, n, m)                \
    (tree[n].Freq < tree[m].Freq ||                 \
    ((tree[n].Freq == tree[m].Freq) &&              \
        (context->depth[n] <= context->depth[m])))

/*
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
static void pqdownheap(PMSZIP_COMPRESS_CONTEXT context,
        ct_data FAR *tree, int k)
/*    ct_data *tree;   the tree to restore */
/*    int k;                node to move down */
{
    int v = context->heap[k];
    int j = k << 1;  /* left son of k */
    while (j <= context->heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < context->heap_len &&
                smaller(context, tree, context->heap[j+1], context->heap[j])) {
            j++;
        }

        /* Exit if v is smaller than both sons */
        if (smaller(context, tree, v, context->heap[j])) {
            break;
        }

        /* Exchange v with the smallest son */
        context->heap[k] = context->heap[j];
        k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
    }
    context->heap[k] = v;
}

/*
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
static void gen_bitlen(PMSZIP_COMPRESS_CONTEXT context, tree_desc FAR *desc)
/*  tree_desc *desc;  the tree descriptor */
{
    ct_data FAR *tree   = desc->dyn_tree;
    int const FAR *extra = desc->extra_bits;
    int base            = desc->extra_base;
    int max_code        = desc->max_code;
    int max_length      = desc->max_length;
    ct_data FAR *stree  = desc->static_tree;
    int h;              /* heap index */
    int n, m;           /* iterate over the tree elements */
    int bits;           /* bit length */
    int xbits;          /* extra bits */
    USHORT f;           /* frequency */
    int overflow = 0;   /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS; bits++) {
        context->bl_count[bits] = 0;
    }

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[context->heap[context->heap_max]].Len = 0; /* root of the heap */

    for (h = context->heap_max+1; h < HEAP_SIZE; h++) {
        n = context->heap[h];
        bits = tree[tree[n].Dad].Len + 1;
        if (bits > max_length) bits = max_length, overflow++;
        tree[n].Len = (USHORT)bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) {
            continue; /* not a leaf node */
        }

        context->bl_count[bits]++;
        xbits = 0;
        if (n >= base) xbits = extra[n-base];
        f = tree[n].Freq;
        context->opt_len += (ULONG)f * (bits + xbits);
        if (stree)
        {
            context->static_len += (ULONG)f * (stree[n].Len + xbits);
        }
    }
    if (overflow == 0) return;

    Trace((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do {
        bits = max_length-1;
        while (context->bl_count[bits] == 0) {
            bits--;
        }
        context->bl_count[bits]--;      /* move one leaf down the tree */
        context->bl_count[bits+1] += 2; /* move one overflow item as its brother */
        context->bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
    } while (overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (bits = max_length; bits != 0; bits--) {
        n = context->bl_count[bits];
        while (n != 0) {
            m = context->heap[--h];
            if (m > max_code) continue;
            if (tree[m].Len != (USHORT) bits) {
                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                context->opt_len += ((long)bits-(long)tree[m].Len)*(long)tree[m].Freq;
                tree[m].Len = (USHORT)bits;
            }
            n--;
        }
    }
}

/*
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
static void gen_codes(PMSZIP_COMPRESS_CONTEXT context,
        ct_data FAR *tree, int max_code)
/*    ct_data *tree;         the tree to decorate */
/*    int max_code;               largest code with non zero frequency */
{
    USHORT next_code[MAX_BITS+1]; /* next code value for each bit length */
    USHORT code = 0;           /* running code value */
    int bits;                  /* bit index */
    int n;                     /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code =
                (USHORT) ((code + context->bl_count[bits-1]) << 1);
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    Assert(context,code + context->bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            "inconsistent bit counts");
    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
        int len = tree[n].Len;
        if (len == 0) continue;
        /* Now reverse the bits */
        tree[n].Code = bi_reverse(next_code[len]++, len);

        Tracec(tree != context->static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
}

/*
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
static void build_tree(PMSZIP_COMPRESS_CONTEXT context,tree_desc FAR *desc)
/*    tree_desc *desc;  the tree descriptor */
{
    ct_data FAR *tree   = desc->dyn_tree;
    ct_data FAR *stree  = desc->static_tree;
    int elems           = desc->elems;
    int n, m;          /* iterate over heap elements */
    int max_code = -1; /* largest code with non zero frequency */
    int node = elems;  /* next internal node of the tree */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    context->heap_len = 0, context->heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
        if (tree[n].Freq != 0) {
            context->heap[++context->heap_len] = max_code = n;
            context->depth[n] = 0;
        } else {
            tree[n].Len = 0;
        }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (context->heap_len < 2) {
        int new = context->heap[++context->heap_len] =
                (max_code < 2 ? ++max_code : 0);
        tree[new].Freq = 1;
        context->depth[new] = 0;
        context->opt_len--;
        if (stree)
        {
            context->static_len -= stree[new].Len;
            /* new is 0 or 1 so it does not have extra bits */
        }
    }
    desc->max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (n = context->heap_len/2; n >= 1; n--) pqdownheap(context, tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    do {
        pqremove(context, tree, n);   /* n = node of least frequency */
        m = context->heap[SMALLEST];  /* m = node of next least frequency */

        context->heap[--context->heap_max] = n; /* keep the nodes sorted by frequency */
        context->heap[--context->heap_max] = m;

        /* Create a new node father of n and m */
        tree[node].Freq = (USHORT)(tree[n].Freq + tree[m].Freq);
        context->depth[node] = (BYTE)
                (MAX(context->depth[n], context->depth[m]) + 1);
        tree[n].Dad = tree[m].Dad = (USHORT)node;
#ifdef DUMP_BL_TREE
        if (tree == bl_tree) {
            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        }
#endif
        /* and insert the new node in the heap */
        context->heap[SMALLEST] = node++;
        pqdownheap(context, tree, SMALLEST);

    } while (context->heap_len >= 2);

    context->heap[--context->heap_max] = context->heap[SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    gen_bitlen(context, (tree_desc FAR *)desc);

    /* The field len is now set, we can generate the bit codes */
    gen_codes(context, (ct_data FAR *)tree, max_code);
}

/*
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree. Updates opt_len to take into account the repeat
 * counts. (The contribution of the bit length codes will be added later
 * during the construction of bl_tree.)
 */
static void scan_tree(PMSZIP_COMPRESS_CONTEXT context,
        ct_data FAR *tree, int max_code)
/*    ct_data *tree;  the tree to be scanned */
/*    int max_code;        and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    if (nextlen == 0) max_count = 138, min_count = 3;
    tree[max_code+1].Len = (USHORT)-1; /* guard */

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            context->bl_tree[curlen].Freq =
                    (USHORT) (context->bl_tree[curlen].Freq + count);
        } else if (curlen != 0) {
            if (curlen != prevlen) {
                context->bl_tree[curlen].Freq++;
            }
            context->bl_tree[REP_3_6].Freq++;
        } else if (count <= 10) {
            context->bl_tree[REPZ_3_10].Freq++;
        } else {
            context->bl_tree[REPZ_11_138].Freq++;
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/*
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
static void send_tree(PMSZIP_COMPRESS_CONTEXT context,
        ct_data FAR *tree, int max_code)
/*    ct_data *tree;  the tree to be scanned */
/*    int max_code;        and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    /* tree[max_code+1].Len = -1; */  /* guard already set */
    if (nextlen == 0) max_count = 138, min_count = 3;

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            do {
                send_code(context, curlen, context->bl_tree);
            } while (--count != 0);

        } else if (curlen != 0) {
            if (curlen != prevlen) {
                send_code(context, curlen, context->bl_tree);
                count--;
            }
            Assert(context,count >= 3 && count <= 6, " 3_6?");
            send_code(context, REP_3_6, context->bl_tree);
            send_bits(context, count-3, 2);

        } else if (count <= 10) {
            send_code(context, REPZ_3_10, context->bl_tree);
            send_bits(context, count-3, 3);

        } else {
            send_code(context, REPZ_11_138, context->bl_tree);
            send_bits(context, count-11, 7);
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/*
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
static int build_bl_tree(PMSZIP_COMPRESS_CONTEXT context)
{
    int max_blindex;  /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */
    scan_tree(context, (ct_data FAR *)(context->dyn_ltree), context->l_desc.max_code);
    scan_tree(context, (ct_data FAR *)(context->dyn_dtree), context->d_desc.max_code);

    /* Build the bit length tree: */
    build_tree(context,(tree_desc FAR *)(&context->bl_desc));
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
        if (context->bl_tree[bl_order[max_blindex]].Len != 0) {
            break;
        }
    }
    /* Update opt_len to include the bit length tree and counts */
    context->opt_len += 3*(max_blindex+1) + 5+5+4;
    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld", context->opt_len, context->static_len));

    return max_blindex;
}

/*
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
static void send_all_trees(PMSZIP_COMPRESS_CONTEXT context,
        int lcodes, int dcodes, int blcodes)
/*  int lcodes, dcodes, blcodes;  number of codes for each tree */
{
    int rank;                    /* index in bl_order */

    Assert(context,lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    Assert(context,lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            "too many codes");
    Tracev((stderr, "\nbl counts: "));
    send_bits(context, lcodes-257, 5); /* not +255 as stated in appnote.txt */
    send_bits(context, dcodes-1,   5);
    send_bits(context, blcodes-4,  4); /* not -3 as stated in appnote.txt */
    for (rank = 0; rank < blcodes; rank++) {
        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(context, context->bl_tree[bl_order[rank]].Len, 3);
    }
    Tracev((stderr, "\nbl tree: sent %ld", context->bits_sent));

    send_tree(context, (ct_data FAR *)(context->dyn_ltree), lcodes-1); /* send the literal tree */
    Tracev((stderr, "\nlit tree: sent %ld", context->bits_sent));

    send_tree(context, (ct_data FAR *)(context->dyn_dtree), dcodes-1); /* send the distance tree */
    Tracev((stderr, "\ndist tree: sent %ld", context->bits_sent));
}

/*
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file. This function
 * returns the total compressed length for the file so far.
 */
static ULONG flush_block(PMSZIP_COMPRESS_CONTEXT context,
        char FAR *buf, ULONG stored_len, int eof)
/*    char *buf;         input block, or NULL if too old */
/*    ULONG stored_len;  length of input block */
/*    int eof;           true if this is the last block for a file */
{
    ULONG opt_lenb, static_lenb; /* opt_len and static_len in bytes */
    int max_blindex;  /* index of last bit length code of non zero freq */

    /* Save the flags for the last 8 items */
    context->flag_buf[context->last_flags] = context->flags;

    /* Construct the literal and distance trees */
    build_tree(context,(tree_desc FAR *)(&context->l_desc));
    Tracev((stderr, "\nlit data: dyn %ld, stat %ld", context->opt_len, context->static_len));

    build_tree(context,(tree_desc FAR *)(&context->d_desc));
    Tracev((stderr, "\ndist data: dyn %ld, stat %ld", context->opt_len, context->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(context);

    /* Determine the best encoding. Compute first the block length in bytes */
    opt_lenb = (context->opt_len+3+7)>>3;
    static_lenb = (context->static_len+3+7)>>3;
    if (static_lenb <= opt_lenb)
    {
        opt_lenb = static_lenb;
    }

#ifdef LARGE_STORED_BLOCKS
    if ((stored_len+4 <= opt_lenb) && (buf != (char FAR *)0))
#else
    if ((stored_len+2 <= opt_lenb) && (buf != (char FAR *)0))
#endif
    {
        /* 2 (4): one (two) word for the length */
        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        send_bits(context, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
        context->compressed_len = (context->compressed_len + 3 + 7) & ~7L;
#ifdef LARGE_STORED_BLOCKS
        context->compressed_len += (stored_len + 4) << 3;
#else
        context->compressed_len += (stored_len + 2) << 3;
#endif

        copy_block(context, buf, (USHORT)stored_len, 1); /* with header */
    }
    else if (static_lenb == opt_lenb)
    {
        send_bits(context, (STATIC_TREES<<1)+eof, 3);
        compress_block(context,
                (ct_data FAR *)(context->static_ltree),
                (ct_data FAR *)(context->static_dtree));
        context->compressed_len += 3 + context->static_len;
    }
    else
    {
        send_bits(context, (DYN_TREES<<1)+eof, 3);
        send_all_trees(context, context->l_desc.max_code+1,
                context->d_desc.max_code+1, max_blindex+1);
        compress_block(context,
                (ct_data FAR *)(context->dyn_ltree),
                (ct_data FAR *)(context->dyn_dtree));
        context->compressed_len += 3 + context->opt_len;
    }
    Assert(context,context->compressed_len == context->bits_sent, "bad compressed size");
    init_block(context);

    if (eof)
    {
        bi_windup(context);
        context->compressed_len += 7;  /* align on byte boundary */
    }
    Tracev((stderr,"\ncomprlen %lu(%lu) ", context->compressed_len>>3,
           context->compressed_len-7*eof));

    return(context->compressed_len >> 3);
}

/*
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
static int ct_tally(PMSZIP_COMPRESS_CONTEXT context,int dist, int lc)
/*    int dist;   distance of matched string */
/*    int lc;     match length-MIN_MATCH or unmatched char (if dist==0) */
{
    context->l_buf[context->last_lit++] = (BYTE)lc;
    if (dist == 0) {
        /* lc is the unmatched char */
        context->dyn_ltree[lc].Freq++;
    } else {
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        Assert(context,(USHORT)dist < (USHORT)MAX_DIST &&
               (USHORT)lc <= (USHORT)(MAX_MATCH-MIN_MATCH) &&
               (USHORT)d_code(context,dist) < (USHORT)D_CODES,  "ct_tally: bad match");

        context->dyn_ltree[context->length_code[lc]+LITERALS+1].Freq++;
        context->dyn_dtree[d_code(context,dist)].Freq++;

        context->d_buf[context->last_dist++] = (USHORT)dist;
        context->flags |= context->flag_bit;
    }
    context->flag_bit <<= 1;

    /* Output the flags if they fill a byte: */
    if ((context->last_lit & 7) == 0) {
        context->flag_buf[context->last_flags++] = context->flags;
        context->flags = 0;
        context->flag_bit = 1;
    }
    /* Try to guess if it is profitable to stop the current block here */
    if ((context->last_lit & 0xfff) == 0) {
        /* Compute an upper bound for the compressed length */
        ULONG out_length = (ULONG)(context->last_lit)*8L;
        ULONG in_length = (ULONG)(context->strstart) - context->block_start;
        int dcode;
        for (dcode = 0; dcode < D_CODES; dcode++) {
            out_length += (ULONG)(context->dyn_dtree[dcode].Freq)*(5L+extra_dbits[dcode]);
        }
        out_length >>= 3;
        Trace((stderr,"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ",
               context->last_lit, context->last_dist, in_length, out_length,
               100L - out_length*100L/in_length));
        if (context->last_dist < context->last_lit/2 && out_length < in_length/2)
        {
            return 1;
        }
    }

    /* We avoid equality with LIT_BUFSIZE because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
    return((context->last_lit == LIT_BUFSIZE-1) ||
            (context->last_dist == DIST_BUFSIZE));
}

/* --- compress_block() --------------------------------------------------- */

/*
 * Send the block data compressed using the given Huffman trees
 */

static void compress_block(PMSZIP_COMPRESS_CONTEXT context,
        ct_data FAR *ltree, ct_data FAR *dtree)
/*    ct_data *ltree;  literal tree */
/*    ct_data *dtree;  distance tree */
{
    int dist;       /* distance of matched string */
    int lc;         /* match length or unmatched char (if dist == 0) */
    USHORT lx = 0;  /* running index in l_buf */
    USHORT dx = 0;  /* running index in d_buf */
    USHORT fx = 0;  /* running index in flag_buf */
    BYTE flag = 0;  /* current flags */
    int code;       /* the code to send */
    int extra;      /* number of extra bits to send */

    if (context->last_lit != 0)
    {
        do
        {
            if ((lx & 7) == 0)
            {
                flag = context->flag_buf[fx++];
            }

            lc = context->l_buf[lx++];

            if ((flag & 1) == 0)
            {
                send_code(context, lc, ltree); /* send a literal byte */
                Tracecv(isgraph(lc), (stderr," '%c' ", lc));
            }
            else
            {
                /* Here, lc is the match length - MIN_MATCH */
                code = context->length_code[lc];
                send_code(context, code+LITERALS+1, ltree); /* send the length code */
                extra = extra_lbits[code];

                if (extra != 0)
                {
                    lc -= context->base_length[code];
                    send_bits(context, lc, extra);  /* send the extra length bits */
                }

                /* Here, dist is the match distance - 1 */
                dist = context->d_buf[dx++];

                code = d_code(context,dist);
                Assert(context,code < D_CODES, "bad d_code");

                send_code(context, code, dtree);       /* send the distance code */
                extra = extra_dbits[code];

                if (extra != 0)
                {
                    dist -= context->base_dist[code];
                    send_bits(context, dist, extra);   /* send the extra distance bits */
                }
            } /* literal or match pair ? */

            flag >>= 1;
        } while (lx < context->last_lit);
    }

    send_code(context, END_BLOCK, ltree);
}

/* --- ins_str() ---------------------------------------------------------- */

#ifdef LGM
/***    ins_str - Insert current string into search tables, find 3 byte match
 *
 *  Entry:
 *      s          - Index of string in input buffer to process (points to
 *                   first character of string)
 *      match_head - Pointer to receive index of most recent previous
 *                   3 byte match (if any)
 *      Globals
 *      -------
 *      head[] - 256 entry array, indexed by the first byte of a string,
 *               that points into the array h1[].  head[] records the
 *               start of the linked lists of 1-byte matches.
 *
 *      h1[]   - Chains together 1-byte matches.  For example, if head['a']
 *               is 203, then 'a' appears at position 203 in the input
 *               buffer, and h1[203] is next previous position in the input
 *               buffer than contained an 'a'.
 *
 *      h2[]   - Chains together 2-byte matches.  For example, if the current
 *               input string is 'ab', and we looked up in head[] and followed
 *               the h1[] link for 'a' until we found a previous occurence of
 *               'ab' in the input at position 119, then h2[119] will point
 *               to the *next* previous position in the input that contained
 *               the string 'ab'.
 *
 *      prev[] - Chains together 3 byte matches.  Following the same scheme
 *               as h1[] and h2[] above, if the string 'abc' is at position
 *               382 in the input buffer, then prev[382] contains the next
 *               previous position in the input buffer where the string 'abc'
 *               was seen.
 *
 *  Exit-Success:
 *      *match_head = valid index in input buffer previous string;
 *      Search tables updated for this string;
 *
 *  Exit-Failure:
 *      *match_head = NIL, no previous 3 byte match found.
 *      Search tables updated for this string;
 */
static void ins_str(PMSZIP_COMPRESS_CONTEXT context,
        USHORT s, IPos FAR *match_head)
{
    IPos i;
    BYTE  b2, b3;
    IPos limit = (IPos) (context->strstart > (IPos)MAX_DIST ?
            context->strstart - (IPos)MAX_DIST : NIL);
    USHORT chain_length = max_chain_length;   /* max hash chain length */

    context->ins_h = (USHORT)(context->window[s]); /* ins_h = index of this char */

    /** Update head of 1-byte chain and link in this byte **/

    i = *(context->head+context->ins_h); /* i = previous occurence of this char */
    *(context->head+context->ins_h) = s; /* head[ins_h] = this occurance */

    *(context->h1+(s & WMASK)) = i;      /* maintain single char chain */

    /* Follow single char chain looking for a two char match */

    b2 = context->window[s+1];           /* b2 = 2nd char in string */
    while (i != NIL && b2 != context->window[i+1]) {
    i = *(context->h1+(i & WMASK));
    if (i <= limit || --chain_length == 0)
        i = NIL;
    }

    *(context->h2+(s & WMASK)) = i;      /* maintain two char chain */

    /* Follow two char chain looking for a three char match */

    b3 = context->window[s+2];           /* b3 = 3rd char in string */
    while (i != NIL && b3 != context->window[i+2]) {
    i = *(context->h2+(i & WMASK));
    if (i <= limit || --chain_length == 0)
        i = NIL;
    }

    *(context->prev+(s & WMASK)) = i;    /* maintain three char chain */

    *match_head = i;            /* return prior three char occurance */
                    /*   (or NIL if none) */
}
#endif /* LGM */

/* --- lm_init_clear_tables() --------------------------------------------- */

/*
 * Initialize the "longest match" routines
 * Clear out the hash tables
 */
static void lm_init_clear_tables(PMSZIP_COMPRESS_CONTEXT context)
{
    Pos j;

    /* Initialize the hash table. */

    for (j = 0; j < HASH_SIZE; j++)
    {
        *(context->head+j) = NIL;
    }

    /* prev will be initialized on the fly */
}

/* --- lm_init_use_tables() ----------------------------------------------- */

/* clear out the hash tables of 2 times ago junk */

static void lm_init_use_tables(PMSZIP_COMPRESS_CONTEXT context)
{
    Pos n,m;

    for (n = 0; n < HASH_SIZE; n++)
    {
        m = *(context->head+n);
        *(context->head+n) = (Pos)((m >= WSIZE) ? (m - WSIZE) : NIL);
    }

    for (n = 0; n < WSIZE; n++)
    {
        m = *(context->prev+n);
        *(context->prev+n) = (Pos)((m >= WSIZE) ? (m - WSIZE) : NIL);

        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */

#ifdef LGM
        m = *(context->h1+n);
        *(context->h1+n) = (Pos)((m >= WSIZE) ? (m - WSIZE) : NIL);

        m = *(context->h2+n);
        *(context->h2+n) = (Pos)((m >= WSIZE) ? (m - WSIZE) : NIL);
#endif
    }
}

/* --- lm_init() ---------------------------------------------------------- */

static void lm_init(PMSZIP_COMPRESS_CONTEXT context)
{
#ifndef LGM
    USHORT j;
#endif

    context->strstart = 32768U;
    context->block_start = 32768L;

    /* lookahead already set */

#ifdef ASMV
    match_init();       /* asm code initialization */
#endif

    context->ins_h = 0;

#ifndef LGM
    for (j = 0; j < (REAL_MIN - 1); j++)
    {
        UPDATE_HASH(context->ins_h, context->window[j + context->strstart]);
    }

    /* If lookahead < MIN_MATCH, ins_h is garbage, but this is
     * not important since only literal bytes will be emitted.
     */
#endif
}

/* --- longest_match() ---------------------------------------------------- */

/*
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 */

/* For MSDOS, OS/2 and 386 Unix, an optimized version is in match.asm or
 * match.s. The code is functionally equivalent, so you can use the C version
 * if desired.
 */
#ifndef ASMV
static int longest_match(PMSZIP_COMPRESS_CONTEXT context, IPos cur_match)
{
    USHORT chain_length = max_chain_length;     /* max hash chain length */
    register BYTE FAR *scan = context->window + context->strstart; /* current string */
    register BYTE FAR *match;                   /* matched string */
    register int len;                           /* length of current match */
    int best_len = context->prev_length;        /* best match length so far */
    IPos limit;

#ifdef UNALIGNED_OK
    /* Compare two bytes at a time. Note: this is not always beneficial.
     * Try with and without -DUNALIGNED_OK to check.
     */
    register BYTE FAR *strend = context->window + context->strstart + MAX_MATCH - 1;
    register USHORT scan_start = *(USHORT FAR *)scan;
    register USHORT scan_end = *(USHORT FAR *)(scan + best_len - 1);
#else
    register BYTE FAR *strend = context->window + context->strstart + MAX_MATCH;
    register BYTE scan_end1 = scan[best_len - 1];
    register BYTE scan_end = scan[best_len];
#endif

    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */

    if (context->strstart > (IPos)MAX_DIST)
    {
        limit = (IPos)(context->strstart - MAX_DIST);
    }
    else
    {
        limit = NIL;
    }

//ATTENTION 01-Mar-1994 msliger What's this doing?
    /* Do not waste too much time if we already have a good match: */
    if (context->prev_length >= good_match)
    {
        chain_length >>= 2;
    }

    Assert(context,context->strstart <= window_size-MIN_LOOKAHEAD, "insufficient lookahead");

    do
    {
        Assert(context,cur_match < context->strstart, "no future");
        match = context->window + cur_match;

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2:
         */

#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)

        /* This code assumes sizeof(USHORT) == 2. Do not use
         * UNALIGNED_OK if your compiler uses a different size.
         */

        if ((*(USHORT FAR *)(match + best_len - 1) != scan_end) ||
            **(USHORT FAR *)match != scan_start))
        {
            continue;
        }

        /* It is not necessary to compare scan[2] and match[2] since they are
         * always equal when the other bytes match, given that the hash keys
         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
         * strstart+3, +5, ... up to strstart+257. We check for insufficient
         * lookahead only every 4th comparison; the 128th check will be made
         * at strstart+257. If (MAX_MATCH - 2) is not a multiple of 8, it is
         * necessary to put more guard bytes at the end of the window, or
         * to check more often for insufficient lookahead.
         */
        scan++;
        match++;

        do
        {
        } while ((*(USHORT FAR *)(scan += 2) == *(USHORT FAR *)(match += 2)) &&
                 (*(USHORT FAR *)(scan += 2) == *(USHORT FAR *)(match += 2)) &&
                 (*(USHORT FAR *)(scan += 2) == *(USHORT FAR *)(match += 2)) &&
                 (*(USHORT FAR *)(scan += 2) == *(USHORT FAR *)(match += 2)) &&
                 (scan < strend));

        /* Here, scan <= window+strstart+257 */

        Assert(context,scan <= window+(USHORT)(window_size-1), "wild scan");

        if (*scan == *match)
        {
            scan++;
        }

        len = (USHORT) (scan - strend + (MAX_MATCH-1));
        scan = strend - (MAX_MATCH-1);

#else /* UNALIGNED_OK */

        if ((match[best_len] != scan_end) ||
                (match[best_len-1] != scan_end1) || (*match != *scan) ||
                (*++match != scan[1]) || (*++match != scan[2]))
        {
            continue;
        }

        /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */

        /* duh you idiot whoever wrote this code.  MIN_MATCH is a defined */
        /* constant that can be changed, but if you do it breaks THIS */
        /* shitty code.  So now hack away using REAL_MIN. */

        scan += MIN_MATCH - 1;

        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */

        do
        {
        } while ((*++scan == *++match && *++scan == *++match) &&
                 (*++scan == *++match && *++scan == *++match) &&
                 (*++scan == *++match && *++scan == *++match) &&
                 (*++scan == *++match && *++scan == *++match) &&
                 (scan < strend));

        len = (int)(scan - strend + MAX_MATCH);

        scan = strend - MAX_MATCH;

#endif /* UNALIGNED_OK */

        if (len > best_len)
        {
            context->match_start = cur_match;
            best_len = len;

            if (len >= nice_match)
            {
                break;
            }

#ifdef UNALIGNED_OK
            scan_end = *(USHORT FAR *)(scan + best_len - 1);
#else
            scan_end1 = scan[best_len - 1];
            scan_end = scan[best_len];
#endif
        }
    } while (((cur_match = *(context->prev+(cur_match & WMASK))) > limit) &&
            (--chain_length != 0));

   /* if (chain_length == 0)                */
   /*   printf("Out of chain length\n");    */

    return best_len;
}
#endif /* ASMV */

/* --- check_match() ------------------------------------------------------ */

#ifdef DEBUG
/*
 * Check that the match at match_start is indeed a match.
 */
static void check_match(PMSZIP_COMPRESS_CONTEXT context,
        IPos start, IPos match, int length)
{
    /* check that the match is indeed a match */

#ifndef BIT16
    if (memcmp(context->window + match,
            context->window + start, length) != EQUAL)
#else
    if (_fmemcmp(context->window + match,
            context->window + start, length) != EQUAL)
#endif
    {
        context->fError = 1;
        printf("invalid match");
    }
}
#endif

/* --- deflate() ---------------------------------------------------------- */

/*
 * Processes a new input file and return its compressed length.
 */

#ifdef NO_LAZY

static ULONG deflate(PMSZIP_COMPRESS_CONTEXT context)
{
    IPos hash_head;         /* head of the hash chain */
    int flush;              /* set if current block must be flushed */
    int match_length = 0;   /* length of best match */

    context->prev_length = MIN_MATCH - 1;

    while (context->lookahead != 0)
    {
        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        if (context->lookahead > REAL_MIN-1)
        {
            INSERT_STRING(context, context->strstart, hash_head);
        }
        else
        {       /* make it do a literal, not adding to hash trees */
            hash_head = NIL;
            match_length = 0;
        }

        /* Find the longest match, discarding those <= prev_length.
         * At this point we have always match_length < MIN_MATCH
         */

        if ((hash_head != NIL) && (context->strstart - hash_head <= MAX_DIST) &&
                (context->strstart < 65533))
        {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */

            match_length = longest_match(context,hash_head);

            /* longest_match() sets match_start */

            if (match_length > context->lookahead)
            {
                match_length = context->lookahead;
            }
        }

        if (match_length >= MIN_MATCH)
        {
            check_match(context, context->strstart, context->match_start, match_length);

            flush = ct_tally(context,context->strstart-context->match_start, match_length - MIN_MATCH);

            context->lookahead -= match_length;
            match_length--; /* string at strstart already in hash table */

            do
            {
                context->strstart++;

                if (context->lookahead > REAL_MIN-1)
                {
                    INSERT_STRING(context, context->strstart, hash_head);
                }
                /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                 * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
                 * these bytes are garbage, but it does not matter since the
                 * next lookahead bytes will always be emitted as literals.
                 */
            } while (--match_length != 0);
        }
        else
        {
            /* No match, output a literal byte */

            flush = ct_tally(context, 0, context->window[context->strstart]);
            context->lookahead--;
        }

        context->strstart++;

        if (flush)
        {
            FLUSH_BLOCK(context,0);
            context->block_start = context->strstart;
        }
    }

    return FLUSH_BLOCK(context,1);      /* eof */
}

#else /* LAZY */

/*
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
static ULONG deflate(PMSZIP_COMPRESS_CONTEXT context)
{
    IPos hash_head;             /* head of hash chain */
    IPos prev_match;            /* previous match */
    int flush;                  /* set if current block must be flushed */
    int match_available = 0;    /* set if previous match exists */
    register int match_length;  /* length of best match */

    match_length = MIN_MATCH - 1;

    /* Process the input block */

    while (context->lookahead != 0)
    {
        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        if (context->lookahead > (REAL_MIN - 1))
        {
            INSERT_STRING(context, context->strstart, hash_head);
        }
        else    /* make it do a literal, not adding to hash trees */
        {
            hash_head = NIL;
            context->prev_length = 0;
        }

        /* Find the longest match, discarding those <= prev_length */

        context->prev_length = match_length;
        prev_match = context->match_start;
        match_length = MIN_MATCH - 1;

        if ((hash_head != NIL) && (context->prev_length < max_lazy_match) &&
                (context->strstart - hash_head <= MAX_DIST) &&
                (context->strstart < 65533))
        {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */

            match_length = longest_match(context,hash_head);
            /* longest_match() sets match_start */

            if (match_length > context->lookahead)
            {
                match_length = context->lookahead;
            }

            /* Ignore a length 3 match if it is too distant: */
            if ((match_length == MIN_MATCH) &&
                    ((context->strstart - context->match_start) > TOO_FAR))
            {
                /* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */
                match_length--;
            }
        }

        /* If there was a match at the previous step and the current
         * match is not better, output the previous match: */

        if ((context->prev_length >= MIN_MATCH) &&
                (match_length <= context->prev_length))
        {
            check_match(context, (IPos)(context->strstart-1), prev_match, context->prev_length);

            flush = ct_tally(context,context->strstart-1-prev_match,
                    context->prev_length - MIN_MATCH);

            /* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted.
             */

            context->lookahead -= context->prev_length-1;
            context->prev_length -= 2;

            do
            {
                context->strstart++;

                if (context->lookahead > REAL_MIN-1)
                {
                    INSERT_STRING(context, context->strstart, hash_head);
                }

                /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                 * always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
                 * these bytes are garbage, but it does not matter since the
                 * next lookahead bytes will always be emitted as literals.
                 */
            } while (--(context->prev_length) != 0);

            match_available = 0;
            match_length = MIN_MATCH-1;
            context->strstart++;
            if (flush)
            {
                FLUSH_BLOCK(context,0);
                context->block_start = context->strstart;
            }
        }
        else if (match_available)
        {
            /* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */
            Tracevv((stderr,"%c",context->window[(USHORT) (context->strstart-1)]));

            if (ct_tally(context, 0, context->window[(USHORT) (context->strstart-1)]))
            {
                FLUSH_BLOCK(context,0);
                context->block_start = context->strstart;
            }

            context->strstart++;
            context->lookahead--;
        }
        else
        {
            /* There is no previous match to compare with, wait for
             * the next step to decide.
             */
            match_available = 1;
            context->strstart++;
            context->lookahead--;
        }
    }

    if (match_available)
    {
        ct_tally(context, 0, context->window[(USHORT) (context->strstart-1)]);
    }

    return FLUSH_BLOCK(context,1);      /* eof */
}
#endif /* LAZY */

/* ------------------------------------------------------------------------ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\precomp.h ===
//**************************************************************************
//
//  Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
//
//  File:   precomp.h
//
//  Description:    Precompiled header file.
//
//  History:
//      02/20/98    CongpaY     Created
//
//**************************************************************************

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <d3dx8seg.h>

#include <stddef.h>
#include <stdio.h>
#include <xtl.h>

#include "memalloc.h"
#include "dpf.h"

#include "dxfile.h"

#include "xheader.h"
#include "xmemory.h"
#include "xparse.h"

#include "xlist.h"

#include "xprim.h"
#include "xstring.h"

#include "xobject.h"
#include "xtempl.h"
#include "xdata.h"
#include "xblob.h"

#include "xstrmrd.h"
#include "ximplapi.h"


#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dxg\d3dx8\xof6\nfmdeco.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1992,1993,1994,1995,1996
 *  Not copyrighted 1992 by Mark Adler
 *  All Rights Reserved.
 *
 *  NFMDECO.C -- memory-based decompressor
 *
 *  History:
 *      13-Feb-1994     msliger     revised type names, ie, UINT16 -> UINT.
 *                                  normalized MCI_MEMORY type.
 *      24-Feb-1994     msliger     Changed MDI_MEMORY to MI_MEMORY.
 *      17-Mar-1994     msliger     Updates for 32 bits.
 *      22-Mar-1994     msliger     Initial work to speed up.
 *      31-Mar-1994     msliger     Changed to private setjmp/longjmp.
 *      06-Apr-1994     msliger     Removed pack(1) for RISCs, added UNALIGNED
 *      12-Apr-1994     msliger     Eliminated setjmp/longjmp.  Optimized
 *                                  stored blocks.
 *      13-Apr-1994     msliger     Defined call convention for alloc/free.
 *      12-May-1994     msliger     ifdef'd 1's complement LARGE_STORED_BLOCKS
 *      07-Oct-1994     msliger     Numerous opts & API enhancements getting
 *                                  ready for ASM port.
 *      15-Nov-1994     msliger     Update source ptr during stored blocks.
 *                                  Reduced internal tables to anticipated
 *                                  sizes.  Reset IncrementalState after a
 *                                  resume during a stored block.  Make sure
 *                                  global bit buffer is empty after a stored
 *                                  block.  Removed refs to NFMalloc, NFMfree.
 *      12-Mar-1995     msliger     Enhanced DISPLAY_DECO output.
 *      25-May-1995     msliger     Dropped NFMuncompress, added NFM_Prepare()
 *                                  and NFM_Decompress().
 *      16-Apr-1996     msliger     Endian-independent block signature check.
 *      06-Nov-1996     msliger     Added support for multiple contexts.
 */

/* --- compilation options ------------------------------------------------ */

/* #define DISPLAY */           /* enables huf info dumping (BROKEN 'cuz we don't know tree size now) */
/* #define DISPLAY_DECO */      /* enables decompression dumping */
/* #define CK_DEBUG */          /* turns on error reporting */

/* --- preprocessor ------------------------------------------------------- */
#include <d3dx8seg.h>
#include <stdio.h>              /* for NULL */
#include <string.h>             /* for memset() */

#include "nfmdeco.h"            /* prototype verification */

#pragma intrinsic(memcpy)

#pragma warning(disable:4001)   /* no single-line comment balking */
#pragma warning(disable:4701)   /* duck PPC 10.00.XXXX compiler bug */

#ifndef _USHORT_DEFINED
#define _USHORT_DEFINED
typedef unsigned short USHORT;
#endif

#ifndef NEAR
#ifdef BIT16
#define NEAR near
#else
#define NEAR
#endif
#endif

typedef unsigned short BOOL;
#define TRUE 1
#define FALSE 0

/*  Huffman code lookup table entry--this entry is four bytes for machines
    that have 16-bit pointers (e.g. PC's in the small or medium model).
    Valid extra bits are 0..13.  e == 15 is EOB (end of block), e == 16
    means that v is a literal, 16 < e < 32 means that v is a pointer to
    the next table, which codes e - 16 bits, and lastly e == 99 indicates
    an unused code.  If a code with e == 99 is looked up, this implies an
    error in the data. */

/*  If POINTERS is defined, the tree is built using direct pointers
    Otherwise, the pointers in the tree are offsets from the beginning
    of the tree.  Offsets are space-efficient on a 32-bit implementation;
    pointers may be very slightly faster on the 16-bit implementation.  */

#define POINTERS 1

typedef struct huft
{
    BYTE e;                     /* number of extra bits or operation */
    BYTE b;                     /* number of bits in this code or subcode */
    union
    {
        USHORT n;               /* literal, length base, or distance base */
#ifdef POINTERS
        struct huft *t;         /* pointer to next level of table */
#else
        USHORT t;               /* 'pointer' to next table as offset in current table */
#endif
    } v;
} HUFF_TREE;

/* --- commentary --------------------------------------------------------- */

/*
    Inflate deflated (PKZIP's method 8 compressed) data.  The compression
    method searches for as much of the current string of bytes (up to a
    length of 258) in the previous 32K bytes.  If it doesn't find any
    matches (of at least length 3), it codes the next byte.  Otherwise, it
    codes the length of the matched string and its distance backwards from
    the current position.  There is a single Huffman code that codes both
    single bytes (called "literals") and match lengths.  A second Huffman
    code codes the distance information, which follows a length code.  Each
    length or distance code actually represents a base value and a number
    of "extra" (sometimes zero) bits to get to add to the base value.  At
    the end of each deflated block is a special end-of-block (EOB) literal/
    length code.  The decoding process is basically: get a literal/length
    code; if EOB then done; if a literal, emit the decoded byte; if a
    length then get the distance and emit the referred-to bytes from the
    sliding window of previously emitted data.

    There are (currently) three kinds of inflate blocks: stored, fixed, and
    dynamic.  The compressor deals with some chunk of data at a time, and
    decides which method to use on a chunk-by-chunk basis.  A chunk might
    typically be 32K or 64K.  If the chunk is uncompressible, then the
    "stored" method is used.  In this case, the bytes are simply stored as
    is, eight bits per byte, with none of the above coding.  The bytes are
    preceded by a count, since there is no longer an EOB code.

    If the data is compressible, then either the fixed or dynamic methods
    are used.  In the dynamic method, the compressed data is preceded by
    an encoding of the literal/length and distance Huffman codes that are
    to be used to decode this block.  The representation is itself Huffman
    coded, and so is preceded by a description of that code.  These code
    descriptions take up a little space, and so for small blocks, there is
    a predefined set of codes, called the fixed codes.  The fixed method is
    used if the block codes up smaller that way (usually for quite small
    chunks), otherwise the dynamic method is used.  In the latter case, the
    codes are customized to the probabilities in the current block, and so
    can code it much better than the pre-determined fixed codes.

    The Huffman codes themselves are decoded using a mutli-level table
    lookup, in order to maximize the speed of decoding plus the speed of
    building the decoding tables.  See the comments below that precede the
    LBITS and DBITS tuning parameters.


    Huffman code decoding is performed using a multi-level table lookup.
    The fastest way to decode is to simply build a lookup table whose
    size is determined by the longest code.  However, the time it takes
    to build this table can also be a factor if the data being decoded
    is not very long.  The most common codes are necessarily the
    shortest codes, so those codes dominate the decoding time, and hence
    the speed.  The idea is you can have a shorter table that decodes the
    shorter, more probable codes, and then point to subsidiary tables for
    the longer codes.  The time it costs to decode the longer codes is
    then traded against the time it takes to make longer tables.

    This results of this trade are in the variables LBITS and DBITS
    below.  LBITS is the number of bits the first level table for literal/
    length codes can decode in one step, and DBITS is the same thing for
    the distance codes.  Subsequent tables are also less than or equal to
    those sizes.  These values may be adjusted either when all of the
    codes are shorter than that, in which case the longest code length in
    bits is used, or when the shortest code is *longer* than the requested
    table size, in which case the length of the shortest code in bits is
    used.

    There are two different values for the two tables, since they code a
    different number of possibilities each.  The literal/length table
    codes 286 possible values, or in a flat code, a little over eight
    bits.  The distance table codes 30 possible values, or a little less
    than five bits, flat.  The optimum values for speed end up being
    about one bit more than those, so LBITS is 8+1 and DBITS is 5+1.
    The optimum values may differ though from machine to machine, and
    possibly even between compilers.  Your mileage may vary.


    Notes beyond the 1.93a appnote.txt:

    1.  Distance pointers never point before the beginning of the output
        stream.
    2.  Distance pointers can point back across blocks, up to 32k away.
    3.  There is an implied maximum of 7 bits for the bit length table and
        15 bits for the actual data.
    4.  If only one code exists, then it is encoded using one bit.  (Zero
        would be more efficient, but perhaps a little confusing.)  If two
        codes exist, they are coded using one bit each (0 and 1).
    5.  There is no way of sending zero distance codes--a dummy must be
        sent if there are none.  (History: a pre 2.0 version of PKZIP would
        store blocks with no distance codes, but this was discovered to be
        too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
        zero distance codes, which is sent as one code of zero bits in
        length.
    6.  There are up to 286 literal/length codes.  Code 256 represents the
        end-of-block.  Note however that the static length tree defines
        288 codes just to fill out the Huffman codes.  Codes 286 and 287
        cannot be used though, since there is no length base or extra bits
        defined for them.  Similarily, there are up to 30 distance codes.
        However, static trees define 32 codes (all 5 bits) to fill out the
        Huffman codes, but the last two had better not show up in the data.
    7.  Unzip can check dynamic Huffman blocks for complete code sets.
        The exception is that a single code would not be complete (see #4).
    8.  The five bits following the block type is really the number of
        literal codes sent minus 257.
    9.  Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
        (1+6+6).  Therefore, to output three times the length, you output
        three codes (1+1+1), whereas to output four times the same length,
        you only need two codes (1+3).  Hmm.
    10. In the tree reconstruction algorithm, Code = Code + Increment
        only if BitLength(i) is not zero.  (Pretty obvious.)
    11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
    12. Note: length code 284 can represent 227-258, but length code 285
        really is 258.  The last length deserves its own, short code
        since it gets used a lot in very redundant files.  The length
        258 is special since 258 - 3 (the min match length) is 255.
    13. The literal/length and distance code bit lengths are read as a
        single stream of lengths.  It is possible (and advantageous) for
        a repeat code (16, 17, or 18) to go across the boundary between
        the two sets of lengths.

    The inflate algorithm uses a sliding 32K byte window on the uncompressed
    stream to find repeated byte strings.  This is implemented here as a
    circular buffer.  The index is updated simply by incrementing and then
    and'ing with 0x7fff (32K-1).  This buffer is the uncompressed data output
    buffer.  When subsequent blocks are presented to be decompressed, the
    caller must return the buffer to Inflate() with the result of the last
    decompression still intact.


    Macros for Inflate() bit peeking and grabbing.
    The usage is:

        NEEDBITS(j)
        x = b & mask_bits[j];
        DUMPBITS(j)

    where NEEDBITS makes sure that b has at least j bits in it, and
    DUMPBITS removes the bits from b.  The macros use the variable k
    for the number of bits in b.  Normally, b and k are register
    variables for speed, and are initialized at the begining of a
    routine that uses these macros from a global bit buffer and count.

    If we assume that EOB will be the longest code, then we will never
    ask for bits with NEEDBITS that are beyond the end of the stream.
    So, NEEDBITS should not read any more bytes than are needed to
    meet the request.  Then no bytes need to be "returned" to the buffer
    at the end of the last block.

    However, this assumption is not true for fixed blocks--the EOB code
    is 7 bits, but the other literal/length codes can be 8 or 9 bits.
    (The EOB code is shorter than other codes becuase fixed blocks are
    generally short.  So, while a block always has an EOB, many other
    literal/length codes have a significantly lower probability of
    showing up at all.)  However, by making the first table have a
    lookup of seven bits, the EOB code will be found in that first
    lookup, and so will not require that too many bits be pulled from
    the stream.
*/

#define sNEWBLOCK       0               /* At beginning of new block */
#define sSTORE          1               /* Store operation in progress */
#define sHUFFTREE       2               /* Entering new match/ literal */
#define sDONE           3               /* Completed block, no data left */

#define FIX_HTL_SIZE    (520)           /* determined by observation */
#define FIX_HTD_SIZE    (32)            /* determined by observation */

#define FIX_B_LIT       9               /* determined by observation */
#define FIX_B_DIST      5               /* determined by observation */

#define HTL_SIZE        (800)           /* have seen up to 778 */
#define HTD_SIZE        (150)           /* have seen up to 140 */

/* --- local data --------------------------------------------------------- */

static HUFF_TREE fhtl[FIX_HTL_SIZE];    /* pre-defined decoding tree, */
static HUFF_TREE fhtd[FIX_HTD_SIZE];    /*   no need to instance this */

typedef struct _MSZIP_DECOMPRESS_CONTEXT {

    int lastBlock;              /* set 1 when last block has been read */
    int get_error;              /* flag set if we over-run input buffer */

    BYTE * inbuf;               /* input buffer */
    BYTE * outbuffer;           /* output pointer */
    BYTE * outstart;            /* beginning of buffer - needed for match copies */

    unsigned insize;            /* valid bytes in inbuf */
    unsigned inptr;             /* index of next byte to process in inbuf */

    unsigned outleft;           /* bytes remaining in output buffer request */
    unsigned bufavail;          /* bytes available in output buffer */

    ULONG bb;                   /* the global bit buffer */
    unsigned bk;                /* number of bits in global bit buffer */

    int IncrementalState;       /* what we were doing when we reached count */

    unsigned sstoreNBytes;      /* for STORE, number of bytes remaining in block */
    BYTE *sstorePointer;        /* for STORE, pointer to source buffer */

    HUFF_TREE * streeTL;        /* for HUFFTREE, saved literal table */
    HUFF_TREE * streeTD;        /* for HUFFTREE, saved distance table */
    int streeBL;                /* for HUFFTREE, saved bits in TL */
    int streeBD;                /* for HUFFTREE, saved bits in TD */
    BOOL streeIsMatch;          /* for HUFFTREE, saved is TRUE if match in progress */
    BYTE * streePointer;        /* for HUFFTREE MATCH, pointer to source bytes */
    unsigned streeNumber;       /* for HUFFTREE MATCH, number of bytes remaining */

    HUFF_TREE htl[HTL_SIZE];    /* the huffman tree for literals */
    HUFF_TREE htd[HTD_SIZE];    /* the huffman tree for distances */

} MSZIP_DECOMPRESS_CONTEXT, FAR *PMSZIP_DECOMPRESS_CONTEXT;

/* --- compression-related definitions ------------------------------------ */

#define NFM_SIG0        'C' /* signature in a block = "CK" */
#define NFM_SIG1        'K'
#define NFM_SIG_LEN 2

#ifndef WSIZE
#define WSIZE 0x8000        /* window size--must be a power of two, and */
#endif                      /*  at least 32K for zip's deflate method */

#define     STORED      0   /* block is simply stored */
#define     FIXED       1   /* block uses the fixed tree */
#define     DYNAMIC     2   /* block uses a dynamic tree */

#define     LBITS       9   /* bits in base literal/length lookup table */
#define     DBITS       6   /* bits in base distance lookup table */

/* If BMAX needs to be larger than 16, then h and x[] should be ULONG. */

#define     BMAX    16      /* max. bit length of any code (16 for explode) */
#define     N_MAX   288     /* maximum number of codes in any set */

/* Tables for deflate from PKZIP's appnote.txt. */

static unsigned border[] =  /* Order of the bit length code lengths */
{
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
};

static USHORT cplens[] =      /* Copy lengths for literal codes 257..285 */
{
    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
    35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
};

static USHORT cplext[] =      /* Extra bits for literal codes 257..285 */
{
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
    3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
};                          /* 99 -> invalid */

static USHORT cpdist[] =      /* Copy offsets for distance codes 0..29 */
{
    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
    257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
    8193, 12289, 16385, 24577
};

static USHORT cpdext[] =      /* Extra bits for distance codes */
{
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
    7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13
};

static USHORT mask_bits[] =   /* masks to get # bits from a value */
{
    0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F,
    0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF,
    0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF
};

/* --- decompressor definitions ------------------------------------------- */

/* ATTENTION 05-Jun-95 MSliger This function will never fail: doesn't advance */

/*  get_char() retrieves the next character from the input buffer.  If the
    input pointer extends beyond the buffer size, the error flag is set, and
    zero is retur