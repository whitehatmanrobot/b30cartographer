3f5f1cf4, 0x3f5598bf, 0x3f4b8541, 0x3f40da28, 0x3f358ea6, 0x3f299972, 0x3f1cf0ba, 0x3f0f8a20, 0x3f015ab3, 0x3ef256e5, 0x3ee27286, 0x3ed1a0b8, 0x3ebfd3e9, 0x3eacfdcc, 0x3e990f4b, 0x3e83f883, 0x3e6da8b5, 0x3e560e41, 0x3e3d1698, 0x3e22ae33, 0x3e06c08a, 0x3de9380a, 0x3dc9fe06, 0x3da8faaf, 0x3d86150c, 0x3d6132ef, 0x3d3a38e4, 0x3d110a32, 0x3ce588cf, 0x3cb7954f, 0x3c870eef, 0x3c53d37c, 0x3c1dbf5b, 0x3be4ad84, 0x3ba8777d, 0x3b68f562, 0x3b25fde8, 0x3adf6661, 0x3a9502cf, 0x3a46a5f2, 0x39f4215a, 0x399d4589, 0x3941e20f, 0x38e1c5ba, 0x387cbebf, 0x38129afc, 0x37a32838, 0x372e346e, 0x36b38e32, 0x3633050b, 0x35ac69ed, 0x351f8fb3, 0x348c4bb0, 0x33f27640, 0x3351eb71, 0x32aa8bac, 0x31fc3c66, 0x3146e8d1, 0x308a8290, 0x2fc70254, 0x2efc686e, 0x2e2abd32, 0x2d521134, 0x2c727d2f, 0x2b8c2198, 0x2a9f25a1, 0x29abb5a3, 0x28b2009b, 0x27b23494, 0x26ac7990, 0x25a0ea7b, 0x248f8b5e, 0x23783bb4, 0x225aa2ea, 0x213613b5, 0x20096000, 0x1ed29165, 0x1d8e6c27, 0x1c378009, 0x1ac42369, 0x19214197, 0x1720899b, 0x1720899b, 0x1720899b },
    { 0x3f962e69, 0x3f962e69, 0x3f8fe929, 0x3f894523, 0x3f823ccd, 0x3f7aca45, 0x3f72e758, 0x3f6a8d74, 0x3f61b5aa, 0x3f5858a3, 0x3f4e6e9f, 0x3f43ef6c, 0x3f38d261, 0x3f2d0e5b, 0x3f2099b0, 0x3f136a2c, 0x3f05750b, 0x3ef6aeee, 0x3ee70bd8, 0x3ed67f1f, 0x3ec4fb6d, 0x3eb272ad, 0x3e9ed609, 0x3e8a15e1, 0x3e7421be, 0x3e5ce84b, 0x3e44574a, 0x3e2a5b89, 0x3e0ee0dd, 0x3df1d212, 0x3dd318e5, 0x3db29df6, 0x3d9048c4, 0x3d6bffa0, 0x3d45a7a4, 0x3d1d24ab, 0x3cf2594b, 0x3cc526cf, 0x3c956d2c, 0x3c630b06, 0x3c2ddda8, 0x3bf5c105, 0x3bba8fbb, 0x3b7c231b, 0x3b3a5330, 0x3af4f6cc, 0x3aabe399, 0x3a5eee36, 0x3a0dea49, 0x39b8aab0, 0x395f01a2, 0x3900c0ea, 0x389dba1f, 0x3835bef0, 0x37c8a176, 0x37563490, 0x36de4c53, 0x3660be81, 0x35dd630d, 0x355414b1, 0x34c4b18e, 0x342f1bd5, 0x33933a7d, 0x32f0f9fd, 0x32484d01, 0x31992d22, 0x30e39b88, 0x3027a17a, 0x2f6550b7, 0x2e9cc3a9, 0x2dce1d34, 0x2cf9882f, 0x2c1f363e, 0x2b3f5e0a, 0x2a5a3881, 0x296ffcfa, 0x2880dbc7, 0x278cf6bf, 0x269456f9, 0x2596de6d, 0x2494335c, 0x238ba1b0, 0x227beaef, 0x2162f5da, 0x203d3c3d, 0x1f04a33d, 0x1dadc7f2, 0x1c2020c3, 0x1c2020c3 },
    { 0x3facd242, 0x3fa7e386, 0x3fa2aa1f, 0x3f9d21ac, 0x3f974588, 0x3f9110ca, 0x3f8a7e42, 0x3f83886f, 0x3f7c2983, 0x3f745b58, 0x3f6c1771, 0x3f6356ee, 0x3f5a128e, 0x3f5042a4, 0x3f45df15, 0x3f3adf50, 0x3f2f3a4a, 0x3f22e670, 0x3f15d9b1, 0x3f080960, 0x3ef96a43, 0x3ee9f07c, 0x3ed98f86, 0x3ec83a2e, 0x3eb5e28d, 0x3ea279f8, 0x3e8df0fe, 0x3e78375a, 0x3e613bf0, 0x3e48ecba, 0x3e2f36ca, 0x3e140637, 0x3df7461c, 0x3dd8e086, 0x3db8be71, 0x3d96c7be, 0x3d72e32d, 0x3d4cf64d, 0x3d24e583, 0x3cfa93f6, 0x3ccde398, 0x3c9eb518, 0x3c6ce7e8, 0x3c385a3d, 0x3c00e913, 0x3bc67032, 0x3b88ca3c, 0x3b47d0bd, 0x3b035c3c, 0x3abb4455, 0x3a6f5fe0, 0x3a1f850d, 0x39cb899c, 0x39734316, 0x3916870d, 0x38b52b68, 0x384f06c1, 0x37e3f0c9, 0x3773c2be, 0x36fe57ea, 0x36838e36, 0x360346c0, 0x357d6692, 0x34f1d749, 0x346087d9, 0x33c96d4a, 0x332c8377, 0x3289cdc6, 0x31e157bf, 0x31333597, 0x307f847b, 0x2fc66aa2, 0x2f0816ff, 0x2e44c088, 0x2d7ca4dd, 0x2cb00638, 0x2bdf2870, 0x2b0a4cc5, 0x2a31ac27, 0x29556f6c, 0x2875a4b3, 0x2792308b, 0x26aab8a3, 0x25be8391, 0x24cc4528, 0x23d1c4fa, 0x22cb33bf, 0x21b1bb02, 0x21b1bb02 },
    { 0x3fba7f26, 0x3fb65f8c, 0x3fb20179, 0x3fad6141, 0x3fa87afe, 0x3fa34a92, 0x3f9dcba1, 0x3f97f990, 0x3f91cf7f, 0x3f8b4844, 0x3f845e6b, 0x3f7d0c2f, 0x3f754b75, 0x3f6d15cc, 0x3f646460, 0x3f5b2ffd, 0x3f517106, 0x3f471f6c, 0x3f3c32b1, 0x3f30a1d8, 0x3f246366, 0x3f176d58, 0x3f09b51b, 0x3efb2f88, 0x3eebd0dd, 0x3edb8cae, 0x3eca55e8, 0x3eb81ec0, 0x3ea4d8b0, 0x3e90746c, 0x3e7ae1d8, 0x3e641006, 0x3e4bed22, 0x3e326677, 0x3e176859, 0x3dfade27, 0x3ddcb23b, 0x3dbccde7, 0x3d9b196e, 0x3d777bfc, 0x3d51db9c, 0x3d2a1d3e, 0x3d0024ab, 0x3cd3d488, 0x3ca50e54, 0x3c73b270, 0x3c3fa020, 0x3c08b597, 0x3bced007, 0x3b91cbb0, 0x3b5183f7, 0x3b0dd389, 0x3ac6947a, 0x3a7ba075, 0x3a2cd0f1, 0x39d9ff70, 0x398305c7, 0x3927be79, 0x38c80514, 0x3863b6a5, 0x37fab231, 0x378cd949, 0x371a109b, 0x36a240a3, 0x36255657, 0x35a343e8, 0x351c0181, 0x348f8e0e, 0x33fdeff5, 0x336735c2, 0x32cb76bd, 0x322ad352, 0x3185753e, 0x30db8f76, 0x302d5da7, 0x2f7b2336, 0x2ec529a2, 0x2e0bbe25, 0x2d4f2e67, 0x2c8fc3fd, 0x2bcdbe72, 0x2b094b48, 0x2a427b2f, 0x29793311, 0x28ad1653, 0x27dd6585, 0x2708c753, 0x262ce530, 0x2545a324 },
    { 0x3fc5cac1, 0x3fc25662, 0x3fbeada1, 0x3fbacd6a, 0x3fb6b277, 0x3fb25952, 0x3fadbe51, 0x3fa8dd97, 0x3fa3b307, 0x3f9e3a4d, 0x3f986ed3, 0x3f924bbc, 0x3f8bcbe7, 0x3f84e9e6, 0x3f7d9ffc, 0x3f75e816, 0x3f6dbbc8, 0x3f65144b, 0x3f5bea72, 0x3f5236aa, 0x3f47f0f2, 0x3f3d10d5, 0x3f318d65, 0x3f255d34, 0x3f18764e, 0x3f0ace34, 0x3efc59cf, 0x3eed0d71, 0x3edcdcc6, 0x3ecbbad4, 0x3eb999ec, 0x3ea66ba7, 0x3e9220da, 0x3e7ca993, 0x3e65f50d, 0x3e4df1a9, 0x3e348ce5, 0x3e19b359, 0x3dfd50a9, 0x3ddf4f85, 0x3dbf999c, 0x3d9e179f, 0x3d7ab134, 0x3d554cfa, 0x3d2dd084, 0x3d04205c, 0x3cd82005, 0x3ca9b1ff, 0x3c78b7d3, 0x3c45121d, 0x3c0ea0a3, 0x3bd54261, 0x3b98d5b2, 0x3b593867, 0x3b1647f8, 0x3acfe1bb, 0x3a85e315, 0x3a3829cc, 0x39e69455, 0x39910235, 0x3937546a, 0x38d96deb, 0x3877342e, 0x38108fbc, 0x37a56cdd, 0x3735bc40, 0x36c173bc, 0x36488f0d, 0x35cb109a, 0x3549022d, 0x34c275a8, 0x3437859b, 0x33a855b9, 0x33151318, 0x327df42b, 0x31e33869, 0x31452781, 0x30a41006, 0x3000457e, 0x2f5a1dac, 0x2eb1ecf2, 0x2e08019b, 0x2d5c9dbb, 0x2cafef34, 0x2c020509, 0x2b52c097, 0x2aa1bfe7, 0x29ee3b94, 0x2936cc73 },
    { 0x3fcf2dc9, 0x3fcc47ce, 0x3fc935da, 0x3fc5f555, 0x3fc2837e, 0x3fbedd6f, 0x3fbb0011, 0x3fb6e823, 0x3fb29232, 0x3fadfa98, 0x3fa91d77, 0x3fa3f6ba, 0x3f9e820f, 0x3f98bae2, 0x3f929c5d, 0x3f8c2163, 0x3f85448a, 0x3f7e001a, 0x3f764e06, 0x3f6e27ea, 0x3f658703, 0x3f5c642d, 0x3f52b7de, 0x3f487a1c, 0x3f3da27d, 0x3f32281f, 0x3f2601a0, 0x3f192519, 0x3f0b8819, 0x3efd1f9d, 0x3eede009, 0x3eddbd20, 0x3ecca9ff, 0x3eba9914, 0x3ea77c18, 0x3e934406, 0x3e7de114, 0x3e6742af, 0x3e4f576f, 0x3e360d13, 0x3e1b507d, 0x3dff0da7, 0x3de12fa4, 0x3dc1a099, 0x3da049bb, 0x3d7d134f, 0x3d57e4a8, 0x3d30a430, 0x3d073767, 0x3cdb82ef, 0x3cad6a99, 0x3c7cd174, 0x3c4999e5, 0x3c13a5bd, 0x3bdad664, 0x3b9f0cfa, 0x3b602a89, 0x3b1e1048, 0x3ad89fd3, 0x3a8fbb87, 0x3a4346db, 0x39f326c5, 0x399f4237, 0x394782a2, 0x38ebd487, 0x388c281d, 0x382871f6, 0x37c0abb9, 0x3754d4dc, 0x36e4f365, 0x3671149a, 0x35f94db7, 0x357dbc7b, 0x34fe879d, 0x347bdf12, 0x33f5fc06, 0x336d2099, 0x32e19728, 0x3253b126, 0x31c3c571, 0x31322dfd, 0x309f44d8, 0x300b6050, 0x2f76ce22, 0x2ee1cd72, 0x2e4c8708, 0x2db7031f, 0x2d211b1f, 0x2c8a645a },
    { 0x3fd702c5, 0x3fd493a9, 0x3fd1ff9b, 0x3fcf446b, 0x3fcc5fcb, 0x3fc94f46, 0x3fc61047, 0x3fc2a00e, 0x3fbefbb5, 0x3fbb2029, 0x3fb70a2a, 0x3fb2b646, 0x3fae20da, 0x3fa9460b, 0x3fa421c5, 0x3f9eafb9, 0x3f98eb57, 0x3f92cfcb, 0x3f8c57fb, 0x3f857e83, 0x3f7e3dad, 0x3f768f72, 0x3f6e6d74, 0x3f65d0f4, 0x3f5cb2d7, 0x3f530b98, 0x3f48d348, 0x3f3e0184, 0x3f328d76, 0x3f266dc7, 0x3f1998a0, 0x3f0c039e, 0x3efda3d2, 0x3eee6db4, 0x3ede551f, 0x3ecd4d4d, 0x3ebb48cc, 0x3ea8397b, 0x3e941080, 0x3e7ebe46, 0x3e683272, 0x3e505be3, 0x3e3728aa, 0x3e1c8606, 0x3e00605f, 0x3de2a34a, 0x3dc33983, 0x3da20cee, 0x3d7f06a1, 0x3d5a0ee0, 0x3d330d2d, 0x3d09e855, 0x3cde867a, 0x3cb0cd2f, 0x3c80a18f, 0x3c4de860, 0x3c18863a, 0x3be05fb9, 0x3ba559b2, 0x3b67597f, 0x3b264542, 0x3ae2044a, 0x3a9a7f71, 0x3a4fa195, 0x3a015818, 0x39af936e, 0x395a47b5, 0x39016d60, 0x38a501e3, 0x38450863, 0x37e18a72, 0x377a98b3, 0x37104b83, 0x36a2c37d, 0x363229e5, 0x35beb0da, 0x35489359, 0x34d014e8, 0x345580ee, 0x33d929a2, 0x335b667f, 0x32dc923e, 0x325d0837, 0x31dd2132, 0x315d2f7f, 0x30dd7a44, 0x305e37c9, 0x2fdf864b, 0x2f61627d },
    { 0x3fdd9018, 0x3fdb847a, 0x3fd959cc, 0x3fd70e39, 0x3fd49fcd, 0x3fd20c7a, 0x3fcf5211, 0x3fcc6e44, 0x3fc95ea0, 0x3fc6208f, 0x3fc2b154, 0x3fbf0e09, 0x3fbb339d, 0x3fb71ed1, 0x3fb2cc34, 0x3fae3825, 0x3fa95eca, 0x3fa43c13, 0x3f9ecbb1, 0x3f990917, 0x3f92ef75, 0x3f8c79b3, 0x3f85a270, 0x3f7e63fc, 0x3f76b852, 0x3f6e991b, 0x3f65ff9d, 0x3f5ce4c5, 0x3f534114, 0x3f490ca4, 0x3f3e3f1e, 0x3f32cfb6, 0x3f26b525, 0x3f19e5a3, 0x3f0c56e1, 0x3efdfe03, 0x3eeecf9c, 0x3edebfa7, 0x3ecdc17f, 0x3ebbc7da, 0x3ea8c4c9, 0x3e94a9aa, 0x3e7f6729, 0x3e68ed3a, 0x3e512b16, 0x3e380f3a, 0x3e1d8761, 0x3e018088, 0x3de3e6f1, 0x3dc4a623, 0x3da3a8f0, 0x3d80d983, 0x3d5c216a, 0x3d3569a6, 0x3d0c9abd, 0x3ce19cdd, 0x3cb457f8, 0x3c84b3e9, 0x3c5298a7, 0x3c1dee7e, 0x3be69e4f, 0x3bac91dc, 0x3b6fb420, 0x3b2ff1b4, 0x3aed393e, 0x3aa77bee, 0x3a5eae06, 0x3a12c76e, 0x39c3c453, 0x3971a5cb, 0x391c727d, 0x38c43747, 0x386907df, 0x380aff61, 0x37aa40c4, 0x3746f735, 0x36e15632, 0x3679997d, 0x361004bc, 0x35a4e2c7, 0x353884a1, 0x34cb3ffe, 0x345d6d6b, 0x33ef65fc, 0x3381808d, 0x33140e8f, 0x32a75852, 0x323b98b7, 0x31d0f817 },
    { 0x3fe30dd5, 0x3fe155a1, 0x3fdf834e, 0x3fdd9550, 0x3fdb8a03, 0x3fd95fac, 0x3fd71474, 0x3fd4a66b, 0x3fd21381, 0x3fcf5987, 0x3fcc7631, 0x3fc9670d, 0x3fc62984, 0x3fc2badb, 0x3fbf182c, 0x3fbb3e68, 0x3fb72a50, 0x3fb2d875, 0x3fae4537, 0x3fa96cbf, 0x3fa44afc, 0x3f9edba4, 0x3f991a2a, 0x3f9301c2, 0x3f8c8d57, 0x3f85b78d, 0x3f7e7ab5, 0x3f76d0d3, 0x3f6eb392, 0x3f661c42, 0x3f5d03d5, 0x3f5362d8, 0x3f49316e, 0x3f3e674d, 0x3f32fbb7, 0x3f26e578, 0x3f1a1adb, 0x3f0c91aa, 0x3efe3f25, 0x3eef1802, 0x3edf1060, 0x3ece1bca, 0x3ebc2d2e, 0x3ea936db, 0x3e952a7c, 0x3e7ff915, 0x3e699304, 0x3e51e7fe, 0x3e38e70f, 0x3e1e7ea0, 0x3e029c76, 0x3de52dbe, 0x3dc61f13, 0x3da55c8e, 0x3d82d1d5, 0x3d5e6a2f, 0x3d3810a4, 0x3d0fb017, 0x3ce53371, 0x3cb885d1, 0x3c8992be, 0x3c58466e, 0x3c248e0c, 0x3bee580e, 0x3bb59497, 0x3b7a35e0, 0x3b3c30b4, 0x3afb7ceb, 0x3ab81600, 0x3a71fb9a, 0x3a29322e, 0x39ddc393, 0x398fbf9c, 0x393f3ca1, 0x38ec57fc, 0x38973667, 0x38400438, 0x37e6f56b, 0x378c4579, 0x373036e4, 0x36d3127c, 0x3675264f, 0x3616c441, 0x35b84050, 0x3559ee80, 0x34fc207c, 0x349f22e1, 0x34433a51, 0x33e8a02a },
    { 0x3fe7a969, 0x3fe6373a, 0x3fe4af12, 0x3fe30fa2, 0x3fe1578c, 0x3fdf8558, 0x3fdd977b, 0x3fdb8c52, 0x3fd96222, 0x3fd71714, 0x3fd4a937, 0x3fd2167d, 0x3fcf5cb8, 0x3fcc799b, 0x3fc96ab4, 0x3fc62d6e, 0x3fc2bf0f, 0x3fbf1cb1, 0x3fbb4345, 0x3fb72f8e, 0x3fb2de1f, 0x3fae4b59, 0x3fa97365, 0x3fa45236, 0x3f9ee383, 0x3f9922c4, 0x3f930b2d, 0x3f8c97af, 0x3f85c2f1, 0x3f7e874b, 0x3f76dec5, 0x3f6ec313, 0x3f662d8d, 0x3f5d172e, 0x3f53788f, 0x3f4949e3, 0x3f3e82f0, 0x3f331b0b, 0x3f270916, 0x3f1a4379, 0x3f0cc01e, 0x3efe746c, 0x3eef5545, 0x3edf56fe, 0x3ece6d62, 0x3ebc8ba8, 0x3ea9a478, 0x3e95a9e4, 0x3e808d6c, 0x3e6a3ffc, 0x3e52b1f4, 0x3e39d327, 0x3e1f92e8, 0x3e03e010, 0x3de6a90d, 0x3dc7dbf5, 0x3da76699, 0x3d8536a2, 0x3d6139ae, 0x3d3b5d7b, 0x3d139014, 0x3ce9c005, 0x3cbddc9d, 0x3c8fd635, 0x3c5f9e82, 0x3c2d28f3, 0x3bf86b17, 0x3bc15d0e, 0x3b87fa08, 0x3b4c40c1, 0x3b0e340c, 0x3acddb64, 0x3a8b436b, 0x3a467e75, 0x39ffa4fc, 0x39b6d601, 0x396c374f, 0x391ff59f, 0x38d24484, 0x38835e23, 0x383382b1, 0x37e2f7a0, 0x37920691, 0x3740fbf4, 0x36f02565, 0x369fcfd2, 0x36504564, 0x3601cb44, 0x35b49f43 },
    { 0x3feb880e, 0x3fea50b1, 0x3fe906d7, 0x3fe7a967, 0x3fe63739, 0x3fe4af13, 0x3fe30fa6, 0x3fe15792, 0x3fdf8561, 0x3fdd9788, 0x3fdb8c65, 0x3fd9623a, 0x3fd71734, 0x3fd4a960, 0x3fd216b1, 0x3fcf5cf9, 0x3fcc79eb, 0x3fc96b17, 0x3fc62de9, 0x3fc2bfa5, 0x3fbf1d67, 0x3fbb4422, 0x3fb7309a, 0x3fb2df62, 0x3fae4cde, 0x3fa9753a, 0x3fa4546a, 0x3f9ee628, 0x3f9925ef, 0x3f930ef8, 0x3f8c9c39, 0x3f85c85e, 0x3f7e8dc7, 0x3f76e683, 0x3f6ecc4f, 0x3f663890, 0x3f5d244f, 0x3f538834, 0x3f495c85, 0x3f3e991e, 0x3f333571, 0x3f27287f, 0x3f1a68d6, 0x3f0cec8b, 0x3efea93c, 0x3eef9408, 0x3edfa18f, 0x3ecec5f1, 0x3ebcf4cf, 0x3eaa2149, 0x3e963e00, 0x3e813d1c, 0x3e6b1052, 0x3e53a8e9, 0x3e3af7c6, 0x3e20ed7d, 0x3e057a5d, 0x3de88e8b, 0x3dca1a1b, 0x3daa0d31, 0x3d885823, 0x3d64ebb1, 0x3d3fb92e, 0x3d18b2c6, 0x3cefcbc1, 0x3cc4f8d0, 0x3c98306c, 0x3c696b31, 0x3c38a44d, 0x3c05d9f1, 0x3bd10dc8, 0x3b9a4575, 0x3b618b0a, 0x3b26ed86, 0x3aea813c, 0x3aac6035, 0x3a6caa78, 0x3a2b862b, 0x39e91fa0, 0x39a5a91e, 0x39615a84, 0x391c70ac, 0x38d72c91, 0x3891d239, 0x384ca765, 0x3807f20a, 0x37c3f6a9, 0x3780f686, 0x373f2dce },
    { 0x3feec885, 0x3fedc297, 0x3fecad1c, 0x3feb8726, 0x3fea4fbc, 0x3fe905d5, 0x3fe7a858, 0x3fe6361c, 0x3fe4ade7, 0x3fe30e6b, 0x3fe15648, 0x3fdf8408, 0x3fdd9620, 0x3fdb8aed, 0x3fd960b3, 0x3fd7159e, 0x3fd4a7bc, 0x3fd21500, 0x3fcf5b3d, 0x3fcc7825, 0x3fc9694a, 0x3fc62c18, 0x3fc2bdd4, 0x3fbf1b9d, 0x3fbb4265, 0x3fb72ef2, 0x3fb2ddda, 0x3fae4b81, 0x3fa97418, 0x3fa45395, 0x3f9ee5b7, 0x3f9925fd, 0x3f930fa6, 0x3f8c9dae, 0x3f85cac9, 0x3f7e9160, 0x3f76eb90, 0x3f6ed320, 0x3f664186, 0x3f5d2fde, 0x3f5396e6, 0x3f496f00, 0x3f3eb026, 0x3f3351f0, 0x3f274b8b, 0x3f1a93ba, 0x3f0d20d0, 0x3efee8b4, 0x3eefe0db, 0x3edffe4e, 0x3ecf35a4, 0x3ebd7b0e, 0x3eaac251, 0x3e96fed7, 0x3e8223ad, 0x3e6c239a, 0x3e54f122, 0x3e3c7e9f, 0x3e22be56, 0x3e07a292, 0x3deb1dc2, 0x3dcd22a2, 0x3dada467, 0x3d8c96f1, 0x3d69ef0b, 0x3d45a2a8, 0x3d1fa935, 0x3cf7fbea, 0x3cce9625, 0x3ca375cf, 0x3c769bc5, 0x3c480c41, 0x3c17cf4c, 0x3be5f125, 0x3bb282a5, 0x3b7d9997, 0x3b4750fd, 0x3b0fc93c, 0x3ad72824, 0x3a9d98db, 0x3a634b8e, 0x3a2874fd, 0x39ed4dca, 0x39b2119a, 0x3976fdfe, 0x393c5136, 0x390248cf, 0x38c9202e, 0x38910f0a },
    { 0x3ff18456, 0x3ff0a7fb, 0x3fefbe88, 0x3feec739, 0x3fedc139, 0x3fecabaa, 0x3feb85a0, 0x3fea4e20, 0x3fe90423, 0x3fe7a68e, 0x3fe6343a, 0x3fe4abec, 0x3fe30c56, 0x3fe15419, 0x3fdf81be, 0x3fdd93ba, 0x3fdb886a, 0x3fd95e15, 0x3fd712e3, 0x3fd4a4e6, 0x3fd21210, 0x3fcf5834, 0x3fcc7506, 0x3fc96618, 0x3fc628d7, 0x3fc2ba8a, 0x3fbf1850, 0x3fbb3f1f, 0x3fb72bbd, 0x3fb2dac4, 0x3fae489b, 0x3fa97177, 0x3fa45152, 0x3f9ee3f0, 0x3f9924d8, 0x3f930f51, 0x3f8c9e5e, 0x3f85ccc0, 0x3f7e94ed, 0x3f76f111, 0x3f6edb07, 0x3f664c5a, 0x3f5d3e41, 0x3f53a99a, 0x3f4986ea, 0x3f3ece59, 0x3f3377b4, 0x3f277a64, 0x3f1acd75, 0x3f0d6793, 0x3eff3f08, 0x3ef049c5, 0x3ee07d5d, 0x3ecfcf11, 0x3ebe33d4, 0x3eaba054, 0x3e980907, 0x3e836237, 0x3e6da01b, 0x3e56b6e6, 0x3e3e9ae4, 0x3e25409f, 0x3e0a9cff, 0x3deea575, 0x3dd15033, 0x3db29463, 0x3d926a62, 0x3d70cc12, 0x3d4db520, 0x3d29235d, 0x3d03171b, 0x3cdb9383, 0x3cb29eff, 0x3c884390, 0x3c5c8f2b, 0x3c2f9404, 0x3c0168d4, 0x3bd228fe, 0x3ba1f4a4, 0x3b70f096, 0x3b3f461c, 0x3b0d2296, 0x3adab6f0, 0x3aa836eb, 0x3a75d836, 0x3a43d167, 0x3a1258d3, 0x39e1a356, 0x39b1e30e }
};

// k  min  0.000038014 max  0.901921617 range 23725.941121027
COEFF CVoiceFilter::m_aK[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC] =
{
    { 0x00032fb7, 0x00032fb7, 0x00032fb7, 0x00032fb7, 0x00039311, 0x0004027d, 0x00047f6f, 0x00050b89, 0x0005a89f, 0x000658bf, 0x00071e32, 0x0007fb8a, 0x0008f3a7, 0x000a09bf, 0x000b416a, 0x000c9eae, 0x000e260c, 0x000fdc89, 0x0011c7c5, 0x0013ee09, 0x00165657, 0x00190887, 0x001c0d5a, 0x001f6e92, 0x00233715, 0x0027730c, 0x002c3003, 0x00317d14, 0x00376b12, 0x003e0cb8, 0x004576de, 0x004dc0b3, 0x005703fd, 0x00615d5f, 0x006ceca2, 0x0079d50b, 0x00883db3, 0x009851ec, 0x00aa41a6, 0x00be41e5, 0x00d48d3b, 0x00ed644d, 0x01090e5d, 0x0127d9e1, 0x014a1d27, 0x017036f2, 0x019a8f31, 0x01c997b3, 0x01fdccdf, 0x0237b678, 0x0277e85a, 0x02bf033e, 0x030db57b, 0x0364bbb8, 0x03c4e1a3, 0x042f028a, 0x04a409f9, 0x0524f42d, 0x05b2ce8b, 0x064eb7ea, 0x06f9e0df, 0x07b58bf7, 0x08830de9, 0x0963cdfd, 0x0a594697, 0x0b650650, 0x0c88b1bf, 0x0dc60696, 0x0f1ee09f, 0x1095418f, 0x122b5d31, 0x13e3abd0, 0x15c1061b, 0x17c6cf5a, 0x19f935b3, 0x1c5d95b5, 0x1efb189a, 0x21dbb93a, 0x250e08cc, 0x28a87844, 0x2cd00bf9, 0x31c7ef3c, 0x381d9404, 0x381d9404, 0x381d9404, 0x381d9404, 0x381d9404, 0x381d9404, 0x381d9404 },
    { 0x0002542f, 0x0002542f, 0x00029cf4, 0x0002ee96, 0x00034a2a, 0x0003b0e4, 0x0004241e, 0x0004a55e, 0x00053655, 0x0005d8ec, 0x00068f45, 0x00075bc3, 0x00084113, 0x00094236, 0x000a6286, 0x000ba5c6, 0x000d102b, 0x000ea66b, 0x00106dcb, 0x00126c30, 0x0014a832, 0x00172933, 0x0019f772, 0x001d1c25, 0x0020a19b, 0x00249354, 0x0028fe2c, 0x002df07b, 0x00337a42, 0x0039ad5f, 0x00409dba, 0x00486185, 0x00511179, 0x005ac91c, 0x0065a70e, 0x0071cd5c, 0x007f61de, 0x008e8e97, 0x009f8226, 0x00b27037, 0x00c79204, 0x00df26dd, 0x00f974b5, 0x0116c8c2, 0x0137781e, 0x015be072, 0x018468a3, 0x01b18194, 0x01e3a6d3, 0x021b5f5b, 0x02593e48, 0x029de384, 0x02e9fc65, 0x033e443d, 0x039b84c3, 0x0402965f, 0x04746041, 0x04f1d845, 0x057c0283, 0x0613f09c, 0x06bac0a3, 0x07719b9f, 0x0839b3aa, 0x091441a3, 0x0a028282, 0x0b05b462, 0x0c1f1374, 0x0d4fd70b, 0x0e992f29, 0x0ffc430c, 0x117a318a, 0x13141429, 0x14cb0677, 0x16a033a0, 0x1894ed45, 0x1aaad042, 0x1ce3feeb, 0x1f437e0e, 0x21cdcdc6, 0x2489f176, 0x27835b3b, 0x2acde79e, 0x2e8f9163, 0x331f4566, 0x39b91572, 0x39b91572, 0x39b91572, 0x39b91572, 0x39b91572 },
    { 0x00022384, 0x00022384, 0x00026663, 0x0002b169, 0x00030596, 0x00036405, 0x0003cdf5, 0x000444cd, 0x0004ca1f, 0x00055faa, 0x00060769, 0x0006c38f, 0x00079695, 0x00088340, 0x00098cab, 0x000ab650, 0x000c0412, 0x000d7a4e, 0x000f1de6, 0x0010f44f, 0x001303a6, 0x001552c5, 0x0017e950, 0x001acfda, 0x001e0ff3, 0x0021b450, 0x0025c8e8, 0x002a5b15, 0x002f79c6, 0x003535a4, 0x003ba148, 0x0042d170, 0x004add3f, 0x0053de7b, 0x005df1db, 0x00693757, 0x0075d27f, 0x0083eada, 0x0093ac54, 0x00a547a9, 0x00b8f2e7, 0x00cee9ee, 0x00e76efe, 0x0102cb52, 0x01214fbc, 0x0143554f, 0x01693e0f, 0x019375a6, 0x01c27219, 0x01f6b483, 0x0230c9c4, 0x02714b30, 0x02b8df28, 0x0308399f, 0x03601c7d, 0x03c157dd, 0x042cca0f, 0x04a35f5a, 0x0526116e, 0x05b5e669, 0x0653ef7f, 0x0701470a, 0x07bf0e27, 0x088e69a9, 0x09707e87, 0x0a666dba, 0x0b714fa4, 0x0c922f32, 0x0dca04f5, 0x0f19b291, 0x1081ff0d, 0x120394aa, 0x139f013f, 0x1554ba3e, 0x17252608, 0x1910acce, 0x1b17d437, 0x1d3b6ad1, 0x1f7ccbeb, 0x21de4b5a, 0x2463e832, 0x27148a26, 0x29fc6fb2, 0x2d32a8ee, 0x30e86427, 0x35a83b0c, 0x35a83b0c, 0x35a83b0c, 0x35a83b0c },
    { 0x0001f6a7, 0x0001f6a7, 0x00023413, 0x000278fe, 0x0002c651, 0x00031d13, 0x00037e6a, 0x0003eb9e, 0x00046623, 0x0004ef95, 0x000589c5, 0x000636bd, 0x0006f8c2, 0x0007d264, 0x0008c67e, 0x0009d845, 0x000b0b52, 0x000c63aa, 0x000de5d0, 0x000f96d0, 0x00117c50, 0x00139ca4, 0x0015fee2, 0x0018aaf5, 0x001ba9bd, 0x001f0522, 0x0022c83c, 0x0026ff72, 0x002bb89c, 0x00310337, 0x0036f08a, 0x003d93e2, 0x004502c8, 0x004d553f, 0x0056a60e, 0x00611309, 0x006cbd67, 0x0079ca1f, 0x00886248, 0x0098b38e, 0x00aaf09e, 0x00bf51b0, 0x00d61509, 0x00ef7f8f, 0x010bdd68, 0x012b829b, 0x014ecbba, 0x01761e96, 0x01a1eaf1, 0x01d2ab36, 0x0208e526, 0x02452a86, 0x028819b8, 0x02d25e3b, 0x0324b116, 0x037fd911, 0x03e4aab8, 0x04540813, 0x04cee01b, 0x05562daf, 0x05eaf621, 0x068e4732, 0x07413475, 0x0804d401, 0x08da3a80, 0x09c2767d, 0x0abe8b23, 0x0bcf6a5f, 0x0cf5eec1, 0x0e32d541, 0x0f86b771, 0x10f20687, 0x12750809, 0x140fd4e9, 0x15c25c28, 0x178c6a51, 0x196db772, 0x1b65fdf1, 0x1d751d7e, 0x1f9b4fb7, 0x21d97821, 0x2431a24d, 0x26a7d611, 0x29439ec2, 0x2c133d10, 0x2f33a1a2, 0x32eafa0f, 0x32eafa0f, 0x32eafa0f },
    { 0x0001cd62, 0x0001cd62, 0x000205c8, 0x00024511, 0x00028c13, 0x0002dbc1, 0x00033528, 0x00039978, 0x00040a03, 0x00048849, 0x000515f3, 0x0005b4e2, 0x0006672e, 0x00072f32, 0x00080f90, 0x00090b3d, 0x000a258a, 0x000b622b, 0x000cc548, 0x000e538b, 0x0010122a, 0x001206fd, 0x0014388e, 0x0016ae2f, 0x00197011, 0x001c8761, 0x001ffe60, 0x0023e087, 0x00283aab, 0x002d1b23, 0x003291f3, 0x0038b103, 0x003f8c4d, 0x00473a20, 0x004fd35d, 0x005973c1, 0x00643a36, 0x00704928, 0x007dc6e5, 0x008cde06, 0x009dbde0, 0x00b09afa, 0x00c5af96, 0x00dd3c39, 0x00f78845, 0x0114e292, 0x0135a219, 0x015a269d, 0x0182d95d, 0x01b02dc3, 0x01e2a215, 0x021ac01a, 0x02591dba, 0x029e5d7e, 0x02eb2efa, 0x03404f0c, 0x039e87e9, 0x0406b0dc, 0x0479adc0, 0x04f86e02, 0x0583eb30, 0x061d2703, 0x06c528b0, 0x077cf9a2, 0x0845a162, 0x092020be, 0x0a0d6c42, 0x0b0e65ea, 0x0c23d66c, 0x0d4e6624, 0x0e8e961e, 0x0fe4b990, 0x1150f07a, 0x12d323fa, 0x146b054c, 0x1618103b, 0x17d99237, 0x19aeb752, 0x1b969e8f, 0x1d9077d2, 0x1f9baece, 0x21b828c2, 0x23e6a087, 0x26293843, 0x288475ad, 0x2b012cb7, 0x2db0da5d, 0x30ba095c, 0x30ba095c },
    { 0x0001794e, 0x0001a772, 0x0001db38, 0x00021552, 0x00025684, 0x00029fad, 0x0002f1c5, 0x00034de2, 0x0003b53e, 0x00042936, 0x0004ab54, 0x00053d51, 0x0005e11b, 0x000698dd, 0x00076703, 0x00084e46, 0x000951b2, 0x000a74b4, 0x000bbb1f, 0x000d293d, 0x000ec3de, 0x00109064, 0x001294d8, 0x0014d7fa, 0x0017615c, 0x001a3972, 0x001d69b9, 0x0020fcc8, 0x0024fe7c, 0x00297c17, 0x002e846b, 0x0034280b, 0x003a7977, 0x00418d59, 0x00497ac3, 0x00525b70, 0x005c4c10, 0x00676c9c, 0x0073e0b0, 0x0081cfe9, 0x00916654, 0x00a2d4e2, 0x00b651e1, 0x00cc1986, 0x00e46e7a, 0x00ff9a74, 0x011deed5, 0x013fc551, 0x01658096, 0x018f8cff, 0x01be6137, 0x01f27ee4, 0x022c7340, 0x026cd79c, 0x02b451d1, 0x03039482, 0x035b5f2e, 0x03bc7e07, 0x0427c96c, 0x049e250c, 0x05207e81, 0x05afcb75, 0x064d070b, 0x06f92eaa, 0x07b53dfd, 0x08822a20, 0x0960dc0f, 0x0a522a46, 0x0b56d1cf, 0x0c6f6ed3, 0x0d9c750d, 0x0ede287a, 0x103496c4, 0x119f9209, 0x131eadaa, 0x14b13ded, 0x16565b33, 0x180ce9ad, 0x19d3a65e, 0x1ba93a71, 0x1d8c561e, 0x1f7bd50e, 0x2176efb7, 0x237d8042, 0x259068ea, 0x27b239d6, 0x29e85e5e, 0x2c3d9358, 0x2c3d9358 },
    { 0x00015a3d, 0x00018496, 0x0001b41c, 0x0001e972, 0x0002254b, 0x00026875, 0x0002b3d2, 0x00030865, 0x0003674b, 0x0003d1c7, 0x00044942, 0x0004cf53, 0x000565bf, 0x00060e84, 0x0006cbde, 0x0007a04d, 0x00088ea1, 0x000999fe, 0x000ac5ea, 0x000c165a, 0x000d8fbb, 0x000f3703, 0x001111c1, 0x0013262e, 0x00157b44, 0x001818d1, 0x001b0792, 0x001e5150, 0x002200fc, 0x002622d5, 0x002ac48d, 0x002ff572, 0x0035c6a1, 0x003c4b37, 0x0043988c, 0x004bc673, 0x0054ef7e, 0x005f3151, 0x006aacf0, 0x0077871e, 0x0085e8c1, 0x0095ff52, 0x00a7fd50, 0x00bc1ac0, 0x00d295b6, 0x00ebb2e4, 0x0107be33, 0x01270b61, 0x0149f6a9, 0x0170e564, 0x019c46b1, 0x01cc941a, 0x02025227, 0x023e10e8, 0x02806c60, 0x02ca0cd5, 0x031ba6e8, 0x0375fb74, 0x03d9d725, 0x044811a5, 0x04c18c61, 0x054730be, 0x05d9edb8, 0x067ab4c8, 0x072a7611, 0x07ea1bbc, 0x08ba8480, 0x099c7d61, 0x0a90bac5, 0x0b97d0f4, 0x0cb22c5e, 0x0de009dd, 0x0f216f99, 0x107626d4, 0x11ddb782, 0x1357662a, 0x14e234cf, 0x167ce78f, 0x18260d90, 0x19dc0eb7, 0x1b9d3ebb, 0x1d67f61c, 0x1f3ab1d8, 0x21143bce, 0x22f3df6a, 0x24d9b2b0, 0x26c704ea, 0x28bf1ac3, 0x2ac89c1a },
    { 0x00013db4, 0x00016492, 0x00019030, 0x0001c124, 0x0001f813, 0x000235b8, 0x00027ae6, 0x0002c889, 0x00031fa7, 0x00038169, 0x0003ef1b, 0x00046a32, 0x0004f450, 0x00058f49, 0x00063d2b, 0x00070043, 0x0007db25, 0x0008d0b8, 0x0009e438, 0x000b1949, 0x000c73fe, 0x000df8e8, 0x000fad25, 0x00119671, 0x0013bb39, 0x001622ac, 0x0018d4d9, 0x001bdac6, 0x001f3e88, 0x00230b6c, 0x00274e14, 0x002c14a1, 0x00316edf, 0x00376e77, 0x003e2720, 0x0045aee0, 0x004e1e4d, 0x005790cf, 0x006224f9, 0x006dfcd6, 0x007b3e4d, 0x008a1388, 0x009aab5f, 0x00ad39d5, 0x00c1f894, 0x00d9277b, 0x00f30d27, 0x010ff794, 0x01303caf, 0x01543b01, 0x017c5a46, 0x01a90c0e, 0x01dacc51, 0x021221f5, 0x024f9f3b, 0x0293e210, 0x02df9433, 0x03336b20, 0x039027b0, 0x03f6956a, 0x0467895d, 0x04e3e07d, 0x056c7d6c, 0x06024594, 0x06a61d88, 0x0758e497, 0x081b6f98, 0x08ee82de, 0x09d2cb77, 0x0ac8d7d9, 0x0bd11026, 0x0cebae6d, 0x0e18b736, 0x0f57f2ea, 0x10a8e8ac, 0x120adb23, 0x137cc7f2, 0x14fd6a6e, 0x168b41f7, 0x18249c70, 0x19c7a4f0, 0x1b7276d3, 0x1d23352d, 0x1ed826db, 0x208fd7e6, 0x2249423f, 0x2404024f, 0x25c0a169, 0x27810c5b },
    { 0x00012382, 0x0001472c, 0x00016f34, 0x00019c20, 0x0001ce8a, 0x0002071f, 0x0002469d, 0x00028ddf, 0x0002ddd5, 0x00033791, 0x00039c43, 0x00040d43, 0x00048c0e, 0x00051a56, 0x0005b9fb, 0x00066d1d, 0x0007361a, 0x0008179c, 0x0009149d, 0x000a3077, 0x000b6ee9, 0x000cd426, 0x000e64e4, 0x00102669, 0x00121e9f, 0x00145425, 0x0016ce67, 0x001995b1, 0x001cb351, 0x002031ae, 0x00241c6f, 0x0028809b, 0x002d6cc2, 0x0032f130, 0x00392019, 0x00400dd0, 0x0047d10a, 0x0050831b, 0x005a4044, 0x00652801, 0x00715d64, 0x007f0773, 0x008e5191, 0x009f6bee, 0x00b28c03, 0x00c7ed0e, 0x00dfd0a0, 0x00fa7f27, 0x01184887, 0x013984b0, 0x015e9439, 0x0187e0f6, 0x01b5de87, 0x01e90adc, 0x0221eea5, 0x02611da3, 0x02a736d2, 0x02f4e463, 0x034adb6d, 0x03a9db52, 0x0412acb5, 0x04862003, 0x05050b5f, 0x059047fa, 0x0628aead, 0x06cf13d2, 0x07844255, 0x0848f5f7, 0x091dd4d5, 0x0a036855, 0x0afa15a1, 0x0c021601, 0x0d1b6f69, 0x0e45edb5, 0x0f811d18, 0x10cc464a, 0x12266d14, 0x138e51ac, 0x15027574, 0x1681233c, 0x18087b41, 0x199682cd, 0x1b293725, 0x1cbea389, 0x1e54f9f6, 0x1feaaecd, 0x217e9845, 0x23101435, 0x249f3a0a },
    { 0x00010b74, 0x00012c2f, 0x000150ea, 0x00017a24, 0x0001a868, 0x0001dc54, 0x00021699, 0x000257fe, 0x0002a162, 0x0002f3be, 0x0003502a, 0x0003b7e2, 0x00042c45, 0x0004aee0, 0x0005416e, 0x0005e5e0, 0x00069e66, 0x00076d71, 0x000855bf, 0x00095a63, 0x000a7ecf, 0x000bc6e0, 0x000d36eb, 0x000ed3cb, 0x0010a2ee, 0x0012aa6e, 0x0014f11e, 0x00177ea3, 0x001a5b8c, 0x001d916e, 0x00212b04, 0x0025344f, 0x0029babc, 0x002ecd4d, 0x00347ccc, 0x003adbfa, 0x0041ffc7, 0x0049ff94, 0x0052f577, 0x005cfe84, 0x00683b21, 0x0074cf60, 0x0082e360, 0x0092a3b7, 0x00a441e3, 0x00b7f4c0, 0x00cdf911, 0x00e691fc, 0x0102099f, 0x0120b19f, 0x0142e3b5, 0x01690245, 0x019378e3, 0x01c2bcd7, 0x01f74d86, 0x0231b4c8, 0x02728719, 0x02ba6395, 0x0309f3c0, 0x0361eaf8, 0x03c3058e, 0x042e076a, 0x04a3ba2e, 0x0524eaba, 0x05b2660c, 0x064cf55b, 0x06f5597c, 0x07ac4577, 0x08725869, 0x094816c2, 0x0a2de310, 0x0b23f696, 0x0c2a5a01, 0x0d40deaa, 0x0e6718db, 0x0f9c5baa, 0x10dfb6e2, 0x122ff786, 0x138bab5a, 0x14f127a5, 0x165e934c, 0x17d1f428, 0x19493f27, 0x1ac26ad4, 0x1c3b83a2, 0x1db2c176, 0x1f269e3c, 0x2095eddb, 0x21fff8fe },
    { 0x0000f561, 0x00011369, 0x0001351d, 0x00015af1, 0x00018565, 0x0001b50a, 0x0001ea83, 0x00022686, 0x000269e0, 0x0002b575, 0x00030a47, 0x00036978, 0x0003d44a, 0x00044c2a, 0x0004d2ae, 0x000569a1, 0x00061303, 0x0006d113, 0x0007a656, 0x000895a0, 0x0009a21a, 0x000acf53, 0x000c2145, 0x000d9c66, 0x000f45b8, 0x001122d4, 0x00133a01, 0x00159248, 0x0018338a, 0x001b2698, 0x001e7552, 0x00222ac5, 0x0026534d, 0x002afcbf, 0x00303691, 0x0036120a, 0x003ca279, 0x0043fd6b, 0x004c3aef, 0x005575d8, 0x005fcc0d, 0x006b5edb, 0x00785351, 0x0086d29e, 0x00970a82, 0x00a92dba, 0x00bd747a, 0x00d41cec, 0x00ed6bb3, 0x0109ac78, 0x0129326d, 0x014c58db, 0x017383a4, 0x019f1fc1, 0x01cfa3a9, 0x02058fa5, 0x02416e05, 0x0283d325, 0x02cd5d3f, 0x031eb3f2, 0x03788770, 0x03db8f4b, 0x044888b9, 0x04c03453, 0x05435330, 0x05d2a349, 0x066edb2f, 0x0718a4fc, 0x07d0988c, 0x08973525, 0x096cda96, 0x0a51c229, 0x0b45f791, 0x0c495259, 0x0d5b702a, 0x0e7bb07e, 0x0fa93225, 0x10e2d337, 0x122733b3, 0x1374bb25, 0x14c9a15c, 0x1623fa08, 0x1781c2ea, 0x18e0f412, 0x1a3f9171, 0x1b9bbd16, 0x1cf3c978, 0x1e464b68, 0x1f922bcd },
    { 0x0000e11e, 0x0000fcac, 0x00011b98, 0x00013e4e, 0x00016542, 0x000190fa, 0x0001c20b, 0x0001f91c, 0x000236e9, 0x00027c45, 0x0002ca1c, 0x00032177, 0x0003837f, 0x0003f183, 0x00046cf8, 0x0004f783, 0x000592fa, 0x0006416e, 0x0007052f, 0x0007e0d6, 0x0008d74b, 0x0009ebd3, 0x000b2215, 0x000c7e2b, 0x000e04ae, 0x000fbac5, 0x0011a636, 0x0013cd77, 0x001637c8, 0x0018ed45, 0x001bf703, 0x001f5f2e, 0x00233125, 0x002779a4, 0x002c46e6, 0x0031a8d4, 0x0037b136, 0x003e73e9, 0x00460715, 0x004e8376, 0x0058049e, 0x0062a942, 0x006e9393, 0x007be994, 0x008ad580, 0x009b8635, 0x00ae2fa0, 0x00c30b37, 0x00da5874, 0x00f45d57, 0x011166e5, 0x0131c9a9, 0x0155e238, 0x017e159e, 0x01aad1cc, 0x01dc8de6, 0x0213ca77, 0x02511184, 0x0294f65e, 0x02e01541, 0x03331297, 0x038e99df, 0x03f35c20, 0x04620dd2, 0x04db643a, 0x05601213, 0x05f0c392, 0x068e19b1, 0x0738a4cd, 0x07f0deae, 0x08b72410, 0x098badee, 0x0a6e8ac7, 0x0b5f984a, 0x0c5e7dba, 0x0d6aa797, 0x0e8344f7, 0x0fa74701, 0x10d562ef, 0x120c16cf, 0x1349b11d, 0x148c5b0d, 0x15d22535, 0x17191617, 0x185f39d1, 0x19a2b23c, 0x1ae1c6c5, 0x1c1af35e, 0x1d4cf631 },
    { 0x0000ce86, 0x0000e7ce, 0x0001042d, 0x00012405, 0x000147c3, 0x00016fe0, 0x00019ce5, 0x0001cf6c, 0x00020821, 0x000247c6, 0x00028f33, 0x0002df5c, 0x00033951, 0x00039e46, 0x00040f92, 0x00048eb7, 0x00051d65, 0x0005bd81, 0x0006712b, 0x00073ac6, 0x00081cfd, 0x00091ad1, 0x000a379d, 0x000b7727, 0x000cdda7, 0x000e6fd9, 0x0010330c, 0x00122d31, 0x001464f0, 0x0016e1bf, 0x0019abf9, 0x001cccf7, 0x00204f2f, 0x00243e58, 0x0028a78a, 0x002d996a, 0x00332455, 0x00395a94, 0x0040508f, 0x00481d0e, 0x0050d976, 0x005aa213, 0x0065966a, 0x0071d987, 0x007f925d, 0x008eec29, 0x00a016d7, 0x00b34775, 0x00c8b8a4, 0x00e0ab12, 0x00fb65f0, 0x01193773, 0x013a7543, 0x015f7cf0, 0x0188b453, 0x01b689db, 0x01e974ca, 0x0221f53d, 0x02609415, 0x02a5e299, 0x02f279d5, 0x0346f998, 0x03a4070e, 0x040a4ad7, 0x047a6e97, 0x04f519e7, 0x057aeea3, 0x060c8490, 0x06aa6459, 0x075501f9, 0x080cb6b6, 0x08d1bac3, 0x09a41ef0, 0x0a83c696, 0x0b706236, 0x0c696b2c, 0x0d6e20f1, 0x0e7d8855, 0x0f966cfa, 0x10b76567, 0x11ded9b8, 0x130b0ccd, 0x143a27b8, 0x156a46de, 0x16998831, 0x17c619c7, 0x18ee480b, 0x1a108ae8, 0x1b2b9167 },
    { 0x0000bd76, 0x0000d4a7, 0x0000eeaf, 0x00010be7, 0x00012cb1, 0x0001517f, 0x00017acd, 0x0001a929, 0x0001dd31, 0x00021796, 0x00025920, 0x0002a2ad, 0x0002f539, 0x000351dd, 0x0003b9d4, 0x00042e80, 0x0004b16e, 0x0005445d, 0x0005e93f, 0x0006a244, 0x000771e2, 0x00085ad9, 0x0009603f, 0x000a858a, 0x000bce9c, 0x000d3fcd, 0x000eddfe, 0x0010aea5, 0x0012b7e0, 0x0015008a, 0x00179050, 0x001a6fcc, 0x001da89b, 0x00214582, 0x0025528d, 0x0029dd33, 0x002ef483, 0x0034a94f, 0x003b0e5f, 0x004238aa, 0x004a3f93, 0x00533d28, 0x005d4e6f, 0x006893b3, 0x007530d9, 0x00834dbc, 0x0093168b, 0x00a4bc35, 0x00b874d3, 0x00ce7c16, 0x00e713bc, 0x01028400, 0x01211c0c, 0x01433261, 0x01692533, 0x01935aba, 0x01c24165, 0x01f64fee, 0x02300543, 0x026fe838, 0x02b686f5, 0x03047611, 0x035a4f47, 0x03b8afbe, 0x042035c7, 0x04917e13, 0x050d2048, 0x0593aaf7, 0x06259eff, 0x06c36a55, 0x076d6267, 0x0823be2c, 0x08e6902d, 0x09b5c0c6, 0x0a910909, 0x0b77ee8d, 0x0c69c0ae, 0x0d659798, 0x0e6a5565, 0x0f76a99c, 0x1089171d, 0x119ffc66, 0x12b99de6, 0x13d431f4, 0x14ededce, 0x160512e7, 0x1717fbde, 0x1825286a, 0x192b47b2 },
    { 0x0000adce, 0x0000c315, 0x0000daf7, 0x0000f5c5, 0x000113da, 0x0001359e, 0x00015b84, 0x0001860c, 0x0001b5c9, 0x0001eb5d, 0x0002277e, 0x00026afb, 0x0002b6b8, 0x00030bb9, 0x00036b1e, 0x0003d62d, 0x00044e52, 0x0004d526, 0x00056c74, 0x0006163e, 0x0006d4c5, 0x0007aa91, 0x00089a77, 0x0009a7a4, 0x000ad5aa, 0x000c2886, 0x000da4b2, 0x000f4f33, 0x00112da9, 0x0013465e, 0x0015a062, 0x0018439b, 0x001b38df, 0x001e8a15, 0x00224250, 0x00266df0, 0x002b1ace, 0x00305862, 0x003637f3, 0x003ccccb, 0x00442c6d, 0x004c6ed4, 0x0055aeb8, 0x006009d3, 0x006ba132, 0x0078998c, 0x00871b95, 0x00975467, 0x00a975de, 0x00bdb706, 0x00d45482, 0x00ed90f8, 0x0109b57d, 0x012911ee, 0x014bfd57, 0x0172d631, 0x019e029b, 0x01cdf070, 0x02031533, 0x023dedd0, 0x027efe12, 0x02c6cfd9, 0x0315f1f0, 0x036cf676, 0x03cc70cf, 0x0434f315, 0x04a70af1, 0x05233de3, 0x05aa04fa, 0x063bc806, 0x06d8d852, 0x07816b2a, 0x0835943d, 0x08f54038, 0x09c02fec, 0x0a95f44f, 0x0b75ebc5, 0x0c5f4109, 0x0d50ec0c, 0x0e49b4f5, 0x0f48396b, 0x104af40a, 0x115045c1, 0x125680c5, 0x135bf472, 0x145ef986, 0x155dfe0a, 0x16579042, 0x174a6820 },
    { 0x00009f71, 0x0000b2f6, 0x0000c8de, 0x0000e176, 0x0000fd0f, 0x00011c09, 0x00013ece, 0x000165d3, 0x0001919f, 0x0001c2c7, 0x0001f9f2, 0x000237dd, 0x00027d5b, 0x0002cb59, 0x000322e0, 0x0003851a, 0x0003f358, 0x00046f0f, 0x0004f9e5, 0x000595b2, 0x00064487, 0x000708b8, 0x0007e4de, 0x0008dbe4, 0x0009f110, 0x000b280c, 0x000c84f6, 0x000e0c69, 0x000fc38e, 0x0011b02f, 0x0013d8c7, 0x00164497, 0x0018fbbf, 0x001c0757, 0x001f718c, 0x002345bf, 0x002790aa, 0x002c6085, 0x0031c533, 0x0037d070, 0x003e9604, 0x00462bff, 0x004eaaf5, 0x00582e40, 0x0062d44c, 0x006ebee2, 0x007c137e, 0x008afba7, 0x009ba54a, 0x00ae4320, 0x00c30d09, 0x00da4079, 0x00f420d1, 0x0110f7c2, 0x0131159d, 0x0154d19b, 0x017c8a0e, 0x01a8a479, 0x01d98d81, 0x020fb8b5, 0x024ba016, 0x028dc35b, 0x02d6a6e6, 0x0326d24f, 0x037ece84, 0x03df236b, 0x04485503, 0x04badff1, 0x05373590, 0x05bdb779, 0x064eb2ab, 0x06ea5a69, 0x0790c302, 0x0841dcc7, 0x08fd6f74, 0x09c31669, 0x0a923e06, 0x0b6a2289, 0x0c49d0ad, 0x0d302852, 0x0e1be132, 0x0f0b919f, 0x0ffdb710, 0x10f0c01e, 0x11e3176c, 0x12d32eeb, 0x13bf8ad2, 0x14a6cbb7, 0x1587b740 }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\midi.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      MIDI.cpp
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#include "math.h"
#include "debug.h"
#endif
 
CMIDIDataList    CMIDIRecorder::m_sFreeList; 
DWORD            CMIDIRecorder::m_sUsageCount = 0;

CMIDIData::CMIDIData() 
{
    m_stTime = 0;
    m_lData = 0;            
}


CMIDIRecorder::CMIDIRecorder()
{
    m_sUsageCount++;
    m_lCurrentData = 0;
    m_stCurrentTime = 0;
}

CMIDIRecorder::~CMIDIRecorder()

{
    ClearMIDI(0x7FFFFFFF);
    m_sUsageCount--;
    // If there are no instances of CMIDIRecorder left, get rid of the free pool.
    if (!m_sUsageCount)
    {
        CMIDIData *pMD;
        while (pMD = m_sFreeList.RemoveHead())
        {
            delete pMD;
        }
    }
}

VREL CMIDIRecorder::m_vrMIDIToVREL[128] = 
{
    -9600, -8415, -7211, -6506, -6006, -5619, -5302, -5034, 
    -4802, -4598, -4415, -4249, -4098, -3959, -3830, -3710, 
    -3598, -3493, -3394, -3300, -3211, -3126, -3045, -2968, 
    -2894, -2823, -2755, -2689, -2626, -2565, -2506, -2449, 
    -2394, -2341, -2289, -2238, -2190, -2142, -2096, -2050, 
    -2006, -1964, -1922, -1881, -1841, -1802, -1764, -1726, 
    -1690, -1654, -1619, -1584, -1551, -1518, -1485, -1453, 
    -1422, -1391, -1361, -1331, -1302, -1273, -1245, -1217, 
    -1190, -1163, -1137, -1110, -1085, -1059, -1034, -1010, 
    -985, -961, -938, -914, -891, -869, -846, -824, 
    -802, -781, -759, -738, -718, -697, -677, -657, 
    -637, -617, -598, -579, -560, -541, -522, -504, 
    -486, -468, -450, -432, -415, -397, -380, -363, 
    -347, -330, -313, -297, -281, -265, -249, -233, 
    -218, -202, -187, -172, -157, -142, -127, -113, 
    -98, -84, -69, -55, -41, -27, -13, 0
};

VREL CMIDIRecorder::m_vrMIDIPercentToVREL[128] = 
{
    -9600, -4207, -3605, -3253, -3003, -2809, -2651, -2517, 
    -2401, -2299, -2207, -2124, -2049, -1979, -1915, -1855, 
    -1799, -1746, -1697, -1650, -1605, -1563, -1522, -1484, 
    -1447, -1411, -1377, -1344, -1313, -1282, -1253, -1224, 
    -1197, -1170, -1144, -1119, -1095, -1071, -1048, -1025, 
    -1003, -982, -961, -940, -920, -901, -882, -863, 
    -845, -827, -809, -792, -775, -759, -742, -726, 
    -711, -695, -680, -665, -651, -636, -622, -608, 
    -595, -581, -568, -555, -542, -529, -517, -505, 
    -492, -480, -469, -457, -445, -434, -423, -412, 
    -401, -390, -379, -369, -359, -348, -338, -328, 
    -318, -308, -299, -289, -280, -270, -261, -252, 
    -243, -234, -225, -216, -207, -198, -190, -181, 
    -173, -165, -156, -148, -140, -132, -124, -116, 
    -109, -101, -93, -86, -78, -71, -63, -56, 
    -49, -42, -34, -27, -20, -13, -6, 0 
};

/*void CMIDIRecorder::Init()
{
        for (nIndex = 1; nIndex < 128; nIndex++)
        {
            double   flTemp;
            flTemp = nIndex;
            flTemp /= 127.0;
            flTemp = pow(flTemp,4.0);
            flTemp = log10(flTemp);
            flTemp *= 1000.0;
            Trace(0,"%ld, ",(long)flTemp);
            if ((nIndex % 8) == 7)
                Trace(0,"\n");
            m_vrMIDIToVREL[nIndex] = (VREL) flTemp;
        }
        Trace(0,"\n");
        m_vrMIDIToVREL[0] = -9600;
        for (nIndex = 1; nIndex < 128; nIndex++)
        {
            double flTemp;
            flTemp = nIndex;
            flTemp /= 127;
            flTemp *= flTemp;
            flTemp = log10(flTemp);
            flTemp *= 1000.0;
            m_vrMIDIPercentToVREL[nIndex] = (VREL) flTemp;
            Trace(0,"%ld, ",(long)flTemp);
            if ((nIndex % 8) == 7)
                Trace(0,"\n");
        }
        m_vrMIDIPercentToVREL[0] = -9600;
}*/

BOOL CMIDIRecorder::FlushMIDI(STIME stTime)
{
    CMIDIData *pMD;
    CMIDIData *pLast = NULL;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            if (pLast == NULL)
            {
                m_EventList.RemoveAll();
            }
            else
            {
                pLast->SetNext(NULL);
            }
            m_sFreeList.Cat(pMD);
            break;
        }
        pLast = pMD;
    }
    return m_EventList.IsEmpty();
}

BOOL CMIDIRecorder::ClearMIDI(STIME stTime)

{
    CMIDIData *pMD;
    for (;pMD = m_EventList.GetHead();)
    {
        if (pMD->m_stTime < stTime)
        {
            m_EventList.RemoveHead();
            m_stCurrentTime = pMD->m_stTime;
            m_lCurrentData = pMD->m_lData;
            m_sFreeList.AddHead(pMD);
            
        }
        else break;
    }
    return m_EventList.IsEmpty();
}

VREL CMIDIRecorder::VelocityToVolume(WORD nVelocity)

{
    return (m_vrMIDIToVREL[nVelocity]);
}

BOOL CMIDIRecorder::RecordMIDINote(STIME stTime, long lData)

{
    CMIDIData *pMD = m_sFreeList.RemoveHead();
    if (!pMD)
    {
        pMD = new CMIDIData;
    }
    CMIDIData *pScan = m_EventList.GetHead();
    CMIDIData *pNext;
    if (pMD)
    {
        pMD->m_stTime = stTime;
        pMD->m_lData = lData;
        if (pScan == NULL)
        {
            m_EventList.AddHead(pMD);
        }
        else
        {
            if (pScan->m_stTime > stTime)
            {
                m_EventList.AddHead(pMD);
            }
            else
            {
                for (;pScan != NULL; pScan = pNext)
                {
                    pNext = pScan->GetNext();
                    if (pNext == NULL)
                    {
                        pScan->SetNext(pMD);
                    }
                    else
                    {
                        if (pNext->m_stTime > stTime)
                        {
                            pMD->SetNext(pNext);
                            pScan->SetNext(pMD);
                            break;
                        }
                    }
                }
            }
        }
        return (TRUE);
    }
    return (FALSE);
}

BOOL CMIDIRecorder::RecordMIDI(STIME stTime, long lData)

{
    CMIDIData *pMD = m_sFreeList.RemoveHead();
    if (!pMD)
    {
        pMD = new CMIDIData;
    }
    CMIDIData *pScan = m_EventList.GetHead();
    CMIDIData *pNext;
    if (pMD)
    {
        pMD->m_stTime = stTime;
        pMD->m_lData = lData;
        if (pScan == NULL)
        {
            m_EventList.AddHead(pMD);
        }
        else
        {
            if (pScan->m_stTime > stTime)
            {
                m_EventList.AddHead(pMD);
            }
            else
            {
                for (;pScan != NULL; pScan = pNext)
                {
                    if ((pScan->m_stTime == stTime) && 
                        (pScan->m_lData == lData))
                    {
                        m_sFreeList.AddHead(pMD);
                        break;
                    }
                    pNext = pScan->GetNext();
                    if (pNext == NULL)
                    {
                        pScan->SetNext(pMD);
                    }
                    else
                    {
                        if (pNext->m_stTime > stTime)
                        {
                            pMD->SetNext(pNext);
                            pScan->SetNext(pMD);
                            break;
                        }
                    }
                }
            }
        }
        return (TRUE);
    }
/*#ifdef DBG
    static gWarnCount = 0;
    if (!gWarnCount)
    {
        Trace(1,"Warning: MIDI Free event pool empty. This can be caused by time stamping problems, too much MIDI data, or too many PChannels.\n");
        gWarnCount = 100;
    }
    gWarnCount--;
#endif*/
    return (FALSE);
}

long CMIDIRecorder::GetData(STIME stTime)

{
    CMIDIData *pMD = m_EventList.GetHead();
    long lData = m_lCurrentData;
    for (;pMD;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime > stTime)
        {
            break;
        }
        lData = pMD->m_lData;
    }
    return (lData);
}

BOOL CNoteIn::RecordNote(STIME stTime, CNote * pNote)

{
    long lData = pNote->m_bPart << 16;
    lData |= pNote->m_bKey << 8;
    lData |= pNote->m_bVelocity;
    return (RecordMIDINote(stTime,lData));
}

BOOL CNoteIn::RecordEvent(STIME stTime, DWORD dwPart, DWORD dwCommand, BYTE bData)

{
    long lData = dwPart;
    lData <<= 8;
    lData |= dwCommand;
    lData <<= 8;
    lData |= bData;
    return (RecordMIDINote(stTime,lData));  
}

BOOL CNoteIn::GetNote(STIME stTime, CNote * pNote)

{
    CMIDIData *pMD = m_EventList.GetHead();
    if (pMD != NULL)
    {
        if (pMD->m_stTime <= stTime)
        {
            pNote->m_stTime = pMD->m_stTime;
            pNote->m_bPart = (BYTE) (pMD->m_lData >> 16);
            pNote->m_bKey = (BYTE) (pMD->m_lData >> 8) & 0xFF;
            pNote->m_bVelocity = (BYTE) pMD->m_lData & 0xFF;
            m_EventList.RemoveHead();
            m_sFreeList.AddHead(pMD);
            return (TRUE);
        }
    }
    return (FALSE);
}

void CNoteIn::FlushMIDI(STIME stTime)

{
    CMIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            pMD->m_stTime = stTime;     // Play now.
            pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
        }
    }
}


void CNoteIn::FlushPart(STIME stTime, BYTE bChannel)

{
    CMIDIData *pMD;
    for (pMD = m_EventList.GetHead();pMD != NULL;pMD = pMD->GetNext())
    {
        if (pMD->m_stTime >= stTime)
        {
            if (bChannel == (BYTE) (pMD->m_lData >> 16))
            {
                pMD->m_stTime = stTime;     // Play now.
                pMD->m_lData &= 0xFFFFFF00; // Clear velocity to make note off.
            }
        }
    }
}

DWORD CModWheelIn::GetModulation(STIME stTime)

{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}

CPitchBendIn::CPitchBendIn()

{
    m_lCurrentData = 0x2000;    // initially at midpoint, no bend
#ifdef DXAPI
    m_prRange = 200;           // whole tone range by default.
#else
    m_prRange = 8192;           // pitch cents range. This is counting on the performance
                                // layer to manage the default ranges.
#endif
}

// note (davidmay 8/14/96): we don't keep a time-stamped range.
// if people are changing the pitch bend range often, this won't work right,
// but that didn't seem likely enough to warrant a new list.
PREL CPitchBendIn::GetPitch(STIME stTime)

{
    PREL prResult = (PREL) CMIDIRecorder::GetData(stTime);
    prResult -= 0x2000;         // Subtract MIDI Midpoint.
    prResult *= m_prRange;  // adjust by current range
    prResult >>= 13;
    return (prResult);
}

CVolumeIn::CVolumeIn()

{
    m_lCurrentData = 100;
}

VREL CVolumeIn::GetVolume(STIME stTime)

{
    long lResult = CMIDIRecorder::GetData(stTime);
    return (m_vrMIDIToVREL[lResult]);
}

CExpressionIn::CExpressionIn()

{
    m_lCurrentData = 127;
}

VREL CExpressionIn::GetVolume(STIME stTime)

{
    long lResult = CMIDIRecorder::GetData(stTime);
    return (m_vrMIDIToVREL[lResult]);
}

CPanIn::CPanIn()

{
    m_lCurrentData = 64;
}

long CPanIn::GetPan(STIME stTime)

{
    long lResult = (long) CMIDIRecorder::GetData(stTime);
    return (lResult);
}

//////////////////////////////////////////////////////////
// Directx8 Methods 

DWORD CPressureIn::GetPressure(STIME stTime)

{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}

CReverbIn::CReverbIn()

{
    m_lCurrentData = 40;
}

DWORD CReverbIn::GetVolume(STIME stTime)

{
    return (m_vrMIDIPercentToVREL[CMIDIRecorder::GetData(stTime)]);
}

DWORD CChorusIn::GetVolume(STIME stTime)

{
    return (m_vrMIDIPercentToVREL[CMIDIRecorder::GetData(stTime)]);
}

CCutOffFreqIn::CCutOffFreqIn()
{
    m_lCurrentData = 64;
}

DWORD CCutOffFreqIn::GetFrequency(STIME stTime)
{
    DWORD nResult = CMIDIRecorder::GetData(stTime);
    return (nResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\miniport.cpp ===
// Copyright (c) 1998 Microsoft Corporation
//
// DirectMusic Software Synthesizer
//
#include "common.h"
#include "private.h"
#include "dmusicks.h"


#define STR_MODULENAME "DmSynth: "

#pragma code_seg("PAGE")


// Property handlers
//
NTSTATUS PropertyHandler_SynthCaps(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_SynthPortParameters(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_SynthMasterClock(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_SynthPortChannelGroups(IN PPCPROPERTY_REQUEST);

NTSTATUS PropertyHandler_DlsDownload(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_DlsUnload(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_DlsCompact(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_DlsAppend(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_DlsVolume(IN PPCPROPERTY_REQUEST);


NTSTATUS PropertyHandler_GetLatency(IN PPCPROPERTY_REQUEST);
NTSTATUS PropertyHandler_GetLatencyClock(IN PPCPROPERTY_REQUEST);

// CreateMiniportDirectMusic
//
//
NTSTATUS CreateMiniportDmSynth
(
    OUT PUNKNOWN *  Unknown,
    IN  PUNKNOWN    UnknownOuter OPTIONAL,
    IN  POOL_TYPE   PoolType
)
{
    PAGED_CODE();
    ASSERT(Unknown);

    _DbgPrintF(DEBUGLVL_TERSE, ("Creating DirectMusic synth miniport"));
    STD_CREATE_BODY(CMiniportDmSynth, Unknown, UnknownOuter, PoolType);
}

STDMETHODIMP CMiniportDmSynth::NonDelegatingQueryInterface
(
    IN  REFIID      Interface,
    OUT PVOID*      Object
)
{
    PAGED_CODE();

    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniport))
    {
        *Object = PVOID(PMINIPORT(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportSynthesizer))
    {
        *Object = PVOID(PMINIPORTSYNTHESIZER(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

CMiniportDmSynth::~CMiniportDmSynth()
{
}

STDMETHODIMP CMiniportDmSynth::Init
(
    IN  PUNKNOWN            Unknown OPTIONAL,
    IN  PRESOURCELIST       ResourceList,
    IN  PPORTSYNTHESIZER    Port_,
    OUT PSERVICEGROUP*      ServiceGroup
)
{
    _DbgPrintF(DEBUGLVL_TERSE, ("[CMiniportDmSynth::Init]"));
    ASSERT(ResourceList);
    ASSERT(Port_);
    ASSERT(ServiceGroup);

    
    Port = Port_;
    Port->AddRef();   

    Stream = NULL;
    
    *ServiceGroup = NULL;
    
    return STATUS_SUCCESS; 
}

STDMETHODIMP CMiniportDmSynth::NewStream
(
    OUT     PMINIPORTSYNTHESIZERSTREAM *   Stream_,
    IN      PUNKNOWN                OuterUnknown    OPTIONAL,
    IN      POOL_TYPE               PoolType,
    IN      ULONG                   Pin,
    IN      BOOLEAN                 Capture,
    IN      PKSDATAFORMAT           DataFormat,
    OUT     PSERVICEGROUP *         ServiceGroup
)
{
    _DbgPrintF(DEBUGLVL_TERSE, ("[CMiniportDmSynth::NewStream]"));
    NTSTATUS nt = STATUS_SUCCESS;

    if (Stream)
    {
        // XXX Multiinstance!!!
        //
        nt = STATUS_INVALID_DEVICE_REQUEST;
    }
    else
    {
        CDmSynthStream *Stream = new(PoolType) CDmSynthStream(OuterUnknown);

        if (Stream)
        {
            nt = Stream->Init(this);
            if (NT_SUCCESS(nt))
            {
                Stream->AddRef();
                *Stream_ = PMINIPORTSYNTHESIZERSTREAM(Stream);
            }
            else
            {
                Stream->Release();
                Stream = NULL;
            }
        }
        else
        {
            nt = STATUS_INSUFFICIENT_RESOURCES;
        }

    }

    return nt;
}

STDMETHODIMP_(void) CMiniportDmSynth::Service()
{
}

// ==============================================================================
// PinDataRangesStream
// Structures indicating range of valid format values for streaming pins.
// ==============================================================================
static
KSDATARANGE_MUSIC PinDataRangesStream[] =
{
    {
        {
            sizeof(KSDATARANGE_MUSIC),
            0,
            0,
            0,
            STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
            STATICGUIDOF(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC),
            STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
        },
        STATICGUIDOF(KSMUSIC_TECHNOLOGY_WAVETABLE),
        0,                                      // Channels
        0,                                      // Notes
        0x0000ffff                              // ChannelMask
    }
};

// ==============================================================================
// PinDataRangePointersStream
// List of pointers to structures indicating range of valid format values
// for streaming pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersStream[] =
{
    PKSDATARANGE(&PinDataRangesStream[0])
};

#if 0
// ==============================================================================
// PinDataRangesBridge
// Structures indicating range of valid format values for bridge pins.
// ==============================================================================
static
KSDATARANGE PinDataRangesBridge[] =
{
   {
      sizeof(KSDATARANGE),
      0,
      0,
      0,
      STATICGUIDOF(KSDATAFORMAT_TYPE_MUSIC),
      STATICGUIDOF(KSDATAFORMAT_SUBTYPE_MIDI_BUS),
      STATICGUIDOF(KSDATAFORMAT_SPECIFIER_NONE)
   }
};

// ==============================================================================
// PinDataRangePointersBridge
// List of pointers to structures indicating range of valid format values
// for bridge pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersBridge[] =
{
    &PinDataRangesBridge[0]
};
#endif

// ==============================================================================
// PinDataRangesAudio
// Structures indicating range of valid format values for audio pins.
// ==============================================================================
static
KSDATARANGE_AUDIO PinDataRangesAudio[] =
{
    {
        { sizeof(KSDATARANGE_AUDIO),
          0,
          0,
          0,
          STATICGUIDOF(KSDATAFORMAT_TYPE_AUDIO),
          STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
          STATICGUIDOF(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX),
        },
        2,
        16,
        16,
        22050,
        22050
    }
};

// ==============================================================================
// PinDataRangePointersAudio
// List of pointers to structures indicating range of valid format values
// for audio pins.
// ==============================================================================
static
PKSDATARANGE PinDataRangePointersAudio[] =
{
    (PKSDATARANGE)&PinDataRangesAudio
};

static
PCPROPERTY_ITEM
SynthProperties[] =
{
    ///////////////////////////////////////////////////////////////////
    //
    // Configuration items
    //

    // Global: Synth caps
    // 
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CAPS,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_SynthCaps
    },
    
    // Per Stream: Synth port parameters
    // 
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_PORTPARAMETERS,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_SynthPortParameters
    },

    // Global: Master clock
    // 
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_MASTERCLOCK,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_SynthMasterClock
    },

    // Per Stream: Channel groups
    // 
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_CHANNELGROUPS,
        KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_SET,
        PropertyHandler_SynthPortChannelGroups
    },

    ///////////////////////////////////////////////////////////////////
    //
    // DLS items
    //

    // Per stream: Download DLS sample
    //
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_DOWNLOAD,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_DlsDownload
    },

    // Per stream: Unload DLS sample
    //
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_UNLOAD,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_DlsUnload
    },

    // Global: Compact DLS memory
    //
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_COMPACT,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_DlsCompact
    },

    // Per stream: append
    //                
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_APPEND,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_DlsAppend
    },

    // Per stream: volume
    //                
    {
        &KSPROPSETID_Synth_Dls,
        KSPROPERTY_SYNTH_VOLUME,
        KSPROPERTY_TYPE_SET,
        PropertyHandler_DlsVolume
    },

    ///////////////////////////////////////////////////////////////////
    //
    // Clock items
    //

    // Per stream: Get desired latency
    //
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_LATENCY,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_GetLatency
    },

    // Per stream: Get current latency time
    //
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_LatencyClock,
        KSPROPERTY_TYPE_GET,
        PropertyHandler_GetLatencyClock
    }
};

DEFINE_PCAUTOMATION_TABLE_PROP(AutomationSynth, SynthProperties);

// ==============================================================================
// MiniportPins
// List of pins.
// ==============================================================================
static
PCPIN_DESCRIPTOR 
MiniportPins[] =
{
    {
        1,1,1,  // InstanceCount
        NULL, 
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersStream),   // DataRangesCount
            PinDataRangePointersStream,                 // DataRanges
            KSPIN_DATAFLOW_IN,                          // DataFlow
            KSPIN_COMMUNICATION_SINK,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                          // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    },
#if 0 
    {
        0,0,0,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersBridge),   // DataRangesCount
            PinDataRangePointersBridge,                 // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_NONE,                   // Communication
            (GUID *) &KSCATEGORY_AUDIO,                          // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
#else
    {
        1,1,1,  // InstanceCount
        NULL,   // AutomationTable
        {       // KsPinDescriptor
            0,                                          // InterfacesCount
            NULL,                                       // Interfaces
            0,                                          // MediumsCount
            NULL,                                       // Mediums
            SIZEOF_ARRAY(PinDataRangePointersAudio),    // DataRangesCount
            PinDataRangePointersAudio,                  // DataRanges
            KSPIN_DATAFLOW_OUT,                         // DataFlow
            KSPIN_COMMUNICATION_SOURCE,                 // Communication
            (GUID *) &KSCATEGORY_AUDIO,                 // Category
            NULL,                                       // Name
            0                                           // Reserved
        }
    }
#endif
};

// ==============================================================================
// MiniportNodes
// List of nodes.
// ==============================================================================
#define CONST_PCNODE_DESCRIPTOR(n)			{ 0, NULL, &n, NULL }
#define CONST_PCNODE_DESCRIPTOR_AUTO(n,a)	{ 0, &a, &n, NULL }
static
PCNODE_DESCRIPTOR MiniportNodes[] =
{
    CONST_PCNODE_DESCRIPTOR_AUTO(KSNODETYPE_SYNTHESIZER, AutomationSynth)
};

// ==============================================================================
// MiniportConnections
// List of connections.
// ==============================================================================
static
PCCONNECTION_DESCRIPTOR MiniportConnections[] =
{
    // From node            From pin        To node                 To pin
    //
    { PCFILTER_NODE,        0,              0,                      1 },    // Stream in to synth.
    { 0,                    0,              PCFILTER_NODE,          1 }     // Synth to bridge out.
};

/*****************************************************************************
 * MiniportFilterDescriptor
 *****************************************************************************
 * Complete miniport description.
 */
static
PCFILTER_DESCRIPTOR 
MiniportFilterDescriptor =
{
    0,                                  // Version
    NULL,                               // AutomationTable
    sizeof(PCPIN_DESCRIPTOR),           // PinSize
    SIZEOF_ARRAY(MiniportPins),         // PinCount
    MiniportPins,                       // Pins
    sizeof(PCNODE_DESCRIPTOR),          // NodeSize
    SIZEOF_ARRAY(MiniportNodes),        // NodeCount
    MiniportNodes,                      // Nodes
    SIZEOF_ARRAY(MiniportConnections),  // ConnectionCount
    MiniportConnections,                // Connections
    0,                                  // CategoryCount
    NULL                                // Categories
};

STDMETHODIMP CMiniportDmSynth::GetDescription
(
    OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
)
{
    PAGED_CODE();
    ASSERT(OutFilterDescriptor);

    _DbgPrintF(DEBUGLVL_VERBOSE, ("GetDescription"));

    *OutFilterDescriptor = &MiniportFilterDescriptor;
    return STATUS_SUCCESS;
}

STDMETHODIMP CMiniportDmSynth::DataRangeIntersection
(
    IN      ULONG           PinId,
    IN      PKSDATARANGE    DataRange,
    IN      PKSDATARANGE    MatchingDataRange,
    IN      ULONG           OutputBufferLength,
    OUT     PVOID           ResultantFormat    OPTIONAL,
    OUT     PULONG          ResultantFormatLength
)
{
    // XXX ???
    //
    return STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////////////////////
//
// CDmSynthStream
//

CDmSynthStream::~CDmSynthStream()
{
    _DbgPrintF(DEBUGLVL_TERSE, ("[CDmSynthStream destruct]"));

    if (Miniport)
    {
        Miniport->Stream = NULL;
        Miniport->Release();
    }

    if (Synth)
    {
        delete Synth;
    }

    if (Sink)
    {
        Sink->Release();
    }
}

NTSTATUS CDmSynthStream::Init
(
    CMiniportDmSynth        *Miniport_
)
{
    _DbgPrintF(DEBUGLVL_TERSE, ("[CDmSynthStream::Init]"));
    _DbgPrintF(DEBUGLVL_TERSE, ("Stream IUnkown is %08X", DWORD(PVOID(PUNKNOWN(this)))));

    Miniport = Miniport_;
    Miniport->AddRef();

    Synth = new CSynth;
    if (Synth == NULL)
    {
        Miniport->Release();
        return STATUS_NO_MEMORY;
    }

    Sink = new CSysLink;
    if (Sink == NULL)
    {
        delete Synth;
        Synth = NULL;
        Miniport->Release();
        return STATUS_NO_MEMORY;
    }

    return STATUS_SUCCESS;
}

STDMETHODIMP CDmSynthStream::NonDelegatingQueryInterface
(
    IN  REFIID      Interface,
    OUT PVOID*      Object
)
{
    PAGED_CODE();
    ASSERT(Object);

    if (IsEqualGUIDAligned(Interface, IID_IUnknown))
    {
        *Object = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(Interface, IID_IMiniportSynthesizerStream))
    {
        *Object = PVOID(PMINIPORTSYNTHESIZERSTREAM(this));
    }
    else
    {
        *Object = NULL;
    }

    if (*Object)
    {
        //
        // We reference the interface for the caller.
        //
        PUNKNOWN(*Object)->AddRef();
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

STDMETHODIMP CDmSynthStream::SetState
(
    IN      KSSTATE     NewState
)
{
    PAGED_CODE();

    _DbgPrintF(DEBUGLVL_VERBOSE, ("[CDmSynthStream::SetState]"));

    NTSTATUS nt = STATUS_SUCCESS;

    // XXX Propogate to activate state
    //
    switch (NewState)
    {
        case KSSTATE_RUN:
            nt = Synth->Activate(PortParams.SampleRate,
                                 PortParams.Stereo ? 2 : 1);
            break;

        case KSSTATE_ACQUIRE:
        case KSSTATE_STOP:
        case KSSTATE_PAUSE:
            nt = Synth->Deactivate();
            break;
    }

    return nt;
}

STDMETHODIMP CDmSynthStream::ConnectOutput
(
    PMXFFILTER ConnectionPoint
)
{
    return STATUS_NOT_IMPLEMENTED;
}

STDMETHODIMP CDmSynthStream::DisconnectOutput
(
    PMXFFILTER ConnectionPoint
)
{
    return STATUS_NOT_IMPLEMENTED;
}

STDMETHODIMP CDmSynthStream::PutMessage
(
    IN  PDMUS_KERNEL_EVENT  Event
)
{
    PBYTE Data = (Event->ByteCount <= sizeof(PBYTE) ? &Event->ActualData.Data[0] : Event->ActualData.DataPtr);

    // This is just MIDI bytes
    //
    return Synth->PlayBuffer(Sink,
                             Event->PresTime100Ns,
                             Data,
                             Event->ByteCount,
                             (ULONG)Event->ChannelGroup);
}

// CDmSynthStream::HandlePortParams
//
// Fix up the port params to include defaults. Cache the params as well
// as passing the updated version back.
//
STDMETHODIMP CDmSynthStream::HandlePortParams
(
    IN      PPCPROPERTY_REQUEST pRequest
)
{
    BOOL ValidParamChanged = FALSE;

    SYNTH_PORTPARAMS *Params = (SYNTH_PORTPARAMS*)pRequest->Value;
    if (pRequest->ValueSize < sizeof(SYNTH_PORTPARAMS))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_VOICES))
    {
        Params->Voices = 32;
    }
    else if (Params->Voices > 32)
    {
        Params->Voices = 32;
        ValidParamChanged = TRUE;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_CHANNELGROUPS))
    {
        Params->ChannelGroups = 32;
    }
    else if (Params->ChannelGroups > 32)
    {
        Params->ChannelGroups = 32;
        ValidParamChanged = TRUE;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_SAMPLERATE))
    {
        Params->SampleRate = 22050;
    }
    else if (Params->SampleRate != 11025 && Params->SampleRate != 22050 && Params->SampleRate != 44100)
    {
        Params->SampleRate = 22050;
        ValidParamChanged = TRUE;
    }

    if (!(Params->ValidParams & SYNTH_PORTPARAMS_REVERB))
    {
        Params->Reverb = FALSE;
    }
    else if (Params->Reverb)
    {
        Params->Reverb = FALSE;
        ValidParamChanged = TRUE;
    }

    RtlCopyMemory(&PortParams, Params, sizeof(PortParams));    
    
    return ValidParamChanged ? STATUS_NOT_ALL_ASSIGNED : STATUS_SUCCESS;
}


///////////////////////////////////////////////////////////////////////////////
//
// Property dispatchers
//
// XXX All of these need to be connected
//

NTSTATUS PropertyHandler_SynthCaps
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    SYNTHCAPS caps;

    caps.Flags              = SYNTH_PC_DLS | SYNTH_PC_SOFTWARESYNTH;
    caps.MemorySize         = SYNTH_PC_SYSTEMMEMORY;         
    caps.MaxChannelGroups   = 32;
    caps.MaxVoices          = 32;

    pRequest->ValueSize = min(pRequest->ValueSize, sizeof(caps));
    RtlCopyMemory(pRequest->Value, &caps, pRequest->ValueSize);

    return STATUS_SUCCESS;
}

// PropertyHandler_SynthPortParameters
//
NTSTATUS PropertyHandler_SynthPortParameters
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    ASSERT(pRequest);
    ASSERT(pRequest->MinorTarget);
    
    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->HandlePortParams(pRequest);
}

// PropertyHandler_SynthMasterClock
//
NTSTATUS PropertyHandler_SynthMasterClock
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    return STATUS_SUCCESS;
}

// PropertyHandler_SynthPortChannelGroups
//
NTSTATUS PropertyHandler_SynthPortChannelGroups
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    ASSERT(pRequest);
    ASSERT(pRequest->MinorTarget);

    if (pRequest->ValueSize < sizeof(ULONG))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    ULONG ChannelGroups = *(PULONG)(pRequest->Value);

    return (PDMSYNTHSTREAM(pRequest->MinorTarget))->Synth->SetNumChannelGroups(ChannelGroups);
}

// PropertyHandler_DlsDownload
//
NTSTATUS PropertyHandler_DlsDownload
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    // XXX Lock down this memory
    //
    // XXX Validate entire buffer size???
    //
    HANDLE DownloadHandle;
    BOOL Free;

    NTSTATUS Status = (PDMSYNTHSTREAM(pRequest->MinorTarget))->Synth->Download(
        &DownloadHandle,
        pRequest->Value,
        &Free);

    if (SUCCEEDED(Status))
    {
        ASSERT(pRequest->ValueSize >= sizeof(DownloadHandle));
        RtlCopyMemory(pRequest->Value, &DownloadHandle, sizeof(DownloadHandle));
        pRequest->ValueSize = sizeof(DownloadHandle);
    }

    return Status;
}

// PropertyHandler_DlsUnload
//
HRESULT CALLBACK UnloadComplete(HANDLE,HANDLE);

NTSTATUS PropertyHandler_DlsUnload
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    ASSERT(pRequest);
    ASSERT(pRequest->MinorTarget);

    if (pRequest->ValueSize < sizeof(HANDLE))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    // XXX Need some concurrency control here
    //
    NTSTATUS Status = (PDMSYNTHSTREAM(pRequest->MinorTarget))->Synth->Unload(
        *(HANDLE*)pRequest->Value,
        UnloadComplete,
        (HANDLE)pRequest);
    
    return STATUS_SUCCESS;
}

HRESULT CALLBACK UnloadComplete(HANDLE WhichDownload, HANDLE CallbackInstance)
{
    PPCPROPERTY_REQUEST pRequest = (PPCPROPERTY_REQUEST)CallbackInstance;
        
    PcCompletePendingPropertyRequest(pRequest, STATUS_SUCCESS);

    return STATUS_SUCCESS;
}

// PropertyHandler_DlsCompact
//
// We don't care
//
NTSTATUS PropertyHandler_DlsCompact
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    return STATUS_SUCCESS;
}

NTSTATUS PropertyHandler_DlsAppend
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    ASSERT(pRequest);

    if (pRequest->ValueSize < sizeof(ULONG))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    *(PULONG)(pRequest->Value) = 4;
    pRequest->ValueSize = sizeof(ULONG);

    return STATUS_SUCCESS;
}

NTSTATUS PropertyHandler_DlsVolume
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    // XXX *Both* versions of the synth need this
    //
    return STATUS_SUCCESS;
}

NTSTATUS PropertyHandler_GetLatency
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    if (pRequest->ValueSize < sizeof(ULONGLONG))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    *((PULONGLONG)pRequest->Value) = 0;
    pRequest->ValueSize = sizeof(ULONGLONG);

    return STATUS_SUCCESS;
}

NTSTATUS PropertyHandler_GetLatencyClock
(
    IN PPCPROPERTY_REQUEST pRequest
)
{
    // XXX This depends on the synth sink
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\instr.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      Instrument.cpp
//

#include "simple.h"
#include <mmsystem.h>
#include <dmerror.h>
#include "synth.h"
#include "math.h"
#include "debug.h"
#include "..\shared\validate.h"
#include <dmusicf.h>
void MemDump(char * prompt);

CSourceLFO::CSourceLFO()

{
    Init(0);
}

void CSourceLFO::Init(DWORD dwMode)

{
    m_Registers.dwLFO = dwMode;
    m_Registers.lAmplitudeModulation = 0;
    m_Registers.dwDelay = 0;
    m_Registers.dwDelta = 5 * 65536 / 1500; // 5hz.
    m_Registers.lFilterCutOffRange = 0;
    m_Registers.lPitchModulation = 0;
//    m_pfFrequency = (256 * 4096 * 16 * 5) / dwSampleRate;
//    m_stDelay = 0;
    m_prMWPitchScale = 0;
    m_vrMWVolumeScale = 0;
    m_vrVolumeScale = 0;
    m_prPitchScale = 0;
    m_prCPPitchScale = 0;
    m_vrCPVolumeScale = 0;
    m_prCutoffScale = 0;
    m_prMWCutoffScale = 0;
    m_prCPCutoffScale = 0;    
}

void CSourceLFO::Verify()

{
//    FORCEBOUNDS(m_pfFrequency,64,7600);
//    FORCEBOUNDS(m_stDelay,0,441000);
    FORCEBOUNDS(m_vrVolumeScale,-120,120);
    FORCEBOUNDS(m_vrMWVolumeScale,-120,120);
    FORCEBOUNDS(m_prPitchScale,-1200,1200);
    FORCEBOUNDS(m_prMWPitchScale,-1200,1200);
    FORCEBOUNDS(m_prCPPitchScale,-1200,1200);
    FORCEBOUNDS(m_vrCPVolumeScale,-120,120);
    FORCEBOUNDS(m_prCutoffScale, -12800, 12800);
    FORCEBOUNDS(m_prMWCutoffScale, -12800, 12800);
    FORCEBOUNDS(m_prCPCutoffScale, -12800, 12800);
    FORCEBOUNDS(m_Registers.lAmplitudeModulation,-128,127);
    FORCEBOUNDS(m_Registers.dwDelay,0,0x7FFF);
    FORCEBOUNDS(m_Registers.lFilterCutOffRange,-128,127);
    FORCEBOUNDS(m_Registers.lPitchModulation,-128,127);
    FORCEBOUNDS(m_Registers.dwDelta,0,0x3FF);
}

CSourceEG::CSourceEG()

{
    Init(0);
}

void CSourceEG::Init(DWORD dwEG)

{
    m_trVelAttackScale = 0;
    m_trKeyDecayScale = 0;
    m_trKeyHoldScale = 0;
    m_prCutoffScale = 0;
    m_Registers.dwAttack = 0;
    m_Registers.dwDecay = 0;
    m_Registers.dwDelay = 0;
    m_Registers.dwEG = dwEG;
    m_Registers.lFilterCutOff = 0;
    m_Registers.dwHold = 0;
    m_Registers.dwMode = DSEG_MODE_DELAY;
    m_Registers.lPitchScale = 0;
    m_Registers.dwRelease = 0;
    m_Registers.dwSustain = 255;
}


void CSourceEG::Verify()

{
//    FORCEBOUNDS(m_stAttack,0,1764000);
//    FORCEBOUNDS(m_stDecay,0,1764000);
//    FORCEBOUNDS(m_pcSustain,0,1000);
//    FORCEBOUNDS(m_stRelease,0,1764000);
//    FORCEBOUNDS(m_sScale,-1200,1200);
    FORCEBOUNDS(m_trKeyDecayScale,-12000,12000);
    FORCEBOUNDS(m_trVelAttackScale,-12000,12000);
    FORCEBOUNDS(m_trKeyHoldScale,-12000,12000);
    FORCEBOUNDS(m_prCutoffScale,-12800,12800);
    FORCEBOUNDS(m_Registers.dwAttack,0,3750);
    FORCEBOUNDS(m_Registers.dwDecay,0,3750);
    FORCEBOUNDS(m_Registers.dwDelay,0,3750);
    FORCEBOUNDS(m_Registers.lFilterCutOff,-128,127);
    FORCEBOUNDS(m_Registers.dwHold,0,3750);
    FORCEBOUNDS(m_Registers.lPitchScale,-128,127);
    FORCEBOUNDS(m_Registers.dwRelease,0,3750);
    FORCEBOUNDS(m_Registers.dwSustain,0,255);
}

CSourceFilter::CSourceFilter()
{
    Init();
}

void CSourceFilter::Init()
{
    // First, calculate the playback samplerate in pitch rels. 
    // The reference frequency is a440, which is midi note 69.
    // So, calculate the ratio of the sample rate to 440 and
    // convert into prels (1200 per octave), then add the 
    // offset of 6900.
//    double fSampleRate = (double)48000;

//    fSampleRate /= 440.0;
//    fSampleRate = log(fSampleRate) / log(2.0);
//    fSampleRate *= 1200.0;
//    fSampleRate += 6900.0;
//    m_prSampleRate = (PRELS)fSampleRate;

    m_prCutoff = (PRELS)0x7FFF;
    m_vrQ = (VRELS)0;
    m_prVelScale = (PRELS)0;
    m_prKeyScale = (PRELS)0;
//    m_prCutoffSRAdjust = 0;
//    m_iQIndex = 0;
}


void CSourceFilter::Verify()
{
    if ( m_prCutoff == 0x7FFF )
    {
        m_vrQ = 0;
        m_prVelScale = 0;
        m_prKeyScale = 0;
    }
    else
    {
        FORCEBOUNDS(m_prCutoff, 5535, 11921);
        FORCEBOUNDS(m_vrQ, 0, 225);
        FORCEBOUNDS(m_prVelScale, -12800, 12800);
    }
}

CSourceArticulation::CSourceArticulation()

{
//    m_sVelToVolScale = -9600;
    m_wUsageCount = 0;
    m_sDefaultPan = 0;
//    m_dwSampleRate = 22050;
//    m_PitchEG.m_sScale = 0; // pitch envelope defaults to off
}

void CSourceArticulation::Init(BOOL fWave)

{
    m_VolumeEG.Init(DSEG_AMPLITUDE);
    m_PitchEG.Init(DSEG_MULTI);
    m_LFO.Init(DSLFO_MULTI);       
    m_LFO2.Init(DSLFO_PITCH);      
    m_Filter.Init();
    if (fWave)
    {
        // For Wave, set the volume attack and release to fade in and out very quickly.
        m_VolumeEG.m_Registers.dwRelease = 1;
        m_VolumeEG.m_Registers.dwDecay = 1;
        // And turn off the pitch/filter envelope.
        m_PitchEG.m_Registers.dwMode = DSEG_MODE_DISABLE ;
    }
}

void CSourceArticulation::Verify()

{
    m_LFO.Verify();
    m_PitchEG.Verify();
    m_VolumeEG.Verify();
    m_LFO2.Verify();
    m_Filter.Verify();
}

void CSourceArticulation::AddRef()

{
    m_wUsageCount++;
}

void CSourceArticulation::Release()

{
    m_wUsageCount--;
    if (m_wUsageCount == 0)
    {
        delete this;
    }
}

CSourceSample::CSourceSample()

{
    m_pWave = NULL;
    m_dwLoopStart = 0;
    m_dwLoopEnd = 1;
    m_dwLoopType = WLOOP_TYPE_FORWARD;
    m_dwSampleLength = 0;
    m_dwSampleDataSize = 0;
    m_prFineTune = 0;
    m_dwSampleRate = 22050;
    m_bMIDIRootKey = 60;
    m_bOneShot = TRUE;
    m_bSampleType = 0;
}

CSourceSample::~CSourceSample()

{ 
    if (m_pWave != NULL)
    {
        m_pWave->Release();
    }
}

void CSourceSample::Verify()

{
    if (m_pWave != NULL)
    {
        FORCEBOUNDS(m_dwSampleLength,0,m_pWave->m_dwSampleLength);
        FORCEBOUNDS(m_dwLoopEnd,1,m_dwSampleLength);
        FORCEBOUNDS(m_dwLoopStart,0,m_dwLoopEnd);
        if ((m_dwLoopEnd - m_dwLoopStart) < 6) 
        {
            m_bOneShot = TRUE;
        }
    }
    FORCEBOUNDS(m_dwSampleRate,3000,200000);
    FORCEBOUNDS(m_bMIDIRootKey,0,127);
    FORCEBOUNDS(m_prFineTune,-1200,1200);
}

BOOL CSourceSample::CopyFromWave()

{
    if (m_pWave == NULL)
    {
        return FALSE;
    }
    m_dwSampleLength = m_pWave->m_dwSampleLength;
    m_dwSampleRate = m_pWave->m_dwSampleRate;
    m_bSampleType = m_pWave->m_bSampleType; 
    m_dwSampleDataSize = m_pWave->m_dwSampleDataSize;
    if (m_bOneShot)
    {
/*        m_dwSampleLength--;
        if (m_pWave->m_bSampleType & SFORMAT_16)
        {
            m_pWave->m_pnWave[m_dwSampleLength] = 0;
        }
        else
        {
            char *pBuffer = (char *) m_pWave->m_pnWave;
            pBuffer[m_dwSampleLength] = 0;
        }*/
    }
    else 
    {
        if (m_dwLoopStart >= m_dwSampleLength)
        {
            m_dwLoopStart = 0;
        }
/*        if (m_pWave->m_bSampleType & SFORMAT_16)
        {
            m_pWave->m_pnWave[m_dwSampleLength-1] =
                m_pWave->m_pnWave[m_dwLoopStart];
        }
        else
        {
            char *pBuffer = (char *) m_pWave->m_pnWave;
            pBuffer[m_dwSampleLength-1] =
                pBuffer[m_dwLoopStart];
        }*/
    }
    Verify();
    return (TRUE);
}


CWave::CWave()
{
    m_hUserData = NULL;
    m_lpFreeHandle = NULL;
    m_pnWave = NULL;
    m_dwSampleRate = 22050;
    m_bSampleType = SFORMAT_16;
    m_dwSampleLength = 0;
    m_dwSampleDataSize = 0;
    m_wUsageCount = 0;
    m_dwID = 0;
    m_wPlayCount = 0;
    m_bStream = FALSE;
    m_bActive = FALSE;      
    m_bLastSampleInit = FALSE;
    m_bValid = FALSE;
}

CWave::~CWave()

{
    if (m_pnWave && m_lpFreeHandle)
    {
        m_lpFreeHandle((HANDLE) this,m_hUserData);
    }
#ifdef XMIX
#ifdef DVTSNOOPBUG
    if(m_pnWave){
        XPhysicalFree(m_pnWave);
    }
#endif
#endif
}

void CWave::Verify()

{
    FORCEBOUNDS(m_dwSampleRate,3000,200000);
}

void CWave::PlayOn()

{
    m_wPlayCount++;
    AddRef();
}

void CWave::PlayOff()

{
    m_wPlayCount--;
    Release();
}

BOOL CWave::IsPlaying()

{
    return (m_wPlayCount);
}

void CWave::AddRef()

{
    m_wUsageCount++;
}

void CWave::Release()

{
    m_wUsageCount--;
    if (m_wUsageCount == 0)
    {
        delete this;
    }
}

CSourceRegion::CSourceRegion()
{
    m_pArticulation = NULL;
    m_vrAttenuation = 0;
    m_prTuning = 0;
    m_bKeyHigh = 127;
    m_bKeyLow = 0;
    m_bGroup = 0;
    m_bAllowOverlap = FALSE;
    m_bVelocityHigh = 127;
    m_bVelocityLow  = 0;
    m_dwChannel = 0;
    m_sWaveLinkOptions = 0;
}

CSourceRegion::~CSourceRegion()
{
    if (m_pArticulation)
    {
        m_pArticulation->Release();
    }
}

void CSourceRegion::Verify()

{
    FORCEBOUNDS(m_bKeyHigh,0,127);
    FORCEBOUNDS(m_bKeyLow,0,127);
    FORCEBOUNDS(m_prTuning,-12000,12000);
    FORCEBOUNDS(m_vrAttenuation,-9600,0);
    m_Sample.Verify();
    if (m_pArticulation != NULL)
    {
        m_pArticulation->Verify();
    }
}

CInstrument::CInstrument() : m_MemTrack(DMTRACK_INSTRUMENT)
{
    m_dwProgram = 0;
}

CInstrument::~CInstrument()
{
    while (!m_RegionList.IsEmpty())
    {
        CSourceRegion *pRegion = m_RegionList.RemoveHead();
        delete pRegion;
    }
}

void CInstrument::Verify()

{
    CSourceRegion *pRegion = m_RegionList.GetHead();
    CSourceArticulation *pArticulation = NULL;
    for (;pRegion != NULL;pRegion = pRegion->GetNext())
    {
        if (pRegion->m_pArticulation != NULL)
        {
            pArticulation = pRegion->m_pArticulation;
        }
        pRegion->Verify();
    }
    pRegion = m_RegionList.GetHead();
    for (;pRegion != NULL;pRegion = pRegion->GetNext())
    {
        if (pRegion->m_pArticulation == NULL  && pArticulation)
        {
            pRegion->m_pArticulation = pArticulation;
            pArticulation->AddRef();
        }
    }
}

CSourceRegion * CInstrument::ScanForRegion(DWORD dwNoteValue, DWORD dwVelocity, CSourceRegion *pRegion)

{
    if ( pRegion == NULL )
        pRegion = m_RegionList.GetHead(); // Starting search 
    else
        pRegion = pRegion->GetNext();     // Continuing search through the rest of the regions

    for (;pRegion;pRegion = pRegion->GetNext())
    {
        if (dwNoteValue >= pRegion->m_bKeyLow  &&
            dwNoteValue <= pRegion->m_bKeyHigh && 
            dwVelocity  >= pRegion->m_bVelocityLow &&
            dwVelocity  <= pRegion->m_bVelocityHigh )
        {
            break ;
        }
    }
    return pRegion;
}

CInstManager *g_pInstManager = NULL;

CInstManager::CInstManager()

{
    m_dwSampleRate = 22050;
    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;
    m_dwSynthMemUse = 0;
    g_pInstManager = this;
}

CInstManager::~CInstManager()

{
    if (g_pInstManager == this)
    {
        g_pInstManager = NULL;
    }
    if (m_fCSInitialized)
    {
       	while (!m_CollectionList.IsEmpty())
        {
            CCollection *pCollection = m_CollectionList.RemoveHead();
            delete pCollection;
        }

        while (!m_FreeWavePool.IsEmpty()) 
        {
            CWave *pWave = m_FreeWavePool.RemoveHead();
            pWave->Release();
        }
    
/*        for(int nCount = 0; nCount < WAVEART_HASH_SIZE; nCount++)
        {
            while(!m_WaveArtList[nCount].IsEmpty())
            {
                CWaveArt* pWaveArt = m_WaveArtList[nCount].RemoveHead();
                if(pWaveArt)
                {
                    pWaveArt->Release();
                }
            }
        }*/

        DeleteCriticalSection(&m_CriticalSection);
    }
}

void CInstManager::Verify()

{
    DWORD dwIndex;
    EnterCriticalSection(&m_CriticalSection);
    CCollection *pCollection = m_CollectionList.GetHead();
    for(;pCollection;pCollection = pCollection->GetNext())
    {
        for (dwIndex = 0;dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
        {
            CInstrument *pInstrument = pCollection->m_InstrumentList[dwIndex].GetHead();
            for (;pInstrument != NULL;pInstrument = pInstrument->GetNext())
            {
                pInstrument->Verify();
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
}

CInstrument * CInstManager::GetInstrument(DWORD dwProgram, DWORD dwKey, DWORD dwVelocity)

{
    CInstrument *pInstrument = NULL;
    EnterCriticalSection(&m_CriticalSection);
    CCollection *pCollection = m_CollectionList.GetHead();
    for (;pCollection != NULL; pCollection = pCollection->GetNext())
    {
        pInstrument = pCollection->m_InstrumentList[dwProgram % INSTRUMENT_HASH_SIZE].GetHead();
        for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
        {
            if (pInstrument->m_dwProgram == dwProgram) 
            {
                if (pInstrument->ScanForRegion(dwKey, dwVelocity, NULL) != NULL)
                {
                    break;
                }
                else
                {
                    Trace(2,"Warning: No region was found in instrument # %lx that matched note %ld\n",
                        dwProgram,dwKey);
                }
            }
        }
        if (pInstrument) break;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return (pInstrument);
}


DWORD TimeCents2Samples(long tcTime, DWORD dwSampleRate)
{
    if (tcTime ==  0x80000000) return (0);
    double flTemp = tcTime;
    flTemp /= (65536 * 1200);
    flTemp = pow(2.0,flTemp);
    flTemp *= dwSampleRate;
    return (DWORD) flTemp;
}

DWORD PitchCents2PitchFract(long pcRate,DWORD dwSampleRate)

{
    double fTemp = pcRate;
    fTemp /= 65536;
    fTemp -= 6900;
    fTemp /= 1200;
    fTemp = pow(2.0,fTemp);
    fTemp *= 7381975040.0; // (440*256*16*4096);
    fTemp /= dwSampleRate;
    return (DWORD) (fTemp);
}

HRESULT CSourceArticulation::Download(DMUS_DOWNLOADINFO * pInfo, 
                                void * pvOffsetTable[], 
                                DWORD dwIndex, 
                                DWORD dwSampleRate,
                                BOOL fNewFormat)
{
    if (fNewFormat)
    {
        DMUS_ARTICULATION2 * pdmArtic = 
            (DMUS_ARTICULATION2 *) pvOffsetTable[dwIndex];
        while (pdmArtic)
        {
            if (pdmArtic->ulArtIdx)
            {
                if (pdmArtic->ulArtIdx >= pInfo->dwNumOffsetTableEntries)
                {
                    Trace(1,"Error: Download failed because articulation chunk has an error.\n");
                    return DMUS_E_BADARTICULATION;
                }           
                DWORD dwPosition;
                void *pData = pvOffsetTable[pdmArtic->ulArtIdx];
                CONNECTIONLIST * pConnectionList = 
                    (CONNECTIONLIST *) pData;
                CONNECTION *pConnection;
                dwPosition = sizeof(CONNECTIONLIST);
                for (dwIndex = 0; dwIndex < pConnectionList->cConnections; dwIndex++)
                {
                    pConnection = (CONNECTION *) ((BYTE *)pData + dwPosition);
                    dwPosition += sizeof(CONNECTION);
                    switch (pConnection->usSource)
                    {
                    case CONN_SRC_NONE :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_LFO_FREQUENCY :
                            m_LFO.m_Registers.dwDelta = PitchCents2PitchFract(
                                pConnection->lScale,6000*64); // 48000*64 / 8)
                            break;
                        case CONN_DST_LFO_STARTDELAY :
                            m_LFO.m_Registers.dwDelay = (DWORD) TimeCents2Samples(
                                (TCENT) pConnection->lScale,1500); // 48000 / 32
                            break;
                        case CONN_DST_EG1_ATTACKTIME :
                            m_VolumeEG.m_Registers.dwAttack = TimeCents2Samples(
                                (TCENT) pConnection->lScale,94); // 48000 / 512
                            break;
                        case CONN_DST_EG1_DECAYTIME :
                            m_VolumeEG.m_Registers.dwDecay = TimeCents2Samples(
                            (TCENT) pConnection->lScale,94);
                            break;
                        case CONN_DST_EG1_SUSTAINLEVEL :
                            {
                                // The nvidia chip takes the sustain level in 
                                // absolute volume, not dB, so first convert.
                                long lTemp = (pConnection->lScale >> 16) - 1000;
                                lTemp *= 9600;
                                lTemp /= 1000;
                                lTemp = CDigitalAudio::VRELToVFRACT(lTemp);
                                m_VolumeEG.m_Registers.dwSustain = lTemp >> 4;
                            }
                            break;
                        case CONN_DST_EG1_RELEASETIME :
                            m_VolumeEG.m_Registers.dwRelease = TimeCents2Samples(
                                (TCENT) pConnection->lScale,94);
                            break;
                        case CONN_DST_EG2_ATTACKTIME :
                            m_PitchEG.m_Registers.dwAttack = TimeCents2Samples(
                                (TCENT) pConnection->lScale,94);
                            break;
                        case CONN_DST_EG2_DECAYTIME :
                            m_PitchEG.m_Registers.dwDecay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,94);
                            break;
                        case CONN_DST_EG2_SUSTAINLEVEL :
                            m_PitchEG.m_Registers.dwSustain =
                                (SPERCENT) ((long) (pConnection->lScale / 257003));
                            break;
                        case CONN_DST_EG2_RELEASETIME :
                            m_PitchEG.m_Registers.dwRelease = TimeCents2Samples(
                                (TCENT) pConnection->lScale,94); 
                            break;
                        case CONN_DST_PAN :
                            m_sDefaultPan = (short) 
                                ((long) ((long) pConnection->lScale >> 12) / 125);
                            break;

                        /* DLS2 */
                        case CONN_DST_EG1_DELAYTIME:
                            m_VolumeEG.m_Registers.dwDelay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,94);
                            break;
                        case CONN_DST_EG1_HOLDTIME:
                            m_VolumeEG.m_Registers.dwHold  = TimeCents2Samples(
                                (TCENT) pConnection->lScale,94);
                            break;
                        case CONN_DST_EG2_DELAYTIME:
                            m_PitchEG.m_Registers.dwDelay  = TimeCents2Samples(
                                (TCENT) pConnection->lScale,94);
                            break;
                        case CONN_DST_EG2_HOLDTIME:
                            m_PitchEG.m_Registers.dwHold = TimeCents2Samples(
                                (TCENT) pConnection->lScale,94);
                            break;
                        case CONN_DST_VIB_FREQUENCY :
                            m_LFO2.m_Registers.dwDelta = PitchCents2PitchFract(
                                pConnection->lScale,6000*64);
                            break;    
                        case CONN_DST_VIB_STARTDELAY :
                            m_LFO2.m_Registers.dwDelay = TimeCents2Samples(
                                (TCENT) pConnection->lScale,1500);
                            break;                                
                        case CONN_DST_FILTER_CUTOFF:
                            // First, get the filter cutoff frequency, which is relative to a440.
                            m_Filter.m_prCutoff = (PRELS)
                                (pConnection->lScale >> 16);
                            // Then, calculate the resulting prel, taking into consideration
                            // the sample rate and the base of the filter coefficient lookup
                            // table, relative to the sample rate (FILTER_FREQ_RANGE).
                            // This number can then be used directly look up the coefficients in the
                            // filter table. 
         //                   m_Filter.m_prCutoffSRAdjust = (PRELS)
         //                       FILTER_FREQ_RANGE - m_Filter.m_prSampleRate + m_Filter.m_prCutoff; 
                            break;
                        case CONN_DST_FILTER_Q:
                            m_Filter.m_vrQ = (VRELS)
                                (pConnection->lScale >> 16); //>>>>>>>> not really VRELS, but 1/10th's
         //                   m_Filter.m_iQIndex = (DWORD)
         //                       ((m_Filter.m_vrQ / 15.0f) + 0.5f);
                            break;
                        }
                        break;
                    case CONN_SRC_LFO :
                        switch (pConnection->usControl)
                        {
                        case CONN_SRC_NONE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_ATTENUATION :
                                m_LFO.m_vrVolumeScale = (VRELS)
                                    ((long) (pConnection->lScale >> 16));
                                m_LFO.m_Registers.lAmplitudeModulation = pConnection->lScale / 38400;
                                break;
                            case CONN_DST_PITCH :
                                m_LFO.m_prPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16)); 
                                m_LFO.m_Registers.lPitchModulation = pConnection->lScale / 614400;
                                break;
                            case CONN_DST_FILTER_CUTOFF:
                                m_LFO.m_prCutoffScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16)); 
                                m_LFO.m_Registers.lFilterCutOffRange = pConnection->lScale / 4915200; 
                                break;
                            }
                            break;
                        case CONN_SRC_CC1 :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_ATTENUATION :
                                m_LFO.m_vrMWVolumeScale = (VRELS)
                                    ((long) (pConnection->lScale >> 16)); 
                                break;
                            case CONN_DST_PITCH :
                                m_LFO.m_prMWPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16)); 
                                break;

                            /* DLS2 */
                            case CONN_DST_FILTER_CUTOFF:
                                m_LFO.m_prMWCutoffScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16)); 
                                break;
                            }
                            break;

                        /* DLS2 */
                        case CONN_SRC_CHANNELPRESSURE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_ATTENUATION :
                                m_LFO.m_vrCPVolumeScale = (VRELS) 
                                    ((long) (pConnection->lScale >> 16)); 
                                break;
                            case CONN_DST_PITCH :
                                m_LFO.m_prCPPitchScale  = (PRELS) 
                                    ((long) (pConnection->lScale >> 16)); 
                                break;

                            /* DLS2 */
                            case CONN_DST_FILTER_CUTOFF:
                                m_LFO.m_prCPCutoffScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16)); 
                                break;
                            }
                            break;
                        }
                        break;
                    case CONN_SRC_KEYONVELOCITY :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_EG1_ATTACKTIME :
                            m_VolumeEG.m_trVelAttackScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_ATTACKTIME :
                            m_PitchEG.m_trVelAttackScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;

                        /* DLS2 */
                        case CONN_DST_FILTER_CUTOFF:
                            m_Filter.m_prVelScale = (PRELS)
                                ((long) (pConnection->lScale >> 16)); 
                            break;
                        }
                        break;
                    case CONN_SRC_KEYNUMBER :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_EG1_DECAYTIME :
                            m_VolumeEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_DECAYTIME :
                            m_PitchEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;

                        /* DLS2 */
                        case CONN_DST_EG1_HOLDTIME :
                            m_PitchEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        case CONN_DST_EG2_HOLDTIME :
                            m_PitchEG.m_trKeyDecayScale = (TRELS)
                                ((long) (pConnection->lScale >> 16));
                        case CONN_DST_FILTER_CUTOFF :
                            m_Filter.m_prKeyScale = (PRELS)
                                ((long) (pConnection->lScale >> 16));
                            break;
                        }
                        break;
                    case CONN_SRC_EG2 :
                        switch (pConnection->usDestination)
                        {
                        case CONN_DST_PITCH :
                            m_PitchEG.m_Registers.lPitchScale = pConnection->lScale / 614400;
                            break;

                        /* DLS2 */
                        case CONN_DST_FILTER_CUTOFF:
                            m_PitchEG.m_Registers.lFilterCutOff = pConnection->lScale / 4915200; 
                            break;
                        }
                        break;      

                    /* DLS2 */
                    case CONN_SRC_VIBRATO :
                        switch (pConnection->usControl)
                        {
                        case CONN_SRC_NONE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_PITCH :
                                m_LFO2.m_prPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16)); 
                                m_LFO2.m_Registers.lPitchModulation = pConnection->lScale / 614400;
                                break;
                            }
                            break;
                        case CONN_SRC_CC1 :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_PITCH :
                                m_LFO2.m_prMWPitchScale = (PRELS)
                                    ((long) (pConnection->lScale >> 16)); 
                                break;
                            }
                            break;
                        case CONN_SRC_CHANNELPRESSURE :
                            switch (pConnection->usDestination)
                            {
                            case CONN_DST_PITCH :
                                m_LFO2.m_prCPPitchScale  = (PRELS) 
                                    ((long) (pConnection->lScale >> 16)); 
                                break;
                            }
                            break;
                        }
                        break;
                    }
                }
            }
            if (pdmArtic->ulNextArtIdx)
            {
                if (pdmArtic->ulNextArtIdx >= pInfo->dwNumOffsetTableEntries)
                {
                    Trace(1,"Error: Download failed because articulation chunk has an error.\n");
                    return DMUS_E_BADARTICULATION;
                }
                pdmArtic = (DMUS_ARTICULATION2 *) pvOffsetTable[pdmArtic->ulNextArtIdx];
            }
            else 
            {
                pdmArtic = NULL;
            }
        }
    }
/*    else
    {
        DMUS_ARTICULATION * pdmArtic = 
            (DMUS_ARTICULATION *) pvOffsetTable[dwIndex];

        if (pdmArtic->ulArt1Idx)
        {
            if (pdmArtic->ulArt1Idx >= pInfo->dwNumOffsetTableEntries)
            {
                Trace(1,"Error: Download failed because articulation chunk has an error.\n");
                return DMUS_E_BADARTICULATION;
            }
            DMUS_ARTICPARAMS * pdmArticParams = 
                (DMUS_ARTICPARAMS *) pvOffsetTable[pdmArtic->ulArt1Idx];

            m_LFO.m_pfFrequency = PitchCents2PitchFract(
                pdmArticParams->LFO.pcFrequency,dwSampleRate);
            m_LFO.m_stDelay = TimeCents2Samples(
                (TCENT) pdmArticParams->LFO.tcDelay,dwSampleRate);
            m_LFO.m_vrVolumeScale = (VRELS)
                ((long) ((pdmArticParams->LFO.gcVolumeScale * 10) >> 16));
            m_LFO.m_prPitchScale = (PRELS)
                ((long) (pdmArticParams->LFO.pcPitchScale >> 16)); 
            m_LFO.m_vrMWVolumeScale = (VRELS)
                ((long) ((pdmArticParams->LFO.gcMWToVolume * 10) >> 16)); 
            m_LFO.m_prMWPitchScale = (PRELS)
                ((long) (pdmArticParams->LFO.pcMWToPitch >> 16)); 

            m_VolumeEG.m_stAttack = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcAttack,dwSampleRate);
            m_VolumeEG.m_stDecay = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcDecay,dwSampleRate);
            m_VolumeEG.m_pcSustain = 
                (SPERCENT) ((long) (pdmArticParams->VolEG.ptSustain >> 16));
            m_VolumeEG.m_stRelease = TimeCents2Samples(
                (TCENT) pdmArticParams->VolEG.tcRelease,dwSampleRate); 
            m_VolumeEG.m_trVelAttackScale = (TRELS)
                ((long) (pdmArticParams->VolEG.tcVel2Attack >> 16));
            m_VolumeEG.m_trKeyDecayScale = (TRELS)
                ((long) (pdmArticParams->VolEG.tcKey2Decay >> 16));

            m_PitchEG.m_trKeyDecayScale = (TRELS)
                ((long) (pdmArticParams->PitchEG.tcKey2Decay >> 16));
            m_PitchEG.m_sScale = (short)
                ((long) (pdmArticParams->PitchEG.pcRange >> 16));
            m_PitchEG.m_trVelAttackScale = (TRELS)
                ((long) (pdmArticParams->PitchEG.tcVel2Attack >> 16));
            m_PitchEG.m_stAttack = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcAttack,dwSampleRate);
            m_PitchEG.m_stDecay = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcDecay,dwSampleRate);
            m_PitchEG.m_pcSustain =
                (SPERCENT) ((long) (pdmArticParams->PitchEG.ptSustain >> 16));
            m_PitchEG.m_stRelease = TimeCents2Samples(
                (TCENT) pdmArticParams->PitchEG.tcRelease,dwSampleRate); 

            m_sDefaultPan = (short) 
                ((long) ((long) pdmArticParams->Misc.ptDefaultPan >> 12) / 125);
        }
    }*/
    Verify();   // Make sure all parameters are legal.

    return S_OK;
}

HRESULT CSourceRegion::Download(DMUS_DOWNLOADINFO * pInfo, 
                                void * pvOffsetTable[], 
                                DWORD *pdwRegionIX, 
                                DWORD dwSampleRate,
                                BOOL fNewFormat)
{
    DMUS_REGION * pdmRegion = (DMUS_REGION *) pvOffsetTable[*pdwRegionIX];
    *pdwRegionIX = pdmRegion->ulNextRegionIdx;  // Clear to avoid loops.
    pdmRegion->ulNextRegionIdx = 0;
    // Read the Region chunk...
    m_bKeyHigh = (BYTE) pdmRegion->RangeKey.usHigh;
    m_bKeyLow  = (BYTE) pdmRegion->RangeKey.usLow;
    m_bVelocityHigh = (BYTE) pdmRegion->RangeVelocity.usHigh;
    m_bVelocityLow  = (BYTE) pdmRegion->RangeVelocity.usLow;

    //
    // Fix DLS Designer bug
    // Designer was putting velocity ranges that fail
    // on DLS2 synths
    //
    if ( m_bVelocityHigh == 0 && m_bVelocityLow == 0 )
        m_bVelocityHigh = 127;

    if (pdmRegion->fusOptions & F_RGN_OPTION_SELFNONEXCLUSIVE)
    {
        m_bAllowOverlap = TRUE;
    }
    else
    {
        m_bAllowOverlap = FALSE;
    }
    m_bGroup = (BYTE) pdmRegion->usKeyGroup;
    // Now, the WSMP and WLOOP chunks...
    m_vrAttenuation = (short) ((long) ((pdmRegion->WSMP.lAttenuation) * 10) >> 16);
    m_Sample.m_prFineTune = pdmRegion->WSMP.sFineTune;
    m_Sample.m_bMIDIRootKey = (BYTE) pdmRegion->WSMP.usUnityNote;
    if (pdmRegion->WSMP.cSampleLoops == 0)
    {
        m_Sample.m_bOneShot = TRUE;
    }
    else
    {
        m_Sample.m_dwLoopStart = pdmRegion->WLOOP[0].ulStart;
        m_Sample.m_dwLoopEnd = m_Sample.m_dwLoopStart + pdmRegion->WLOOP[0].ulLength;
        m_Sample.m_bOneShot = FALSE;
        m_Sample.m_dwLoopType = pdmRegion->WLOOP[0].ulType;
    }
    m_Sample.m_dwSampleRate = dwSampleRate;

    m_sWaveLinkOptions = pdmRegion->WaveLink.fusOptions;
    m_dwChannel = pdmRegion->WaveLink.ulChannel;
    
    if ( (m_dwChannel != WAVELINK_CHANNEL_LEFT) && !IsMultiChannel() )
    {
        Trace(1, "Download failed: Attempt to use a non-mono channel without setting the multichannel flag.\n");
        return DMUS_E_NOTMONO;
    }
    
    m_Sample.m_wID = (WORD) pdmRegion->WaveLink.ulTableIndex;
    
    // Does it have its own articulation?
    //
    if (pdmRegion->ulRegionArtIdx )
    {
        if (pdmRegion->ulRegionArtIdx >= pInfo->dwNumOffsetTableEntries)
        {
            Trace(1,"Error: Download failed because articulation chunk has an error.\n");
            return DMUS_E_BADARTICULATION;
        }

        CSourceArticulation *pArticulation = new CSourceArticulation;
        if (pArticulation)
        {
            pArticulation->Init(FALSE);
            HRESULT hr = pArticulation->Download(pInfo, pvOffsetTable, 
                    pdmRegion->ulRegionArtIdx, dwSampleRate, fNewFormat);

            if (FAILED(hr))
            {
                delete pArticulation;
                return hr;
            }
            m_pArticulation = pArticulation;
            m_pArticulation->AddRef();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}



HRESULT CInstManager::DownloadInstrument(LPHANDLE phDownload, 
                                         DMUS_DOWNLOADINFO *pInfo, 
                                         void *pvOffsetTable[], 
                                         void *pvData,
                                         BOOL fNewFormat)
                                         
{
    DMUS_INSTRUMENT *pdmInstrument = (DMUS_INSTRUMENT *) pvData;
    CInstrument *pInstrument = new CInstrument;
    if (pInstrument)
    {
        Trace(3,"Downloading instrument %lx\n",pdmInstrument->ulPatch);
        pInstrument->m_dwProgram = pdmInstrument->ulPatch;

        DWORD dwRegionIX = pdmInstrument->ulFirstRegionIdx;
        pdmInstrument->ulFirstRegionIdx = 0; // Clear to avoid loops.
        while (dwRegionIX)
        {
            if (dwRegionIX >= pInfo->dwNumOffsetTableEntries)
            {
                Trace(1,"Error: Download failed because instrument has error in region list.\n");
                delete pInstrument;
                return DMUS_E_BADINSTRUMENT;
            }
            CSourceRegion *pRegion = new CSourceRegion;
            if (!pRegion)
            {
                delete pInstrument;
                return E_OUTOFMEMORY;
            }
            pInstrument->m_RegionList.AddHead(pRegion);
            HRESULT hr = pRegion->Download(pInfo, pvOffsetTable, &dwRegionIX, m_dwSampleRate, fNewFormat);
            if (FAILED(hr))
            {
                delete pInstrument;
                return hr;
            }
            EnterCriticalSection(&m_CriticalSection);
            CWave *pWave = m_WavePool[pRegion->m_Sample.m_wID % WAVE_HASH_SIZE].GetHead();
            for (;pWave;pWave = pWave->GetNext())
            {
                if (pRegion->m_Sample.m_wID == pWave->m_dwID)
                {
                    pRegion->m_Sample.m_pWave = pWave;
                    pWave->AddRef();
                    pRegion->m_Sample.CopyFromWave();
                    break;
                }
            }
            LeaveCriticalSection(&m_CriticalSection);
        }
        if (pdmInstrument->ulGlobalArtIdx)
        {
            if (pdmInstrument->ulGlobalArtIdx >= pInfo->dwNumOffsetTableEntries)
            {
                Trace(1,"Error: Download failed because of out of range articulation chunk.\n");
                delete pInstrument;
                return DMUS_E_BADARTICULATION;
            }

            CSourceArticulation *pArticulation = new CSourceArticulation;
            if (pArticulation)
            {
                pArticulation->Init(FALSE);
                HRESULT hr = pArticulation->Download(pInfo, pvOffsetTable, 
                        pdmInstrument->ulGlobalArtIdx, m_dwSampleRate, fNewFormat);
                if (FAILED(hr))
                {
                    delete pArticulation;
                    return hr;
                }
                for (CSourceRegion *pr = pInstrument->m_RegionList.GetHead();
                     pr != NULL;
                     pr = pr->GetNext())
                {
                    if (pr->m_pArticulation == NULL)
                    {
                        pr->m_pArticulation = pArticulation;
                        pArticulation->AddRef();    
                    }
                }
                if (!pArticulation->m_wUsageCount)
                {
                    delete pArticulation;
                }
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            for (CSourceRegion *pr = pInstrument->m_RegionList.GetHead();
                 pr != NULL;
                 pr = pr->GetNext())
            {
                if (pr->m_pArticulation == NULL)
                {
                    Trace(1,"Error: Download failed because region has no articulation.\n");
                    delete pInstrument;
                    return DMUS_E_NOARTICULATION;
                }
            }
        }
        EnterCriticalSection(&m_CriticalSection);
        if (pdmInstrument->ulFlags & DMUS_INSTRUMENT_GM_INSTRUMENT)
        {
            pInstrument->SetNext(NULL);
//            m_InstrumentList[pInstrument->m_dwProgram % INSTRUMENT_HASH_SIZE].AddTail(pInstrument);
        }
        else
        {
//            m_InstrumentList[pInstrument->m_dwProgram % INSTRUMENT_HASH_SIZE].AddHead(pInstrument);
        }
        LeaveCriticalSection(&m_CriticalSection);
        *phDownload = (HANDLE) pInstrument;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInstManager::DownloadWave(LPHANDLE phDownload, 
                                   DMUS_DOWNLOADINFO *pInfo, 
                                   void *pvOffsetTable[], 
                                   void *pvData)
{
    DMUS_WAVE *pdmWave = (DMUS_WAVE *) pvData; 
    if ((pdmWave->WaveformatEx.wFormatTag != WAVE_FORMAT_PCM) &&
        (pdmWave->WaveformatEx.wFormatTag != WAVE_FORMAT_XBOX_ADPCM))
    {
        Trace(1,"Error: Download failed because wave data is not PCM format.\n");
        return DMUS_E_NOTPCM;
    }
    
    if (pdmWave->WaveformatEx.nChannels != 1)
    {
        Trace(1,"Error: Download failed because wave data is not mono.\n");
        return DMUS_E_NOTMONO;
    }

    if (pdmWave->ulWaveDataIdx >= pInfo->dwNumOffsetTableEntries)
    {
        Trace(1,"Error: Download failed because wave data is at invalid location.\n");
        return DMUS_E_BADWAVE;
    }

    CWave *pWave = new CWave;
    if (pWave)
    {   
        DMUS_WAVEDATA *pdmWaveData= (DMUS_WAVEDATA *) 
            pvOffsetTable[pdmWave->ulWaveDataIdx];
        pWave->m_dwID = pInfo->dwDLId;
        pWave->m_hUserData = NULL;
        pWave->m_lpFreeHandle = NULL;
        pWave->m_dwSampleLength = pdmWaveData->cbSize;
        pWave->m_dwSampleDataSize = pdmWaveData->cbSize;
        pWave->m_pnWave = (short *) &pdmWaveData->byData[0];
        pWave->m_dwSampleRate = pdmWave->WaveformatEx.nSamplesPerSec;

        if (pdmWave->WaveformatEx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
        {
            pWave->m_bSampleType = SFORMAT_ADPCM;
            pWave->m_dwSampleLength /= 36;
            pWave->m_dwSampleLength *= 64;  // This forces it to be block aligned.
        }
        else if (pdmWave->WaveformatEx.wBitsPerSample == 8)
        {
            pWave->m_bSampleType = SFORMAT_8;
        }
        else if (pdmWave->WaveformatEx.wBitsPerSample == 16)
        {
            pWave->m_dwSampleLength >>= 1;
            pWave->m_bSampleType = SFORMAT_16;
        }
        else
        {
            Trace(1,"Error: Downloading wave %ld, bad wave format.\n",pInfo->dwDLId);
            delete pWave;
            return DMUS_E_BADWAVE;
        }
        // The following line is commented out becase Xbox hardware mixing doesn't need the extra sample?
//        pWave->m_dwSampleLength++;  // We always add one sample to the end for interpolation.
        EnterCriticalSection(&m_CriticalSection);
        m_WavePool[pWave->m_dwID % WAVE_HASH_SIZE].AddHead(pWave);
        LeaveCriticalSection(&m_CriticalSection);
        *phDownload = (HANDLE) pWave;
        pWave->AddRef();

        // Track memory usage 
        m_dwSynthMemUse += pWave->m_dwSampleDataSize;  
        Trace(3,"Downloading wave %ld memory usage %ld\n",pInfo->dwDLId,m_dwSynthMemUse);

        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInstManager::Download(LPHANDLE phDownload, 
                               void * pvData,
                               LPBOOL pbFree)
                               

{
    V_INAME(IDirectMusicSynthX::Download);
    V_BUFPTR_READ(pvData,sizeof(DMUS_DOWNLOADINFO));

    HRESULT hr = DMUS_E_UNKNOWNDOWNLOAD;
    void ** ppvOffsetTable;     // Array of pointers to chunks in data.
    DMUS_DOWNLOADINFO * pInfo = (DMUS_DOWNLOADINFO *) pvData;
    DMUS_OFFSETTABLE* pOffsetTable = (DMUS_OFFSETTABLE *)(((BYTE*)pvData) + sizeof(DMUS_DOWNLOADINFO));
    char *pcData = (char *) pvData;

    V_BUFPTR_READ(pvData,pInfo->cbSize);

    //Code fails if pInfo->dwNumOffsetTableEntries == 0
    //Saninty check here for debug
    assert(pInfo->dwNumOffsetTableEntries);
    
    ppvOffsetTable = new void *[pInfo->dwNumOffsetTableEntries];
    if (ppvOffsetTable) // Create the pointer array and validate.
    {
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < pInfo->dwNumOffsetTableEntries; dwIndex++)
        {
            if (pOffsetTable->ulOffsetTable[dwIndex] >= pInfo->cbSize)
            {
                delete[] ppvOffsetTable;
                Trace(1,"Error: Download failed because of corrupt download tables.\n");
                return DMUS_E_BADOFFSETTABLE;   // Bad!
            }
            ppvOffsetTable[dwIndex] = (void *) &pcData[pOffsetTable->ulOffsetTable[dwIndex]];
        }
        if (pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT) // Instrument.
        {
            *pbFree = TRUE;
            hr = DownloadInstrument(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0],FALSE); 
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_INSTRUMENT2) // New instrument format.
        {
            *pbFree = TRUE;
            hr = DownloadInstrument(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0],TRUE); 
        }
        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_WAVE) // Wave.
        {
            *pbFree = FALSE;
            hr = DownloadWave(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]); 
        }
//        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_WAVEARTICULATION) // Wave onshot & streaming 
//        {
//            *pbFree = TRUE;
//            hr = DownloadWaveArticulation(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]); 
//        }
//        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_STREAMINGWAVE) // Streaming 
//        {
//            *pbFree = FALSE;
//            hr = DownloadWaveRaw(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]); 
//        }
//        else if (pInfo->dwDLType == DMUS_DOWNLOADINFO_ONESHOTWAVE) // Wave onshot
//        {
//            *pbFree = FALSE;
//            hr = DownloadWaveRaw(phDownload, pInfo, ppvOffsetTable, ppvOffsetTable[0]); 
//        }

        delete[] ppvOffsetTable;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CInstManager::Unload(HANDLE hDownload,
                             HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                             HANDLE hUserData)

{
    DWORD dwIndex;
    EnterCriticalSection(&m_CriticalSection);
/*    for (dwIndex = 0; dwIndex < INSTRUMENT_HASH_SIZE; dwIndex++)
    {
        CInstrument *pInstrument = m_InstrumentList[dwIndex].GetHead();
        for (;pInstrument != NULL; pInstrument = pInstrument->GetNext())
        {
            if (pInstrument == (CInstrument *) hDownload) 
            {
                Trace(3,"Unloading instrument %lx\n",pInstrument->m_dwProgram);
                m_InstrumentList[dwIndex].Remove(pInstrument);
                delete pInstrument;
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }*/
    for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
    {
        CWave *pWave = m_WavePool[dwIndex].GetHead();
        for (;pWave != NULL;pWave = pWave->GetNext())
        {
            if (pWave == (CWave *) hDownload)
            {
                // Track memory usage 
                m_dwSynthMemUse -= pWave->m_dwSampleDataSize;  

                Trace(3,"Unloading wave %ld memory usage %ld\n",pWave->m_dwID,m_dwSynthMemUse);
                m_WavePool[dwIndex].Remove(pWave);

                pWave->m_hUserData = hUserData;
                pWave->m_lpFreeHandle = lpFreeHandle;
                pWave->Release();
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }
/*    for (dwIndex = 0; dwIndex < WAVE_HASH_SIZE; dwIndex++)
    {
        CWaveArt* pWaveArt = m_WaveArtList[dwIndex].GetHead();
        for (;pWaveArt != NULL;pWaveArt = pWaveArt->GetNext())
        {
            if (pWaveArt == (CWaveArt *) hDownload)
            {
                Trace(3,"Unloading wave articulation %ld\n",pWaveArt->m_dwID,m_dwSynthMemUse);
                m_WaveArtList[dwIndex].Remove(pWaveArt);

                pWaveArt->Release();
                LeaveCriticalSection(&m_CriticalSection);
                return S_OK;
            }
        }
    }*/
    LeaveCriticalSection(&m_CriticalSection);
    Trace(1,"Error: Unload failed - downloaded object not found.\n");
    return E_FAIL;
}

//////////////////////////////////////////////////////////
// Directx8 Methods 

CWave * CInstManager::GetWave(DWORD dwDLId)
{
    EnterCriticalSection(&m_CriticalSection);
    CWave *pWave = m_WavePool[dwDLId % WAVE_HASH_SIZE].GetHead();
    for (;pWave;pWave = pWave->GetNext())
    {
        if (dwDLId == pWave->m_dwID)
        {
            break;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);

    return pWave;
}

/*CWaveArt *  CInstManager::GetWaveArt(DWORD dwDLId)
{
    EnterCriticalSection(&m_CriticalSection);
    CWaveArt *pWaveArt = m_WaveArtList[dwDLId % WAVEART_HASH_SIZE].GetHead();
    for (;pWaveArt;pWaveArt = pWaveArt->GetNext())
    {
        if (dwDLId == pWaveArt->m_dwID)
        {
            break;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);

    return pWaveArt;
}

HRESULT CInstManager::DownloadWaveArticulation(LPHANDLE phDownload, 
                                   DMUS_DOWNLOADINFO *pInfo, 
                                   void *pvOffsetTable[], 
                                   void *pvData)
{
    DMUS_WAVEARTDL* pWaveArtDl  = (DMUS_WAVEARTDL*)pvData; 
    WAVEFORMATEX *pWaveformatEx = (WAVEFORMATEX *) pvOffsetTable[1]; 
    DWORD *dwDlId = (DWORD*)pvOffsetTable[2]; 
    DWORD i;

    CWaveArt* pWaveArt = new CWaveArt();
    if ( pWaveArt )
    {
        pWaveArt->m_dwID = pInfo->dwDLId;
        pWaveArt->m_WaveArtDl = *pWaveArtDl;;
        pWaveArt->m_WaveformatEx = *pWaveformatEx;
        if (pWaveArt->m_WaveformatEx.nChannels > 1)
        {
            pWaveArt->m_WaveformatEx.nAvgBytesPerSec /= pWaveArt->m_WaveformatEx.nChannels;
            pWaveArt->m_WaveformatEx.nBlockAlign /= pWaveArt->m_WaveformatEx.nChannels;
            pWaveArt->m_WaveformatEx.nChannels = 1;
        }
        if (pWaveformatEx->wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
        {
            pWaveArt->m_bSampleType = SFORMAT_ADPCM;
        }
        else if (pWaveformatEx->wBitsPerSample == 8)
        {
            pWaveArt->m_bSampleType = SFORMAT_8;
        }
        else if (pWaveformatEx->wBitsPerSample == 16)
        {
            pWaveArt->m_bSampleType = SFORMAT_16;
        }
        else
        {
            Trace(1,"Error: Download failed because wave data is %ld bits instead of 8 or 16.\n",(long) pWaveformatEx->wBitsPerSample);
            delete pWaveArt;
            return DMUS_E_BADWAVE;
        }

        for ( i = 0; i < pWaveArtDl->ulBuffers; i++ )
        {
            // Get wave buffer and fill header with waveformat data
            CWave *pWave = GetWave(dwDlId[i]);
            assert(pWave);
            if (!pWave)
            {
                delete pWaveArt;
                return E_POINTER;
            }
            pWave->m_dwSampleRate = pWaveformatEx->nSamplesPerSec;
            // Reset the sample length so it can be set correctly in the ensuing sample size cases.
            pWave->m_dwSampleLength = pWave->m_dwSampleDataSize;

            if (pWaveformatEx->wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
            {
                // Every 36 bytes is 64 samples. Buffer must be a multiple of 36 bytes or the
                // wave will be garbled on playback when we cross a buffer boundary.
                assert(pWave->m_dwSampleLength / 36 * 36 == pWave->m_dwSampleLength);

                pWave->m_dwSampleLength /= 36;
                pWave->m_dwSampleLength *= 64;  // This forces it to be block aligned.
                pWave->m_bSampleType = SFORMAT_ADPCM;
            }
            else if (pWaveformatEx->wBitsPerSample == 8)
            {
                pWave->m_bSampleType = SFORMAT_8;
            }
            else if (pWaveformatEx->wBitsPerSample == 16)
            {
                pWave->m_dwSampleLength >>= 1;
                pWave->m_bSampleType = SFORMAT_16;
            }
            else
            {
                Trace(1,"Error: Download failed because wave data is %ld bits instead of 8 or 16.\n",(long) pWaveformatEx->wBitsPerSample);
                delete pWaveArt;
                return DMUS_E_BADWAVE;
            }
#ifdef XBOX
    // We don't add a sample on the end for interpolation on Xbox. The hardware knows what to do.
#else
            pWave->m_dwSampleLength++;  // We always add one sample to the end for interpolation.

            // Default is to duplicate last sample. This will be overrwritten for
            // streaming waves.
            //
            if (pWave->m_dwSampleLength > 1)
            {
                if (pWave->m_bSampleType == SFORMAT_8)
                {
                    char* pb = (char*)pWave->m_pnWave;
                    pb[pWave->m_dwSampleLength - 1] = pb[pWave->m_dwSampleLength - 2];
                }
                else if (pWave->m_bSampleType == SFORMAT_16)
                {
                    short *pn = pWave->m_pnWave;
                    pn[pWave->m_dwSampleLength - 1] = pn[pWave->m_dwSampleLength - 2];
                }
            }
#endif

            // Create a WaveBuffer listitem and save the wave in and add it to the circular buffer list
            CWaveBuffer* pWavBuf = new CWaveBuffer();
            if ( pWavBuf == NULL )
            {
                delete pWaveArt;
                return E_OUTOFMEMORY;
            }
            pWavBuf->m_pWave = pWave;

            // This Articulation will be handling streaming data 
            if ( pWave->m_bStream )
                pWaveArt->m_bStream = TRUE;

            pWaveArt->m_pWaves.AddTail(pWavBuf);
        }

        EnterCriticalSection(&m_CriticalSection);
        if (pWaveArt)
        {
            CWaveBuffer* pCurrentBuffer = pWaveArt->m_pWaves.GetHead();
            for (; pCurrentBuffer; pCurrentBuffer = pCurrentBuffer->GetNext() )
            {
                if (pCurrentBuffer->m_pWave)
                {
                    pCurrentBuffer->m_pWave->AddRef();
                }
            }
        }
        m_WaveArtList[pWaveArt->m_dwID % WAVEART_HASH_SIZE].AddHead(pWaveArt);
        LeaveCriticalSection(&m_CriticalSection);

        *phDownload = (HANDLE) pWaveArt;

        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CInstManager::DownloadWaveRaw(LPHANDLE phDownload, 
                                   DMUS_DOWNLOADINFO *pInfo, 
                                   void *pvOffsetTable[], 
                                   void *pvData)
{
    CWave *pWave = new CWave;
    if (pWave)
    {   
        DMUS_WAVEDATA *pdmWaveData= (DMUS_WAVEDATA *)pvData;
        Trace(3,"Downloading raw wave data%ld\n",pInfo->dwDLId);

        pWave->m_dwID = pInfo->dwDLId;
        pWave->m_hUserData = NULL;
        pWave->m_lpFreeHandle = NULL;
        pWave->m_dwSampleLength = pdmWaveData->cbSize;
        pWave->m_dwSampleDataSize = pdmWaveData->cbSize;
        pWave->m_pnWave = (short *) &pdmWaveData->byData[0];

        if ( pInfo->dwDLType == DMUS_DOWNLOADINFO_STREAMINGWAVE )
        {
            pWave->m_bStream = TRUE;
            pWave->m_bValid = TRUE;
        }

        EnterCriticalSection(&m_CriticalSection);
        m_WavePool[pWave->m_dwID % WAVE_HASH_SIZE].AddHead(pWave);
        LeaveCriticalSection(&m_CriticalSection);

        *phDownload = (HANDLE) pWave;
        pWave->AddRef();

        m_dwSynthMemUse += pWave->m_dwSampleDataSize; 

        return S_OK;
    }
    return E_OUTOFMEMORY;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\plclock.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*	CPhaseLockClock

  */


#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include <windowsx.h>
#include <stdio.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "plclock.h"
#include "misc.h"
#define MILS_TO_REF	10000

CPhaseLockClock::CPhaseLockClock()

{
	m_rfOffset = 0;
}

void CPhaseLockClock::Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime)

/*	When the clock starts, it needs to mark down the 
	difference between the time it is given and its concept of time. 
*/

{
	m_rfOffset = rfMasterTime - rfSlaveTime;
}	

void CPhaseLockClock::GetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)

/*	Convert the passed time to use the same base as the master clock.
*/

{
	rfSlaveTime += m_rfOffset;
	*prfTime = rfSlaveTime;
}

void CPhaseLockClock::SetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)

{
	rfSlaveTime -= m_rfOffset;
	*prfTime = rfSlaveTime;
}

void CPhaseLockClock::SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime)

/*	SyncToTime provides the needed magic to keep the clock
	in sync. Since the clock uses its own clock (rfSlaveTime)
	to increment, it can drift. This call provides a reference
	time which the clock compares with its internal 
	concept of time. The difference between the two is
	considered the drift. Since the sync time may increment in
	a lurching way, the correction has to be subtle. 
	So, the difference between the two is divided by
	100 and added to the offset.
*/

{
	rfSlaveTime += m_rfOffset;
	rfSlaveTime -= rfMasterTime;	// Find difference between calculated and expected time.
	rfSlaveTime /= 100;				// Reduce in magnitude.
	m_rfOffset -= rfSlaveTime;		// Subtract that from the original offset.
}

CSampleClock::CSampleClock()

{
	m_dwStart = 0;
	m_dwSampleRate = 22050;
}

void CSampleClock::Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples)

{
	REFERENCE_TIME rfStart;
	m_dwStart = dwSamples;
	m_dwSampleRate = dwSampleRate;
	if (pIClock)
	{
		pIClock->GetTime(&rfStart);
		m_PLClock.Start(rfStart,0);
	}
}

void CSampleClock::SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime)

{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	m_PLClock.GetSlaveTime(llSampleTime, prfTime);
}

LONGLONG CSampleClock::RefTimeToSample(REFERENCE_TIME rfTime)

{
	m_PLClock.SetSlaveTime(rfTime, &rfTime);
	rfTime /= 1000;
	rfTime *= m_dwSampleRate;
	rfTime /= MILS_TO_REF;
	return rfTime + m_dwStart;
}


void CSampleClock::SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock)

{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	if (pIClock)
	{
		REFERENCE_TIME rfMasterTime;
		pIClock->GetTime(&rfMasterTime);
		m_PLClock.SyncToMaster(llSampleTime, rfMasterTime);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\mix.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      Mix.cpp
//      Mix engines for MSSynth

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#define STR_MODULENAME "DMusicMix:"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#endif

#ifndef XMIX

#pragma warning(disable : 4101 4102 4146)  

#ifdef _ALPHA_

extern "C" {
	int __ADAWI(short, short *);
};
#pragma intrinsic(__ADAWI)

#define ALPHA_OVERFLOW 2 
#define ALPHA_NEGATIVE 8

#else // !_ALPHA_
//  TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#ifdef DMSYNTH_MINIPORT
#pragma code_seg("PAGE")
#endif // DMSYNTH_MINIPORT

DWORD CDigitalAudio::Mix8(short * pBuffer, 
						  DWORD dwLength, 
						  DWORD dwDeltaPeriod,
						  VFRACT vfDeltaLVolume, 
						  VFRACT vfDeltaRVolume,
					      VFRACT vfLastVolume[],
						  PFRACT pfDeltaPitch, 
						  PFRACT pfSampleLength, 
						  PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM, lLM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8;  
	dwLength <<= 1;

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lLM = pcWave[dwPosition];
        lM = ((pcWave[dwPosition + 1] - lLM) * dwFract) >> 12;
        lM += lLM;
        lLM = lM;

        lLM *= vfLVolume;
        lLM >>= 5;         // Signal bumps up to 15 bits.
        lM *= vfRVolume;
        lM >>= 5;

#ifndef _X86_

#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lLM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else // !_ALPHA_
    // TODO -- overflow detection on ia64 (+ axp64?)
#endif // !_ALPHA_

#else // _X86_  (dead code)
      //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lLM;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:
#endif // _X86_  (dead code)

		dwI += 2;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;

// esi = b == dwIncDelta

; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = (dwLength - dwI) / 2;	// Remaining span.

	mov	edx, edi
	neg	edx
	shr	edx, 1		// edx = a

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543	

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI >> 1);
; 1094 : }

	lea	edx, [edx*2+2]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

; 1018 : 				lLM = lM;
; 1019 : 				lLM *= vfLVolume;
; 1020 : 				lLM >>= 5;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lLM;
; 1028 : 						lM *= vfRVolume;
; 1029 : 						lM >>= 5;
; 1030 : 				pBuffer[dwI+1] += (short) lM;
; 1036 : 
; 1037 : 				dwI += 2;
	sub	edx, eax

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_lx
no_oflowlx:

	imul	esi, edx

; 1038 : 			} while (--dwIncDelta);

	sar	esi, 5					; 00000005H
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	jo	overflow_rx

no_oflowrx:

	add	edi, 2
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:

; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 984  : 			{
; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaLVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfLVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfLVFract += vfDeltaLVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;
; 998  :             vfRVFract += vfDeltaRVolume;

	sar	ecx, 8
	mov	DWORD PTR vfLVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR vfDeltaRVolume

	mov	DWORD PTR vfLVolume, edx
	mov	edx, DWORD PTR vfRVFract

	add	edx, esi
	mov	DWORD PTR pfPitch, ecx

	mov	DWORD PTR vfRVFract, edx
	mov	esi, DWORD PTR dwDeltaPeriod

; 999  :             vfRVolume = vfRVFract >> 8;

	sar	edx, 8
	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	mov	DWORD PTR vfRVolume, edx
	jmp	$L30541

// Handle truncation.

overflow_l:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowl
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflowl

overflow_r:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowr
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowr

overflow_lx:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowlx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowlx

overflow_rx:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowrx
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowrx

$L30543:
; 1041 : 		}
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	add	ebx, ecx
	and	esi, 4095				; 00000fffH

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1049 :         lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

    sub	edx, eax
	
    imul	edx, esi

; 1052 :         lLM = lM;
; 1053 :         lLM *= vfLVolume;
; 1054 :         lLM >>= 5;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lLM;

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_l
no_oflowl:

; 1078 :         lM *= vfRVolume;
; 1079 : 		lM >>= 5;

	imul	esi, edx

; 1080 : 		pBuffer[dwI+1] += (short) lM;
; 1085 : no_oflowr:
; 1087 : 		dwI += 2;

	sar	esi, 5					; 00000005H
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	mov	edx, DWORD PTR pfPFract

	jo	overflow_r

no_oflowr:
; 978  : 
; 979  :     for (dwI = 0; dwI < dwLength; )

	add	edi, 2
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    vfLastVolume[0] = vfLVolume;
    vfLastVolume[1] = vfRVolume;

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}

#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono8(short * pBuffer, 
							  DWORD dwLength,
							  DWORD dwDeltaPeriod,
							  VFRACT vfDeltaVolume,
							  VFRACT vfLastVolume[],
							  PFRACT pfDeltaPitch, 
							  PFRACT pfSampleLength, 
							  PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around. 

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lM = pcWave[dwPosition];
	    lM += ((pcWave[dwPosition + 1] - lM) * dwFract) >> 12;
		lM *= vfVolume;
		lM >>= 5;

#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#else // !_ALPHA_
    //  TODO -- overflow code on ia64 (+ axp64?)
#endif // !_ALPHA_

#else // _X86_  (dead code)
      // Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:
#endif  // _X86_  (dead code)
		dwI++;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:

; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta

; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;

; 1009 : 	a = dwLength - dwI;	// Remaining span.

	mov	edx, edi
	neg	edx

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI);
; 1094 : }

	lea	edx, [edx+1]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
		
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

	sub	edx, eax

; 1018 : 				lLM = lM;
; 1019 : 				lLM *= vfLVolume;
; 1020 : 				lLM >>= 5;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lLM;
; 1027 : no_oflowx:	
; 1037 : 				++dwI;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	mov	ecx, DWORD PTR pfPitch
	add	edx, eax

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	jo	overflow_x

no_oflowx:

	inc	edi
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 984  : 			{
; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfVFract += vfDeltaVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;

	sar	ecx, 8
	mov	DWORD PTR vfVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR dwDeltaPeriod


	mov	DWORD PTR vfVolume, edx
	mov	DWORD PTR pfPitch, ecx


	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	jmp	$L30541

// Handle truncation.

overflow_:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflow
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflow

overflow_x:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	add	ebx, ecx
	and	esi, 4095				; 00000fffH

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lLM = (long) pcWave[dwPosition];

	movsx	eax, BYTE PTR [ecx+edx]

; 1049 :         lM = ((pcWave[dwPosition+1] - lLM) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lLM;

	movsx	edx, BYTE PTR [ecx+edx+1]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lLM = lM;
; 1053 :         lLM *= vfLVolume;
; 1054 :         lLM >>= 5;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lLM;

	imul	esi, edx

	sar	esi, 5					; 00000005H
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	jo	overflow_
no_oflow:
	inc	edi
	mov	edx, DWORD PTR pfPFract

; 979  :     for (dwI = 0; dwI < dwLength; )

	mov	ecx, DWORD PTR pfPitch
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    vfLastVolume[0] = vfVolume;
    vfLastVolume[1] = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}
#endif

DWORD CDigitalAudio::Mix16(short * pBuffer, 
						   DWORD dwLength, 
						   DWORD dwDeltaPeriod,
						   VFRACT vfDeltaLVolume, 
						   VFRACT vfDeltaRVolume,
						   VFRACT vfLastVolume[],
						   PFRACT pfDeltaPitch, 
						   PFRACT pfSampleLength, 
						   PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfLVFract = vfLVolume << 8;  // Keep high res version around.
    VFRACT vfRVFract = vfRVolume << 8; 
	dwLength <<= 1;

	static int _a = 0, _b = 0, _c = 0;

#ifndef _X86_
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
			{
				pfSamplePos -= pfLoopLength;
			}
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)    
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfLVFract += vfDeltaLVolume;
            vfLVolume = vfLVFract >> 8;
            vfRVFract += vfDeltaRVolume;
            vfRVolume = vfRVFract >> 8;
        }
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = ((pcWave[dwPosition+1] - lA) * dwFract);
        lM >>= 12;
        lM += lA;
        lA = lM;
        lA *= vfLVolume;
        lA >>= 13;         // Signal bumps up to 15 bits.
		lM *= vfRVolume;
		lM >>= 13;
#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lA, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI+1] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI+1] = 0x7FFF;
			}
			else  pBuffer[dwI+1] = (short) 0x8000;
		}
#else // !_ALPHA_
    //  TODO -- overflow detection on ia64 (+ axp64?)
#endif // !_ALPHA_
#else // _X86_  (dead code)
      //  Keep this around so we can use it to generate new assembly code (see below...)
		pBuffer[dwI] += (short) lA;

        _asm{jno no_oflowl}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflowl}
        pBuffer[dwI] = (short) 0x8000;
no_oflowl:	

		pBuffer[dwI+1] += (short) lM;

        _asm{jno no_oflowr}
        pBuffer[dwI+1] = 0x7fff;
        _asm{js  no_oflowr}
        pBuffer[dwI+1] = (short) 0x8000;
no_oflowr:

#endif // _X86_  (dead code)
		dwI += 2;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta
; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = (dwLength - dwI) / 2;	// Remaining span.

	mov	edx, edi
	neg	edx
	shr	edx, 1		// edx = a

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:

    push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI >> 1);
; 1094 : }

	lea	edx, [edx*2+2]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
		
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1014 : 				lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]
	sub	edx, eax

; 1018 : 				lA = lM;
; 1019 : 				lA *= vfLVolume;
; 1020 : 				lA >>= 13;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lA;
; 1027 : no_oflowlx:	
; 1028 : 						lM *= vfRVolume;
; 1029 : 						lM >>= 13;
; 1030 : 				pBuffer[dwI+1] += (short) lM;
; 1035 : no_oflowrx:
; 1037 : 				dwI += 2;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax
	mov	eax, DWORD PTR pBufX

	imul	esi, edx

	sar	esi, 13					; 0000000dH

	add	WORD PTR [eax+edi*2], si

	mov	esi, DWORD PTR vfRVolume
	jo	overflow_lx
no_oflowlx:

	imul	esi, edx

; 1038 : 			} while (--dwIncDelta);

	sar	esi, 13					; 0000000dH
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	jo	overflow_rx

no_oflowrx:

	add	edi, 2
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 982  : 	    {	
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaLVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfLVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfLVFract += vfDeltaLVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfLVolume = vfLVFract >> 8;
; 998  :             vfRVFract += vfDeltaRVolume;

	sar	ecx, 8
	mov	DWORD PTR vfLVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR vfDeltaRVolume

	mov	DWORD PTR vfLVolume, edx
	mov	edx, DWORD PTR vfRVFract

	add	edx, esi
	mov	DWORD PTR pfPitch, ecx

	mov	DWORD PTR vfRVFract, edx
	mov	esi, DWORD PTR dwDeltaPeriod

; 999  :             vfRVolume = vfRVFract >> 8;

	sar	edx, 8
	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	mov	DWORD PTR vfRVolume, edx
	jmp	$L30541

// Handle truncation.
overflow_l:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowl
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflowl

overflow_r:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowr
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowr

overflow_lx:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowlx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowlx

overflow_rx:
	mov	WORD PTR [eax+edi*2+2], 0x7fff
	js	no_oflowrx
	mov	WORD PTR [eax+edi*2+2], 0x8000
	jmp	no_oflowrx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	and	esi, 4095				; 00000fffH
	add	ebx, ecx

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1049 :         lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lA = lM;
; 1053 :         lA *= vfLVolume;
; 1054 :         lA >>= 13;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfLVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lA;

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	mov	esi, DWORD PTR vfRVolume

	jo	overflow_l
no_oflowl:

; 1077 : no_oflowl:	
; 1078 :         lM *= vfRVolume;
; 1079 : 		lM >>= 13;

	imul	esi, edx

; 1080 : 		pBuffer[dwI+1] += (short) lM;
; 1085 : no_oflowr:
; 1086 : #endif  /* _ALPHA */
; 1087 : 		dwI += 2;

	sar	esi, 13					; 0000000dH
	mov	ecx, DWORD PTR pfPitch

	add	WORD PTR [eax+edi*2+2], si
	mov	edx, DWORD PTR pfPFract

	jo	overflow_r
no_oflowr:

	add	edi, 2

; 978  : 
; 979  :     for (dwI = 0; dwI < dwLength; )

	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}

	dwI += dwLength;

#endif // _X86_

    vfLastVolume[0] = vfLVolume;
    vfLastVolume[1] = vfRVolume;
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI >> 1);
}


#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono16(short * pBuffer, 
							   DWORD dwLength,
							   DWORD dwDeltaPeriod,
							   VFRACT vfDeltaVolume,
							   VFRACT vfLastVolume[],
							   PFRACT pfDeltaPitch, 
							   PFRACT pfSampleLength, 
							   PFRACT pfLoopLength)
{
    DWORD dwI;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.

#ifndef _X86_
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		    pfSamplePos -= pfLoopLength;
	        else
		    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            vfVFract += vfDeltaVolume;
            vfVolume = vfVFract >> 8;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lM = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        lM *= vfVolume; 
        lM >>= 13;         // Signal bumps up to 12 bits.

#ifndef _X86_
#ifdef _ALPHA_
		int nBitmask;
		if( ALPHA_OVERFLOW & (nBitmask = __ADAWI( (short) lM, &pBuffer[dwI] )) )  {
			if( ALPHA_NEGATIVE & nBitmask )  {
				pBuffer[dwI] = 0x7FFF;
			}
			else  pBuffer[dwI] = (short) 0x8000;
		}
#else // !_ALPHA_
    // TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#else // _X86_  (dead code)
        // Keep this around so we can use it to generate new assembly code (see below...)
        pBuffer[dwI] += (short) lM;
        _asm{jno no_oflow}
        pBuffer[dwI] = 0x7fff;
        _asm{js  no_oflow}
        pBuffer[dwI] = (short) 0x8000;
no_oflow:	
#endif // _X86  (dead code)
		dwI++;
    }
#else // _X86_
	int i, a, b, c, total;
	short * pBuf = pBuffer + dwLength, *pBufX;
	dwI = - dwLength;

	_asm {

; 979  :     for (dwI = 0; dwI < dwLength; )

//	Induction variables.
	mov	edi, dwI
	mov	ebx, DWORD PTR pfSamplePos

// Previously set up.
	cmp	DWORD PTR dwLength, 0
	mov	edx, pfPFract

	mov	ecx, DWORD PTR pfPitch
	je	$L30539

$L30536:
	cmp	ebx, DWORD PTR pfSampleLength

; 981  :         if (pfSamplePos >= pfSampleLength)

	mov	esi, DWORD PTR dwIncDelta
	jge	SHORT $L30540_

$L30540:
; 987  : 	        else
; 988  : 		    break;
; 990  :         dwIncDelta--;

	dec	esi
	mov	DWORD PTR dwIncDelta, esi

; 991  :         if (!dwIncDelta)    

	je	SHORT $L30541_

$L30541:
// esi, edx, edi		esi == dwIncDelta

	mov	DWORD PTR i, 0

; 1010 : 	b = dwIncDelta;
// esi = b == dwIncDelta
; 1011 : 	c = (pfSampleLength - pfSamplePos) / pfPitch;
; 1009 : 	a = dwLength - dwI;	// Remaining span.

	mov	edx, edi
	neg	edx

; 1017 : 	if (b < a && b < c)

	cmp	esi, edx
	jge	try_ax

	mov	eax, ecx
	imul	eax, esi
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength 
	jge	try_c

; 1019 : 		i = b;

	cmp	esi, 3
	jl	got_it

	mov	DWORD PTR i, esi
	jmp	SHORT got_it

; 1013 : 	if (a < b && a < c)

try_a:

	cmp	edx, esi
	jge	try_c
try_ax:
	mov	eax, edx
	imul	eax, ecx
	add	eax, ebx

	cmp eax, DWORD PTR pfSampleLength
	jge	try_c

; 1015 : 		i = a;

	cmp	edx, 3
	jl	got_it

	mov	DWORD PTR i, edx
	jmp	SHORT got_it

; 1021 : 	else if (c < a && c < b)
try_c:
	push	edx
	mov	eax, DWORD PTR pfSampleLength
	sub	eax, ebx
	cdq
	idiv	ecx		// eax == c
	pop	edx

    cmp	eax, edx
	jge	got_it
try_cx:
	cmp	eax, esi
	jge	got_it

; 1023 : 		i = c;

	cmp	eax, 3
	jl	$L30543

	mov DWORD PTR i, eax

got_it:
	mov	edx, DWORD PTR i
	mov	eax, DWORD PTR pBuf

	dec	edx
	jl	$L30543

	sub	DWORD PTR dwIncDelta, edx

; 1093 :     return (dwI);
; 1094 : }

	lea	edx, [edx+1]			// Current span.
	lea	eax, [eax+edi*2]		// Starting position.

	add	edi, edx				// Remaining span.
	lea	eax, [eax+edx*2]		// New ending position.

	push	edi
	mov	edi, edx				// Current span.

	mov	DWORD PTR pBufX, eax
	neg	edi

$L30797:
; 1005 : 			do
; 1010 : 				dwPosition = pfSamplePos >> 12;
; 1011 : 				dwFract = pfSamplePos & 0xFFF;

	mov	edx, ebx
	mov	esi, ebx

	add	ebx, ecx
	mov	ecx, DWORD PTR pcWave

; 1012 : 				pfSamplePos += pfPitch;

	sar	edx, 12					; 0000000cH
	and	esi, 4095				; 00000fffH

; 1013 : 
; 1014 : 				lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1015 : 				lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1016 : 				lM >>= 12;
; 1017 : 				lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

; 1018 : 				lA = lM;
; 1019 : 				lA *= vfLVolume;
; 1020 : 				lA >>= 13;         // Signal bumps up to 15 bits.
; 1022 : 				pBuffer[dwI] += (short) lA;
; 1027 : no_oflowx:	
; 1037 : 				++dwI;

	imul	edx, esi

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax
	mov	ecx, DWORD PTR pfPitch

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBufX

	add	WORD PTR [eax+edi*2], si
	jo	overflow_x
no_oflowx:

; 1038 : 			} while (--dwIncDelta);

	inc	edi
	jne	SHORT $L30797

	pop	edi

; 1039 : 			++dwIncDelta;
; 1040 : 			continue;

	mov	edx, DWORD PTR pfPFract
	cmp	edi, 0

	jl	SHORT $L30536
	jmp	SHORT $L30539

$L30540_:
; 983  : 	        if (pfLoopLength)

	cmp	DWORD PTR pfLoopLength, 0
	je	$L30539

; 985  : 				pfSamplePos -= pfLoopLength;

	sub	ebx, DWORD PTR pfLoopLength
	jmp	$L30540

$L30541_:
; 994  :             pfPFract += pfDeltaPitch;

	mov	ecx, DWORD PTR pfDeltaPitch
	mov	esi, DWORD PTR vfDeltaVolume

	add	ecx, edx
	mov	edx, DWORD PTR vfVFract

; 995  :             pfPitch = pfPFract >> 8;
; 996  :             vfVFract += vfDeltaVolume;

	mov	DWORD PTR pfPFract, ecx
	add	edx, esi

; 997  :             vfVolume = vfVFract >> 8;

	sar	ecx, 8
	mov	DWORD PTR vfVFract, edx
	
	sar	edx, 8
	mov	esi, DWORD PTR dwDeltaPeriod

	mov	DWORD PTR vfVolume, edx
	mov	DWORD PTR pfPitch, ecx


	mov	DWORD PTR dwIncDelta, esi

; 993  :             dwIncDelta = dwDeltaPeriod;

	jmp	$L30541

// Handle truncation.
overflow_:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflow
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp no_oflow

overflow_x:
	mov	WORD PTR [eax+edi*2], 0x7fff
	js	no_oflowx
	mov	WORD PTR [eax+edi*2], 0x8000
	jmp	no_oflowx

$L30543:
; 1044 :         dwPosition = pfSamplePos >> 12;

	mov	edx, ebx
	mov	ecx, DWORD PTR pfPitch

; 1045 :         dwFract = pfSamplePos & 0xFFF;

	sar	edx, 12					; 0000000cH
	mov	esi, ebx

	and	esi, 4095				; 00000fffH
	add	ebx, ecx

; 1046 :         pfSamplePos += pfPitch;

	mov	ecx, DWORD PTR pcWave

; 1047 : 
; 1048 :         lA = (long) pcWave[dwPosition];

	movsx	eax, WORD PTR [ecx+edx*2]

; 1049 :         lM = ((pcWave[dwPosition+1] - lA) * dwFract);
; 1050 :         lM >>= 12;
; 1051 :         lM += lA;

	movsx	edx, WORD PTR [ecx+edx*2+2]

	sub	edx, eax

	imul	edx, esi

; 1052 :         lA = lM;
; 1053 :         lA *= vfVolume;
; 1054 :         lA >>= 13;         // Signal bumps up to 15 bits.

	sar	edx, 12					; 0000000cH
	mov	esi, DWORD PTR vfVolume

	add	edx, eax

; 1072 : 		pBuffer[dwI] += (short) lA;

	imul	esi, edx

	sar	esi, 13					; 0000000dH
	mov	eax, DWORD PTR pBuf

	add	WORD PTR [eax+edi*2], si
	jo	overflow_
no_oflow:
; 1077 : no_oflowl:	
; 1087 : 		++dwI;

	inc	edi
	mov	edx, DWORD PTR pfPFract

; 979  :     for (dwI = 0; dwI < dwLength; )

	mov	ecx, DWORD PTR pfPitch
	jl $L30536

$L30539:
	mov DWORD PTR dwI, edi
	mov DWORD PTR pfSamplePos, ebx
}
	dwI += dwLength;

#endif // _X86_
    vfLastVolume[0] = vfVolume;
    vfLastVolume[1] = vfVolume; // !!! is this right?
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;
    return (dwI);
}
#endif

#endif // XMIX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\plclock.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*	PLClock.h

  */

#ifndef __PLCLOCK_H__
#define __PLCLOCK_H__

class CPhaseLockClock
{
public:
						CPhaseLockClock();
	void				Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime);
	void				GetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime);
private:
	REFERENCE_TIME		m_rfOffset;
};

class CSampleClock
{
public:
						CSampleClock();
	void				Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples);
	void				SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock);
	LONGLONG			RefTimeToSample(REFERENCE_TIME rfTime);

private:
	CPhaseLockClock		m_PLClock;
	DWORD				m_dwStart;		// Initial sample offset.
	DWORD				m_dwSampleRate;
};



#endif	// __PLCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\mmdebug.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
/*
 * johnkn's debug logging and assert macros
 *
 */
 
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#if !defined _INC_MMDEBUG_
#define _INC_MMDEBUG_

#if defined _DEBUG && !defined DEBUG
 #define DEBUG
#endif

//
// prototypes for debug functions.
//
    #define SQUAWKNUMZ(num) #num
    #define SQUAWKNUM(num) SQUAWKNUMZ(num)
    #define SQUAWK __FILE__ "(" SQUAWKNUM(__LINE__) ") ----"
    #define DEBUGLINE __FILE__ "(" SQUAWKNUM(__LINE__) ") "
        
    #if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL

        #define STATICFN

        int  FAR _cdecl AuxDebugEx(int, LPTSTR, ...);
        void FAR _cdecl AuxRip(LPTSTR, ...);
        VOID WINAPI AuxDebugDump (int, LPVOID, int);
        LPCTSTR WINAPI AuxMMErrText(DWORD  mmr);
        int  WINAPI DebugSetOutputLevel (int,int);
        UINT WINAPI AuxFault (DWORD dwFaultMask);

       #if defined DEBUG_RETAIL && !defined DEBUG && !defined _DEBUG
        #define INLINE_BREAK
       #else
        #if !defined _WIN32 || defined _X86_
         #define INLINE_BREAK _asm {int 3}
        #else
         #define INLINE_BREAK DebugBreak()
        #endif
       #endif

        #define FAULT_HERE AuxFault

       #undef  assert
       #define assert(exp) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " #exp "\r\n"); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert2
       #define assert2(exp,sz) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n"); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert3
       #define assert3(exp,sz,arg) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert4
       #define assert4(exp,sz,arg1,arg2) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg1),(arg2)); \
               INLINE_BREAK;\
               }\
           }
       #undef  assert5
       #define assert5(exp,sz,arg1,arg2,arg3) {\
           if (!(exp)) {\
               AuxDebugEx(-2, DEBUGLINE "assert failed: " sz "\r\n", (arg1),(arg2),(arg3)); \
               INLINE_BREAK;\
               }\
           }

    #else // defined(DEBUG) || defined(_DEBUG)
                      
       #define AuxDebugEx  1 ? (void)0 :
       #define AuxDebugDump(a,b,c)
       #define AuxMMErrText(m)     NULL
       #define AuxRip  1 ? (void)0 :

       #define assert(a)          ((void)0)
       #define assert2(a,b)       ((void)0)
       #define assert3(a,b,c)     ((void)0)
       #define assert4(a,b,c,d)   ((void)0)
       #define assert5(a,b,c,d,e) ((void)0)

       #define FAULT_HERE    1 ? (void)0 :
       #define INLINE_BREAK
       #define DebugSetOutputLevel(i,j)
       #define STATICFN static

   #endif // defined(DEBUG) || defined _DEBUG || defined DEBUG_RETAIL

   #ifndef DPF_CATEGORY
    #define DPF_CATEGORY 0x0100
   #endif

   // translate DPF's only in internal debug builds
   //
   #if defined DEBUG || defined _DEBUG
       #define DUMP(n,a,b) AuxDebugDump (DPF_CATEGORY | (n), a, b)
       #define RIP AuxDebugEx (0, DEBUGLINE), AuxRip
       #define AuxMMR(api,mmr) (mmr) ? AuxDebugEx(1, DEBUGLINE #api " error %d '%s'\r\n", mmr, AuxMMErrText(mmr)) : (int)0
       #define DPF(n,sz) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n")
       #define DPF1(n,sz,a) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a))
       #define DPF2(n,sz,a,b) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b))
       #define DPF3(n,sz,a,b,c) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c))
       #define DPF4(n,sz,a,b,c,d) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d))
       #define DPF5(n,sz,a,b,c,d,e) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(e))
       #define DPF6(n,sz,a,b,c,d,e,f) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(d),(f))
       #define DPF7(n,sz,a,b,c,d,e,f,g) AuxDebugEx (DPF_CATEGORY | (n), DEBUGLINE sz "\r\n",(a),(b),(c),(d),(d),(f),(g))
   #else
       #define DUMP(n,a,b)
       #define RIP AuxRip
       #define AuxMMR(api,mmr)
       #define DPF(n,sz)
       #define DPF1(n,sz,a)
       #define DPF2(n,sz,a,b)
       #define DPF3(n,sz,a,b,c)
       #define DPF4(n,sz,a,b,c,d)
       #define DPF5(n,sz,a,b,c,d,e)
       #define DPF6(n,sz,a,b,c,d,e,f)
       #define DPF7(n,sz,a,b,c,d,e,f,g)
   #endif
   
#endif //_INC_MMDEBUG_

// =============================================================================

//
// include this in only one module in a DLL or APP
//   
#if defined DEBUG || defined _DEBUG || defined DEBUG_RETAIL
    #if (defined _INC_MMDEBUG_CODE_) && (_INC_MMDEBUG_CODE_ != FALSE)
    #undef _INC_MMDEBUG_CODE_
    #define _INC_MMDEBUG_CODE_ FALSE
       
    #include <stdarg.h>   

    #if !defined _WIN32 && !defined wvsprintfA
     #define wvsprintfA wvsprintf
    #endif

static struct _mmerrors {
   DWORD    mmr;
   LPCTSTR  psz;
   } aMMErr[] = {
      MMSYSERR_NOERROR      ,"Success",
   #ifdef DEBUG
      MMSYSERR_ERROR        ,"unspecified error",
      MMSYSERR_BADDEVICEID  ,"device ID out of range",
      MMSYSERR_NOTENABLED   ,"driver failed enable",
      MMSYSERR_ALLOCATED    ,"device already allocated",
      MMSYSERR_INVALHANDLE  ,"device handle is invalid",
      MMSYSERR_NODRIVER     ,"no device driver present",
      MMSYSERR_NOMEM        ,"memory allocation error",
      MMSYSERR_NOTSUPPORTED ,"function isn't supported",
      MMSYSERR_BADERRNUM    ,"error value out of range",
      MMSYSERR_INVALFLAG    ,"invalid flag passed",
      MMSYSERR_INVALPARAM   ,"invalid parameter passed",
     #if (WINVER >= 0x0400)
      MMSYSERR_HANDLEBUSY   ,"handle in use by another thread",
      MMSYSERR_INVALIDALIAS ,"specified alias not found",
      MMSYSERR_BADDB        ,"bad registry database",
      MMSYSERR_KEYNOTFOUND  ,"registry key not found",
      MMSYSERR_READERROR    ,"registry read error",
      MMSYSERR_WRITEERROR   ,"registry write error",
      MMSYSERR_DELETEERROR  ,"registry delete error",
      MMSYSERR_VALNOTFOUND  ,"registry value not found",
      MMSYSERR_NODRIVERCB   ,"Never got a 32 bit callback from driver",
     #endif // WINVER >= 0x400

      WAVERR_BADFORMAT      ,"wave:unsupported wave format",
      WAVERR_STILLPLAYING   ,"wave:still something playing",
      WAVERR_UNPREPARED     ,"wave:header not prepared",
      WAVERR_SYNC           ,"wave:device is synchronous",

      MIDIERR_UNPREPARED    ,"midi:header not prepared",
      MIDIERR_STILLPLAYING  ,"midi:still something playing",
      //MIDIERR_NOMAP         ,"midi:no configured instruments",
      MIDIERR_NOTREADY      ,"midi:hardware is still busy",
      MIDIERR_NODEVICE      ,"midi:port no longer connected",
      MIDIERR_INVALIDSETUP  ,"midi:invalid MIF",
      #ifdef CHICAGO
      MIDIERR_BADOPENMODE   ,"midi:operation unsupported w/ open mode",
      #endif

      TIMERR_NOCANDO        ,"timer: request not completed",
      JOYERR_PARMS          ,"joy:bad parameters",
      JOYERR_NOCANDO        ,"joy:request not completed",
      JOYERR_UNPLUGGED      ,"joystick is unplugged",

      MCIERR_INVALID_DEVICE_ID        ,"MCIERR_INVALID_DEVICE_ID",
      MCIERR_UNRECOGNIZED_KEYWORD     ,"MCIERR_UNRECOGNIZED_KEYWORD",
      MCIERR_UNRECOGNIZED_COMMAND     ,"MCIERR_UNRECOGNIZED_COMMAND",
      MCIERR_HARDWARE                 ,"MCIERR_HARDWARE",
      MCIERR_INVALID_DEVICE_NAME      ,"MCIERR_INVALID_DEVICE_NAME",
      MCIERR_OUT_OF_MEMORY            ,"MCIERR_OUT_OF_MEMORY",
      MCIERR_DEVICE_OPEN              ,"MCIERR_DEVICE_OPEN",
      MCIERR_CANNOT_LOAD_DRIVER       ,"MCIERR_CANNOT_LOAD_DRIVER",
      MCIERR_MISSING_COMMAND_STRING   ,"MCIERR_MISSING_COMMAND_STRING",
      MCIERR_PARAM_OVERFLOW           ,"MCIERR_PARAM_OVERFLOW",
      MCIERR_MISSING_STRING_ARGUMENT  ,"MCIERR_MISSING_STRING_ARGUMENT",
      MCIERR_BAD_INTEGER              ,"MCIERR_BAD_INTEGER",
      MCIERR_PARSER_INTERNAL          ,"MCIERR_PARSER_INTERNAL",
      MCIERR_DRIVER_INTERNAL          ,"MCIERR_DRIVER_INTERNAL",
      MCIERR_MISSING_PARAMETER        ,"MCIERR_MISSING_PARAMETER",
      MCIERR_UNSUPPORTED_FUNCTION     ,"MCIERR_UNSUPPORTED_FUNCTION",
      MCIERR_FILE_NOT_FOUND           ,"MCIERR_FILE_NOT_FOUND",
      MCIERR_DEVICE_NOT_READY         ,"MCIERR_DEVICE_NOT_READY",
      MCIERR_INTERNAL                 ,"MCIERR_INTERNAL",
      MCIERR_DRIVER                   ,"MCIERR_DRIVER",
      MCIERR_CANNOT_USE_ALL           ,"MCIERR_CANNOT_USE_ALL",
      MCIERR_MULTIPLE                 ,"MCIERR_MULTIPLE",
      MCIERR_EXTENSION_NOT_FOUND      ,"MCIERR_EXTENSION_NOT_FOUND",
      MCIERR_OUTOFRANGE               ,"MCIERR_OUTOFRANGE",
      MCIERR_FLAGS_NOT_COMPATIBLE     ,"MCIERR_FLAGS_NOT_COMPATIBLE",
      MCIERR_FILE_NOT_SAVED           ,"MCIERR_FILE_NOT_SAVED",
      MCIERR_DEVICE_TYPE_REQUIRED     ,"MCIERR_DEVICE_TYPE_REQUIRED",
      MCIERR_DEVICE_LOCKED            ,"MCIERR_DEVICE_LOCKED",
      MCIERR_DUPLICATE_ALIAS          ,"MCIERR_DUPLICATE_ALIAS",
      MCIERR_BAD_CONSTANT             ,"MCIERR_BAD_CONSTANT",
      MCIERR_MUST_USE_SHAREABLE       ,"MCIERR_MUST_USE_SHAREABLE",
      MCIERR_MISSING_DEVICE_NAME      ,"MCIERR_MISSING_DEVICE_NAME",
      MCIERR_BAD_TIME_FORMAT          ,"MCIERR_BAD_TIME_FORMAT",
      MCIERR_NO_CLOSING_QUOTE         ,"MCIERR_NO_CLOSING_QUOTE",
      MCIERR_DUPLICATE_FLAGS          ,"MCIERR_DUPLICATE_FLAGS",
      MCIERR_INVALID_FILE             ,"MCIERR_INVALID_FILE",
      MCIERR_NULL_PARAMETER_BLOCK     ,"MCIERR_NULL_PARAMETER_BLOCK",
      MCIERR_UNNAMED_RESOURCE         ,"MCIERR_UNNAMED_RESOURCE",
      MCIERR_NEW_REQUIRES_ALIAS       ,"MCIERR_NEW_REQUIRES_ALIAS",
      MCIERR_NOTIFY_ON_AUTO_OPEN      ,"MCIERR_NOTIFY_ON_AUTO_OPEN",
      MCIERR_NO_ELEMENT_ALLOWED       ,"MCIERR_NO_ELEMENT_ALLOWED",
      MCIERR_NONAPPLICABLE_FUNCTION   ,"MCIERR_NONAPPLICABLE_FUNCTION",
      MCIERR_ILLEGAL_FOR_AUTO_OPEN    ,"MCIERR_ILLEGAL_FOR_AUTO_OPEN",
      MCIERR_FILENAME_REQUIRED        ,"MCIERR_FILENAME_REQUIRED",
      MCIERR_EXTRA_CHARACTERS         ,"MCIERR_EXTRA_CHARACTERS",
      MCIERR_DEVICE_NOT_INSTALLED     ,"MCIERR_DEVICE_NOT_INSTALLED",
      MCIERR_GET_CD                   ,"MCIERR_GET_CD",
      MCIERR_SET_CD                   ,"MCIERR_SET_CD",
      MCIERR_SET_DRIVE                ,"MCIERR_SET_DRIVE",
      MCIERR_DEVICE_LENGTH            ,"MCIERR_DEVICE_LENGTH",
      MCIERR_DEVICE_ORD_LENGTH        ,"MCIERR_DEVICE_ORD_LENGTH",
      MCIERR_NO_INTEGER               ,"MCIERR_NO_INTEGER",
      MCIERR_WAVE_OUTPUTSINUSE        ,"MCIERR_WAVE_OUTPUTSINUSE",
      MCIERR_WAVE_SETOUTPUTINUSE      ,"MCIERR_WAVE_SETOUTPUTINUSE",
      MCIERR_WAVE_INPUTSINUSE         ,"MCIERR_WAVE_INPUTSINUSE",
      MCIERR_WAVE_SETINPUTINUSE       ,"MCIERR_WAVE_SETINPUTINUSE",
      MCIERR_WAVE_OUTPUTUNSPECIFIED   ,"MCIERR_WAVE_OUTPUTUNSPECIFIED",
      MCIERR_WAVE_INPUTUNSPECIFIED    ,"MCIERR_WAVE_INPUTUNSPECIFIED",
      MCIERR_WAVE_OUTPUTSUNSUITABLE   ,"MCIERR_WAVE_OUTPUTSUNSUITABLE",
      MCIERR_WAVE_SETOUTPUTUNSUITABLE ,"MCIERR_WAVE_SETOUTPUTUNSUITABLE",
      MCIERR_WAVE_INPUTSUNSUITABLE    ,"MCIERR_WAVE_INPUTSUNSUITABLE",
      MCIERR_WAVE_SETINPUTUNSUITABLE  ,"MCIERR_WAVE_SETINPUTUNSUITABLE",
      MCIERR_SEQ_DIV_INCOMPATIBLE     ,"MCIERR_SEQ_DIV_INCOMPATIBLE",
      MCIERR_SEQ_PORT_INUSE           ,"MCIERR_SEQ_PORT_INUSE",
      MCIERR_SEQ_PORT_NONEXISTENT     ,"MCIERR_SEQ_PORT_NONEXISTENT",
      MCIERR_SEQ_PORT_MAPNODEVICE     ,"MCIERR_SEQ_PORT_MAPNODEVICE",
      MCIERR_SEQ_PORT_MISCERROR       ,"MCIERR_SEQ_PORT_MISCERROR",
      MCIERR_SEQ_TIMER                ,"MCIERR_SEQ_TIMER",
      MCIERR_SEQ_PORTUNSPECIFIED      ,"MCIERR_SEQ_PORTUNSPECIFIED",
      MCIERR_SEQ_NOMIDIPRESENT        ,"MCIERR_SEQ_NOMIDIPRESENT",
      MCIERR_NO_WINDOW                ,"MCIERR_NO_WINDOW",
      MCIERR_CREATEWINDOW             ,"MCIERR_CREATEWINDOW",
      MCIERR_FILE_READ                ,"MCIERR_FILE_READ",
      MCIERR_FILE_WRITE               ,"MCIERR_FILE_WRITE",
     #ifdef CHICAGO
      MCIERR_NO_IDENTITY              ,"MCIERR_NO_IDENTITY",

      MIXERR_INVALLINE            ,"Invalid Mixer Line",
      MIXERR_INVALCONTROL         ,"Invalid Mixer Control",
      MIXERR_INVALVALUE           ,"Invalid Mixer Value",
     #endif // CHICAGO
   #endif // DEBUG
      0xFFFFFFFE                  , "unknown error %d"
      };

    struct _mmdebug {
        int    Level;
        int    Mask;
        int    StopOnRip;
        DWORD  TakeFault;
        struct _mmerrors *paErrs;
        BOOL   Initialized;
        HANDLE hOut;
        } mmdebug = {0, 0xFF, 0, 0xFF, aMMErr};

    /*+ AuxFault
     *
     *-=================================================================*/

     UINT WINAPI AuxFault (
         DWORD dwFaultMask)
     {
         LPUINT pData = NULL;

         if (dwFaultMask & mmdebug.TakeFault)
            return *pData;
         return 0;
     }


    /*+ AuxOut - write a string to designated debug out
     *
     *-=================================================================*/

   void WINAPI AuxOut (
      LPTSTR psz)
      {
     #ifdef WIN32
      if (mmdebug.hOut)
         {
         UINT  cb = lstrlen(psz);
         DWORD dw;
         if (INVALID_HANDLE_VALUE != mmdebug.hOut)
            WriteFile (mmdebug.hOut, psz, cb, &dw, NULL);
         }
      else
     #endif
         {
        #ifdef DbgLog
         DbgOutString (psz); // from \quartz\sdk\classes\base\debug.cpp
        #else
         OutputDebugString (psz);
        #endif
         }
      }

    /*+ AuxDebug - create a formatted string and output to debug terminal
     *
     *-=================================================================*/
    
    int FAR _cdecl AuxDebugEx (
       int    iLevel,
       LPTSTR lpFormat,
       ...)
       {
      #ifdef WIN32
       char     szBuf[1024];
      #else
       static char szBuf[1024];
      #endif
       int      cb;
       va_list  va;
       LPSTR    psz;

       // mask the iLevel passed with mmdebug.Mask. if this ends up
       // clearing the high bits then iLevel has a shot being smaller
       // than mmdebug.Level.  if not, then the second test will always
       // fail.  Thus mmdebug.Mask has bits set to DISABLE that category.
       // 
       // note that we always pass messages that have an iLevel < 0.
       // this level corresponds to Asserts & Rips so we always want to see them.
       //
       if (iLevel < 0 || mmdebug.Level >= (iLevel & mmdebug.Mask))
          {
          va_start (va, lpFormat);
          cb = wvsprintfA (szBuf, lpFormat, va);
          va_end (va);

          // eat leading ..\..\ which we get from __FILE__ since
          // george's wierd generic makefile stuff.
          //
          psz = szBuf;
          while (psz[0] == '.' && psz[1] == '.' && psz[2] == '\\')
             psz += 3;

          // if we begin with a drive letter, strip off all but filename
          //  
          if (psz[0] && psz[1] == ':')
             {
             UINT ii = 2;
             for (ii = 2; psz[ii] != 0; ++ii)
                 if (psz[ii] == '\\')
                    psz += ii+1, ii = 0;
             }

          // write to standard out if we have a handle. otherwise write to 
          // the debugger
          //
         #ifdef MODULE_DEBUG_PREFIX
          if (psz != szBuf)
             AuxOut (MODULE_DEBUG_PREFIX);
         #endif
          AuxOut (psz);
          }

       return cb;
       }

    /*+ AuxRip
     *
     *-=================================================================*/

    void FAR _cdecl AuxRip (
       LPTSTR lpFormat,
       ...)
       {
      #ifdef WIN32
       char     szBuf[1024];
      #else
       static char szBuf[1024];
      #endif
       va_list  va;
       LPSTR    psz;
                
       va_start (va, lpFormat);
       wvsprintfA (szBuf, lpFormat, va);
       va_end (va);

       // eat leading ..\..\ which we get from __FILE__ since
       // george's wierd generic makefile stuff.
       //
       psz = szBuf;
       while (psz[0] == '.' && psz[1] == '.' && psz[2] == '\\')
          psz += 3;

       AuxOut ("RIP: ");
       AuxOut (psz);
       AuxOut ("\r\n");

       if (mmdebug.StopOnRip)
          {
         #if !defined _WIN32 || defined _X86_
          _asm {int 3};
         #else
          DebugBreak();
         #endif
          }
       }

    /*+ AuxDebugDump -
     *
     *-=================================================================*/
    
    VOID WINAPI AuxDebugDump (
       int    iLevel,
       LPVOID lpvData,
       int    nCount)
       {
       LPBYTE   lpData = (LPBYTE)lpvData;
       char     szBuf[128];
       LPSTR    psz;
       int      cb;
       int      ix;
       BYTE     abRow[8];
                
       if ((mmdebug.Level < (iLevel & mmdebug.Mask)) || nCount <= 0)
          return;

       do {
          cb = wsprintf (szBuf, "\t%08X: ", lpData);
          psz = szBuf + cb;

          for (ix = 0; ix < 8; ++ix)
             {
             LPBYTE lpb = lpData;

             abRow[ix] = '.';
             if (IsBadReadPtr (lpData + ix, 1))
                lstrcpy (psz, ".. ");
             else
                {
                wsprintf (psz, "%02X ", lpData[ix]);
                if (lpData[ix] >= 32 && lpData[ix] < 127)
                    abRow[ix] = lpData[ix];
                }
             psz += 3;
             }
          for (ix = 0; ix < 8; ++ix)
             *psz++ = abRow[ix];

          lstrcpy (psz, "\r\n");

          #ifdef MODULE_DEBUG_PREFIX
           AuxOut (MODULE_DEBUG_PREFIX);
          #endif

          AuxOut (szBuf);

          } while (lpData += 8, (nCount -= 8) > 0);

       return;
       }
       
    /*+ AuxMMErrText
     *
     *-=================================================================*/
    
   LPCTSTR WINAPI AuxMMErrText (
      DWORD  mmr)
   {
      UINT uRemain = sizeof(aMMErr)/sizeof(aMMErr[0]);
      UINT uUpper  = uRemain-1;
      UINT uLower  = 0;
      static char szTemp[50];

      if (mmr <= aMMErr[uUpper].mmr)
      {
         // binary search for mmr match, if match
         // return string pointer
         //
         while (--uRemain)
         {
            UINT ii = (uLower + uUpper) >> 1;

            if (aMMErr[ii].mmr < mmr)
            {
               if (uLower == ii)
                  break;
               uLower = ii;
            }
            else if (aMMErr[ii].mmr > mmr)
            {
               if (uUpper == ii)
                  break;
               uUpper = ii;
            }
            else
            {
               return aMMErr[ii].psz;
               break;
            }
         }

         // we can only get to here if no match was found for
         // the error id.
         //
         if ( ! uRemain)
         {
            int ix;

            INLINE_BREAK;

            for (ix = 0; ix < sizeof(aMMErr)/sizeof(aMMErr[0])-1; ++ix)
            {
                assert (aMMErr[ix].mmr < aMMErr[ix+1].mmr);
            }
            wsprintf (szTemp, "error %d 0x%X", mmr, mmr);
            return szTemp;
         }
      }

      wsprintf (szTemp, aMMErr[uUpper].psz, mmr);
      return szTemp;
   }

    /*+ DebugSetOutputLevel
     *
     *-=================================================================*/
    
    BOOL  WINAPI DebugSetOutputLevel (
        int nLevel,
        int nMask)
        {
        int nOldLevel = mmdebug.Level;

        if (!mmdebug.Initialized)
           {
          #ifdef WIN32
           TCHAR szFile[MAX_PATH];
           mmdebug.TakeFault = GetProfileInt("Debug", "FaultMask", 1);

           GetProfileString("Debug", "MMDebugTo", "", szFile, sizeof(szFile));
#if 0
           if (!lstrcmpi(szFile, "Console"))
              {
              mmdebug.hOut = GetStdHandle (STD_OUTPUT_HANDLE);
              if (!mmdebug.hOut || mmdebug.hOut == INVALID_HANDLE_VALUE)
                 {
                 AllocConsole ();
                 mmdebug.hOut = GetStdHandle (STD_OUTPUT_HANDLE);
                 if (mmdebug.hOut == INVALID_HANDLE_VALUE)
                    mmdebug.hOut = NULL;
                 }
              SetConsoleTitle (MODULE_DEBUG_PREFIX " Debug Output");
              }
           else
#endif
           if (szFile[0] &&
                    lstrcmpi(szFile, "Debug") &&
                    lstrcmpi(szFile, "Debugger") &&
                    lstrcmpi(szFile, "Deb"))
              {
              mmdebug.hOut = CreateFile(szFile, GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL, OPEN_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);
              if (INVALID_HANDLE_VALUE != mmdebug.hOut)
                 SetFilePointer (mmdebug.hOut, 0, NULL, FILE_END);
              }
          #endif
           mmdebug.Initialized = TRUE;
           }

        mmdebug.Level = (nLevel & 0xFF);
        mmdebug.Mask  = (nMask | 0xFF);
        return nOldLevel;
        }


    #endif // _INC_MMDEBUG_CODE_
#endif // DEBUG || _DEBUG    

#ifdef __cplusplus
}
#endif // _cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\simple.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation


#ifdef XBOX
#include <xtl.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#include <windowsx.h>
#include <stdio.h>
#include "misc.h"

#ifdef XBOX
#ifndef _SECURITY_ATTRIBUTES_
#define _SECURITY_ATTRIBUTES_
typedef struct  _SECURITY_ATTRIBUTES
    {
    DWORD nLength;
    /* [size_is] */ LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
    }	SECURITY_ATTRIBUTES;
#endif // !_SECURITY_ATTRIBUTES_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\sintab.h ===
static short sSin16[51] =
{
    0,
    3759,
    7460,
    11043,
    14452,
    17633,
    20536,
    23115,
    25329,
    27144,
    28531,
    29468,
    29940,
    29940,
    29468,
    28531,
    27144,
    25329,
    23115,
    20536,
    17633,
    14452,
    11043,
    7460,
    3759,
    0,
    -3759,
    -7460,
    -11043,
    -14452,
    -17633,
    -20536,
    -23115,
    -25329,
    -27144,
    -28531,
    -29468,
    -29940,
    -29940,
    -29468,
    -28531,
    -27144,
    -25329,
    -23115,
    -20536,
    -17633,
    -14452,
    -11043,
    -7460,
    -3760,
    0,
};
static unsigned char sSin8[51] =
{
    128,
    143,
    159,
    174,
    189,
    202,
    214,
    225,
    235,
    242,
    248,
    252,
    254,
    254,
    252,
    248,
    242,
    235,
    225,
    214,
    202,
    189,
    174,
    159,
    143,
    128,
    113,
    97,
    82,
    67,
    54,
    42,
    31,
    21,
    14,
    8,
    4,
    2,
    2,
    4,
    8,
    14,
    21,
    31,
    42,
    54,
    67,
    82,
    97,
    113,
    128,
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\mixmulti.cpp ===
//      Mix.cpp
//      Copyright (c) Microsoft Corporation	1996, 1998
//      Mix engines for MSSynth

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#define STR_MODULENAME "DMusicMix:"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#endif

#ifndef XMIX


///////////////////////////////////////////////////////
// Modifications 
// member m_nChannels => parameter dwBufferCount
//
// Changed number of arguments into Filtered mixers
//
// Remove range checking after filter 

#pragma warning(disable : 4101 4102 4146)  

#ifdef _ALPHA_

extern "C" {
	int __ADAWI(short, short *);
};
#pragma intrinsic(__ADAWI)

#define ALPHA_OVERFLOW 2 
#define ALPHA_NEGATIVE 8

#else // !_ALPHA_
//  TODO -- overflow detection for ia64 (+ axp64?)
#endif // !_ALPHA_
#ifdef DMSYNTH_MINIPORT
#pragma code_seg("PAGE")
#endif // DMSYNTH_MINIPORT

#define USE_MMX
#define USE_MMX_FILTERED

#ifdef i386 // {
DWORD CDigitalAudio::MixMulti8(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
    VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    long lA;//, lB;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }   
	
#if 1 // {
	DWORD l_nChannels = dwBufferCount;
#if 1 // {
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
#ifdef USE_MMX // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off    
	cmp	Use_MMX, 0
	je	AssignMmxLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX

	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi

	}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00 \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
    _asm _emit 0x89 _asm _emit 0x42 _asm _emit 0x00

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43860:
_asm {
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
//	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm5, mm6
	psraw		mm5, 8
	movd		esi, mm4
//	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm4, mm6
	psraw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1
	psrad		mm6, 12								// lMIntrep2, lMInterp
//	pand		mm6, QWORD PTR ffffMask
//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.

	movq		mm4, mm5
	mov	esi, DWORD PTR [ecx+4]

	punpckldq	mm4, mm4
	pmaddwd		mm4, mm6
	psrad		mm4, 5
	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2

	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
	mov	esi, DWORD PTR [ecx+8]

	pmaddwd		mm5, mm6
	psrad		mm5, 5
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // There is noise here, probably due to the signed nature of the multiply.
	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }

$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, BYTE PTR [eax+edx]
	movsx	eax, BYTE PTR [eax+edx+1]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches

	add	eax, esi		// lMInterp
	jmp	edi

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 5;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 5
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms
NoMmxCleanupLabel:
#endif
}
#else // }{
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;

#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1]; \
			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
            for (dwJ = 0; dwJ < l_nChannels; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
#endif
        }

#if 1 // {
		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;
		DWORD b = dwLength - dwI;

		if (b < a) a = b;
		if (dwIncDelta < a) a = dwIncDelta;

		dwIncDelta -= a - 1;
		a          += dwI;

		for (; dwI < a; dwI++)
		{
			dwPosition = pfSamplePos >> 12;
			dwFract = pfSamplePos & 0xFFF;
			pfSamplePos += pfPitch;

			lA = (long) pcWave[dwPosition];
			lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1 // {
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else // }{
			for (dwJ = 0; dwJ < l_nChannels; dwJ++)
			{
				lM = lMInterp * vfVolume[dwJ]; 
				lM >>= 5;         // Signal bumps up to 12 bits.

				// Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
				ppBuffer[dwJ][dwI] += (short) lM;
				_asm{jno no_oflow}
				ppBuffer[dwJ][dwI] = 0x7fff;
				_asm{js  no_oflow}
				ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
			}
#endif // }
		}
#else // }{
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 5; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
        for (dwJ = 0; dwJ < l_nChannels; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 5;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
        }
#endif
		dwI++;
#endif // }
    }
#endif // }
#else // }{
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
        }
		dwI++;
    }
#endif // }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}
                        
DWORD CDigitalAudio::MixMulti8Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 
	DWORD dMM6[2];

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

#if 1 // {
	DWORD l_nChannels = dwBufferCount;
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
	long l_lPrevPrevSample = m_lPrevPrevSample, l_lPrevSample = m_lPrevSample;

#ifdef USE_MMX_FILTERED // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off    
	cmp	Use_MMX, 0
	je	AssignMmxLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX

	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi

	}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00  \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
    _asm _emit 0x89 _asm _emit 0x42 _asm _emit 0x00

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1

_asm {
	//	cfK += cfdK;
	//	cfB1 += cfdB1;
	//	cfB2 += cfdB2;

	mov	eax, DWORD PTR cfdK
	mov	edx, DWORD PTR cfdB1
	
	mov	esi, DWORD PTR cfdB2
	add	DWORD PTR cfK, eax

	add DWORD PTR cfB1, edx
	add	DWORD PTR cfB2, esi

$L43860:
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX_FILTERED // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
//	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm5, mm6
	psraw		mm5, 8
	movd		esi, mm4
//	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
	mov			si, WORD PTR [eax+esi]
	movd		mm6, esi
	punpcklbw	mm4, mm6
	psraw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1
	psrad		mm6, 12								// lMIntrep2, lMInterp

#if 1
	//	eax, ebx, ecx, edx, esi are used.	edi is free...
	push	eax
	push	ecx
	push	edx

	movq	QWORD PTR dMM6, mm6

	mov		eax, DWORD PTR dMM6
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx


	mov	DWORD PTR dMM6, eax
	mov	DWORD PTR l_lPrevSample, eax

	//	2nd sample

	mov		eax, DWORD PTR dMM6+4
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx

	mov	DWORD PTR dMM6+4, eax
	mov	DWORD PTR l_lPrevSample, eax

	movq	mm6, QWORD PTR dMM6

	pop		edx
	pop		ecx
	pop		eax
#endif
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1

//	pand		mm6, QWORD PTR ffffMask
	
//	packssdw	mm6, mm0				// 		Saturate to 16 bits, instead.
//	punpcklwd	mm6, mm0

//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.

	movq		mm4, mm5
	mov	esi, DWORD PTR [ecx+4]

	punpckldq	mm4, mm4
	pmaddwd		mm4, mm6
	psrad		mm4, 5
	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2

	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
	mov	esi, DWORD PTR [ecx+8]

	pmaddwd		mm5, mm6
	psrad		mm5, 5
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // There is noise here, probably due to the signed nature of the multiply.
	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }

$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, BYTE PTR [eax+edx]
	movsx	eax, BYTE PTR [eax+edx+1]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches

	add	eax, esi		// lMInterp

//	lMInterp =
//		MulDiv(lMInterp, cfK, (1 << 30))
//		- MulDiv(m_lPrevPrevSample, cfB2, (1 << 30))
//		+ MulDiv(m_lPrevSample, cfB1, (1 << 30))

	push	ecx
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		esi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		esi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx			// esi:eax
	adc		esi, edx

	pop		ecx
//	shrd	eax, esi, 30
		
//>>>>> MOD:PETCHEY 
//	shld	eax, esi, 2
//>>>>> should be 
	shld	esi, eax, 2
	mov		eax, esi

//>>>>>>>>>>>> removed dp
#if 0 
//	if (lMInterp < -32767) lMInterp = -32767;
//	else if (lMInterp > 32767) lMInterp = 32767;

	cmp		eax, -32767
	jl		Less_than
	cmp		eax, 32767
	jg		Greater_than
#endif

//	m_lPrevPrevSample = m_lPrevSample;
//	m_lPrevSample = lMInterp;

	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

Less_than:
	mov	eax, -32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

Greater_than:
	mov	eax, 32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 5;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 5
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 5 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX_FILTERED
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms
NoMmxCleanupLabel:
#endif
}
	m_lPrevPrevSample = l_lPrevPrevSample;
	m_lPrevSample     = l_lPrevSample;
#else // }{
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
            cfB2 += cfdB2;
        }
	    
	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        // Filter
        //
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            - MulDiv(m_lPrevSample, cfB1, (1 << 30))
            + MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
        }
		dwI++;
    }
#endif // }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}

#if 0
DWORD CDigitalAudio::MixMulti16(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;


        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
#endif
no_oflow:	;
        }
		dwI++;
    }
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }
    return (dwI);
}
#else
DWORD CDigitalAudio::MixMulti16(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 


    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

#if 1 // {
	DWORD l_nChannels = dwBufferCount;
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
#ifdef USE_MMX // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off
	cmp	Use_MMX, 0
	je	AssignMMXLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX
	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi

	}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------
#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00 \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx], eax };

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43860:
_asm {
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm5, mm6
//	psarw		mm5, 8
	movd		esi, mm4
	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm4, mm6
//	psarw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1
	psrad		mm6, 12								// lMIntrep2, lMInterp
//	pand		mm6, QWORD PTR ffffMask
//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.

	movq		mm4, mm5
	mov	esi, DWORD PTR [ecx+4]

	punpckldq	mm4, mm4
	pmaddwd		mm4, mm6
	psrad		mm4, 13
	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2

	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
	mov	esi, DWORD PTR [ecx+8]

	pmaddwd		mm5, mm6
	psrad		mm5, 13
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // There is noise here, probably due to the signed nature of the multiply.
	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }


$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, WORD PTR [eax+edx*2]
	movsx	eax, WORD PTR [eax+edx*2+2]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches

	add	eax, esi		// lMInterp
	jmp	edi

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 13;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 13
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms
NoMmxCleanupLabel:
#endif
}
#else // }{
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;

#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1]; \
			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
            for (dwJ = 0; dwJ < l_nChannels; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
#endif
        }

#if 1 // {
		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;
		DWORD b = dwLength - dwI;

		if (b < a) a = b;
		if (dwIncDelta < a) a = dwIncDelta;

		dwIncDelta -= a - 1;
		a          += dwI;

		for (; dwI < a; dwI++)
		{
			dwPosition = pfSamplePos >> 12;
			dwFract = pfSamplePos & 0xFFF;
			pfSamplePos += pfPitch;

			lA = (long) pcWave[dwPosition];
			lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1 // {
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else // }{
			for (dwJ = 0; dwJ < l_nChannels; dwJ++)
			{
				lM = lMInterp * vfVolume[dwJ]; 
				lM >>= 13;         // Signal bumps up to 12 bits.

				// Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
				ppBuffer[dwJ][dwI] += (short) lM;
				_asm{jno no_oflow}
				ppBuffer[dwJ][dwI] = 0x7fff;
				_asm{js  no_oflow}
				ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
			}
#endif // }
		}
#else // }{
        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;
#if 1
#if 1
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
			long b = ppBuffer[dwJ - 1][dwI]; \
			if ((short)b != b) { \
				if ((long)b < 0) b = 0x8000; \
				else b = 0x7fff; \
				ppBuffer[dwJ - 1][dwI] = (short) b; \
			} \
 		}
#else
#define ONE_CHANNEL_VOLUME(dwJ) \
		{ \
            lM = lMInterp * vfVolume[dwJ - 1]; \
            lM >>= 13; \
			ppBuffer[dwJ - 1][dwI] += (short) lM;\
 		}
#endif
			switch (l_nChannels)
			{
			default:
				for (dwJ = l_nChannels; dwJ > 8; dwJ--)
				{
					ONE_CHANNEL_VOLUME(dwJ);
				}
			case 8: ONE_CHANNEL_VOLUME(8);
			case 7: ONE_CHANNEL_VOLUME(7);
			case 6: ONE_CHANNEL_VOLUME(6);
			case 5: ONE_CHANNEL_VOLUME(5);
			case 4: ONE_CHANNEL_VOLUME(4);
			case 3: ONE_CHANNEL_VOLUME(3);
			case 2: ONE_CHANNEL_VOLUME(2);
			case 1: ONE_CHANNEL_VOLUME(1);
			case 0:;
			}
#undef ONE_CHANNEL_VOLUME
#else
        for (dwJ = 0; dwJ < l_nChannels; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
        }
#endif
		dwI++;
#endif // }
    }
#endif // }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    return (dwI);
}
#endif

DWORD CDigitalAudio::MixMulti16Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
	DWORD dMM6[2];					// Handle filter...
	DWORD dMM4[2];					// Handle filter...
	DWORD dMM5[2];					// Handle filter...
    
    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

#if 1 // {
	DWORD l_nChannels = dwBufferCount;
	DWORD a;
	DWORD One_Channel_1, One_Channel_2;	// Code address locations.
	long l_lPrevPrevSample = m_lPrevPrevSample, l_lPrevSample = m_lPrevSample;

#ifdef USE_MMX_FILTERED // {
	typedef __int64 QWORD;
	QWORD	OneMask	 = 0x0000000010001000;
	QWORD	fffMask  = 0x00000fff00000fff;
	QWORD	ffffMask = 0x0000ffff0000ffff;
	DWORD	UseMmx;
    DWORD   MmxVolume[2];
	int		Use_MMX = m_sfMMXEnabled;

	_asm {
    lea edi, $L43865

    // Turned off
	cmp	Use_MMX, 0
	je	AssignMMXLabel

    // != 2 channels
	mov	esi, DWORD PTR l_nChannels
	cmp	esi, 2
	jne	AssignMmxLabel

    // Ok, init and use MMX
	lea	edi, UseMmxLabel

	pxor		mm0, mm0
	movq		mm3, QWORD PTR OneMask		// 0, 0, 0x1000, 0x1000

AssignMmxLabel:
	mov	DWORD PTR UseMmx, edi
}
#endif // }

	_asm {
	mov	edi, DWORD PTR l_nChannels

	cmp	edi, 8
	jna	Start1

	lea	esi, $L44008
	jmp Do_One_Channel_2

	// Put this code more than 127 bytes away from the references.

overflow_x:
	js	overflow_y
	mov	WORD PTR [esi+ebx*2], 0x8000
	jmp	edi

overflow_y:
	mov	WORD PTR [esi+ebx*2], 0x7fff
	jmp	edi

Start1:	
	test	edi, edi
	jne	Start2

	lea	esi, $L43860
	jmp	Do_One_Channel_2

Start2:
	lea	eax, $L43851
	lea	edx, $L43853

	sub	edx, eax
	mov	esi, 8

	sub	esi, edi
	imul	esi, edx
	add	esi, eax

Do_One_Channel_2:
	mov	DWORD PTR One_Channel_1, esi

	//	Create second jump table location.
	
	lea	esi, $L43876
	lea	ecx, $L43880

	sub	ecx, esi

	push ecx				// Span between branches.

	mov	eax, 8
	sub	eax, DWORD PTR l_nChannels

	jge		Start3
	
	lea	ecx, $L44009
	jmp	Done_Do_Channel_2

Start3:
	cmp	eax, 8
	jne	Start4

	lea	ecx, $L43866
	jmp	Done_Do_Channel_2

Start4:
	imul	ecx, eax
	add		ecx, esi

Done_Do_Channel_2:
	mov	DWORD PTR One_Channel_2, ecx


	mov	ecx, DWORD PTR dwLength
	xor	ebx, ebx					// dwI

	test	ecx, ecx
	jbe	Exit_$L43841

	mov	ecx, DWORD PTR ppBuffer
	sub	ecx, 4

	//	ecx == ppBuffer - 4
	//	ebx == dwI
	//	edi == l_nChannels
$L44021:

	mov	edx, DWORD PTR pfSamplePos
	cmp	edx, DWORD PTR pfSampleLength
	jl	SHORT $L43842

	mov	eax, DWORD PTR pfLoopLength
	test	eax, eax
	je	Exit_$L43841

	sub	edx, eax
	mov	DWORD PTR pfSamplePos, edx

$L43842:
	mov	edx, DWORD PTR dwIncDelta
	mov	eax, DWORD PTR pfPFract

	dec	edx

	mov	DWORD PTR dwIncDelta, edx
	jne	$L43860

	mov	edx, DWORD PTR dwDeltaPeriod
	mov	esi, DWORD PTR pfDeltaPitch

	mov	DWORD PTR dwIncDelta, edx
	add	eax, esi

	mov	DWORD PTR pfPFract, eax

	sar	eax, 8
	mov	DWORD PTR pfPitch, eax

	mov	esi, DWORD PTR vfDeltaVolume
	jmp	One_Channel_1

// ONE_CHANNEL
//			vfVFract[dwJ - 1] += vfDeltaVolume[dwJ - 1];
//			vfVolume[dwJ - 1]  = vfVFract     [dwJ - 1] >> 8;

$L44008:

	mov	DWORD PTR dwI, ebx
	lea	ebx, DWORD PTR [edi*4-4]
	add	edi, -8					; fffffff8H
$L43849:

	lea	eax, DWORD PTR vfVFract[ebx]
	mov	ecx, DWORD PTR [esi+ebx]
	sub	ebx, 4
	add	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [eax]
	sar	eax, 8
	mov	DWORD PTR vfVolume[ebx+4], eax
	dec	edi
	jne	SHORT $L43849

	mov	edi, DWORD PTR l_nChannels
	mov	ecx, DWORD PTR ppBuffer

	mov	ebx, DWORD PTR dwI
	sub	ecx, 4
}
#define ONE_CHANNEL_VOLUME(dwJ) \
	_asm { mov	eax, DWORD PTR vfVFract[(dwJ-1)*4] }; \
	_asm { add	eax, DWORD PTR [esi+(dwJ-1)*4] }; \
	_asm { mov	DWORD PTR vfVFract[(dwJ-1)*4], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
	_asm { mov	DWORD PTR [edx + (dwJ-1)*4], eax };

    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
	_asm { mov	eax, DWORD PTR vfVFract[0] }; \
    _asm _emit 0x03 _asm _emit 0x46 _asm _emit 0x00 \
	_asm { mov	DWORD PTR vfVFract[0], eax }; \
	_asm { sar	eax, 8 }; \
    _asm { lea  edx, vfVolume }; \
    _asm _emit 0x89 _asm _emit 0x42 _asm _emit 0x00

$L43851:
	ONE_CHANNEL_VOLUME(8)
$L43853:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1

_asm {
	//	cfK += cfdK;
	//	cfB1 += cfdB1;
	//	cfB2 += cfdB2;

	mov	eax, DWORD PTR cfdK
	mov	edx, DWORD PTR cfdB1
	
	mov	esi, DWORD PTR cfdB2
	add	DWORD PTR cfK, eax

	add DWORD PTR cfB1, edx
	add	DWORD PTR cfB2, esi

$L43860:
; 304  : 		DWORD a = (pfSampleLength - pfSamplePos + pfPitch - 1) / pfPitch;

	mov	esi, DWORD PTR pfPitch
	mov	eax, DWORD PTR pfSampleLength

	dec	esi
	sub	eax, DWORD PTR pfSamplePos

	add	eax, esi
	cdq
	idiv	DWORD PTR pfPitch

	mov	edx, DWORD PTR dwLength
	sub	edx, ebx

	cmp	edx, eax
	jae	SHORT $L43863
	mov	eax, edx

$L43863:
	mov	edx, DWORD PTR dwIncDelta
	cmp	edx, eax
	jae	SHORT $L43864
	mov	eax, edx

$L43864:

; 309  : 
; 310  : 		for (a += dwI; dwI < a; dwI++)

	inc	edx

	sub	edx, eax
	add	eax, ebx

	mov	DWORD PTR dwIncDelta, edx
	cmp	ebx, eax

	mov	DWORD PTR a, eax
	jae	$L43867

#ifdef USE_MMX_FILTERED // {
	// Try to handle two positions at once.

	lea	edx, [eax-3]
	cmp	ebx, edx
	jge	$L43865

	jmp	UseMmx

UseMmxLabel:
	//	Ok, there are at least two samples to handle.

	movd		mm1, DWORD PTR pfPitch
	psllq		mm1, 32						// Pitch,				0
	movd		mm2, DWORD PTR pfSamplePos
	punpckldq	mm2, mm2					// SamplePos,			SamplePos
	paddd		mm2, mm1					// SamplePos + Pitch,	SamplePos
	punpckhdq	mm1, mm1					// Pitch,				Pitch
	pslld		mm1, 1						// Pitch * 2,			Pitch * 2

	mov			eax, DWORD PTR pcWave
#if 0
    movq        mm4, QWORD PTR vfVolume
    pand        mm4, QWORD PTR ffffMask
    movq        mm5, mm4
    pslld       mm4, 16
    por         mm4, mm5
    psllw       mm4, 3
    movq        QWORD PTR MmxVolume, mm4
#endif
	
TwoAtATime:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;

	movq		mm4, mm2
	psrad		mm4, 12				// dwPosition + Pitch,	dwPosition

;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * (dwFract)) >> 12) + lA;

	movd		esi, mm4						// dwPosition
	punpckhdq	mm4, mm4						// dwPosition ( + Pitch ) = dwPos2
	movd		mm5, DWORD PTR [eax+esi*2]		// 0, 0, dwPosition + 1, dwPosition
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm5, mm6
//	psarw		mm5, 8
	movd		esi, mm4
	movd		mm4, DWORD PTR [eax+esi*2]		// 0, 0, dwPos2 + 1, dwPos2
//	Instead for byte codes
//	mov			si, WORD PTR [eax+esi]
//	movd		mm6, esi
//	punpcklbw	mm4, mm6
//	psarw		mm4, 8
//	This code could be combined with code above, a bit.

	punpckldq	mm5, mm4						// dwPos2 + 1, dwPos2, dwPos1 + 1, dwPos1
	movq		mm4, mm2
	pand		mm4, QWORD PTR fffMask				// dwFract + Pitch,		dwFract
	packssdw	mm4, mm0
	movq		mm6, mm3
	psubw		mm6, mm4							// 0, 0, 1000 - dwFract + Pitch, 1000 - dwFract
	punpcklwd	mm6, mm4
	paddd		mm2, mm1			                // Next iteration
	pmaddwd		mm6, mm5
#if 1 // {
	psrad		mm6, 12								// lMIntrep2, lMInterp

#if 1 // {
	//	eax, ebx, ecx, edx, esi are used.	edi is free...
	push	eax
	push	ecx
	push	edx

	movq	QWORD PTR dMM6, mm6

	mov		eax, DWORD PTR dMM6
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx

	mov	DWORD PTR dMM6, eax
	mov	DWORD PTR l_lPrevSample, eax

	//	2nd sample

	mov		eax, DWORD PTR dMM6+4
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		edi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		edi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
	adc		edx, edi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx

	mov	DWORD PTR dMM6+4, eax
	mov	DWORD PTR l_lPrevSample, eax

	movq	mm6, QWORD PTR dMM6

	pop		edx
	pop		ecx
	pop		eax
#endif // }

#define DO_32BIT_MULTIPLY
#ifndef DO_32BIT_MULTIPLY
	movq		mm5, QWORD PTR vfVolume 			//	Volume2, Volume1
//	pand    	mm5, QWORD PTR ffffMask			//	16 bits only.
#endif

//	pand		mm6, QWORD PTR ffffMask

#ifndef DO_32BIT_MULTIPLY
	movq		mm4, mm5
#endif
	mov	esi, DWORD PTR [ecx+4]

#ifndef DO_32BIT_MULTIPLY
	punpckldq	mm4, mm4
#endif

#ifdef DO_32BIT_MULTIPLY
	mov			edi, DWORD PTR vfVolume
	imul		edi, DWORD PTR dMM6
	sar			edi, 13
	mov			DWORD PTR dMM4, edi

	mov			edi, DWORD PTR vfVolume
	imul		edi, DWORD PTR dMM6+4
	sar			edi, 13
	mov			DWORD PTR dMM4+4, edi

	movq		mm4, QWORD PTR dMM4
#else
	pmaddwd		mm4, mm6
	psrad		mm4, 13
#endif

	packssdw	mm4, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm4
	movd		DWORD PTR [esi+ebx*2], mm7

	//	CHANNEL 2


#ifndef DO_32BIT_MULTIPLY
	punpckhdq	mm5, mm5						// 0, Volume2,   0, Volume2
#endif
	mov	esi, DWORD PTR [ecx+8]

#ifdef DO_32BIT_MULTIPLY
	mov			edi, DWORD PTR vfVolume+4
	imul		edi, DWORD PTR dMM6
	sar			edi, 13
	mov			DWORD PTR dMM5, edi

	mov			edi, DWORD PTR vfVolume+4
	imul		edi, DWORD PTR dMM6+4
	sar			edi, 13
	mov			DWORD PTR dMM5+4, edi

	movq		mm5, QWORD PTR dMM5
#else
	pmaddwd		mm5, mm6
	psrad		mm5, 13
#endif
	packssdw	mm5, mm0

	movd		mm7, DWORD PTR [esi+ebx*2]
	paddsw		mm7, mm5
	movd		DWORD PTR [esi+ebx*2], mm7

#else           // }{ There is noise here, probably due to the signed nature of the multiply.

	// NOTE the filter is NOT implemented here....

	psrad		mm6, 12								// lMIntrep2, lMInterp
    movq        mm5, QWORD PTR MmxVolume
    packssdw    mm6, mm0
    punpckldq   mm6, mm6
    pmulhw      mm6, mm5
	mov	esi, DWORD PTR [ecx+4]
	movd		mm7, DWORD PTR [esi+ebx*2]
	mov	esi, DWORD PTR [ecx+8]
	movd		mm4, DWORD PTR [esi+ebx*2]
    punpckldq   mm4, mm7
    paddsw      mm4, mm6
    movd        DWORD PTR [esi+ebx*2], mm4
    punpckhdq   mm4, mm4
	mov	esi, DWORD PTR [ecx+4]
    movd        DWORD PTR [esi+ebx*2], mm4

#endif // }

	add	ebx, 2

	cmp	ebx, edx
	jb	TwoAtATime

	movd	DWORD PTR pfSamplePos, mm2
#endif  // }

$L43865:

;					dwPosition = pfSamplePos >> 12;
;					dwFract = pfSamplePos & 0xFFF;
;					pfSamplePos += pfPitch;
;					lA = (long) pcWave[dwPosition];
;					lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

	mov	esi, DWORD PTR pfPitch
	mov	edx, DWORD PTR pfSamplePos

	mov	eax, DWORD PTR pcWave
	mov	edi, edx

	add	esi, edx
	and	edi, 4095

	sar	edx, 12
	mov	DWORD PTR pfSamplePos, esi

	movsx	esi, WORD PTR [eax+edx*2]
	movsx	eax, WORD PTR [eax+edx*2+2]

	sub	eax, esi

	imul	eax, edi

	sar	eax, 12
	mov	edi, One_Channel_2

	//	ebx, ecx, edx are used in switch branches
	add	eax, esi		// lMInterp

#if 1 
//	lMInterp =
//		MulDiv(lMInterp, cfK, (1 << 30))
//		- MulDiv(m_lPrevPrevSample, cfB2, (1 << 30))
//		+ MulDiv(m_lPrevSample, cfB1, (1 << 30))

	push	ecx
	imul	DWORD PTR cfK		// edx:eax
	
	mov		ecx, eax
	mov		eax, DWORD PTR l_lPrevPrevSample

	mov		esi, edx			// esi:ecx
	imul	DWORD PTR cfB2

	sub		ecx, eax
	mov		eax, DWORD PTR l_lPrevSample

	sbb		esi, edx
	mov		DWORD PTR l_lPrevPrevSample, eax

	imul	DWORD PTR cfB1

	add		eax, ecx
//	adc		esi, edx
	adc		edx, esi

	pop		ecx
//	shrd	eax, edx, 30
//	mov		esi,0x40000000
//	idiv	esi

//>>>>> MOD:PETCHEY 
//	shld	eax, edx, 2
//>>>>> should be 
	shld	edx, eax, 2
	mov		eax, edx
#endif
	
//>>>>>>>>>>>> removed dp
#if 0 
//	if (lMInterp < -32767) lMInterp = -32767;
//	else if (lMInterp > 32767) lMInterp = 32767;

	cmp		eax, -32767
	jl		Less_than
	cmp		eax, 32767
	jg		Greater_than
#endif

//	m_lPrevPrevSample = m_lPrevSample;
//	m_lPrevSample = lMInterp;

	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

//>>>>>>>>>>>> removed dp
#if 0 
Less_than:
	mov	eax, -32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi

Greater_than:
	mov	eax, 32767
	mov	DWORD PTR l_lPrevSample, eax
	jmp	edi
#endif

// ONE_CHANNEL
//          lM = lMInterp * vfVolume[dwJ - 1];
//          lM >>= 13;
//			ppBuffer[dwJ - 1][dwI] += (short) lM;

$L44009:

; 342  : 			default:
; 343  : 				for (dwJ = l_nChannels; dwJ > 8; dwJ--)

	mov	edi, DWORD PTR l_nChannels

	//	ecx ppBuffer
	//	eax lMInterp
	//	edi counter
	//	ebx dwI

$L43874:
	mov	edx, DWORD PTR vfVolume[edi*4-4]
	mov	esi, DWORD PTR [ecx+edi*4]			// ppBuffer[dwJ - 1]

	imul	edx, eax
	sar	edx, 13
	add	WORD PTR [esi+ebx*2], dx

	jno	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x7fff
	js	no_overflow
	mov	WORD PTR [esi+ebx*2], 0x8000

no_overflow:
	dec	edi
	cmp	edi, 8
	jne	SHORT $L43874

	lea	edi, $L43876
}

#define ONE_CHANNEL_VOLUME(dwJ) \
    _asm { lea  edx, vfVolume } \
	_asm { mov	edx, DWORD PTR [edx + (dwJ-1) * 4] } \
	_asm { mov	esi, DWORD PTR [ecx + (dwJ) * 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 


    //-------------------------------------------------------------------------
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    // This lovely hack makes sure that all the instructions
    // are the same length for the case (dwJ - 1) == 0. Code depends on this
    // by calculating instruction offsets based on having 8 identical blocks.
    //
    //          ***** ***** ***** DO NOT CHANGE THIS! ***** ***** *****
    //
    //-------------------------------------------------------------------------

#define ONE_CHANNEL_VOLUME_1 \
    _asm { lea  edx, vfVolume } \
    _asm _emit 0x8B _asm _emit 0x52 _asm _emit 0x00 \
	_asm { mov	esi, DWORD PTR [ecx + 4] } \
	_asm { imul	edx, eax } \
	_asm { sar	edx, 13 } \
	_asm { add	edi, [esp] } \
	\
	_asm { add	WORD PTR [esi+ebx*2], dx } \
	_asm { jo	FAR overflow_x } 

$L43876:
	ONE_CHANNEL_VOLUME(8);
$L43880:
	ONE_CHANNEL_VOLUME(7);
	ONE_CHANNEL_VOLUME(6);
	ONE_CHANNEL_VOLUME(5);
	ONE_CHANNEL_VOLUME(4);
	ONE_CHANNEL_VOLUME(3);
	ONE_CHANNEL_VOLUME(2);
	ONE_CHANNEL_VOLUME_1;
#undef ONE_CHANNEL_VOLUME
#undef ONE_CHANNEL_VOLUME_1
$L43866:
_asm {
	mov	eax, DWORD PTR a
	inc	ebx

	cmp	ebx, eax
	jb	$L43865

	mov	edi, DWORD PTR l_nChannels
$L43867:
	cmp	ebx, DWORD PTR dwLength
	jb	$L44021
Exit_$L43841:
	pop eax
	mov	DWORD PTR dwI, ebx

#ifdef USE_MMX_FILTERED
    mov edi, UseMmx
    cmp edi, UseMmxLabel
    jne NoMmxCleanupLabel

	emms

NoMmxCleanupLabel:
#endif
}

	m_lPrevPrevSample = l_lPrevPrevSample;
	m_lPrevSample     = l_lPrevSample;
#else // }{
    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
           cfB2 += cfdB2;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// We store the negative of b1 in the table, so we flip the sign again by
		// adding here
		//
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            + MulDiv(m_lPrevSample, cfB1, (1 << 30))
            - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

//>>>>>>>>>>>> removed dp
#if 0 
		if (lMInterp < -32767) lMInterp = -32767;
		else if (lMInterp > 32767) lMInterp = 32767;
#endif
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
        }
		dwI++;
    }
#endif // }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

	m_cfLastK = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    return (dwI);
}

#else // }{     all assembly code
DWORD CDigitalAudio::MixMulti8(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
    VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    long lA;//, lB;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }   
	
    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;
	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
#endif
        }
		dwI++;
    }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}
                        
DWORD CDigitalAudio::MixMulti8Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lMInterp;
    long lM;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 
	DWORD dMM6[2];

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength; )
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
		        pfSamplePos -= pfLoopLength;
	        else
		        break;
	    }
        dwIncDelta--;
        if (!dwIncDelta) 
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
            cfB2 += cfdB2;
        }
	    
	    dwPosition = pfSamplePos >> 12;
	    dwFract = pfSamplePos & 0xFFF;
		pfSamplePos += pfPitch;

	    lMInterp = pcWave[dwPosition]; // pcWave
	    lMInterp += ((pcWave[dwPosition + 1] - lMInterp) * dwFract) >> 12;

        // Filter
        //
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            - MulDiv(m_lPrevSample, cfB1, (1 << 30))
            + MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
    		lM = lMInterp * vfVolume[dwJ];
    		lM >>= 5;

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
		    ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:   ;
#endif
#endif
        }
		dwI++;
    }

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    return (dwI);
}

DWORD CDigitalAudio::MixMulti16(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength)
{
    DWORD dwI = 0;
    DWORD dwJ = 0;
    DWORD dwPosition = 0;
    long lA = 0;//, lB;
    long lM = 0;
    long lMInterp = 0;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;

    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
#endif
        }
		dwI++;
    }
    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }
    return (dwI);
}

DWORD CDigitalAudio::MixMulti16Filter(
    short *ppBuffer[], 
	DWORD dwBufferCount,
    DWORD dwLength, 
    DWORD dwDeltaPeriod, 
    VFRACT vfDeltaVolume[], 
	VFRACT vfLastVolume[], 
    PFRACT pfDeltaPitch, 
    PFRACT pfSampleLength, 
    PFRACT pfLoopLength,
    COEFF cfdK,
    COEFF cfdB1,
    COEFF cfdB2)
{
    DWORD dwI, dwJ;
    DWORD dwPosition;
    long lA;//, lB;
    long lM;
    long lMInterp;
    DWORD dwIncDelta = dwDeltaPeriod;
    VFRACT dwFract;
    short * pcWave = m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    COEFF cfK  = m_cfLastK;
    COEFF cfB1 = m_cfLastB1;
    COEFF cfB2 = m_cfLastB2;
	DWORD dMM6[2];					// Handle filter...
    
    VFRACT vfVolume[MAX_DAUD_CHAN]; // = m_vfLastLVolume;
    VFRACT vfVFract[MAX_DAUD_CHAN]; // = vfVolume << 8;  // Keep high res version around. 

    for (dwI = 0; dwI < dwBufferCount; dwI++)
    {
        vfVolume[dwI] = vfLastVolume[dwI];
        vfVFract[dwI] = vfVolume[dwI] << 8;
    }    

    for (dwI = 0; dwI < dwLength;)
    {
        if (pfSamplePos >= pfSampleLength)
	    {	
	        if (pfLoopLength)
    		    pfSamplePos -= pfLoopLength;
	        else
	    	    break;
	    }
        dwIncDelta--;
        if (!dwIncDelta)   
        {
            dwIncDelta = dwDeltaPeriod;
            pfPFract += pfDeltaPitch;
            pfPitch = pfPFract >> 8;
            for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
            {
                vfVFract[dwJ] += vfDeltaVolume[dwJ];
                vfVolume[dwJ] = vfVFract[dwJ] >> 8;
            }

            cfK += cfdK;
            cfB1 += cfdB1;
           cfB2 += cfdB2;
        }

        dwPosition = pfSamplePos >> 12;
        dwFract = pfSamplePos & 0xFFF;
        pfSamplePos += pfPitch;

        lA = (long) pcWave[dwPosition];
        lMInterp = (((pcWave[dwPosition+1] - lA) * dwFract) >> 12) + lA;

        // Filter
        //
		// z = k*s - b1*z1 - b2*b2
		// We store the negative of b1 in the table, so we flip the sign again by
		// adding here
		//
        lMInterp =
              MulDiv(lMInterp, cfK, (1 << 30))
            + MulDiv(m_lPrevSample, cfB1, (1 << 30))
            - MulDiv(m_lPrevPrevSample, cfB2, (1 << 30));

//>>>>>>>>>>>> removed dp
#if 0 
		if (lMInterp < -32767) lMInterp = -32767;
		else if (lMInterp > 32767) lMInterp = 32767;
#endif
        m_lPrevPrevSample = m_lPrevSample;
        m_lPrevSample = lMInterp;

        for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
        {
            lM = lMInterp * vfVolume[dwJ]; 
            lM >>= 13;         // Signal bumps up to 12 bits.

            // Keep this around so we can use it to generate new assembly code (see below...)
#if 1
			{
			long x = ppBuffer[dwJ][dwI];
			
			x += lM;

			if (x != (short)x) {
				if (x > 32767) x = 32767;
				else  x = -32768;
			}

			ppBuffer[dwJ][dwI] = (short)x;
			}
#else
            ppBuffer[dwJ][dwI] += (short) lM;
#ifdef i386
            _asm{jno no_oflow}
            ppBuffer[dwJ][dwI] = 0x7fff;
            _asm{js  no_oflow}
            ppBuffer[dwJ][dwI] = (short) 0x8000;
no_oflow:	;
#endif
#endif
        }
		dwI++;
    }

    m_pfLastPitch = pfPitch;
    m_pfLastSample = pfSamplePos;

	m_cfLastK = cfK;
	m_cfLastB1 = cfB1;
	m_cfLastB2 = cfB2;

    for (dwJ = 0; dwJ < dwBufferCount; dwJ++)
    {
        vfLastVolume[dwJ] = vfVolume[dwJ];
    }

    return (dwI);
}

#endif // }

#endif // XMIX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\stdafx.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__58C2B4C5_46E7_11D1_89AC_00A0C9054129__INCLUDED_)
#define AFX_STDAFX_H__58C2B4C5_46E7_11D1_89AC_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__58C2B4C5_46E7_11D1_89AC_00A0C9054129__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\stdafx.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\sverb.h ===
/***********************************************************
Copyrights : ksWaves Ltd. 1998.

Provided to Microsoft under contract between ksWaves and Microsoft.

************************************************************/

/****************************************************************************
Const defines :
*****************************************************************************/
#define FPU_DENORM_OFFS (float)1.0E-30

#define BASE_REV_DELAY  0x4000
#define BASE_DSPS_DELAY 0x800

#define DSPS_MASK   0x7ff
#define REV_MASK    0x3fff

/****************************************************************************
Coefs Struct :
*****************************************************************************/
typedef struct
{

	long mySize;
	long myVersion;
	float SampleRate;

	float directGain; 
	long  l_directGain; 
	float revGain; 
	long l_revGain; 

	long lDelay1;
	long lDelay2;
	long lDelay3;
	long lDelay4;

	long lDDly1; 
	long lDDly2; 

	float dDsps;
	long l_dDsps;

	float dDG1;
	long l_dDG1;

	float dDG2; 
	long l_dDG2; 

	float dFB11;
	long l_dFB11;
	float dFB12;
	long l_dFB12;
	float dFB21;
	long l_dFB21;
	float dFB22;
	long l_dFB22;
	float dFB31;
	long l_dFB31;
	float dFB32;
	long l_dFB32;
	float dFB41;
	long l_dFB41;
	float dFB42;
	long l_dFB42;

	float dDamp;
	long l_dDamp;


} sCoefsStruct;

/****************************************************************************
Initialization and control functions :
*****************************************************************************/

#ifdef __cplusplus
extern "C"
{
#endif

#define MAX_16 (float)((unsigned long)0x00008000)

void InitSVerbStates( long *pStates );
long DToF32( float dbl  );
void ConvertCoefsToFix( void *pC );
void InitSVerb( float SampleRate, void  *pCoefs);
void SetSVerb( float InGain, float dRevMix,  float dRevTime, 
			    float dHighFreqRTRatio, void  *pCoefs );



long GetCoefsSize(void);
long GetStatesSize(void);
long GetSVerbVersion(void);

float VerifySampleRate(void  *pCoefs);
long VerifyVersion(void  *pCoefs);
long VerifySize(void  *pCoefs);


#define CLIP_SHORT_TO_SHORT(x)\
			if (x>32767)\
				x = 32767;\
			else if (x<-32768)\
				x = -32768;

/****************************************************************************
//Process Functions :
*****************************************************************************/

__inline void dsps( float *pDly, long ref, long delay, float dDG1, float dDsps, float *inL, float *inR );
__inline void dspsL( long *pDly, long ref, long delay, long dDG1, long dDsps, long *inL, long *inR );

void SVerbMonoToMonoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbMonoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbStereoToStereoShort(long NumInFrames, short *pInShort, short *pOutShort, 
						 void  *pCoefs, long *pStates);

void SVerbMonoToMonoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);

void SVerbMonoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);

void SVerbStereoToStereoFloat(long NumInFrames, float *pInFloat, float *pOutFloat, 
						 void  *pCoefs, float *pStates);


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\syslink.cpp ===
// Copyright (c) 1998 Microsoft Corporation
//
// syslink.cpp
//
#include "common.h"
#include <mmsystem.h>


CSysLink::CSysLink()
{
    m_cRef = 1;
}

CSysLink::~CSysLink()
{
}

STDMETHODIMP CSysLink::QueryInterface(const IID &iid, void **ppv)
{
    if (IsEqualGUIDAligned(iid, IID_IUnknown))
    {
        *ppv = PVOID(PUNKNOWN(this));
    }
    else if (IsEqualGUIDAligned(iid, IID_IDirectMusicSynthSink))
    {
        *ppv = PVOID(PDIRECTMUSICSYNTHSINK(this));
    }
    else
    {
        return E_NOINTERFACE;
    }

    return S_OK;
}

STDMETHODIMP_(ULONG) CSysLink::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSysLink::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSysLink::Init(CSynth *pSynth) 
{
    return S_OK;
}

STDMETHODIMP CSysLink::SetFormat(LPCWAVEFORMATEX pWaveFormat)
{
    return S_OK;
}

STDMETHODIMP CSysLink::SetMasterClock(IReferenceClock *pClock)
{
    return S_OK;
}

STDMETHODIMP CSysLink::GetLatencyClock(IReferenceClock **ppClock)
{
    return S_OK;
}

STDMETHODIMP CSysLink::Activate(HWND hWnd, BOOL fEnable)
{
    return S_OK;
}

STDMETHODIMP CSysLink::SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime)
{
    return S_OK;
}

STDMETHODIMP CSysLink::RefTimeToSample(REFERENCE_TIME rfTime, LONGLONG *pllSampleTime)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\syslink.h ===
// Copyright (c) 1998 Microsoft Corporation
//
//
// 
#ifndef _SYSLINK_
#define _SYSLINK_

#include <mmsystem.h>

#undef  INTERFACE
#define INTERFACE  IReferenceClock
DECLARE_INTERFACE_(IReferenceClock, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;

    /*  IReferenceClock */
    /*  */
    
    /*  get the time now */
    STDMETHOD(GetTime)                  (THIS_ REFERENCE_TIME *pTime) PURE;

    /*  ask for an async notification that a time has elapsed */
    STDMETHOD(AdviseTime)               (THIS_ REFERENCE_TIME baseTime,         /*  base time */
                                               REFERENCE_TIME streamTime,       /*  stream offset time */
                                               HANDLE hEvent,                   /*  advise via this event */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  ask for an async periodic notification that a time has elapsed */
    STDMETHOD(AdvisePeriodic)           (THIS_ REFERENCE_TIME startTime,        /*  starting at this time */
                                               REFERENCE_TIME periodTime,       /*  time between notifications */
                                               HANDLE hSemaphore,               /*  advise via a semaphore */
                                               DWORD * pdwAdviseCookie) PURE;   /*  where your cookie goes */

    /*  cancel a request for notification */
    STDMETHOD(Unadvise)                 (THIS_ DWORD dwAdviseCookie) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthSink
DECLARE_INTERFACE_(IDirectMusicSynthSink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynthSink */
    STDMETHOD(Init)                 (THIS_ CSynth *pSynth) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pWaveFormat) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ HWND hWnd, 
                                           BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,
                                           REFERENCE_TIME *prfTime) PURE;
    STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, 
                                           LONGLONG *pllSampleTime) PURE;
};

typedef IDirectMusicSynthSink *PDIRECTMUSICSYNTHSINK;

class CSysLink : public IDirectMusicSynthSink
{
public:
    // IUnknown
    //
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *);
    STDMETHOD_(ULONG, AddRef)       (THIS);
    STDMETHOD_(ULONG, Release)      (THIS);

    // IDirectMusicSynthSink
    //
    STDMETHOD(Init)                 (THIS_ CSynth *pSynth);
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pWaveFormat);
	STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock);
	STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock);
	STDMETHOD(Activate)             (THIS_ HWND hWnd, BOOL fEnable);
	STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, LONGLONG *pllSampleTime);

    // Class
    //
	CSysLink();
	~CSysLink();

private:
    LONG m_cRef;
};

#define STATIC_IID_IDirectMusicSynthSink \
    0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6
DEFINE_GUIDSTRUCT("aec17ce3-a514-11d1-afa6-00aa0024d8b6", IID_IDirectMusicSynthSink);
#define IID_IDirectMusicSynthSink DEFINE_GUIDNAMED(IID_IDirectMusicSynthSink)

#endif // _SYSLINK_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992-1998 Microsoft Corporation
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef WIN32

    //----------------------------------------------------------------------;
    //
    //  Win 32
    //
    //----------------------------------------------------------------------;

    #ifdef _X86_
    
        //
        //  Use 32-bit x86 assembly.
        //

        #pragma warning(disable:4035 4704)

        INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     imul    ebx              //  imul ebx
            _asm     idiv    ecx              //  idiv ecx
            _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     shr     ebx,1            //  sar  ebx,1
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDiv32()

        INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     mov     ebx,ecx          //  mov  ebx,ecx
            _asm     dec     ebx              //  dec  ebx
            _asm     add     eax,ebx          //  add  eax,ebx
            _asm     adc     edx,0            //  adc  edx,0
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRU32()

        INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
        {
            _asm     mov     eax,dword ptr a  //  mov  eax, a
            _asm     mov     ebx,dword ptr b  //  mov  ebx, b
            _asm     mov     ecx,dword ptr c  //  mov  ecx, c
            _asm     mul     ebx              //  mul  ebx
            _asm     div     ecx              //  div  ecx
            _asm     shld    edx, eax, 16     //  shld edx, eax, 16

        } // MulDivRD32()

        #pragma warning(default:4035 4704)


    #else

        //
        //  Use C9 __int64 support for Daytona RISC platforms.
        //

        INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
        {
            return (LONG)( Int32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( UInt32x32To64(a,b) / c );
        }


        INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
        }


        INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
        {
            return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
        }

    #endif


#else

    //----------------------------------------------------------------------;
    //
    //  Win 16
    //
    //----------------------------------------------------------------------;

    #pragma warning(disable:4035 4704)

    //
    //  Compile for 16-bit - we can use x86 with proper opcode prefixes
    //	    to get 32-bit instructions.
    //

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    imul    bx              //  imul ebx
        _asm _emit 0x66 _asm    idiv    cx              //  idiv ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    shr     bx,1            //  sar  ebx,1
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    mov     bx,cx           //  mov  ebx,ecx
        _asm _emit 0x66 _asm    dec     bx              //  dec  ebx
        _asm _emit 0x66 _asm    add     ax,bx           //  add  eax,ebx
        _asm _emit 0x66 _asm    adc     dx,0            //  adc  edx,0
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRU32()


    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm _emit 0x66 _asm    mov     ax,word ptr a   //  mov  eax, a
        _asm _emit 0x66 _asm    mov     bx,word ptr b   //  mov  ebx, b
        _asm _emit 0x66 _asm    mov     cx,word ptr c   //  mov  ecx, c
        _asm _emit 0x66 _asm    mul     bx              //  mul  ebx
        _asm _emit 0x66 _asm    div     cx              //  div  ecx
        _asm _emit 0x66                                 //  shld edx, eax, 16
        _asm _emit 0x0F
        _asm _emit 0xA4
        _asm _emit 0xC2
        _asm _emit 0x10

    } // MulDivRD32()

    #pragma warning(default:4035 4704)

#endif


//
//  some code references these by other names.
//
#define MulDiv      MulDiv32
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\mmx.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//      Mmx.cpp
//      MMX Mix engines for Microsoft synth

/*
Variable useage.

		Variable									register 
		pfSamplePos									eax
		pfPitch										ebx
		dwI											ecx
		dwIncDelta									edx (edx is sometimes a temporary register)
		dwPosition1									esi
		dwPostiion2									edi

		vfRvolume and vfLvolume						mm0		
		vfRVolume, vfLVolume						mm2		

		mm4 - mm7 are temporary mmx registers.
*/

// Notes about calculation.

		// Loop is unrolled once.
		// *1  shifting volumne to 15 bit values to get rid of shifts and simplify code.
		// This make the packed mulitply work better later since I keep the sound interpolated
		// wave value at 16 bit signed value.  For a PMULHW, this results in 15 bit results
		// which is the same as the original code.


		// *2 linear interpolation can be done very quickly with MMX by re-arranging the
		// way that the interpolation is done. Here is code in C that shows the difference.
		// Original C code		
        //lM1 = ((pcWave[dwPosition1 + 1] - pcWave[dwPosition1]) * dwFract1) >> 12;
		//lM2 = ((pcWave[dwPosition2 + 1] - pcWave[dwPosition2]) * dwFract2) >> 12;
        //lM1 += pcWave[dwPosition1];
		//lM2 += pcWave[dwPosition2];

		// Equivalent C Code that can be done with a pmadd
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;


#ifdef DMSYNTH_MINIPORT
#include "common.h"
#else
#include "simple.h"
#include <mmsystem.h>
#include "synth.h"
#include "debug.h"
#endif

#ifdef XMIX

BOOL MultiMediaInstructionsSupported()
{
    return TRUE;
}

#else // rest of file

typedef unsigned __int64 QWORD;

#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono8X(short * pBuffer, 
							   DWORD dwLength,
							   DWORD dwDeltaPeriod,
							   VFRACT vfDeltaVolume,
							   VFRACT vfLastVolume[],
							   PFRACT pfDeltaPitch, 
							   PFRACT pfSampleLength, 
							   PFRACT pfLoopLength)
{
    DWORD dwI;    
    DWORD dwIncDelta = dwDeltaPeriod;
    
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfVolume
	movd	mm7, vfVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaVolume
	movd	mm6, vfDeltaVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfVFract += vfDeltaVolume;
											// vfVFract += vfDeltaVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		inc		ecx					//dwI++;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		//shl		esi, 1			// do not shift left since pcWave is array of chars
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movzx	esi, word ptr[esi]	//lLM1 = pcWave[dwPosition1];
		movd	mm3, esi

		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		//shl		edi, 1			//do not shift left since pcWave is array of chars
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;
		
		movzx	edi, word ptr[edi]	//lLM2 = pcWave[dwPoisition2];
		movd	mm6, edi

		pxor	mm7, mm7		// zero out mm7 to make 8 bit into 16 bit
					
								// low 4 bytes in mm3
		punpcklwd	mm3, mm6	// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1]											
		
		add		esi, pBuffer	//
	punpcklbw	mm7, mm3		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		

		movq	mm3, mm2		// put left and right volume levels in mm3
		add		eax, ebx		//pfSamplePos += pfPitch;

		packssdw	mm3, mm2		// words in mm7
								// vfVolume, vfVolume, vfVolume, vfVolume
									
		movd	mm5, dword ptr[esi-2]	// Load values from buffer
		inc		ecx				// dwI++;
						
		psrad	mm7, 12			// shift back down to 16 bits.

	packssdw	mm7, mm4		// only need one word in mono case.
								// low word are lm2 and lm1
										        
		// above multiplies and shifts are all done with this one pmul. Low two word are only
		// interest in mono case
		pmulhw		mm3, mm7	// lLM1 *= vfVolume;								
								// lLM2 *= vfVolume;
								
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movd	dword ptr[esi-2], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		//shl		esi, 1				// do not shift left since pcWave is array of chars
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		movzx	esi, word ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		pxor	mm7, mm7
								// low four bytes
		movd	mm4, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

								// 8 bytes after unpakc
		punpcklbw	mm7, mm4	// 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits
				
		movq		mm5, mm2	// move volume into mm5
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer

		movd	edx, mm5

		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:		
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfVolume;
    //vfLastVolume[1] = vfVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
#if 0 
	movd	[edx]this.m_vfLastVolume[0], mm2	
	movd	[edx]this.m_vfLastVolume[1], mm2
#endif
	movd	vfLastVolume[0], mm2	
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI);
}
#endif

DWORD CDigitalAudio::Mix8X(short * pBuffer, 
						   DWORD dwLength, 
						   DWORD dwDeltaPeriod,
						   VFRACT vfDeltaLVolume, 
						   VFRACT vfDeltaRVolume,
						   VFRACT vfLastVolume[],
						   PFRACT pfDeltaPitch, 
						   PFRACT pfSampleLength, 
						   PFRACT pfLoopLength)

{
    DWORD dwI;
    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
	//long lM2, lLM2;
    DWORD dwIncDelta = dwDeltaPeriod;
    //VFRACT dwFract1, dwFract2;
    char * pcWave = (char *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];

	VFRACT vfLVolume2 = vfLastVolume[0];
    VFRACT vfRVolume2 = vfLastVolume[1];

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
	dwLength <<= 1;

	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfLVolume
	movd	mm7, vfRVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaLVolume
	movd	mm6, vfDeltaRVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfLVFract += vfDeltaLVolume;
											// vfRVFract += vfDeltaRVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		add		ecx, 2				//dwI += 2;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		//shl		esi, 1			// do not shift left since pcWave is array of chars
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movzx	esi, word ptr[esi]	//lLM1 = pcWave[dwPosition1];

		movd	mm3, esi

		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		//shl		edi, 1			// do not shift left since pcWave is array of chars
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		
					
		movzx	edi, word ptr[edi]	//lLM2 = pcWave[dwPosition2];
		movd	mm6, edi
	
		pxor	mm7, mm7		// zero out mm7 to make 8 bit into 16 bit

								// low 4 bytes bytes in mm3
	punpcklwd	mm3, mm6		// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
		
		add		esi, pBuffer	//
	punpcklbw	mm7, mm3		// bytes in mm7
								// pcWave[dwPos2+1], 0, pcWave[dwPos2], 0, pcWave[dwPos1+1], pcWave[dwPos1], 0 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		

		movq	mm3, mm2		// put left and right volume levels in mm3

		add		eax, ebx		//pfSamplePos += pfPitch;
	packssdw	mm3, mm2		// words in mm3
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		movq	mm5, qword ptr[esi-4]	// Load values from buffer
		add		ecx, 2			// dwI += 2;
						
		psrad	mm7, 12			// shift back down to 16 bits.

		pand	mm7, wordmask	// combine results to get ready to multiply by left and right
		movq	mm6, mm7		// volume levels.
		pslld	mm6, 16			//
		por		mm7, mm6		// words in mm7
								// lM2, lM2, lM1, lM1
										        
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm3, mm7	// lLM1 *= vfLVolume;
								// lM1 *= vfRVolume;
								// lLM2 *= vfLVolume;
								// lM2 *= vfRVolume;
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movq	qword ptr[esi-4], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		//shl		esi, 1				// do not shift left since pcWave is array of chars
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		movzx	esi, word ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

		pxor	mm7, mm7
								// byte in MMX registers
		movd	mm4, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 

		punpcklbw	mm7, mm4	// 0, 0, 0, 0, pcWave[dwPos1+1], 0, pcWave[dwPos1], 0
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits

		pand		mm7, wordmask	// combine results to get ready to multiply by left and right 
		movq		mm6, mm7		// volume levels.
		pslld		mm6, 16			//
		por			mm7, mm6		// words in mm7
									// lM2, lM2, lM1, lM1

		pxor		mm6, mm6

		movq		mm5, mm2	// move volume1 into mm5
								
								// use pack to get 4 volume values together for multiplication.
		packssdw	mm5, mm6    // words in mm7
								// 0, 0, vfRVolume1, vfLVolume1
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer		

/*
		add		word ptr[edi-4], si
        jno		no_oflowl1
		// pBuffer[dwI] = 0x7fff;
		mov		word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
		mov		word ptr[edi-4], 0x8000
no_oflowl1:
		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:
*/
		movd	mm7, dword ptr[edi-4]		
		paddsw	mm7, mm5
		movd	dword ptr[edi-4], mm7
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfLVolume;
    //vfLastVolume[1] = vfRVolume;
	// need to shift volume back down to 12 bits before storing
#if 0
	psrld	mm2, 3
	movd	[edx]this.m_vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	[edx]this.m_vfLastVolume[1], mm2
#endif
	psrld	mm2, 3
	movd	vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI >> 1);
}

#ifdef ORG_MONO_MIXER
DWORD CDigitalAudio::MixMono16X(short * pBuffer, 
								DWORD dwLength,
								DWORD dwDeltaPeriod,
								VFRACT vfDeltaVolume,
							    VFRACT vfLastVolume[],
								PFRACT pfDeltaPitch, 
								PFRACT pfSampleLength, 
								PFRACT pfLoopLength)

{
    DWORD dwI;    
    
    
    DWORD dwIncDelta = dwDeltaPeriod;
    
    short * pcWave = (short*) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfVolume = vfLastVolume[0];
    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
    VFRACT vfVFract = vfVolume << 8;  // Keep high res version around.


	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfVolume
	movd	mm7, vfVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaVolume
	movd	mm6, vfDeltaVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfVFract += vfDeltaVolume;
											// vfVFract += vfDeltaVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		inc		ecx					//dwI++;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		shl		esi, 1			// shift left since pcWave is array of shorts
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movd	mm7, dword ptr[esi]	//lLM1 = pcWave[dwPosition1];
		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		shl		edi, 1			// shift left since pcWave is array of shorts
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		movq	mm3, mm2		// put left and right volume levels in mm3
		
					
		movd	mm6, dword ptr[edi]	//lLM2 = pcWave[dwPosition2];
	packssdw	mm3, mm2		// words in mm7
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		add		esi, pBuffer	//
	punpckldq	mm7, mm6		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		
		add		eax, ebx		//pfSamplePos += pfPitch;
		
		movd	mm5, dword ptr[esi-2]	// Load values from buffer
		inc		ecx				// dwI++;
						
		psrad	mm7, 12			// shift back down to 16 bits.

	packssdw	mm7, mm4		// only need one word in mono case.
								// low word are lm2 and lm1
										        
		// above multiplies and shifts are all done with this one pmul. Low two word are only
		// interest in mono case
		pmulhw		mm3, mm7	// lLM1 *= vfVolume;								
								// lLM2 *= vfVolume;
								
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movd	dword ptr[esi-2], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		shl		esi, 1				// shift left since pcWave is array of shorts
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		mov		esi, dword ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		movd	mm7, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits
				
		movq		mm5, mm2	// move volume into mm5
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer

		movd	edx, mm5

		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:		
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfVolume;
    //vfLastVolume[1] = vfVolume;
	// need to shift volume back down to 12 bits before storing
	psrld	mm2, 3
#if 0
	movd	[edx]this.m_vfLastVolume[0], mm2	
	movd	[edx]this.m_vfLastVolume[1], mm2
#endif
	movd	vfLastVolume[0], mm2	
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI);
}
#endif

DWORD CDigitalAudio::Mix16X(short * pBuffer, 
							DWORD dwLength, 
							DWORD dwDeltaPeriod,
							VFRACT vfDeltaLVolume, 
							VFRACT vfDeltaRVolume,
						    VFRACT vfLastVolume[],
							PFRACT pfDeltaPitch, 
							PFRACT pfSampleLength, 
							PFRACT pfLoopLength)
{
    DWORD dwI;
    //DWORD dwPosition1, dwPosition2;
    //long lM1, lLM1;
	//long lM2, lLM2;
    DWORD dwIncDelta = dwDeltaPeriod;
    //VFRACT dwFract1, dwFract2;
    short * pcWave = (short *) m_pnWave;
    PFRACT pfSamplePos = m_pfLastSample;
    VFRACT vfLVolume = vfLastVolume[0];
    VFRACT vfRVolume = vfLastVolume[1];

	VFRACT vfLVolume2 = vfLastVolume[0];
    VFRACT vfRVolume2 = vfLastVolume[1];

    PFRACT pfPitch = m_pfLastPitch;
    PFRACT pfPFract = pfPitch << 8;
	dwLength <<= 1;

	QWORD	dwFractMASK =	0x000000000FFF0FFF;
	QWORD	dwFractOne  =	0x0000000010001000;	
	QWORD	wordmask	=	0x0000FFFF0000FFFF;
	QWORD	vfDeltaLandRVolume;

_asm{
				
	// vfLVFract and vfRVFract are in mm0
    //VFRACT vfLVFract = vfLVolume1 << 8;  // Keep high res version around.
    //VFRACT vfRVFract = vfRVolume1 << 8;	
	
	movd	mm0, vfLVolume
	movd	mm7, vfRVolume

	// vfDeltaLVolume and vfDeltaRVolume are put in mm1 so that they can be stored in vfDeltaLandRVolume
	movd	mm1, vfDeltaLVolume
	movd	mm6, vfDeltaRVolume

  punpckldq mm1, mm6
	
	// dwI = 0
	mov		ecx, 0
	movq	vfDeltaLandRVolume, mm1


	movq	mm1, dwFractOne
	movq	mm4, dwFractMASK
	
	mov		eax, pfSamplePos


  punpckldq mm0, mm7
  	mov		ebx, pfPitch

	pslld	mm0, 8
	mov		edx, dwIncDelta

	movq	mm2, mm0		// vfLVolume and vfRVolume in mm2
							// need to be set before first pass.
 	
	// *1 I shift by 5 so that volume is a 15 bit value instead of a 12 bit value
	psrld	mm2, 5	
	
    //for (dwI = 0; dwI < dwLength; )
    //{
mainloop:
	cmp		ecx, dwLength
	jae		done

		
		
		cmp		eax, pfSampleLength	//if (pfSamplePos >= pfSampleLength)
		jb		NotPastEndOfSample1	//{	
				        
		cmp		pfLoopLength, 0		//if (!pfLoopLength)
			
		je		done				// break;
			
		sub		eax, pfLoopLength	// else pfSamplePos -= pfLoopLength;
	
NotPastEndOfSample1:				//}
					
		mov		esi, eax			// dwPosition1 = pfSamplePos;
		add		eax, ebx			// pfSamplePos += pfPitch;		
				
		sub		edx, 2				// dwIncDelta-=2;				        		        
		jnz		DontIncreaseValues1	//if (!dwIncDelta) {

			// Since edx was use for dwIncDelta and now its zero, we can use if for a temporary
			// for a bit. All code that TestLVol and TestRVol is doing is zeroing out the volume
			// if it goes below zero.
						
			paddd	mm0, vfDeltaLandRVolume	// vfLVFract += vfDeltaLVolume;
											// vfRVFract += vfDeltaRVolume;
			pxor	mm5, mm5				// TestLVol = 0; TestRVol = 0;

			
			mov		edx, pfPFract			// Temp = pfPFract;
			pcmpgtd	mm5, mm0			// if (TestLVol > vfLVFract) TestLVol = 0xffffffff;
										// if (TestRVol > vfRVFract) TestRVol = 0xffffffff;

			add		edx, pfDeltaPitch	// Temp += pfDeltaPitch;
			pandn	mm5, mm0			// TestLVol = vfLVFract & (~TestLVol);
										// TestRVol = vfRVFract & (~TestRVol);

			mov		pfPFract, edx		// pfPFract = Temp;
			movq	mm2, mm5			// vfLVolume = TestLVol;
										// vfRVolume = TestRVol;
			

			shr		edx, 8				// Temp = Temp >> 8;
			psrld	mm2, 5				// vfLVolume = vfLVolume >> 5;
										// vfRVolume = vfRVolume >> 5;						
			
			mov		ebx, edx			// pfPitch = Temp;
			mov		edx, dwDeltaPeriod	//dwIncDelta = dwDeltaPeriod;			
			
        //}
DontIncreaseValues1:

		movd	mm6, esi			// dwFract1 = dwPosition1;
		movq	mm5, mm1			// words in mm5 = 0, 0, 0x1000, 0x1000		
		
		shr		esi, 12				// dwPosition1 = dwPosition1 >> 12;		
		add		ecx, 2				//dwI += 2;
						
		// if ( dwI < dwLength) break;						
		cmp		ecx, dwLength
		jae		StoreOne
		
		//if (pfSamplePos >= pfSampleLength)
	    //{	
		cmp		eax, pfSampleLength
		jb		NotPastEndOfSample2

			// Original if in C was not negated
	        //if (!pfLoopLength)		    
			cmp		pfLoopLength, 0
			//break;			
			je		StoreOne
			//else
			//pfSamplePos -= pfLoopLength;
			sub		eax, pfLoopLength
	    //}
NotPastEndOfSample2:

		shl		esi, 1			// shift left since pcWave is array of shorts
		mov		edi, eax		// dwPosition2 = pfSamplePos;

		add		esi, pcWave		// Put address of pcWave[dwPosition1] in esi			
		movd	mm7, eax		// dwFract2 = pfSamplePos;

		shr		edi, 12			// dwPosition2 = dwPosition2 >> 12;
	punpcklwd	mm6, mm7		// combine dwFract Values. Words in mm6 after unpack are
								// 0, 0, dwFract2, dwFract1
								
		pand	mm6, mm4		// dwFract2 &= 0xfff; dwFract1 &= 0xfff;
		
		movd	mm7, dword ptr[esi]	//lLM1 = pcWave[dwPosition1];
		psubw	mm5, mm6		// 0, 0, 0x1000 - dwFract2, 0x1000 - dwFract1

		shl		edi, 1			// shift left since pcWave is array of shorts
	punpcklwd	mm5, mm6		// dwFract2, 0x1000 - dwFract2, dwFract1, 0x1000 - dwFract1
								
		add		edi, pcWave		// Put address of pcWave[dwPosition2] in edi
		mov		esi, ecx		// Temp = dWI;
             																									
		shl		esi, 1			// Temp = Temp << 1;								
		movq	mm3, mm2		// put left and right volume levels in mm3
		
					
		movd	mm6, dword ptr[edi]	//lLM2 = pcWave[dwPosition2];
	packssdw	mm3, mm2		// words in mm7
								// vfRVolume2, vfLVolume2, vfRVolume1, vfLVolume1
		
		add		esi, pBuffer	//
	punpckldq	mm7, mm6		// low four bytes bytes in 
								// pcWave[dwPos2+1], pcWave[dwPos2], pcWave[dwPos1+1], pcWave[dwPos1] 
												
		pmaddwd	mm7, mm5		// high dword = lM2 =
								//(pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2))
								// low dword = lM1 =
								//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))		
		add		eax, ebx		//pfSamplePos += pfPitch;
		
		movq	mm5, qword ptr[esi-4]	// Load values from buffer
		add		ecx, 2			// dwI += 2;
						
		psrad	mm7, 12			// shift back down to 16 bits.

		pand	mm7, wordmask	// combine results to get ready to multiply by left and right
		movq	mm6, mm7		// volume levels.
		pslld	mm6, 16			//
		por		mm7, mm6		// words in mm7
								// lM2, lM2, lM1, lM1
										        
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm3, mm7	// lLM1 *= vfLVolume;
								// lM1 *= vfRVolume;
								// lLM2 *= vfLVolume;
								// lM2 *= vfRVolume;
								
		paddsw	mm5, mm3				// Add values to buffer with saturation
		movq	qword ptr[esi-4], mm5	// Store values back into buffer.
								
    // }
	jmp		mainloop

	// Need to write only one.
	//if (dwI < dwLength)
	//{
StoreOne:		
#if 1
		// Linearly interpolate between points and store only one value.
		// combine dwFract Values.
	
		// Make mm7 zero for unpacking

		shl		esi, 1				// shift left since pcWave is array of shorts
		add		esi, pcWave			// Put address of pcWave[dwPosition1] in esi
		pxor	mm7, mm7
				
		//lLM1 = pcWave[dwPosition1];
		mov		esi, dword ptr[esi]
		
		// Doing AND that was not done for dwFract1 and dwFract2
		pand	mm6, mm4

								// words in MMX register after operation is complete.		
		psubw	mm5, mm6		// 0, 0, 0x1000 - 0, 0x1000 - dwFract1
	punpcklwd	mm5, mm6		// 0 , 0x1000 - 0, dwFract1, 0x1000 - dwFract1
				
		// put values of pcWave into MMX registers.  They are read into a regular register so
		// that the routine does not read past the end of the buffer otherwise, it could read
		// directly into the MMX registers.

								// words in MMX registers
		movd	mm7, esi		// 0, 0, pcWave[dwPos1+1], pcWave[dwPos1] 
	  	    	
		// *2 pmadd efficent code.
		//lM2 = (pcWave[dwPosition2 + 1] * dwFract2 + pcWave[dwPosition2]*(0x1000-dwFract2)) >> 12;
		//lM1 = (pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1)) >> 12;

		pmaddwd		mm7, mm5// low dword = lM1 =
							//(pcWave[dwPosition1 + 1] * dwFract1 + pcWave[dwPosition1]*(0x1000-dwFract1))
		
		psrad		mm7, 12			// shift back down to 16 bits

		pand		mm7, wordmask	// combine results to get ready to multiply by left and right 
		movq		mm6, mm7		// volume levels.
		pslld		mm6, 16			//
		por			mm7, mm6		// words in mm7
									// lM2, lM2, lM1, lM1

		pxor		mm6, mm6

		movq		mm5, mm2	// move volume1 into mm5
								
								// use pack to get 4 volume values together for multiplication.
		packssdw	mm5, mm6    // words in mm7
								// 0, 0, vfRVolume1, vfLVolume1
/*		
		// Set lLM to be same as lM
        lLM1 = lM1;

        lLM1 *= vfLVolume1;
        lLM1 >>= 5;         // Signal bumps up to 15 bits.
        lM1 *= vfRVolume1;
        lM1 >>= 5;

		// Set lLM to be same as lM
        lLM2 = lM2;

        lLM2 *= vfLVolume2;
        lLM2 >>= 5;         // Signal bumps up to 15 bits.
        lM2 *= vfRVolume2;
        lM2 >>= 5;
*/
		// above multiplies and shifts are all done with this one pmul
		pmulhw		mm5, mm7
		
		// calculate buffer location.
		mov		edi, ecx
		shl		edi, 1
		add		edi, pBuffer		

/*
		add		word ptr[edi-4], si
        jno		no_oflowl1
		// pBuffer[dwI] = 0x7fff;
		mov		word ptr[edi-4], 0x7fff
        js  no_oflowl1
        //pBuffer[dwI] = (short) 0x8000;
		mov		word ptr[edi-4], 0x8000
no_oflowl1:
		//pBuffer[dwI+1] += (short) lM1;
		add		word ptr[edi-2], dx
        jno no_oflowr1
        //pBuffer[dwI+1] = 0x7fff;
		mov		word ptr[edi-2], 0x7fff
        js  no_oflowr1
        //pBuffer[dwI+1] = (short) 0x8000;
		mov		word ptr[edi-2], 0x8000
no_oflowr1:
*/
		movd	mm7, dword ptr[edi-4]		
		paddsw	mm7, mm5
		movd	dword ptr[edi-4], mm7
	//}
#endif 
done:

	mov		edx, this                       // get address of class object

    //vfLastVolume[0] = vfLVolume;
    //vfLastVolume[1] = vfRVolume;
	// need to shift volume back down to 12 bits before storing
#if 0
	psrld	mm2, 3
	movd	[edx]this.vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	[edx]this.vfLastVolume[1], mm2
#endif 
	psrld	mm2, 3
	movd	vfLastVolume[0], mm2
	psrlq	mm2, 32
	movd	vfLastVolume[1], mm2
	
    //m_pfLastPitch = pfPitch;
	mov		[edx]this.m_pfLastPitch, ebx
	    
	//m_pfLastSample = pfSamplePos;
	mov		[edx]this.m_pfLastSample, eax
		
	// put value back into dwI to be returned. This could just be passed back in eax I think. 	
	mov		dwI, ecx
	emms	
} // ASM block
    return (dwI >> 1);
}

static BOOL MMXDisabled()
{
#ifdef XBOX
    return FALSE;
#else // XBOX
    ULONG ulValue = FALSE;

    if (!GetRegValueDword(
            TEXT("Software\\Microsoft\\DirectMusic"),
            TEXT("MMXDisabled"),
            &ulValue))
    {
        return FALSE;
    }

    return (BOOL)ulValue;
#endif // XBOX
}

#define CPU_ID _asm _emit 0x0f _asm _emit 0xa2  

BOOL MultiMediaInstructionsSupported()
{
    static  BOOL bMultiMediaInstructionsSupported = FALSE;
    static  BOOL bFlagNotSetYet = TRUE;
    
    // No need to keep interogating the CPU after it has been checked the first time
    if (bFlagNotSetYet)
    {
        bFlagNotSetYet = FALSE;         // Don't repeat the check for each call
		if (!MMXDisabled())
		{
			_asm 
			{
				pushfd                      // Store original EFLAGS on stack
				pop     eax                 // Get original EFLAGS in EAX
				mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
				xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
				push    eax                 // Save new EFLAGS value on stack
				popfd                       // Replace current EFLAGS value
				pushfd                      // Store new EFLAGS on stack
				pop     eax                 // Get new EFLAGS in EAX
				xor     eax, ecx            // Can we toggle ID bit?
				jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
				mov     eax, 1              // Set EAX to tell the CPUID instruction what to return
				push	ebx
				CPU_ID                      // Get family/model/stepping/features
				pop		ebx
				test    edx, 0x00800000L    // Check if mmx technology available
				jz      Done                // Jump if no
			}
			// Tests have passed, this machine supports the Intel MultiMedia Instruction Set!
			bMultiMediaInstructionsSupported = TRUE;
Done:
			NULL;
		}
    }

#if DBG
	if ( bMultiMediaInstructionsSupported )
	{
		Trace(2,"MMX - Detected, Enabling MMX mixing\n\r");
	}
	else
	{
		Trace(2,"MMX - Not Detected\n\r");
	}
#endif

    return (bMultiMediaInstructionsSupported);
}    

#endif // XMIX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\alist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.h
//
#ifndef __ALIST_H__
#define __ALIST_H__

#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#endif // XBOX

class AListItem
{
public:
    AListItem() { m_pNext=NULL; };
    AListItem *GetNext() const {return m_pNext;};
    void SetNext(AListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    AListItem* Cat(AListItem* pItem);
    AListItem* AddTail(AListItem* pItem) {return Cat(pItem);};
    AListItem* Remove(AListItem* pItem);
    AListItem* GetPrev(AListItem *pItem) const;
    AListItem* GetItem(LONG index);

protected:
    AListItem *m_pNext;
};

class AList
{
public:
    AList() {m_pHead=NULL;};
    AListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    AListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(AListItem *pItem,AListItem *pInsert);
    void Cat(AListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(AList *pList)
        {
//            assert(pList!=NULL);
            if (pList)
            {
                m_pHead=m_pHead->Cat(pList->GetHead());
            }
        };
    void AddHead(AListItem *pItem)
        {
            if (pItem!=NULL)
            {
                pItem->SetNext(m_pHead);
                m_pHead=pItem;
            }
        };
    void AddTail(AListItem *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(AListItem *pItem) 
        {
            if (pItem != NULL)
            {
                m_pHead=m_pHead->Remove(pItem);
            }
        };
    AListItem *GetPrev(AListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    AListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    BOOL IsMember(AListItem *pItem);
    AListItem *RemoveHead(void)
        {
            AListItem *li;
            li = m_pHead;
            if(m_pHead)
            {
                m_pHead = m_pHead->GetNext();
                li->SetNext(NULL);
            }
            return li;
        }
    void Reverse();

protected:
    AListItem *m_pHead;
};

#endif // __ALIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\private.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
//
//
//
#ifndef _PRIVATE
#define _PRIVATE_

NTSTATUS CreateMiniportDmSynth
(
    OUT PUNKNOWN *  Unknown,
    IN  PUNKNOWN    UnknownOuter OPTIONAL,
    IN  POOL_TYPE   PoolType
);


#include <stdunk.h>

class CDmSynthStream;

class CMiniportDmSynth : public IMiniportSynthesizer, public CUnknown
{
friend class CDmSynthStream;

public:
    // IUnknown
    //
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CMiniportDmSynth);

    ~CMiniportDmSynth();

    // IMiniport
    //
    STDMETHOD(GetDescription)
    (   THIS_
        OUT     PPCFILTER_DESCRIPTOR *  OutFilterDescriptor
    );

    STDMETHOD(DataRangeIntersection)
    (   THIS_
        IN      ULONG           PinId,
        IN      PKSDATARANGE    DataRange,
        IN      PKSDATARANGE    MatchingDataRange,
        IN      ULONG           OutputBufferLength,
        OUT     PVOID           ResultantFormat    OPTIONAL,
        OUT     PULONG          ResultantFormatLength
    );

    // IMiniportDmSynth
    //
    STDMETHOD(Init)
    (   THIS_
        IN      PUNKNOWN        UnknownNotUsed  OPTIONAL,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTSYNTHESIZER Port,
        OUT     PSERVICEGROUP * ServiceGroup
    );  
      
    STDMETHOD(NewStream)
    (   THIS_
        OUT     PMINIPORTSYNTHESIZERSTREAM *   Stream,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   Pin,
        IN      BOOLEAN                 Capture,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP *         ServiceGroup
    );

    STDMETHOD_(void, Service)
    (   void
    );

private:
    PPORTSYNTHESIZER        Port;
    CDmSynthStream *        Stream;    
};


class CDmSynthStream : public IMiniportSynthesizerStream, public CUnknown
{
public:
    // IUnknown
    //
    DECLARE_STD_UNKNOWN();
    DEFINE_STD_CONSTRUCTOR(CDmSynthStream);
    ~CDmSynthStream();
    NTSTATUS Init(CMiniportDmSynth *Miniport);

    // IMxfFilter
    //
    STDMETHOD(ConnectOutput)
    (
        PMXFFILTER ConnectionPoint
    );
    
    STDMETHOD(DisconnectOutput)
    (
        PMXFFILTER ConnectionPoint
    );

    STDMETHOD(PutMessage)
    (   THIS_
        IN  PDMUS_KERNEL_EVENT  Event
    ); 

    // IMiniportSynthStream
    //
    STDMETHOD(SetState)
    (   THIS_
        IN      KSSTATE     State
    );

    // Class
    //
    STDMETHOD(HandlePortParams)
    (   THIS_
        IN      PPCPROPERTY_REQUEST pRequest
    );

public:
    CSynth *                Synth;

private:
    CMiniportDmSynth *      Miniport;
    CSysLink *              Sink;
    SYNTH_PORTPARAMS        PortParams;
};

typedef CDmSynthStream *PDMSYNTHSTREAM;

#endif // _PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\critsec.h ===
#ifdef XBOX
extern long g_cComponent;
#define IncrementDLLCount() 
#define DecrementDLLCount()
#else
extern long g_cComponent;
#define IncrementDLLCount() InterlockedIncrement(&g_cComponent)
#define DecrementDLLCount() InterlockedDecrement(&g_cComponent)
extern bool g_fInitCS;
extern CRITICAL_SECTION g_CritSec;
#endif


#ifdef XBOX
#define ENTER_CRITICAL_SECTION(cr) EnterCriticalSection(cr);	
#define LEAVE_CRITICAL_SECTION(cr) LeaveCriticalSection(cr); 
#define INITIALIZE_CRITICAL_SECTION(cr) InitializeCriticalSection(cr);
#define DELETE_CRITICAL_SECTION(cr) DeleteCriticalSection(cr);
extern  CRITICAL_SECTION		g_APICriticalSection;	
extern  long					g_lCritSecCount;
#ifdef DBG
extern "C" ULONG __cdecl DbgPrint(PCH Format, ...);
#define ENTER_API_CRITICAL_SECTION   /*EnterCriticalSection(&g_APICriticalSection);	*/
#define LEAVE_API_CRITICAL_SECTION   /*LeaveCriticalSection(&g_APICriticalSection); */
#else
#define ENTER_API_CRITICAL_SECTION   /*EnterCriticalSection(&g_APICriticalSection)  */
#define LEAVE_API_CRITICAL_SECTION   /*LeaveCriticalSection(&g_APICriticalSection)  */
#endif
#else
#define ENTER_CRITICAL_SECTION(cr) EnterCriticalSection(cr)
#define LEAVE_CRITICAL_SECTION(cr) LeaveCriticalSection(cr)
#define INITIALIZE_CRITICAL_SECTION(cr) InitializeCriticalSection(cr);
#define DELETE_CRITICAL_SECTION(cr) DeleteCriticalSection(cr);
#define ENTER_GLOBAL_CRITICAL_SECTION   
#define LEAVE_GLOBAL_CRITICAL_SECTION   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\synth.h ===
//      Synth.h
//      Copyright (c) 1996-1999 Microsoft Corporation
//

/*  For internal representation, volume is stored in Volume Cents, 
    where each increment represents 1/100 of a dB.
    Pitch is stored in Pitch Cents, where each increment
    represents 1/100 of a semitone.
*/ 

#ifndef __SYNTH_H__
#define __SYNTH_H__

#pragma warning(disable:4296)

#include "clist.h"
#include "dmdls.h"
#include "dls2.h"
//#include "dsound.h"   
#include "dmusicc.h"
#include "dsoundsequencer.h"
#include "..\shared\dmstrm.h"
#include "..\shared\debug.h"
#include "..\shared\xsoundp.h"

#ifdef DBG
extern DWORD sdwDebugLevel;
#endif

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE

// controller numbers
#define CC_BANKSELECTH  0x00
#define CC_BANKSELECTL  0x20

#define CC_MODWHEEL     0x01
#define CC_VOLUME       0x07
#define CC_PAN          0x0A
#define CC_EXPRESSION   0x0B
#define CC_SUSTAIN      0x40
#define CC_CUTOFFFREQ   0x4A
#define CC_REVERB       0x5B
#define CC_CHORUS       0x5D
#define CC_MIXBINVOLUME 0x66
#define CC_ALLSOUNDSOFF 0x78
#define CC_RESETALL     0x79
#define CC_ALLNOTESOFF  0x7B
#define CC_MONOMODE     0x7E
#define CC_POLYMODE     0x7F

// rpn controllers
#define CC_DATAENTRYMSB 0x06
#define CC_DATAENTRYLSB 0x26
#define CC_NRPN_LSB     0x62
#define CC_NRPN_MSB     0x63
#define CC_RPN_LSB      0x64
#define CC_RPN_MSB      0x65

// registered parameter numbers
#define RPN_PITCHBEND   0x00
#define RPN_FINETUNE    0x01
#define RPN_COARSETUNE  0x02

/*  Sample format and Sample playback flags are organized
    together because together they determine which 
    mix loop to use.
*/

#define SFORMAT_16              1       // Sixteen bit sample.
#define SFORMAT_8               2       // Eight bit sample.
#define SFORMAT_ADPCM           4       // Four bit sample.
#define SPLAY_MMX               0x10    // Use MMX processor (16 bit only).
#define SPLAY_INTERLEAVED       0x40    // Interleave Buffer 
#define SPLAY_FILTERED          0x80    // Non-trivial filter coeff's


/*  Output buffer format flags, defines whether the buffers being
    played are multi-buffer, interleave or just plain mono
*/
#define BUFFERFLAG_MONO         0x00000000
#define BUFFERFLAG_INTERLEAVED  0x00000001
#define BUFFERFLAG_MULTIBUFFER  0x00000002


typedef long    PREL;   // Pitch cents, for relative pitch.
typedef short   PRELS;  // Pitch cents, in storage form.
typedef long    VREL;   // Volume cents, for relative volume.
typedef short   VRELS;  // Volume cents, in storage form.
typedef long    TREL;   // Time cents, for relative time
typedef short   TRELS;  // Time Cents, in storage form.
typedef LONGLONG    STIME;  // Time value, in samples.
typedef long    MTIME;  // Time value, in milliseconds.
typedef long    PFRACT; // Pitch increment, where upper 20 bits are
                        // the index and the lower 12 are the fractional
                        // component.
typedef long    VFRACT; // Volume, where lower 12 bits are the fraction.

typedef long    TCENT;
typedef short   SPERCENT;

#define COEFF_UNITY 0x40000000  // 1.0 multiplier as a 2.30 number
typedef unsigned long COEFF;    // 2.30 fixed point filter coefficient
typedef long COEFFDELTA;        // 2.30 fixed point filter coefficient delta value

#define FILTER_PARMS_DIM_Q  16      // the number of different resonances in the filter parameter table (rows)
#define FILTER_PARMS_DIM_FC 89      // the number of different cutoff frequencies in the filter parameter table (cols)
#define FILTER_FREQ_RANGE   10688   // the difference in pitch cents between the sample rate of the filter design and the 

#define MAX_VOLUME      0       // No attenuation and no amplification 
#define MIN_VOLUME     -9600    // Below 96 db down is considered off.
#define PERCEIVED_MIN_VOLUME   -8000   // But, we cheat.
#define SAMPLE_RATE_22  22050   // 22 kHz is the standard rate.
#define SAMPLE_RATE_44  44100   // 44 kHz is the high quality rate.
#define SAMPLE_RATE_11  11025   // 11 kHz should not be allowed!
#define STEREO_ON       1
#define STEREO_OFF      0

#define MAX_DAUD_CHAN   8       // Maximum outputs for one voice. 

#define FORCEBOUNDS(data,min,max) {if (data < min) data = min; else if (data > max) data = max;}
#define CLAMP_VOLUME(a) {if (a < DSBVOLUME_MIN) a = DSBVOLUME_MIN; else if (a > DSBVOLUME_MAX) a = DSBVOLUME_MAX;}

class CControlLogic;

/*
>>>>>>>>> comment 
*/
#ifdef XBOX
class CBusIds
{
public:
    CBusIds() 
    {
        m_bControllers[0] = 0;
        m_dwMixBins = 0;
        m_pBuffer = NULL;
    }

    CBusIds(const CBusIds& other)
    {
        memcpy(m_bControllers,other.m_bControllers,8);
        m_dwMixBins = other.m_dwMixBins;
        m_pBuffer = other.m_pBuffer;
        if(m_pBuffer)
        {
            m_pBuffer->AddRef();
        }
    }

    ~CBusIds() 
    {
        if (m_pBuffer)
        {
            m_pBuffer->Release();
        }
    }

    CBusIds& operator=(const CBusIds& other)
    {
        if(this != &other)
        {
            memcpy(m_bControllers,other.m_bControllers,8);
            m_dwMixBins = other.m_dwMixBins;
            if(m_pBuffer)
            {
                m_pBuffer->Release();
            }
            m_pBuffer = other.m_pBuffer;
            if(m_pBuffer)
            {
                m_pBuffer->AddRef();
            }
        }
        return *this;
    }

    void AssignOutput(IDirectSoundBuffer *pBuffer,DWORD dwMixBins,BYTE *pbControllers)
    {
        m_dwMixBins = dwMixBins;
        if (pbControllers)
        {
            memcpy(m_bControllers,pbControllers,8);
        }
        else m_bControllers[0] = 0;
        if (m_pBuffer)
        {
            m_pBuffer->Release();
        }
        m_pBuffer = pBuffer;
        if (m_pBuffer)
        {
            m_pBuffer->AddRef();
        }
    }

    bool HasBuffer() { return m_pBuffer != NULL; }

    IDirectSoundBuffer* GetBuffer() 
    {
        if(m_pBuffer)
        {
            m_pBuffer->AddRef();
        }
        return m_pBuffer;
    }

    DWORD                   m_dwMixBins;      // Which of the 32 mixbins this sends to.
    BYTE                    m_bControllers[8];// Which controllers for which mixbins on multi-mixbin buffer.

private:
    IDirectSoundBuffer *    m_pBuffer;      // Pointer to DSound buffer.
};
#else
class CBusIds
{
public:
    CBusIds();
    ~CBusIds();

    HRESULT     Initialize();
    HRESULT     AssignBuses(LPDWORD pdwBusIds, DWORD dwBusCount);

public:
    DWORD       m_dwBusCount;               // Number of Bus Id's
    DWORD       m_dwBusIds[MAX_DAUD_CHAN];  // Array of bus IDs 
};
#endif
/*  CSourceLFO is the file format definition of the LFO in an
    instrument. This is used to represent an LFO as part of
    a specific articulation set within an instrument that
    has been loaded from disk. Once the instrument is chosen
    to play a note, this is also copied into the CVoice
    object.
*/

class CSourceLFO
{
public:
                CSourceLFO();
    void        Init(DWORD dwMode);
//    void        SetSampleRate(long lDirection);
    void        Verify();           // Verifies that the data is valid.
//    PFRACT      m_pfFrequency;      // Frequency, in increments through the sine table.
//    STIME       m_stDelay;          // How long to delay in sample units.
    VRELS       m_vrMWVolumeScale;  // Scaling of volume LFO by Mod Wheel.
    PRELS       m_prMWPitchScale;   // Scaling of pitch LFO by Mod Wheel.
    VRELS       m_vrVolumeScale;    // Scaling of straight volume signal from LFO.
    PRELS       m_prPitchScale;     // Scaling of straight pitch signal from LFO.

    /* DirectX8 members */
    PRELS       m_prCPPitchScale;   // Scaling of pitch signal from channel pressure. 
    VRELS       m_vrCPVolumeScale;  // Scaling of volume signal from channel pressure.
//>>>>>>>> comments 
    PRELS       m_prCutoffScale;    // Scaling of Cutoff freq >>>>>> 
    PRELS       m_prMWCutoffScale;  // Scaling of Cutoff freq mod wheel
    PRELS       m_prCPCutoffScale;  // Scaling of Cutoff freq channel pressure
    DSLFODESC   m_Registers;
};

/*  CSourceEG is the file format definition of an Envelope
    generator in an instrument.
*/

class CSourceEG
{
public:
                CSourceEG();
    void        Init(DWORD dwEg);
    void        Verify();           // Verifies valid data.
//    STIME       m_stAttack;         // Attack rate.
//    STIME       m_stDecay;          // Decay rate.
//    STIME       m_stRelease;        // Release rate.
    TRELS       m_trVelAttackScale; // Scaling of attack by note velocity.
    TRELS       m_trKeyDecayScale;  // Scaling of decay by note value.
//    SPERCENT    m_pcSustain;        // Sustain level.
//    short       m_sScale;           // Scaling of entire signal.

    /* DLS2 */
//    STIME       m_stDelay;          // Delay rate.
//    STIME       m_stHold;           // Hold rate.
    TRELS       m_trKeyHoldScale;   // Scaling of Hold by note value.
//>>>>>>>> comments 
    PRELS       m_prCutoffScale;    // Scaling of Cutoff feq >>>>>>

    DSENVELOPEDESC m_Registers;     // Envelope descriptor for hardware.
};

//>>>>>>>> comments 

class CSourceFilter
{
public:
                CSourceFilter();
    void        Init();
    void        Verify();

//    PRELS       m_prSampleRate;     // Sample rate in cents
    PRELS       m_prCutoff;         // Cutoff Frequency in absolute pitch
//    PRELS       m_prCutoffSRAdjust; // Cutoff Frequency adjusted to the sampel rate
    VRELS       m_vrQ;              // Resonance
//    DWORD       m_iQIndex;          // Q index          
    PRELS       m_prVelScale;       // Scale by key velocity
    PRELS       m_prKeyScale;       // Scaling by note value.
};

/*  CSourceArticulation is the file format definition of
    a complete articulation set: the LFO and two
    envelope generators.
    Since several regions within one Instrument can 
    share one articulation, a counter is used to keep
    track of the usage.
*/

class CSourceArticulation

{
public:
                CSourceArticulation();
    HRESULT     Load(CRiffParser *pParser);
    HRESULT     Download(DMUS_DOWNLOADINFO * pInfo, 
                    void * pvOffsetTable[], DWORD dwIndex, 
                    DWORD dwSampleRate, BOOL fNewFormat);
#ifdef DDUMP
    void        Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    void        Init(BOOL fWave);
    void        Verify();           // Verifies valid data.
    void        AddRef();
    void        Release();
    CSourceEG   m_PitchEG;          // Pitch envelope.
    CSourceEG   m_VolumeEG;         // Volume envelope.
    CSourceLFO  m_LFO;              // Low frequency oscillator.
//    DWORD       m_dwSampleRate;
    WORD        m_wUsageCount;      // Keeps track of how many times in use.
    short       m_sDefaultPan;      // default pan (for drums)

    /* DLS2 */
    CSourceLFO  m_LFO2;             // Vibrato
    CSourceFilter m_Filter;         // Low pass filter
};

/*  Since multiple regions may reference
    the same Wave, a reference count is maintained to
    keep track of how many regions are using the sample.
*/

class CWave : public CListItem
{
public:
                    CWave();
                    ~CWave();
#ifdef DDUMP
    void            Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    HRESULT         Load(CRiffParser *pParser);
    void            Verify();           // Verifies that the data is valid.
    void            Release();          // Remove reference.
    void            AddRef();           // Add reference.
    void            PlayOn();           // Increment play count.
    void            PlayOff();          // Decrement play count.
    BOOL            IsPlaying();        // Is currently playing?
    CWave *         GetNext() {return(CWave *)CListItem::GetNext();};
    DWORD           m_dwSampleLength;   // Length of sample.
    DWORD           m_dwSampleDataSize; // Size in bytes.
    DWORD           m_dwSampleRate;
    HRESULT ( CALLBACK *m_lpFreeHandle)(HANDLE,HANDLE);
    XBOXADPCMWAVEFORMAT m_WaveFormat;   // Wave format from file.
    HANDLE          m_hUserData;        // Used to notify app when wave released.
    short *         m_pnWave;
    DWORD           m_dwID;             // ID for matching wave with regions.
    WORD            m_wUsageCount;      // Keeps track of how many times in use.
    WORD            m_wPlayCount;       // Wave is currently being played.
    BYTE            m_bSampleType;

    /* DirectX 8 members */
    BYTE            m_bStream;          // This wave is used as a streaming buffer
    BYTE            m_bActive;          // This buffer is currently be used to play out of
    BYTE            m_bValid;           // Indicates data in the buffer is valid 
    BYTE            m_bLastSampleInit;  // Indicates the the buffers last sample has been initialize
};


class CWavePool : public CList
{
public:
    CWave *         GetHead() {return (CWave *)CList::GetHead();};
    CWave *         GetItem(DWORD dwID) {return (CWave *)CList::GetItem((LONG)dwID);};
    CWave *         RemoveHead() {return (CWave *)CList::RemoveHead();};
    void            AddTail(CWave *pItem) {CList::AddTail(pItem);};
};

// Private interface for getting the length of a wave
interface IPrivateWave : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE GetLength(REFERENCE_TIME *prtLength,
        DWORD *dwLoopStart, DWORD *dwLoopEnd) =0;
    virtual HRESULT STDMETHODCALLTYPE SetWaveParams(REFERENCE_TIME rtReadAhead,
        DWORD dwFlags) =0;
};

DEFINE_GUID(IID_IPrivateWave, 0xce6ae366, 0x9d61, 0x420a, 0xad, 0x53, 0xe5, 0xe5, 0xf6, 0xa8, 0x4a, 0xe4);
DEFINE_GUID(IID_CSourceWave,0xf94831cf, 0x6b90, 0x4138, 0xa9, 0xae, 0xb6, 0xb3, 0xa1, 0x63, 0xbb, 0x1);

// Flags for SetWaveBehavior()

#define DSOUND_WAVEF_ONESHOT        1           /* The wave will be played as a one shot */
#define DSOUND_WAVEF_PORT           2           /* The wave will be played via a DMusic port. */
#define DSOUND_WAVEF_SINK           4           /* The wave will be played via a streamed sink interface. */
#define DSOUND_WAVEF_CREATEMASK     0x00000001  /*  Currently only ONESHOT is define for CreateSource  */

// Source wave for Wave object loaded directly from a file (as opposed to member of DLS collection.)

class CSourceWave : CMemTrack,
    public IDirectSoundWave,    // Standard interface.
    public IPersistStream,      // For file io
    public IDirectMusicObject,  // For DirectMusic loader
    public IPrivateWave         // For GetLength
{
friend class CVoice;
friend class CControlLogic;
public:
    CSourceWave();
    ~CSourceWave();

    // IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectSoundWave
    STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    STDMETHODIMP CreateSource(IDirectSoundSource **ppSource, LPWAVEFORMATEX pwfx, DWORD dwFlags);
    STDMETHODIMP GetStreamingParms(LPDWORD pdwFlags, LPREFERENCE_TIME prtReadahread);

    // IPersist functions (base class for IPersistStream)
    STDMETHODIMP GetClassID( CLSID* pClsId );

    // IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

    // IDirectMusicObject 
    STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    // IPrivateWave
    STDMETHODIMP GetLength(REFERENCE_TIME *prtLength,
        DWORD *dwLoopStart, DWORD *dwLoopEnd);
    STDMETHODIMP SetWaveParams(REFERENCE_TIME rtReadAhead,
        DWORD dwFlags);
    

private:
    
    // Internal methods.
    HRESULT             Load(CRiffParser *pParser);
    HRESULT             Read(DWORD dwStartPosition, BYTE *pbData, DWORD dwLength); 

    BYTE                m_bActive;
    CRITICAL_SECTION    m_CriticalSection;      // Used to ensure thread safe
    REFERENCE_TIME      m_rtReadAheadTime;      // Readahead for streaming.
    DWORD               m_fdwFlags;             // Various flags, including whether this is a one-shot.
    long                m_cRef;                 // COM reference counter.
    IStream *           m_pStream;              // IStream pointer which is connected to IPersistStream
    XBOXADPCMWAVEFORMAT m_WaveFormat;           // File's format
    CSourceArticulation m_Articulation;         // For articulation embedded in wave file.
    short *             m_pnWave;               // Wave data.
    DWORD               m_dwSampleDataOffset;   // Start point for wave data in stream.
    DWORD               m_dwSampleDataSize;     // Raw size of wave data.
    DWORD               m_dwSampleCount;        // Total number of sample.
    DWORD               m_dwLoopStart; 
    DWORD               m_dwLoopEnd;
    DWORD               m_dwRepeatCount;
    CInfo               m_Info;
};


/*  The CSourceSample class describes one sample in an
    instrument. The sample is referenced by a CSourceRegion
    structure. 
*/
class Collection;

class CSourceSample
{
public:
                CSourceSample();
                ~CSourceSample();
    BOOL        CopyFromWave();
    void        Verify();           // Verifies that the data is valid.
    CWave *     m_pWave;            // Wave in pool.
    DWORD       m_dwLoopStart;      // Index of start of loop.
    DWORD       m_dwLoopEnd;        // Index of end of loop.
    DWORD       m_dwSampleLength;   // Length of sample.
    DWORD       m_dwSampleDataSize; // Size of sample date.
    DWORD       m_dwSampleRate;     // Sample rate of recording.
    PRELS       m_prFineTune;       // Fine tune to correct pitch.
    WORD        m_wID;              // Wave pool id.
    BYTE        m_bSampleType;      // 16 or 8 or ADPCM.
    BYTE        m_bOneShot;         // Is this a one shot sample?
    BYTE        m_bMIDIRootKey;     // MIDI note number for sample.
    DWORD       m_dwLoopType;       // WLOOP_TYPE_xxx
};

/*  The CSourceRegion class defines a region within an instrument.
    The sample is managed with a pointer instead of an embedded
    sample. This allows multiple regions to use the same
    sample.
    Each region also has an associated articulation. For drums, there
    is a one to one matching. For melodic instruments, all regions
    share the same articulation. So, to manage this, each region
    points to the articulation.
*/

class CSourceRegion : public CListItem
{
public:
                CSourceRegion();
                ~CSourceRegion();
#ifdef DDUMP
    void        Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    CSourceRegion *GetNext() {return(CSourceRegion *)CListItem::GetNext();};
    void        Verify();           // Verifies that the data is valid.
    HRESULT     Load(CRiffParser *pParser);
    HRESULT     Download(DMUS_DOWNLOADINFO * pInfo, void * pvOffsetTable[], 
                    DWORD *pdwRegionIX, DWORD dwSampleRate, BOOL fNewFormat);
    CSourceSample m_Sample;       // Sample structure.
    CSourceArticulation * m_pArticulation; // Pointer to associated articulation.
    VRELS       m_vrAttenuation;    // Volume change to apply to sample.
    PRELS       m_prTuning;         // Pitch shift to apply to sample.
    BYTE        m_bAllowOverlap;    // Allow overlapping of note.
    BYTE        m_bKeyHigh;         // Upper note value for region.
    BYTE        m_bKeyLow;          // Lower note value.
    BYTE        m_bGroup;           // Logical group (for drums.)

    /* DLS2 */
    BYTE        m_bVelocityHigh;    // Upper velocity value for region.
    BYTE        m_bVelocityLow;     // Lower velocity value.
    SHORT       m_sWaveLinkOptions; // Wave link chunk option flags
    DWORD       m_dwChannel;        // Region channels, from WAVELINK chunk

    // Channel in m_dwChannel provides voice destination and overrides anything
    // from the articulation.
    //
    inline BOOL IsMultiChannel() const
    { return (BOOL)(m_sWaveLinkOptions & F_WAVELINK_MULTICHANNEL); }
};


class CSourceRegionList : public CList
{
public:
    CSourceRegion *GetHead() {return (CSourceRegion *)CList::GetHead();};
    CSourceRegion *RemoveHead() {return (CSourceRegion *)CList::RemoveHead();};
};


/*  The CInstrument class is really the file format definition
    of an instrument.
    The CInstrument can be either a Drum or a Melodic instrument.
    If a drum, it has up to 128 pairings of articulations and
    regions. If melodic, all regions share the same articulation.
    ScanForRegion is called by ControlLogic to get the region
    that corresponds to a note.
*/

class CInstManager;

class CInstrument :  public CListItem 
{
public:
                    CInstrument();
                    ~CInstrument();
#ifdef DDUMP
    void            Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    void            Init(DWORD dwSampleRate);
    void            Verify();           // Verifies that the data is valid.
    CInstrument *   GetInstrument(DWORD dwProgram,DWORD dwAccept);
    CInstrument *   GetNext() {return(CInstrument *)CListItem::GetNext();};
    CSourceRegion * ScanForRegion(DWORD dwNoteValue, DWORD dwVelocity, CSourceRegion *pRegion = NULL);
    CSourceRegionList m_RegionList;     // Linked list of regions.
    DWORD           m_dwProgram;        // Which program change it represents.
    HRESULT         LoadRegions(CRiffParser *pParser);
    HRESULT         Load(CRiffParser *pParser);
    CMemTrack       m_MemTrack;         // Only exists for debugging.
};

class CInstrumentList : public CList
{
public:
    CInstrument *    GetHead() {return (CInstrument *)CList::GetHead();};
    CInstrument *    RemoveHead() {return (CInstrument *)CList::RemoveHead();};
};
/*
class CWaveBufferList;
class CWaveBuffer : public CListItem 
{
friend CWaveBufferList;
public:
                CWaveBuffer() 
                {
                }
    CWaveBuffer * GetNext() { return (CWaveBuffer *)CListItem::GetNext();};
    CWaveBuffer * GetNextLoop() 
                {
                    // Threat the list as a circular list
                    CWaveBuffer *pbuf;
                    pbuf = (CWaveBuffer *)CListItem::GetNext();
                    if ( pbuf == NULL )
                        pbuf = (CWaveBuffer *)*m_ppHead;

                    return pbuf;
                };

    CWave *     m_pWave;            // pointer to wave object
protected:
    CListItem** m_ppHead;
};

class CWaveBufferList : public CList
{
public:
    CWaveBuffer *GetHead() {return (CWaveBuffer *)CList::GetHead();};
    CWaveBuffer *RemoveHead() {return (CWaveBuffer *)CList::RemoveHead();};

    // Overide these methods so that m_pHead can be added to CWaveBuffer ListItem
    // to allow GetNextLoop() to function as a simple circular buffer list 
    void InsertBefore(CListItem *pItem,CWaveBuffer *pInsert) {pInsert->m_ppHead = &m_pHead; CList::Cat(pItem);};
    void Cat(CWaveBuffer *pItem)     {pItem->m_ppHead = &m_pHead; CList::Cat(pItem);};
    void AddHead(CWaveBuffer *pItem) {pItem->m_ppHead = &m_pHead; CList::AddHead(pItem);};
    void AddTail(CWaveBuffer *pItem) {pItem->m_ppHead = &m_pHead; CList::AddTail(pItem);};
};

class CWaveArt : public CListItem
{
public:
                    CWaveArt();
                    ~CWaveArt();
    void            Release();          // Remove reference.
    void            AddRef();           // Add reference.
    void            Verify();           // Verifies that the data is valid.
    CWaveArt *      GetNext() {return(CWaveArt *)CListItem::GetNext();};
    DWORD           m_dwID;             // ID for matching wave with regions.
    DMUS_WAVEARTDL  m_WaveArtDl;
    WAVEFORMATEX    m_WaveformatEx;
    CWaveBufferList m_pWaves;           // Array of Wave buffers associated with dowload id's
//  DWORD           m_dwSampleLength;
    BYTE            m_bSampleType;
    BOOL            m_bStream;          // Is this a streaming articulation 
    WORD            m_wUsageCount;      // Keeps track of how many times in use.
};

class CWaveArtList : public CList
{
public:
    CWaveArt *      GetHead() {return (CWaveArt *)CList::GetHead();};
    CWaveArt *      RemoveHead() {return (CWaveArt *)CList::RemoveHead();};
};*/

#define WAVE_HASH_SIZE          15      // Keep waves in a hash table of linked lists to speed access.
#define INSTRUMENT_HASH_SIZE    15      // Same with instruments.
#define WAVEART_HASH_SIZE       31

class CCollection : public IDirectMusicCollection, public IPersistStream, public IDirectMusicObject, public AListItem
{
friend class CInstManager;

public:
    
	// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IPersist
	STDMETHODIMP GetClassID(CLSID* pClassID);

    // IPersistStream
	STDMETHODIMP IsDirty();
    STDMETHODIMP Load(IStream* pIStream);
    STDMETHODIMP Save(IStream* pIStream, BOOL fClearDirty) ;
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize) ;

	// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	// IDirectMusicCollection
	STDMETHODIMP GetInstrument(DWORD dwPatch, IDirectMusicInstrument** pInstrument);
	STDMETHODIMP EnumInstrument(DWORD dwIndex, DWORD* pdwPatch, LPWSTR pName, DWORD cwchName);

	// Class
	CCollection();
    ~CCollection();

    CCollection *   GetNext() {return(CCollection *)AListItem::GetNext();};
private:
    HRESULT         Load(CRiffParser *pParser);
    void            AddInstrument(CInstrument *pInstrument);
    CInstrument *   GetInstrument(DWORD dwProgram,DWORD dwKey);
    HRESULT         LoadWaves(CRiffParser *pParser);
    HRESULT         LoadInstruments(CRiffParser *pParser);
    void            ResolveConnections();
private:
    CMemTrack           m_MemTrack;
    CInfo               m_Info;
	long				m_cRef;
    CInstrumentList     m_InstrumentList[INSTRUMENT_HASH_SIZE];
    CWavePool           m_WavePool[WAVE_HASH_SIZE];
    CRITICAL_SECTION    m_CriticalSection;
};

class CCollectionList : public AList
{
public:
    CCollection *GetHead() {return (CCollection *)AList::GetHead();};
    void        AddHead(CCollection * pC) {AList::AddHead((AListItem *) pC);};
    CCollection *RemoveHead() {return (CCollection *)AList::RemoveHead();};
};


class CInstManager {
friend class CCollection;
public:
                    CInstManager();
                    ~CInstManager();
#ifdef DDUMP
    void            Dump(DWORD dwIndent,DWORD dwLevel);
#endif
    CInstrument *   GetInstrument(DWORD dwPatch,DWORD dwKey,DWORD dwVelocity);
    void            Verify();           // Verifies that the data is valid.
//    void            SetSampleRate(DWORD dwSampleRate);
    HRESULT         Download(LPHANDLE phDownload, 
                            void * pvData,
                            LPBOOL pbFree);
    HRESULT         Unload(HANDLE hDownload,
                            HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
                            HANDLE hUserData);
    CWave *         GetWave(DWORD dwDLId);
//    CWaveArt *      GetWaveArt(DWORD dwDLId);

private:
    HRESULT         DownloadInstrument(LPHANDLE phDownload, 
                                         DMUS_DOWNLOADINFO *pInfo, 
                                         void *pvOffsetTable[], 
                                         void *pvData,
                                         BOOL fNewFormat);
    HRESULT         DownloadWave(LPHANDLE phDownload,
                                DMUS_DOWNLOADINFO *pInfo, 
                                void *pvOffsetTable[], 
                                void *pvData);
    /* DirectX8 Private Methods */
/*    HRESULT         DownloadWaveArticulation(LPHANDLE phDownload, 
                                   DMUS_DOWNLOADINFO *pInfo, 
                                   void *pvOffsetTable[], 
                                   void *pvData);
    HRESULT         DownloadWaveRaw(LPHANDLE phDownload, 
                                   DMUS_DOWNLOADINFO *pInfo, 
                                   void *pvOffsetTable[], 
                                   void *pvData);*/
    CCollectionList m_CollectionList;
    CWavePool       m_WavePool[WAVE_HASH_SIZE];
    CWavePool       m_FreeWavePool;     // Track waves still in use, but unloaded.
    DWORD           m_dwSampleRate;     // Sample rate requested by app.

    /* DirectX8 Private Memmebers */
//    CWaveArtList    m_WaveArtList[WAVEART_HASH_SIZE];
public:
    DWORD           m_dwSynthMemUse;        /* Memory used by synth wave data */ 

    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.
    BOOL             m_fCSInitialized;
};


/*
class CWaveEvent {
public:
                CWaveEvent() : 
                m_stTime(0),
                m_bPart(0),
                m_dwVoiceId(0),
                m_vrVolume(0),
                m_prPitch(0),
                m_pWaveArt(NULL)
                {}
public:
    STIME       m_stTime;
    BYTE        m_bPart;
    DWORD       m_dwVoiceId;
    VREL        m_vrVolume;
    PREL        m_prPitch;
    SAMPLE_TIME m_stVoiceStart;
    SAMPLE_TIME m_stLoopStart;
    SAMPLE_TIME m_stLoopEnd;
    CWaveArt*   m_pWaveArt;
};

class CWaveData : public CListItem 
{
public:
                CWaveData();
    CWaveData * GetNext() {return (CWaveData *)CListItem::GetNext();};
    STIME       m_stTime;           // Time this event was recorded.
    CWaveEvent  m_WaveEventData;    // Data stored in event.            
};

class CWaveDataList : public CList
{
public:
    CWaveData *GetHead() {return (CWaveData *)CList::GetHead();};
    CWaveData *RemoveHead() {return (CWaveData *)CList::RemoveHead();};
};

class CWaveIn 
{
public:
                CWaveIn();
                ~CWaveIn();              // Be sure to clear local list.
    BOOL        ClearWave(STIME stTime); // Clear up to time stamp.
    BOOL        RemoveWave(DWORD dwID);  // Remove wave with dwID.
    BOOL        RemoveWaveByStopTime(DWORD dwID, STIME stStopTime);
    BOOL        RecordWave(STIME stTime, CWaveEvent *pWaveData); 
    BOOL        GetWave(STIME stTime, CWaveEvent *pWave); 

private:
    static DWORD m_sUsageCount;         // Keeps track of how many instances so free list can be released.
public:
    static CWaveDataList m_sFreeList;   // Global free list of events.

protected:
    CWaveDataList m_EventList;          // This recorder's list.
    STIME         m_stCurrentTime;      // Time for current value.
    CWaveEvent    m_lCurrentData;       // Current value.
}; 
*/
/*  The CVoiceLFO class is used to track the behavior
    of an LFO within a voice. The LFO is hard wired to 
    output both volume and pitch values, through separate
    calls to GetVolume and GetPitch.
    It also manages mixing Mod Wheel control of pitch and
    volume LFO output. It tracks the scaling of Mod Wheel
    for each of these in m_nMWVolumeScale and m_nMWPitchScale.
    It calls the Mod Wheel module to get the current values 
    if the respective scalings are greater than 0.
    All of the preset values for the LFO are carried in
    the m_CSource field, which is a replica of the file
    CSourceLFO structure. This is initialized with the
    StartVoice call.
*/

class CVoiceLFO 
{
public:
                CVoiceLFO();
//    static void Init();             // Set up sine table.
//    STIME       StartVoice(CSourceLFO *pSource, 
//                    STIME stStartTime,CModWheelIn * pModWheelIn, CPressureIn * pPressureIn);
//    VREL        GetVolume(STIME stTime, STIME *pstTime);    // Returns volume cents.
//    PREL        GetPitch(STIME stTime, STIME *pstTime);     // Returns pitch cents.

    /* DirectX8 Methods */
    void        Enable(BOOL bEnable) {m_bEnable = bEnable;};
    PREL        GetCutoff(STIME stTime);                    // Return filter cutoff

private:
    long        GetLevel(STIME stTime, STIME *pstTime);
    CSourceLFO  m_Source;           // All of the preset information.
//    STIME       m_stStartTime;      // Time the voice started playing.
//    CModWheelIn *m_pModWheelIn;     // Pointer to Mod Wheel for this channel.
//    STIME       m_stRepeatTime;     // Repeat time for LFO.
//    static short m_snSineTable[256];    // Sine lookup table.

    /* DirectX8 Memmebers */
//    CPressureIn *m_pPressureIn;     // Pointer to Channel Pressure for this channel.
    BOOL        m_bEnable;
};

/*  The CVoiceEG class is used to track the behavior of
    an Envelope Generator within a voice. There are two 
    EG's, one for pitch and one for volume. However, they
    behave identically.
    All of the preset values for the EG are carried in
    the m_Source field, which is a replica of the file
    CSourceEG structure. This is initialized with the
    StartVoice call.
*/

class CVoiceEG
{
public:
    static void Init();             // Set up linear attack table.
                CVoiceEG();
    STIME       StartVoice(CSourceEG *pSource, STIME stStartTime, 
                    WORD nKey, WORD nVelocity, STIME stMinAttack);
    void        StopVoice(STIME stTime);
    void        QuickStopVoice(STIME stTime, DWORD dwSampleRate);
    VREL        GetVolume(STIME stTime, STIME *pstTime);    // Returns volume cents.
    PREL        GetPitch(STIME stTime, STIME *pstTime);     // Returns pitch cents.
    BOOL        InAttack(STIME stTime);     // is voice still in attack?
    BOOL        InRelease(STIME stTime);    // is voice in release?

    /* DirectX8 Methods */
    void        Enable(BOOL bEnable) {m_bEnable = bEnable;};
    PREL        GetCutoff(STIME stTime);                    // Return filter cutoff

#ifdef XMIX
    void        SetupEnvelopeDesc(LPDSENVELOPEDESC pEnvDesc, bool bAmplitude);
#endif // XMIX

private:
    long        GetLevel(STIME stTime, STIME *pstTime, BOOL fVolume);
    CSourceEG   m_Source;           // Preset values for envelope, copied from file.
    STIME       m_stStartTime;      // Time note turned on
    STIME       m_stStopTime;       // Time note turned off
    static short m_snAttackTable[201];

    /* DirectX8 Memmebers */
    BOOL        m_bEnable;
};

//>>>>>>>>>>> comment 
class CVoiceFilter
{
public:
    void        StartVoice(CSourceFilter *pSource, CVoiceLFO *pLFO, CVoiceEG *pEG, WORD nKey, WORD nVelocity);
    void        GetCoeff(STIME stTime, PREL prFreqIn, COEFF &cfK, COEFF &cfB1, COEFF &cfB2);
    BOOL        IsFiltered();
    
public:
    CSourceFilter   m_Source;   
    CVoiceLFO       *m_pLFO;
    CVoiceEG        *m_pEG;
//    CPitchBendIn    *m_pPitchBend;

    PREL            m_prVelScale;
    PREL            m_prKeyScale;
    
    static COEFF    m_aK[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC];
    static COEFF    m_aB1[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC];
    static COEFF    m_aB2[FILTER_PARMS_DIM_Q][FILTER_PARMS_DIM_FC];
};

/*  The CDigitalAudio class is used to track the playback
    of a sample within a voice.
    It manages the loop points, the pointer to the sample.
    and the base pitch and base volume, which it initially sets 
    when called via StartVoice(). 
    Pitch is stored in a fixed point format, where the leftmost
    20 bits define the sample increment and the right 12 bits
    define the factional increment within the sample. This 
    format is also used to track the position in the sample.
    Mix is a critical routine. It is called by the CVoice to blend
    the instrument into the data buffer. It is handed relative change
    values for pitch and volume (semitone cents and decibel
    cents.) These it converts into three linear values:
    Left volume, Right volume, and Pitch.
    It then compares these new values with the values that existed 
    for the previous slice and divides by the number of samples to 
    determine an incremental change at the sample rate. 
    Then, in the critical mix loop, these are added to the 
    volume and pitch indices to give a smooth linear slope to the
    change in volume and pitch.
*/

#define MAX_SAMPLE    4095
#define MIN_SAMPLE  (-4096)

#define MAXDB            0
#define MINDB           -100
#define TEST_WRITE_SIZE  3000
#define TEST_SOURCE_SIZE 44100

class CSynth;

class CDigitalAudio 
{
public:
//                CDigitalAudio();
//                ~CDigitalAudio();
/*
    void        ClearVoice();
    STIME       StartVoice(CSynth *pSynth,
                    CSourceSample *pSample,
                    PREL prBasePitch, long lKey);
    STIME       StartWave(CSynth *pSynth,
                    CWaveArt *pWaveArt, 
                    PREL prBasePitch,
                    SAMPLE_TIME stVoiceStart,
                    SAMPLE_TIME stLoopStart,
                    SAMPLE_TIME stLoopEnd);

//    inline void BreakLoop()
//    { m_bOneShot = TRUE; }
*/
    static void Init();                         // Set up lookup tables.
    static PFRACT PRELToPFRACT(PREL prPitch);   // Pitch cents to pitch.
    static VFRACT VRELToVFRACT(VREL vrVolume);  // dB to absolute.

//    SAMPLE_POSITION GetCurrentPos() {return m_ullSamplesSoFar;};


/*private:
    void        BeforeBigSampleMix();
    void        AfterBigSampleMix();

private:
    CSourceSample   m_Source;           // Preset values for sample.
//    CSynth *        m_pSynth;           // For access to sample rate, etc.
*/
    static PFRACT   m_spfCents[201];    // Pitch increment lookup.
    static PFRACT   m_spfSemiTones[97]; // Four octaves up and down.
    static VFRACT   m_svfDbToVolume[(MAXDB - MINDB) * 10 + 1]; // dB conversion table.
/*    static BOOL     m_sfMMXEnabled;

private:
    short *     m_pnWave;           // Private pointer to wave.

    PFRACT      m_pfBasePitch;      // Overall pitch.
    PFRACT      m_pfLastPitch;      // The last pitch value.
    PREL        m_prLastPitch;      // Same for pitch, in PREL.
    PFRACT      m_pfLastSample;     // The last sample position.
    PFRACT      m_pfLoopStart;      // Start of loop.
    PFRACT      m_pfLoopEnd;        // End of loop.
    PFRACT      m_pfSampleLength;   // Length of sample buffer.
    BOOL        m_fElGrande;        // Indicates larger than 1m wave.
    ULONGLONG   m_ullLastSample;    // Used to track > 1m wave.
    ULONGLONG   m_ullLoopStart;     // Used to track > 1m wave.
    ULONGLONG   m_ullLoopEnd;       // Used to track > 1m wave.
    ULONGLONG   m_ullSampleLength;  // Used to track > 1m wave.
    DWORD       m_dwAddressUpper;   // Temp storage for upper bits of address.
    BOOL        m_bOneShot;         // Is the source region we're mixing a one-shot?
*/
    /* DLS2 filter members */
/*    COEFF       m_cfLastK;          // Held filter coefficients
    COEFF       m_cfLastB1;
    COEFF       m_cfLastB2;
    long        m_lPrevSample;      // Last two samples, post-filter
    long        m_lPrevPrevSample;
*/
    /* DirectX8 members */
//    CWaveBuffer*    m_pCurrentBuffer;
//    CWaveArt*       m_pWaveArt;
//    ULONGLONG       m_ullSamplesSoFar;
};

VREL VelocityToVolume(WORD nVelocity);
VREL MIDIToPercent(WORD nMIDI);

class CPart;

class CVoice : public CListItem
{
public:
                    CVoice();
#ifdef XMIX
                    ~CVoice();
#endif
    CVoice *        GetNext() {return (CVoice *)CListItem::GetNext();};

    BOOL            StartVoice(CSynth *pControl,
                        CSourceRegion *pRegion, REFERENCE_TIME rtStartTime,
                        CBusIds * pBusIds,
                        WORD nKey,WORD nVelocity,
                        VREL vrVolume,      
                        VREL vrMIDIVolume,
                        PREL prPitch,
                        PREL prMIDIPitch);     

    BOOL            StartWave(CSynth *pSynth,
                        CSourceWave *pWave,
                        DWORD dwVoiceId,
                        REFERENCE_TIME rtStartTime,
                        CBusIds * pBusIds,
                        VREL vrVolume,      
                        VREL vrMIDIVolume,
                        PREL prPitch,
                        PREL prMIDIPitch,
                        DWORD dwVoiceStart,
                        DWORD dwLoopStart,
                        DWORD dwLoopEnd );

    BOOL            StartStreamedWave(CSynth *pSynth,
                        CSourceWave *pWave,
                        DWORD dwVoiceId,
                        REFERENCE_TIME rtStartTime,
                        CBusIds * pBusIds,
                        VREL vrVolume,     
                        VREL vrMIDIVolume,
                        PREL prPitch,
                        PREL prMIDIPitch,
                        DWORD dwVoiceStart,
                        DWORD dwLoopStart,
                        DWORD dwLoopEnd );
    static void     Init();             // Initialize LFO, Digital Audio.
    void            SendVolume(REFERENCE_TIME rtTime);
    void            SendPitch(REFERENCE_TIME rtTime);
    void            SendFilter(REFERENCE_TIME rtTime,BOOL fStart);
    void            SendLFOs(REFERENCE_TIME rtTime);
    void            StopVoice(REFERENCE_TIME rtTime);// Called on note off event.
    void            QuickStopVoice(REFERENCE_TIME rtTime);// Called to get quick release.
    void            ClearVoice();       // Release use of sample.
    void            DoWork(CSynth* pSynth);
    SAMPLE_POSITION GetCurrentPos();
    LPDIRECTSOUNDSEQUENCER GetSequencer();
    HRESULT         AllocateBuffer(XBOXADPCMWAVEFORMAT* pwfxFormat);
    LPDIRECTSOUNDSEQUENCERBUFFER m_pBuffer;
    XBOXADPCMWAVEFORMAT     m_WaveFormat; // Format of current buffer

#define VOICE_NUM_PACKETS 2 // Must match PACKETCOUNT in dmime\audiosink.h

    DWORD           m_dwPacketIndex[VOICE_NUM_PACKETS];
    WORD            m_wCurrentPacket;    // Index into m_dwStreamStatus
    WORD            m_wPacketsSubmitted; // count 0..VOICE_NUM_PACKETS
    DWORD           m_dwStreamPosition;
    DWORD           m_dwLoopStart;      // For streamed looping.
    DWORD           m_dwLoopEnd;  
    PVOID           m_pvBuffer[VOICE_NUM_PACKETS];
    DWORD           m_dwBufferSize;

    LPDIRECTSOUNDSEQUENCERSTREAM m_pStream;
    CSourceWave *   m_pWave;        // Pointer to source wave for streaming.
    void            CreateStream();
    bool            StreamDoWork(REFERENCE_TIME now);
    HRESULT         WritePacket(REFERENCE_TIME rtTime,DWORD dwPacket);
    void            ProcessCompletedPackets(bool bCompleteUnsubmitted);

    void            StopStream(REFERENCE_TIME rt);

private:
//    CDigitalAudio m_DigitalAudio;  // The Digital Audio Engine structure.
    CSynth *    m_pSynth;           // To access sample rate, etc.
    long        m_lDefaultPan;      // Default pan
    PREL        m_prLastCutOff;     // Last cut off value.
    CSourceArticulation m_Articulation; // Copy of source articulation. We may munge some of it. 

public:
    DWORD       m_dwNoteID;         // Unique id to keep all voices that represent layers of one note connected.
    REFERENCE_TIME m_rtStartTime;   // Time the sound starts.
    REFERENCE_TIME m_rtStopTime;    // Time the sound stops.
    BOOL        m_fInUse;           // This is currently in use.
    BOOL        m_fNoteOn;          // Note is considered on.
    BOOL        m_fTag;             // Used to track note stealing.
    BOOL        m_fSustainOn;       // Sus pedal kept note on after off event.
    WORD        m_nPart;            // Part that is playing this (channel).
    WORD        m_nKey;             // Note played.
    BOOL        m_fAllowOverlap;    // Allow overlapped note.
    DWORD       m_dwGroup;          // Group this voice is playing now
    DWORD       m_dwProgram;        // Bank and Patch choice.
    DWORD       m_dwPriority;       // Priority.
    CControlLogic * m_pControl;     // Which control group is playing voice.
    CPart *     m_pPart;            // And which corresponding part.
    DWORD       m_dwVoiceId;        // Used to identify a playing wave
    CSourceRegion *m_pRegion;       // Used to determine which region a voice is playing out of 
    CBusIds     m_BusIds;           // Bus Id's to play on this voice
    DWORD       m_dwLoopType;       // Loop type
    BOOL        m_fIgnorePan;       // If we're part of a multichannel wave/sample
    VREL        m_vrStartVolume;    // Initial volume, as computed by velocity, region, etc.
    PREL        m_prStartPitch;     // Initial pitch, as computed by region, sample rate, etc.
    PREL        m_prStartFilter;    // Initial filter.
    short       m_wFilterQ;         // Initial resonance.
    BOOL        m_fWave;
    BOOL        m_fStreamed;
    BOOL        m_fUseFilter;
    VREL        m_vrLastVolumes[8]; // Last volumes sent.
    PREL        m_prLastPitch;      // Last pitch sent.
    PREL        m_prLastFilter;     // Last filter sent.
};


class CVoiceList : public CList
{
public:
    CVoice *     GetHead() {return (CVoice *)CList::GetHead();};
    CVoice *     RemoveHead() {return (CVoice *)CList::RemoveHead();};
    CVoice *     GetItem(LONG lIndex) {return (CVoice *) CList::GetItem(lIndex);};
};

/*  Finally, ControlLogic is the big Kahuna that manages 
    the whole system. It parses incoming MIDI events
    by channel and event type. And, it manages the mixing
    of voices into the buffer.

  MIDI Input:

    The most important events are the note on and
    off events. When a note on event comes in, 
    ControlLogic searches for an available voice.
    ControlLogic matches the channel and finds the
    instrument on that channel. It then call the instrument's
    ScanForRegion() command which finds the region 
    that matches the note. At this point, it can copy
    the region and associated articulation into the
    voice, using the StartVoice command.
    When it receives the sustain pedal command,
    it artificially sets all notes on the channel on
    until a sustain off arrives. To keep track of notes
    that have been shut off while the sustain was on
    it uses an array of 128 shorts, with each bit position 
    representing a channel. When the sustain releases,
    it scans through the array and creates a note off for
    each bit that was set.
    It also receives program change events to set the
    instrument choice for the channel. When such
    a command comes in, it consults the softsynth.ini file 
    and loads an instrument with the file name described
    in the ini file.
    Additional continuous controller events are managed
    by the CModWheelIn, CPitchBendIn, etc., MIDI input recording
    modules.

  Mixing:

    Control Logic is also called to mix the instruments into
    a buffer at regular intervals. The buffer is provided by the
    calling sound driver (initially, AudioMan.) 
    Each voice is called to mix its sample into the buffer.
*/

typedef struct PerfStats
{
    DWORD dwTotalTime;
    DWORD dwTotalSamples;
    DWORD dwNotesLost;
    DWORD dwVoices;
    DWORD dwCPU;
    DWORD dwMaxAmplitude;
} PerfStats;

#define MAX_NUM_VOICES          32  
#define NUM_EXTRA_VOICES        8   // Extra voices for when we overload.

class CPart
{
public:
                    CPart();
    void            Init(CControlLogic *pControl, CSynth *pSynth);
    void            RecordMIDI(REFERENCE_TIME rtTimeIn, BYTE bStatus, BYTE bData1, BYTE bData2);
    void            PlayNoteOff(REFERENCE_TIME rtTime,BYTE bNote);
    void            PlayNoteOn(REFERENCE_TIME rtTime,BYTE bNote, BYTE bVelocity);
    void            SendVolume(REFERENCE_TIME rtTime);
    void            SendPitch(REFERENCE_TIME rtTime);
    void            SendFilter(REFERENCE_TIME rtTime);
    void            SendLFOs(REFERENCE_TIME rtTime);
    void            SetSustain(REFERENCE_TIME rtTime,BOOL fSustain);
    void            GetVolume(VREL vrVoice,long lDefaultPan, VREL *pvrVolume,VREL *pvrLeft,VREL *pvrRight,VREL *pvrReverb,VREL *pvrChorus);
    void            GetVolume(VREL vrVoice, BYTE pbControllers[], VREL pvrVolume[]);
    void            GetPitch(PREL *prPitch);
    void            GetFilter(PREL *prFilter);
    void            GetModWheel(DWORD *pdwModWheel);
    void            GetPressure(DWORD *pdwPressure);
    void            AllNotesOff(REFERENCE_TIME rtTime);
    void            AllSoundsOff(REFERENCE_TIME rtTime);

    static VREL     m_svrPanToVREL[128];// Converts Pan to db.

    CControlLogic * m_pControl;
    CSynth *        m_pSynth;
    CBusIds         m_BusIds;           // Bus Id's for this channel 
    REFERENCE_TIME  m_rtLastTime;       // Time of the last event to come in. 
    BOOL            m_fSustain;         // Sustain on / off.
    BOOL            m_fMono;            // Mono mode?
    DWORD           m_dwProgram;        // Instrument choice.
    DWORD           m_dwPriority;       // Priorities for each channel.
    PREL            m_prFineTune;       // Fine tune for each channel.
    PREL            m_prScaleTune[12];  // Alternate scale for each channel.
    PREL            m_prCoarseTune;     // Coarse tune.
    short           m_nPitchBend;       // Pitch Bend.
    short           m_nCurrentRPN;      // RPN number.
    WORD            m_nData;            // Used to track RPN reading.
    BYTE            m_bModWheel;        // Mod Wheel.
    BYTE            m_bVolume;          // Volume.
    BYTE            m_bExpression;      // Expression.
    BYTE            m_bPan;             // Pan.
    BYTE            m_bReverbSend;      // Reverb send.
    BYTE            m_bChorusSend;      // Chorus send.
    BYTE            m_bFilter;          // Filter control.
    BYTE            m_bPressure;        // Channel Pressure.
    BYTE            m_bBankH;           // Bank selects for instrument.
    BYTE            m_bBankL;         
    BYTE            m_bPartToChannel;   // Channel to Part converter.
    BYTE            m_bDrums;           // Melodic or which drum?
    BYTE            m_bMixBinVolume[8]; // The 8 MixBin volume controllers.
};


class CControlLogic
{
    friend class CPart;
public:
                    CControlLogic();
                    ~CControlLogic();
    HRESULT         Init(CInstManager *pInstruments, CSynth *pSynth);
    BOOL            RecordMIDI(REFERENCE_TIME rtTime,BYTE bStatus, BYTE bData1, BYTE bData2);
    HRESULT         RecordSysEx(DWORD dwSysExLength,BYTE *pSysExData, REFERENCE_TIME rtTime);
    CSynth *        m_pSynth;
    void            SetGainAdjust(VREL vrGainAdjust);
    HRESULT         SetChannelPriority(DWORD dwChannel,DWORD dwPriority);
    HRESULT         GetChannelPriority(DWORD dwChannel,LPDWORD pdwPriority);

    /* DirectX8 methods */
    BOOL            RecordWaveEvent(REFERENCE_TIME rtTime, BYTE bChannel, VREL vrVolume, PREL prPitchIn, 
                        SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd,
                        IDirectSoundWave *pIWave, DWORD *pdwVoiceID);
    HRESULT         AssignChannelToOutput(DWORD dwChannel, IDirectSoundBuffer *pBuffer,DWORD dwMixBins, BYTE *pbControllers );
    
private:
    void            GMReset();
    CInstManager *  m_pInstruments;
    CPart           m_Part[16];         // One part for each MIDI channel. 
    BOOL            m_fEmpty;           // Indicates empty lists, no need to flush.
    VREL            m_vrGainAdjust;     // Final stage gain adjust
    BOOL            m_fXGActive;        // Is XG Active?
    BOOL            m_fGSActive;        // Is GS enabled?
    VREL            m_vrMasterVolume;   // Master Volume.

public:
    // This is static to protect the CMIDIRecorder free list, which is also static.
    // 
    static CRITICAL_SECTION s_CriticalSection; // Critical section to manage access.
    static DWORD            m_dwCSRefCount;    // Keep track of how many times it is requested.

    void InitCriticalSection();
    void KillCriticalSection();

};

#endif // __SYNTH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\dmscriptautguids.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declares the CLSIDs for creating the wrapper objects that implement the IDispatch
// interfaces for the various DirectMusic objects.  These CLSIDs are not public --
// they are only needed in the implementation of the DirectMusic objects.  A user of
// the IDispatch interface will get ahold of it by QueryInterface from the associated
// DirectMusic object.

#pragma once

DEFINE_GUID(CLSID_AutDirectMusicPerformance,		0xa861c6e2, 0xfcfc, 0x11d2, 0x8b, 0xc9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {A861C6E2-FCFC-11d2-8BC9-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSegment,			0x4062c116, 0x0270, 0x11d3, 0x8b, 0xcb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {4062C116-0270-11d3-8BCB-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicSong,				0xa16f1761, 0xb6d8, 0x42eb, 0x8d, 0x57, 0x4a, 0x44, 0xfe, 0xdd, 0x3b, 0xd2);// {A16F1761-B6D8-42eb-8D57-4A44FEDD3BD2}
DEFINE_GUID(CLSID_AutDirectMusicSegmentState,		0xebf2320a, 0x2502, 0x11d3, 0x8b, 0xd1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {EBF2320A-2502-11d3-8BD1-00600893B1B6}
DEFINE_GUID(CLSID_AutDirectMusicAudioPathConfig,	0x1cebde3e, 0x6b91, 0x484a, 0xaf, 0x48, 0x5e, 0x4f, 0x4e, 0xd6, 0xb1, 0xe1);// {1CEBDE3E-6B91-484a-AF48-5E4F4ED6B1E1}
DEFINE_GUID(CLSID_AutDirectMusicAudioPath,			0x2c5f9b72, 0x7148, 0x4d97, 0xbf, 0xc9, 0x68, 0xa0, 0xe0, 0x76, 0xbe, 0xbd);// {2C5F9B72-7148-4d97-BFC9-68A0E076BEBD}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\sources.inc ===
!IF 0

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

NOTE:	The file ddksources in this directory structure is used to build the
        DDK sythesizer sample.  If you make changes to this file, make sure
        to keep ddksources in sync as well.  See ddkreadme.txt for more info.

!ENDIF

!include ..\..\sources.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmsynth$(LIBEXT)

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF


TARGETTYPE = LIBRARY
TARGETPATH = ..\..\obj
USE_MAPSYM=1

!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -DREVERB_ENABLED -D_DMUSIC_USER_MODE_ -D_MT -DXBOX -DUNICODE

USE_LIBCMT=1

INCLUDES= $(INCLUDES); \
        ..\..\xprivate;   \
        ..\..\shared; \
        ..

SOURCES=\
clist.cpp           \
control.cpp         \
csynth.cpp          \
instr.cpp           \
voice.cpp           \
guids_dmsynth.cpp   \
wave.cpp            \
dls.cpp             \
dmrand.cpp


# XMIX is (DSound-based) hardware mixing for Xbox
!if !defined(SILVER) && !defined(NOXMIX)

C_DEFINES = $(C_DEFINES) -DXMIX

INCLUDES= $(INCLUDES); \
    $(BASEDIR)\private\ntos\inc;\
    $(BASEDIR)\private\windows\directx\dsound\dsound;\
    $(BASEDIR)\private\windows\directx\dsound\ac97;\
    $(BASEDIR)\private\windows\directx\dsound\tools\inc

SOURCES = $(SOURCES) \
dsoundsequencer.cpp
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\voice.cpp ===
//      Voice.cpp
//      Copyright (c) 1996-1999 Microsoft Corporation
//

#ifdef DMSYNTH_MINIPORT
#include "common.h"
#include <math.h>
#include "muldiv32.h"
#else
#include "debug.h"
#include "simple.h"
#include <mmsystem.h>
#include <dmusicc.h>
#include <dmusics.h>
#include "synth.h"
#include <math.h>
#include <stdio.h>
#include "csynth.h"
#endif
#include "fparms.h" // Generated filter parameter arrays

#ifdef _X86_
#define MMX_ENABLED 1
#endif

#ifdef DBG
extern DWORD sdwDebugLevel;
#endif

#ifdef XBOX
#include "..\dmime\cmixbins.h"
#endif

#ifdef XMIX

static REFERENCE_TIME STimeToSeqTime(STIME stTime){
    // stTime is in sample time - 48000 units per second
    // REFERENCE_TIME is in NT system time = 10,000,000 per second
    REFERENCE_TIME result = stTime;
    result = result * 10000000 / 48000;
    return result;
}

#endif

PFRACT CDigitalAudio::m_spfCents[201];
PFRACT CDigitalAudio::m_spfSemiTones[97];
VFRACT CDigitalAudio::m_svfDbToVolume[(MAXDB - MINDB) * 10 + 1];

void CDigitalAudio::Init()
{
    double flTemp;
    VREL    vrdB;

    for (vrdB = MINDB * 10;vrdB <= MAXDB * 10;vrdB++)
    {
        flTemp = vrdB;
        flTemp /= 100.0;
        flTemp = pow(10.0,flTemp);
        flTemp = pow(flTemp,0.5);   // square root.
        flTemp *= 4095.0; // 2^12th, but avoid overflow...
        m_svfDbToVolume[vrdB - (MINDB * 10)] = (long) flTemp;
    }

    PREL prRatio;

    for (prRatio = -100;prRatio <= 100;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 1200.0;
        flTemp = pow(2.0,flTemp);
        flTemp *= 4096.0;
        m_spfCents[prRatio + 100] = (long) flTemp;
    }
    
    for (prRatio = -48;prRatio <= 48;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 12.0;
        flTemp = pow(2.0,flTemp);
        flTemp *= 4096.0;
        m_spfSemiTones[prRatio + 48] = (long) flTemp;
    }
}

VFRACT CDigitalAudio::VRELToVFRACT(VREL vrVolume)
{
    vrVolume /= 10;

    if (vrVolume < MINDB * 10) 
        vrVolume = MINDB * 10;
    else if (vrVolume >= MAXDB * 10) 
        vrVolume = MAXDB * 10;

    return (m_svfDbToVolume[vrVolume - MINDB * 10]);
}

PFRACT CDigitalAudio::PRELToPFRACT(PREL prPitch)
{
    PFRACT pfPitch = 0;
    PREL prOctave;
    if (prPitch > 100)
    {
        prOctave = prPitch / 100;
        prPitch = prPitch % 100;
        pfPitch = m_spfCents[prPitch + 100];
        pfPitch <<= prOctave / 12;
        prOctave = prOctave % 12;
        pfPitch *= m_spfSemiTones[prOctave + 48];
        pfPitch >>= 12;
    }
    else if (prPitch < -100)
    {
        prOctave = prPitch / 100;
        prPitch = (-prPitch) % 100;
        pfPitch = m_spfCents[100 - prPitch];
        pfPitch >>= ((-prOctave) / 12);
        prOctave = (-prOctave) % 12;
        pfPitch *= m_spfSemiTones[48 - prOctave];
        pfPitch >>= 12;
    }
    else
    {
        pfPitch = m_spfCents[prPitch + 100];
    }
    return (pfPitch);
}


CVoice::CVoice()
{
    m_pBuffer = NULL;
    m_pWave = NULL;
    memset(&m_WaveFormat, 0, sizeof(m_WaveFormat));
    m_pStream = NULL;
    memset(m_dwPacketIndex,0,sizeof(m_dwPacketIndex));
    memset(m_pvBuffer,0,sizeof(m_pvBuffer));
    m_dwBufferSize = 0;
    m_wCurrentPacket = 0;
    m_wPacketsSubmitted = 0;
    m_pControl = NULL;
    m_dwPriority = 0;
    m_nPart = 0;
    m_nKey = 0;
    m_fInUse = FALSE;
    m_fSustainOn = FALSE;
    m_fNoteOn = FALSE;
    m_fTag = FALSE;
    m_rtStartTime = 0;
    m_rtStopTime = 0x7fffffffffffffff;
    m_fAllowOverlap = FALSE;
    m_pRegion = NULL;
    m_dwLoopType = 0;
}


CVoice::~CVoice()
{
    ClearVoice();
}

void CVoice::Init()
{
    static BOOL fBeenHereBefore = FALSE;
    if (fBeenHereBefore) return;
    fBeenHereBefore = TRUE;
    CDigitalAudio::Init();
}

LPDIRECTSOUNDSEQUENCER CVoice::GetSequencer()
{
    return m_pSynth->GetSequencer();
}

void CVoice::StopVoice(REFERENCE_TIME rtTime)
{
    if (m_fNoteOn)
    {
        m_dwGroup = 0;
        m_fNoteOn = FALSE;
        m_fSustainOn = FALSE;
        m_rtStopTime = rtTime;
        if(m_pBuffer)
        {
            DWORD dwFlags = DSBSTOPEX_ENVELOPE;
            if (m_dwLoopType == WLOOP_TYPE_RELEASE)
            {
                dwFlags |= DSBSTOPEX_RELEASEWAVEFORM;
            }
            HRESULT hr = m_pBuffer->StopEx(rtTime,dwFlags);
            if(FAILED(hr) && rtTime)
            { 
                // If we ran out of memory, try to stop immediately to avoid a stuck-on note.
                m_pBuffer->StopEx(0,dwFlags);
            }
        }
        else 
        {
            StopStream(rtTime);
        }
    }
}

void CVoice::QuickStopVoice(REFERENCE_TIME rtTime)
{
    m_fSustainOn = FALSE;
    m_rtStopTime = rtTime;
    m_dwGroup = 0;
    if (m_pBuffer)
    {
        // Only kill the sound if it is on. We currently get a click if we try to call StopEx() a second time.
        if (m_fNoteOn) 
        {
            m_pBuffer->ClearAtOrAfter(rtTime);
            // Wave already has a release time of 1.
            if (!m_fWave) 
            {
                m_Articulation.m_VolumeEG.m_Registers.dwRelease = 1;
                m_pBuffer->SetEG(rtTime, &m_Articulation.m_VolumeEG.m_Registers);
            }
            if (FAILED(m_pBuffer->StopEx(rtTime,DSBSTOPEX_ENVELOPE)))
            {
                m_pBuffer->StopEx(0,DSBSTOPEX_ENVELOPE);
            }
        }
        else
        // If the sound is already in the release phase, hack to fade it out by hand.
        {
            if (!m_fTag)
            {
                m_pBuffer->ClearAtOrAfter(rtTime);
            }
            for (DWORD dwI = 0; dwI < 4; dwI++)
            {
                m_vrStartVolume -= 1200; // Drop the volume 12dB.
                SendVolume(rtTime);
                rtTime += 10000;    // Increment forward 1 ms. 
            }
        }
    }
    else
    {
        StopStream(rtTime);
    }
    m_fTag = TRUE;
    m_fNoteOn = FALSE;
}

void CVoice::StopStream(REFERENCE_TIME rtTime)
{
    ClearVoice();
//    if(m_pStream)
//    {
        // Unfortunately, we need to wait until after the Flush is processed so we can
        // release our buffer data. So we ignore the rtTime argument and stop immediately.

//        m_pStream->Clear();  // Remove any queued commands
//        m_pStream->Flush(0); // Stop audio, set status of pending packets to Flushed.
        DirectSoundDoWork(); // So the packet status gets updated.

//        ProcessCompletedPackets(TRUE); // Releases packets.

//        m_pStream->Release();

//        m_pStream = NULL;
//        m_fInUse = false;
//    }
}


HRESULT CVoice::AllocateBuffer(XBOXADPCMWAVEFORMAT* pwfxFormat)
{
    HRESULT hr = S_OK;

    if(m_pBuffer && !(pwfxFormat->wfx.cbSize == m_WaveFormat.wfx.cbSize
        && pwfxFormat->wfx.nAvgBytesPerSec == m_WaveFormat.wfx.nAvgBytesPerSec
        && pwfxFormat->wfx.nBlockAlign == m_WaveFormat.wfx.nBlockAlign
        && pwfxFormat->wfx.nChannels == m_WaveFormat.wfx.nChannels
        && pwfxFormat->wfx.nSamplesPerSec == m_WaveFormat.wfx.nSamplesPerSec
        && pwfxFormat->wfx.wBitsPerSample == m_WaveFormat.wfx.wBitsPerSample
        && pwfxFormat->wfx.wFormatTag == m_WaveFormat.wfx.wFormatTag))
    {
        m_pBuffer->Release();
        m_pBuffer = 0;
        memset(&m_WaveFormat, 0, sizeof(m_WaveFormat));
    }
    if(!m_pBuffer)
    {
        m_WaveFormat = *pwfxFormat;
        DSBUFFERDESC dsbd;
        memset(&dsbd, 0, sizeof(dsbd));
        dsbd.lpwfxFormat = &m_WaveFormat.wfx;
        dsbd.dwFlags = DSBCAPS_CTRLFREQUENCY
            | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPOSITIONNOTIFY;
        hr = GetSequencer()->CreateBuffer(&dsbd, &m_pBuffer);
        if (FAILED(hr))
        {
            DbgPrint("Failed buffer creation!\n");
        }
    }
    return hr;
}

// Convert from frequency ratio to PREL.

__inline long RatioToPREL(float flRatio)
{
    const float             fl4096  = 1200.0f;
    long                    lPitch;

    __asm 
    {
        fld     fl4096
        fld     flRatio
        fyl2x
        fistp   lPitch
    }

    return lPitch;
}

void CVoice::SendPitch(REFERENCE_TIME rtTime)

{
    PREL prPitch;
    m_pPart->GetPitch(&prPitch);
    prPitch += m_prStartPitch;
    if (prPitch != m_prLastPitch)
    {
        m_prLastPitch = prPitch;
        // Convert from PREL format (1200 per octave) to NVidia (4096 per octave.)
        prPitch = (prPitch * 1024) + 512;
        prPitch /= 300;

        if(prPitch < DSBPITCH_MIN){
            Trace(3,"Clamping pitch to DSBPITCH_MIN\n");
            prPitch = DSBPITCH_MIN;
        }
        if(prPitch > DSBPITCH_MAX){
            Trace(3,"Clamping pitch to DSBPITCH_MAX\n");
            prPitch = DSBPITCH_MAX;
        }

        if (m_fStreamed)
        {
            if (m_pStream)
            {
                m_pStream->SetPitch(rtTime,prPitch);
            }
        }
        else
        {
            if (m_pBuffer)
            {
                m_pBuffer->SetPitch(rtTime,prPitch);
            }
        }
    }
}

void CVoice::SendLFOs(REFERENCE_TIME rtTime)

{
    long lPressure, lModWheel;
    m_pPart->GetPressure((DWORD *) &lPressure);
    m_pPart->GetModWheel((DWORD *) &lModWheel);

    // First, take the control pressure to pitch parameter and scale by control pressure.
    VREL vrTemp = (lPressure * m_Articulation.m_LFO.m_prCPPitchScale) / 127;
    // Then, add mod wheel to pitch parameter and scale it.
    vrTemp += (lModWheel * m_Articulation.m_LFO.m_prMWPitchScale) / 127;
    // Then, add to the default pitch control.
    vrTemp += m_Articulation.m_LFO.m_prPitchScale;
    vrTemp <<= 16;      // Scale up to full 32 bit DLS2 file format.
    vrTemp /= 614400;   // Then convert to NVidia format.
    FORCEBOUNDS(vrTemp,-128,127);
    m_Articulation.m_LFO.m_Registers.lPitchModulation = vrTemp;

    // Now, do the same for LF02, which only does vibrato.
    vrTemp = (lPressure * m_Articulation.m_LFO2.m_prCPPitchScale) / 127;
    vrTemp += (lModWheel * m_Articulation.m_LFO2.m_prMWPitchScale) / 127;
    vrTemp += m_Articulation.m_LFO2.m_prPitchScale;
    vrTemp <<= 16;      // Scale up to full 32 bit DLS2 file format.
    vrTemp /= 614400;   // Then convert to NVidia format.
    FORCEBOUNDS(vrTemp,-128,127);
    m_Articulation.m_LFO2.m_Registers.lPitchModulation = vrTemp;

    // Do the same for volume on first LFO. 
    vrTemp = (lPressure * m_Articulation.m_LFO.m_vrCPVolumeScale) / 127;
    vrTemp += (lModWheel * m_Articulation.m_LFO.m_vrMWVolumeScale) / 127;
    vrTemp += m_Articulation.m_LFO.m_vrVolumeScale;
    vrTemp <<= 16;      // Scale up to full 32 bit DLS2 file format.
    vrTemp /= 38400;    // Then convert to NVidia format.
    FORCEBOUNDS(vrTemp,-128,127);
    m_Articulation.m_LFO.m_Registers.lAmplitudeModulation = vrTemp;

    // And, filter on the the first LFO.
    vrTemp = (lPressure * m_Articulation.m_LFO.m_prCPCutoffScale) / 127;
    vrTemp += (lModWheel * m_Articulation.m_LFO.m_prMWCutoffScale) / 127;
    vrTemp += m_Articulation.m_LFO.m_prCutoffScale;
    vrTemp <<= 16;      // Scale up to full 32 bit DLS2 file format.
    vrTemp /= 4915200;  // Then convert to NVidia format.
    FORCEBOUNDS(vrTemp,-128,127);
    m_Articulation.m_LFO.m_Registers.lFilterCutOffRange = vrTemp;

    if (m_pBuffer)
    {
        m_pBuffer->SetLFO(rtTime, &m_Articulation.m_LFO.m_Registers);
        m_pBuffer->SetLFO(rtTime, &m_Articulation.m_LFO2.m_Registers);
    }
    else if (m_pStream)
    {
        m_pStream->SetLFO(rtTime, &m_Articulation.m_LFO.m_Registers);
        m_pStream->SetLFO(rtTime, &m_Articulation.m_LFO2.m_Registers);
    }
}

unsigned short g_nFilter[128] = {
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8020, 0x819d, 0x8303, 0x8455, 0x8595, 0x8756,
    0x886f, 0x89fe, 0x8af9, 0x8c5f, 0x8e1e, 0x8f57, 0x9081, 0x91f9,
    0x935a, 0x94a7, 0x95e2, 0x9756, 0x98b3, 0x99fe, 0x9b36, 0x9c99,
    0x9e1e, 0x9f57, 0xa0b2, 0xa1f9, 0xa35a, 0xa4a7, 0xa608, 0xa756,
    0xa8b3, 0xa9fe, 0xab55, 0xacb6, 0xae1d, 0xaf57, 0xb0b1, 0xb20f,
    0xb36f, 0xb4bb, 0xb61b, 0xb767, 0xb8c4, 0xba0d, 0xbb63, 0xbcc3,
    0xbe1d, 0xbf70, 0xc0bd, 0xc21a, 0xc36e, 0xc4c4, 0xc61a, 0xc76f,
    0xc8c2, 0xca13, 0xcb69, 0xccc1, 0xce1a, 0xcf6d, 0xd0c0, 0xd216,
    0xd36a, 0xd4bf, 0xd615, 0xd769, 0xd8bc, 0xda10, 0xdb65, 0xdcbc,
    0xde11, 0xdf62, 0xe0b6, 0xe208, 0xe35d, 0xe4b0, 0xe601, 0xe753,
    0xe8a6, 0xe9f7, 0xeb48, 0xec99, 0xede9, 0xef36, 0xf085, 0xf1d2,
    0xf31f, 0xf46a, 0xf5b4, 0xf6fc, 0xf842, 0xf988, 0xfacb, 0xfc0c,
    0xfd4b, 0xfe85, 0xffbe, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
    0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff,
};

static unsigned short CalcCutOff(PREL prPitch)

{
    prPitch += 6400;
    if (prPitch < 0) prPitch = 0;
    if (prPitch > 12700) prPitch = 12700;
    long lIndex = prPitch / 100;
    long lTemp = g_nFilter[lIndex] + 
        ((prPitch % 100) * (g_nFilter[lIndex+1] - g_nFilter[lIndex])) / 100;
    return (short) lTemp;
}

unsigned short g_nResonance[23] = {
    0x8000, 0x7214, 0x65ac, 0x5a9d, 0x50c3, 0x47fa, 0x4026, 0x392c,
    0x32f5, 0x2d6a, 0x287a, 0x2413, 0x2026, 0x1ca7, 0x198a, 0x16c3,
    0x1449, 0x1214, 0x101d, 0xe5c, 0xccc, 0xb68, 0xa2a,
};


static unsigned short CalcResonance(DWORD dwQ)

{
    if (dwQ > 22) dwQ = 22;
    return g_nResonance[dwQ];
}

/* Code to generate the tables:

#include "stdafx.h"
#include "stdio.h"
#include "math.h"

long m_spfCents[201];
long m_spfSemiTones[97];

void Init()
{
    long prRatio;
    double flTemp;

    for (prRatio = -100;prRatio <= 100;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 1200.0;
        flTemp = pow(2.0,flTemp);
        flTemp *= 4096.0;
        m_spfCents[prRatio + 100] = (long) flTemp;
    }
    
    for (prRatio = -48;prRatio <= 48;prRatio++)
    {
        flTemp = prRatio;
        flTemp /= 12.0;
        flTemp = pow(2.0,flTemp);
        flTemp *= 4096.0;
        m_spfSemiTones[prRatio + 48] = (long) flTemp;
    }
}

long PRELToPFRACT(long prPitch)
{
    long pfPitch = 0;
    long prOctave;
    if (prPitch > 100)
    {
//        if (prPitch > 4800)
//        {
//            prPitch = 4800;
//        }
        prOctave = prPitch / 100;
        prPitch = prPitch % 100;
        pfPitch = m_spfCents[prPitch + 100];
        pfPitch <<= prOctave / 12;
        prOctave = prOctave % 12;
        pfPitch *= m_spfSemiTones[prOctave + 48];
        pfPitch >>= 12;
    }
    else if (prPitch < -100)
    {
//        if (prPitch < -4800)
//        {
//            prPitch = -4800;
//        }
        prOctave = prPitch / 100;
        prPitch = (-prPitch) % 100;
        pfPitch = m_spfCents[100 - prPitch];
        pfPitch >>= ((-prOctave) / 12);
        prOctave = (-prOctave) % 12;
        pfPitch *= m_spfSemiTones[48 - prOctave];
        pfPitch >>= 12;
    }
    else
    {
        pfPitch = m_spfCents[prPitch + 100];
    }
    return (pfPitch);
}


unsigned long FreqToHardwareCoeff( float fFreq )
{
    float fNormCutoff = fFreq / 48000.0f;

    // Filter is ineffective out of these ranges, so why
    // bother even trying?
    if( fFreq < 30.0f )
        return 0x8000;
    if( fFreq > 8000.0f )
        return 0xffff;

    double fFC = float( 2.0f * sin( 3.1415926535897932384626433832795 * fNormCutoff ) );
    fFC = 4096.0f * log( fFC ) / log( 2.0f );
    long lOctaves = (long) fFC;

    return (unsigned long)lOctaves & 0xFFFF;
}

unsigned long dBToHardwareCoeff( long lResonance )
{
    float fResonance = (float)lResonance;

    if( fResonance > 22.5f )
        fResonance = 22.5f;

    double fQ = pow( 10.0, -0.05*fResonance);
    unsigned int dwQ = (unsigned int)(fQ*(1<<15));
    if( dwQ > 0xFFFF )
        dwQ = 0xFFFF;

    return (unsigned long)dwQ;
}

void GenerateQ()

{
    printf("short g_nResonance[23] = {\n    ");
    long dwIndent = 0;
    float flResonance;
    for (flResonance = 0; flResonance < 23; flResonance++)
    {
        if (dwIndent == 8)
        {
            printf("\n    ");
            dwIndent = 0;
        }
        dwIndent++;
        unsigned int pQ = dBToHardwareCoeff((long)flResonance);
        printf("0x%lx, ",(long)pQ);
    }
    printf("\n};\n");
}

void GenerateCutoff()

{
    Init();
    printf("short g_nFilter[128] = {\n    ");
    unsigned long dwIndent = 0;
    long prFilter;
    for (prFilter = (-64 * 100); prFilter < (64 * 100); prFilter += 100)
    {
        if (dwIndent == 8)
        {
            printf("\n    ");
            dwIndent = 0;
        }
        dwIndent++;
        // Now, we need to convert to a real frequency. The PREL values are relative
        // to A440, so get the sample rate by multiplying this relative pitch against 440Hz.
        unsigned long dwSampleRate = PRELToPFRACT(prFilter); 
        dwSampleRate = (440 * dwSampleRate) >> 12;
        unsigned int pF, pQ;
        pF = FreqToHardwareCoeff((float) dwSampleRate);
        char output[100];
        printf("0x%x, ",(long)pF);
    }
    printf("\n};\n");
}




int main(int argc, char* argv[])
{
	GenerateCutoff();
    GenerateQ();
	return 0;
}

*/

void CVoice::SendFilter(REFERENCE_TIME rtTime,BOOL fStart)

{
    DSFILTERDESC FilterDesc;
    // If this is a wave or DLS instrument that doesn't use filter, turn off filter if this
    // is the start.
    if (m_fUseFilter)
    {
        PREL prFilter;
        m_pPart->GetFilter(&prFilter);
        prFilter += m_prStartFilter;
        if (abs(prFilter - m_prLastFilter) >= 50)
        {
            DSFILTERDESC FilterDesc;
            FilterDesc.dwMode = DSFILTER_MODE_DLS2;
            FilterDesc.adwCoefficients[0] = CalcCutOff(prFilter-6900);
            FilterDesc.adwCoefficients[1] = CalcResonance(m_wFilterQ);
            FilterDesc.adwCoefficients[2] = 0;
            FilterDesc.adwCoefficients[3] = 0;
            FilterDesc.dwQCoefficient = 0;
            m_prLastFilter = prFilter;
            if (m_pBuffer)
            {
                m_pBuffer->SetFilter(rtTime,&FilterDesc);
            }
            else if (m_pStream)
            {
                m_pStream->SetFilter(rtTime,&FilterDesc);
            }
        }
        else
        {
            if (fStart)
            {
                m_prLastFilter = 0;
                FilterDesc.dwMode = DSFILTER_MODE_BYPASS;
                FilterDesc.adwCoefficients[0] = 0;
                FilterDesc.adwCoefficients[1] = 0;
                FilterDesc.adwCoefficients[2] = 0;
                FilterDesc.adwCoefficients[3] = 0;
                FilterDesc.dwQCoefficient = 0;
                if (m_pBuffer)
                {
                    m_pBuffer->SetFilter(rtTime,&FilterDesc);
                }
                else if (m_pStream)
                {
                    m_pStream->SetFilter(rtTime,&FilterDesc);
                }
            }
        }
/*      Testing parametric eq...
        // Now, we need to convert to a real frequency. The PREL values are relative
        // to A440, so get the samplerate by multiplying this relative pitch against 440Hz.
        static double fSampleRate = 100;
        fSampleRate *= 1.1;
        if (fSampleRate > 14000) fSampleRate = 50;
        FilterDesc.dwMode = DSFILTER_MODE_PARAMEQ;
        unsigned int pF, pQ;
        DlsToChamberlin(fSampleRate,10,&pF,&pQ);
        FilterDesc.adwCoefficients[0] = 1;
        FilterDesc.adwCoefficients[1] = 1;
        FilterDesc.adwCoefficients[2] = pF;
        FilterDesc.adwCoefficients[3] = pQ;
        FilterDesc.dwQCoefficient = 3;
        m_pBuffer->SetFilter(rtTime,&FilterDesc);*/

    }
}

void CVoice::SendVolume(REFERENCE_TIME rtTime)

{
    BOOL fBuffer = (m_pBuffer && !m_fStreamed);
    if (fBuffer || (m_fStreamed && m_pStream))
    {
        if (m_BusIds.HasBuffer())
        {
            // If we are sending to a buffer, then we just call SetVolume since there are no mixbins.
            VREL vrVolume;
            m_pPart->GetVolume(m_vrStartVolume,0,&vrVolume,NULL,NULL,NULL,NULL);
            CLAMP_VOLUME(vrVolume);
            if (abs(vrVolume - m_vrLastVolumes[0]) >= 10)
            {
                if (fBuffer)
                {
                    m_pBuffer->SetVolume(rtTime,vrVolume);
                }
                else 
                {
                    m_pStream->SetVolume(rtTime,vrVolume);
                }
                m_vrLastVolumes[0] = vrVolume;
            }
        }
        else if (m_BusIds.m_bControllers[0]) // Is this a multi-mixbin buffer?
        { 
            VREL vrVolumes[8];
            BOOL fChanged = false;
            m_pPart->GetVolume(m_vrStartVolume,m_BusIds.m_bControllers,vrVolumes);
            for (DWORD dwX = 0; m_BusIds.m_bControllers[dwX];dwX++)
            {
                CLAMP_VOLUME(vrVolumes[dwX]);
                if (abs(vrVolumes[dwX] - m_vrLastVolumes[dwX]) >= 10)
                {
                    m_vrLastVolumes[dwX] = vrVolumes[dwX];
                    fChanged = true;
                }
            }
            if (fChanged)
            {
                CMIXBINS MixBins;
                MixBins.CreateFromMask(m_BusIds.m_dwMixBins);
                MixBins.PokeMixBinVolumesBasedOnMask(m_BusIds.m_dwMixBins, (long *)vrVolumes);
                if (fBuffer)
                {
                    m_pBuffer->SetMixBinVolumes(rtTime,MixBins.GetMixBins());
                }
                else 
                {
                    m_pStream->SetMixBinVolumes(rtTime,MixBins.GetMixBins());
                }
            }
        } 
        else if ((m_BusIds.m_dwMixBins & ((1 << DSMIXBIN_FRONT_LEFT) | (1 << DSMIXBIN_FRONT_RIGHT))) == 
                ((1 << DSMIXBIN_FRONT_LEFT) | (1 << DSMIXBIN_FRONT_RIGHT)))
        {
            VREL vrVolumes[4];
            m_pPart->GetVolume(m_vrStartVolume,m_lDefaultPan,NULL,&vrVolumes[0],&vrVolumes[1],&vrVolumes[2],&vrVolumes[3]);
            CLAMP_VOLUME(vrVolumes[0]);
            CLAMP_VOLUME(vrVolumes[1]);
            CLAMP_VOLUME(vrVolumes[2]);
            CLAMP_VOLUME(vrVolumes[3]);
            if ((abs(vrVolumes[0] - m_vrLastVolumes[0]) >= 10) ||
                (abs(vrVolumes[1] - m_vrLastVolumes[1]) >= 10) ||
                (abs(vrVolumes[2] - m_vrLastVolumes[2]) >= 10) ||
                (abs(vrVolumes[3] - m_vrLastVolumes[3]) >= 10))
            {
                CMIXBINS MixBins;
                MixBins.CreateFromMask(m_BusIds.m_dwMixBins);
                MixBins.PokeMixBinVolumesBasedOnMask(m_BusIds.m_dwMixBins, vrVolumes);                
                if (fBuffer)
                {
                    m_pBuffer->SetMixBinVolumes(rtTime,MixBins.GetMixBins());
                }
                else 
                {
                    m_pStream->SetMixBinVolumes(rtTime,MixBins.GetMixBins());
                }
                m_vrLastVolumes[0] = vrVolumes[0];
                m_vrLastVolumes[1] = vrVolumes[1];
                m_vrLastVolumes[2] = vrVolumes[2];
                m_vrLastVolumes[3] = vrVolumes[3];
            }
        }   
        // Then, the case of the one side of a stereo wave
        else 
        {
            VREL vrVolumes[3];
            m_pPart->GetVolume(m_vrStartVolume,m_lDefaultPan,&vrVolumes[0],NULL,NULL,&vrVolumes[1],&vrVolumes[2]);
            CLAMP_VOLUME(vrVolumes[0]);
            CLAMP_VOLUME(vrVolumes[1]);
            CLAMP_VOLUME(vrVolumes[2]);
            if ((abs(vrVolumes[0] - m_vrLastVolumes[0]) >= 10) ||
                (abs(vrVolumes[1] - m_vrLastVolumes[1]) >= 10) ||
                (abs(vrVolumes[2] - m_vrLastVolumes[2]) >= 10))
            {
                CMIXBINS MixBins;
                MixBins.CreateFromMask(m_BusIds.m_dwMixBins);
                MixBins.PokeMixBinVolumesBasedOnMask(m_BusIds.m_dwMixBins, (long *)vrVolumes);
                if (fBuffer)
                {
                    m_pBuffer->SetMixBinVolumes(rtTime,MixBins.GetMixBins());
                }
                else
                {
                    m_pStream->SetMixBinVolumes(rtTime,MixBins.GetMixBins());
                }
                m_vrLastVolumes[0] = vrVolumes[0];
                m_vrLastVolumes[1] = vrVolumes[1];
                m_vrLastVolumes[2] = vrVolumes[2];
            }
        }      
    }
}

BOOL CVoice::StartVoice(CSynth *pSynth,
                        CSourceRegion *pRegion, REFERENCE_TIME rtStartTime,
                        CBusIds * pBusIds,
                        WORD nKey,WORD nVelocity,
                        VREL vrVolume,
                        VREL vrMIDIVolume,
                        PREL prPitch,
                        PREL prMIDIPitch)
{
    m_pSynth = pSynth;  
    m_fWave = FALSE;
    m_fStreamed = FALSE;
    m_BusIds = *pBusIds;

    memset(&m_vrLastVolumes[0],0,sizeof(VREL)*8);
    m_prLastPitch = m_prLastFilter = 0;
    if (pRegion->m_pArticulation == NULL)
    {
        return FALSE;
    }

    // If this is multichannel, that means this is a component of a larger wave. 
    // So, force it to play on the appropriate channel.
    if (!m_BusIds.HasBuffer() && pRegion->IsMultiChannel())
    {
        if (pRegion->m_dwChannel & WAVELINK_CHANNEL_RIGHT)
        {
            // Right side.
            m_BusIds.m_dwMixBins &= ~(1 << DSMIXBIN_FRONT_LEFT);
        }
        else
        {
            // Left side.
            m_BusIds.m_dwMixBins &= ~(1 << DSMIXBIN_FRONT_RIGHT);
        }
    }


    m_Articulation = *pRegion->m_pArticulation;
    m_dwLoopType = pRegion->m_Sample.m_dwLoopType;

    m_dwGroup = pRegion->m_bGroup;
    m_fAllowOverlap = pRegion->m_bAllowOverlap;

    m_vrStartVolume = VelocityToVolume(nVelocity);

    m_vrStartVolume += pRegion->m_vrAttenuation;

    m_lDefaultPan = m_Articulation.m_sDefaultPan;
  
    // Now, scale the attack, hold, and decay times as appropriate by the velocity and midi note.
    m_Articulation.m_VolumeEG.m_Registers.dwAttack *= 
        CDigitalAudio::PRELToPFRACT(nVelocity * m_Articulation.m_VolumeEG.m_trVelAttackScale / 127);
    m_Articulation.m_VolumeEG.m_Registers.dwAttack /= 4096;
    FORCEBOUNDS(m_Articulation.m_VolumeEG.m_Registers.dwAttack,0,3750);

    m_Articulation.m_PitchEG.m_Registers.dwAttack *= 
        CDigitalAudio::PRELToPFRACT(nVelocity * m_Articulation.m_PitchEG.m_trVelAttackScale / 127);
    m_Articulation.m_PitchEG.m_Registers.dwAttack /= 4096;
    FORCEBOUNDS(m_Articulation.m_PitchEG.m_Registers.dwAttack,0,3750);

    m_Articulation.m_VolumeEG.m_Registers.dwHold  *= 
        CDigitalAudio::PRELToPFRACT(nKey * m_Articulation.m_VolumeEG.m_trKeyDecayScale / 127);
    m_Articulation.m_VolumeEG.m_Registers.dwHold  /= 4096;
    FORCEBOUNDS(m_Articulation.m_VolumeEG.m_Registers.dwHold,0,3750);

    m_Articulation.m_PitchEG.m_Registers.dwHold  *= 
        CDigitalAudio::PRELToPFRACT(nKey * m_Articulation.m_PitchEG.m_trKeyDecayScale / 127);
    m_Articulation.m_PitchEG.m_Registers.dwHold  /= 4096;
    FORCEBOUNDS(m_Articulation.m_PitchEG.m_Registers.dwHold,0,3750);

    m_Articulation.m_VolumeEG.m_Registers.dwDecay *= 
        CDigitalAudio::PRELToPFRACT(nKey * m_Articulation.m_VolumeEG.m_trKeyDecayScale / 127);
    m_Articulation.m_VolumeEG.m_Registers.dwDecay /= 4096;
    FORCEBOUNDS(m_Articulation.m_VolumeEG.m_Registers.dwDecay,0,3750);

    m_Articulation.m_PitchEG.m_Registers.dwDecay *= 
        CDigitalAudio::PRELToPFRACT(nKey * m_Articulation.m_PitchEG.m_trKeyDecayScale / 127);
    m_Articulation.m_PitchEG.m_Registers.dwDecay /= 4096;
    FORCEBOUNDS(m_Articulation.m_PitchEG.m_Registers.dwDecay,0,3750);

    // Make sure we have a pointer to the wave ready:
    if ((pRegion->m_Sample.m_pWave == NULL) || (pRegion->m_Sample.m_pWave->m_pnWave == NULL))
    {
        return (FALSE);     // Do nothing if no sample.
    }

    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_fSustainOn = FALSE;
    m_rtStartTime = rtStartTime;
    m_rtStopTime = 0x7fffffffffffffff;
//    m_DigitalAudio.m_Source = pRegion->m_Sample;

    pRegion->m_Sample.m_pWave->AddRef(); // Keeps track of Wave usage.
    pRegion->m_Sample.m_pWave->PlayOn();

//    m_pCurrentBuffer = 0;
//    m_DigitalAudio.m_pWaveArt = NULL;
    XBOXADPCMWAVEFORMAT *pWaveFormat = &pRegion->m_Sample.m_pWave->m_WaveFormat;

    if (SUCCEEDED(AllocateBuffer(pWaveFormat)))
    {
        DWORD dwSamplesPerBlock = 1;
        if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
        {
            dwSamplesPerBlock = 64;
        }
        // Now that we have a buffer, set the output.
        if (pBusIds->HasBuffer())
        {
            IDirectSoundBuffer* pBuffer = pBusIds->GetBuffer();
            m_pBuffer->SetOutputBuffer(0,pBuffer);
            pBuffer->Release();
        }
        else
        {
    //        Trace(-1,"%ld: Setting Mix Bins %lx on buffer %lx\n",(long) rtStartTime,pBusIds->m_dwMixBins,m_pBuffer);
            CMIXBINS MixBins;
            MixBins.CreateFromMask(m_BusIds.m_dwMixBins);
            m_pBuffer->SetMixBins(0,MixBins.GetMixBins());
        }

        // Pitch to frequency

        prPitch += pRegion->m_prTuning;
        CSourceSample* pSample = &pRegion->m_Sample;
        long lKey = (long) nKey;
        prPitch += pSample->m_prFineTune;
        prPitch += ((lKey - pSample->m_bMIDIRootKey) * 100);
        prPitch += RatioToPREL((float)pWaveFormat->wfx.nSamplesPerSec / (float) 48000);
        m_prStartPitch = prPitch;   // Store this as the base pitch.

        SendPitch(0);
        SendVolume(0);

        m_fUseFilter = (m_Articulation.m_Filter.m_prCutoff != 0x7FFF);
        m_prStartFilter = m_Articulation.m_Filter.m_prCutoff + 
            ((nVelocity * m_Articulation.m_Filter.m_prVelScale) / 127) + 
            ((nKey * m_Articulation.m_Filter.m_prKeyScale) / 127);
        m_wFilterQ = m_Articulation.m_Filter.m_vrQ / 10;
        SendFilter(0,TRUE);
        
        m_pBuffer->SetBufferData(0, pRegion->m_Sample.m_pWave->m_pnWave, pRegion->m_Sample.m_pWave->m_dwSampleDataSize);

        m_pBuffer->SetEG(0, &m_Articulation.m_VolumeEG.m_Registers);
        m_pBuffer->SetEG(0, &m_Articulation.m_PitchEG.m_Registers);

        SendLFOs(0);

        DWORD dwflag = 0;
        if(!pRegion->m_Sample.m_bOneShot)
        {
            // If there are loop points, convert to byte positions. 
            DWORD dwByteStart = (pRegion->m_Sample.m_dwLoopStart * pWaveFormat->wfx.nBlockAlign) / dwSamplesPerBlock;
            DWORD dwByteEnd = (pRegion->m_Sample.m_dwLoopEnd * pWaveFormat->wfx.nBlockAlign) / dwSamplesPerBlock;
            if(dwByteEnd > pRegion->m_Sample.m_pWave->m_dwSampleDataSize)
            {
                dwByteEnd = pRegion->m_Sample.m_pWave->m_dwSampleDataSize;
            }
            if (dwByteEnd > dwByteStart)
            {
                m_pBuffer->SetLoopRegion(0, dwByteStart, dwByteEnd - dwByteStart);
                dwflag = DSBPLAY_LOOPING;
            }
        }
    

        m_pBuffer->Play(rtStartTime, 0, 0, dwflag);
        return (TRUE);
    }
    return (FALSE);
}


BOOL CVoice::StartWave(CSynth *pSynth,
                       CSourceWave *pWave,
                       DWORD dwVoiceId,
                       REFERENCE_TIME rtStartTime,
                       CBusIds * pBusIds,
                       VREL vrVolume,
                       VREL vrMIDIVolume,
                       PREL prPitch,
                       PREL prMIDIPitch,
                       DWORD dwVoiceStart,
                       DWORD dwLoopStart,
                       DWORD dwLoopEnd
                       )
{
    m_pSynth = pSynth;
    m_fWave = TRUE;
    m_fStreamed = FALSE;
    m_BusIds = *pBusIds;
    memset(&m_vrLastVolumes[0],0,sizeof(VREL)*8);
    m_prLastPitch = m_prLastFilter = 0;
    m_Articulation = pWave->m_Articulation;

    // If this is multichannel, that means this is a component of a larger wave. 
    // So, force it to play on the appropriate channel.
/*    if (!m_BusIds.HasBuffer() && pWaveArt->m_WaveArtDl.usOptions & F_WAVELINK_MULTICHANNEL)
    {
        if (pWaveArt->m_WaveArtDl.ulBus == 1)
        {
            // Right side.
            m_BusIds.m_dwMixBins &= ~(1 << DSMIXBIN_FRONT_LEFT);
        }
        else
        {
            // Left side.
            m_BusIds.m_dwMixBins &= ~(1 << DSMIXBIN_FRONT_RIGHT);
        }
    }*/

    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_rtStartTime = rtStartTime;
    m_rtStopTime = 0x7fffffffffffffff; 
    m_dwGroup = 0;
    m_lDefaultPan = 0;
    m_fAllowOverlap = FALSE;    
    m_fSustainOn = FALSE;
    m_dwVoiceId = dwVoiceId;

    pWave->m_bActive = TRUE;
    pWave->AddRef();

    if (SUCCEEDED(AllocateBuffer(&pWave->m_WaveFormat)))
    {

        // Now that we have a buffer, set the output.
        if (pBusIds->HasBuffer())
        {
            IDirectSoundBuffer* pBuffer = pBusIds->GetBuffer();
            m_pBuffer->SetOutputBuffer(0,pBuffer);
            pBuffer->Release();
        }
        else
        {
            CMIXBINS MixBins;
            MixBins.CreateFromMask(m_BusIds.m_dwMixBins);
            m_pBuffer->SetMixBins(0,MixBins.GetMixBins());

        }

        prPitch += RatioToPREL((float)pWave->m_WaveFormat.wfx.nSamplesPerSec / (float) 48000);
        m_prStartPitch = prPitch;   // Store this as the base pitch.
        SendPitch(0);
        m_vrStartVolume = vrVolume;
        SendVolume(0);
        DWORD dwSampleLength = pWave->m_dwSampleCount;
        DWORD dwSamplesPerBlock = 1;
        if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
        {
            dwSamplesPerBlock = 64;
        }
        dwVoiceStart = (dwVoiceStart * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;
        dwSampleLength = (dwSampleLength * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;
        dwSampleLength -= dwVoiceStart;
        dwLoopEnd = (dwLoopEnd * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;
        dwLoopStart = (dwLoopStart * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;

        m_pBuffer->SetBufferData(0, &pWave->m_pnWave[dwVoiceStart/2], dwSampleLength);

        m_fUseFilter = (m_Articulation.m_Filter.m_prCutoff != 0x7FFF);
        m_prStartFilter = m_Articulation.m_Filter.m_prCutoff;
        m_wFilterQ = m_Articulation.m_Filter.m_vrQ / 10;
        SendFilter(0,TRUE);
        
        m_pBuffer->SetEG(0, &m_Articulation.m_VolumeEG.m_Registers);
        m_pBuffer->SetEG(0, &m_Articulation.m_PitchEG.m_Registers);

        SendLFOs(0);

        DWORD dwflag = 0;
        if ((dwLoopEnd > dwVoiceStart) && (dwLoopStart >= dwVoiceStart))
        {
            dwLoopEnd -= dwVoiceStart;
            dwLoopStart -= dwVoiceStart;
            if(dwLoopEnd > dwSampleLength)
            {
                dwLoopEnd = dwSampleLength;
            }
            if (dwLoopEnd > dwLoopStart)
            {
                m_pBuffer->SetLoopRegion(rtStartTime, dwLoopStart, (dwLoopEnd - dwLoopStart));
                dwflag = DSBPLAY_LOOPING;
            }
        }
        m_pBuffer->Play(rtStartTime, 0, 0, dwflag);
        return (TRUE);
    }
    return (FALSE);
}

BOOL CVoice::StartStreamedWave(CSynth *pSynth,
                       CSourceWave *pWave,
                       DWORD dwVoiceId,
                       REFERENCE_TIME rtStartTime,
                       CBusIds * pBusIds,
                       VREL vrVolume, VREL vrMIDIVolume,
                       PREL prPitch, PREL prMIDIPitch,
                       DWORD dwVoiceStart,
                       DWORD dwLoopStart,
                       DWORD dwLoopEnd)
{
    m_pSynth = pSynth;
    m_fWave = TRUE;
    m_fStreamed = TRUE;
    m_BusIds = *pBusIds;
    memset(&m_vrLastVolumes[0],0,sizeof(VREL)*8);
    m_prLastPitch = m_prLastFilter = 0;
    m_Articulation = pWave->m_Articulation;


    // If this is multichannel, that means this is a component of a larger wave. 
    // So, force it to play on the appropriate channel.
/*    if (!m_BusIds.HasBuffer() && pWaveArt->m_WaveArtDl.usOptions & F_WAVELINK_MULTICHANNEL)
    {
        if (pWaveArt->m_WaveArtDl.ulBus == 1)
        {
            // Right side.
            m_BusIds.m_dwMixBins &= ~(1 << DSMIXBIN_FRONT_LEFT);
        }
        else
        {
            // Left side.
            m_BusIds.m_dwMixBins &= ~(1 << DSMIXBIN_FRONT_RIGHT);
        }
    }*/


    // Initialize an envelope for wave playing 
    //

    m_fNoteOn = TRUE;
    m_fTag = FALSE;
    m_rtStartTime = rtStartTime;
    m_rtStopTime = 0x7fffffffffffffff; 
    m_dwGroup = 0;
    m_lDefaultPan = 0;
    m_fAllowOverlap = FALSE;    
    m_fSustainOn = FALSE;
    m_dwVoiceId = dwVoiceId;

    if(m_pStream)
    {
        m_pStream->Release();
        m_pStream = 0;
    }
    
    DSSTREAMDESC dssd;

    ZeroMemory(&dssd, sizeof(dssd));
    
    dssd.dwFlags = DSSTREAMCAPS_CTRLFREQUENCY | DSSTREAMCAPS_CTRLVOLUME | DSSTREAMCAPS_ACCURATENOTIFY;
    dssd.dwMaxAttachedPackets = VOICE_NUM_PACKETS;
    dssd.lpwfxFormat = (LPWAVEFORMATEX) &pWave->m_WaveFormat;
    m_WaveFormat = pWave->m_WaveFormat;


    if (FAILED(GetSequencer()->CreateStream(&dssd, &m_pStream)))
    {
        return FALSE;
    }

    if (pBusIds->HasBuffer())
    {
        IDirectSoundBuffer* pBuffer = pBusIds->GetBuffer();
        m_pStream->SetOutputBuffer(0,pBuffer);
        pBuffer->Release();
    }
    else
    {
        CMIXBINS MixBins;
        MixBins.CreateFromMask(m_BusIds.m_dwMixBins);
        m_pStream->SetMixBins(0,MixBins.GetMixBins());
    }

    prPitch += RatioToPREL((float)pWave->m_WaveFormat.wfx.nSamplesPerSec / (float) 48000);
    m_prStartPitch = prPitch;   // Store this as the base pitch.
    SendPitch(0);

    m_vrStartVolume = vrVolume;
    SendVolume(0);

    m_fUseFilter = (m_Articulation.m_Filter.m_prCutoff != 0x7FFF);
    m_prStartFilter = m_Articulation.m_Filter.m_prCutoff;
    m_wFilterQ = m_Articulation.m_Filter.m_vrQ / 10;
    SendFilter(0,TRUE);
    
    m_pStream->SetEG(0, &m_Articulation.m_VolumeEG.m_Registers);
    m_pStream->SetEG(0, &m_Articulation.m_PitchEG.m_Registers);

    SendLFOs(0);

    DWORD dwSamplesPerBlock = 1;
    if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
    {
        dwSamplesPerBlock = 64;
    }
    
    m_dwStreamPosition = (dwVoiceStart * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;
    m_dwLoopEnd = (dwLoopEnd * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;
    m_dwLoopStart = (dwLoopStart * m_WaveFormat.wfx.nBlockAlign) / dwSamplesPerBlock;
    
    // Allocate the buffers.
    m_dwBufferSize = (DWORD)(pWave->m_rtReadAheadTime / 10000);
    if (m_dwBufferSize < 50) m_dwBufferSize = 50;
    m_dwBufferSize *= m_WaveFormat.wfx.nSamplesPerSec;
    m_dwBufferSize += 500;
    m_dwBufferSize /= 1000;
    if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
    {
        m_dwBufferSize += 32;
        m_dwBufferSize /= 64;
    }
    m_dwBufferSize *= m_WaveFormat.wfx.nBlockAlign;
    DWORD dwPacket = 0;
    for (; dwPacket < VOICE_NUM_PACKETS; dwPacket++)
    {
        if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
        {        
            m_pvBuffer[dwPacket] = DirectMusicPhysicalAllocI(m_dwBufferSize);
        }
        else
        {
            m_pvBuffer[dwPacket] = new BYTE[m_dwBufferSize];
        }
        assert(m_pvBuffer[dwPacket]);
        if(!m_pvBuffer[dwPacket])
        {
            return false; // Out of physical memory. Eep!
        }
    }

    m_pWave = pWave;
    pWave->AddRef();
    m_wPacketsSubmitted = 0;
    m_wCurrentPacket = 0;
    memset(m_dwPacketIndex,0,sizeof(m_dwPacketIndex));

    for (; m_wCurrentPacket < VOICE_NUM_PACKETS; )
    {
        if (FAILED(WritePacket(rtStartTime,m_wCurrentPacket++)))
        {
            break;
        }
    }
    m_wCurrentPacket %= VOICE_NUM_PACKETS;
    return (TRUE);
}

HRESULT CVoice::WritePacket(REFERENCE_TIME rtTime,DWORD dwPacket)

{
    HRESULT hr = E_FAIL;
    if (m_dwStreamPosition < m_pWave->m_dwSampleDataSize)
    {
        DWORD dwPacketSize = m_dwBufferSize;
        if (m_dwLoopEnd && ((m_dwStreamPosition + dwPacketSize) > m_dwLoopEnd))
        {
            dwPacketSize = m_dwLoopEnd - m_dwStreamPosition;
            hr = m_pWave->Read(m_dwStreamPosition,(BYTE*) m_pvBuffer[dwPacket],dwPacketSize);
            m_dwStreamPosition = m_dwLoopStart;
        }
        else 
        {
            if ((m_dwStreamPosition + dwPacketSize) > m_pWave->m_dwSampleDataSize)
            {
                // If this is longer than the rest of the wave, read just what's needed.
                dwPacketSize = m_pWave->m_dwSampleDataSize - m_dwStreamPosition;
            }
            hr = m_pWave->Read(m_dwStreamPosition,(BYTE*) m_pvBuffer[dwPacket],dwPacketSize);
            m_dwStreamPosition += dwPacketSize;
        }
        if (SUCCEEDED(hr))
        {
            XMEDIAPACKET xmp;
            memset(&xmp,0,sizeof(xmp));
            xmp.pvBuffer = m_pvBuffer[dwPacket];
            xmp.dwMaxSize = dwPacketSize;      
            hr = m_pStream->Process(rtTime, &xmp, &m_dwPacketIndex[dwPacket]);
            m_wPacketsSubmitted++;
        }
    }
    return hr;
}

bool CVoice::StreamDoWork(REFERENCE_TIME rtNow)
{
    DWORD dwPacketStatus;
    if (rtNow > m_rtStartTime)
    {
        rtNow = 0;
    }
    else
    {
        rtNow = m_rtStartTime;
    }
    HRESULT hr = S_OK;
    for (;SUCCEEDED(hr);)
    {
        m_pStream->GetPacketStatus(m_dwPacketIndex[m_wCurrentPacket], &dwPacketStatus);
        if (dwPacketStatus != XMEDIAPACKET_STATUS_PENDING)
        {
            // Packet is no longer pending, so we can write to it again...
            hr = WritePacket(rtNow,m_wCurrentPacket++);
            m_wCurrentPacket %= VOICE_NUM_PACKETS;
        }
        else
        {
            break;
        }
    }
    return SUCCEEDED(hr);
}

/*SAMPLE_POSITION CVoice::GetCurrentPos()
{
    // TODO: Figure out why returning m_stStreamPosition sometimes causes the higher levels
    // to get ahead of us and try to refresh an active buffer.
    // (See Xbox bug 5956 DMusic: Streaming waves play back incorrectly; tons of debug spew.)

    // Trace(-1,"Reporting stream position %d\n", (DWORD) m_stStreamPosition);
    return m_dwStreamPosition;
}*/
    
void CVoice::ClearVoice()
{
    m_fInUse = FALSE;
    if(m_pBuffer)
    {
        m_pBuffer->Clear();
        m_pBuffer->SetBufferData(0,NULL,0);
        m_pBuffer->SetOutputBuffer(0,NULL);
        // Release the buffer so it will go back to the dsound pool.
        m_pBuffer->Release(); 
        m_pBuffer = NULL;
    }
    if(m_pStream)
    {
        m_pStream->Clear();
        m_pStream->Flush(0);
        // Release the stream so it will go back to the dsound pool. For some reason,
        // this was not enabled before. Need to make sure this is stable...
        m_pStream->Release();
        m_pStream = NULL;
    }
    if (m_pWave)
    {
        m_pWave->Release();
        m_pWave = NULL;
    }
    for(int i = 0; i < VOICE_NUM_PACKETS; i++)
    {
        if(m_pvBuffer[i])
        {
            if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
            {
                DirectMusicPhysicalFreeI(m_pvBuffer[i]);
            }
            else
            {
                delete [] m_pvBuffer[i];
            }
            m_pvBuffer[i] = NULL;
        }
    }
}

void CVoice::DoWork(CSynth* pSynth)

{
    if (!m_fNoteOn) 
    {
        if(m_pBuffer)
        {
            DWORD dwStatus;
            m_pBuffer->GetStatus(&dwStatus);
            if( dwStatus == 0 ) // Sound stopped playing
            {
                ClearVoice();
            }
            else
            {
                // If this has been playing for 40 seconds after the stop time, it's somehow stuck on. Kill it.
                REFERENCE_TIME now;
                pSynth->m_MasterClock.GetTime(&now);
                if (now > (m_rtStopTime + (10000 * 40 * 1000)))
                {
                    ClearVoice();
                }
            }
        }
    }
    else
    {
        if (m_pStream && m_fInUse)
        {
            REFERENCE_TIME now;
            pSynth->m_MasterClock.GetTime(&now);
            m_fInUse = StreamDoWork(now); 
            if (!m_fInUse) 
            {
                ClearVoice();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\umsynth.h ===
//      Copyright (c) 1996-1999 Microsoft Corporation
// UMSynth.h : Declaration of CUserModeSynth

#ifndef __UMSYNTH_H_
#define __UMSYNTH_H_

#include <ks.h>
#include <ksproxy.h>
#include <mmsystem.h>
#include "dmusicc.h"
#include "dmusics.h"
#include "CSynth.h"
#include "synth.h"
#include "..\shared\xsoundp.h" // For IDirectSoundSource
#include "..\shared\dmusiccp.h" // For class ids.
class CUserModeSynth;

// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.  See ddkreadme.txt for more info.
#if 0 // The following section will only take affect in the DDK sample.
// @@END_DDKSPLIT
// {F5038F82-C052-11D2-872F-00600893B1BD}
DEFINE_GUID(CLSID_DDKSynth, 
0xf5038f82, 0xc052, 0x11d2, 0x87, 0x2f, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);
// @@BEGIN_DDKSPLIT -- This section will be removed in the DDK sample.
#endif
// @@END_DDKSPLIT

typedef HRESULT (CUserModeSynth::*GENPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG cbBuffer);

#define GENPROP_F_STATIC                0x00000000
#define GENPROP_F_FNHANDLER             0x00000001


#include <pshpack4.h>
struct GENERICPROPERTY
{
    const GUID *pguidPropertySet;       // What property set?
    ULONG       ulId;                   // What item?

    ULONG       ulSupported;            // Get/Set flags for QuerySupported

    ULONG       ulFlags;                // GENPROP_F_xxx

    LPVOID      pPropertyData;          // Data to be returned
    ULONG       cbPropertyData;         // and its size    

    GENPROPHANDLER pfnHandler;          // Handler fn iff GENPROP_F_FNHANDLER
};
#include <poppack.h>


class CClock : public IReferenceClock
{
friend class CUserModeSynth;
public:

    CClock();

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /* IReferenceClock methods */
    HRESULT STDMETHODCALLTYPE GetTime( 
        /* [out] */ REFERENCE_TIME __RPC_FAR *pTime);
    
    HRESULT STDMETHODCALLTYPE AdviseTime( 
        /* [in] */ REFERENCE_TIME baseTime,
        /* [in] */ REFERENCE_TIME streamTime,
        /* [in] */ HANDLE hEvent,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
        /* [in] */ REFERENCE_TIME startTime,
        /* [in] */ REFERENCE_TIME periodTime,
        /* [in] */ HANDLE hSemaphore,
        /* [out] */ DWORD __RPC_FAR *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE Unadvise( 
        /* [in] */ DWORD dwAdviseCookie);
private:
    CUserModeSynth *	m_pParent;      // Pointer to parent structure.
    DWORD               m_dwLastPosition;
    LONGLONG            m_llSampleTime;
};


/////////////////////////////////////////////////////////////////////////////
// CDMSynth

class CUserModeSynth : public IDirectMusicSynthX, public IKsControl
{
friend class CClock;

public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicSynthX
public:
	virtual STDMETHODIMP Open(LPDMUS_PORTPARAMS pPortParams);
	virtual STDMETHODIMP Close(); 
	virtual STDMETHODIMP SetNumChannelGroups(DWORD dwGroups);
    virtual STDMETHODIMP SetMasterVolume(LONG lVolume);
    virtual STDMETHODIMP SendShortMsg(REFERENCE_TIME rt, DWORD dwGroup, DWORD dwMsg);
    virtual STDMETHODIMP SendLongMsg(REFERENCE_TIME rt, DWORD dwGroup, BYTE *pbMsg, DWORD dwLength);
//	virtual STDMETHODIMP Download(LPHANDLE phDownload, LPVOID pvData, LPBOOL pbFree);
//	virtual STDMETHODIMP Unload(HANDLE hDownload,
//								HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE),
//								HANDLE hUserData);

//	virtual STDMETHODIMP PlayBuffer(REFERENCE_TIME rt, LPBYTE pbBuffer, DWORD cbBuffer);
//	virtual STDMETHODIMP GetRunningStats(LPDMUS_SYNTHSTATS pStats);
//	virtual STDMETHODIMP GetPortCaps(LPDMUS_PORTCAPS pCaps);
	virtual STDMETHODIMP GetMasterClock(IReferenceClock **ppClock);
//	virtual STDMETHODIMP GetLatencyClock(IReferenceClock **ppClock);
//	virtual STDMETHODIMP Activate(BOOL fEnable);
//	virtual STDMETHODIMP SetSynthSink(IDirectMusicSynthSink *pSynthSink);
//	virtual STDMETHODIMP Render(short *pBuffer, DWORD dwLength, LONGLONG llPosition);
    virtual STDMETHODIMP SetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, DWORD dwPriority);
    virtual STDMETHODIMP GetChannelPriority(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwPriority);
//    virtual STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, LPDWORD pdwWaveFormatExSize);
//    virtual STDMETHODIMP GetAppend(DWORD* pdwAppend);

	virtual STDMETHODIMP PlayWave(REFERENCE_TIME rt, DWORD dwChannelGroup, DWORD dwChannel, PREL prPitch, VREL vrVolume, SAMPLE_TIME stVoiceStart, SAMPLE_TIME stLoopStart, SAMPLE_TIME stLoopEnd, IDirectSoundWave *pIWave, DWORD *pdwVoiceID );
    virtual STDMETHODIMP StopWave(REFERENCE_TIME rt, DWORD dwVoiceId );
//    virtual STDMETHODIMP GetVoiceState(DWORD dwVoice[], DWORD cbVoice, DMUS_VOICE_STATE VoiceState[] );
//    virtual STDMETHODIMP Refresh(DWORD dwDownloadID, DWORD dwFlags );
    virtual STDMETHODIMP AssignChannelToOutput(DWORD dwChannelGroup, DWORD dwChannel, IDirectSoundBuffer *pBuffer,DWORD dwMixBins, BYTE *pbControllers );

// IDirectSoundSource
/*public:
    virtual STDMETHODIMP GetFormat(LPWAVEFORMATEX pWaveFormatEx, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten);
    virtual STDMETHODIMP SetSink(IDirectSoundConnect* pSinkConnect);
    virtual STDMETHODIMP Seek(ULONGLONG sp);
    virtual STDMETHODIMP Read(LPVOID *ppvBuffer, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchBends, DWORD cpvBuffer, PULONGLONG pcb);
	virtual STDMETHODIMP GetSize(PULONGLONG pcb);*/

// IDirectSoundSource : members 
private:
//	ULONGLONG m_ullPosition;

// IKsControl
public:
 	virtual STDMETHODIMP KsProperty(
		PKSPROPERTY pPropertyIn, 
		ULONG ulPropertyLength,
		LPVOID pvPropertyData, 
		ULONG ulDataLength,
		PULONG pulBytesReturned);

    virtual STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    virtual STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
    
	CUserModeSynth();
	~CUserModeSynth();
	HRESULT		Init();

private:
    CClock      m_MasterClock;  // Master clock for timing, derived from DSound.
	long		m_cRef;
	CSynth *	m_pSynth;		// Just one synth engine.
	BOOL		m_fActive;		// Currently active.
    LONG        m_lVolume;      // in 1/100 dB
    LONG        m_lBoost;       // in 1/100 dB
    LONG        m_lGainAdjust;  // in 1/100 dB
    CRITICAL_SECTION m_CriticalSection; // Critical section to manage access.

    HRESULT HandleSetVolume(
        ULONG               ulId, 
        BOOL                fSet, 
        LPVOID              pbBuffer, 
        PULONG              pcbBuffer);

    HRESULT HandleSetBoost(
        ULONG               ulId, 
        BOOL                fSet, 
        LPVOID              pbBuffer, 
        PULONG              pcbBuffer);
        
	HRESULT HandleReverb(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
	HRESULT HandleEffects(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    HRESULT HandleGetSampleRate(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    static GENERICPROPERTY m_aProperty[];
    static const int m_nProperty;
    //static GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);
    GENERICPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);
};

// Class factory
//
// Common to emulation/WDM.
// 
class CDirectMusicSynthFactory : public IClassFactory
{
public:
	// IUnknown
    //
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CDirectMusicSynthFactory();

	// Destructor
	~CDirectMusicSynthFactory();

private:
	long m_cRef;
};



#endif //__UMSYNTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\dmstrm.h ===
//
// dmstrm.h
// 
// Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
//


#ifndef DMSTRM_H
#define DMSTRM_H

#include "dmusicip.h"

#ifdef XBOX
#include "mmsystem.h"
#endif

DEFINE_GUID(IID_IDMStream, 0x1894c260, 0xaa21, 0x11d1, 0x86, 0xbc, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef);

DECLARE_INTERFACE_(IDMStream, IUnknown)
{
    // IUnknown
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDMStream
	STDMETHOD(Init)					(THIS_ IStream* pStream) PURE;
    STDMETHOD(Descend)		(THIS_ LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD(Ascend)		(THIS_ LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(CreateChunk)	(THIS_ LPMMCKINFO lpck, UINT wFlags) PURE;
   	STDMETHOD(SetStream)			(THIS_ IStream* pIStream) PURE;
    STDMETHOD_(IStream*, GetStream)	(THIS) PURE;
};

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream);

class CDirectMusicStream : public IDMStream
{
public:

    CDirectMusicStream();
    ~CDirectMusicStream();
 
	STDMETHODIMP Init(IStream* pStream);
	
	// IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDMStream
    STDMETHODIMP Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags);
    STDMETHODIMP Ascend(LPMMCKINFO lpck, UINT wFlags);
    STDMETHODIMP CreateChunk(LPMMCKINFO lpck, UINT wFlags);

	STDMETHODIMP SetStream(IStream* pStream);
    STDMETHODIMP_(IStream*) GetStream();

private:
	long		m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on
};

// Macro to round up an odd size to RIFF 16 bit boundary.
#define RIFF_ALIGN(dwSize) (dwSize + (dwSize & 1))

typedef struct _RIFFIO
{
    FOURCC          ckid;           /* chunk ID */
    long            cksize;         /* chunk size */
    FOURCC          fccType;        /* form type or list type */
    long            lRead;          /* How much of this chunk has been read so far. */
    _RIFFIO *       pParent;        /* pointer to parent chunk */
    LARGE_INTEGER   liPosition;     /* Filled in by MarkPosition() when handing stream to another component. */
} RIFFIO;


class CRiffParser
{
public:
    CRiffParser(IStream *pStream);
    void        DebugOn() { m_fDebugOn = TRUE; } // Turns on tracing of parsing. Only available in debug builds.
    BOOL        NextChunk(HRESULT * pHr); // Does the work of LeaveChunk, MoreChunks, and EnterChunk in one call. 
    void        EnterList(RIFFIO *pChunk); // Descend into a new list.
    void        LeaveList();    // Pop out of the current list. 
    BOOL        MoreChunks();   // Returns true if there are more chunks to process in this LIST or RIFF.
    HRESULT     EnterChunk();   // Reads header of next chunk in this LIST or RIFF container.
    HRESULT     LeaveChunk();   // Move to the end of the current chunk in the LIST or RIFF.
    void        MarkPosition(); // Stores the absolute position of the start of the current chunk.
    HRESULT     SeekBack();     // Scan back to the beginning of the current chunk.
    HRESULT     SeekForward();  // Scan forward to the end of the current chunk.
    HRESULT     Read(void *pv,ULONG cb); // Reads data from stream. 
    HRESULT     Skip(ULONG ulBytes); // Seeks forward ulBytes.
    void        EnteringComponent() { m_fInComponent = true; } 
    BOOL        ComponentFailed() { return m_fComponentFailed; }
    IStream *   GetStream() { return m_pStream; }
private:
    BOOL        m_fDebugOn;     // Set true to turn tracing of parsing on. 
    BOOL        m_fFirstPass;   // Used by NextChunk to understand whether this is the first time in the list.
    IStream *   m_pStream;      // Stream to operate on. 
    RIFFIO *    m_pChunk;       // Current chunk that we are in. 
    RIFFIO *    m_pParent;      // Parent chunk of current chunk.
    long        m_lRead;        // How far we've read in the current chunk.
    BOOL        m_fComponentFailed; // Set true if a component failed to load, yet the file is okay.
    BOOL        m_fInComponent; // Set to true when inside a component's chunk.
};

class CInfo
{
public:
    CInfo() { Init(); }
    void Init();
   	HRESULT GetDescriptor(LPDMUS_OBJECTDESC pDesc, REFGUID rguidClassID);
	HRESULT SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	HRESULT ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc, DWORD dwRIFFID, REFGUID guidClassID);
    HRESULT ReadChunk(CRiffParser *pParser,DWORD dwID);
	DWORD	            m_dwValidData;
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
private:
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                           /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                         /* Version. */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
};

class CLinkParser
{
public:
    HRESULT     LoadReferencedObject(CRiffParser *pParser,void **ppObject,REFGUID rguidIID,BOOL fDontCache);
    HRESULT     ReadReference(CRiffParser *pParser,LPDMUS_OBJECTDESC pDesc);
};
#endif // #ifndef DMSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\umsynth.cpp ===
//      Copyright (c) 1996-1999 Microsoft Corporation

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//

#pragma warning(disable:4530)
// UMSynth.cpp : Implementation of CUserModeSynth

#ifdef XBOX
#include <xtl.h>
#include <xboxutil.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif

#include <objbase.h>
#include <mmsystem.h>
#ifdef XBOX
#undef timeGetTime
#define timeGetTime GetTickCount
#endif // XBOX
#include <dsoundp.h>
#include <ks.h>

#include "debug.h"
#include "UMSynth.h"
#include "dmusicc.h"
#include "dmusics.h"
#include "math.h"
#include "misc.h"
#include "dmksctrl.h"
#include "dsoundp.h"    // For IDirectSoundSource

#include <dmusprop.h>

#include "..\shared\validate.h"

/*DWORD GetTheCurrentTime()
{
	static BOOL s_fFirstTime = TRUE;
	static LARGE_INTEGER s_liPerfFrequency;
	static BOOL s_fUsePerfCounter = FALSE;
	if (s_fFirstTime)
	{
		s_fFirstTime = FALSE;
		s_fUsePerfCounter = QueryPerformanceFrequency(&s_liPerfFrequency);
		s_liPerfFrequency.QuadPart /= 1000;
	}
	if (s_fUsePerfCounter)
	{
		LARGE_INTEGER liPerfCounter;
		QueryPerformanceCounter(&liPerfCounter);
		liPerfCounter.QuadPart /= s_liPerfFrequency.QuadPart;
		return (DWORD) liPerfCounter.QuadPart;
	}
	else
	{
		return timeGetTime();
	}
}*/

/////////////////////////////////////////////////////////////////////////////
// CUserModeSynth

HRESULT CUserModeSynth::Init()

{
	return S_OK;
}

CUserModeSynth::CUserModeSynth()

{
    ::InitializeCriticalSection(&m_CriticalSection);
    m_MasterClock.m_pParent = this;
	m_cRef = 0;
    m_lVolume = 0;
    m_lBoost = 6 * 100;
    m_lGainAdjust = 6 * 100;            // Default 6 dB boost
	m_fActive = FALSE;
    m_pSynth = NULL;
}

CUserModeSynth::~CUserModeSynth()

{
//	Activate(FALSE);

    ::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        delete m_pSynth;
    	m_pSynth = NULL;
    }
    ::LeaveCriticalSection(&m_CriticalSection);
    ::DeleteCriticalSection(&m_CriticalSection);
}


// CUserModeSynth::QueryInterface
//
STDMETHODIMP
CUserModeSynth::QueryInterface(const IID &iid,
                                   void **ppv)
{
    V_INAME(IDirectMusicSynth::QueryInterface);
    V_REFGUID(iid);
    V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicSynthX) {
        *ppv = static_cast<IDirectMusicSynthX*>(this);
    }
	else if (iid == IID_IKsControl) 
    {
        *ppv = static_cast<IKsControl*>(this);
    }
/*	else if (iid == IID_IDirectSoundSource)
    {
        *ppv = static_cast<IDirectSoundSource*>(this);
	}*/
    else
	{
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// CUserModeSynth::AddRef
//
STDMETHODIMP_(ULONG)
CUserModeSynth::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CUserModeSynth::Release
//
STDMETHODIMP_(ULONG)
CUserModeSynth::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

/*STDMETHODIMP CUserModeSynth::SetSynthSink(
	IDirectMusicSynthSink *pSynthSink)	// <i IDirectMusicSynthSink> to connect to synth, or
										// NULL to disconnect.
{
	HRESULT hr = S_OK;
	V_INAME(IDirectMusicSynth::SetSynthSink);
	V_INTERFACE_OPT(pSynthSink);
	
    ::EnterCriticalSection(&m_CriticalSection);

//>>>>>>>>. RELEASE THE DSINK IF PRESENT !!!!

	if (m_pSynthSink)
	{
		hr = m_pSynthSink->Init(NULL);
		m_pSynthSink->Release();
	}

	m_pSynthSink = pSynthSink;

//>>>>>>>>> the current state of the format of the the synth is
//>>>>>>>>> ambiguos if a sink has been previously applied.  
	m_dwBufferFlags &= ~BUFFERFLAG_MULTIBUFFER;	// .... just in case 

	if (m_pSynthSink)
	{
		m_pSynthSink->AddRef();
//		hr = m_pSynthSink->Init(static_cast<IDirectMusicSynthX*>(this));
	}
	::LeaveCriticalSection(&m_CriticalSection);
	
    return hr;
}*/

STDMETHODIMP CUserModeSynth::Open(	
	LPDMUS_PORTPARAMS pPortParams)		// <t DMUS_PORTPARAMS> structure for opening the port. If NULL, default settings are used.
{
	V_INAME(IDirectMusicSynth::Open);
    //if (pPortParams == NULL)
	//{
    //    Trace(1,"Error: Open called with NULL PortParams.\n");
	//	return E_FAIL;
	//}

    DWORD cbPortParams = 0;
    DWORD dwVer;
    
	if (pPortParams)
	{
        V_STRUCTPTR_READ_VER(pPortParams, dwVer);
        V_STRUCTPTR_READ_VER_CASE(DMUS_PORTPARAMS, 7);
        V_STRUCTPTR_READ_VER_CASE(DMUS_PORTPARAMS, 8);
        V_STRUCTPTR_READ_VER_END(DMUS_PORTPARAMS, pPortParams);

        switch (dwVer)
        {
            case 7:
                cbPortParams = sizeof(DMUS_PORTPARAMS7);
                break;

            case 8:
                cbPortParams = sizeof(DMUS_PORTPARAMS8);
                break;
        }
    }
        
    
	bool bPartialOpen = false;
	
	DMUS_PORTPARAMS myParams;
	myParams.dwSize = sizeof (myParams);
	myParams.dwVoices = 32;
	myParams.dwChannelGroups = 2;
	myParams.dwAudioChannels = 2;
	myParams.dwSampleRate = 22050;
	myParams.dwEffectFlags = DMUS_EFFECT_NONE;
    myParams.fShare = FALSE;
	myParams.dwValidParams = 
		DMUS_PORTPARAMS_VOICES | 
		DMUS_PORTPARAMS_CHANNELGROUPS |
		DMUS_PORTPARAMS_AUDIOCHANNELS |
		DMUS_PORTPARAMS_SAMPLERATE |
		DMUS_PORTPARAMS_EFFECTS |
		DMUS_PORTPARAMS_SHARE;
    
	if (pPortParams)
	{
	    if (pPortParams->dwSize >= sizeof(DMUS_PORTPARAMS8))
        {
            myParams.dwValidParams |= DMUS_PORTPARAMS_FEATURES;
            myParams.dwFeatures = 0;
        }
		if (pPortParams->dwValidParams & DMUS_PORTPARAMS_VOICES)
		{
			if (pPortParams->dwVoices)
			{
				if (pPortParams->dwVoices <= MAX_VOICES)
				{
					myParams.dwVoices = pPortParams->dwVoices;
				}
				else
				{
					bPartialOpen = true;
					myParams.dwVoices = MAX_VOICES;
				}
			}
			else
			{
				bPartialOpen = true;
				myParams.dwVoices = 1; // MIN_VOICES
			}
		}
		if (pPortParams->dwValidParams & DMUS_PORTPARAMS_CHANNELGROUPS)
		{
			if (pPortParams->dwChannelGroups)
            {
                if (pPortParams->dwChannelGroups <= MAX_CHANNEL_GROUPS)
			    {
				    myParams.dwChannelGroups = pPortParams->dwChannelGroups;
			    }
			    else
			    {
				    bPartialOpen = true;
				    myParams.dwChannelGroups = MAX_CHANNEL_GROUPS;
			    }
            }
			else
			{
				bPartialOpen = true;
				myParams.dwChannelGroups = 1; // MIN_CHANNEL_GROUPS
			}
		}
		if (pPortParams->dwValidParams & DMUS_PORTPARAMS_AUDIOCHANNELS)
		{
			if (pPortParams->dwAudioChannels)
            {
                if (pPortParams->dwAudioChannels <= 2)
			    {
				    myParams.dwAudioChannels = pPortParams->dwAudioChannels;
			    }
			    else
			    {
				    bPartialOpen = true;
				    myParams.dwAudioChannels = 2; // MAX_AUDIO_CHANNELS
			    }
            }
			else
			{
				bPartialOpen = true;
				myParams.dwAudioChannels = 1; // MIN_AUDIO_CHANNELS
			}
		}
		if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SAMPLERATE)
		{
            if (dwVer == 7)
            {
                // DX-7 compat: clamp sample rate to one of the
                // understood rates.
                //
    			if (pPortParams->dwSampleRate > 30000)
    			{
    				if(pPortParams->dwSampleRate != 44100)
    				{
    					bPartialOpen = true;
    				}
    				
    				myParams.dwSampleRate = 44100;
    			}
    			else if (pPortParams->dwSampleRate > 15000)
    			{
    				if(pPortParams->dwSampleRate != 22050)
    				{
    					bPartialOpen = true;
    				}

    				myParams.dwSampleRate = 22050;
    			}
    			else 
    			{
    				if(pPortParams->dwSampleRate != 11025)
    				{
    					bPartialOpen = true;
    				}

    				myParams.dwSampleRate = 11025;
    			}
            }
            else
            {
    			if (pPortParams->dwSampleRate > 96000)
    			{
    				bPartialOpen = true;
    				myParams.dwSampleRate = 96000;
    			}
    			else if (pPortParams->dwSampleRate < 11025)
    			{
    				bPartialOpen = true;
    				myParams.dwSampleRate = 11025;
    			}
                else myParams.dwSampleRate = pPortParams->dwSampleRate;
            }
		}
		if (pPortParams->dwValidParams & DMUS_PORTPARAMS_EFFECTS)
		{
            if (pPortParams->dwEffectFlags & ~DMUS_EFFECT_REVERB)
            {
                bPartialOpen = true;
                pPortParams->dwEffectFlags &= DMUS_EFFECT_REVERB;
            }

			myParams.dwEffectFlags = DMUS_EFFECT_NONE; 
			if (pPortParams->dwEffectFlags & DMUS_EFFECT_REVERB)
			{
				bPartialOpen = true;
			}
        }
        if (pPortParams->dwValidParams & DMUS_PORTPARAMS_SHARE)
        {
            if (pPortParams->fShare)
            {
                bPartialOpen = true;
            }
        }

        if ((pPortParams->dwValidParams & DMUS_PORTPARAMS_FEATURES) &&
            (pPortParams->dwSize >= sizeof(DMUS_PORTPARAMS8)))
        {
            myParams.dwFeatures = pPortParams->dwFeatures;
        }
	}

	if (pPortParams)
	{
        DWORD dwSize = min(cbPortParams, myParams.dwSize);

        memcpy(pPortParams, &myParams, dwSize);
        pPortParams->dwSize = dwSize;
	}

//    m_dwSampleRate = 48000;
//    m_dwChannels = 2;
//	m_dwBufferFlags = (m_dwChannels==1)?BUFFERFLAG_MONO:BUFFERFLAG_INTERLEAVED;

	::EnterCriticalSection(&m_CriticalSection);
	HRESULT hr = DMUS_E_ALREADYOPEN;
	if (!m_pSynth)
	{
        try
        {
		    m_pSynth = new CSynth;
        }
        catch( ... )
        {
            m_pSynth = NULL;
        }

		if (!m_pSynth)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			// Note: hr is initalized to DMUS_E_ALREADYOPEN,
			// so we can't do the typical "if(SUCCEEDED(hr))" here.
			hr = m_pSynth->Initialize();

			if (SUCCEEDED(hr))
			{
				hr = m_pSynth->Open(myParams.dwChannelGroups,
					myParams.dwVoices);
			}
			if (SUCCEEDED(hr))
			{
                m_pSynth->SetGainAdjust(m_lGainAdjust);
                m_pSynth->SetMasterClock(&m_MasterClock);
//                m_pSynth->Activate(m_dwSampleRate, m_dwBufferFlags);
			}
			else
			{
				delete m_pSynth;
				m_pSynth = NULL;
			}
		}
	}
	::LeaveCriticalSection(&m_CriticalSection);
	
	if(SUCCEEDED(hr))
	{
		if(bPartialOpen)
		{
			hr = S_FALSE;
		}
	}
	
	return hr;
}

STDMETHODIMP CUserModeSynth::SetNumChannelGroups(
	DWORD dwGroups)		// Number of ChannelGroups requested.

{
	::EnterCriticalSection(&m_CriticalSection);
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
	if (m_pSynth)
	{
		hr = m_pSynth->SetNumChannelGroups(dwGroups);
	}
	::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CUserModeSynth::SetMasterVolume(LONG lVolume)

{
	::EnterCriticalSection(&m_CriticalSection);
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
    m_lVolume =  lVolume;
    m_lGainAdjust = m_lVolume + m_lBoost;

    if (m_pSynth)
    {
        m_pSynth->SetGainAdjust(m_lGainAdjust);
    }	
    ::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}


STDMETHODIMP CUserModeSynth::SendShortMsg(REFERENCE_TIME rt, DWORD dwGroup, DWORD dwMsg)
{
	::EnterCriticalSection(&m_CriticalSection);
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
	if (m_pSynth)
	{
		hr = m_pSynth->SendShortMsg(rt,dwGroup,dwMsg);
	}
	::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}



STDMETHODIMP CUserModeSynth::SendLongMsg(REFERENCE_TIME rt, DWORD dwGroup, BYTE *pbMsg, DWORD dwLength)
{
	::EnterCriticalSection(&m_CriticalSection);
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
	if (m_pSynth)
	{
		hr = m_pSynth->SendLongMsg(rt,dwGroup,pbMsg,dwLength);
	}
	::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}


STDMETHODIMP CUserModeSynth::Close()

{
	::EnterCriticalSection(&m_CriticalSection);
	HRESULT hr = DMUS_E_ALREADYCLOSED;
	if (m_pSynth)
	{
		hr = m_pSynth->Close();
		delete m_pSynth;
		m_pSynth = NULL;
	}
	::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}
/*STDMETHODIMP CUserModeSynth::Download(
	LPHANDLE phDownload,	// Pointer to download handle, to be created by <om IDirectMusicSynth::Download> and used later to unload the data.
	LPVOID pvData,			// Pointer to continuous memory segment with download data.
	LPBOOL pbFree)			// <p pbFree> indicates whether the synthesizer wishes to keep the memory in <p pvData> allocated.
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
	V_INAME(IDirectMusicSynth::Download);
	V_PTR_WRITE(phDownload,HANDLE); 
	V_PTR_WRITE(pbFree,BOOL); 

	// pvData is validated inside synth while parsing.
	::EnterCriticalSection(&m_CriticalSection);
	if (m_pSynth)
	{
		hr = m_pSynth->Download(phDownload, pvData, pbFree);
	}
	::LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

STDMETHODIMP CUserModeSynth::Unload(
	HANDLE hDownload,	// Handle to data, previously downloaded with a call to <om IDirectMusicSynth::Download>.
	HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), // If the original call to
						// <om IDirectMusicSynth::Download> returned FALSE in <p pbFree>,
						// the synthesizer hung onto the memory in the download chunk. If so,
						// the caller must be notified once the memory has been freed,
						// but that could occur later than <om IDirectMusicSynth::Download>
						// since a wave might be currently in use. <p lpFreeHandle> is a 
						// pointer to a callback
						// function which will be called when the memory is no longer in use.
	HANDLE hUserData)	// Pointer to user data, passed as a parameter to the 
						// <p lpFreeHandle> function, typically used so the callback routine can retrieve
						// its state.
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;
	::EnterCriticalSection(&m_CriticalSection);
	if (m_pSynth)
	{
		hr = m_pSynth->Unload(hDownload, lpFreeHandle, hUserData);
	}
	::LeaveCriticalSection(&m_CriticalSection);
	return hr;
}

STDMETHODIMP CUserModeSynth::PlayBuffer(
	REFERENCE_TIME rt,	// Start time of the buffer. This should be in 
						// REFERENCE_TIME units, relative to the master
						// clock, previously set with a call to <om IDirectMusicSynth::SetMasterClock>.
						// And, this should be after the time returned by the clock in 
						// <om IDirectMusicSynth::GetLatencyClock>.
	LPBYTE pbBuffer,	// Memory chunk with all the MIDI events, generated by <i IDirectMusicBuffer>.
	DWORD cbBuffer)		// Size of buffer.
{
	class MIDIEVENT : public DMUS_EVENTHEADER {
	public:
		 BYTE  abEvent[4];           
	};

	typedef class MIDIEVENT FAR  *LPMIDIEVENT;
	#define QWORD_ALIGN(x) (((x) + 7) & ~7)

	HRESULT hr;

    V_INAME(IDirectMusicSynth::PlayBuffer);
    V_BUFPTR_READ(pbBuffer,cbBuffer);

	::EnterCriticalSection(&m_CriticalSection);

    LPMIDIEVENT lpEventHdr;
    DWORD cbEvent;

    while (cbBuffer)
    {
        if (cbBuffer < sizeof(DMUS_EVENTHEADER))
        {
            Trace(1,"Error: PlayBuffer called with error in buffer size.\n");
			::LeaveCriticalSection(&m_CriticalSection);
            return E_INVALIDARG;
        }

        lpEventHdr = (LPMIDIEVENT)pbBuffer; 
        cbEvent = DMUS_EVENT_SIZE(lpEventHdr->cbEvent);
        if (cbEvent > cbBuffer)
        {
            Trace(1,"Error: PlayBuffer called with error in event size.\n");
			::LeaveCriticalSection(&m_CriticalSection);
            return E_INVALIDARG;
        }
        
        pbBuffer += cbEvent;
        cbBuffer -= cbEvent;
		{
			hr = m_pSynth->PlayBuffer(rt + lpEventHdr->rtDelta, 
									  &lpEventHdr->abEvent[0],
									  lpEventHdr->cbEvent,
									  lpEventHdr->dwChannelGroup);
		}

        if (FAILED(hr))
        {
            ::LeaveCriticalSection(&m_CriticalSection);
            return hr;
        }
	}
	::LeaveCriticalSection(&m_CriticalSection);
	return S_OK;
}
*/


STDMETHODIMP CUserModeSynth::GetMasterClock(
	IReferenceClock **ppClock)	// Pointer to master <i IReferenceClock>, 
								// used by all devices in current instance of DirectMusic.

{
    return m_MasterClock.QueryInterface(IID_IReferenceClock,(void **) ppClock);
}

STDMETHODIMP CUserModeSynth::SetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    DWORD dwPriority)
{
    if (m_pSynth)
    {
        return m_pSynth->SetChannelPriority(dwChannelGroup,dwChannel,dwPriority);
    }
    Trace(1,"Error: Synth not initialized.\n");
    return E_FAIL;
}

STDMETHODIMP CUserModeSynth::GetChannelPriority(
    DWORD dwChannelGroup, 
    DWORD dwChannel, 
    LPDWORD pdwPriority)
{
    if (m_pSynth)
    {
        return m_pSynth->GetChannelPriority(dwChannelGroup,dwChannel,pdwPriority);
    }
    Trace(1,"Error: Synth not initialized.\n");
    return E_FAIL;
}

static DWORD dwPropFalse = FALSE;
static DWORD dwPropTrue  = TRUE;
static DWORD dwSystemMemory = DMUS_PC_SYSTEMMEMORY;

GENERICPROPERTY CUserModeSynth::m_aProperty[] = 
{      
    { 
        &GUID_DMUS_PROP_GM_Hardware,		// Set
        0,                                  // Item
        KSPROPERTY_SUPPORT_GET,             // KS support flags
        GENPROP_F_STATIC,                   // GENPROP flags
        &dwPropFalse, sizeof(dwPropFalse),  // static data and size
        NULL                                // Handler
    },
    {   &GUID_DMUS_PROP_GS_Hardware,		
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropFalse, sizeof(dwPropFalse), 
        NULL
    },
    {   &GUID_DMUS_PROP_XG_Hardware,		
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropFalse, sizeof(dwPropFalse),
        NULL
    },
    {   &GUID_DMUS_PROP_XG_Capable,		
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    {   &GUID_DMUS_PROP_GS_Capable,		
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    {   &GUID_DMUS_PROP_INSTRUMENT2,		
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropTrue, sizeof(dwPropTrue),
        NULL
    },
    { 
        &GUID_DMUS_PROP_DLS1,				
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropTrue,  sizeof(dwPropTrue),
        NULL
    },
    { 
        &GUID_DMUS_PROP_DLS2,				
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwPropTrue,  sizeof(dwPropTrue),
        NULL
    },
    { 
        &GUID_DMUS_PROP_SampleMemorySize,				
        0,  
        KSPROPERTY_SUPPORT_GET, 
        GENPROP_F_STATIC,
        &dwSystemMemory,  sizeof(dwSystemMemory),
        NULL
    },
    {
        &KSPROPSETID_Synth,
        KSPROPERTY_SYNTH_VOLUMEBOOST,
        KSPROPERTY_SUPPORT_SET,
        GENPROP_F_FNHANDLER,
        NULL, 0,
        CUserModeSynth::HandleSetBoost
    },
};

const int CUserModeSynth::m_nProperty = sizeof(m_aProperty) / sizeof(m_aProperty[0]);

HRESULT CUserModeSynth::HandleSetBoost(
        ULONG               ulId, 
        BOOL                fSet, 
        LPVOID              pbBuffer, 
        PULONG              pcbBuffer)
{
    if (*pcbBuffer != sizeof(LONG)) 
    {
        return E_INVALIDARG;
    }

    m_lBoost =  *(LONG*)pbBuffer;
    m_lGainAdjust = m_lVolume + m_lBoost;

    if (m_pSynth)
    {
        m_pSynth->SetGainAdjust(m_lGainAdjust);
    }
    return S_OK;
}

// 
// CDirectMusicEmulatePort::FindPropertyItem
//                         
// Given a GUID and an item ID, find the associated property item in the synth's
// table of SYNPROPERTY's.
//
// Returns a pointer to the entry or NULL if the item was not found.
//
GENERICPROPERTY *CUserModeSynth::FindPropertyItem(REFGUID rguid, ULONG ulId)
{
    GENERICPROPERTY *pPropertyItem = &m_aProperty[0];
    GENERICPROPERTY *pEndOfItems = pPropertyItem + m_nProperty;



    for (; pPropertyItem != pEndOfItems; pPropertyItem++)
    {
        if (*pPropertyItem->pguidPropertySet == rguid && 
             pPropertyItem->ulId == ulId)
        {
            return pPropertyItem;
        }
    }

    

    return NULL;
}

#define KS_VALID_FLAGS (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET| KSPROPERTY_TYPE_BASICSUPPORT)

STDMETHODIMP CUserModeSynth::KsProperty(
    PKSPROPERTY pPropertyIn, ULONG ulPropertyLength,
    LPVOID pvPropertyData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsProperty);
    V_BUFPTR_WRITE(pPropertyIn, ulPropertyLength);

    DWORD dwFlags = pPropertyIn->Flags & KS_VALID_FLAGS;

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            V_BUFPTR_WRITE_OPT(pvPropertyData, ulDataLength);
            break;
            
        case KSPROPERTY_TYPE_SET:
            V_BUFPTR_READ(pvPropertyData, ulDataLength);
            break;
            
        case KSPROPERTY_TYPE_BASICSUPPORT:
            V_BUFPTR_WRITE(pvPropertyData, ulDataLength);
            break;
    }

    
    V_PTR_WRITE(pulBytesReturned, ULONG);    

    GENERICPROPERTY *pProperty = FindPropertyItem(pPropertyIn->Set, pPropertyIn->Id);

    if (pProperty == NULL)
    {
        Trace(2,"Warning: KsProperty call requested unknown property.\n");
        return DMUS_E_UNKNOWN_PROPERTY;
    }

    switch (dwFlags)
    {
        case KSPROPERTY_TYPE_GET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_GET))
            {
                Trace(1,"Error: SynthSink does not support Get for the requested property.\n");
                return DMUS_E_GET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                *pulBytesReturned = ulDataLength;
                return (this->*pfn)(pPropertyIn->Id, FALSE, pvPropertyData, pulBytesReturned);
            }
    
            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            if (pvPropertyData != NULL)
            {
                CopyMemory(pvPropertyData, pProperty->pPropertyData, ulDataLength);
            }
            *pulBytesReturned = ulDataLength;

            return S_OK;

        case KSPROPERTY_TYPE_SET:
            if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_SET))
            {
                Trace(1,"Error: SynthSink does not support Set for the requested property.\n");
                return DMUS_E_SET_UNSUPPORTED;
            }

            if (pProperty->ulFlags & GENPROP_F_FNHANDLER)
            {
                GENPROPHANDLER pfn = pProperty->pfnHandler;
                return (this->*pfn)(pPropertyIn->Id, TRUE, pvPropertyData, &ulDataLength);
            }

            if (ulDataLength > pProperty->cbPropertyData)
            {
                ulDataLength = pProperty->cbPropertyData;
            }

            CopyMemory(pProperty->pPropertyData, pvPropertyData, ulDataLength);

            return S_OK;
            

        case KSPROPERTY_TYPE_BASICSUPPORT:
            if (pProperty == NULL)
            {
                Trace(1,"Error: Synth does not provide support for requested property type.\n");
                return DMUS_E_UNKNOWN_PROPERTY;
            }

            // XXX Find out what convention is for this!!
            //
            if (ulDataLength < sizeof(DWORD))
            {
                Trace(1,"Error: Data size for property is too small.\n");
                return E_INVALIDARG;
            }

            *(LPDWORD)pvPropertyData = pProperty->ulSupported;    
            *pulBytesReturned = sizeof(DWORD);
            
            return S_OK;
    }

    Trace(1, "Error: KSProperty Flags must contain one of: %s\n"
              "\tKSPROPERTY_TYPE_SET, KSPROPERTY_TYPE_GET, or KSPROPERTY_TYPE_BASICSUPPORT\n");
    return E_INVALIDARG;
}

STDMETHODIMP CUserModeSynth::KsMethod(
    PKSMETHOD pMethod, ULONG ulMethodLength,
    LPVOID pvMethodData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynth::IKsContol::KsMethod);
    V_BUFPTR_WRITE(pMethod, ulMethodLength);
    V_BUFPTR_WRITE_OPT(pvMethodData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);

    return DMUS_E_UNKNOWN_PROPERTY;
}
STDMETHODIMP CUserModeSynth::KsEvent(
    PKSEVENT pEvent, ULONG ulEventLength,
    LPVOID pvEventData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    V_INAME(DirectMusicSynthPort::IKsContol::KsEvent);
    V_BUFPTR_WRITE(pEvent, ulEventLength);
    V_BUFPTR_WRITE_OPT(pvEventData, ulDataLength);
    V_PTR_WRITE(pulBytesReturned, ULONG);
    
    return DMUS_E_UNKNOWN_PROPERTY;
}

/////////////////////////////////////////////////////////////////////
// Implementation of IDirectMusicSynthX

STDMETHODIMP CUserModeSynth::PlayWave(REFERENCE_TIME rt, 
                                      DWORD dwChannelGroup, 
                                      DWORD dwChannel, 
                                      PREL prPitch, 
                                      VREL vrVolume, 
                                      SAMPLE_TIME stVoiceStart, 
                                      SAMPLE_TIME stLoopStart, 
                                      SAMPLE_TIME stLoopEnd,
                                      IDirectSoundWave *pIWave,
                                      DWORD *pdwVoiceID)
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->PlayWave(rt,dwChannelGroup, 
								 dwChannel,
								 vrVolume,
								 prPitch,
								 stVoiceStart,
								 stLoopStart,
								 stLoopEnd,
                                 pIWave,
                                 pdwVoiceID);
    }
    else
    {
        Trace(1,"Error: Failed wave playback, synth is not properly configured.\n");
    }
	::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

STDMETHODIMP CUserModeSynth::StopWave(REFERENCE_TIME rt, DWORD dwVoiceId )
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->StopWave(rt, 
								 dwVoiceId); 
    }
    else
    {
        Trace(1,"Error: Failed stop of wave playback, synth is not properly configured.\n");
    }
	::LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

/*STDMETHODIMP CUserModeSynth::GetVoiceState(DWORD dwVoice[], DWORD cbVoice, DMUS_VOICE_STATE VoiceState[] )
{
	V_INAME(IDirectMusicSynth::GetVoiceState);
	V_PTR_READ(dwVoice,sizeof(DWORD)*cbVoice);

	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {

        hr = m_pSynth->GetVoiceState(dwVoice, 
								     cbVoice, 
									 VoiceState);

    }
	::LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

STDMETHODIMP CUserModeSynth::Refresh(DWORD dwDownloadID, DWORD dwFlags )
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->Refresh(dwDownloadID, 
							   dwFlags);
    }
	::LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

#ifdef XBOX
STDMETHODIMP CUserModeSynth::IsReadyForData(DWORD dwDownloadId)
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
        hr = m_pSynth->IsReadyForData(dwDownloadId);
    }
	::LeaveCriticalSection(&m_CriticalSection);

	return hr;
}
#endif
*/

#ifndef XBOX
STDMETHODIMP CUserModeSynth::AssignChannelToBuses(DWORD dwChannelGroup, DWORD dwChannel, LPDWORD pdwBuses, DWORD cBuses )
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
	hr = m_pSynth->AssignChannelToBuses(dwChannelGroup, 
									     dwChannel, 
						                 pdwBuses, 
						                 cBuses);
	}
    else
    {
        Trace(1,"Error: Failed synth channel assignment, synth is not properly configured.\n");
    }
	::LeaveCriticalSection(&m_CriticalSection);

    return hr;
}                                           
#else
STDMETHODIMP CUserModeSynth::AssignChannelToOutput(DWORD dwChannelGroup, DWORD dwChannel, IDirectSoundBuffer *pBuffer,DWORD dwMixBins, BYTE *pbControllers  )
{
	HRESULT hr = DMUS_E_SYNTHNOTCONFIGURED;

	::EnterCriticalSection(&m_CriticalSection);
    if (m_pSynth)
    {
	hr = m_pSynth->AssignChannelToOutput(dwChannelGroup, 
									     dwChannel, 
						                 pBuffer, 
						                 dwMixBins,
                                         pbControllers);
	}
    else
    {
        Trace(1,"Error: Failed synth channel assignment, synth is not properly configured.\n");
    }
	::LeaveCriticalSection(&m_CriticalSection);

    return hr;
} 

#endif
/////////////////////////////////////////////////////////////////////
// Implementation of IDirectSoundSource

/*STDMETHODIMP CUserModeSynth::SetSink(IDirectSoundConnect* pSinkConnect)
{
    V_INAME(IDirectSoundSink::SetSink);
    V_INTERFACE_OPT(pSinkConnect);

	HRESULT hr = S_OK;

	LPVOID ptr = NULL;
    V_BUFPTR_WRITE_OPT(ptr, 0);

    ::EnterCriticalSection(&m_CriticalSection);

//>>>>>>>> RELEASE THE DSLINK IF PRESENT !!!!

// FIXME: The calls into the SynthSink8 may require the DSound DLL Mutex.  If the Sink
// is making a a call to READ then we end up in a deadlock.  We need to be sure that the
// Synth isn't playing when we do this.

	if (m_pSynthSink8)
	{
	    // FIXME: whoever called us->SetSink() should previously have called
	    // pOldSink->RemoveSource(us) - it shouldn't be our responsibility to
	    // do this call (??):
		// m_pSynthSink8->RemoveSource(this);
		m_pSynthSink8->Release();
        m_pSynthSink8 = NULL;
	}

	if (pSinkConnect)
	{
        // Obtain the IDirectSoundSynthSink interface on the sink
        hr = pSinkConnect->QueryInterface(IID_IDirectSoundSynthSink, (void**)&m_pSynthSink8);

        if (SUCCEEDED(hr))
        {
    		//
    		// Get the sink's format and validate it
    		//
    		WAVEFORMATEX wfx;
    		DWORD dwSize = sizeof wfx;
    		hr = m_pSynthSink8->GetFormat(&wfx, dwSize, NULL);
    		if (SUCCEEDED(hr) && wfx.wBitsPerSample != 16 )
    		{
                Trace(1,"Error; Synth can not write to any format other than 16 bit PCM.\n");
    			hr = DMUS_E_WAVEFORMATNOTSUPPORTED;
    		}

    		if (SUCCEEDED(hr))
    		{
    			// Flag the buffer format to be non-interleaved 
    			m_dwChannels = 1;	// This synth with a sink is concidered a mono source.
    			m_dwBufferFlags = BUFFERFLAG_MULTIBUFFER;	

    			if (m_pSynth)	
    			{
    				// reset sample rate if it has changed 
    				if (wfx.nSamplesPerSec != (WORD)m_dwSampleRate)
    				{
//    					m_pSynth->SetSampleRate(wfx.nSamplesPerSec);
    				}

    			}
    		}
    	}
    }

    ::LeaveCriticalSection(&m_CriticalSection);

	return hr;
}

STDMETHODIMP CUserModeSynth::Seek(ULONGLONG sp)
{

	m_ullPosition = sp/2;	//Convert from bytes to samples 

    return S_OK;
}

STDMETHODIMP CUserModeSynth::Read(LPVOID *ppvBuffer, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchBends, DWORD dwBufferCount, PULONGLONG pullLength )
{
	V_INAME(IDirectMusicSynth::Read);
	V_PTR_READ(ppvBuffer,sizeof(LPVOID)*dwBufferCount);
	V_PTR_READ(pdwIDs,sizeof(LPDWORD)*dwBufferCount);
	for ( DWORD i = 0; i < dwBufferCount; i++ )
	{
		V_BUFPTR_WRITE(ppvBuffer[i],(DWORD)*pullLength);
		if ( ppvBuffer[i] == NULL )
		{
            Trace(1,"Error: Read called with NULL buffer.\n");
			return E_INVALIDARG;
		}
	}

	if ( *pullLength > 0x00000000FFFFFFFF )	// can't read more than a DWORD's worth of data
	{
        Trace(1,"Error: Read called with invalid buffer length.\n");
		return E_INVALIDARG;
	}

	if ( dwBufferCount == 0 )				// don't read no buffers
	{
        Trace(4,"Warning: Read called with 0 buffers.\n");
		return E_INVALIDARG;
	}
	if (!m_pSynthSink8)
	{
        Trace(1,"Error: Synth is not configured, can not play.\n");
		return DMUS_E_SYNTHNOTCONFIGURED;
	}
    if (!m_fActive)
    {
        Trace(3,"Warning: Synth is not active, can not play.\n");
        return DMUS_E_SYNTHINACTIVE;
    }

    ::EnterCriticalSection(&m_CriticalSection);

	if (m_pSynth)
	{
		// Mix
		DWORD dwLength = (DWORD)(*pullLength)/2;	// Convert from bytes to number of samples. Synth assumes 16 bit
		m_pSynth->Mix((short**)ppvBuffer, pdwIDs, pdwFuncIDs, plPitchBends, dwBufferCount, m_dwBufferFlags, dwLength, m_ullPosition);

		// Increment current sample position in the audio stream
		m_ullPosition += dwLength; //*pullLength;
	}

    ::LeaveCriticalSection(&m_CriticalSection);

	return S_OK;
}

STDMETHODIMP CUserModeSynth::GetSize(PULONGLONG pcb)
{
    return E_NOTIMPL;
}
*/

CClock::CClock()

{
    m_pParent = NULL;
    m_dwLastPosition = 0;
    m_llSampleTime = 0;
}


STDMETHODIMP CClock::QueryInterface(const IID &iid, void **ppv)
{
    if(iid == IID_IUnknown || iid == IID_IReferenceClock)
    {
        *ppv = static_cast<IReferenceClock*>(this);
    } 
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    
    return S_OK;
}

STDMETHODIMP_(ULONG) CClock::AddRef()
{
    return m_pParent->AddRef();
}

STDMETHODIMP_(ULONG) CClock::Release()
{
    return m_pParent->Release();
}

STDMETHODIMP CClock::AdviseTime(REFERENCE_TIME ,REFERENCE_TIME,HANDLE,DWORD *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CClock::AdvisePeriodic(REFERENCE_TIME,REFERENCE_TIME,HANDLE,DWORD * )
{
    return E_NOTIMPL;
}

STDMETHODIMP CClock::Unadvise( DWORD )
{
    return E_NOTIMPL;
}

EXTERN_C DWORD WINAPI DirectSoundGetSampleTime(void);

STDMETHODIMP CClock::GetTime(LPREFERENCE_TIME pTime)
{
    if( pTime == NULL )
    {
        return E_INVALIDARG;
    }

	EnterCriticalSection( &m_pParent->m_CriticalSection );

    DWORD dwPosition = DirectSoundGetSampleTime();

    // Check to see if we looped around, which happens every 24 hours

    LONGLONG delta;
    if(dwPosition < m_dwLastPosition){
        // This is either a loop, or a dsound bug

        if(dwPosition < 100000 && m_dwLastPosition > (1 << 30) ){
            Trace(-1, "CClock::GetTime sample time wrapped (as it should every 24 hours. Was: %u is: %u\n",
                m_dwLastPosition, dwPosition);
            delta = ((((LONGLONG) 1) << 32) + dwPosition) - m_dwLastPosition;
        }
        else {
            Trace(-1, "CClock::GetTime stream position decreased unexpectedly. Was: %u is: %u\n",
                m_dwLastPosition, dwPosition);
            delta = 0; // Ignore.
            m_dwLastPosition = dwPosition; // Catch up. (Sometimes DSound resets the stream on us.)
        }
    }
    else {
        delta = dwPosition - m_dwLastPosition;
    }

    m_dwLastPosition = dwPosition;
    m_llSampleTime += delta;
    LONGLONG llTemp = m_llSampleTime * 10000;
	llTemp /= 48000;
	llTemp *= 1000;
    *pTime = llTemp;
	LeaveCriticalSection( &m_pParent->m_CriticalSection );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\dmusver.h ===
#include <xboxverp.h>

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#pragma data_seg(".XBLD$V")

#if DBG
#pragma comment(linker, "/include:_DMusicBuildNumberD")
__declspec(selectany) unsigned short DMusicBuildNumberD[8] = { 'D' | ('M' << 8), 'U' | ('S' << 8), 'I' | ('C' << 8), 'D',
                                        VER_PRODUCTVERSION | 0x8000 };
#elif PROFILE
#pragma comment(linker, "/include:_DMusicBuildNumberI")
__declspec(selectany) unsigned short DMusicBuildNumberI[8] = { 'D' | ('M' << 8), 'U' | ('S' << 8), 'I' | ('C' << 8), 'I',
                                        VER_PRODUCTVERSION };
#elif LTCG
#pragma comment(linker, "/include:_DMusicBuildNumberL")
__declspec(selectany) unsigned short DMusicBuildNumberL[8] = { 'D' | ('M' << 8), 'U' | ('S' << 8), 'I' | ('C' << 8), 'L' | ('T' << 8),
                                        VER_PRODUCTVERSION | 0x4000 };
#else
#pragma comment(linker, "/include:_DMusicBuildNumber")
__declspec(selectany) unsigned short DMusicBuildNumber[8] = { 'D' | ('M' << 8), 'U' | ('S' << 8), 'I' | ('C' << 8), 0,
                                        VER_PRODUCTVERSION | 0x4000 };
#endif

#pragma data_seg()
#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\dowork.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DoWork.h 

#include "Alist.h"
#include "..\shared\debug.h"

class CBossMan;

typedef void (WINAPI *PWORKER_ROUTINE)(void * pWorkerState, REFERENCE_TIME *prtWakeUp );

class CWorker : public AListItem
{
    friend class CBossMan;
public:     
    CWorker *   GetNext() { return (CWorker*)AListItem::GetNext();};
    void        WakeUp() { m_rtWakeUpTime = 0; };   // Tells the worker to wake up as soon as possible.
    void        PinkSlip();   // Gets rid of the worker.
private:
    bool        HasBeenToldToDie();
    void        DoPinkSlip();   // Does the actual work of getting rid of the worker.
    bool                    m_bToldToDie;
    PWORKER_ROUTINE         m_pWorkRoutine;     // Function to call.
    void *                  m_pContext;         // Pointer to object associated with function.
    REFERENCE_TIME          m_rtWakeUpTime;     // When to wake up next.
    DWORD                   m_dwOrder;          // Where in the chain of workers this should reside.
    CBossMan *              m_pBossMan;         // Parent.
#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
    REFERENCE_TIME          m_rtElapsedTime;    // For tracking time elapsed
    DWORD                   m_dwElapsedTime;    // Translated for performance counter. 
    char                    m_szName[100];      // Name for display.
#endif
};

class CBossMan : public AList
{
public:
                CBossMan() { m_pMasterClock = NULL; };
                ~CBossMan();

    CWorker*    GetHead(){return (CWorker*)AList::GetHead();};
    CWorker*    RemoveHead(){return (CWorker*)AList::RemoveHead();};
//    void        InsertBefore(CWorker *pItem,CWorker *pInsert){ AList::InsertBefore((AListItem *pItem,AListItem
    void        Remove(CWorker *pItem){AList::Remove((AListItem *)pItem);};
    void        SetMasterClock(IReferenceClock *pClock);
    CWorker *   InstallWorker(PWORKER_ROUTINE pRoutine,void * pContext,DWORD dwOrder,char *pszName);
    void        DoWork(DWORD dwQuantum);
    void        WakeUp(CWorker*);
    IReferenceClock * m_pMasterClock;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\miscutil.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Misc tiny helper functions.
//

#pragma once

// Releases a COM pointer and then sets it to NULL.  No effect if pointer already was NULL.
template<class T>
void SafeRelease(T *&t) { if (t) t->Release(); t = NULL; }

// Returns the number of elements in an array determined at compile time.
// Note: Only works for variables actually declared as arrays.  Don't try this with a pointer to an array.  There's no way to determine the size at that point.
#define ARRAY_SIZE(array) (sizeof(array) / sizeof(*(array)))

// Zeros memory of struct pointed to.
// Note: This is statically typed.  Don't use it with a pointer to void, pointer to an array, or a pointer to a base class because the size will be too small.
template<class T> void Zero(T *pT) { ZeroMemory(pT, sizeof(*pT)); }

// Zeros memory of the struct pointed to and sets its dwSize field.
template<class T> void ZeroAndSize(T *pT) { Zero(pT); pT->dwSize = sizeof(*pT); }

// Copies one dwSize struct to another dwSize struct without reading/writing beyond either struct
template<class T> void CopySizedStruct(T *ptDest, const T *ptSrc)
{
	assert(ptDest && ptSrc);
	DWORD dwDestSize = ptDest->dwSize;
	memcpy(ptDest, ptSrc, std::min<DWORD>(ptDest->dwSize, ptSrc->dwSize));
	ptDest->dwSize = dwDestSize;
}

// Copy pwszSource to pwszDest where pwszDest is a buffer of size uiBufferSize.
// Returns S_OK if successful or DMUS_S_STRING_TRUNCATED if the string had to be truncated.
// Faster then wcsncpy for short strings because the entire buffer isn't padded with nulls.
inline HRESULT wcsTruncatedCopy(WCHAR *pwszDest, const WCHAR *pwszSource, UINT uiBufferSize)
{
    for (UINT i = 0; i < uiBufferSize; ++i)
    {
        if (!(pwszDest[i] = pwszSource[i])) // assign and check for null
            return S_OK; // the whole string copied
    }

    // string needs to be truncated
    pwszDest[uiBufferSize - 1] = L'\0';
    return DMUS_S_STRING_TRUNCATED;
}

// DirectMusic-specific versions of the C Runtime rand and srand function, so we don't
// pollute the application's use of rand and srand.
// This is needed on Xbox because xbox doesn't use dlls.

int    __cdecl dm_rand(void);
void   __cdecl dm_srand(unsigned int);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\dmsynth\wave.cpp ===
//      Copyright (c) 1996-2001 Microsoft Corporation
//      dls.cpp
//

#include "simple.h"
#include <mmsystem.h>
#include <dmerror.h>
#include "synth.h"
#include "math.h"
#include "debug.h"
#include "..\shared\validate.h"
#include <dmusicf.h>
void MemDump(char * prompt);

#ifdef XBOX
#include <xtl.h>
#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define _WINGDI_
#endif // XBOX

#include <objbase.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <dsoundp.h>
//#include "debug.h"

#include "debug.h" 
#include "dmusicc.h" 
#include "dmusicip.h" 
#include "dmusicf.h" 
#include "validate.h"
#include "synth.h"
#include <regstr.h>
#include <share.h>
//#include "waveutil.h"
#include "dmstrm.h"


STDAPI DirectSoundWaveCreate(REFIID iid, void ** ppDMC )
{
    CSourceWave *pWave = new CSourceWave;
    if (pWave)
    {
        return pWave->QueryInterface(iid,ppDMC);
    }
    return E_OUTOFMEMORY;
}

CSourceWave::CSourceWave() : CMemTrack(DMTRACK_WAVE)
{
    InitializeCriticalSection(&m_CriticalSection);

	m_fdwFlags		  = 0;
//    m_fdwOptions      = 0;
//    m_cSamples        = 0L;
	m_pStream         = NULL;
    m_dwLoopStart     = 0;
    m_dwLoopEnd       = 0;
    m_dwRepeatCount   = 0;
	m_rtReadAheadTime = 100 * 10000;
    m_Articulation.Init(TRUE);
    m_dwSampleDataSize = 0;

    m_cRef = 0;
}

CSourceWave::~CSourceWave()
{
	if (m_pStream) m_pStream->Release();

    DeleteCriticalSection(&m_CriticalSection);
}

STDMETHODIMP CSourceWave::QueryInterface
(
    const IID &iid,
    void **ppv
)
{
	V_INAME(CSourceWave::QueryInterface);
	V_REFGUID(iid);
	V_PTRPTR_WRITE(ppv);

    if (iid == IID_IUnknown || iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_CSourceWave)
    {
        *ppv = static_cast<CSourceWave*>(this);
    }
    else if (iid == IID_IPrivateWave)
    {
        *ppv = static_cast<IPrivateWave*>(this);
    }
    else if (iid == IID_IDirectSoundWave)
    {
        *ppv = static_cast<IDirectSoundWave*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Wave Object\n");
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CSourceWave::AddRef()
{
	V_INAME(CSourceWave::AddRef);

    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSourceWave::Release()
{
	V_INAME(CSourceWave::Release);

    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSourceWave::GetFormat
(
    LPWAVEFORMATEX pwfx,
    DWORD dwSizeAllocated,
    LPDWORD pdwSizeWritten
)
{
    return E_FAIL;
/*	V_INAME(CSourceWave::GetFormat);

    if (!pwfx && !pdwSizeWritten)
    {
        Trace(1, "ERROR: GetFormat (Wave): Must request either the format or the required size\n.");
        return E_INVALIDARG;
    }

    dwSizeAllocated = min(sizeof(XBOXADPCMWAVEFORMAT),dwSizeAllocated);

	V_BUFPTR_WRITE(pwfx, dwSizeAllocated); 
    pwfx->cbSize = 0;
    memcpy(pwfx, &m_WaveFormat, dwSizeAllocated);
    // Return the numbers of bytes actually writted
    if (pdwSizeWritten)
    {
        *pdwSizeWritten = dwSizeAllocated;
    }

    return S_OK;*/
}

STDMETHODIMP CSourceWave::CreateSource
(
    IDirectSoundSource  **ppSource,
    LPWAVEFORMATEX      pwfx,
    DWORD               fdwFlags
)
{
	HRESULT			hr = S_OK;
//	CWaveViewPort* 	pVP;
//	CREATEVIEWPORT	cvp;

	V_INAME(CSourceWave::CreateSource);
	V_PTRPTR_WRITE(ppSource);
//    V_PWFX_READ(pwfx);

    DWORD dwCreateFlags = 0;
    if (fdwFlags == DMUS_DOWNLOADINFO_ONESHOTWAVE)
    {
        dwCreateFlags |= DSOUND_WAVEF_ONESHOT;
    }
	if (dwCreateFlags & (~DSOUND_WAVEF_CREATEMASK))
	{
        Trace(1, "ERROR: CreateSource (Wave): Unknown flag.\n");
		return (E_INVALIDARG);
	}

//    TraceI(5, "CSourceWave::CreateSource [%d samples]\n", m_cSamples);
	return E_FAIL;
/*	pVP = new CWaveViewPort;
    if (!pVP)
    {
        return E_OUTOFMEMORY;
    }

	cvp.pStream 	= m_pStream;
	cvp.cSamples	= m_cSamples;
	cvp.cbStream	= m_cbStream;
	cvp.pwfxSource	= m_pwfx;
	cvp.pwfxTarget  = pwfx;
    cvp.fdwOptions  = dwCreateFlags;

	hr = pVP->Create(&cvp);

	if (SUCCEEDED(hr)) 
	{
		hr = pVP->QueryInterface(IID_IDirectSoundSource, (void **)ppSource);
	}
	else
	{
	    TraceI(5, "CSourceWave::CreateSource 00\n");
	}

	if (SUCCEEDED(hr))
	{
		// The QI gave us one ref too many
		pVP->Release();
	}
	else
	{
	    TraceI(5, "CSourceWave::CreateSource 01\n");
	}

    return hr;*/
}

STDMETHODIMP CSourceWave::GetStreamingParms
(
    LPDWORD              pdwFlags, 
    LPREFERENCE_TIME    prtReadAhead
)
{
    V_INAME(IDirectSoundWave::GetStreamingParms);
    V_PTR_WRITE(pdwFlags, DWORD);
    V_PTR_WRITE(prtReadAhead, REFERENCE_TIME);
    
    *pdwFlags = 0;

    if(!(m_fdwFlags & DSOUND_WAVEF_ONESHOT))
    {
        *pdwFlags = DMUS_WAVEF_STREAMING;
    }

    *pdwFlags |= m_fdwFlags & (DMUS_WAVEF_NOPREROLL | DMUS_WAVEF_IGNORELOOPS);

    *prtReadAhead  = m_rtReadAheadTime;
    return S_OK;
}

STDMETHODIMP CSourceWave::GetClassID
(
    CLSID*  pClsId
)
{
	V_INAME(CSourceWave::GetClassID);
	V_PTR_WRITE(pClsId, CLSID); 

    *pClsId = CLSID_DirectSoundWave;
    return S_OK;
}

STDMETHODIMP CSourceWave::IsDirty()
{
	V_INAME(CSourceWave::IsDirty);

    return S_FALSE;
}

HRESULT CSourceWave::Read(DWORD dwStartPosition, BYTE *pbBuffer, DWORD dwLength)

{
    if ((dwLength + dwStartPosition) <= m_dwSampleDataSize)
    {
        LARGE_INTEGER li;
        li.QuadPart = m_dwSampleDataOffset + dwStartPosition;
        m_pStream->Seek(li, STREAM_SEEK_SET, NULL);
        return m_pStream->Read(pbBuffer,dwLength,NULL);
    }
    return E_FAIL;
}


HRESULT CSourceWave::Load(CRiffParser *pParser)

{
	RIFFIO ckNext;
	HRESULT hr = S_OK; 

	BOOL fFormat = FALSE;
 	BOOL fData = FALSE;
 	BOOL fHeader = FALSE;
    DWORD dwSamplesFromFact = 0;
    
    
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
		switch(ckNext.ckid)
		{
        case DMUS_FOURCC_WAVEHEADER_CHUNK:
			{
                m_fdwFlags = 0;
				fHeader = TRUE;
				DMUS_IO_WAVE_HEADER iWaveHeader;
				memset(&iWaveHeader, 0, sizeof(iWaveHeader));
                hr = pParser->Read(&iWaveHeader, sizeof(iWaveHeader));
				if (iWaveHeader.dwFlags & DMUS_WAVEF_STREAMING)
				{
					m_rtReadAheadTime = iWaveHeader.rtReadAhead;
				}
				else
				{
					m_fdwFlags = DSOUND_WAVEF_ONESHOT;
					m_rtReadAheadTime = 0;
				}
                m_fdwFlags |= iWaveHeader.dwFlags & 
                    (DMUS_WAVEF_NOPREROLL | DMUS_WAVEF_IGNORELOOPS);

                break;
			}
        case mmioFOURCC('f','m','t',' ') :
            hr = pParser->Read(&m_WaveFormat, sizeof(XBOXADPCMWAVEFORMAT));
            if ((m_WaveFormat.wfx.wFormatTag != WAVE_FORMAT_PCM)
                && (m_WaveFormat.wfx.wFormatTag != WAVE_FORMAT_XBOX_ADPCM)) 
            {
                return E_FAIL;
            } 
            // Clean up ADPCM waveformat if it's broken.
/*            if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
            {
                m_WaveFormat.wSamplesPerBlock = 64;
                m_WaveFormat.wfx.nBlockAlign = 36;
                m_WaveFormat.wfx.wBitsPerSample = 4;
                m_WaveFormat.wfx.cbSize = sizeof(m_WaveFormat) - sizeof(m_WaveFormat.wfx);
            }
            else
            {
                m_WaveFormat.wfx.cbSize = 0;
            }*/
		    fFormat = TRUE;
            break;
        case DMUS_FOURCC_GUID_CHUNK:
        case DMUS_FOURCC_VERSION_CHUNK:
        case DMUS_FOURCC_CATEGORY_CHUNK:
        case DMUS_FOURCC_DATE_CHUNK:
            hr = m_Info.ReadChunk(pParser,ckNext.ckid);
			break;
		case FOURCC_LIST:
			switch(ckNext.fccType)
			{
                case DMUS_FOURCC_INFO_LIST:
                case DMUS_FOURCC_UNFO_LIST:
                    hr = m_Info.ReadChunk(pParser,ckNext.fccType);
                    break;
                case FOURCC_LART :
                case FOURCC_LAR2 :
                m_Articulation.Init(FALSE);
                m_Articulation.Load(pParser);
                break;
            }
            break;
        case mmioFOURCC('f','a','c','t'):
           hr = pParser->Read(&dwSamplesFromFact, sizeof(DWORD));
           break;
        case mmioFOURCC('s','m','p','l'):
            {
                typedef struct _rsmpl 
                {
                  DWORD dwManufacturer;
                  DWORD dwProduct;
                  DWORD dwSamplePeriod;
                  DWORD dwMIDIUnityNote;
                  DWORD dwMIDIPitchFraction;
                  DWORD dwSMPTEFormat;
                  DWORD dwSMPTEOffset;
                  DWORD cSampleLoops;
                  DWORD cbSamplerData;
                  // That ends the RSMPL structure, which is followed
                  // by the RLOOP structure:
                  DWORD dwIdentifier;
                  DWORD dwType;
                  DWORD dwStart;
                  DWORD dwEnd;
                  DWORD dwFraction;
                  DWORD dwPlayCount;
                } RSMPL_PLUS_RLOOP;
                RSMPL_PLUS_RLOOP rloop;
                rloop.dwEnd = rloop.dwStart = 0;
                rloop.cSampleLoops = 0;
                hr = pParser->Read(&rloop,sizeof(RSMPL_PLUS_RLOOP));
                if (rloop.cSampleLoops)
                {
                    m_dwLoopStart = rloop.dwStart;
                    m_dwLoopEnd = rloop.dwEnd + 1; // File format has endpoint inclusive.
                    if (rloop.dwPlayCount)
                    {
                        m_dwRepeatCount = rloop.dwPlayCount;
                    }
                    else
                    {
                        m_dwRepeatCount = -1; 
                    }
                }
            }
            break;

        case mmioFOURCC('d','a','t','a') :
            if (!fFormat) 
            {
                hr = E_FAIL; // If no wave format, this is a bad file. 
                break;
            }
            m_dwSampleDataSize = ckNext.cksize;
            // Load the data if this is non streaming. If there was no header chunk,
            // decide by looking at the length of the wave.
            if (!fHeader)
            {
                LONGLONG llTemp;
                if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
                {
                    llTemp = (m_dwSampleDataSize * 64) / (36 * m_WaveFormat.wfx.nChannels);
                }
                else if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_PCM)
                {
                    llTemp = m_dwSampleDataSize * 8; // Total bits.
                    llTemp /= (m_WaveFormat.wfx.nChannels * m_WaveFormat.wfx.wBitsPerSample); // divided by bits per interleaved sample.
                }
                llTemp *= 1000;
                llTemp /= m_WaveFormat.wfx.nSamplesPerSec;
                if (llTemp > 5000)
                {
                    m_rtReadAheadTime = 100 * 10000;
                    m_fdwFlags &= ~DSOUND_WAVEF_ONESHOT;
                }
                else
                {
                    m_rtReadAheadTime = 0;
                    m_fdwFlags |= DSOUND_WAVEF_ONESHOT;
                }
            }
            if (m_fdwFlags & DSOUND_WAVEF_ONESHOT)
            {
                m_pnWave = (short *) new char[m_dwSampleDataSize];
                if (m_pnWave)
                {
                    hr = pParser->Read(m_pnWave, m_dwSampleDataSize);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                // Store the start position if this is supposed to be streamed.
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream = pParser->GetStream();
                m_pStream->AddRef();
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
                m_dwSampleDataOffset = (DWORD) ul.QuadPart;
            }
            break;
        default:
            break;
        }
    }
    pParser->LeaveList();
    if (fFormat)
    {
        // Now, calculate out the number of samples, taking into consideration compression.
        LONGLONG llTemp;
        if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM)
        {
            llTemp = (m_dwSampleDataSize * 64) / (36 * m_WaveFormat.wfx.nChannels);
        }
        else if (m_WaveFormat.wfx.wFormatTag == WAVE_FORMAT_PCM)
        {
            llTemp = m_dwSampleDataSize * 8; // Total bits.
            llTemp /= (m_WaveFormat.wfx.nChannels * m_WaveFormat.wfx.wBitsPerSample); // divided by bits per interleaved sample.
        }
        else
        {
            Trace(0,"ERROR: Unknown wave format tag.");
            llTemp = 0;
            hr = E_FAIL;
        }
        m_dwSampleCount = (DWORD) llTemp;
    }
    else 
    {
        // No format or no data, return error (and wave will be deleted.)
        hr = E_FAIL;
    }
    return hr;
}

HRESULT CSourceWave::Load( IStream* pIStream )
{
	V_INAME(IPersistStream::Load);
	V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == mmioFOURCC('W','A','V','E')))
    {
        hr = Load(&Parser);
    }
    else
    {
        Trace(1,"Error: Unknown file format when parsing Wave\n");
        hr = E_FAIL;
    }
    return hr;
}


STDMETHODIMP CSourceWave::Save
(
    IStream*    pIStream,
    BOOL        fClearDirty
)
{
	V_INAME(CSourceWave::Save);

	return E_NOTIMPL; 
}

STDMETHODIMP CSourceWave::GetSizeMax
(
    ULARGE_INTEGER FAR* pcbSize
)
{
	V_INAME(CSourceWave::GetSizeMax);

	return E_NOTIMPL; 
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CSourceWave::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CSourceWave::GetDescriptor);
	V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    return m_Info.GetDescriptor(pDesc,CLSID_DirectSoundWave);
}

STDMETHODIMP CSourceWave::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
	// Argument validation
	V_INAME(CSourceWave::SetDescriptor);
	V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
	return m_Info.SetDescriptor(pDesc);
}

STDMETHODIMP CSourceWave::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc) 
{
    V_INAME(CSourceWave::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    return m_Info.ParseDescriptor(pIStream,pDesc,mmioFOURCC('W','A','V','E'),CLSID_DirectSoundWave);
}

STDMETHODIMP CSourceWave::SetWaveParams(REFERENCE_TIME rtReadAhead,DWORD dwFlags)
{
	if (dwFlags & DMUS_WAVEF_STREAMING)
	{
		m_fdwFlags &= ~DSOUND_WAVEF_ONESHOT;
		m_rtReadAheadTime = rtReadAhead;
	}
	else
	{
		m_fdwFlags |= DSOUND_WAVEF_ONESHOT;
		m_rtReadAheadTime = 0;
	}

    m_fdwFlags &= ~(DMUS_WAVEF_NOPREROLL | DMUS_WAVEF_IGNORELOOPS);
    m_fdwFlags |= dwFlags & (DMUS_WAVEF_NOPREROLL | DMUS_WAVEF_IGNORELOOPS);

    return S_OK;
}

STDMETHODIMP CSourceWave::GetLength(REFERENCE_TIME *prtLength,
                               DWORD *dwLoopStart, DWORD *dwLoopEnd)
{
	HRESULT hr = S_OK;
    *dwLoopStart = m_dwLoopStart;
    *dwLoopEnd = m_dwLoopEnd;
	if (m_WaveFormat.wfx.nSamplesPerSec)
	{
        *prtLength = m_dwSampleCount;
        if (m_dwRepeatCount)
        {
            // If it repeats infinitely, just return the max.
            if (m_dwRepeatCount == -1)
            {
                // Make it play for 5 years, which is the life expectancy of the XBOX. 
                // That should be long enough, and it still
                // avoids overflowing which would happen if we set this to max.
                // Note that this is in mils, not reference time.
                *prtLength = 157680000000; // 1000 * 60 * 60 * 24 * 365 * 5
                return S_OK;
            }
            else
            {
                // Add all the repeats to the length.
                *prtLength += m_dwRepeatCount * (m_dwLoopEnd - m_dwLoopStart);
                // Subtract the section between the end of loop and the end.
                // We have to lose this because the synth loops infinitely, so we are really
                // sending back a length that will cause playback to stop after the
                // nth repeat, but there currently is no way to get it to follow into
                // the final section, so we lose that.
                // But, first test for a bad file.
                if (m_dwLoopEnd > m_dwSampleCount)
                {
                    Trace(1, "Warning: Wave has loop end %ld longer than wave length %ld\n",m_dwLoopEnd,m_dwSampleCount);
                    m_dwLoopEnd = m_dwSampleCount;
                }
                *prtLength -= (long) (m_dwSampleCount - m_dwLoopEnd);
            }
        }
        *prtLength *= 1000;
        *prtLength /= m_WaveFormat.wfx.nSamplesPerSec;
	}
	else
	{
        Trace(2, "WARNING: Couldn't get a length for a Wave.\n");
		hr = DMUS_E_BADWAVE;
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\nocom.h ===
#ifndef __NOCOM_H__
#define __NOCOM_H__

#ifdef XBOX

__inline HRESULT
CreateInstance(LPCWSTR pszModuleName, LPCSTR pszFunctionName, REFIID iid, LPVOID *ppvInterface)

{
    typedef HRESULT (STDAPICALLTYPE *LPFNCREATEINSTANCE)(LPUNKNOWN *ppObject, LPUNKNOWN pUnknownOuter);

    LPUNKNOWN pUnknown;
    HINSTANCE hModule;
    LPFNCREATEINSTANCE pfnCreateInstance;
    HRESULT hr;

    Trace(0,"ERROR: No CreateInstance yet!\n");
    return E_FAIL;
    // Need to rewrite this, but we currently aren't calling this at all anyway...
/*    if(!(hModule = LoadLibraryW(pszModuleName)))
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    if(!(pfnCreateInstance = (LPFNCREATEINSTANCE)GetProcAddress(hModule, pszFunctionName)))
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    if(FAILED(hr = pfnCreateInstance(&pUnknown, NULL)))
    {
        return hr;
    }

    hr = pUnknown->QueryInterface(iid, ppvInterface);

    pUnknown->Release();

    return hr;*/
}

// HRESULT
// CreateInstance(REFCLSID clsid, REFIID iid, LPVOID *ppvInterface);

#endif // XBOX

#endif // __NOCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_
#ifndef _XBOX_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif // _XBOX_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#ifndef _XBOX_
#include <objbase.h>
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szApartment[]		= TEXT("Apartment");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szApartment);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
	lstrcat(szClsKey, szKey);

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}


#endif // _XBOX_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\str.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       str.h
//
//--------------------------------------------------------------------------

//
// string.h
//

#ifdef XBOX
#include <xtl.h>
#else
#include <objbase.h>
#endif

#ifndef __BRSTRING_H__
#define __BRSTRING_H__

class Archive;

class String
{
    friend String operator+( const String& str1, const String& str2 );
    friend String operator+( const String& str1, LPCSTR lpszStr );
    friend String operator+( LPCSTR lpszStr, const String& str1 );
    friend String operator+( const String& str1, char ch );
    friend String operator+( char ch, const String& str1 );

public:
    String();
    String( LPCSTR lpszStr );
    String( const String& str );
    String( LPCWSTR pszWstr );
    ~String();

    //BOOL LoadString( UINT nID, HINSTANCE hInstance );

    BOOL IsEmpty() const
    {
        return ( m_wLength == 0 );
    };
    WORD GetLength() const
    {
        return m_wLength;
    };
    int Compare( const String& str ) const
    {
		if (m_pBuf && str.m_pBuf)
		{
			return _wcsicmp( m_pBuf, str.m_pBuf );
		}
		else if (!m_pBuf && !str.m_pBuf)
		{
			return 0;
		}
		else if (!m_pBuf)
		{
			return -1;
		}
		else
		{
			return 1;
		}
    };
    int Compare( LPCWSTR lpwzStr ) const
    {
		if (m_pBuf && lpwzStr)
		{
			return _wcsicmp( m_pBuf, lpwzStr );
		}
		else if (!m_pBuf && !lpwzStr)
		{
			return 0;
		}
		else if (!m_pBuf)
		{
			return -1;
		}
		else
		{
			return 1;
		}
    };
    void Concat( const String& str );
    void Concat( LPCWSTR lpwzStr );
    void Concat( WCHAR wch );
    void TrimTrailingSpaces();
    WCHAR GetAt( UINT nIndex ) const
    {
        if( nIndex >= m_wLength )
        {
            return L'\0';
        }
        return m_pBuf[nIndex];
    };
    void SetAt( UINT nIndex, char ch )
    {
        if( nIndex < m_wLength )
        {
            m_pBuf[nIndex] = ch;
        }
    };
    HRESULT ReadWCS( LPSTREAM pStream, DWORD cSize );
    //HRESULT WriteWCS( LPSTREAM pStream );

// operators
    const String& operator+=( const String& str )   // concatenation
    {
        Concat( str );
        return *this;
    };
    const String& operator+=( LPCSTR lpszStr )      // concatenation
    {
        Concat( lpszStr );
        return *this;
    };
    const String& operator+=( char ch )             // concatenation
    {
        Concat( ch );
        return *this;
    };
    String& operator=( const String& str );
	String& operator=( LPCSTR pszStr );
    String& operator=( LPCWSTR pszWstr );
    operator const WCHAR*() const
    {
        return m_pBuf;
    }

private:
    WORD figureblocksize( WORD slen )
    {
        ++slen;         // for '\0'
        slen = static_cast<WORD>( slen / sm_wBlockSize );
        return static_cast<WORD>( ( slen + 1 ) * sm_wBlockSize );
    };

private:
    WORD m_wLength;
    WORD m_wAllocated;
    WCHAR* m_pBuf;

    static WORD sm_wBlockSize;  // size blocks are allocated in for strings
};

inline BOOL operator==( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) == 0 );
}

inline BOOL operator==( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) == 0 );
}

inline BOOL operator==( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) == 0 );
}

inline BOOL operator!=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) != 0 );
}

inline BOOL operator!=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) != 0 );
}

inline BOOL operator!=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) != 0 );
}

inline BOOL operator<( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) < 0 );
}

inline BOOL operator<( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) > 0 );
}

inline BOOL operator<( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) < 0 );
}

inline BOOL operator>( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) > 0 );
}

inline BOOL operator>( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) < 0 );
}

inline BOOL operator>( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) > 0 );
}

inline BOOL operator<=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) <= 0 );
}

inline BOOL operator<=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) >= 0 );
}

inline BOOL operator<=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) <= 0 );
}

inline BOOL operator>=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) >= 0 );
}

inline BOOL operator>=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) <= 0 );
}

inline BOOL operator>=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) >= 0 );
}
#endif // __BRSTRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include "xalloc.h"

#ifdef XBOX
#include <xtl.h>
extern "C" ULONG _cdecl DbgPrint(PCH Format, ...);
#ifndef _DUMMY_MSG
#define _DUMMY_MSG
struct MSG;
typedef MSG* LPMSG;
#endif
#include <ole2.h>
#else // XBOX
#include <windows.h>
#endif // XBOX

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#ifdef XBOX
#ifdef DBG
#define CHECK_ZOMBIE(exp) \
    if (exp) \
    { \
        Trace(0, "Error: Accessing object after it has been garbage collected. "); \
        return DMUS_S_GARBAGE_COLLECTED; \
    } 
#else // DBG
#define CHECK_ZOMBIE(exp) // Do nothing with XBOX retail.
#endif // !DBG
#else // XBOX
#define CHECK_ZOMBIE(exp) \
    if (exp) \
    { \
        Trace(1, "Error: Accessing object after it has been garbage collected. "); \
        return DMUS_S_GARBAGE_COLLECTED; \
    }
#endif  // !XBOX

#include "alist.h"

//Don't forget to update gpNames in DEBUG.CPP when you update this enumClass structure!!!
typedef enum enumClass
{
    DMTRACK_FILE_STREAM,
    DMTRACK_MEM_STREAM,
    DMTRACK_STREAM_STREAM,
    DMTRACK_SEGMENT,
    DMTRACK_SEGMENT_STATE,
    DMTRACK_LOADER,
    DMTRACK_PERFORMANCE,
    DMTRACK_WAVE_TRACK,
    DMTRACK_WAVE,
    DMTRACK_AUDIOPATH,
    DMTRACK_AUDIOPATH_CONFIG,
    DMTRACK_SCRIPT,
    DMTRACK_GRAPH,
    DMTRACK_BAND,
    DMTRACK_BAND_TRACK,
    DMTRACK_COLLECTION,
    DMTRACK_INSTRUMENT,
    DMTRACK_COMPOSER,
    DMTRACK_CHORDMAP,
    DMTRACK_TEMPLATE,
    DMTRACK_SIGNPOST_TRACK,
    DMTRACK_CHORDMAP_TRACK,
    DMTRACK_LYRICS_TRACK,
    DMTRACK_MARKER_TRACK,
    DMTRACK_PARAM_TRACK,
    DMTRACK_SEGTRIGGER_TRACK,
    DMTRACK_SEQUENCE_TRACK,
    DMTRACK_SONG,
    DMTRACK_SYSEX_TRACK,
    DMTRACK_TEMPO_TRACK,
    DMTRACK_TIMESIG_TRACK,
    DMTRACK_CONTAINER,
    DMTRACK_SYNTH,
    DMTRACK_MAX
} debugClass;

#ifdef DBG
class CMemTrack : public AListItem
{
public:
    CMemTrack(DWORD dwClass);
    ~CMemTrack();
    CMemTrack* GetNext() { return (CMemTrack*)AListItem::GetNext();}
private:
    DWORD   m_dwClass;
};

class CMemTrackList : public AList
{
public:
    CMemTrackList();
    ~CMemTrackList();
    LONG GetCount();
    void AddHead(CMemTrack* pMemTrack);
    CMemTrack* GetHead();
    CMemTrack* RemoveHead();
    void Remove(CMemTrack* pMemTrack);
    CRITICAL_SECTION    m_CriticalSection;
};

#else
class CMemTrack 
{
public:
    CMemTrack(DWORD dwClass) { };
};

class CMemTrackList
{
};
#endif

#if defined(DBG) || defined(PROFILE)
#define IMPLEMENT_PERFORMANCE_COUNTERS
#endif

#ifdef IMPLEMENT_PERFORMANCE_COUNTERS
#include <xbdm.h>
extern "C" void DMusicRegisterPerformanceCounter(const char* szName, unsigned long dwType, void* pvArg);
extern "C" void DMusicUnregisterPerformanceCounter(const char* szName);

extern "C" void DMusicRegisterPerformanceCounters();
extern "C" void DMusicUnregisterPerformanceCounters();

#endif





#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\tlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       tlist.cpp
//
//--------------------------------------------------------------------------

//
// tlist.cpp
//

//#include "stdafx.h"
#include "tlist.h"

template <class T>
TListItem<T>::~TListItem()
{
	//if (m_pNext != NULL) { delete m_pNext; }
	// IMPORTANT: user of the list is required to delete content first!
	//ZeroMemory(&m_Tinfo, sizeof(T));
}

template <class T>
void TListItem<T>::Delete(TListItem<T>* pFirst)
{
	TListItem<T>* pScan = pFirst;
	TListItem<T>* pNext = NULL;
	while (pScan)
	{
		pNext = pScan->m_pNext;
		delete pScan;
		pScan = pNext;
	}
}

template <class T>
LONG TListItem<T>::GetCount(void) const
{
    LONG l;
    const TListItem<T> *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

template <class T>
TListItem<T>* TListItem<T>::Cat(TListItem<T> *pItem)
{
    TListItem<T> *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::Remove(TListItem<T> *pItem)
{
    TListItem<T> *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::GetPrev(TListItem<T> *pItem) const
{
    const TListItem<T> *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (TListItem<T>*)prev;
}

template <class T>
TListItem<T> * TListItem<T>::GetItem(LONG index)

{
	TListItem<T> *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

template <class T>
TListItem<T>* TListItem<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pNext != NULL)
	{
		TListItem<T> *pList1, *pList2;
		Divide(pList1, pList2);
		return pList1->MergeSort(fcnCompare)->Merge(pList2->MergeSort(fcnCompare), fcnCompare);
	}
	return this;
}

template <class T>
void TListItem<T>::Divide(TListItem<T>*& pHead1, TListItem<T>*& pHead2)
{
	TListItem<T> *pCurrent = this, *pTail1 = NULL, *pTail2 = NULL;
	do
	{
		pHead1 = pCurrent;
		pCurrent = pCurrent->m_pNext;
		pHead1->m_pNext = pTail1;
		pTail1 = pHead1;
		if (pCurrent != NULL)
		{
			pHead2 = pCurrent;
			pCurrent = pCurrent->m_pNext;
			pHead2->m_pNext = pTail2;
			pTail2 = pHead2;
		}
	} while (pCurrent != NULL);
}

template <class T>
TListItem<T>* TListItem<T>::Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&))
{
	if (!pOtherList) return this;
	TListItem<T>
		*pThisList = this, *pResultHead = NULL, *pResultTail = NULL, *pMergeItem = NULL;
	while (pThisList && pOtherList)
	{
		if ( fcnCompare(pThisList->m_Tinfo, pOtherList->m_Tinfo) )
		{
			pMergeItem = pThisList;
			pThisList = pThisList->GetNext();
		}
		else
		{
			pMergeItem = pOtherList;
			pOtherList = pOtherList->GetNext();
		}
		pMergeItem->SetNext(NULL);
		if (!pResultTail)
		{
			pResultHead = pResultTail = pMergeItem;
		}
		else
		{
			pResultTail->SetNext(pMergeItem);
			pResultTail = pMergeItem;
		}
	}
	if (pThisList) pResultTail->SetNext(pThisList);
	else pResultTail->SetNext(pOtherList);
	return pResultHead;
}

template <class T>
void TList<T>::InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert)

{
	TListItem<T> *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

template <class T>
void TList<T>::AddTail(TListItem<T> *pItem) 

{
	m_pHead = m_pHead->AddTail(pItem);
}

template <class T>
void TList<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pHead != NULL && m_pHead->GetNext() != NULL)
		m_pHead = m_pHead->MergeSort(fcnCompare);
}

template <class T>
void TList<T>::Reverse(void)
{
	if( m_pHead )
	{
		TListItem<T>* pNewHead = m_pHead;
		TListItem<T>* pNext = m_pHead->GetNext();
		pNewHead->SetNext(NULL);
		for( m_pHead = pNext; m_pHead; m_pHead = pNext )
		{
			pNext = m_pHead->GetNext();
			m_pHead->SetNext(pNewHead);
			pNewHead = m_pHead;
		}
		m_pHead = pNewHead;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\dmusiccp.h ===
//
// dmusiccp.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Private interfaces

#ifndef _DMUSICCP_DOT_H_
#define _DMUSICCP_DOT_H_

#include <dsound.h>  // For IDirectSoundWave
#ifdef XBOX
#include "xsoundp.h"
#endif // XBOX

// Interfaces/methods removed from Direct Music Core layer:

// IDirectMusicVoiceP
interface IDirectMusicVoiceP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicVoiceP
	virtual HRESULT STDMETHODCALLTYPE Play(
         REFERENCE_TIME rtStart,                // Time to play
         LONG prPitch,                          // Initial pitch
         LONG vrVolume                          // Initial volume
        )=0;
    
	virtual HRESULT STDMETHODCALLTYPE Stop(
          REFERENCE_TIME rtStop                 // When to stop
        )=0;
};


// IDirectSoundDownloadedWaveP
interface IDirectSoundDownloadedWaveP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectSoundDownloadedWaveP
};

// IDirectMusicPortP
interface IDirectMusicPortP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicPortP
	virtual HRESULT STDMETHODCALLTYPE DownloadWave(
		IDirectSoundWave *pWave,                // Wave object
        IDirectSoundDownloadedWaveP **ppWave,   // Returned downloaded wave
        REFERENCE_TIME rtStartHint = 0          // Where we're likely to start
        )=0;
        
	virtual HRESULT STDMETHODCALLTYPE UnloadWave(
		IDirectSoundDownloadedWaveP *pWave      // Wave object
        )=0;
            
	virtual HRESULT STDMETHODCALLTYPE AllocVoice(
         IDirectSoundDownloadedWaveP *pWave,    // Wave to play on this voice
         DWORD dwChannel,                       // Channel and channel group
         DWORD dwChannelGroup,                  //  this voice will play on
         REFERENCE_TIME rtStart,                // Start position (stream only)
         SAMPLE_TIME stLoopStart,               // Loop start (one-shot only)
         SAMPLE_TIME stLoopEnd,                 // Loop end (one-shot only)
         IDirectMusicVoiceP **ppVoice           // Returned voice
        )=0;
        
#ifndef XBOX
	virtual HRESULT STDMETHODCALLTYPE AssignChannelToBuses(
		DWORD dwChannelGroup,                   // Channel group and
		DWORD dwChannel,                        // channel to assign
		LPDWORD pdwBuses,                       // Array of bus id's to assign
		DWORD cBusCount                         // Count of bus id's           
        )=0;
#else
	virtual HRESULT STDMETHODCALLTYPE AssignChannelToOutput(
		DWORD dwChannelGroup,                   // Channel group and
		DWORD dwChannel,                        // channel to assign
        IDirectSoundBuffer *pBuffer,            // Buffer, if assigned to buffer.
        DWORD dwMixBins,                        // Or, mixbins, if assigned to them.
        BYTE *pbControllers)=0;

#endif
        
	virtual HRESULT STDMETHODCALLTYPE SetSink(
		IDirectSoundConnect *pSinkConnect       // From IDirectSoundPrivate::AllocSink
        )=0;
        
 	virtual HRESULT STDMETHODCALLTYPE GetSink(
		IDirectSoundConnect **ppSinkConnect     // The sink in use 
        )=0;
};

interface IDirectMusicSynthX;
interface IDirectMusicSynthSink;

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthX
DECLARE_INTERFACE_(IDirectMusicSynthX, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynthX */
    STDMETHOD(Init)                 (THIS_ DWORD dwVoicePoolSize) PURE;
//    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
	STDMETHOD(SetMasterVolume)      (THIS_ LONG lVolume)PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload, 
                                           LPVOID pvData, 
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload, 
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), 
                                           HANDLE hUserData ) PURE; 
//    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt, 
//                                           LPBYTE pbBuffer, 
//                                           DWORD cbBuffer) PURE;
//    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
//    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SendShortMsg)         (THIS_ REFERENCE_TIME rt, DWORD dwGroup, DWORD dwMsg)PURE;
    STDMETHOD(SendLongMsg)          (THIS_ REFERENCE_TIME rt, DWORD dwGroup, BYTE *pbMsg, DWORD dwLength)PURE;
    STDMETHOD(GetMasterClock)       (THIS_ IReferenceClock **ppClock) PURE;
//    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
//    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
//    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
//    STDMETHOD(Render)               (THIS_ short *pBuffer, 
//                                           DWORD dwLength, 
//                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
//    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
//                                           LPDWORD pdwWaveFormatExSize) PURE;
//    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
    STDMETHOD(PlayWave)            (THIS_ REFERENCE_TIME rt,
										   DWORD dwChannelGroup, 
										   DWORD dwChannel,
										   long	 prPitch,			/* PREL not defined here */
										   long  vrVolume,          /* VREL not defined here */
                                           SAMPLE_TIME stVoiceStart,
                                           SAMPLE_TIME stLoopStart,
                                           SAMPLE_TIME stLoopEnd,
                                           IDirectSoundWave *pIWave,
                                           DWORD *pdwVoiceID) PURE;

    STDMETHOD(StopWave)            (THIS_ REFERENCE_TIME rt, 
										   DWORD dwVoiceId ) PURE;

//    STDMETHOD(GetVoiceState)        (THIS_ DWORD dwVoice[], 
//										   DWORD cbVoice,
//										   DMUS_VOICE_STATE dwVoiceState[] ) PURE;
//    STDMETHOD(Refresh)              (THIS_ DWORD dwDownloadID,
//                                           DWORD dwFlags) PURE;
//    STDMETHOD(IsReadyForData)       (THIS_ DWORD dwDownloadID) PURE;
    STDMETHOD(AssignChannelToOutput) (THIS_ DWORD dwChannelGroup,                   // Channel group and
		                                    DWORD dwChannel,                        // channel to assign
                                            IDirectSoundBuffer *pBuffer,            // Buffer, if assigned to buffer.
                                            DWORD dwMixBins,
                                            BYTE *pbMixBins)PURE;
};


// GUIDs for new core layer private interfaces
DEFINE_GUID(IID_IDirectMusicSynthX, 0x827ae931, 0xe44, 0x420d, 0x95, 0x24, 0x56, 0xf4, 0x93, 0x57, 0x8, 0xa6);
DEFINE_GUID(IID_IDirectMusicVoiceP, 0x827ae928, 0xe44, 0x420d, 0x95, 0x24, 0x56, 0xf4, 0x93, 0x57, 0x8, 0xa6);
DEFINE_GUID(IID_IDirectSoundDownloadedWaveP, 0x3b527b6e, 0x5577, 0x4060, 0xb9, 0x6, 0xcd, 0x34, 0xa, 0x46, 0x71, 0x27);
DEFINE_GUID(IID_IDirectMusicPortP, 0x7048bcd8, 0x43fd, 0x4ca5, 0x93, 0x11, 0xf3, 0x24, 0x8f, 0xa, 0x25, 0x22);

// Class ID for synth sink. We pulled this from public headers since apps should never cocreate this.
DEFINE_GUID(CLSID_DirectMusicSynthSink,0xaec17ce3, 0xa514, 0x11d1, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);


#endif          // _DMUSICCP_DOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\tlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       tlist.h
//
//--------------------------------------------------------------------------

//
// tlist.h --- template version of AList
//
#ifndef __TLIST_H__
#define __TLIST_H__

//#include "stdafx.h"

//template <class T>
//typedef BOOL (* TRelation) (T, T);

// TListItem<> contains four more members than AListItem: one additional constructor,
// a destructor, one member function, and one data member.
template <class T>
class TListItem
{
public:
    TListItem() { m_pNext=NULL; };
    ~TListItem();												// new destructor
	static void Delete(TListItem<T>* pFirst);                           // new deletion helper
    TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.
    TListItem<T> *GetNext() const {return m_pNext;};
    void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    TListItem<T>* Cat(TListItem<T>* pItem);
    TListItem<T>* AddTail(TListItem<T>* pItem) {return Cat(pItem);};
    TListItem<T>* Remove(TListItem<T>* pItem);
    TListItem<T>* GetPrev(TListItem<T> *pItem) const;
    TListItem<T>* GetItem(LONG index);
    T& GetItemValue() { return m_Tinfo; }  // additional member function
	TListItem<T>* MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list items 
private:
	void Divide(TListItem<T>* &pHalf1, TListItem<T>* &pHalf2);
	TListItem<T>* Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&));
	T m_Tinfo;  // additional data member, but memory is the same since in AListItem 
				// you put the extra data member in the derived class 
    TListItem<T> *m_pNext;
};

// TList<> adds a destructor to AList.
template <class T>
class TList
{
public:
    TList() {m_pHead=NULL;}
	~TList()
	{ 
		//if (m_pHead != NULL) delete m_pHead;
		TListItem<T>::Delete(m_pHead);
	} // new destructor
    TListItem<T> *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    void CleanUp() 
	{ 
		//if (m_pHead) delete m_pHead;
		if (m_pHead) TListItem<T>::Delete(m_pHead);
		m_pHead=NULL;
	}
    LONG GetCount() const {return m_pHead->GetCount();}; 
    TListItem<T> *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert);
    void Cat(TListItem<T> *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(TList<T> *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(TListItem<T> *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(TListItem<T> *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(TListItem<T> *pItem) {m_pHead=m_pHead->Remove(pItem);};
    TListItem<T> *GetPrev(TListItem<T> *pItem) const {return m_pHead->GetPrev(pItem);};
    TListItem<T> *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    TListItem<T> *RemoveHead(void)
        {
            TListItem<T> *li;
            li=m_pHead;
            if(m_pHead)
			{
                m_pHead=m_pHead->GetNext();
				li->SetNext(NULL);
			}
            return li;
        }
	void MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list
	void Reverse(void); // Reverses the entire list

protected:
    TListItem<T> *m_pHead;
};

#include "tlist.cpp"

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\toolprops_i.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* at Fri Jun 23 00:16:49 2000
 */
/* Compiler settings for ..\toolprops.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_TOOLPROPSLib,0x2735B8F3,0xFF4A,0x4AF2,0x80,0x53,0xBE,0x22,0xC0,0xCA,0x32,0x32);


MIDL_DEFINE_GUID(CLSID, CLSID_EchoPage,0x5337AF8F,0x3827,0x44DD,0x9E,0xE9,0xAB,0x6E,0x1A,0xAB,0xB6,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_TransposePage,0x691BD8C2,0x2B07,0x4C92,0xA8,0x2E,0x92,0xD8,0x58,0xDE,0x23,0xD6);


MIDL_DEFINE_GUID(CLSID, CLSID_DurationPage,0x79D9CAF8,0xDBDA,0x4560,0xA8,0xB0,0x07,0xE7,0x3A,0x79,0xFA,0x6B);


MIDL_DEFINE_GUID(CLSID, CLSID_QuantizePage,0x623286DC,0x67F8,0x4055,0xA9,0xBE,0xF7,0xA7,0x17,0x6B,0xD1,0x50);


MIDL_DEFINE_GUID(CLSID, CLSID_TimeShiftPage,0x7D3BDEE7,0x9557,0x4085,0x82,0xEE,0x1B,0x2F,0x02,0xCE,0x4B,0xA6);


MIDL_DEFINE_GUID(CLSID, CLSID_SwingPage,0x0B237E01,0x062A,0x4A40,0x8D,0x43,0x4B,0x5F,0xCD,0x49,0x96,0x5A);


MIDL_DEFINE_GUID(CLSID, CLSID_VelocityPage,0x30EC7213,0x64BE,0x4EF6,0xBB,0x1B,0x46,0x34,0x27,0xEC,0x86,0x4B);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0328 */
/* at Fri Jun 23 00:16:49 2000
 */
/* Compiler settings for ..\toolprops.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_TOOLPROPSLib,0x2735B8F3,0xFF4A,0x4AF2,0x80,0x53,0xBE,0x22,0xC0,0xCA,0x32,0x32);


MIDL_DEFINE_GUID(CLSID, CLSID_EchoPage,0x5337AF8F,0x3827,0x44DD,0x9E,0xE9,0xAB,0x6E,0x1A,0xAB,0xB6,0x0F);


MIDL_DEFINE_GUID(CLSID, CLSID_TransposePage,0x691BD8C2,0x2B07,0x4C92,0xA8,0x2E,0x92,0xD8,0x58,0xDE,0x23,0xD6);


MIDL_DEFINE_GUID(CLSID, CLSID_DurationPage,0x79D9CAF8,0xDBDA,0x4560,0xA8,0xB0,0x07,0xE7,0x3A,0x79,0xFA,0x6B);


MIDL_DEFINE_GUID(CLSID, CLSID_QuantizePage,0x623286DC,0x67F8,0x4055,0xA9,0xBE,0xF7,0xA7,0x17,0x6B,0xD1,0x50);


MIDL_DEFINE_GUID(CLSID, CLSID_TimeShiftPage,0x7D3BDEE7,0x9557,0x4085,0x82,0xEE,0x1B,0x2F,0x02,0xCE,0x4B,0xA6);


MIDL_DEFINE_GUID(CLSID, CLSID_SwingPage,0x0B237E01,0x062A,0x4A40,0x8D,0x43,0x4B,0x5F,0xCD,0x49,0x96,0x5A);


MIDL_DEFINE_GUID(CLSID, CLSID_VelocityPage,0x30EC7213,0x64BE,0x4EF6,0xBB,0x1B,0x46,0x34,0x27,0xEC,0x86,0x4B);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\tpool.h ===
// Copyright (c) 1998 Microsoft Corporation
//
// TPool.h
//
// Template pool memory manager. Efficiently manage requests for many of the same (small) object.
// Named after t'Pool, the Vulcan programmer who invented the technique.
//
#ifndef _TPOOL_H_
#define _TPOOL_H_

#include "debug.h"

#define POOL_DEFAULT_BYTE_PER_BLOCK     4096
#define MIN_ITEMS_PER_BLOCK             4

///////////////////////////////////////////////////////////////////////////////
//
// CPool
//
// A simple memory manager that efficiently handles many objects of the same 
// size by allocating blocks containing multiple objects at once.
//
// 
template<class contained> class CPool
{
public:
    CPool(int nApproxBytesPerBlock = POOL_DEFAULT_BYTE_PER_BLOCK);
    ~CPool();

    contained *Alloc();
    void Free(contained* pToFree);

private:
    union CPoolNode
    {
        CPoolNode       *pNext;
        contained       c;
    };

    class CPoolBlock
    {
    public:
        CPoolBlock      *pNext;
        CPoolNode       *pObjects;
    };

    int                 nItemsPerBlock;             // Based on bytes per block
    int                 nAllocatedBlocks;           // # allocated blocks
    CPoolBlock          *pAllocatedBlocks;          // list of allocated blocks
    int                 nFreeList;                  // # nodes in free list
    CPoolNode           *pFreeList;                 // free list

private:
    bool RefillFreeList();

#ifdef DBG
    bool IsPoolNode(CPoolNode *pNode);
    bool IsInFreeList(CPoolNode *pNode);
#endif

};

///////////////////////////////////////////////////////////////////////////////
//
// CPool::CPool
//
// Figure out the number of contained objects per block based on the requested
// approximate block size. Initialize the free list to contain one block's 
// worth of objects.
// 
//
template<class contained> CPool<contained>::CPool(int nApproxBytesPerBlock)
{
    // Figure out how many items per block and cheat if too small
    //
    nItemsPerBlock = nApproxBytesPerBlock / sizeof(CPoolNode);
    if (nItemsPerBlock < MIN_ITEMS_PER_BLOCK)
    {
        nItemsPerBlock = MIN_ITEMS_PER_BLOCK;
    }

    nAllocatedBlocks = 0;
    pAllocatedBlocks = NULL;
    nFreeList = 0;
    pFreeList = NULL;

    // Fill up with some items ahead of time
    //
    RefillFreeList();
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::~CPool
//
// Free up all allocated blocks. There should be no outstanding blocks 
// allocated at this point.
//
// 
template<class contained> CPool<contained>::~CPool()
{
#ifdef DBG
    if (nFreeList < nAllocatedBlocks * nItemsPerBlock)
    {
        Trace(0, "CPool::~Cpool: Warning: free'ing with outstanding objects allocated.\n");
    }
#endif
    
    // Clean up all allocated blocks and contained objects.
    //
    while (pAllocatedBlocks)
    {
        CPoolBlock *pNext = pAllocatedBlocks->pNext;

        delete[] pAllocatedBlocks->pObjects;
        delete pAllocatedBlocks;

        pAllocatedBlocks = pNext;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Alloc
//
// Attempt to allocate a contained object and return NULL if out of memory.
// If the free list is empty then allocate another block.
//
// 
template<class contained> contained *CPool<contained>::Alloc()
{
    if (pFreeList == NULL)
    {
        if (!RefillFreeList())
        {
            return false;
        }
    }

    nFreeList--;
    contained *pAlloc = (contained*)pFreeList;
    pFreeList = pFreeList->pNext;

    return pAlloc;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::Free
//
// Return a contained object to the free list. In the debug version make sure
// the object was in fact allocated from this pool in the first place and that
// it isn't already in the free list.
//
// 
template<class contained> void CPool<contained>::Free(contained *pToFree)
{
    CPoolNode *pNode = (CPoolNode*)pToFree;

#ifdef DBG
    if (!IsPoolNode(pNode))
    {
        Trace(0, "CPool::Free() Object %p is not a pool node; ignored.\n", pToFree);
        return;
    }
    
    if (IsInFreeList(pNode))
    {
        Trace(0, "CPool::Free() Object %p is already in the free list; ignored.\n", pToFree);
        return;
    }
#endif

    nFreeList++;
    pNode->pNext = pFreeList;
    pFreeList = pNode;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::RefillFreeList
//
// Add one block's worth of contained objects to the free list, tracking the 
// allocated memory so we can free it later.
//
// 
template<class contained> bool CPool<contained>::RefillFreeList()
{
    // Allocate a new block and the actual block of objects
    //
    CPoolBlock *pNewBlock = new CPoolBlock;
    if (pNewBlock == NULL)
    {
        return false;
    }

    pNewBlock->pObjects = new CPoolNode[nItemsPerBlock];
    if (pNewBlock->pObjects == NULL)
    {
        delete pNewBlock;
        return false;
    }

    // Link the block and objects into the right places. First link the new block
    // into the list of allocated blocks.
    //
    pNewBlock->pNext = pAllocatedBlocks;
    pAllocatedBlocks = pNewBlock;

    // Link all the contained object nodes into the free list.
    //
    CPoolNode *pFirstNode = &pNewBlock->pObjects[0];
    CPoolNode *pLastNode  = &pNewBlock->pObjects[nItemsPerBlock - 1];

    for (CPoolNode *pNode = pFirstNode; pNode < pLastNode; pNode++)
    {
        pNode->pNext = pNode + 1;
    }

    pLastNode->pNext = pFreeList;
    pFreeList = pFirstNode;
    
    nFreeList += nItemsPerBlock;
    nAllocatedBlocks++;

    return true;
}

#ifdef DBG
///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsPoolNode (debug)
//
// Verify that the passed pointer is a pointer to a pool node by walking the list
// of allocated blocks.
//
// 
template<class contained> bool CPool<contained>::IsPoolNode(CPoolNode *pTest)
{
    for (CPoolBlock *pBlock = pAllocatedBlocks; pBlock; pBlock = pBlock->pNext)
    {
        CPoolNode *pFirstNode = &pBlock->pObjects[0];
        CPoolNode *pLastNode  = &pBlock->pObjects[nItemsPerBlock - 1];

        for (CPoolNode *pNode = pFirstNode; pNode <= pLastNode; pNode++)
        {
            if (pNode == pTest)
            {
                return true;
            }
        }
    }

    return false;
}

///////////////////////////////////////////////////////////////////////////////
//
// CPool::IsInFreeList (debug)
//
// Verify that the passed pointer points to a node that is already in the free
// list.
//
// 
template<class contained> bool CPool<contained>::IsInFreeList(CPoolNode *pTest)
{
    for (CPoolNode *pNode = pFreeList; pNode; pNode = pNode->pNext)
    {
        if (pTest == pNode)
        {
            return true;
        }
    }
    
    return false;
}
#endif  // DBG
#endif  // _TPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\trackhelp.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Implementations for CBasicTrack.
//

#include "trackhelp.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// Creation

CBasicTrack::CBasicTrack(long *plModuleLockCounter)
  : m_cRef(0),
	m_plModuleLockCounter(plModuleLockCounter)
{
	InitializeCriticalSection(&m_CriticalSection);
	InterlockedIncrement(plModuleLockCounter);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP 
CBasicTrack::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CBasicTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
		*ppv = static_cast<IDirectMusicTrack8*>(this);
	else if (iid == IID_IPersistStream)
		*ppv = static_cast<IPersistStream*>(this);
	else if (iid == IID_IPersist)
		*ppv = static_cast<IPersist*>(this);
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG)
CBasicTrack::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CBasicTrack::Release()
{
	if (!InterlockedDecrement(&m_cRef))
	{
		DeleteCriticalSection(&m_CriticalSection);
		delete this;
		return 0;
	}

	return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

STDMETHODIMP
CBasicTrack::Init(IDirectMusicSegment *pSegment)
{
	V_INAME(CBasicTrack::Init);
	V_INTERFACE(pSegment);
	return S_OK;
}

STDMETHODIMP
CBasicTrack::Play(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID)
{
	return this->PlayMusicOrClock(
					pStateData,
					mtStart,
					mtEnd,
					mtOffset,
					0,
					dwFlags,
					pPerf,
					pSegSt,
					dwVirtualID,
					false);
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack8

STDMETHODIMP CBasicTrack::PlayEx(
		void* pStateData,
		REFERENCE_TIME rtStart,
		REFERENCE_TIME rtEnd,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID)
{
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
	    // Convert all reference times to millisecond times and then just use them as if this were MUSIC_TIME.
	    return this->PlayMusicOrClock(
					pStateData,
					static_cast<MUSIC_TIME>(rtStart / gc_RefPerMil),
					static_cast<MUSIC_TIME>(rtEnd / gc_RefPerMil),
					static_cast<MUSIC_TIME>(rtOffset / gc_RefPerMil),
					rtOffset,
					dwFlags,
					pPerf,
					pSegSt,
					dwVirtualID,
					true);
    }
    else
    {
        return this->PlayMusicOrClock(
					pStateData,
					static_cast<MUSIC_TIME>(rtStart),
					static_cast<MUSIC_TIME>(rtEnd),
					static_cast<MUSIC_TIME>(rtOffset),
					0,
					dwFlags,
					pPerf,
					pSegSt,
					dwVirtualID,
					false);
    }
}

STDMETHODIMP CBasicTrack::GetParamEx(
		REFGUID rguidType,
		REFERENCE_TIME rtTime,
		REFERENCE_TIME* prtNext,
		void* pParam,
        void * pStateData,
        DWORD dwFlags)
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
	    hr = GetParam(rguidType, static_cast<MUSIC_TIME>(rtTime / gc_RefPerMil), &mtNext, pParam);
	    if (prtNext)
	    {
		    *prtNext = mtNext * gc_RefPerMil;
	    }
    }
    else
    {
	    hr = GetParam(rguidType, static_cast<MUSIC_TIME>(rtTime), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CBasicTrack::SetParamEx(
		REFGUID rguidType,
		REFERENCE_TIME rtTime,
		void* pParam, void * pStateData, DWORD dwFlags) 
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= gc_RefPerMil;
    }
	return SetParam(rguidType, static_cast<MUSIC_TIME>(rtTime ), pParam);
}


STDMETHODIMP CBasicTrack::Compose(
		IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CBasicTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\dmstrm.cpp ===
//
// dmstrm.cpp
// 
// Copyright (c) 1995-2000 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

/////////////////////////////////////////////////////////////////////////////
// AllocDIrectMusicStream

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream)
{
	if(pIStream == NULL || ppIDMStream == NULL)
	{
		return E_INVALIDARG;            
	}

	if((*ppIDMStream = (IDMStream*) new CDirectMusicStream()) == NULL)
    {
		return E_OUTOFMEMORY;
    }
	
	((CDirectMusicStream*)*ppIDMStream)->Init(pIStream);
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CDirectMusicStream

CDirectMusicStream::CDirectMusicStream() :
m_cRef(1),
m_pStream(NULL)
{
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::~CDirectMusicStream
   
CDirectMusicStream::~CDirectMusicStream()
{
	if(m_pStream != NULL)
    {
		m_pStream->Release();
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Init
   
STDMETHODIMP CDirectMusicStream::Init(IStream* pStream)
{
    SetStream(pStream);
	
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::QueryInterface

STDMETHODIMP CDirectMusicStream::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CDirectMusicStream::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if(iid == IID_IUnknown || iid == IID_IDMStream)
	{
		*ppv = static_cast<IDMStream*>(this);
    } 
	else 
	{
		*ppv = NULL;
		return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::AddRef

STDMETHODIMP_(ULONG) CDirectMusicStream::AddRef()
{
	return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Release

STDMETHODIMP_(ULONG) CDirectMusicStream::Release()
{
    if(!InterlockedDecrement(&m_cRef)) 
	{
		delete this;
		return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::SetStream

STDMETHODIMP CDirectMusicStream::SetStream(IStream* pStream)
{
    if(m_pStream != NULL)
    {
		m_pStream->Release();
    }

	m_pStream = pStream;
    
	if(m_pStream != NULL)
    {
		m_pStream->AddRef();
    }
    
	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::GetStream

STDMETHODIMP_(IStream*) CDirectMusicStream::GetStream()
{
	if(m_pStream != NULL)
    {
		m_pStream->AddRef();
    }
    
	return m_pStream;
}

//////////////////////////////////////////////////////////////////////
// IDMStream

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Descend

STDMETHODIMP CDirectMusicStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    assert(lpck);

	FOURCC ckidFind;           // Chunk ID to find (or NULL)
    FOURCC fccTypeFind;    // Form/list type to find (or NULL)

    // Figure out what chunk id and form/list type for which to search
    if(wFlags & MMIO_FINDCHUNK)
	{
		ckidFind = lpck->ckid;
		fccTypeFind = NULL;
	}
    else if(wFlags & MMIO_FINDRIFF)
    {
		ckidFind = FOURCC_RIFF;
		fccTypeFind = lpck->fccType;
    }
	else if(wFlags & MMIO_FINDLIST)
	{
		ckidFind = FOURCC_LIST;
		fccTypeFind = lpck->fccType;
	}
    else
    {
		ckidFind = fccTypeFind = NULL;
	}

    lpck->dwFlags = 0L;

    for(;;)
    {
		HRESULT hr;
		LARGE_INTEGER li;
		ULARGE_INTEGER uli;
		ULONG cbRead;

		// Read the chunk header
		hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

        if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))
		{
            Trace(1,"Error: Unable to read file.\n");
			return DMUS_E_DESCEND_CHUNK_FAIL;
		}

		// Store the offset of the data part of the chunk
		li.QuadPart = 0;
		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to read file.\n");
			return DMUS_E_CANNOTSEEK;
		}
		else
		{
			lpck->dwDataOffset = uli.LowPart;
		}

		// See if the chunk is within the parent chunk (if given)
		if((lpckParent != NULL) &&
		   (lpck->dwDataOffset - 8L >=
		   lpckParent->dwDataOffset + lpckParent->cksize))
		{
            Trace(1,"Error: Unable to read file.\n");
			return DMUS_E_DESCEND_CHUNK_FAIL;
		}

		// If the chunk is a 'RIFF' or 'LIST' chunk, read the
		// form type or list type
		if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
		{

			ULONG cbRead;

			hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

			if(FAILED(hr) || (cbRead != sizeof(DWORD)))
			{
                Trace(1,"Error: Unable to read file.\n");
				return DMUS_E_DESCEND_CHUNK_FAIL;
			}
		}
		else
		{
			lpck->fccType = NULL;
		}

		// If this is the chunk we're looking for, stop looking
		if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
		   ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))
		{
			break;
		}

		// Ascend out of the chunk and try again
		HRESULT w = Ascend(lpck, 0);
		if(FAILED(w))
		{
			return w;
		}
	}

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Ascend

STDMETHODIMP CDirectMusicStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
	assert(lpck);

    HRESULT hr;
	LARGE_INTEGER li;
	ULARGE_INTEGER uli;
	
	if (lpck->dwFlags & MMIO_DIRTY)
    {
		// <lpck> refers to a chunk created by CreateChunk();
		// check that the chunk size that was written when
		// CreateChunk() was called is the real chunk size;
		// if not, fix it
		LONG lOffset;           // current offset in file
		LONG lActualSize;   // actual size of chunk data

		li.QuadPart = 0;
		hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTSEEK;
		}
		else
		{
			lOffset = uli.LowPart;
		}
		
		if((lActualSize = lOffset - lpck->dwDataOffset) < 0)
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTWRITE;
		}

		if(LOWORD(lActualSize) & 1)
		{
			ULONG cbWritten;

			// Chunk size is odd -- write a null pad byte
			hr = m_pStream->Write("\0", 1, &cbWritten); 
			
			if(FAILED(hr) || cbWritten != 1)
			{
                Trace(1,"Error: Unable to write file.\n");
				return DMUS_E_CANNOTWRITE;
			}
		
		}
	
		if(lpck->cksize == (DWORD)lActualSize)
		{
			return S_OK;
		}

		// Fix the chunk header
		lpck->cksize = lActualSize;

		li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);
		hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

		if(FAILED(hr))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTSEEK;
		}

		ULONG cbWritten;

		hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten); 
		
		if(FAILED(hr) || cbWritten != sizeof(DWORD))
		{
            Trace(1,"Error: Unable to write file.\n");
			return DMUS_E_CANNOTWRITE;
		}
    }

	// Seek to the end of the chunk, past the null pad byte
	// (which is only there if chunk size is odd)
	li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);
	hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

	if(FAILED(hr))
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTSEEK;
	}

	return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CreateChunk

STDMETHODIMP CDirectMusicStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
	assert(lpck);

    UINT iBytes;    // Bytes to write
    LONG lOffset;   // Current offset in file

	// Store the offset of the data part of the chunk
	LARGE_INTEGER li;
	ULARGE_INTEGER uli;

	li.QuadPart = 0;
	HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

	if(FAILED(hr))
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTSEEK;
	}
    else
	{
		lOffset = uli.LowPart;
	}
    
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if(wFlags & MMIO_CREATERIFF)
	{
		lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    }
	else if(wFlags & MMIO_CREATELIST)
	{
		lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
	}
    else
    {
		iBytes = 2 * sizeof(DWORD);
	}

    // Write the chunk header
	ULONG cbWritten;

	hr = m_pStream->Write(lpck, iBytes, &cbWritten); 
		
	if(FAILED(hr) || cbWritten != iBytes)
	{
        Trace(1,"Error: Unable to write file.\n");
		return DMUS_E_CANNOTWRITE;
	}

	lpck->dwFlags = MMIO_DIRTY;

    return S_OK;
}

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream; 
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent) 
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
	    HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
		    {
			    hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
                else
                {
                    Trace(1,"Error: Unable to read file.\n");
                }
		    }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        else
        {
            Trace(1,"Error: Unable to read file.\n");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                Trace(1,"Error: Unable to read file.\n");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            Trace(1,"Error: Unable to read %ld bytes from file.\n",cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
		li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which 
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD))); 
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart + 
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\pchmap.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* This is a class to manage tracking mutes for the SeqTrack and BandTrack. */

#ifndef _PCHMAP__
#define _PCHMAP__
#include "dmusicip.h"
#include "..\dmstyle\tlist.h"

struct PCHMAP_ITEM
{
	MUSIC_TIME	mtNext;
	DWORD		dwPChannel;
	DWORD		dwPChMap;
	BOOL		fMute;
};

class CPChMap
{
public:
	CPChMap();
	~CPChMap();
	void Reset(void);
	void GetInfo( DWORD dwPCh, MUSIC_TIME mtTime, MUSIC_TIME mtOffset, DWORD dwGroupBits,
				  IDirectMusicPerformance* pPerf, BOOL* pfMute, DWORD* pdwNewPCh , BOOL fClockTime);
private:
	TList<PCHMAP_ITEM>	m_PChMapList;
};
#endif // _PCHMAP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\urlmonhelper.h ===
// Needed to get urlmon.h to compile

#pragma once

#ifdef XBOX
#ifndef _SECURITY_ATTRIBUTES_
#define _SECURITY_ATTRIBUTES_
typedef struct  _SECURITY_ATTRIBUTES
    {
    DWORD nLength;
    /* [size_is] */ LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
    }	SECURITY_ATTRIBUTES;
#endif // !_SECURITY_ATTRIBUTES_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\dmusicp.h ===
//
// dmusicp.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Private interfaces

#ifndef _DMUSICP_DOT_H_
#define _DMUSICP_DOT_H_

#include <dmusicf.h>
#include <dmusicc.h>
#ifdef XBOX
#include "xboxutil.h"
#endif

// private guid for script track events
DEFINE_GUID(IID_CScriptTrackEvent, 0x8f42c9da, 0xd37a, 0x499c, 0x85, 0x82, 0x1a, 0x80, 0xeb, 0xf9, 0xb2, 0x3c);

// Stuff used in melody formulation that's currently either not implemented or hidden by Producer.

/* Used to get a playmode to be used for a melody (pParam points to a single byte) */
DEFINE_GUID(GUID_MelodyPlaymode, 0x288ea6ca, 0xaecc, 0x4327, 0x9f, 0x79, 0xfb, 0x46, 0x44, 0x37, 0x4a, 0x65);

#define DMUS_FRAGMENTF_ANTICIPATE      (0x1 << 3) /* Anticipate next chord */
#define DMUS_FRAGMENTF_INVERT          (0x1 << 4) /* Invert the fragment */
#define DMUS_FRAGMENTF_REVERSE         (0x1 << 5) /* Reverse the fragment */
#define DMUS_FRAGMENTF_SCALE           (0x1 << 6) /* Align MIDI values with scale intervals */
#define DMUS_FRAGMENTF_CHORD           (0x1 << 7) /* Align MIDI values with chord intervals */
#define DMUS_FRAGMENTF_USE_PLAYMODE    (0x1 << 8) /* Use playmode to compute MIDI values */

#define DMUS_CONNECTIONF_GHOST         0x1        /* Use ghost notes for transitions */

// flags used in ComposeSegmentFromTemplateEx
typedef enum enumDMUS_COMPOSE_TEMPLATEF_FLAGS
{
    DMUS_COMPOSE_TEMPLATEF_ACTIVITY    = 0x1, // Use activity level (dx7 default)
    DMUS_COMPOSE_TEMPLATEF_CLONE       = 0x2  // Clone a segment from the template (dx7 default)
} DMUS_COMPOSE_TEMPLATEF_FLAGS;

// Interfaces/methods removed from Direct Music Performance layer:

// IDirectMusicSegment8P
interface IDirectMusicSegment8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicSegment8P
	virtual HRESULT STDMETHODCALLTYPE GetObjectInPath(
		DWORD dwPChannel,    /* PChannel to search. */
		DWORD dwStage,       /* Which stage in the path. */
		DWORD dwBuffer,      /* Which buffer to address, if more than one. */
		REFGUID guidObject,  /* ClassID of object. */
		DWORD dwIndex,       /* Which object of that class. */
		REFGUID iidInterface,/* Requested COM interface. */
		void ** ppObject)=0; /* Pointer to interface. */
    virtual HRESULT STDMETHODCALLTYPE GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader)=0; /* Header chunk to fill. */
    virtual HRESULT STDMETHODCALLTYPE SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader)=0; /* Header chunk to fill. */
    virtual HRESULT STDMETHODCALLTYPE SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority) = 0;      /* Priority to set. */
    virtual HRESULT STDMETHODCALLTYPE SetAudioPathConfig(
        IUnknown *pAudioPathConfig) = 0; /* Audio path config, from file. */
};


// IDirectMusicComposer8P
interface IDirectMusicComposer8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicComposer8P
    // Use style to get embellishment lengths
	virtual HRESULT STDMETHODCALLTYPE ComposeTemplateFromShapeEx(
		WORD wNumMeasures,
		WORD wShape, 
		BOOL fIntro,
		BOOL fEnd,
		IDirectMusicStyle* pStyle, 
		IDirectMusicSegment** ppTemplate)=0;
    // New flags DWORD (discard activity level; compose in place)
    virtual HRESULT STDMETHODCALLTYPE ComposeSegmentFromTemplateEx(
        IDirectMusicStyle* pStyle, 
        IDirectMusicSegment* pTemplate, 
        DWORD dwFlags,
        DWORD dwActivity,
        IDirectMusicChordMap* pChordMap, 
        IDirectMusicSegment** ppSegment)=0;
};

//  IDirectMusicStyle8P
interface IDirectMusicStyle8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	//  IDirectMusicStyle8P
	virtual HRESULT STDMETHODCALLTYPE ComposeMelodyFromTemplate(
		IDirectMusicStyle* pStyle, 
		IDirectMusicSegment* pTemplate, 
        IDirectMusicSegment** ppSegment)=0;
};

// IDirectMusicLoader8P
interface IDirectMusicLoader8P : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicLoader8P
	virtual HRESULT STDMETHODCALLTYPE GetDynamicallyReferencedObject(
		IDirectMusicObject *pSourceObject,
		LPDMUS_OBJECTDESC pDesc,
		REFIID riid,
		LPVOID FAR *ppv)=0;
	virtual HRESULT STDMETHODCALLTYPE ReportDynamicallyReferencedObject(
		IDirectMusicObject *pSourceObject,
		IUnknown *pReferencedObject)=0;

	// These should probably never be exposed publicly.
	// Scripts hold a reference to the loader because they need to be able to inform it
	// when they set variables to reference DirectMusic objects the loader tracks for
	// garbage collection.  However, that would create a circular reference because the
	// loader also holds a reference to scripts in its cache.  Garbage collection can't break
	// a circular reference that the loader itself is involved in.  Instead we use these private
	// ref count methods.  When the app is no longer using the loader (public Release drops
	// to zero) then the loader can clear its cache.  This releases references to scripts
	// (and also to streams, which use the same technique), triggering them to do ReleaseP
	// and everything gets cleaned up.
	virtual ULONG STDMETHODCALLTYPE AddRefP() = 0;	// Private AddRef, for scripts.
	virtual ULONG STDMETHODCALLTYPE ReleaseP() = 0;	// Private Release, for scripts.
};

// IDirectMusicBandP
interface IDirectMusicBandP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicBandP
	virtual HRESULT STDMETHODCALLTYPE DownloadEx(IUnknown *pAudioPath)=0; 
	virtual HRESULT STDMETHODCALLTYPE UnloadEx(IUnknown *pAudioPath)=0; 
};

// IDirectMusicObjectP
interface IDirectMusicObjectP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicObjectP
	virtual void STDMETHODCALLTYPE Zombie()=0; 
};

// IDirectMusicPerformanceP
interface IDirectMusicPerformanceP : IUnknown
{
	// IUnknown
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *)=0; 
	virtual ULONG STDMETHODCALLTYPE AddRef()=0; 
	virtual ULONG STDMETHODCALLTYPE Release()=0; 

	// IDirectMusicPerformanceP
    virtual HRESULT STDMETHODCALLTYPE GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags) = 0;
};

#define DM_PORTFLAGS_GM     1       /* Synth has GM set locally. */
#define DM_PORTFLAGS_GS     2       /* Synth has GS set locally. */
#define DM_PORTFLAGS_XG     4       /* Synth has XG set locally. */


// Private path stage to access the sink.
#define DMUS_PATH_SINK             0x5000      /* Access the DSound Sink interface. */

// GUIDs for new performance layer private interfaces
DEFINE_GUID(IID_IDirectMusicSegment8P, 0x4bd7fb35, 0x8253, 0x48e0, 0x90, 0x64, 0x8a, 0x20, 0x89, 0x82, 0x37, 0xcb);
DEFINE_GUID(IID_IDirectMusicComposer8P, 0xabaf70dc, 0xdfba, 0x4adf, 0xbf, 0xa9, 0x7b, 0x0, 0xe4, 0x19, 0xeb, 0xbb);
DEFINE_GUID(IID_IDirectMusicStyle8P, 0x2b7c5f39, 0x990a, 0x4fd7, 0x9b, 0x70, 0x1e, 0xa3, 0xde, 0x31, 0x55, 0xa5);
DEFINE_GUID(IID_IDirectMusicLoader8P, 0x3939facd, 0xf6ed, 0x4619, 0xbd, 0x16, 0x56, 0x60, 0x3f, 0x1, 0x51, 0xca);
DEFINE_GUID(IID_IDirectMusicBandP, 0xf2e00137, 0xa131, 0x4289, 0xaa, 0x6c, 0xa9, 0x60, 0x7d, 0x4, 0x85, 0xf5);
DEFINE_GUID(IID_IDirectMusicObjectP, 0x6a20c217, 0xeb3e, 0x40ec, 0x9f, 0x3a, 0x92, 0x5, 0x8, 0x70, 0x2b, 0x5e);
DEFINE_GUID(IID_IDirectMusicPerformanceP, 0xe583be58, 0xe93f, 0x4316, 0xbb, 0x6b, 0xcb, 0x2c, 0x71, 0x96, 0x40, 0x44);
DEFINE_GUID(IID_CFileStream, 0x6d03e6e2, 0xd7a6, 0x47c3, 0xbf, 0x62, 0x12, 0x46, 0xe, 0x3, 0xf4, 0x60);
DEFINE_GUID(IID_CMemStream, 0x6d03e6e3, 0xd7a6, 0x47c3, 0xbf, 0x63, 0x12, 0x46, 0xe, 0x3, 0xf4, 0x60);
DEFINE_GUID(IID_CStream, 0x6d03e6e4, 0xd7a6, 0x47c3, 0xbf, 0x64, 0x12, 0x46, 0xe, 0x3, 0xf4, 0x60);


/* DMUS_PMSGT_PRIVATE_TYPES fill the DMUS_PMSG's dwType member */
/* These start at 15000 in order to avoid conflicting with public DMUS_PMSGT_TYPES. */
typedef enum enumDMUS_PMSGT_PRIVATE_TYPES
{
    DMUS_PMSGT_SCRIPTTRACKERROR = 15000, /* Sent by the script track when an error occurs in the script. */
} DMUS_PMSGT_PRIVATE_TYPES;

/* DMUS_SCRIPT_TRACK_ERROR_PMSG */
/* These PMsgs are sent by the script track if there is a syntax error in a script it tries to connect to or
   if a routine it calls fails. */
typedef struct _DMUS_SCRIPT_TRACK_ERROR_PMSG
{
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */

    DMUS_SCRIPT_ERRORINFO ErrorInfo; /* The error that occured.  Same as structure returned by IDirectMusicScript's Init and CallRoutine members. */
} DMUS_SCRIPT_TRACK_ERROR_PMSG;

/* Track param type guids */

/* Use (call SetParam on the script track) to turn on PMsgs (DMUS_SCRIPT_TRACK_ERROR_PMSG) the script track sends if there
   is a syntax error in the script it tries to connect to or if one of the routines it calls fails. */
DEFINE_GUID(GUID_EnableScriptTrackError,0x1cc7e0bf, 0x981c, 0x4b9f, 0xbe, 0x17, 0xd5, 0x72, 0xfc, 0x5f, 0xa9, 0x33); // {1CC7E0BF-981C-4b9f-BE17-D572FC5FA933}

DEFINE_GUID(GUID_Zombie,0xd931892b, 0x7fa6, 0x40b9, 0x92, 0x1b, 0x19, 0xc6, 0x9a, 0xd, 0xf0, 0xe1);


#endif          // _DMUSICP_DOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\validp.h ===
// Copyright (c) 1998 Microsoft Corporation
// ValidP.h --- An inline function to test for valid pointers

#ifndef __VALID_P__
#define __VALID_P__

// The debug version checks for Null pointers and pointers to unreadable/unwriteable data.
// (NOTE: only the first byte pointed to is checked)
// The non-debug version just checks for Null pointers.

template <class T>
inline BOOL Validate(T *p)
{ 
#ifdef _DEBUG
	return (p != NULL) && !IsBadReadPtr(p, 1) && !IsBadWritePtr(p, 1);
#else
	return p != NULL;
#endif
}

/* Use:

  Foo *pFoo;
  //
  // stuff...
  //
  if (Validate(pFoo))
  {
     // do stuff with the pointer
  }
  else
  {
     // don't do stuff with the pointer
  }

*/

#endif // __VALID_P__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\smartref.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Simple helper classes that use the "resource acquisition is initialization" technique.
// In English, this means they acquire a reference to a resource and the resource is automatically
//    released in the destructor.
//

#include "smartref.h"
using namespace SmartRef;
#include <xutility>
#include "miscutil.h"
#include "dmusicf.h"

//////////////////////////////////////////////////////////////////////
// AString

AString::AString(const char *psz, UINT cch)
{
	assert(psz);
	m_psz = new char[cch + 1];
	if (m_psz)
	{
		strncpy(m_psz, psz, cch);
		m_psz[cch] = L'\0';
	}
}

AString &
AString::operator =(const char *psz)
{
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	if (psz)
	{
		m_psz = new char[strlen(psz) + 1];
		if (m_psz)
			strcpy(m_psz, psz);
	}

	return *this;
}

AString &AString::Assign(const char *psz, UINT cch)
{
	assert(psz);
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	m_psz = new char[cch + 1];
	if (m_psz)
	{
		strncpy(m_psz, psz, cch);
		m_psz[cch] = L'\0';
	}

	return *this;
}

AString &
AString::AssignFromW(const WCHAR *psz)
{
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	if (psz)
	{
		int cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL);
		if (cch)
		{
			m_psz = new char[cch];
			if (m_psz)
			{
				cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, m_psz, cch, NULL, NULL);
				if (!cch)
				{
					assert(false);
					delete[] m_psz;
					m_psz = NULL;
				}
			}
		}
	}

	return *this;
}

//////////////////////////////////////////////////////////////////////
// WString

WString &
WString::operator =(const WCHAR *psz)
{
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	if (psz)
	{
		m_psz = new WCHAR[wcslen(psz) + 1];
		if (m_psz)
			wcscpy(m_psz, psz);
	}

	return *this;
}

WString &WString::Assign(const WCHAR *psz, UINT cch)
{
	assert(psz);
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	m_psz = new WCHAR[cch + 1];
	if (m_psz)
	{
		wcsncpy(m_psz, psz, cch);
		m_psz[cch] = L'\0';
	}

	return *this;
}

WString &
WString::AssignFromA(const char *psz)
{
	if (m_psz)
	{
		delete[] m_psz;
		m_psz = NULL;
	}

	if (psz)
	{
		int cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
		if (cch)
		{
			m_psz = new WCHAR[cch];
			if (m_psz)
			{
				cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, m_psz, cch);
				if (!cch)
				{
					assert(false);
					delete[] m_psz;
					m_psz = NULL;
				}
			}
		}
	}

	return *this;
}

//////////////////////////////////////////////////////////////////////
// RiffIter

RiffIter::RiffIter(IStream *pStream)
  : m_hr(S_OK),
	m_pIStream(pStream),
	m_pIDMStream(NULL),
	m_fParent(false)
{
	m_pIStream->AddRef();

	ZeroMemory(&m_ckParent, sizeof(m_ckParent));
	ZeroMemory(&m_ckChild, sizeof(m_ckChild));

	m_hr = ::AllocDirectMusicStream(m_pIStream, &m_pIDMStream);
	if (FAILED(m_hr))
		return;

	m_hr = m_pIDMStream->Descend(&m_ckChild, NULL, 0);
}

RiffIter::~RiffIter()
{
	if (!m_fParent)
	{
		SafeRelease(m_pIStream);
		SafeRelease(m_pIDMStream);
	}
}

RiffIter
&RiffIter::operator ++()
{
	if (validate())
		return *this;

	m_hr = m_pIDMStream->Ascend(&m_ckChild, 0);
	if (FAILED(m_hr))
		return *this;

	m_ckChild.ckid = 0;
	m_ckChild.fccType = 0;
	m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);
	return *this;
}

RiffIter
&RiffIter::Find(RiffType t, FOURCC idFind)
{
	if (validate())
		return *this;

	while (*this && (type() != t || id() != idFind))
		++*this;

	return *this;
}

HRESULT
RiffIter::ReadChunk(
		void *pv,
		UINT cb)
{
	if (type() != Chunk)
	{
		assert(false);
		return DMUS_E_CANNOTREAD;
	}

	ZeroMemory(pv, cb);
	DWORD cbRead = 0;
	DWORD cbSize = std::_cpp_min<DWORD>(cb, m_ckChild.cksize);
	HRESULT hr = m_pIStream->Read(pv, cbSize, &cbRead);
	if (FAILED(hr) || cbRead != cbSize)
		hr = DMUS_E_CANNOTREAD;
	return hr;
}

HRESULT
RiffIter::ReadArrayChunk(
	DWORD cbSize,
	void **ppv,
	int *pcRecords)
{
	// zero the out params
	*ppv = NULL;
	*pcRecords = 0;

	// get the size of the chunk and its records

	UINT cbChunk = size();
	if (cbChunk < sizeof(DWORD))
	{
		assert(false);
		return E_FAIL;
	}

	DWORD cbChunkRecord = 0;
	HRESULT hr = RiffIterReadChunk(*this, &cbChunkRecord);
	if (FAILED(hr))
		return hr;
	cbChunk -= sizeof(DWORD);

	if (cbChunk % cbChunkRecord != 0)
	{
		// array is not divisible by size of records!
		assert(false);
		return E_FAIL;
	}

	UINT cRecords = cbChunk / cbChunkRecord;

	// Get the whole rest of the chunk
	PtrArray<char> sprgChunk = new char[cbChunk];
	if (!sprgChunk)
		return E_OUTOFMEMORY;
	hr = ReadChunk(sprgChunk, cbChunk);
	if (FAILED(hr))
		return hr;

	// Return the chunk and its info.

	if (cbChunkRecord == cbSize)
	{
		// Great!  Return the chunk as is.
		*ppv = sprgChunk.disown();
	}
	else
	{
		// make an array of the requested size
		char *pArray = new char[cbSize * cRecords];
		if (!pArray)
			return E_OUTOFMEMORY;
		ZeroMemory(pArray, cbSize * cRecords);

		// copy each record
		char *pRec = sprgChunk; // iterate reading each record of the chunk
		char *pEnd = pRec + cbChunkRecord * cRecords; // stop before this (nonexistant) record
		char *pOut = pArray; // iterate writing into the array
		while (pRec < pEnd)
		{
			memcpy(pOut, pRec, std::_cpp_min<DWORD>(cbChunkRecord, cbSize));
			pRec += cbChunkRecord;
			pOut += cbSize;
		}
		*ppv = pArray;
	}

	*pcRecords = cRecords;
	return hr;
}

HRESULT RiffIter::FindAndClone(RiffType t, FOURCC idFind, HRESULT hrOnNotFound, IStream **ppStream)
{
	if (validate() || !ppStream)
	{
		assert(false);
		return E_FAIL;
	}

	*ppStream = NULL;
	MMCKINFO ckLast;
	ZeroMemory(&ckLast, sizeof(ckLast));

	while (*this && (type() != t || id() != idFind))
	{
		ckLast = m_ckChild;
		++*this;
	}

	if (!*this)
		return hrOnNotFound;

	// Ascend in such a way that the cloned stream can be used to find this chunk.
	m_hr = m_pIDMStream->Ascend(&ckLast, 0);
	if (FAILED(m_hr))
		return m_hr;

	HRESULT hrClone = m_pIStream->Clone(ppStream);

	m_ckChild.ckid = 0;
	m_ckChild.fccType = 0;
	m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);

	HRESULT hrDescend = this->hr();
	return FAILED(hrDescend) ? hrDescend : hrClone;
}

HRESULT
RiffIter::ReadReference(DMUS_OBJECTDESC *pDESC)
{
	HRESULT hr = S_OK;

	assert(this->type() == List && this->id() == DMUS_FOURCC_REF_LIST);

	ZeroAndSize(pDESC);

	for (RiffIter ri = this->Descend(); ri; ++ri)
	{
		switch (ri.id())
		{
			case  DMUS_FOURCC_REF_CHUNK:
				DMUS_IO_REFERENCE ioDMRef;
				hr = SmartRef::RiffIterReadChunk(ri, &ioDMRef);
				if (SUCCEEDED(hr))
				{
					pDESC->guidClass = ioDMRef.guidClassID;
					pDESC->dwValidData |= ioDMRef.dwValidData;
					pDESC->dwValidData |= DMUS_OBJ_CLASS;
				}
				break;

			case DMUS_FOURCC_GUID_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->guidObject);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_OBJECT;
				break;

			case DMUS_FOURCC_DATE_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->ftDate);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_DATE;
				break;

			case DMUS_FOURCC_NAME_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszName);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_NAME;
				break;
			
			case DMUS_FOURCC_FILE_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszFileName);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_FILENAME;
				break;

			case DMUS_FOURCC_CATEGORY_CHUNK:
				hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszCategory);
				if (SUCCEEDED(hr))
					pDESC->dwValidData |=  DMUS_OBJ_CATEGORY;
				break;

			case DMUS_FOURCC_VERSION_CHUNK:
				DMUS_IO_VERSION ioDMObjVer;
				hr = SmartRef::RiffIterReadChunk(ri, &ioDMObjVer);
				if (SUCCEEDED(hr))
				{
					pDESC->vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
					pDESC->vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
					pDESC->dwValidData |= DMUS_OBJ_VERSION;
				}
				else
				{
					hr = E_FAIL;
				}
				break;

			default:
				break;
		}
	}
	return ri.hr();
}

HRESULT RiffIter::LoadObjectInfo(ObjectInfo *pObjInfo, RiffType rtypeStop, FOURCC ridStop)
{
	assert(pObjInfo);
	pObjInfo->Clear();

	HRESULT hr = S_OK;

	if (!(*this))
		return this->hr();

	for ( ; *this; ++(*this))
	{
		RiffType rtype = type();
		FOURCC fcc = id();
		if (rtype == rtypeStop && fcc == ridStop)
			return S_OK;

		if (rtype == SmartRef::RiffIter::Chunk)
		{
			if (fcc == DMUS_FOURCC_GUID_CHUNK)
				hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->guid);
			else if (fcc == DMUS_FOURCC_VERSION_CHUNK)
				hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->vVersion);
		}
		else if (rtype == SmartRef::RiffIter::List)
		{
			if (fcc == DMUS_FOURCC_UNFO_LIST)
			{
				RiffIter riUnfo = this->Descend();
				if (!riUnfo)
					return riUnfo.hr();
				if (riUnfo.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_UNAM_CHUNK))
				{
					hr = riUnfo.ReadTextTrunc(pObjInfo->wszName, DMUS_MAX_NAME);
					if (FAILED(hr))
						return hr;
				}
			}
		}

		if (FAILED(hr))
			return hr;
	}
	
	return E_FAIL;
}

HRESULT RiffIter::ReadText(WCHAR **ppwsz)
{
	DWORD dwSize = this->size();
	if (dwSize % 2 != 0)
	{
		assert(false);
		return E_FAIL;
	}
	*ppwsz = new WCHAR[dwSize / 2];
	if (!*ppwsz)
		return E_OUTOFMEMORY;
	HRESULT hr = this->ReadChunk(*ppwsz, dwSize);
	return hr;
}

HRESULT RiffIter::ReadTextTrunc(WCHAR *pwsz, UINT cbBufSize)
{
	DWORD dwSize = this->size();
	if (dwSize % 2 != 0)
	{
		assert(false);
		return E_FAIL;
	}
	HRESULT hr = this->ReadChunk(pwsz, std::_MIN<DWORD>(dwSize, (cbBufSize - 1) * 2));
	pwsz[cbBufSize - 1] = L'\0';
	return hr;
}

RiffIter::RiffIter(const RiffIter &other, MMCKINFO ckParent)
  : m_hr(S_OK),
	m_pIStream(other.m_pIStream),
	m_pIDMStream(other.m_pIDMStream),
	m_fParent(true),
	m_ckParent(ckParent)
{
	other.validate();
	ZeroMemory(&m_ckChild, sizeof(m_ckChild));

	m_hr = m_pIDMStream->Descend(&m_ckChild, &m_ckParent, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\xboxutil.h ===
// XBox compatability functions

#pragma once

#ifdef XBOX

// On Xbox, DeleteCriticalSection is defined as an empty macro.
// This causes problems when it is called in the DMusic sources
// as ::DeleteCriticalSection(...);
// which macro-expands to:
// ::(...);

#ifdef DeleteCriticalSection
#undef DeleteCriticalSection
inline void DeleteCriticalSection(void* /* unused */)
{
}
#endif // DeleteCriticalSection

#endif // XBOX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\xcreate.h ===
#pragma once

STDAPI DirectMusicChordTrackCreate( REFIID iid, void ** ppDMT );

STDAPI DirectMusicCommandTrackCreate( REFIID iid, void ** ppDMT );

STDAPI DirectMusicStyleTrackCreate( REFIID iid, void ** ppDMT );

STDAPI DirectMusicMelodyFormulationTrackCreate(REFIID iid, void ** ppDMT );

STDAPI DirectMusicMuteTrackCreate(REFIID iid, void ** ppDMT );

STDAPI DirectMusicChordMapTrackCreate(REFIID iid, void ** ppDMT );

STDAPI DirectMusicChordMapCreate(REFIID iid, void ** ppChordMap );

STDAPI DirectMusicSignPostTrackCreate(REFIID iid, void ** ppChordMap );

STDAPI DirectMusicTempoTrackCreate(REFIID iid, void ** ppDMT );

STDAPI DirectMusicTimeSigTrackCreate(REFIID iid, void ** ppDMT );

STDAPI DirectMusicMarkerTrackCreate(REFIID iid, void ** ppDMT );

STDAPI DirectMusicBandTrackCreate(REFIID iid, void ** ppDMT );

STDAPI DirectMusicPatternTrackCreate(REFIID iid, void ** ppDMT );

STDAPI DirectMusicMotifTrackCreate(REFIID iid, void ** ppDMT );

STDAPI DirectMusicWaveTrackCreate(REFIID iid, void ** ppDMT);

STDAPI DirectMusicSegmentCreate( REFIID iid, void ** ppDMSeg );

STDAPI DirectMusicTemplCreate(REFIID iid, void ** ppDMTempl );

STDAPI DirectMusicPerformanceCreate(REFIID iid, void ** ppDMP);

STDAPI DirectMusicBandCreate(REFIID iid, void ** ppBand);

STDAPI DirectMusicStyleCreate(REFIID iid, void ** ppStyle);

STDAPI DirectMusicSectionCreate(REFIID iid, void ** ppSection);

STDAPI DirectMusicAutAudioPathCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);

STDAPI DirectMusicAutAudioPathConfigCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);

STDAPI DirectMusicAutSongCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);

STDAPI DirectMusicAutPerformanceCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);

STDAPI DirectMusicAutSegmentCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);

STDAPI DirectMusicScriptCreate(REFIID iid, void ** ppScript);

STDAPI DirectMusicScriptTrackCreate(REFIID iid, void ** ppTrack);

STDAPI DirectMusicSongCreate(REFIID iid, void ** ppSong);

STDAPI DirectMusicAudioPathConfigCreate(REFIID iid, void ** ppPath);

STDAPI DirectMusicSeqTrackCreate(REFIID iid, void ** ppTrack);

STDAPI DirectMusicGraphCreate(REFIID iid, void ** ppGraph);

STDAPI DirectMusicSysexTrackCreate(REFIID iid, void ** ppTrack);

STDAPI DirectMusicTriggerTrackCreate(REFIID iid, void ** ppTrack);

STDAPI DirectMusicLyricsTrackCreate(REFIID iid, void ** ppTrack);

STDAPI DirectMusicParamsTrackCreate(REFIID iid, void ** ppTrack);

STDAPI DirectMusicSegStateCreate(REFIID iid, void ** ppSegState);

STDAPI DirectMusicComposerCreate(REFIID iid, void ** ppDMComp8 );

STDAPI DirectMusicCreate(REFIID iid, void ** ppDMC );

STDAPI DirectMusicCollectionCreate(REFIID iid, void ** ppDMC );

STDAPI DirectMusicSynthCreate(REFIID iid, void ** ppDMSynth );

STDAPI DirectSoundWaveCreate( REFIID iid, void ** ppDSW );

STDAPI DirectMusicContainerCreate( REFIID iid, void ** ppContainer );

STDAPI DirectMusicLoaderCreate( REFIID iid, void ** ppLoader );

STDAPI AutDirectMusicSegmentStateCreate(LPUNKNOWN pUnkOuter, REFIID iid, void ** ppLoader );

STDAPI DirectMusicMemStreamCreate( REFIID iid, void ** ppStream );

STDAPI DirectMusicStreamStreamCreate( REFIID iid, void ** ppStream );

STDAPI DirectMusicFileStreamCreate( REFIID iid, void ** ppStream );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\xalloc.h ===
//
// Copyright (C) Microsoft Corporation. All Rights Reserved.
//
#pragma once

extern void* DirectMusicAllocI(size_t cb);
extern void  DirectMusicFreeI(void *pv);
extern void* DirectMusicPhysicalAllocI(size_t dwSize);
extern void DirectMusicPhysicalFreeI(void* lpAddress);

static inline void * __cdecl operator new(size_t cb)
{
    return DirectMusicAllocI(cb);
}

static inline void __cdecl operator delete(void *pv)
{
    DirectMusicFreeI(pv);
}

static inline void * __cdecl operator new[](size_t cb)
{
    return DirectMusicAllocI(cb);
}

static inline void __cdecl operator delete[](void *pv)
{
    DirectMusicFreeI(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\validate.h ===
//
// validate.h
//
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Parameter validation macros
//
// Summary:
//
// V_INAME(interfacename)                - Set the interface name for error display
// V_STRUCTPTR_READ(ptr,type)            - A dwSize struct which we will read
// V_STRUCTPTR_WRITE(ptr,type)           - A dwSize struct which we will read/write
// V_PTR_READ(ptr,type)                  - A typed ptr w/o a dwSize which we will read
// V_PTR_WRITE(ptr,type)                 - A typed ptr w/o a dwSize which we will read/write
// V_PTR_WRITE_OPT(ptr,type)             - An optional typed ptr w/o a dwSize which we will read/write
// V_BUFPTR_READ(ptr,size)               - A variable-size buffer that we will read
// V_BUFPTR_READ_OPT(ptr,size)			 - An optional variable-size buffer that we will read
// V_BUFPTR_WRITE(ptr,size)              - A variable-size buffer that we will read/write
// V_BUFPTR_WRITE_OPT(ptr,size)          - An optional variable-size buffer that we will read/write
// V_PTRPTR_WRITE(ptrptr)                - A pointer to a pointer to write to
// V_PTRPTR_WRITE_OPT(ptrptr)            - A pointer to a pointer to write to that is optional
// V_PUNKOUTER(punk)                     - A pointer to a controlling unknown, aggregation supported
// V_PUNKOUTER_NOADD(punk)               - A pointer to a controlling unknown, aggregation not supported
// V_INTERFACE(ptr)                      - A pointer to a COM interface
// V_INTERFACE_OPT(ptr)                  - An optional pointer to a COM interface
// V_REFGUID(ref)                        - A reference to a GUID (type REFGUID)
// V_HWND(hwnd)							 - A window handle
// V_HWNDOPT(hwnd)						 - An optional window handle
//
// For handling different versions of structures:
// 
// V_STRUCTPTR_READ_VER(ptr,ver)         - Begin a struct version block for read access
//                                         At the end, 'ver' will contain the 
//                                         discovered version of the struct
// V_STRUCTPTR_READ_VER_CASE(base,ver)   - Test struct against version ver of
//                                         type 'base'. 
// V_STRUCTPTR_READ_VER_END(base,ptr)    - End a struct version block
//
// V_STRUCTPTR_WRITE_VER(ptr,ver)        - Struct version block for write access
// V_STRUCTPTR_WRITE_VER_CASE(base,ver)
// V_STRUCTPTR_WRITE_VER_END(base,ptr)
//
// The struct version block expects type names of a base type followed by a 
// numeric version, such as
//
// typedef struct { } FOO7;
// typedef struct { } FOO8;
//
// In the header FOO and LPFOO are conditionally typedef'd based on a version
// #define. The DLL will be compiled with the latest version number and hence
// the largest version of the struct.
//
// Since Windows headers are compiled by default with 8-byte alignment, adding
// one DWORD may not cause the size of the structure to change. If this happens
// you will get a 'case label already used' error on one of the VER_CASE macros.
// If this happens, you can get around it by adding a dwReserved field to the 
// end of the struct to force the padding.
//
// 'optional' means the pointer is allowed to be NULL by the interface specification.
//
// Sample usage:
//
// int IDirectMusic::SetFooBarInterface(
//     LPDMUS_REQUESTED_CAPS    pCaps,          // Caps w/ dwSize (read-only)
//     LPVOID                   pBuffer,        // Buffer we will fill in
//     DWORD                    cbSize,         // Size of the buffer
//     PDIRECTMUSICBAR          pBar)           // Callback interface for bar on this buffer
// {
//     V_INTERFACE(IDirectMusic::SetFooBarInterface);
//     V_BUFPTR_WRITE(pBuffer, cbSize);
//     V_INTERFACE(pBar);
//     DWORD dwCapsVer;                         // Must be a DWORD!!!
//
//     V_STRUCTPTR_READ_VER(pCaps, dwCapsVer);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 7);
//     V_STRUCTPTR_READ_VER_CASE(DMUS_REQUESTED_CAPS, 8);
//     V_STRUCTPTR_READ_VER_END_(DMUS_REQUESTED_CAPS, pCaps);
//
//     // At this point, if we are still in the function we have a valid pCaps
//     // pointer and dwCapsVer is either 7 or 8, indicating the version of
//     // the struct passed in.
//
//     ...
// }
//
#ifndef _VALIDATE_H_
#define _VALIDATE_H_


#ifdef DBG
#include <stddef.h>

#include "debug.h"

// To turn on DebugBreak on parameter error, use the following or -DRIP_BREAK in the build:
//
//#define RIP_BREAK 1
#ifdef XBOX
#define IsWindow(h) TRUE
#define RIP_BREAK 1
#endif

#ifdef RIP_BREAK
#define _RIP_BREAK DebugBreak();
#else
#define _RIP_BREAK 
#endif

#ifdef XBOX
#ifdef DBG // Under XBox, don't keep the function names around for retail builds.
#define V_INAME(x) \
    static const char __szValidateInterfaceName[] = #x;  
#else
#define V_INAME(x)
#endif
                     
#define RIP_E_POINTER(ptr) \
{   Trace(-1, "%s: Invalid pointer " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK  }

#define RIP_E_INVALIDARG(ptr) \
{   Trace(-1, "%s: Invalid argument " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK }

#define RIP_E_HANDLE(h) \
{	Trace(-1, "%s: Invalid handle " #h "\n", __szValidateInterfaceName); \
    _RIP_BREAK }
    
#define RIP_W_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize matches no known structure size. Defaulting to oldest structure.\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    }
    
#define RIP_E_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize is too small\n", __szValidateInterfaceName); \
    _RIP_BREAK ; }
    
#define RIP_E_BLOCKVSDWSIZE(ptr) \
{   Trace(-1, "%s: " #ptr " does not point to as much memory as " #ptr "->dwSize indicates\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK  }
  
#else // !XBOX

#define RIP_E_POINTER(ptr) \
{   Trace(-1, "%s: Invalid pointer " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_POINTER; }

#define RIP_E_INVALIDARG(ptr) \
{   Trace(-1, "%s: Invalid argument " #ptr "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }

#define RIP_E_HANDLE(h) \
{	Trace(-1, "%s: Invalid handle " #h "\n", __szValidateInterfaceName); \
    _RIP_BREAK \
	return E_HANDLE; }
    
#define RIP_W_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize matches no known structure size. Defaulting to oldest structure.\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    }
    
#define RIP_E_INVALIDSIZE(ptr) \
{   Trace(-1, "%s: " #ptr "->dwSize is too small\n", __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }
    
#define RIP_E_BLOCKVSDWSIZE(ptr) \
{   Trace(-1, "%s: " #ptr " does not point to as much memory as " #ptr "->dwSize indicates\n", \
    __szValidateInterfaceName); \
    _RIP_BREAK \
    return E_INVALIDARG; }    

#endif // !XBOX  

// NOTE: The DebugBreak() not in #ifdef is intentional - this is something that
// must be fixed in our code, not an app-generated error.
//
#define V_ASSERT(exp) \
{   if (!(exp)) { \
        Trace(-1, "%s@%s: %s\n", __FILE__, __LINE__, #exp); \
        DebugBreak(); }}

#else

#define V_INAME(x)
#define RIP_E_POINTER(ptr)          { return E_POINTER; }
#define RIP_E_INVALIDARG(ptr)       { return E_INVALIDARG; }
#define RIP_E_HANDLE(h)	            { return E_HANDLE; }
#define RIP_E_BLOCKVSDWSIZE(ptr)    { return E_INVALIDARG; }
#define RIP_W_INVALIDSIZE(ptr)
#define RIP_E_INVALIDSIZE(ptr)      { return E_INVALIDARG; }
#define V_ASSERT(exp)

#endif          // DBG

#if defined(XBOX) && !defined(DBG)
#define V_STRUCTPTR_READ(ptr,type) 
#define V_STRUCTPTR_WRITE(ptr,type) 
#define V_PTR_READ(ptr,type) 
#define V_PTR_WRITE(ptr,type) 
#define V_PTR_WRITE_OPT(ptr,type) 
#define V_BUFPTR_READ(ptr,len) 
#define V_BUFPTR_READ_OPT(ptr,len)
#define V_BUFPTR_WRITE(ptr,len) 
#define V_BUFPTR_WRITE_OPT(ptr,len) 
#define V_PTRPTR_WRITE(ptr) 
#define V_PTRPTR_WRITE_OPT(ptr) 
#define V_PUNKOUTER(punk) 
#define V_PUNKOUTER_NOAGG(punk) 
#define V_INTERFACE(ptr)
#define V_INTERFACE_OPT(ptr) 
#define V_REFGUID(ref)
#define V_HWND(h) 
#define V_HWND_OPT(h) 
// The following will not be called in XBOX soon, so I will remove them at that point.
#define V_STRUCTPTR_READ_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_READ_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
    *pdw = ver; break;
    
#define V_STRUCTPTR_READ_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}

#define V_STRUCTPTR_WRITE_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_WRITE_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
        *pdw = ver; break;
    
#define V_STRUCTPTR_WRITE_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}
#else

// A passed struct we will only read from or may write to. Must be a struct
// with a dwSize.
//
// int foo(CFoo *pFoo)
// ...
// V_STRUCTPTR_READ(pFoo, CFoo);
// V_STRUCTPTR_WRITE(pFoo, CFoo);
//
// Use _PTR_ variants for structs w/o a dwSize
//

#define V_STRUCTPTR_READ(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_STRUCTPTR_WRITE(ptr,type) \
{   V_ASSERT(offsetof(type, dwSize) == 0); \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
	if (ptr->dwSize < sizeof(type))						RIP_E_INVALIDSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); }

#define V_PTR_READ(ptr,type) \
{ if (IsBadReadPtr(ptr, sizeof(type)))                  RIP_E_POINTER(ptr); }

#define V_PTR_WRITE(ptr,type) \
{ if (IsBadWritePtr(ptr, sizeof(type)))                 RIP_E_POINTER(ptr); }

#define V_PTR_WRITE_OPT(ptr,type) \
{ if (ptr) if (IsBadWritePtr(ptr, sizeof(type)))        RIP_E_POINTER(ptr); }

// A buffer pointer with separate length (not defined by the pointer type) we will only
// read from or may write to.
//
// int foo(LPVOID *pBuffer, DWORD cbBuffer)
// ...
// V_BUFPTR_READ(pBuffer, cbBuffer);
// V_BUFPTR_WRITE(pBuffer, cbBuffer);
//
#define V_BUFPTR_READ(ptr,len) \
{   if (IsBadReadPtr(ptr, len))                         RIP_E_POINTER(ptr); }

#define V_BUFPTR_READ_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_READ(ptr,len); }

#define V_BUFPTR_WRITE(ptr,len) \
{   if (IsBadWritePtr(ptr, len))                        RIP_E_POINTER(ptr); }

#define V_BUFPTR_WRITE_OPT(ptr,len) \
{	if (ptr) V_BUFPTR_WRITE(ptr,len); }

// A pointer to a pointer (such as a pointer to an interface pointer) to return
//
// int foo(IReturnMe **ppRet)
// ...
// V_PTRPTR_WRITE(ppRet);
// V_PTRPTR_WRITE_OPT(ppRet);
//
#define V_PTRPTR_WRITE(ptr) \
{   if (IsBadWritePtr(ptr, sizeof(void*)))              RIP_E_POINTER(ptr); }

#define V_PTRPTR_WRITE_OPT(ptr) \
{   if (ptr) if (IsBadWritePtr(ptr, sizeof(void*)))     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown
//
#define V_PUNKOUTER(punk) \
{   if (punk && IsBadCodePtr(punk))                     RIP_E_POINTER(ptr); }

// A pointer to a controlling unknown for which we don't support aggregation
//
#define V_PUNKOUTER_NOAGG(punk) \
{   if (punk && IsBadReadPtr(punk, sizeof(IUnknown)))   RIP_E_POINTER(ptr); \
    if (punk) return CLASS_E_NOAGGREGATION; }

// Validate an incoming interface pointer. 
//
struct _V_GENERIC_INTERFACE
{
    FARPROC *(__vptr[1]);
};

#define V_INTERFACE(ptr) \
{   if (IsBadReadPtr(ptr, sizeof(_V_GENERIC_INTERFACE)))                              RIP_E_POINTER(ptr); \
    if (IsBadReadPtr(*reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr, sizeof(FARPROC))) \
                                                                                      RIP_E_POINTER(ptr); \
    if (IsBadCodePtr(*(reinterpret_cast<_V_GENERIC_INTERFACE*>(ptr)->__vptr)[0]))     RIP_E_POINTER(ptr); }

#define V_INTERFACE_OPT(ptr) \
{   if (ptr) V_INTERFACE(ptr); }

// Validation for a reference to a GUID, which we only ever read. 
//
#define V_REFGUID(ref) \
{   if (IsBadReadPtr((void*)&ref, sizeof(GUID)))        RIP_E_POINTER((void*)&ref); }

// Validation for a window handle
//
#define V_HWND(h) \
{	if (!IsWindow(h))									RIP_E_HANDLE(h); }	

#define V_HWND_OPT(h) \
{	if (h) if (!IsWindow(h))							RIP_E_HANDLE(h); }	

// Validation for multiple sized structs based on version
//
#define V_STRUCTPTR_READ_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadReadPtr(ptr, (ptr)->dwSize))               RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_READ_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
    V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
    *pdw = ver; break;
    
#define V_STRUCTPTR_READ_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}


#define V_STRUCTPTR_WRITE_VER(ptr,ver) \
{   ver = 7; DWORD *pdw = &ver;  \
    if (IsBadReadPtr(ptr, sizeof(DWORD)))               RIP_E_BLOCKVSDWSIZE(ptr); \
    if (IsBadWritePtr(ptr, (ptr)->dwSize))              RIP_E_BLOCKVSDWSIZE(ptr); \
    switch ((ptr)->dwSize) {
    
#define V_STRUCTPTR_WRITE_VER_CASE(basetype,ver) \
    case sizeof(basetype##ver) : \
        V_ASSERT(offsetof(basetype##ver, dwSize) == 0); \
        *pdw = ver; break;
    
#define V_STRUCTPTR_WRITE_VER_END(basetype,ptr) \
    default : if ((ptr)->dwSize > sizeof(basetype##7)) \
    { RIP_W_INVALIDSIZE(ptr); } else \
    RIP_E_INVALIDSIZE(ptr); }}

#endif          // !(XBOX && DBG)

#endif          // _VALIDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\xsoundp.h ===
//
// xsoundp.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
// Private interfaces

#ifndef _XSOUNDP_DOT_H_
#define _XSOUNDP_DOT_H_

#ifdef XBOX

#include <xtl.h>
#include <dmusicc.h>

// Temporary defines until the "8"s go back

#define IDirectSound8 IDirectSound
#define LPDIRECTSOUND8 LPDIRECTSOUND
#define IDirectSoundBuffer8 IDirectSoundBuffer
#define DirectSoundCreate8 DirectSoundCreate

// This probably needs to go back into dsound.h


// Dummy reverberation GUIDs, until DSound gets its act together.

// I3DL2 Environmental Reverberation: Source Effect {EFBA364A-E606-451C-8E97-07D508119C65}
DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2SOURCE, 0xefba364a, 0xe606, 0x451c, 0x8e, 0x97, 0x07, 0xd5, 0x08, 0x11, 0x9c, 0x65);

// I3DL2 Environmental Reverberation: Reverb (Listener) Effect {EF985E71-D5C7-42D4-BA4D-2D073E2E96F4}
DEFINE_GUID(GUID_DSFX_STANDARD_I3DL2REVERB, 0xef985e71, 0xd5c7, 0x42d4, 0xba, 0x4d, 0x2d, 0x07, 0x3e, 0x2e, 0x96, 0xf4);

// Waves Reverberation {87FC0268-9A55-4360-95AA-004A1D9DE26C}
DEFINE_GUID(GUID_DSFX_WAVES_REVERB, 0x87fc0268, 0x9a55, 0x4360, 0x95, 0xaa, 0x00, 0x4a, 0x1d, 0x9d, 0xe2, 0x6c);


// Private classes that used to be in dsound.x, but which are only used by DirectMusic.

// Forward declarations

struct IReferenceClock;

//
// Private DirectSound interfaces used by DMusic, DPlayVoice, etc.
// Eventually much of the MSINTERNAL stuff above should migrate here.
//

#ifdef __cplusplus
struct IDirectSoundPrivate;
struct IDirectSoundSynthSink;
struct IDirectSoundConnect;
struct IDirectSoundSinkSync;
struct IDirectSoundSource;
struct IDirectSoundWave;
class CBuffer;
#endif // __cplusplus

#define IDirectSoundPrivate8          IDirectSoundPrivate
#define IDirectSoundSynthSink8        IDirectSoundSynthSink
#define IDirectSoundConnect8          IDirectSoundConnect
#define IDirectSoundSinkSync8         IDirectSoundSinkSync
#define IDirectSoundSource8           IDirectSoundSource
#define IDirectSoundWave8             IDirectSoundWave

#define IID_IDirectSoundPrivate8      IID_IDirectSoundPrivate
#define IID_IDirectSoundSynthSink8    IID_IDirectSoundSynthSink
#define IID_IDirectSoundConnect8      IID_IDirectSoundConnect
#define IID_IDirectSoundSinkSync8     IID_IDirectSoundSinkSync
#define IID_IDirectSoundSource8       IID_IDirectSoundSource
#define IID_IDirectSoundWave8         IID_IDirectSoundWave

typedef struct IDirectSoundPrivate    *LPDIRECTSOUNDPRIVATE;
typedef struct IDirectSoundSynthSink  *LPDIRECTSOUNDSYNTHSINK;
typedef struct IDirectSoundConnect    *LPDIRECTSOUNDCONNECT;
typedef struct IDirectSoundSinkSync   *LPDIRECTSOUNDSINKSYNC;
typedef struct IDirectSoundSource     *LPDIRECTSOUNDSOURCE;
typedef struct IDirectSoundWave       *LPDIRECTSOUNDWAVE;

typedef struct IDirectSoundPrivate8   *LPDIRECTSOUNDPRIVATE8;
typedef struct IDirectSoundSynthSink8 *LPDIRECTSOUNDSYNTHSINK8;
typedef struct IDirectSoundConnect8   *LPDIRECTSOUNDCONNECT8;
typedef struct IDirectSoundSinkSync8  *LPDIRECTSOUNDSINKSYNC8;
typedef struct IDirectSoundSource8    *LPDIRECTSOUNDSOURCE8;
typedef struct IDirectSoundWave8      *LPDIRECTSOUNDWAVE8;

//
// IDirectSoundPrivate: used by DirectMusic to create DirectSoundSink objects
//

DEFINE_GUID(IID_IDirectSoundPrivate, 0xd6e525ae, 0xb125, 0x4ec4, 0xbe, 0x13, 0x12, 0x6d, 0x0c, 0xf7, 0xaf, 0xb6);

// There is no IID for dsound buffer, so make one for now...

DEFINE_GUID(IID_IDirectSoundBuffer,0x1b13ff5e, 0x981b, 0x4ca9, 0x92, 0x6a, 0xcd, 0x7b, 0xb6, 0x68, 0xc8, 0x5d);


#undef INTERFACE
#define INTERFACE IDirectSoundPrivate

DECLARE_INTERFACE_(IDirectSoundPrivate, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundPrivate methods
    STDMETHOD(AllocSink)            (THIS_ LPWAVEFORMATEX pwfxFormat, LPDIRECTSOUNDCONNECT *ppSinkConnect) PURE;
};

#define IDirectSoundPrivate_QueryInterface(p,a,b)       IUnknown_QueryInterface(p,a,b)
#define IDirectSoundPrivate_AddRef(p)                   IUnknown_AddRef(p)
#define IDirectSoundPrivate_Release(p)                  IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundPrivate_AllocSink(p,a,b)            (p)->lpVtbl->AllocSink(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundPrivate_AllocSink(p,a,b)            (p)->AllocSink(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSynthSink: used by the DirectMusic synthesiser
//

DEFINE_GUID(IID_IDirectSoundSynthSink, 0x73a6a85a, 0x493e, 0x4c87, 0xb4, 0xa5, 0xbe, 0x53, 0xeb, 0x92, 0x74, 0x4b);

#undef INTERFACE
#define INTERFACE IDirectSoundSynthSink

DECLARE_INTERFACE_(IDirectSoundSynthSink, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSynthSink methods
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime, REFERENCE_TIME *prtTime) PURE;
    STDMETHOD(RefToSampleTime)      (THIS_ REFERENCE_TIME rtTime, LONGLONG *pllSampleTime) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
};

#define IDirectSoundSynthSink_QueryInterface(p,a,b)     IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSynthSink_AddRef(p)                 IUnknown_AddRef(p)
#define IDirectSoundSynthSink_Release(p)                IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSynthSink_GetLatencyClock(p,a)      (p)->lpVtbl->GetLatencyClock(p,a)
#define IDirectSoundSynthSink_Activate(p,a)             (p)->lpVtbl->Activate(p,a)
#define IDirectSoundSynthSink_SampleToRefTime(p,a,b)    (p)->lpVtbl->SampleToRefTime(p,a,b)
#define IDirectSoundSynthSink_RefToSampleTime(p,a,b)    (p)->lpVtbl->RefToSampleTime(p,a,b)
#define IDirectSoundSynthSink_GetFormat(p,a,b)          (p)->lpVtbl->GetFormat(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSynthSink_GetLatencyClock(p,a)      (p)->GetLatencyClock(a)
#define IDirectSoundSynthSink_Activate(p,a)             (p)->Activate(a)
#define IDirectSoundSynthSink_SampleToRefTime(p,a,b)    (p)->SampleToRefTime(a,b)
#define IDirectSoundSynthSink_RefToSampleTime(p,a,b)    (p)->RefToSampleTime(a,b)
#define IDirectSoundSynthSink_GetFormat(p,a,b)          (p)->GetFormat(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundConnect: used by DirectMusic to implement
// audio paths and connect the synthesiser to the sink
//

DEFINE_GUID(IID_IDirectSoundConnect, 0x5bee1fe0, 0x60d5, 0x4ef9, 0x88, 0xbc, 0x33, 0x67, 0xb9, 0x75, 0xc6, 0x11);

#undef INTERFACE
#define INTERFACE IDirectSoundConnect

DECLARE_INTERFACE_(IDirectSoundConnect, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundConnect methods
    STDMETHOD(AddSource)            (THIS_ LPDIRECTSOUNDSOURCE pDSSource) PURE;
    STDMETHOD(RemoveSource)         (THIS_ LPDIRECTSOUNDSOURCE pDSSource) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDWORD pdwFuncID, DWORD dwBusIDCount,
                                           REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(CreateSoundBufferFromConfig) (THIS_ LPUNKNOWN pConfig, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(GetSoundBuffer)       (THIS_ DWORD dwBusID, LPDIRECTSOUNDBUFFER *ppDSBuffer) PURE;
    STDMETHOD(GetBusCount)          (THIS_ LPDWORD pdwCount) PURE;
    STDMETHOD(GetBusIDs)            (THIS_ LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount) PURE;
    STDMETHOD(GetFunctionalID)      (THIS_ DWORD dwBusID, LPDWORD pdwFuncID) PURE;
    STDMETHOD(GetSoundBufferBusIDs) (THIS_ LPDIRECTSOUNDBUFFER pDSBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount) PURE;
};

#define IDirectSoundConnect_QueryInterface(p,a,b)               IUnknown_QueryInterface(p,a,b)
#define IDirectSoundConnect_AddRef(p)                           IUnknown_AddRef(p)
#define IDirectSoundConnect_Release(p)                          IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundConnect_AddSource(p,a)                      (p)->lpVtbl->AddSource(p,a)
#define IDirectSoundConnect_RemoveSource(p,a)                   (p)->lpVtbl->RemoveSource(p,a)
#define IDirectSoundConnect_SetMasterClock(p,a)                 (p)->lpVtbl->SetMasterClock(p,a)
#define IDirectSoundConnect_CreateSoundBuffer(p,a,b,c,d)        (p)->lpVtbl->CreateSoundBuffer(p,a,b,c,d)
#define IDirectSoundConnect_CreateSoundBufferFromConfig(p,a,b)  (p)->lpVtbl->CreateSoundBufferFromConfig(p,a,b)
#define IDirectSoundConnect_GetSoundBuffer(p,a,b)               (p)->lpVtbl->GetSoundBuffer(p,a,b)
#define IDirectSoundConnect_GetBusCount(p,a)                    (p)->lpVtbl->GetBusCount(p,a)
#define IDirectSoundConnect_GetBusIDs(p,a,b,c)                  (p)->lpVtbl->GetBusIDs(p,a,b,c)
#define IDirectSoundConnect_GetFunctionalID(p,a,b)              (p)->lpVtbl->GetFunctionalID(p,a,b)
#define IDirectSoundConnect_GetSoundBufferBusIDs(p,a,b,c,d)     (p)->lpVtbl->GetSoundBufferBusIDs(p,a,b,c,d)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundConnect_AddSource(p,a)                      (p)->AddSource(a)
#define IDirectSoundConnect_RemoveSource(p,a)                   (p)->RemoveSource(a)
#define IDirectSoundConnect_SetMasterClock(p,a)                 (p)->SetMasterClock(a)
#define IDirectSoundConnect_CreateSoundBuffer(p,a,b,c,d)        (p)->CreateSoundBuffer(a,b,c,d)
#define IDirectSoundConnect_CreateSoundBufferFromConfig(p,a,b)  (p)->CreateSoundBufferFromConfig(a,b)
#define IDirectSoundConnect_GetSoundBuffer(p,a,b)               (p)->GetSoundBuffer(a,b)
#define IDirectSoundConnect_GetBusCount(p,a)                    (p)->GetBusCount(a)
#define IDirectSoundConnect_GetBusIDs(p,a,b,c)                  (p)->GetBusIDs(a,b,c)
#define IDirectSoundConnect_GetFunctionalID(p,a,b)              (p)->GetFunctionalID(a,b)
#define IDirectSoundConnect_GetSoundBufferBusIDs(p,a,b,c,d)     (p)->GetSoundBufferBusIDs(a,b,c,d)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSinkSync: provided by the DirectMusic master clock
// to allow DirectSound to synchronize with it
//

DEFINE_GUID(IID_IDirectSoundSinkSync, 0xd28de0d0, 0x2794, 0x492f, 0xa3, 0xff, 0xe2, 0x41, 0x80, 0xd5, 0x43, 0x79);

#undef INTERFACE
#define INTERFACE IDirectSoundSinkSync

DECLARE_INTERFACE_(IDirectSoundSinkSync, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSinkSync methods
    STDMETHOD(SetClockOffset)       (THIS_ LONGLONG llOffset) PURE;
};

#define IDirectSoundSinkSync_QueryInterface(p,a,b)  IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSinkSync_AddRef(p)              IUnknown_AddRef(p)
#define IDirectSoundSinkSync_Release(p)             IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSinkSync_SetClockOffset(p,a)    (p)->lpVtbl->SetClockOffset(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSinkSync_SetClockOffset(p,a)    (p)->SetClockOffset(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundSource (currently private)
//

DEFINE_GUID(IID_IDirectSoundSource, 0x536f7af3, 0xdb03, 0x4888, 0x93, 0x66, 0x54, 0x48, 0xb1, 0x1d, 0x4a, 0x19);

#undef INTERFACE
#define INTERFACE IDirectSoundSource

DECLARE_INTERFACE_(IDirectSoundSource, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundSource methods
    STDMETHOD(SetSink)              (THIS_ LPDIRECTSOUNDCONNECT pSinkConnect) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(Seek)                 (THIS_ ULONGLONG ullPosition) PURE;
    STDMETHOD(Read)                 (THIS_ LPVOID *ppvBusBuffers, LPDWORD pdwIDs, LPDWORD pdwFuncIDs, LPLONG plPitchAdjust, DWORD dwBufferCount, ULONGLONG *ullLength) PURE;
    STDMETHOD(GetSize)              (THIS_ ULONGLONG *pullStreamSize) PURE;
};

#define IDirectSoundSource_QueryInterface(p,a,b)    IUnknown_QueryInterface(p,a,b)
#define IDirectSoundSource_AddRef(p)                IUnknown_AddRef(p)
#define IDirectSoundSource_Release(p)               IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSource_SetSink(p,a)             (p)->lpVtbl->SetSink(p,a)
#define IDirectSoundSource_GetFormat(p,a,b)         (p)->lpVtbl->GetFormat(p,a,b)
#define IDirectSoundSource_Seek(p,a)                (p)->lpVtbl->Seek(p,a)
#define IDirectSoundSource_Read(p,a,b,c,d,e)        (p)->lpVtbl->Read(p,a,b,c,d,e)
#define IDirectSoundSource_GetSize(p,a)             (p)->lpVtbl->GetSize(p,a)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundSource_SetSink(p,a)             (p)->SetSink(a)
#define IDirectSoundSource_GetFormat(p,a,b)         (p)->GetFormat(a,b)
#define IDirectSoundSource_Seek(p,a)                (p)->Seek(a)
#define IDirectSoundSource_Read(p,a,b,c,d,e)        (p)->Read(a,b,c,d,e)
#define IDirectSoundSource_GetSize(p,a)             (p)->GetSize(a)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

//
// IDirectSoundWave (currently private)
//

DEFINE_GUID(IID_IDirectSoundWave, 0x69e934e4, 0x97f1, 0x4f1d, 0x88, 0xe8, 0xf2, 0xac, 0x88, 0x67, 0x13, 0x27);

#define DSWCS_F_DEINTERLEAVED   0x00000001
#define DSWCS_F_TOGGLE_8BIT     0x00000002

#undef INTERFACE
#define INTERFACE IDirectSoundWave

DECLARE_INTERFACE_(IDirectSoundWave, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    // IDirectSoundWave methods
    STDMETHOD(CreateSource)         (THIS_ LPDIRECTSOUNDSOURCE *ppDSSource, LPWAVEFORMATEX pwfxFormat, DWORD dwFlags) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStreamingParms)    (THIS_ LPDWORD pdwFlags, REFERENCE_TIME *prtReadAhead) PURE;
};

#define IDirectSoundWave_QueryInterface(p,a,b)      IUnknown_QueryInterface(p,a,b)
#define IDirectSoundWave_AddRef(p)                  IUnknown_AddRef(p)
#define IDirectSoundWave_Release(p)                 IUnknown_Release(p)

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundWave_CreateSource(p,a,b,c)      (p)->lpVtbl->CreateSource(p,a,b,c)
#define IDirectSoundWave_GetFormat(p,a,b)           (p)->lpVtbl->GetFormat(p,a,b)
#define IDirectSoundWave_GetStreamingParms(p,a,b)   (p)->lpVtbl->GetStreamingParms(p,a,b)
#else // !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectSoundWave_CreateSource(p,a,b,c)      (p)->CreateSource(a,b,c)
#define IDirectSoundWave_GetFormat(p,a,b)           (p)->GetFormat(a,b)
#define IDirectSoundWave_GetStreamingParms(p,a,b)   (p)->GetStreamingParms(a,b)
#endif // !defined(__cplusplus) || defined(CINTERFACE)

#endif // XBOX

#endif // _XSOUNDP_DOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\trackhelp.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Unless you're doing something pretty unusual, you should be able to inherit from one
//    of these classes and reduce the work needed to implement a new track type.
//
// * CBasicTrack
//    Contains stubs that no-op or return notimpl most track methods.
//    You implement Load, InitPlay, EndPlay, PlayMusicOrClock, and Clone.
//
// * CPlayingTrack
//    CBasicTrack plus standard implementations of InitPlay, EndPlay, Clone.
//    PlayMusicOrClock and Load are partially implemented.  You fill in the rest by implementing
//       the methods PlayItem and LoadRiff.
//    You also must implement classes for event items and (optionally) state data.

#pragma once

#include "dmusicip.h"
#include "dmplugin.h"
#include "validate.h"
#include "miscutil.h"
#include "tlist.h"
#include "smartref.h"


const int gc_RefPerMil = 10000; // Value for converting from reference time to milliseconds


//////////////////////////////////////////////////////////////////////
// TrackHelpCreateInstance
// Standard implementation of CreateInstance to call from class factory templated on
// the type of your derived class.  Your class constructor must take an HRESULT pointer
// it can use to return an error.

template <class T>
HRESULT TrackHelpCreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv, T *pUnused = NULL)
{
	// 
	// pUnused is just a dummy to force generation of the correct template type T.
	// Compiler bug?

	*ppv = NULL;
	if (pUnknownOuter)
		 return CLASS_E_NOAGGREGATION;

	HRESULT hr = S_OK;
	T *pInst = new T(&hr);
	if (pInst == NULL)
		return E_OUTOFMEMORY;
	if (FAILED(hr))
		return hr;

	return pInst->QueryInterface(iid, ppv);
}

//////////////////////////////////////////////////////////////////////
// CBasicTrack
//
// Base class with a standard implementation the following aspects of a DirectMusic track:
// - IUnknown: AddRef, Release, and QueryInterface (QI for IUnknown, IDirectMusicTrack, IDirectMusicTrack8, IPersistStream, IPersist)
// - IPersistStrea: stubs out GetClassID, IsDirty, Save, and GetSizeMax.
// - IDirectMusicTrack:
//      stubs out IsParamSupported, Init, GetParam, SetParam, AddNotificationType, RemoveNotificationType.
//      implements millisecond time conversion for PlayEx, GetParamEx, SetParamEx.
// - Declares and initializes a critical section.
//
// Pure virtual functions you must implement:
// - Load
// - InitPlay
// - EndPlay
// - Clone
// - PlayMusicOrClock (single method called by both Play and PlayEx)

class CBasicTrack
  : public IPersistStream,
	public IDirectMusicTrack8
{
public:
	// IUnknown
	STDMETHOD(QueryInterface)(const IID &iid, void **ppv);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IPersistStream functions
	STDMETHOD(GetClassID)(CLSID* pClassID);
	STDMETHOD(IsDirty)() {return S_FALSE;}
	STDMETHOD(Load)(IStream* pStream) = 0;
	STDMETHOD(Save)(IStream* pStream, BOOL fClearDirty) {return E_NOTIMPL;}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pcbSize) {return E_NOTIMPL;}

	// IDirectMusicTrack methods
	STDMETHOD(IsParamSupported)(REFGUID rguid) {return DMUS_E_TYPE_UNSUPPORTED;}
	STDMETHOD(Init)(IDirectMusicSegment *pSegment);
	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags) = 0;
	STDMETHOD(EndPlay)(void *pStateData) = 0;
	STDMETHOD(Play)(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID);
	STDMETHOD(GetParam)(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData) {return DMUS_E_GET_UNSUPPORTED;}
	STDMETHOD(SetParam)(REFGUID rguid,MUSIC_TIME mtTime,void *pData) {return DMUS_E_SET_UNSUPPORTED;}
	STDMETHOD(AddNotificationType)(REFGUID rguidNotification) {return E_NOTIMPL;}
	STDMETHOD(RemoveNotificationType)(REFGUID rguidNotification) {return E_NOTIMPL;}
	STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack) = 0;

	// IDirectMusicTrack8
	STDMETHODIMP PlayEx(
		void* pStateData,
		REFERENCE_TIME rtStart,
		REFERENCE_TIME rtEnd,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID);
	STDMETHODIMP GetParamEx(REFGUID rguidType, REFERENCE_TIME rtTime, REFERENCE_TIME* prtNext, void* pParam, void * pStateData, DWORD dwFlags);
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

protected:
	// plModuleLockCounter: a pointer to your .dll's lock counter that will be incremented/decremented when the track is created/destroyed
	// rclsid: the classid of your track
	CBasicTrack(long *plModuleLockCounter, const CLSID &rclsid); // Takes pointer to lock counter to increment and decrement on component creation/destruction.  Typically, pass &g_cComponent and the clsid of your track.
	virtual ~CBasicTrack() { InterlockedDecrement(m_plModuleLockCounter); }

	// Shared implentation of play for either music or clock time.
	virtual HRESULT PlayMusicOrClock(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		bool fClockTime) = 0;

	// Use this critical section to guard entry points for thread safety
	CRITICAL_SECTION m_CriticalSection;

private:
	long m_cRef;
	long *m_plModuleLockCounter;
	const CLSID &m_rclsid;
};

//////////////////////////////////////////////////////////////////////
// CPlayingTrack
//
// Base class that provides standard implementations of InitPlay, EndPlay, and Clone.
// Also, partially implemented are:
//  - PlayMusicOrClock.  You must implement the pure virual function PlayItem, which is
//    called during play as each event needs to be performed.
//  - Load.  This just does a few standard things (clearing the event list, incrementing the
//    state data counter, optionally getting the loader, and sorting the results).  It
//    depends on your implementation of the pure virtual function LoadRiff that you must
//    implement to do the real processing.
// Template types required:
//    T: Your derived class (needed for New in clone).  Must have a constructor that takes a pointer to an HRESULT.
//    StateData: Type for your state data.  Must contain dwValidate, used to check if the track has been reloaded, and pCurrentEvent, a pointer to the next event item to be played.
//    EventItem: Type for the event items in your track.  Must contain lTriggerTime, which is the time during Play when PlayItem will be called.  Must implement Clone, which copies another EventItem, shifting it back according to a start MUSIC_TIME.

// Standard state data for use with CPlayingTrack.  Or inherit from it and add more information.
template<class EventItem>
struct CStandardStateData
{
	CStandardStateData() : dwValidate(0), pCurrentEvent(NULL) {}
	DWORD dwValidate;
	TListItem<EventItem> *pCurrentEvent;
};

template<class T, class EventItem, class StateData = CStandardStateData<EventItem> >
class CPlayingTrack
  : public CBasicTrack
{
public:
	typedef StateData statedata;

	STDMETHOD(Load)(IStream* pIStream);
	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags);
	STDMETHOD(EndPlay)(void *pStateData);
	STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
	virtual HRESULT PlayMusicOrClock(
		void *pStateData,
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		DWORD dwFlags,
		IDirectMusicPerformance* pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		bool fClockTime);

protected:
	// plModuleLockCounter: a pointer to your .dll's lock counter that will be incremented/decremented when the track is created/destroyed
	// rclsid: the classid of your track
	// fNeedsLoader: pass true if you will need a reference to the loader when your LoadRiff method is called
	// fPlayInvalidations: if true, then your items will be played more than once when an invalidation occurs
	//						pass false if your track doesn't want to respond to invalidations
	CPlayingTrack(long *plModuleLockCounter, const CLSID &rclsid, bool fNeedsLoader, bool fPlayInvalidations);

	virtual HRESULT PlayItem(
		const EventItem &item,
		StateData &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime) = 0; // feel free to add additional parameters if you need to pass more information from Play
	virtual HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader) = 0; // note that pIDMLoader will be null unless true is passed for fNeedsLoader in constructor

	virtual TListItem<EventItem> *Seek(MUSIC_TIME mtStart); // this method is provided in case you want to inherit and intercept when a seek is happening

	// Increment this counter in Load, causing the state data to synchonize with the new events
	DWORD m_dwValidate;
	TList<EventItem> m_EventList;
	bool m_fNeedsLoader;
	bool m_fPlayInvalidations;
};

#include "trackhelp.inl"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dmusic2\shared\smartref.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Simple helper classes that use the "resource acquisition is initialization" technique.
// In English, this means they acquire a reference to a resource and the resource is automatically
//    released in the destructor.
//

// This is particularly helpful if you are using exception handling or simulating it (painfully)
//    in OLE by putting "if (FAILED(hr)) return;" after every function call.  In such circumstances
//    it simpler if you know that the resource will be automatically freed no matter how you end
//    up exiting the function.
// Since we're not using exception handling, these classes do not throw.  If resource acquisition
//    could fail, be sure to check for the error before using the resource!
// Sometimes these helper classes are more than just simple wrappers for freeing the resource.
//    They may also provide useful methods that make it easier to perform operations on the resource.
// Everything here is enclosed in the SmartRef namespace.  Thus you can't refer to CritSec directly.
//    Instead you must say SmartRef::CritSec.

#pragma once
#include "debug.h"
#include "mmsystem.h"
#include "dmstrm.h"
#include "dmerror.h"
#include "dmusicip.h"

// Place this in the private: section of a class to prevent use of the default C++ copy and assignment.
// Creates an error if someone later tries to use the automatic member-by-member copy that would be incorrect.
// Use this if you don't do the work to implement correct copying or if copying doesn't make sense for this class.
#define NOCOPYANDASSIGN(classname) classname(const classname &o); classname &operator= (const classname &o);

namespace SmartRef
{

	// Enters a critical section on contruction.  Leaves on destruction.
	class CritSec
	{
	public:
#ifdef XBOX
		CritSec(CRITICAL_SECTION *pCriticalSection) : m_pCriticalSection() {  }
		~CritSec() {  }
#else
		CritSec(CRITICAL_SECTION *pCriticalSection) : m_pCriticalSection(pCriticalSection) { EnterCriticalSection(m_pCriticalSection); }
		~CritSec() { LeaveCriticalSection(m_pCriticalSection); }
#endif
	private:
		NOCOPYANDASSIGN(CritSec)
		CRITICAL_SECTION *m_pCriticalSection;
	};

	// Makes a copy of an ANSI string and frees it on destruction.
	// hungarian: astr
	class AString
	{
	public:
		AString(const WCHAR *psz) : m_psz(NULL) { this->AssignFromW(psz); }
		AString(const char *psz = NULL) : m_psz(NULL) { *this = psz; }
		AString(const char *psz, UINT cch); // take first cch characters of psz
		AString(const AString &str) : m_psz(NULL) { *this = str.m_psz; }
		~AString() { *this = NULL; }
		operator const char *() const { return m_psz; }
		AString &operator= (const char *psz);
		AString &operator= (const AString &str) { return *this = str.m_psz; }
		AString &Assign(const char *psz, UINT cch); // take first cch characters of psz
		AString &AssignFromW(const WCHAR *psz);

		char ** operator& () { assert(!m_psz); return &m_psz; } // allows direct setting of psz, adopting a string without copying it

	private:
		char *m_psz;
	};

	// Same as AString for Unicode strings.
	// Also accepts ANSI strings, converting them to Unicode.
	// hungarian: wstr
	class WString
	{
	public:
		WString(const char *psz) : m_psz(NULL) { this->AssignFromA(psz); }
		WString(const WCHAR *psz = NULL) : m_psz(NULL) { *this = psz; }
		WString(const WCHAR *psz, UINT cch) : m_psz(NULL) { this->Assign(psz, cch); }
		WString(const WString &str) : m_psz(NULL) { *this = str.m_psz; }
		~WString() { *this = static_cast<WCHAR *>(NULL); }
		operator const WCHAR *() const { return m_psz; }
		WString &operator= (const WCHAR *psz);
		WString &operator= (const WString &str) { return *this = str.m_psz; }
		WString &Assign(const WCHAR *psz, UINT cch); // take first cch characters of psz
		WString &AssignFromA(const char *psz);

		WCHAR ** operator& () { assert(!m_psz); return &m_psz; } // allows direct setting of psz, adopting a string without copying it

	private:
		WCHAR *m_psz;
	};

	// Allocates a writable buffer of a fixed size and frees it on destruction.
	// (For example, you could use a Buffer<char> to write a string into.)
	// hungarian: buf prefixed by type
	//            use abuf for Buffer<char> and wbuf for Buffer<WCHAR>
	template<class T>
	class Buffer
	{
	public:
		Buffer(UINT uiSize) { m_p = new T[uiSize + 1]; }
		~Buffer() { delete[] m_p; }
		operator T *() { return m_p; }

		// use to defer allocation (say, if you don't know the size at the declaration)
		Buffer() : m_p(NULL) {}
		void Alloc(UINT uiSize) { delete[] m_p; m_p = new T[uiSize + 1]; }
		T* disown() { T *_p = m_p; m_p = NULL; return _p; }
		T** operator& () { assert(!m_p); return &m_p; } // allows direct setting of m_p, adopting a string without copying it

	private:
		NOCOPYANDASSIGN(Buffer)
		T *m_p;
	};

	// Holds an array that grows automatically.
	// Doesn't throw so you must call AccessTo before using a position that might have required
	//    reallocation to ensure that memory didn't run out.
	// Values held in the vector must have value semantics so that they can be copied freely
	//    into reallocated memory slots.
	// hungarian: vec prefixed by type
	//            of just use svec (for smart vector) without specifying the type
	//            use avec for Vector<char> and wvec for Vector<WCHAR>
	template<class T>
	class Vector
	{
	public:
		Vector() : m_pT(NULL), m_size(0), m_capacity(0) {}
		~Vector() { delete[] m_pT; }
		UINT size() { return m_size; }
		operator bool() { return m_fFail; }
		bool AccessTo(UINT uiPos) { return Grow(uiPos + 1); }
		T& operator[](UINT uiPos) { assert(uiPos < m_size); return m_pT[uiPos]; }
		T* GetArray() { return m_pT; } // Danger: only use when needed and don't write past the end.
		void Shrink(UINT uiNewSize) { m_size = uiNewSize; } // Semantically shrinks -- doesn't actually free up any memory

	private:
		NOCOPYANDASSIGN(Vector)
		bool Grow(UINT size)
			{
				if (size > m_size)
				{
					if (size > m_capacity)
					{
						for (UINT capacity = m_capacity ? m_capacity : 1;
								capacity < size;
								capacity *= 2)
						{}
						T *pT = new T[capacity];
						if (!pT)
							return false;
						for (UINT i = 0; i < m_size; ++i)
							pT[i] = m_pT[i];
						delete[] m_pT;
						m_pT = pT;
						m_capacity = capacity;
					}
					m_size = size;
				}
				return true;
			}

		T *m_pT;
		UINT m_size;
		UINT m_capacity;
	};

	// Standard stack abstract data type.
	// Values held in the stack must have value semantics so that they can be copied freely
	//    into reallocated memory slots.
	// hungarian: stack prefixed by type
	template<class T>
	class Stack
	{
	public:
		Stack() : iTop(-1) {}
		bool empty() { return iTop < 0; }
		HRESULT push(const T& t) { if (!m_vec.AccessTo(iTop + 1)) return E_OUTOFMEMORY; m_vec[++iTop] = t; return S_OK; }
		T top() { if (empty()) {assert(false); return T();} return m_vec[iTop]; }
		void pop() { if (empty()) {assert(false); return;} --iTop; }

	private:
		Vector<T> m_vec;
		int iTop;
	};

	// Lookup table that maps keys to values.  Grows automatically as needed.
	// Type K (keys) must support operator =, operator ==. and a Hash function that returns an int.
	// Type V must support operator =.
	template <class K, class V>
	class Hash
	{
	public:
		Hash(HRESULT *phr, int iInitialSize = 2) : m_p(NULL), m_iCapacity(0), m_iSize(0) { *phr = Grow(iInitialSize); }
		~Hash() { delete[] m_p; }

		struct entry
		{
			V v;
			bool fFound() { return iHash != -1; }
		private:
			// only let the hash make them
			friend class Hash<K, V>;
			entry() : iHash(-1) {};
			entry(const entry &o); // disallowed copy constructor

			int iHash;
			K k;
		};

		entry &Find(K k) // if iHash is -1 then it wasn't found and you may immediately add the entry using Add().
		{
			assert(m_p);
			return HashTo(k.Hash(), k, m_p, m_iCapacity);
		}

		// Warning: no intervening additions may have occurred between the time e was returned by Find and the time Add(e, ...) is called.
		// Also k must be the same in both calls.  If you want to be crafty, "same" can be replaced with equivalence in terms of Hash and operator==.
		HRESULT Add(entry &e, K k, V v)
		{
			assert(!e.fFound());
			assert(&e == &Find(k));

			e.v = v;
			e.iHash = k.Hash();
			e.k = k;
			++m_iSize;
			if (m_iSize * 2 > m_iCapacity)
				return Grow(m_iCapacity * 2);
			return S_OK;
		}

		V &operator[](K k)
		{
			entry &e = Find(k);
			assert(e.fFound());
			return e.v;
		}

	private:
		HRESULT Grow(int iCapacity)
		{
#ifdef DBG
			// size must be at least 2 and a power of 2
			for (int iCheckSize = iCapacity; !(iCheckSize & 1); iCheckSize >>= 1)
			{}
			assert(iCapacity > 1 && iCheckSize == 1);
#endif

			// alloc new table
			entry *p = new entry[iCapacity];
			if (!p)
			{
				delete[] m_p;
				return E_OUTOFMEMORY;
			}

			// rehash everything into the larger table
			for (int i = 0; i < m_iCapacity; ++i)
			{
				entry &eSrc = m_p[i];
				if (eSrc.iHash != -1)
				{
					entry &eDst = HashTo(eSrc.iHash, eSrc.k, p, iCapacity);
					assert(eDst.iHash == -1);
					eDst = eSrc;
				}
			}

			delete[] m_p;
			m_p = p;
			m_iCapacity = iCapacity;
			return S_OK;
		}

		entry &HashTo(int iHash, K k, entry *p, int iCapacity)
		{
			// initial hash using modulus, then jump three slots at a time (3 is guaranteed to take us to all slots because capacity is a power of 2)
			assert(iHash >= 0);
			for (int i = iHash % iCapacity;
					p[i].iHash != -1 && (p[i].iHash != iHash || !(p[i].k == k)); // rehash while slot occupied or it doesn't match
					i = (i + 3) % iCapacity)
			{}
			return p[i];
		}
		
		entry *m_p;
		int m_iCapacity;
		int m_iSize;
	};

	// Holds the supplied pointer and frees it on destruction.
	// hungarian: sp (smart pointer)
	template <class T>
	class Ptr
	{
	public:
		Ptr(T *_p) : p(_p) {}
		~Ptr() { delete p; }
		operator T*() { return p; }
		T *operator->() { return p; }

		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		NOCOPYANDASSIGN(Ptr)
		T* p;
	};

	// Holds the supplied pointer to an array and frees it (with delete[]) on destruction.
	// hungarian: sprg
	template <class T>
	class PtrArray
	{
	public:
		PtrArray(T *_p) : p(_p) {}
		~PtrArray() { delete[] p; }
		operator T*() { return p; }

		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		NOCOPYANDASSIGN(PtrArray)
		T* p;
	};

	// Holds the supplied COM interface and releases it on destruction.
	// hungarian: scom
	template <class T>
	class ComPtr
	{
	public:
		ComPtr(T *_p = NULL) : p(_p) {}
		~ComPtr() { *this = NULL; }
		operator T*() { return p; }
		T* operator-> () { assert(p); return p; }
		ComPtr &operator= (T *_p) { if (p) p->Release(); p = _p; return *this; }
		T** operator& () { assert(!p); return &p; }

		void Release() { *this = NULL; }
		T* disown() { T *_p = p; p = NULL; return _p; }

	private:
		T* p;
	};

#ifndef XBOX
	// Holds the supplied registry key handle and closes it on destruction.
	// hungarian: shkey
	class HKey
	{
	public:
		HKey(HKEY hkey = NULL) : m_hkey(hkey) {}
		~HKey() { *this = NULL; }
		HKey &operator= (HKEY hkey) { if (m_hkey) ::RegCloseKey(m_hkey); m_hkey = hkey; return *this; }
		HKEY *operator& () { assert(!m_hkey); return &m_hkey; }
		operator HKEY() { return m_hkey; }

	private:
		NOCOPYANDASSIGN(HKey)
		HKEY m_hkey;
	};
#endif // XBOX

	// Allocates and clears a one of the DMUS_*_PMSG structures.  You fill out its fields
	// and then call StampAndSend.  The message is automatically cleared after a successful
	// send or freed on destruction.  Be sure the check the hr function for failures.
	// hungarian: pmsg
	template <class T>
	class PMsg
	{
	public:
		T *p; // pointer to the message structure -- use to set the fields before sending
		PMsg(IDirectMusicPerformance *pPerf, UINT cbExtra = 0) // use cbExtra to allocate extra space in the structure, such as for DMUS_SYSEX_PMSG or DMUS_LYRIC_PMSG
		  : m_pPerf(pPerf), m_hr(S_OK), p(NULL)
		{
			const UINT cb = sizeof(T) + cbExtra;
			m_hr = m_pPerf->AllocPMsg(cb, reinterpret_cast<DMUS_PMSG**>(&p));
			if (SUCCEEDED(m_hr))
			{
				assert(p->dwSize == cb);
				ZeroMemory(p, cb);
				p->dwSize = cb;
			}
		}
		~PMsg() { if (p) m_pPerf->FreePMsg(reinterpret_cast<DMUS_PMSG*>(p)); }
		void StampAndSend(IDirectMusicGraph *pGraph)
		{
			m_hr = pGraph->StampPMsg(reinterpret_cast<DMUS_PMSG*>(p));
			if (FAILED(m_hr))
				return;

			m_hr = m_pPerf->SendPMsg(reinterpret_cast<DMUS_PMSG*>(p));
			if (SUCCEEDED(m_hr))
				p = NULL; // PMsg now owned by the performance
		}
		HRESULT hr() { return m_hr; }

	private:
		NOCOPYANDASSIGN(PMsg)
		IDirectMusicPerformance *m_pPerf; // weak ref
		HRESULT m_hr;
	};

	// Walks through the RIFF file structure held in a stream.  Releases it on destruction.
	// Although I found this to be quite useful, it a bit complicated.  You should look over
	//    the source or step through some examples before you use it.  Although I'm not positive
	//    this wouldn't work, it is not designed to have multiple RiffIter's walking over the
	//    same stream at once (see note in Descend).
	// hungarian: ri
	class RiffIter
	{
	public:
		enum RiffType { Riff, List, Chunk };

		RiffIter(IStream *pStream);
		~RiffIter();

		RiffIter &operator ++();
		RiffIter &Find(RiffType t, FOURCC id);
		HRESULT FindRequired(RiffType t, FOURCC id, HRESULT hrOnNotFound) { if (Find(t, id)) return S_OK; HRESULT _hr = hr(); return SUCCEEDED(_hr) ? hrOnNotFound : _hr; } // Attempts to find the expected chunk.  Returns S_OK if found, an error code if there was a problem reading, and hrOnNotFound if reading worked OK but the chunk simply wasn't there.

		// With Descend, use the returned iterator to process the children before resuming use of the parent.  Using both at once won't work.
		RiffIter Descend() { validate(); return RiffIter(*this, m_ckChild); }

		operator bool() const { return SUCCEEDED(m_hr); }
		HRESULT hr() const { return (m_hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : m_hr; }

		RiffType type() const { validate(); return (m_ckChild.ckid == FOURCC_LIST) ? List : ((m_ckChild.ckid == FOURCC_RIFF) ? Riff : Chunk); }
		FOURCC id() const { validate(); return (type() == Chunk) ? m_ckChild.ckid : m_ckChild.fccType; }

		DWORD size() const { validate(); assert(type() == Chunk); return m_ckChild.cksize; }
		HRESULT ReadChunk(void *pv, UINT cb);
		HRESULT ReadArrayChunk(DWORD cbSize, void **ppv, int *pcRecords); // Reads an array chunk that is an array of records where the first DWORD gives the size of the records.  The records are copied into an array of records of size dwSize (filling with zero if the actual records in the file are smaller and ignoring additional fields if the actual records are larger).  ppv is set to return a pointer to this array, which the caller now owns and must delete.  pcRecords is set to the number of records returned.

		// Find the chunk (or return hrOnNoteFound). Load an object embedded in the stream. Then leaves the iterator on the next chunk.
		HRESULT FindAndGetEmbeddedObject(RiffType t, FOURCC id, HRESULT hrOnNotFound, IDirectMusicLoader *pLoader, REFCLSID rclsid, REFIID riid, LPVOID *ppv);

		// read specific RIFF structures
		HRESULT ReadReference(DMUS_OBJECTDESC *pDESC); // no need to init (zero, set size) the passed descriptor before calling
		HRESULT LoadReference(IDirectMusicLoader *pIDMLoader, const IID &iid, void **ppvObject)
		{
			DMUS_OBJECTDESC desc;
			HRESULT hr = ReadReference(&desc);
			if(SUCCEEDED(hr))
				hr = pIDMLoader->GetObject(&desc, iid, ppvObject);
			return hr;
		}

		struct ObjectInfo
		{
			ObjectInfo() { Clear(); }
			void Clear() { wszName[0] = L'\0'; guid = GUID_NULL; vVersion.dwVersionMS = 0; vVersion.dwVersionLS = 0; }

			WCHAR wszName[DMUS_MAX_NAME];
			GUID guid;
			DMUS_VERSION vVersion;
		};
		HRESULT LoadObjectInfo(ObjectInfo *pObjInfo, RiffType rtypeStop, FOURCC ridStop); // No need to init/zero. Reads from <guid-ck>, <vers-ck>, and <UNFO-list>/<UNAM-ck>. Stops at rtypeStop/ridStop, or returns E_FAIL if not found.

		HRESULT ReadText(WCHAR **ppwsz); // allocates a buffer and reads the current chunk--a NULL-terminated Unicode string--into it
		HRESULT ReadTextTrunc(WCHAR *pwsz, UINT cbBufSize); // reads only as much as it can fit in the buffer with a terminator

		// This is deliberately placed in the public section but never implemented in order to allow statements such as:
		//   SmartRef::RiffIter riChild = ri.Descend();
		// But it is never defined to prevent someone from trying to actually make two copies of a riffiter and then use them, which is not supported.
		// This would yield an unresolved symbol error:
		//   SmartRef::RiffIter riError = ri;
		// We don't allow general copying of RiffIters.  Only used to get the return value of Descend, where it is optimized away.
		RiffIter(const RiffIter &o);

	private:
		RiffIter &operator= (const RiffIter &o); // Also never defined -- don't allow assignment

		RiffIter(const RiffIter &other, MMCKINFO ckParent);
		bool validate() const { if (FAILED(m_hr)) { assert(false); return true; } else return false; }

		HRESULT m_hr;
		IStream *m_pIStream;
		IDMStream *m_pIDMStream;
		bool m_fParent;
		MMCKINFO m_ckParent;
		MMCKINFO m_ckChild;
	};

	// Templated ReadChunk typed helpers (templated member function wasn't working for me on current version of compiler)
	template <class T> HRESULT RiffIterReadChunk(RiffIter &ri, T *pT) { return ri.ReadChunk(pT, sizeof(*pT)); }
	template <class T> HRESULT RiffIterReadArrayChunk(RiffIter &ri, T **ppT, int *pcRecords) { return ri.ReadArrayChunk(sizeof(T), reinterpret_cast<void**>(ppT), pcRecords); }

}; // namespace SmartRef
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_
#define _BILINK_

#ifdef	__cplusplus
extern	"C"
{
#endif	// __cplusplus


#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

#ifndef	CONTAINING_RECORD
#define CONTAINING_RECORD(address,type,field) \
						((type *)((PCHAR)(address) - (UINT_PTR)(&((type *)0)->field)))
#endif	// CONTAINING_RECORD

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
	void *pvObject;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink, _pvObject ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink); (_pBilink)->pvObject = _pvObject; 

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#ifdef	__cplusplus
}
#endif	// __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\bilink.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       bilink.c
 *  Content:    Management for doubly linked (BILINK) lists
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   1993				George Joy
 *   10/15/99	mjn		Changed Delete to initialize bilink element after adjusting pointers
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "commoni.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

// Note: serialization of access to BILINK structures must 
//       take place in the calling code.  Operations are
//       not intrinsically atomic.

#ifdef DEBUG
#undef DPF_MODNAME
#define DPF_MODNAME "FindObject"
int FindObject(BILINK *link,BILINK *list)
{
    BILINK *p = list->next;
    while(p != link && p != list)
        p= p->next;
    return (p==link);
}
#endif


/*=========================================================================
 *  Description:
 *      Insert an object after a specified object in the doubly linked list.
 *      The after object could be the Head BILINK for adding to the head of a
 *      queue.
 *  Returns:
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "InsertAfter"
void InsertAfter(BILINK *in,BILINK *after)
{
    #ifdef DEBUG
    if(FindObject(in,after)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = after->next;
    in->prev = after;
    after->next->prev = in;
    after->next = in;
}


/*=========================================================================
 *  Description:
 * Inserts an  object before a specified object in the doubly linked list.
 * The before object could be the Head BILINK for adding to the end
 * of the queue
 * CALLED WITH INTERRUPTS_OFF
 *
 *  Returns:
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "InsertBefore"
void InsertBefore(BILINK *in,BILINK *before)
{
    #ifdef DEBUG
    if(FindObject(in,before)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = before;
    in->prev = before->prev;
    before->prev->next = in;
    before->prev = in;
}


/*=========================================================================
 *  Description:
 *
 * Delete a  object from a doubly linked list. Make sure it IS on a list!
 * CALLED WITH INTERRUPTS OFF (must be atomic).
 *
 *  Returns:
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "Delete"
void Delete(BILINK *p)
{
    DNASSERT(p && p->prev && p->next);
    DNASSERT(p->prev->next == p && p->next->prev == p);
#ifdef	DEBUG
    if(!p && p->prev && p->next){
    	DEBUG_BREAK();
    }
    if(!(p->prev->next == p && p->next->prev == p)){
    	DEBUG_BREAK();
    }
#endif
    p->next->prev = p->prev;
    p->prev->next = p->next;
    InitBilink(p, p->pvObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\classbilink.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassBilink.h
 *  Content:	Class-based bilink
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	09/17/99	jtk		Derived from bilink.c
 *	08/15/00	masonb		Changed assert to DNASSERT and added DNASSERT(this)
 *
 ***************************************************************************/

#ifndef __CLASS_BILINK_H__
#define __CLASS_BILINK_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function Prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

class	CBilink
{
	STDNEWDELETE

	public:
		CBilink(){};
		~CBilink(){};

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::Initialize"
		void	Initialize( void )
		{
			DNASSERT( this );

			m_pNext = this;
			m_pPrev = this;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::GetNext"
		CBilink	*GetNext( void ) const 
		{ 
			DNASSERT( this );

			return m_pNext; 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::GetPrev"
		CBilink *GetPrev( void ) const 
		{ 
			DNASSERT( this );

			return m_pPrev; 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::IsEmpty"
		BOOL	IsEmpty( void ) const
		{
			DNASSERT( this );
			DNASSERT( m_pNext != NULL );

			if ( ( m_pNext == m_pPrev ) &&
				 ( m_pNext == this ) )
			{
				return	TRUE;
			}

			return	FALSE;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::IsListMember"
		BOOL	IsListMember( const CBilink *const pList ) const
		{
			DNASSERT( this );
			DNASSERT( pList );

			CBilink	*pTemp = pList->GetNext();
			while ( pTemp != pList )
			{
				if ( pTemp == this )
				{
					return	TRUE;
				}
				pTemp = pTemp->GetNext();
			}

			return	FALSE;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::InsertAfter"
		void	InsertAfter( CBilink* const pList )
		{
			DNASSERT( this );
			DNASSERT( pList->m_pNext );
			DNASSERT( pList->m_pPrev );
			DNASSERT( !IsListMember( pList ) );

			m_pNext = pList->m_pNext;
			m_pPrev = pList;
			pList->m_pNext->m_pPrev = this;
			pList->m_pNext = this;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::InsertBefore"
		void	InsertBefore( CBilink* const pList )
		{
			DNASSERT( this );
			DNASSERT( pList->m_pNext );
			DNASSERT( pList->m_pPrev );
			DNASSERT( !IsListMember( pList ) );

			m_pNext = pList;
			m_pPrev = pList->m_pPrev;
			pList->m_pPrev->m_pNext = this;
			pList->m_pPrev = this;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CBilink::RemoveFromList"
		void	RemoveFromList( void )
		{
			DNASSERT( this );
			DNASSERT( m_pNext );
			DNASSERT( m_pPrev );
			DNASSERT( m_pNext->m_pPrev == this );
			DNASSERT( m_pPrev->m_pNext == this );

			m_pNext->m_pPrev = m_pPrev;
			m_pPrev->m_pNext = m_pNext;
			Initialize();
		}

	protected:

	private:
		CBilink	*m_pNext;
		CBilink	*m_pPrev;
};

#undef DPF_MODNAME
#undef DPF_SUBCOMP

#endif	// __CLASS_BILINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\sources.inc ===
INCLUDES=\
    $(PRIVATE_INC_PATH); \
    $(BASEDIR)\private\ntos\inc; \
    $(BASEDIR)\private\windows\directx\dplay\protocol; \
    $(BASEDIR)\private\windows\directx\dplay\common; \
    $(BASEDIR)\private\windows\directx\dplay\dnaddress; \
    $(BASEDIR)\private\windows\directx\dplay\core; \
    $(BASEDIR)\private\windows\directx\dplay\sp\wsock; \
    $(BASEDIR)\private\online\client\inc


C_DEFINES=\
    -D_UNICODE \
    -DUNICODE \
    -DNT \
    -DMICHAEL \
    -DCINTERFACE \
    -DDPLAY_DOWORK

MSC_WARNING_LEVEL=/W3 /WX

!ifdef DEBUG_DPLAY
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /FAcs
!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\classfpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFPM.h
 *  Content:	fixed size pool manager for classes
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97	aarono	Original
 *	11-06-98	ejs		Add custom handler for Release function
 *	04-12-99	jtk		Trimmed unused functions and parameters, added size assert
 *	01-31-2000	jtk		Added code to check for items already being in the pool on Release().
***************************************************************************/

#ifndef __CLASS_FPM_H__
#define __CLASS_FPM_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	CLASSFPM_BLANK_NODE_VALUE	0x55AA817E

#define	CHECK_FOR_DUPLICATE_CLASSFPM_RELEASE

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

// class to act as a link in the pool
template< class T >
class	CPoolNode
{
	STDNEWDELETE

	public:
		CPoolNode() { m_pNext = NULL; }
		~CPoolNode() {};

		T			m_Item;
		CPoolNode	*m_pNext;

	protected:
	private:
};

// class to manage the pool
template< class T >
class	CFixedPool
{
	STDNEWDELETE

	public:
		CFixedPool();
		~CFixedPool();

		T		*Get( void );
		void	Release( T *const pItem );

	protected:

	private:
		CPoolNode< T >		*m_pPool;		// pointer to list of available elements
		DEBUG_ONLY( UINT_PTR	m_uOutstandingItemCount );
};

//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CFixedPool::Get - get an item from the pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CFixedPool::CFixedPool"

template< class T >
CFixedPool< T >::CFixedPool()
{
	m_pPool = NULL;
	DEBUG_ONLY( m_uOutstandingItemCount = 0 );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CFixedPool::~CFixedPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CFixedPool::~CFixedPool"

template< class T >
CFixedPool< T >::~CFixedPool()
{
	DEBUG_ONLY( DNASSERT( m_uOutstandingItemCount == 0 ) );
	while ( m_pPool != NULL )
	{
		CPoolNode< T >	*pTemp;

		pTemp = m_pPool;
		m_pPool = m_pPool->m_pNext;
		delete	pTemp;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CFixedPool::Get - get an item from the pool
//
// Entry:		Nothing
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CFixedPool::Get"

template< class T >
T	*CFixedPool< T >::Get( void )
{
	CPoolNode< T >	*pNode;
	T	*pReturn;


	// initialize
	pReturn = NULL;

	// is the pool empty?
	if ( m_pPool == NULL )
	{
		// try to create a new entry
		pNode = new CPoolNode< T >;
	}
	else
	{
		// grab first item from the pool
		pNode = m_pPool;
		m_pPool = m_pPool->m_pNext;
	}

	if ( pNode != NULL )
	{
		DEBUG_ONLY( pNode->m_pNext = (CPoolNode<T>*) CLASSFPM_BLANK_NODE_VALUE );
		pReturn = &pNode->m_Item;
		DEBUG_ONLY( m_uOutstandingItemCount++ );
	}

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CFixedPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CFixedPool::Release"

template< class T >
void	CFixedPool< T >::Release( T *const pItem )
{
	CPoolNode< T >	*pNode;


	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );
	DBG_CASSERT( sizeof( CPoolNode< T >* ) == sizeof( BYTE* ) );
	pNode = reinterpret_cast<CPoolNode< T >*>( &reinterpret_cast<BYTE*>( pItem )[ -OFFSETOF( CPoolNode< T >, m_Item ) ] );

#if defined(CHECK_FOR_DUPLICATE_CLASSFPM_RELEASE) && defined(DEBUG)
	{
		CPoolNode< T >	*pTemp;


		pTemp = m_pPool;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pNode );
			pTemp = pTemp->m_pNext;
		}
	}
#endif	// CHECK_FOR_DUPLICATE_CLASSFPM_RELEASE

	DEBUG_ONLY( DNASSERT( pNode->m_pNext == (CPoolNode< T >*)CLASSFPM_BLANK_NODE_VALUE ) );
	pNode->m_pNext = m_pPool;
	m_pPool = pNode;
	DEBUG_ONLY( m_uOutstandingItemCount-- );
}
//**********************************************************************

#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__

#undef DPF_SUBCOMP
#undef DPF_MODNAME

#endif	// __CLASS_FPM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\comutil.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comutil.h
 *  Content:    Defines COM helper functions for DPLAY8 project.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06/07/00	rmt		Created
 *   06/27/00	rmt		Added abstraction for COM_Co(Un)Initialize
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

HRESULT COM_Init();
HRESULT COM_CoInitialize( void * pvParam );
void COM_CoUninitialize();
HRESULT COM_Free();
STDAPI COM_CoCreateInstance( REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppv );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\commoni.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnaddri.h
 *  Content:    DirectPlayAddress master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/28/00    dereks  Created.
 *  09/11/00	mgere	Converted to DPlay
 *
 ***************************************************************************/

#ifndef __COMMONI_H__
#define __COMMONI_H__

//
// Public includes
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>
#include <stdio.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#include <xtl.h>
#ifdef ENABLE_DPLAY_VOICE
#include <Dvoicep.h>
#endif
#include <xdbg.h>
#include <dplay8p.h>
#include <DPSP8p.h>
#include <DPAddrp.h>
#ifdef DPLAY_DOWORK_STATEMN
#include <statemn.h>
#endif

#ifdef __cplusplus

template <class type> type *__AddRef(type *p)
{
    if(p)
    {
        p->AddRef();
    }

    return p;
}

#define ADDREF(p) \
    __AddRef(p)

template <class type> void __Release(type *p)
{
    if(p)
    {
        p->Release();
    }
}

#define RELEASE(p) \
    __Release(p), p = NULL

#endif // __cplusplus

//
// Private includes
//

typedef	struct DPN_APPLICATION_DESC_INFO DPN_APPLICATION_DESC_INFO;
typedef struct _HANDLETABLE_ARRAY_ENTRY HANDLETABLE_ARRAY_ENTRY;
typedef struct IDirectPlay8Address	IDirectPlay8Address;

class DIRECTNETOBJECT;
class CWorkerJob;
class CSyncEvent;
class CNameTableOp;
class CPendingDeletion;
class CQueuedMsg;

#include "dndbg.h"
#include "DNetErrors.h"
#include "OSInd.h"
#include "guidutil.h"
#include "bilink.h"
#include "Classbilink.h"
#include "fpm.h"
#include "PackBuff.h"
#include "LockedCCfpm.h"
#include "RCBuffer.h"
#include "StrUtils.h"
#include "Queue.h"
#include "LockedCCfpm.h"
#include "createin.h"
#include "comutil.h"
#include "Connection.h"
#include "NTEntry.h"
#include "Async.h"
#include "AsyncOp.h"
#include "GroupCon.h"
#include "GroupMem.h"
#include "dnpextern.h"
#include "dnprot.h"

#include "message.h"
#include "AppDesc.h"
#include "NameTable.h"
#include "HandleTable.h"
#include "Memoryfpm.h"
#include "paramval.h"
#include "Cancel.h"
#include "EnumHosts.h"
#include "handles.h"
#include "DNCore.h"
#include "MessageStructures.h"
#include "jobqueue.h"
#include "locals.h"
#include "iodata.h"
#include "contextcfpm.h"
#include "threadpool.h"
#include "SyncEvent.h"
#include "WorkerJob.h"
#include "NTOp.h"
#include "PendingDel.h"
#include "QueuedMsg.h"

#endif // __COMMONI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\createin.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       createin.h
 *  Content:	defines functions required by the generic class factory
 *
 *
 *	The generic class factory (classfac.c) requires these functions to be
 *	implemented by the COM object(s) its supposed to be generating
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 ***************************************************************************/

#ifndef __CREATEINS__
#define __CREATEINS__


#ifdef __cplusplus
extern "C" {
#endif

// you must implement this function to create an instance of your COM object
HRESULT	DoCreateInstance(LPCLASSFACTORY This, LPUNKNOWN pUnkOuter, REFCLSID rclsid, REFIID riid,
    						LPVOID *ppvObj);

// you must implement this function.  Given a class id, you must respond
//	whether or not your DLL implements it
BOOL	IsClassImplemented(REFCLSID rclsid);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\classhash.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassHash.h
 *  Content:	Hash table that takes a class as a key.  The key class MUST support
 *				two member functions:
 *				'HashFunction' will perform a hash down to a specified number of bits.
 *				'CompareFunction' will perform a comparison of two items of that class.
 *
 *				Note: This class requires an FPM to operate.
 *
 *				THIS CLASS IS NOT THREAD SAFE!!
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/15/98	jwo		Created it (map).
 *	04/19/99	jtk		Rewrote without using STL (map)
 *	08/03/99	jtk		Derived from ClassMap.h
 ***************************************************************************/

#ifndef __CLASS_HASH_H__
#define __CLASS_HASH_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable prototypes
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//
// Template class for entry in map.
//
template<class T, class S>
class CClassHashEntry
{
	STDNEWDELETE

	public:
		CClassHashEntry(){};
		~CClassHashEntry(){};


		//
		// internals, put the linkage at the end to make sure the FPM doesn't
		// wail on it!
		//
		PVOID		m_FPMPlaceHolder;
		S			m_Key;
		T			m_Item;
		CBilink		m_Linkage;

		//
		// linkage functions
		//
		static	CClassHashEntry	*EntryFromBilink( CBilink *const pLinkage )
		{
			DBG_CASSERT( sizeof( void* ) == sizeof( INT_PTR ) );
			return	reinterpret_cast<CClassHashEntry*>( &reinterpret_cast<BYTE*>( pLinkage )[ -OFFSETOF( CClassHashEntry, m_Linkage ) ] );
		}

		void	AddToList( CBilink *const pLinkage )
		{
			m_Linkage.InsertAfter( pLinkage );
		}

		void	RemoveFromList( void )
		{
			m_Linkage.RemoveFromList();
		}

		//
		// pool management functions
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::InitAlloc"
		static	BOOL	InitAlloc( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );

			pThisObject->m_Linkage.Initialize();
			return	TRUE;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::Init"
		static	void	Init( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );
			DNASSERT( pThisObject->m_Linkage.IsEmpty() != FALSE );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::Release"
		static	void	Release( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );
			DNASSERT( pThisObject->m_Linkage.IsEmpty() != FALSE );			
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::Dealloc"
		static	void	Dealloc( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );
			DNASSERT( pThisObject->m_Linkage.IsEmpty() != FALSE );
		}

	protected:

	private:

	//
	// make copy constructor and assignment operator private and unimplemented
	// to prevent illegal copies from being made
	//
	CClassHashEntry( const CClassHashEntry & );
	CClassHashEntry& operator=( const CClassHashEntry & );
};


//
// template class for the map
//
template<class T, class S>
class	CClassHash
{
	STDNEWDELETE

	public:
		CClassHash();
		~CClassHash();

		BOOL	Initialize( const INT_PTR iBitDepth, const INT_PTR iGrowBits );
		void	Deinitialize( void );
		BOOL	Insert( const S& Key, T Item );
		void	Remove( const S& Key );
		BOOL	RemoveLastEntry( T *const pItem );
		BOOL	Find( const S& Key, T *const pItem );
		BOOL	IsEmpty( void ) { return ( m_iEntriesInUse == 0 ); }

		INT_PTR		m_iHashBitDepth;		// number of bits used for hash entry
		INT_PTR		m_iGrowBits;			// number of bits to grow has by
		CBilink		*m_pHashEntries;		// list of hash entries
		INT_PTR		m_iAllocatedEntries;	// count of allocated entries in index/item list
		INT_PTR		m_iEntriesInUse;		// count of entries in use
		FPOOL		m_EntryPool;			// pool of entries

	private:
		DEBUG_ONLY(	BOOL	m_fInitialized );

		BOOL	LocalFind( const S& Key, CBilink **const ppLink );
		void	Grow( void );
		void	InitializeHashEntries( const UINT_PTR uEntryCount ) const;

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CClassHash( const CClassHash & );
		CClassHash& operator=( const CClassHash & );
};

//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::CClassHash - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::CClassHash"

template<class T, class S>
CClassHash< T, S >::CClassHash():
	m_iHashBitDepth( 0 ),
	m_iGrowBits( 0 ),
	m_pHashEntries( NULL ),
	m_iAllocatedEntries( 0 ),
	m_iEntriesInUse( 0 )
{
	//
	// clear internals
	//
	DEBUG_ONLY( m_fInitialized = FALSE );
	memset( &m_EntryPool, 0x00, sizeof( m_EntryPool ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::~CClassHash - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::~CClassHash"

template<class T, class S>
CClassHash< T, S >::~CClassHash()
{
	DNASSERT( m_iHashBitDepth == 0 );
	DNASSERT( m_iGrowBits == 0 );
	DNASSERT( m_pHashEntries == NULL );
	DNASSERT( m_iAllocatedEntries == 0 );
	DNASSERT( m_iEntriesInUse == 0 );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Initialize - initialize hash table
//
// Entry:		Pointer to key
//				Pointer to 'key' associated with this item
//				Pointer to item to add
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Initialize"

template<class T, class S>
BOOL	CClassHash< T, S >::Initialize( const INT_PTR iBitDepth, const INT_PTR iGrowBits )
{
	BOOL		fReturn;


	DNASSERT( iBitDepth != 0 );

	//
	// initialize
	//
	fReturn = TRUE;

	DNASSERT( m_pHashEntries == NULL );
	m_pHashEntries = static_cast<CBilink*>( DNMalloc( sizeof( *m_pHashEntries ) * ( 1 << iBitDepth ) ) );
	if ( m_pHashEntries == NULL )
	{
		fReturn = FALSE;
		DPF( 0, "Unable to allocate memory for hash table!" );
		goto Exit;
	}
	m_iAllocatedEntries = 1 << iBitDepth;
	InitializeHashEntries( m_iAllocatedEntries );

	if ( FPM_Initialize( &m_EntryPool,						// pointer to pool
						 sizeof( CClassHashEntry<T,S> ),	// size of pool entry
						 CClassHashEntry<T,S>::InitAlloc,	// function for allocating item
						 CClassHashEntry<T,S>::Init,		// function for getting item from pool
						 CClassHashEntry<T,S>::Release,		// function for releasing item
						 CClassHashEntry<T,S>::Dealloc		// function for deallocating item
						 ) == FALSE )
	{
		DPF( 0, "Failed to initialize FPM!" );
		fReturn = FALSE;
	}

	m_iHashBitDepth = iBitDepth;
	m_iGrowBits = iGrowBits;

	DEBUG_ONLY( m_fInitialized = TRUE );

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Deinitialize - deinitialize hash table
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Deinitialize"

template<class T, class S>
void	CClassHash< T, S >::Deinitialize( void )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( m_iEntriesInUse == 0 );
	DNASSERT( m_pHashEntries != NULL );
	
	DNFree( m_pHashEntries );
	m_pHashEntries = NULL;
	FPM_Deinitialize( &m_EntryPool );
	
	m_iHashBitDepth = 0;
	m_iGrowBits = 0;
	m_iAllocatedEntries = 0;
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Insert - add item to map
//
// Entry:		Pointer to 'key' associated with this item
//				Pointer to item to add
//
// Exit:		Boolean indicating success:
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Insert"

template<class T, class S>
BOOL	CClassHash< T, S >::Insert( const S& Key, T Item )
{
	BOOL	fReturn;
	BOOL	fFound;
	CBilink	*pLink;
	CClassHashEntry< T, S >	*pNewEntry;

	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
 	fReturn = TRUE;
	pNewEntry = NULL;

	//
	// grow the map if applicable
	//
	if ( ( m_iEntriesInUse >= ( m_iAllocatedEntries / 2 ) ) &&
		 ( m_iGrowBits != 0 ) )
	{
		Grow();
	}

	//
	// get a new table entry before trying the lookup
	//
	pNewEntry = static_cast<CClassHashEntry<T,S>*>( m_EntryPool.Get( &m_EntryPool ) );
	if ( pNewEntry == NULL )
	{
		fReturn = FALSE;
		DPF( 0, "Problem allocating new hash table entry on Insert!" );
		goto Exit;
	}

	//
	// scan for this item in the list, since we're only supposed to have
	// unique items in the list, ASSERT if a duplicate is found
	//
	fFound = LocalFind( Key, &pLink );
	DNASSERT( pLink != NULL );
	DNASSERT( fFound == FALSE );

	//
	// officially add entry to the hash table
	//
	m_iEntriesInUse++;
	pNewEntry->m_Key = Key;
	pNewEntry->m_Item = Item;
	DNASSERT( pLink != NULL );
	pNewEntry->AddToList( pLink );

	DNASSERT( fReturn == TRUE );

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Remove - remove item from map
//
// Entry:		Reference to 'key' used to look up this item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Remove"

template<class T, class S>
void	CClassHash< T, S >::Remove( const S& Key )
{
	CBilink	*pLink;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	if ( LocalFind( Key, &pLink ) != FALSE )
	{
		CClassHashEntry< T, S >	*pEntry;


		DNASSERT( pLink != NULL );
		pEntry = pEntry->EntryFromBilink( pLink );
		pEntry->RemoveFromList();
		m_EntryPool.Release( &m_EntryPool, pEntry );

		DNASSERT( m_iEntriesInUse != 0 );
		m_iEntriesInUse--;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::RemoveLastEntry - remove last item from map
//
// Entry:		Pointer to pointer to item data
//
// Exit:		Boolean indicating success
//				TRUE = item was removed
//				FALSE = item was not removed (map empty)
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::RemoveLastEntry"

template<class T, class S>
BOOL	CClassHash< T, S >::RemoveLastEntry( T *const pItem )
{
	BOOL	fReturn;


	DNASSERT( pItem != NULL );

	//
	// initialize
	//
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	fReturn = FALSE;

	if ( m_iEntriesInUse != 0 )
	{
		INT_PTR	iIndex;


		DNASSERT( m_pHashEntries != NULL );
		iIndex = m_iAllocatedEntries;
		while ( iIndex > 0 )
		{
			iIndex--;

			if ( m_pHashEntries[ iIndex ].IsEmpty() == FALSE )
			{
				CClassHashEntry<T,S>	*pEntry;


				pEntry = pEntry->EntryFromBilink( m_pHashEntries[ iIndex ].GetNext() );
				pEntry->RemoveFromList();
				*pItem = pEntry->m_Item;
				m_EntryPool.Release( &m_EntryPool, pEntry );
				m_iEntriesInUse--;
				fReturn = TRUE;

				goto Exit;
			}
		}
	}

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Find - find item in map
//
// Entry:		Reference of 'key' used to look up this item
//				Pointer to pointer to be filled in with data
//
// Exit:		Boolean indicating success
//				TRUE = item found
//				FALSE = item not found
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Find"

template<class T, class S>
BOOL	CClassHash< T, S >::Find( const S& Key, T *const pItem )
{
	BOOL	fReturn;
	CBilink	*pLinkage;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
	fReturn = FALSE;
	pLinkage = NULL;

	if ( LocalFind( Key, &pLinkage ) != FALSE )
	{
		CClassHashEntry<T,S>	*pEntry;


		pEntry = pEntry->EntryFromBilink( pLinkage );
		*pItem = pEntry->m_Item;
		fReturn = TRUE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::LocalFind - find an entry in a hash table, or find out where to insert.
//
// Entry:		Refernce of 'key' to look for
//				Pointer to pointer to linkage of find or insert
//
// Exit:		Boolean indicating whether the item was found
//				TRUE = found
//				FALSE = not found
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::LocalFind"

template<class T, class S>
BOOL	CClassHash< T, S >::LocalFind( const S& Key, CBilink **const ppLinkage )
{
	BOOL		fFound;
	INT_PTR		HashResult;
	CBilink		*pTemp;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	HashResult = Key->HashFunction( m_iHashBitDepth );
	DNASSERT( ( HashResult < ( 1 << m_iHashBitDepth ) ) &&
			  ( HashResult >= 0 ) );

	fFound = FALSE;
	pTemp = &m_pHashEntries[ HashResult ];
	while ( pTemp->GetNext() != &m_pHashEntries[ HashResult ] )
	{
		const CClassHashEntry< T, S >	*pEntry;


		pEntry = pEntry->EntryFromBilink( pTemp->GetNext() );
		if ( Key->CompareFunction( pEntry->m_Key ) == 0 )
		{
			fFound = TRUE;
			*ppLinkage = pTemp->GetNext();
			goto Exit;
		}
		else
		{
			pTemp = pTemp->GetNext();
		}
	}

	//
	// entry was not found, return pointer to linkage to insert after if a new
	// entry is being added to the table
	//
	*ppLinkage = pTemp;

Exit:
	return	fFound;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Grow - grow hash table to next larger size
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Grow"

template<class T, class S>
void	CClassHash< T, S >::Grow( void )
{
	CBilink	*pTemp;
	INT_PTR	iNewEntryBitCount;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( m_iGrowBits != 0 );

	//
	// We're more than 50% full, find a new has table size that will accomodate
	// all of the current entries, and keep a pointer to the old data in case
	// the memory allocation fails.
	//
	pTemp = m_pHashEntries;
	iNewEntryBitCount = m_iHashBitDepth;

	do
	{
		iNewEntryBitCount += m_iGrowBits;
	} while ( m_iEntriesInUse >= ( ( 1 << iNewEntryBitCount ) / 2 ) );

	//
	// assert that we don't pull up half of the machine's address space!
	//
	DNASSERT( iNewEntryBitCount <= ( sizeof( UINT_PTR ) * 8 / 2 ) );

	m_pHashEntries = static_cast<CBilink*>( DNMalloc( sizeof( *pTemp ) * ( 1 << iNewEntryBitCount ) ) );
	if ( m_pHashEntries == NULL )
	{
		//
		// Allocation failed, restore the old data pointer and insert the item
		// into the hash table.  This will probably result in adding to a bucket.
		//
		m_pHashEntries = pTemp;
		DPF( 0, "Warning: Failed to grow hash table when 50% full!" );
	}
	else
	{
		INT_PTR		iOldHashSize;
		DEBUG_ONLY( INT_PTR		iOldEntryCount );


		//
		// we have more memory, reorient the hash table and re-add all of
		// the old items
		//
		InitializeHashEntries( 1 << iNewEntryBitCount );
		DEBUG_ONLY( iOldEntryCount = m_iEntriesInUse );

		iOldHashSize = 1 << m_iHashBitDepth;
		m_iHashBitDepth = iNewEntryBitCount;

		m_iAllocatedEntries = 1 << iNewEntryBitCount;
		m_iEntriesInUse = 0;

		DNASSERT( iOldHashSize > 0 );
		while ( iOldHashSize > 0 )
		{
			iOldHashSize--;
			while ( pTemp[ iOldHashSize ].GetNext() != &pTemp[ iOldHashSize ] )
			{
				BOOL	fTempReturn;
				S		Key;
				T		Item;
				CClassHashEntry<T,S>	*pTempEntry;


				pTempEntry = pTempEntry->EntryFromBilink( pTemp[ iOldHashSize ].GetNext() );
				pTempEntry->RemoveFromList();
				Key = pTempEntry->m_Key;
				Item = pTempEntry->m_Item;
				m_EntryPool.Release( &m_EntryPool, pTempEntry );

				//
				// Since we're returning the current hash table entry to the pool
				// it will be immediately reused in the new table.  We should never
				// have a problem adding to the new list.
				//
				fTempReturn = Insert( Key, Item );
				DNASSERT( fTempReturn != FALSE );
				DEBUG_ONLY( iOldEntryCount-- );
			}
		}

		DEBUG_ONLY( DNASSERT( iOldEntryCount == 0 ) );
		DNFree( pTemp );
		pTemp = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::InitializeHashEntries - initialize all of the entries in the hash table
//
// Entry:		Count of entries to initialize.
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::InitializeHashEntries"

template<class T, class S>
void	CClassHash< T, S >::InitializeHashEntries( const UINT_PTR uEntryCount ) const
{
	UINT_PTR	uLocalEntryCount;


	DNASSERT( m_pHashEntries != NULL );
	uLocalEntryCount = uEntryCount;
	while ( uLocalEntryCount != 0 )
	{
		uLocalEntryCount--;

		m_pHashEntries[ uLocalEntryCount ].Initialize();
	}
}
//**********************************************************************

#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__

#undef DPF_SUBCOMP
#undef DPF_MODNAME

#endif	// __CLASS_HASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\comutil.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comutil.cpp
 *  Content:    Contains implementation of COM helper functions for DPLAY8 project.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06/07/00	rmt		Created
 *   06/15/2000 rmt     Fixed small bug in COM_CoCreateInstance which was causing AV
 *   06/27/00	rmt		Added abstraction for COM_Co(Un)Initialize
 *   07/06/00	rmt		Modified to match updated creg usage
 *   08/08/2000	rmt		Bug #41736 - AV in call to lstrcpy by COM_GetDllName
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "commoni.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

typedef HRESULT (*PFNDLLGETCLASSOBJECT)(REFCLSID rclsid,REFIID riid,LPVOID *ppvObj );
typedef HRESULT (*PFNDLLCANUNLOADNOW)(void);

extern HRESULT SPDllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID *ppvObj );
extern HRESULT SPDllCanUnloadNow( void );

CBilink g_blComEntriesGlobal;
CRITICAL_SECTION csComEntriesLock;

typedef struct _COMDLL_ENTRY
{
    GUID                    clsid;
    PFNDLLGETCLASSOBJECT    pfnGetClassObject;
    PFNDLLCANUNLOADNOW      pfnCanUnloadNow;
    CBilink                 blComEntries;
} COMDLL_ENTRY, *PCOMDLL_ENTRY;

#undef DPF_MODNAME
#define DPF_MODNAME "COM_Init"
HRESULT COM_Init()
{
    g_blComEntriesGlobal.Initialize();
    InitializeCriticalSection( &csComEntriesLock );
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_Free"
HRESULT COM_Free()
{
    CBilink *pblSearch;
    PCOMDLL_ENTRY pEntry;

    pblSearch = g_blComEntriesGlobal.GetNext();

    while( pblSearch != &g_blComEntriesGlobal )
    {
        pEntry = CONTAINING_RECORD( pblSearch, COMDLL_ENTRY, blComEntries );
        pblSearch = pblSearch->GetNext();

        delete pEntry;
    }

    DeleteCriticalSection( &csComEntriesLock );
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_CoInitialize"
HRESULT COM_CoInitialize( void * pvParam )
{
	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_CoUninitialize"
void COM_CoUninitialize()
{
	return;
}

#undef DPF_MODNAME
#define DPF_MODNAME "COM_GetEntry"
HRESULT COM_GetEntry( GUID clsid, PCOMDLL_ENTRY *ppEntry )
{
    CBilink *pblSearch;
    PCOMDLL_ENTRY pEntry;
    HRESULT hr = E_FAIL;

    EnterCriticalSection( &csComEntriesLock );

    pblSearch = g_blComEntriesGlobal.GetNext();

    while( pblSearch != &g_blComEntriesGlobal )
    {
        pEntry = CONTAINING_RECORD( pblSearch, COMDLL_ENTRY, blComEntries );

		// This should never happen, but makes prefix happy
		if( !pEntry )
		{
			DNASSERT( FALSE );
			return DPNERR_GENERIC;
		}

        if( pEntry->clsid == clsid )
        {
            *ppEntry = pEntry;
            LeaveCriticalSection( &csComEntriesLock );
            return DPN_OK;
        }

        pblSearch = pblSearch->GetNext();
    }

    pEntry = new COMDLL_ENTRY;
    memset( pEntry, 0x00, sizeof( COMDLL_ENTRY ) );

    pEntry->clsid = clsid;
	pEntry->blComEntries.Initialize();

    pEntry->pfnGetClassObject = SPDllGetClassObject;
    pEntry->pfnCanUnloadNow = SPDllCanUnloadNow;

	pEntry->blComEntries.InsertBefore( &g_blComEntriesGlobal );

    LeaveCriticalSection( &csComEntriesLock );

    *ppEntry = pEntry;

    return DPN_OK;
}


// DP_CoCreateInstance
//
// This CoCreateInstance can be used instead of CoCreateInstance and will manually perform the
// steps neccessary to do a CoCreateInstance if COM has not been initialized.
//
#undef DPF_MODNAME
#define DPF_MODNAME "COM_CoCreateInstance"
STDAPI COM_CoCreateInstance( REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppv )
{
    HRESULT hr;
    PCOMDLL_ENTRY pEntry;
    IClassFactory *pClassFactory;

        hr = COM_GetEntry( rclsid, &pEntry );

        if( FAILED( hr ) )
            return hr;

        hr = (*pEntry->pfnGetClassObject)( rclsid, GUID_NULL, (void **) &pClassFactory );

        if( FAILED( hr ) )
        {
            DPF( 0, "Failed getting class object on dynamic entry hr=0x%x", hr );
            return hr;
        }


        hr = pClassFactory->lpVtbl->CreateInstance( pClassFactory, pUnkOuter, riid, ppv );

        if( FAILED( hr ) )
        {
            DPF( 0, "Class factory returned an error hr=0x%x", hr );
        }

        pClassFactory->lpVtbl->Release(pClassFactory);

        return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\classhashvc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassHash.h
 *  Content:	Hash table that takes a class as a key.  The key class MUST support
 *				two member functions:
 *				'HashFunction' will perform a hash down to a specified number of bits.
 *				'CompareFunction' will perform a comparrisson of two items of that class.
 *
 *				Note: This class requires an FPM to operate.
 *
 *				THIS CLASS IS NOT THREAD SAFE!!
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/15/98	jwo		Created it (map).
 *	04/19/99	jtk		Rewrote without using STL (map)
 *	08/03/99	jtk		Derived from ClassMap.h
 ***************************************************************************/

#ifndef __CLASS_HASH_H__
#define __CLASS_HASH_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_VOICE

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable prototypes
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************


// Macro to compute the offset of an element inside of a larger structure.
// Copied from MSDEV's STDLIB.H and modified to return INT_PTR
//
#define OFFSETOF(s,m)	( ( INT_PTR ) &( ( (s*) 0 )->m ) )
//
// Template class for entry in map.
//
template<class T, class S>
class CClassHashEntry
{
	STDNEWDELETE

	public:
		CClassHashEntry(){};
		~CClassHashEntry(){};


		//
		// internals, put the linkage at the end to make sure the FPM doesn't
		// wail on it!
		//
		PVOID		m_FPMPlaceHolder;
		S			m_Key;
		T			*m_pItem;
		CBilink		m_Linkage;

		//
		// linkage functions
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::EntryFromBilink"
		static	CClassHashEntry	*EntryFromBilink( CBilink *const pLinkage )
		{
			DBG_CASSERT( sizeof( void* ) == sizeof( INT_PTR ) );
			return	reinterpret_cast<CClassHashEntry*>( &reinterpret_cast<BYTE*>( pLinkage )[ -OFFSETOF( CClassHashEntry, m_Linkage ) ] );
		}

		void	AddToList( CBilink &Linkage )
		{
			m_Linkage.InsertAfter( &Linkage );
		}

		void	RemoveFromList( void )
		{
			m_Linkage.RemoveFromList();
		}

		//
		// pool management functions
		//
		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::InitAlloc"
		static	BOOL	InitAlloc( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;


			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );

			pThisObject->m_pItem = NULL;
			pThisObject->m_Linkage.Initialize();
			return	TRUE;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::Init"
		static	void	Init( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );
			DNASSERT( pThisObject->m_pItem == NULL );
			DNASSERT( pThisObject->m_Linkage.IsEmpty() != FALSE );
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::Release"
		static	void	Release( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );
			pThisObject->m_pItem = NULL;
			DNASSERT( pThisObject->m_Linkage.IsEmpty() != FALSE );			
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CClassHashEntry::Dealloc"
		static	void	Dealloc( void *pItem )
		{
			CClassHashEntry<T,S>	*pThisObject;

			DNASSERT( pItem != NULL );
			pThisObject = static_cast<CClassHashEntry<T,S>*>( pItem );
			DNASSERT( pThisObject->m_pItem == NULL );
			DNASSERT( pThisObject->m_Linkage.IsEmpty() != FALSE );
		}

	protected:

	private:

	//
	// make copy constructor and assignment operator private and unimplemented
	// to prevent illegal copies from being made
	//
	CClassHashEntry( const CClassHashEntry & );
	CClassHashEntry& operator=( const CClassHashEntry & );
};


//
// template class for the map
//
template<class T, class S>
class	CClassHash
{
	STDNEWDELETE

	public:
		CClassHash();
		~CClassHash();

		BOOL	Initialize( const INT_PTR iBitDepth, const INT_PTR iGrowBits );
		void	Deinitialize( void );
		BOOL	Insert( const S Key, T *const pItem );
		void	Remove( const S Key );
		BOOL	RemoveLastEntry( T **const ppItem );
		BOOL	Find( const S Key, T **const ppItem );
		BOOL	IsEmpty( void ) { return ( m_iEntriesInUse == 0 ); }

		INT_PTR		m_iHashBitDepth;		// number of bits used for hash entry
		INT_PTR		m_iGrowBits;			// number of bits to grow has by
		CBilink		*m_pHashEntries;		// list of hash entries
		INT_PTR		m_iAllocatedEntries;	// count of allocated entries in index/item list
		INT_PTR		m_iEntriesInUse;		// count of entries in use
		FPOOL		m_EntryPool;			// pool of entries
	private:

		BOOL	m_fInitialized;

		BOOL	LocalFind( const S Key, CBilink **const ppLink );
		void	Grow( void );
		void	InitializeHashEntries( const UINT_PTR uEntryCount ) const;

		//
		// make copy constructor and assignment operator private and unimplemented
		// to prevent illegal copies from being made
		//
		CClassHash( const CClassHash & );
		CClassHash& operator=( const CClassHash & );
};

//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::CClassHash - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::CClassHash"

template<class T, class S>
CClassHash< T, S >::CClassHash(): m_iHashBitDepth( 0 ),m_iGrowBits( 0 ),
		m_pHashEntries( NULL ),m_iAllocatedEntries( 0 ),m_iEntriesInUse( 0 )
{
	//
	// clear internals
	//
	m_fInitialized = FALSE;
	memset( &m_EntryPool, 0x00, sizeof( m_EntryPool ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::~CClassHash - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::~CClassHash"

template<class T, class S>
CClassHash< T, S >::~CClassHash()
{
	DNASSERT( m_iHashBitDepth == 0 );
	DNASSERT( m_iGrowBits == 0 );
	DNASSERT( m_pHashEntries == NULL );
	DNASSERT( m_iAllocatedEntries == 0 );
	DNASSERT( m_iEntriesInUse == 0 );
	DNASSERT( m_fInitialized == FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Initialize - initialize hash table
//
// Entry:		Pointer to key
//				Pointer to 'key' associated with this item
//				Pointer to item to add
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Initialize"

template<class T, class S>
BOOL	CClassHash< T, S >::Initialize( const INT_PTR iBitDepth, const INT_PTR iGrowBits )
{
	BOOL		fReturn;


	DNASSERT( iBitDepth != 0 );

	//
	// initialize
	//
	fReturn = TRUE;

	DNASSERT( m_pHashEntries == NULL );
	m_pHashEntries = static_cast<CBilink*>( DNMalloc( sizeof( *m_pHashEntries ) * ( 1 << iBitDepth ) ) );
	if ( m_pHashEntries == NULL )
	{
		fReturn = FALSE;
		DPF( 0, "Unable to allocate memory for hash table!" );
		goto Exit;
	}
	m_iAllocatedEntries = 1 << iBitDepth;
	InitializeHashEntries( m_iAllocatedEntries );

	FPM_Initialize( &m_EntryPool,						// pointer to pool
						 sizeof( CClassHashEntry<T,S> ),	// size of pool entry
						 CClassHashEntry<T,S>::InitAlloc,	// function for allocating item
						 CClassHashEntry<T,S>::Init,		// function for getting item from pool
						 CClassHashEntry<T,S>::Release,		// function for releasing item
						 CClassHashEntry<T,S>::Dealloc		// function for deallocating item
						 );
	m_iHashBitDepth = iBitDepth;
	m_iGrowBits = iGrowBits;

	m_fInitialized = TRUE;

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Deinitialize - deinitialize hash table
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Deinitialize"

template<class T, class S>
void	CClassHash< T, S >::Deinitialize( void )
{
	if( !m_fInitialized )
		return;

	DNASSERT( m_iEntriesInUse == 0 );
	DNASSERT( m_pHashEntries != NULL );
	DNFree( m_pHashEntries );
	m_pHashEntries = NULL;
	FPM_Deinitialize( &m_EntryPool );
	m_fInitialized = FALSE;
	m_iHashBitDepth = 0;
	m_iGrowBits = 0;
	m_iAllocatedEntries = 0;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Insert - add item to map
//
// Entry:		Pointer to 'key' associated with this item
//				Pointer to item to add
//
// Exit:		Boolean indicating success:
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Insert"

template<class T, class S>
BOOL	CClassHash< T, S >::Insert( const S Key, T *const pItem )
{
	BOOL	fReturn;
	BOOL	fFound;
	CBilink	*pLink;
	CClassHashEntry< T, S >	*pNewEntry;


	DNASSERT( pItem != NULL );
	DNASSERT( m_fInitialized != FALSE );

	//
	// initialize
	//
 	fReturn = TRUE;
	pNewEntry = NULL;

	//
	// grow the map if applicable
	//
	if ( m_iEntriesInUse >= ( m_iAllocatedEntries / 2 ) )
	{
		Grow();
	}

	//
	// get a new table entry before trying the lookup
	//
	pNewEntry = static_cast<CClassHashEntry<T,S>*>( m_EntryPool.Get( &m_EntryPool ) );
	if ( pNewEntry == NULL )
	{
		fReturn = FALSE;
		DPF( 0, "Problem allocating new hash table entry on Insert!" );
		goto Exit;
	}

	//
	// scan for this item in the list, since we're only supposed to have
	// unique items in the list, ASSERT if a duplicate is found
	//
	fFound = LocalFind( Key, &pLink );
	DNASSERT( pLink != NULL );
	DNASSERT( fFound == FALSE );

	//
	// officially add entry to the hash table
	//
	m_iEntriesInUse++;
	pNewEntry->m_Key = Key;
	pNewEntry->m_pItem = pItem;
	DNASSERT( pLink != NULL );
	pNewEntry->AddToList( *pLink );

	DNASSERT( fReturn == TRUE );

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Remove - remove item from map
//
// Entry:		Reference to 'key' used to look up this item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Remove"

template<class T, class S>
void	CClassHash< T, S >::Remove( const S Key )
{
	CBilink	*pLink;


	DNASSERT( m_fInitialized != FALSE );
	if ( LocalFind( Key, &pLink ) != FALSE )
	{
		CClassHashEntry< T, S >	*pEntry;


		DNASSERT( pLink != NULL );
		pEntry = pEntry->EntryFromBilink( pLink );
		pEntry->RemoveFromList();
		m_EntryPool.Release( &m_EntryPool, pEntry );

		DNASSERT( m_iEntriesInUse != 0 );
		m_iEntriesInUse--;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::RemoveLastEntry - remove last item from map
//
// Entry:		Pointer to pointer to 'key'
//				Pointer to pointer to item data
//
// Exit:		Boolean indicating success
//				TRUE = item was removed
//				FALSE = item was not removed (map empty)
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::RemoveLastEntry"

template<class T, class S>
BOOL	CClassHash< T, S >::RemoveLastEntry( T **const ppItem )
{
	BOOL	fReturn;


	DNASSERT( ppItem != NULL );

	//
	// initialize
	//
	DNASSERT( m_fInitialized != FALSE );
	fReturn = FALSE;

	if ( m_iEntriesInUse != 0 )
	{
		INT_PTR	iIndex;


		DNASSERT( m_pHashEntries != NULL );
		iIndex = m_iAllocatedEntries;
		while ( iIndex > 0 )
		{
			iIndex--;

			if ( m_pHashEntries[ iIndex ].IsEmpty() == FALSE )
			{
				CClassHashEntry<T,S>	*pEntry;


				pEntry = pEntry->EntryFromBilink( m_pHashEntries[ iIndex ].GetNext() );
				pEntry->RemoveFromList();
				*ppItem = pEntry->m_pItem;
				m_EntryPool.Release( &m_EntryPool, pEntry );
				m_iEntriesInUse--;
				fReturn = TRUE;

				goto Exit;
			}
		}
	}

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Find - find item in map
//
// Entry:		Reference of 'key' used to look up this item
//				Pointer to pointer to be filled in with data
//
// Exit:		Boolean indicating success
//				TRUE = item found
//				FALSE = item not found
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Find"

template<class T, class S>
BOOL	CClassHash< T, S >::Find( const S Key, T **const ppItem )
{
	BOOL	fReturn;
	CBilink	*pLinkage;


	DNASSERT( m_fInitialized != FALSE );

	//
	// initialize
	//
	fReturn = FALSE;
	pLinkage = NULL;

	if ( LocalFind( Key, &pLinkage ) != FALSE )
	{
		CClassHashEntry<T,S>	*pEntry;


		pEntry = pEntry->EntryFromBilink( pLinkage );
		*ppItem = pEntry->m_pItem;
		fReturn = TRUE;
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::LocalFind - find an entry in a hash table, or find out where to insert.
//
// Entry:		Refernce of 'key' to look for
//				Pointer to pointer to linkage of find or insert
//
// Exit:		Boolean indicating whether the item was found
//				TRUE = found
//				FALSE = not found
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::LocalFind"

template<class T, class S>
BOOL	CClassHash< T, S >::LocalFind( const S Key, CBilink **const ppLinkage )
{
	BOOL		fFound;
	DWORD_PTR	HashResult;
	CBilink		*pTemp;


	DNASSERT( m_fInitialized != FALSE );

	HashResult = ClassHash_Hash( Key, m_iHashBitDepth );
	DNASSERT( HashResult < ( 1 << m_iHashBitDepth ) );
//	DNASSERT( HashResult >= 0 );	-- REMOVED by MiNara

	fFound = FALSE;
	pTemp = &m_pHashEntries[ HashResult ];
	while ( pTemp->GetNext() != &m_pHashEntries[ HashResult ] )
	{
		const CClassHashEntry< T, S >	*pEntry;


		pEntry = pEntry->EntryFromBilink( pTemp->GetNext() );
		if ( Key == pEntry->m_Key )
		{
			fFound = TRUE;
			*ppLinkage = pTemp->GetNext();
			goto Exit;
		}
		else
		{
			pTemp = pTemp->GetNext();
		}
	}

	//
	// entry was not found, return pointer to linkage to insert after if a new
	// entry is being added to the table
	//
	*ppLinkage = pTemp;

Exit:
	return	fFound;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::Grow - grow hash table to next larger size
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::Grow"

template<class T, class S>
void	CClassHash< T, S >::Grow( void )
{
	CBilink	*pTemp;
	INT_PTR	iNewEntryBitCount;


	DNASSERT( m_fInitialized != FALSE );

	//
	// We're more than 50% full, find a new has table size that will accomodate
	// all of the current entries, and keep a pointer to the old data
	// in case the memory allocation fails.
	//
	pTemp = m_pHashEntries;
	iNewEntryBitCount = m_iHashBitDepth;

	do
	{
		iNewEntryBitCount += m_iGrowBits;
	} while ( m_iEntriesInUse >= ( ( 1 << iNewEntryBitCount ) / 2 ) );

	//
	// assert that we don't suck up half of the machine's address space!
	//
	DNASSERT( iNewEntryBitCount <= ( sizeof( UINT_PTR ) * 8 / 2 ) );

	m_pHashEntries = static_cast<CBilink*>( DNMalloc( sizeof( *pTemp ) * ( 1 << iNewEntryBitCount ) ) );
	if ( m_pHashEntries == NULL )
	{
		//
		// Allocation failed, restore the old data pointer and insert the item
		// into the hash table.  This will probably result in adding to a bucket.
		//
		m_pHashEntries = pTemp;
		DPF( 0, "Warning: Failed to grow hash table when 50% full!" );
	}
	else
	{
		INT_PTR		iOldHashSize;
		INT_PTR		iOldEntryCount;


		//
		// we have more memory, reorient the hash table and re-add all of
		// the old items
		//
		InitializeHashEntries( 1 << iNewEntryBitCount );
		iOldEntryCount = m_iEntriesInUse;

		iOldHashSize = 1 << m_iHashBitDepth;
		m_iHashBitDepth = iNewEntryBitCount;

		iOldEntryCount = m_iEntriesInUse;
		m_iAllocatedEntries = 1 << iNewEntryBitCount;
		m_iEntriesInUse = 0;

		DNASSERT( iOldHashSize > 0 );
		while ( iOldHashSize > 0 )
		{
			iOldHashSize--;
			while ( pTemp[ iOldHashSize ].GetNext() != &pTemp[ iOldHashSize ] )
			{
				BOOL	fTempReturn;
				S	Key;
				T*		pItem;
				CClassHashEntry<T,S>	*pTempEntry;


				pTempEntry = pTempEntry->EntryFromBilink( pTemp[ iOldHashSize ].GetNext() );
				pTempEntry->RemoveFromList();
				Key = pTempEntry->m_Key;
				pItem = pTempEntry->m_pItem;
				m_EntryPool.Release( &m_EntryPool, pTempEntry );

				//
				// Since we're returning the current hash table entry to the pool
				// it will be immediately reused in the new table.  We should never
				// have a problem adding to the new list.
				//
				fTempReturn = Insert( Key, pItem );
				DNASSERT( fTempReturn != FALSE );
				iOldEntryCount--;
			}
		}

		DNASSERT( iOldEntryCount == 0 );
		DNFree( pTemp );
		pTemp = NULL;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CClassHash::InitializeHashEntries - initialize all of the entries in the hash table
//
// Entry:		Count of entries to initialize.
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CClassHash::InitializeHashEntries"

template<class T, class S>
void	CClassHash< T, S >::InitializeHashEntries( const UINT_PTR uEntryCount ) const
{
	UINT_PTR	uLocalEntryCount;


	DNASSERT( m_pHashEntries != NULL );
	uLocalEntryCount = uEntryCount;
	while ( uLocalEntryCount != 0 )
	{
		uLocalEntryCount--;

		m_pHashEntries[ uLocalEntryCount ].Initialize();
	}
}
//**********************************************************************

#endif	// __CLASS_HASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\contextcfpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ContextCFPM.h
 *  Content:	fixed pool manager for classes that takes into account contexts
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97	aarono	Original
 *	11-06-98	ejs		Add custom handler for Release function
 *	04-12-99	jtk		Trimmed unused functions and parameters, added size assert
 *	01-31-2000	jtk		Added code to check for items already being in the pool on Release().
 *	02-08-2000	jtk		Derived from ClassFPM.h
***************************************************************************/

#ifndef __CONTEXT_CLASS_FPM_H__
#define __CONTEXT_CLASS_FPM_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	CONTEXTCFPM_BLANK_NODE_VALUE	0x5AA5817E

#define	CHECK_FOR_DUPLICATE_CONTEXTCFPM_RELEASE

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

// class to act as a link in the pool
template< class T >
class	CContextClassFPMPoolNode
{
	STDNEWDELETE

	public:
		CContextClassFPMPoolNode() { m_pNext = NULL; }
		~CContextClassFPMPoolNode() {};

		CContextClassFPMPoolNode	*m_pNext;
		T		m_Item;

	protected:
	private:
};

// class to manage the pool
template< class T, class S >
class	CContextFixedPool
{
	STDNEWDELETE

	public:
		CContextFixedPool();
		~CContextFixedPool();


typedef BOOL (T::*PBOOLCALLBACK)( S *const pContext );
typedef	void (T::*PVOIDCONTEXTCALLBACK)( S *const pContext );
typedef void (T::*PVOIDCALLBACK)( void );

		BOOL	Initialize( PBOOLCALLBACK pAllocFunction, PVOIDCONTEXTCALLBACK pInitFunction, PVOIDCALLBACK pReleaseFunction, PVOIDCALLBACK pDeallocFunction );
		void	Deinitialize( void ) { DEBUG_ONLY( m_fInitialized = FALSE ); }

		T		*Get( S *const pContext );
		void	Release( T *const pItem );

	protected:

	private:
		PBOOLCALLBACK			m_pAllocFunction;
		PVOIDCONTEXTCALLBACK	m_pInitFunction;
		PVOIDCALLBACK			m_pReleaseFunction;
		PVOIDCALLBACK			m_pDeallocFunction;

		CContextClassFPMPoolNode< T >	*m_pPool;		// pointer to list of available elements
		DEBUG_ONLY( BOOL		m_fInitialized );
		DEBUG_ONLY( UINT_PTR	m_uOutstandingItemCount );
};

//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedPool::CContextFixedPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedPool::CContextFixedPool"

template< class T, class S >
CContextFixedPool< T, S >::CContextFixedPool():
	m_pAllocFunction( NULL ),
	m_pInitFunction( NULL ),
	m_pReleaseFunction( NULL ),
	m_pDeallocFunction( NULL ),
	m_pPool( NULL )
{
	DEBUG_ONLY( m_uOutstandingItemCount = 0 );
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedPool::~CContextFixedPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedPool::~CContextFixedPool"

template< class T, class S >
CContextFixedPool< T, S >::~CContextFixedPool()
{
	DEBUG_ONLY( DNASSERT( m_uOutstandingItemCount == 0 ) );
	while ( m_pPool != NULL )
	{
		CContextClassFPMPoolNode< T >	*pNode;
		T*	pItem;


		DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
		pNode = m_pPool;
		m_pPool = m_pPool->m_pNext;
		(pNode->m_Item.*this->m_pDeallocFunction)();
		delete	pNode;
	}

	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedPool::Initialize - initialize pool
//
// Entry:		Pointer to function to call when a new entry is allocated
//				Pointer to function to call when a new entry is removed from the pool
//				Pointer to function to call when an entry is returned to the pool
//				Pointer to function to call when an entry is deallocated
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedPool::Initialize"

template< class T, class S >
BOOL	CContextFixedPool< T, S >::Initialize( PBOOLCALLBACK pAllocFunction, PVOIDCONTEXTCALLBACK pInitFunction, PVOIDCALLBACK pReleaseFunction, PVOIDCALLBACK pDeallocFunction )
{
	BOOL	fReturn;


	DNASSERT( pAllocFunction != NULL );
	DNASSERT( pInitFunction != NULL );
	DNASSERT( pReleaseFunction != NULL );
	DNASSERT( pDeallocFunction != NULL );

	fReturn = TRUE;
	m_pAllocFunction = pAllocFunction;
	m_pInitFunction = pInitFunction;
	m_pReleaseFunction = pReleaseFunction;
	m_pDeallocFunction = pDeallocFunction;

	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
	DEBUG_ONLY( m_fInitialized = TRUE );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedPool::Get - get an item from the pool
//
// Entry:		Pointer to user context
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedPool::Get"

template< class T, class S >
T	*CContextFixedPool< T, S >::Get( S *const pContext )
{
	CContextClassFPMPoolNode< T >	*pNode;
	T	*pReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
	pReturn = NULL;

	//
	// if the pool is empty, try to allocate a new entry, otherwise grab
	// the first item from the pool
	//
	if ( m_pPool == NULL )
	{
		pNode = new CContextClassFPMPoolNode< T >;
		if ( pNode != NULL )
		{
			if ( (pNode->m_Item.*this->m_pAllocFunction)( pContext ) == FALSE )
			{
				delete pNode;
				pNode = NULL;
			}
		}
	}
	else
	{
		pNode = m_pPool;
		m_pPool = m_pPool->m_pNext;
	}

	//
	// if we have an entry (it was freshly created, or removed from the pool),
	// attempt to initialize it before passing it to the user
	//
	if ( pNode != NULL )
	{
		(pNode->m_Item.*this->m_pInitFunction)( pContext );

		pReturn = &pNode->m_Item;
		DEBUG_ONLY( pNode->m_pNext = (CContextClassFPMPoolNode<T>*) CONTEXTCFPM_BLANK_NODE_VALUE );
		DEBUG_ONLY( m_uOutstandingItemCount++ );
	}

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CContextFixedPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CContextFixedPool::Release"

template< class T, class S >
void	CContextFixedPool< T, S >::Release( T *const pItem )
{
	CContextClassFPMPoolNode< T >	*pNode;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );
	DBG_CASSERT( sizeof( CContextClassFPMPoolNode< T >* ) == sizeof( BYTE* ) );
	pNode = reinterpret_cast<CContextClassFPMPoolNode< T >*>( &reinterpret_cast<BYTE*>( pItem )[ -OFFSETOF( CContextClassFPMPoolNode< T >, m_Item ) ] );

#if defined(CHECK_FOR_DUPLICATE_CONTEXTCFPM_RELEASE) && defined(DEBUG)
	{
		CContextClassFPMPoolNode< T >	*pTemp;


		pTemp = m_pPool;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pNode );
			pTemp = pTemp->m_pNext;
		}
	}
#endif	// CHECK_FOR_DUPLICATE_CONTEXTCFPM_RELEASE

	DEBUG_ONLY( DNASSERT( pNode->m_pNext == (CContextClassFPMPoolNode< T >*)CONTEXTCFPM_BLANK_NODE_VALUE ) );
	(pNode->m_Item.*this->m_pReleaseFunction)();
	pNode->m_pNext = m_pPool;
	m_pPool = pNode;
	DEBUG_ONLY( m_uOutstandingItemCount-- );
}
//**********************************************************************

#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__

#undef DPF_SUBCOMP
#undef DPF_MODNAME

#endif	// __CONTEXT_CLASS_FPM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\dndbg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dndbg.c
 *  Content:	debug support for DirectPlay8
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  05-20-99	aarono	Created
 *  07-16-99	johnkan	Fixed include of OSInd.h, defined WSPRINTF macro
 *  07-19-99	vanceo	Explicitly declared OutStr as returning void for NT
 *						Build environment.
 *	07-22-99	a-evsch	Check for multiple Inits,  and release CritSec when DebugPrintf
 *						returns early.
 *	08-02-99	a-evsch	Added LOGPF support. LW entries only go into shared-file log
 *	08-31-99	johnkan	Removed include of <OSIND.H>
 *  02-17-00  	rodtoll	Added Memory / String validation routines
 *  05-23-00    RichGr  IA64: Changed some DWORDs to DWORD_PTRs to make va_arg work OK.
 *  07-16-00    jchauvin IA64:  Added %p parsing to change back to %x for Win9x machines in DebugPrintf, DebugPrintfNoLock, LogPrintf
 *  07-24-00    RichGr  IA64: As there's no separate build for Win9x, added code to detect Win9x for the %p parse-and-replace.
 *	07-29-00	masonb	Rewrite to add logging by subcomponent, perf improvements, process ID
 *	08/28/2000	masonb	Voice Merge: Modified asm in DebugPrintf to preserve registers that may have affected Voice
 *	
 *  Notes:
 *	
 *  Use /Oi compiler option for strlen()
 *
 ***************************************************************************/

#include "commoni.h"

#if defined(DEBUG)

// The constructor of this will be called prior to DllMain and the destructor
// after DllMain, so we can be assured of having the logging code properly
// initialized and deinitialized for the life of the module.
struct _InitDbg
{
	_InitDbg() { DebugPrintfInit(); }
	~_InitDbg() { DebugPrintfFini(); }
} DbgInited;

extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

//===============
// Debug  support
//===============

/*******************************************************************************
	This file contains support for the following types of logging:
		1. Logging to a VXD (Win9x only)
		2. Logging to a shared memory region
		3. Logging to the Debug Output
		4. FUTURE: Logging to a file

	General:
	========

	Debug Logging and playback is designed to operate on both Win9x and
	Windows NT (Windows 2000).  A shared file is used to capture information
	and can be played back using dp8log.exe.

	Under NT you can use the 'dt' command of NTSD to dump structures.  For
	example:

		dt DIRECTPLAYOBJECT <some memory address>

	will show all of the members of the DIRECTPLAYOBJECT structure at the
	specified address.  Some features are available only in post-Win2k
	versions of NTSD which can be obtained at http://dbg.

	Logging:
	========

	Debug Logging is controlled by settings in the WIN.INI file, under
	the section heading [DirectPlay8].  There are several settings:

	debug=9

	controls the default debug level.  All messages, at or below that debug level
	are printed.  You can control logging by each component specified in the
	g_rgszSubCompName member by adding its name to the end of the 'debug' setting:

	debug.addr=9

	sets the logging level for the addressing subcomponent to 9, leaving all
	others at either their specified level or the level specified by 'debug'
	if there is no specific level specified.

	The second setting controls where the log is seen.  If not specified, all
	debug logs are sent through the standard DebugPrint and will appear in a
	debugger if it is attached.

	log=0 {no debug output}
	log=1 {spew to console only}
	log=2 {spew to shared memory log only}
	log=3 {spew to console and shared memory log}

	This setting can also be divided by subcomponent, so:

	log=3
	log.protocol=2

	sends logs for the 'protocol' subcomponent to the shared memory log only, and
	all other logs to both locations.

	example win.ini...

	[DirectPlay8]
	Debug=7		; lots of spew
	log=2		; don't spew to debug window

	[DirectPlay8]
	Debug=0		; only fatal errors spewed to debug window

	Asserts:
	========
	Asserts are used to validate assumptions in the code.  For example
	if you know that the variable jojo should be > 700 and are depending
	on it in subsequent code, you SHOULD put an assert before the code
	that acts on that assumption.  The assert would look like:

	DNASSERT(jojo>700);

	Asserts generally will produce 3 lines of debug spew to highlight the
	breaking of the assumption.  You can add text to your asserts by ANDing:
	
	  DNASSERT(jojo>700 && "Jojo was too low");
	
	Will show the specified text when the assert occurs. For testing, you might
	want to set the system to break in on asserts.  This is done in the
	[DirectPlay8] section of WIN.INI by setting BreakOnAssert=TRUE:

	[DirectPlay8]
	Debug=0
	BreakOnAssert=TRUE
	Verbose=1

	The Verbose setting enables logging of file, function, and line information.

	Debug Breaks:
	=============
	When something really severe happens and you want the system to break in
	so that you can debug it later, you should put a debug break in the code
	path.  Some people use the philosophy that all code paths must be
	verified by hand tracing each one in the debugger.  If you abide by this
	you should place a DEBUG_BREAK() in every code path and remove them
	from the source as you trace each.  When you have good coverage but
	some unhit paths (error conditions) you should force those paths in
	the debugger.

	Debug Logging to Shared Memory Region:
	======================================

	All processes will share the same memory region, and will log the specified amount
	of activity.  The log can be viewed with the DPLOG.EXE utility.

	Debug Logging to Debug Output:
	==============================
	This option uses OutputDebugString to log the specified amount of activity.

==============================================================================*/

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DNSUBCOMP_COMMON


#define ASSERT_BUFFER_SIZE   8192
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_MESSAGE_LEVEL 0

#define WSPRINTF		wsprintfA
#define WVSPRINTF		wvsprintfA
#define PROF_SECT		"DirectPlay8"

//
// Globals for shared memory based logging
//

LPSTR g_rgszSubCompName[] =
{
	"UNK",		// DN_SUBCOMP_GLOBAL	0
	"CORE",		// DN_SUBCOMP_CORE		1
	"ADDR",		// DN_SUBCOMP_ADDR		2
	"LOBBY",	// DN_SUBCOMP_LOBBY		3
	"PROTOCOL", // DN_SUBCOMP_PROTOCOL	4
	"VOICE",	// DN_SUBCOMP_VOICE		5
	"DPNSVR",	// DN_SUBCOMP_DPNSVR	6
	"WSOCK",	// DN_SUBCOMP_WSOCK		7
	"MODEM",	// DN_SUBCOMP_MODEM		8
	"COMMON",	// DN_SUBCOMP_COMMON    9
	"MAX",		// DN_SUBCOMP_MAX		10 // NOTE: this should never get used, but
										  // is needed due to the way DebugPrintfInit
										  // is written, since it reads one past the end.
};

#define MAX_SUBCOMPS (sizeof(g_rgszSubCompName)/sizeof(g_rgszSubCompName[0]) - 1)
UINT g_rgLevel[MAX_SUBCOMPS] = {0};
UINT g_rgDestination[MAX_SUBCOMPS] = {1};

DWORD g_fBreakOnAssert = FALSE; // if TRUE, causes DEBUG_BREAK on false asserts.

// Informational variables set for DebugPrintf before actual call
// to do printing/logging.  These variables are locked by csDPF
// when set.  csDPF is dropped when the data is finally printed
// which means there must be a call to DebugSetLineInfo followed
// immediately by a call to DebugPrintf.  This is hidden by the
// DPF macro.
static CRITICAL_SECTION  csDPF;
static char g_szLineInfo [ ASSERT_BUFFER_SIZE ] = {0};
DWORD g_dwCurrentSubComp = DN_SUBCOMP_GLOBAL;

// DebugPrintfInit() - initialize DPF support.
void DebugPrintfInit()
{
	CHAR szLevel[32] = {0};
	strcpy(szLevel, "debug");

	CHAR szDest[32] = {0};
	strcpy(szDest, "log");

	// Loop through all the subcomps, and get the level and destination for each
	for (int iSubComp = 0; iSubComp < sizeof(g_rgszSubCompName)/sizeof(g_rgszSubCompName[0]) - 1; iSubComp++)
	{
		// Set up for the next subcomp
		strcpy(szLevel + 5, "."); // 5 is strlen of "debug", we are building debug.addr, etc.
		strcpy(szLevel + 6, g_rgszSubCompName[iSubComp + 1]);

		strcpy(szDest + 3, "."); // 3 is strlen of "log", we are building log.addr, etc.
		strcpy(szDest + 4, g_rgszSubCompName[iSubComp + 1]);
	}

    InitializeCriticalSection(&csDPF);
}

// DebugPrintfFini() - release resources used by DPF support.
void DebugPrintfFini()
{
	DeleteCriticalSection(&csDPF);
}


// DebugSetLineInfo - store information about where the DPF is from.
//
// Called before a call to DebugPrintf in order to specify the file
// line and function from which the DPF is being called.  This allows
// logging of these values.  In order to support this though, the
// values are stored in globals over the duration of the call, so a
// lock is acquired in this call and released in the DebugPrintf call.
// This means these functions MUST be called one after the other.

// On x86 we can avoid using the critsec by not adjusting the stack after this call,
// and then fixing it in DebugPrintf.  That way the values we need are locals.
void DebugSetLineInfo(LPCSTR szFile, DWORD dwLine, LPCSTR szModName, DWORD dwSubComp)
{
	// Validate the subcomp value.  If it is invalid, log everything under unknown
	if (dwSubComp >= MAX_SUBCOMPS)
	{
		dwSubComp = DN_SUBCOMP_GLOBAL;
	}

	EnterCriticalSection(&csDPF);
/*
	// Save some time if Verbose is OFF
	if (g_fLogFileAndLine)
	{
		LPCSTR c;

		int i = strlen(szFile);
		if (i < 25)
		{
			c = szFile;
		}
		else
		{
			c = szFile + i - 25;
		}

		WSPRINTF(g_szLineInfo,"(%s)%s(L%d)",c , szModName, dwLine);
	}
*/
	g_dwCurrentSubComp = dwSubComp;
}

// DebugPrintf - print a debug string
//
// You must call DebugSetLineInfo before making this call.
//
//#pragma warning(disable:4731)

void DebugPrintf(DWORD dwLevel, LPCSTR pszFormat, ...)
{
	CHAR                    szString[0x400];
	va_list                 va;
	DWORD dwCurrentSubComp;
	
	dwCurrentSubComp = g_dwCurrentSubComp;
	LeaveCriticalSection(&csDPF);

	if(g_rgLevel[dwCurrentSubComp] < dwLevel)
	{
		goto Exit;
	}

        va_start(va, pszFormat);
        vsprintf(szString, pszFormat, va);
        va_end(va);

        DebugPrint("%s:%1d:%04x:%s\n",g_rgszSubCompName[dwCurrentSubComp], dwLevel, GetCurrentThreadId(), szString);
                
Exit:
	return;
/*
	CHAR  cMsg[ ASSERT_BUFFER_SIZE ];
	CHAR  cTemp[ ASSERT_BUFFER_SIZE ];
	LPSTR szFormat;
    char  *psz = NULL;
	va_list argptr;
	LPSTR pszCursor = cMsg;
	DWORD dwCurrentSubComp;
	
	dwCurrentSubComp = g_dwCurrentSubComp;

	va_start(argptr, dwDetail);
	szFormat = (LPSTR) va_arg(argptr, DWORD_PTR);

	cMsg[0] = 0;

	// Prints out / logs as:
	// 1. Verbose
	// subcomp:dwDetail:ProcessId:ThreadId:File:Fn:Line:DebugString
	// e.g.
	// ADDR:2:0450:0378:(c:\somefile.cpp)BuildURLA(L25)Can you believe it?
	//
	// 2. Regular
	// subcomp:dwDetail:ProcessId:ThreadId:DebugString

	strcpy(pszCursor, g_rgszSubCompName[dwCurrentSubComp]);
	pszCursor += strlen(pszCursor);

	WSPRINTF(pszCursor,":%1d:",dwDetail);
	pszCursor += strlen(pszCursor);

	WSPRINTF(pszCursor,"%04x:",GetCurrentThreadId());
	pszCursor += strlen(pszCursor);

	WVSPRINTF(pszCursor, szFormat, argptr);
	pszCursor += strlen(pszCursor);

	strcpy(pszCursor, "\n");
	pszCursor += strlen(pszCursor);

		// log to debugger output
		OutputDebugStringA(cMsg);

	va_end(argptr);
*/
}

//
// NOTE: I don't want to get into error checking for buffer overflows when
// trying to issue an assertion failure message. So instead I just allocate
// a buffer that is "bug enough" (I know, I know...)
//

void _DNAssert( LPCSTR szFile, int nLine, LPCSTR szFnName, DWORD dwSubComp, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

	// Build the debug stream message
    WSPRINTF( buffer, "ASSERTION FAILED! File: %s Line: %d: %s", szFile, nLine, szCondition);

    // Actually issue the message. These messages are considered error level
    // so they all go out at error level priority.

	// Must call DebugSetLineInfo before calling DebugPrintf
	// This enters and leaves the CS 3 times, but it will only happen on an assert,
	// so perf hit should be minimal.  The previous solution was an identical function
	// to DebugPrintf that didn't keep locks.  That was a maintenance hassle keeping
	// the two identical.
	DebugSetLineInfo(szFile, nLine, szFnName, dwSubComp);
	DebugPrintf(ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
	DebugSetLineInfo(szFile, nLine, szFnName, dwSubComp);
	DebugPrintf(ASSERT_MESSAGE_LEVEL, buffer );
	DebugSetLineInfo(szFile, nLine, szFnName, dwSubComp);
	DebugPrintf(ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    // Should we drop into the debugger?
    if(g_fBreakOnAssert)
    {
		// Into the debugger we go...
		DEBUG_BREAK();
    }
}

#endif //defined debug

BOOL IsValidStringA( const CHAR * const szString )
{
	return (!IsBadStringPtrA( szString, 0xFFFFFFFF ) );
}

BOOL IsValidStringW( const WCHAR * const  swzString )
{
	const wchar_t *szTmpLoc = swzString;
	
	if( swzString == NULL )
	{
		return FALSE;
	}
	
	_try
	{
		for( ; *szTmpLoc ; szTmpLoc++ );
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\dneterrors.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNetErrors.h
 *  Content:    Function for expanding DNet errors to debug output
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   12/04/98  johnkan	Created
 *   08/28/2000	masonb	Voice Merge: Fix for code that only defines one of DEBUG, DBG, _DEBUG
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifndef	__DNET_ERRORS_H__
#define	__DNET_ERRORS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumerated values for determining output destination
//
typedef	enum
{
	DPNERR_OUT_CONSOLE,
	DPNERR_OUT_DEBUGGER
} DN_OUT_TYPE;

//
// enumerated values to determine error class
typedef	enum
{
	EC_DPLAY8,
	EC_INET,
	EC_TAPI,
	EC_WIN32,
	EC_WINSOCK

	// no entry for TAPI message output

} EC_TYPE;

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifdef	_DEBUG

	// where is the output going?
	#ifdef	DN_PRINTF
		#define	OUT_TYPE	DPNERR_OUT_CONSOLE
	#else
		#define	OUT_TYPE	DPNERR_OUT_DEBUGGER
	#endif

	// ErrorLevel = DPF level for outputting errors
	// DNErrpr = DirectNet error code

	#define	DisplayString( ErrorLevel, String )			LclDisplayString( OUT_TYPE, ErrorLevel, String )
	#define	DisplayErrorCode( ErrorLevel, Win32Error )	LclDisplayError( EC_WIN32, OUT_TYPE, ErrorLevel, Win32Error )
	#define	DisplayDNError( ErrorLevel, DNError )		LclDisplayError( EC_DPLAY8, OUT_TYPE, ErrorLevel, DNError )
	#define	DisplayInetError( ErrorLevel, InetError )	LclDisplayError( EC_INET, OUT_TYPE, ErrorLevel, InetError )
	#define	DisplayWinsockError( ErrorLevel, WinsockError )	LclDisplayError( EC_WINSOCK, OUT_TYPE, ErrorLevel, WinsockError )

#else	// _DEBUG

	#define	DisplayString( ErrorLevel, String )
	#define	DisplayErrorCode( ErrorLevel, Win32Error )
	#define	DisplayDNError( ErrorLevel, DNError )
	#define	DisplayInetError( ErrorLevel, InetError )
	#define	DisplayWinsockError( ErrorLevel, WinsockError )

#endif	// _DEBUG

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct linemessage_tag	LINEMESSAGE;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#ifdef	__cplusplus
extern	"C"	{
#endif	// __cplusplus

#ifdef	_DEBUG

// don't call this function directly, use the 'DisplayDNError' macro
void	LclDisplayError( EC_TYPE ErrorType, DN_OUT_TYPE OutputType, DWORD ErrorLevel, HRESULT ErrorCode );
void	LclDisplayString( DN_OUT_TYPE OutputType, DWORD ErrorLevel, char *pString );

#endif

#ifdef	__cplusplus
}
#endif	// __cplusplus

#endif	// __DNET_ERRORS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\dndbg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dndbg.h
 *  Content:	debug support functions for DirectNet
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  05-20-99	aarono	Created
 *	07-16-99	johnkan	Added DEBUG_ONLY, DBG_CASSERT, fixed DPFERR to take an argument
 *  02-17-00	rodtoll	Added Memory / String validation routines
 *  05-23-00	RichGr  IA64: Changed some DWORDs to DWORD_PTRs to make va_arg work OK.
 *  07-27-00	masonb	Rewrite to make sub-component stuff work, improve perf
 *  08/28/2000	masonb	Voice Merge: Part of header guard was missing (#define _DNDBG_H_)
 *
 ***************************************************************************/

#ifndef _DNDBG_H_
#define _DNDBG_H_

// Make sure all variations of DEBUG are defined if any one is
#ifdef DEBUG
#undef DBG
#undef _DEBUG
#define DBG 1
#define _DEBUG
#endif

#ifdef __cplusplus
	extern "C" {
#endif	

// DEBUG_BREAK()
#if defined(DEBUG)
		#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
#endif
//
// macros used generate compile time messages
//
// you need to use these with #pragma, example
//
//      #pragma TODO(ToddLa, "Fix this later!")
//

#ifndef DNETLOCALBUILD
#define TODO_OFF
#define BUGBUG_OFF	
#endif

// to turn this off, set cl = /DTODO_OFF in your environment variables
#define __TODO(e,m,n)   message(__FILE__ "(" #n ") : TODO: " #e ": " m)
#define _TODO(e,m,n)    __TODO(e,m,n)
#define __BUGBUG(e,m,n)   message(__FILE__ "(" #n ") : BUGBUG: " #e ": " m)
#define _BUGBUG(e,m,n)    __BUGBUG(e,m,n)

#ifdef TODO_OFF
#define TODO(e,m)
#else
#define TODO(e,m)		_TODO(e,m,__LINE__)
#endif

#ifdef BUGBUG_OFF
#define BUGBUG(e,m)
#else
#define BUGBUG(e,m)		_BUGBUG(e,m,__LINE__)
#endif

//========================
// Debug Logging support
//========================

/*=============================================================================
 Usage:

 In code, you can use DPF to print to the log or the debug windows of the
 running application.  The format of DPF (debug printf) is as follows:

	DPF(level, string *fmt, arg1, arg2, ...);

 level specifies how important this debug printf is.  The standard convention
 for debug levels is as follows.  This is no way strictly enforced for
 personal use, but by the time the code is checked in, it should be as close
 to this as possible...

  DPF_ERRORLEVEL:		Error useful for application developers.
  DPF_WARNINGLEVEL:		Warning useful for application developers.
  DPF_ENTRYLEVEL:		API Entered
  DPF_APIPARAM:			API parameters, API return values
  DPF_LOCKS:			Driver conversation
  DPF_INFOLEVEL:		Deeper program flow notifications
  DPF_STRUCTUREDUMP:	Dump structures
  DPF_TRACELEVEL:		Trace messages

 When printing a critical error, you can use:
	
	  DPERR( "String" );

 which will print a string at debug level zero.

 In order to cause the code to stop and break in.  You can use ASSERT() or
 DEBUG_BREAK().  In order for ASSERT to break in, you must have
 BreakOnAssert set in the win.ini file section (see osindep.cpp).

=============================================================================*/

#define DPF_ERRORLEVEL		0
#define DPF_WARNINGLEVEL	1
#define DPF_ENTRYLEVEL		2
#define DPF_APIPARAM		3
#define DPF_LOCKS			4
#define DPF_INFOLEVEL		5
#define DPF_STRUCTUREDUMP	6
#define DPF_TRACELEVEL		9

#ifdef ENABLE_DPLAY_VOICE
// For Voice
#define DVF_ERRORLEVEL		0
#define DVF_WARNINGLEVEL	1
#define DVF_ENTRYLEVEL		2
#define DVF_APIPARAM		3
#define DVF_LOCKS			4
#define DVF_INFOLEVEL		5
#define DVF_STRUCTUREDUMP	6
#define DVF_TRACELEVEL		9
#endif


#define DN_SUBCOMP_GLOBAL	0
#define DN_SUBCOMP_CORE		1
#define DN_SUBCOMP_ADDR		2
#define DN_SUBCOMP_LOBBY	3
#define DN_SUBCOMP_PROTOCOL	4
#define DN_SUBCOMP_VOICE	5
#define DN_SUBCOMP_DPNSVR	6
#define DN_SUBCOMP_WSOCK	7
#define DN_SUBCOMP_MODEM	8
#define DN_SUBCOMP_COMMON	9

// Default Values
// MASONB: Removing, everyone should now have this defined
/*
#if !defined (DPF_MODNAME)
#undef DPF_MODNAME
#define DPF_MODNAME "UNKNOWN_MODNAME"
#endif

#if !defined (DPF_SUBCOMP)
#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_GLOBAL
#endif
*/

#ifdef DEBUG

extern void __stdcall DebugSetLineInfo(LPCSTR szFile, DWORD dwLineNumber,LPCSTR szFnName, DWORD dwSubComp);
extern void DebugPrintf(DWORD_PTR dwDetail, LPCSTR pszFormat, ...);
extern void DebugPrintfInit(void);
extern void DebugPrintfFini(void);
extern void _DNAssert(LPCSTR szFile, int nLine, LPCSTR szFnName, DWORD dwSubComp, LPCSTR szCondition);

#ifndef DX_FINAL_RELEASE

#define DPF			DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME, DPF_SUBCOMP),DebugPrintf
#define DPFERR( a ) DebugSetLineInfo(__FILE__,__LINE__,DPF_MODNAME, DPF_SUBCOMP),DebugPrintf( DPF_ERRORLEVEL, a )
#define DNASSERT(condition) if (!(condition)) _DNAssert(__FILE__, __LINE__, DPF_MODNAME, DPF_SUBCOMP, #condition)

#else /* THE FINAL RELEASE - ELIMINATE FILE AND LINE INFO */

#define DPF DebugSetLineInfo("",0,DPF_MODNAME, DPF_SUBCOMP),DebugPrintf
#define DPFERR( a ) DebugSetLineInfo("",0,DPF_MODNAME, DPF_SUBCOMP),DebugPrintf( DPF_ERRORLEVEL, a )
#define DNASSERT(condition) if (!(condition)) _DNAssert("",0, DPF_MODNAME, DPF_SUBCOMP, #condition)

#endif 

#define DBG_CASSERT( exp )	switch (0) case 0: case exp:
#define DPFINIT()
#define DPFFINI()
#define	DEBUG_ONLY( arg )	arg
#define DPF_RETURN(a) DPF(DPF_APIPARAM,"Returning: 0x%lx",a);    return a;
#define LOGPF DPF
#define DPF_ENTER() DPF(DPF_TRACELEVEL, "Enter");
#define DPF_EXIT() DPF(DPF_TRACELEVEL, "Exit");


#else /* NOT DEBUG */

	#pragma warning(disable:4002)
	#define DPF()
	#define LOGPF()
    	#define DPF_RETURN(a)                 return a;	
	#define DPFERR()
	#define DPFINIT()
	#define DPFFINI()
	#define DNASSERT()
	#define	DEBUG_ONLY()
	#define	DBG_CASSERT()
	#define DPF_ENTER()
	#define DPF_EXIT()

#endif /* DEBUG */

extern BOOL IsValidStringW( const WCHAR * const szString );
extern BOOL IsValidStringA( const CHAR * const swzString );

#define DNVALID_STRING_A(a)		IsValidStringA(a)
#define DNVALID_STRING_W(a)		IsValidStringW(a)
#define DNVALID_WRITEPTR(a,b)	(!IsBadWritePtr(a,b))
#define DNVALID_READPTR(a,b)	(!IsBadReadPtr(a,b))

#ifdef __cplusplus
	}	//extern "C"
#endif

#endif /* _DNDBG_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\dneterrors.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNetErrors.cpp
 *  Content:    Function for expanding Play8 errors to debug output
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/04/98  johnkan	Created
 *	07/22/99	a-evsch	removed DPF_MODNAME.  This is defined in DbgInfo.h
 *	01/24/00	mjn		Added DPNERR_NOHOSTPLAYER error
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "commoni.h"

#if defined(_DEBUG) || defined(DEBUG) || defined(DBG)


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
static	char	*GetDNErrorString( const HRESULT DNError );
static	char	*GetTAPIErrorString( const HRESULT TAPIError );
static	char	*GetWIN32ErrorString( const LONG Error );
static	char	*GetWinsockErrorString( const DWORD WinsockError );

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// LclDisplayString - display user string
//
// Entry:		Pointer to string
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "LclDisplayString"

void	LclDisplayString( DN_OUT_TYPE OutputType, DWORD ErrorLevel, char *pString )
{
	// was there no error?
	if ( pString != NULL )
	{
		// how do we output?
		switch ( OutputType )
		{
			// output to debugger via DPF
			case DPNERR_OUT_DEBUGGER:
			{
				DPF( ErrorLevel, pString );
				break;
			}

			// unknown debug state
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// LclDisplayError - display error code
//
// Entry:		Error type
//				Output type
//				Error level
//				Error code
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "LclDisplayError"

void	LclDisplayError( EC_TYPE ErrorType, DN_OUT_TYPE OutputType, DWORD ErrorLevel, HRESULT ErrorCode )
{
	char	*pString;


	switch ( ErrorType )
	{
		// DirectNet error
		case EC_DPLAY8:
		{
			pString = GetDNErrorString( ErrorCode );
			break;
		}

		// internet error
		case EC_INET:
		{
			pString = "Unknown Internet Error";
			break;
		}

		// Win32
		case EC_WIN32:
		{
			pString = GetWIN32ErrorString( ErrorCode );
			break;
		}

		// TAPI
		case EC_TAPI:
		{
			break;
		}

		// winsock
		case EC_WINSOCK:
		{
			pString = GetWinsockErrorString( ErrorCode );
			break;
		}

		// unknown type
		default:
		{
			pString = "Unknown error type!";
			DNASSERT( FALSE );
			break;
		}
	}

	LclDisplayString( OutputType, ErrorLevel, pString );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetDNErrorString - convert DirectNet error to a string
//
// Entry:		Error code
//
// Exit:		Pointer to string
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetDNErrorString"

static	char	*GetDNErrorString( HRESULT ErrorCode )
{
	char *pString = NULL;


	// what was the error
	switch ( ErrorCode )
	{

		case DPN_OK:
		{
//			no output if no error
//			pString = "DN_OK";
			break;
		}

		case DPNERR_ABORTED:
		{
			pString = "DPNERR_ABORTED";
			break;
		}

		case DPNERR_ADDRESSING:
		{
			pString = "DPNERR_ADDRESSING";
			break;
		}

		case DPNERR_ALREADYCLOSING:
		{
			pString = "DPNERR_ALREADYCLOSING";
			break;
		}

		case DPNERR_ALREADYCONNECTED:
		{
			pString = "DPNERR_ALREADYCONNECTED";
			break;
		}

		case DPNERR_ALREADYDISCONNECTING:
		{
			pString = "DPNERR_ALREADYDISCONNECTING";
			break;
		}

		case DPNERR_ALREADYINITIALIZED:
		{
			pString = "DPNERR_ALREADYINITIALIZED";
			break;
		}

		case DPNERR_ALREADYREGISTERED:
		{
			pString = "DPNERR_ALREADYREGISTERED";
			break;
		}

		case DPNERR_BUFFERTOOSMALL:
		{
			pString = "DPNERR_BUFFERTOOSMALL";
			break;
		}

		case DPNERR_CANNOTCANCEL:
		{
			pString = "DPNERR_CANNOTCANCEL";
			break;
		}

		case DPNERR_CANTCREATEGROUP:
		{
			pString = "DPNERR_CANTCREATEGROUP";
			break;
		}

		case DPNERR_CANTCREATEPLAYER:
		{
			pString = "DPNERR_CANTCREATEPLAYER";
			break;
		}

		case DPNERR_CANTLAUNCHAPPLICATION:
		{
			pString = "DPNERR_CANTLAUNCHAPPLICATION";
			break;
		}

		case DPNERR_CONNECTING:
		{
			pString = "DPNERR_CONNECTING";
			break;
		}

		case DPNERR_CONNECTIONLOST:
		{
			pString = "DPNERR_CONNECTIONLOST";
			break;
		}

		case DPNERR_CONVERSION:
		{
			pString = "DPNERR_CONVERSION";
			break;
		}

		case DPNERR_DATATOOLARGE:
		{
			pString = "DPNERR_DATATOOLARGE";
			break;
		}

		case DPNERR_DOESNOTEXIST:
		{
			pString = "DPNERR_DOESNOTEXIST";
			break;
		}

		case DPNERR_DUPLICATECOMMAND:
		{
			pString = "DPNERR_DUPLICATECOMMAND";
			break;
		}

		case DPNERR_ENDPOINTNOTRECEIVING:
		{
			pString = "DPNERR_ENDPOINTNOTRECEIVING";
			break;
		}

		case DPNERR_ENUMQUERYTOOLARGE:
		{
			pString = "DPNERR_ENUMQUERYTOOLARGE";
			break;
		}

		case DPNERR_ENUMRESPONSETOOLARGE:
		{
			pString = "DPNERR_ENUMRESPONSETOOLARGE";
			break;
		}

		case DPNERR_EXCEPTION:
		{
			pString = "DPNERR_EXCEPTION";
			break;
		}

		case DPNERR_GENERIC:
		{
			pString = "DPNERR_GENERIC";
			break;
		}

		case DPNERR_GROUPNOTEMPTY:
		{
			pString = "DPNERR_GROUPNOTEMPTY";
			break;
		}

		case DPNERR_HOSTING:
		{
			pString = "DPNERR_HOSTING";
			break;
		}

		case DPNERR_HOSTREJECTEDCONNECTION:
		{
			pString = "DPNERR_HOSTREJECTEDCONNECTION";
			break;
		}

		case DPNERR_HOSTTERMINATEDSESSION:
		{
			pString = "DPNERR_HOSTTERMINATEDSESSION";
			break;
		}

		case DPNERR_INCOMPLETEADDRESS:
		{
			pString = "DPNERR_INCOMPLETEADDRESS";
			break;
		}

		case DPNERR_INVALIDADDRESSFORMAT:
		{
			pString = "DPNERR_INVALIDADDRESSFORMAT";
			break;
		}

		case DPNERR_INVALIDAPPLICATION:
		{
			pString = "DPNERR_INVALIDAPPLICATION";
			break;
		}

		case DPNERR_INVALIDCOMMAND:
		{
			pString = "DPNERR_INVALIDCOMMAND";
			break;
		}

		case DPNERR_INVALIDENDPOINT:
		{
			pString = "DPNERR_INVALIDENDPOINT";
			break;
		}

		case DPNERR_INVALIDFLAGS:
		{
			pString = "DPNERR_INVALIDFLAGS";
			break;
		}

		case DPNERR_INVALIDGROUP:
		{
			pString = "DPNERR_INVALIDGROUP";
			break;
		}

		case DPNERR_INVALIDHANDLE:
		{
			pString = "DPNERR_INVALIDHANDLE";
			break;
		}

		case DPNERR_INVALIDINSTANCE:
		{
			pString = "DPNERR_INVALIDINSTANCE";
			break;
		}

		case DPNERR_INVALIDINTERFACE:
		{
			pString = "DPNERR_INVALIDINTERFACE";
			break;
		}

		case DPNERR_INVALIDDEVICEADDRESS:
		{
			pString = "DPNERR_INVALIDDEVICEADDRESS";
			break;
		}

		case DPNERR_INVALIDOBJECT:
		{
			pString = "DPNERR_INVALIDOBJECT";
			break;
		}

		case DPNERR_INVALIDPARAM:
		{
			pString = "DPNERR_INVALIDPARAM";
			break;
		}

		case DPNERR_INVALIDPASSWORD:
		{
			pString = "DPNERR_INVALIDPASSWORD";
			break;
		}

		case DPNERR_INVALIDPLAYER:
		{
			pString = "DPNERR_INVALIDPLAYER";
			break;
		}

		case DPNERR_INVALIDPOINTER:
		{
			pString = "DPNERR_INVALIDPOINTER";
			break;
		}

		case DPNERR_INVALIDPRIORITY:
		{
			pString = "DPNERR_INVALIDPRIORITY";
			break;
		}

		case DPNERR_INVALIDHOSTADDRESS:
		{
			pString = "DPNERR_INVALIDHOSTADDRESS";
			break;
		}

		case DPNERR_INVALIDSTRING:
		{
			pString = "DPNERR_INVALIDSTRING";
			break;
		}

		case DPNERR_INVALIDURL:
		{
			pString = "DPNERR_INVALIDURL";
			break;
		}

		case DPNERR_INVALIDVERSION:
		{
			pString = "DPNERR_INVALIDVERSION";
			break;
		}

		case DPNERR_NOCAPS:
		{
			pString = "DPNERR_NOCAPS";
			break;
		}

		case DPNERR_NOCONNECTION:
		{
			pString = "DPNERR_NOCONNECTION";
			break;
		}

		case DPNERR_NOHOSTPLAYER:
		{
			pString = "DPNERR_NOHOSTPLAYER";
			break;
		}

		case DPNERR_NOINTERFACE:
		{
			pString = "DPNERR_NOINTERFACE";
			break;
		}

		case DPNERR_NOMOREADDRESSCOMPONENTS:
		{
			pString = "DPNERR_NOMOREADDRESSCOMPONENTS";
			break;
		}

		case DPNERR_NORESPONSE:
		{
			pString = "DPNERR_NORESPONSE";
			break;
		}

		case DPNERR_NOTALLOWED:
		{
			pString = "DPNERR_NOTALLOWED";
			break;
		}

		case DPNERR_NOTHOST:
		{
			pString = "DPNERR_NOTHOST";
			break;
		}

		case DPNERR_NOTREADY:
		{
			pString = "DPNERR_NOTREADY";
			break;
		}

		case DPNERR_NOTREGISTERED:
		{
			pString = "DPNERR_NOTREGISTERED";
			break;
		}

		case DPNERR_OUTOFMEMORY:
		{
			pString = "DPNERR_OUTOFMEMORY";
			break;
		}

		case DPNERR_PENDING:
		{
			pString = "DPNERR_PENDING";
			break;
		}

		case DPNERR_PLAYERLOST:
		{
			pString = "DPNERR_PLAYERLOST";
			break;
		}

		case DPNERR_PLAYERNOTREACHABLE:
		{
			pString = "DPNERR_PLAYERNOTREACHABLE";
			break;
		}

		case DPNERR_SENDTOOLARGE:
		{
			pString = "DPNERR_SENDTOOLARGE";
			break;
		}

		case DPNERR_SESSIONFULL:
		{
			pString = "DPNERR_SESSIONFULL";
			break;
		}

		case DPNERR_TABLEFULL:
		{
			pString = "DPNERR_TABLEFULL";
			break;
		}

		case DPNERR_TIMEDOUT:
		{
			pString = "DPNERR_TIMEDOUT";
			break;
		}

		case DPNERR_UNINITIALIZED:
		{
			pString = "DPNERR_UNINITIALIZED";
			break;
		}

		case DPNERR_UNSUPPORTED:
		{
			pString = "DPNERR_UNSUPPORTED";
			break;
		}

		case DPNERR_USERCANCEL:
		{
			pString = "DPNERR_USERCANCEL";
			break;
		}

		// unknown error code, possibly a new one?
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return	pString;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// GetWIN32ErrorString - convert system error to a string
//
// Entry:		Error code
//
// Exit:		Pointer to string
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetWIN32ErrorString"

static	char	*GetWIN32ErrorString( const LONG Error )
{
	char	*pString;

	switch ( Error )
	{
		case ERROR_SUCCESS:
		{
			// 0 The operation completed successfully.  ERROR_SUCCESS
			pString = "ERROR_SUCCESS";
			break;
		}

		case ERROR_INVALID_FUNCTION:
		{
			// 1 Incorrect function.  ERROR_INVALID_FUNCTION
			pString = "ERROR_INVALID_FUNCTION";
			break;
		}

		case ERROR_FILE_NOT_FOUND:
		{
			// 2 The system cannot find the file specified.  ERROR_FILE_NOT_FOUND
			pString = "ERROR_FILE_NOT_FOUND";
			break;
		}

		case ERROR_PATH_NOT_FOUND:
		{
			// 3 The system cannot find the path specified.  ERROR_PATH_NOT_FOUND
			pString = "ERROR_PATH_NOT_FOUND";
			break;
		}

		case ERROR_TOO_MANY_OPEN_FILES:
		{
			// 4 The system cannot open the file.  ERROR_TOO_MANY_OPEN_FILES
			pString = "ERROR_TOO_MANY_OPEN_FILES";
			break;
		}

		case ERROR_ACCESS_DENIED:
		{
			// 5 Access is denied.  ERROR_ACCESS_DENIED
			pString = "ERROR_ACCESS_DENIED";
			break;
		}

		case ERROR_INVALID_HANDLE:
		{
			// 6 The handle is invalid.  ERROR_INVALID_HANDLE
			pString = "ERROR_INVALID_HANDLE";
			break;
		}

		case ERROR_ARENA_TRASHED:
		{
			// 7 The storage control blocks were destroyed.  ERROR_ARENA_TRASHED
			pString = "ERROR_ARENA_TRASHED";
			break;
		}

		case ERROR_NOT_ENOUGH_MEMORY:
		{
			// 8 Not enough storage is available to process this command.  ERROR_NOT_ENOUGH_MEMORY
			pString = "ERROR_NOT_ENOUGH_MEMORY";
			break;
		}

		case ERROR_INVALID_BLOCK:
		{
			// 9 The storage control block address is invalid.  ERROR_INVALID_BLOCK
			pString = "ERROR_INVALID_BLOCK";
			break;
		}

		case ERROR_BAD_ENVIRONMENT:
		{
			// 10 The environment is incorrect.  ERROR_BAD_ENVIRONMENT
			pString = "ERROR_BAD_ENVIRONMENT";
			break;
		}

		case ERROR_BAD_FORMAT:
		{
			// 11 An attempt was made to load a program with an incorrect format.  ERROR_BAD_FORMAT
			pString = "ERROR_BAD_FORMAT";
			break;
		}

		case ERROR_INVALID_ACCESS:
		{
			// 12 The access code is invalid.  ERROR_INVALID_ACCESS
			pString = "ERROR_INVALID_ACCESS";
			break;
		}

		case ERROR_INVALID_DATA:
		{
			// 13 The data is invalid.  ERROR_INVALID_DATA
			pString = "ERROR_INVALID_DATA";
			break;
		}

		case ERROR_OUTOFMEMORY:
		{
			// 14 Not enough storage is available to complete this operation.  ERROR_OUTOFMEMORY
			pString = "ERROR_OUTOFMEMORY";
			break;
		}

		case ERROR_INVALID_DRIVE:
		{
			// 15 The system cannot find the drive specified.  ERROR_INVALID_DRIVE
			pString = "ERROR_INVALID_DRIVE";
			break;
		}

		case ERROR_CURRENT_DIRECTORY:
		{
			// 16 The directory cannot be removed.  ERROR_CURRENT_DIRECTORY
			pString = "ERROR_CURRENT_DIRECTORY";
			break;
		}

		case ERROR_NOT_SAME_DEVICE:
		{
			// 17 The system cannot move the file to a different disk drive.  ERROR_NOT_SAME_DEVICE
			pString = "ERROR_NOT_SAME_DEVICE";
			break;
		}

		case ERROR_NO_MORE_FILES:
		{
			// 18 There are no more files.  ERROR_NO_MORE_FILES
			pString = "ERROR_NO_MORE_FILES";
			break;
		}

		case ERROR_WRITE_PROTECT:
		{
			// 19 The media is write protected.  ERROR_WRITE_PROTECT
			pString = "ERROR_WRITE_PROTECT";
			break;
		}

		case ERROR_BAD_UNIT:
		{
			// 20 The system cannot find the device specified.  ERROR_BAD_UNIT
			pString = "ERROR_BAD_UNIT";
			break;
		}

		case ERROR_NOT_READY:
		{
			// 21 The device is not ready.  ERROR_NOT_READY
			pString = "ERROR_NOT_READY";
			break;
		}

		case ERROR_BAD_COMMAND:
		{
			// 22 The device does not recognize the command.  ERROR_BAD_COMMAND
			pString = "ERROR_BAD_COMMAND";
			break;
		}

		case ERROR_CRC:
		{
			// 23 Data error (cyclic redundancy check).  ERROR_CRC
			pString = "ERROR_CRC";
			break;
		}

		case ERROR_BAD_LENGTH:
		{
			// 24 The program issued a command but the command length is incorrect.  ERROR_BAD_LENGTH
			pString = "ERROR_BAD_LENGTH";
			break;
		}

		case ERROR_SEEK:
		{
			// 25 The drive cannot locate a specific area or track on the disk.  ERROR_SEEK
			pString = "ERROR_SEEK";
			break;
		}

		case ERROR_NOT_DOS_DISK:
		{
			// 26 The specified disk or diskette cannot be accessed.  ERROR_NOT_DOS_DISK
			pString = "ERROR_NOT_DOS_DISK";
			break;
		}

		case ERROR_SECTOR_NOT_FOUND:
		{
			// 27 The drive cannot find the sector requested.  ERROR_SECTOR_NOT_FOUND
			pString = "ERROR_SECTOR_NOT_FOUND";
			break;
		}

		case ERROR_OUT_OF_PAPER:
		{
			// 28 The printer is out of paper.  ERROR_OUT_OF_PAPER
			pString = "ERROR_OUT_OF_PAPER";
			break;
		}

		case ERROR_WRITE_FAULT:
		{
			// 29 The system cannot write to the specified device.  ERROR_WRITE_FAULT
			pString = "ERROR_WRITE_FAULT";
			break;
		}

		case ERROR_READ_FAULT:
		{
			// 30 The system cannot read from the specified device.  ERROR_READ_FAULT
			pString = "ERROR_READ_FAULT";
			break;
		}

		case ERROR_GEN_FAILURE:
		{
			// 31 A device attached to the system is not functioning.  ERROR_GEN_FAILURE
			pString = "ERROR_GEN_FAILURE";
			break;
		}

		case ERROR_SHARING_VIOLATION:
		{
			// 32 The process cannot access the file because it is being used by another process.  ERROR_SHARING_VIOLATION
			pString = "ERROR_SHARING_VIOLATION";
			break;
		}

		case ERROR_LOCK_VIOLATION:
		{
			// 33 The process cannot access the file because another process has locked a portion of the file.  ERROR_LOCK_VIOLATION
			pString = "ERROR_LOCK_VIOLATION";
			break;
		}

		case ERROR_WRONG_DISK:
		{
			// 34 The wrong diskette is in the drive. Insert %2 (Volume Serial Number: %3) into drive %1.  ERROR_WRONG_DISK
			pString = "ERROR_WRONG_DISK";
			break;
		}

		case ERROR_SHARING_BUFFER_EXCEEDED:
		{
			// 36 Too many files opened for sharing.  ERROR_SHARING_BUFFER_EXCEEDED
			pString = "ERROR_SHARING_BUFFER_EXCEEDED";
			break;
		}

		case ERROR_HANDLE_EOF:
		{
			// 38 Reached the end of the file.  ERROR_HANDLE_EOF
			pString = "ERROR_HANDLE_EOF";
			break;
		}

		case ERROR_HANDLE_DISK_FULL:
		{
			// 39 The disk is full.  ERROR_HANDLE_DISK_FULL
			pString = "ERROR_HANDLE_DISK_FULL";
			break;
		}

		case ERROR_NOT_SUPPORTED:
		{
			// 50 The network request is not supported.  ERROR_NOT_SUPPORTED
			pString = "ERROR_NOT_SUPPORTED";
			break;
		}

		case ERROR_REM_NOT_LIST:
		{
			// 51 The remote computer is not available.  ERROR_REM_NOT_LIST
			pString = "ERROR_REM_NOT_LIST";
			break;
		}

		case ERROR_DUP_NAME:
		{
			// 52 A duplicate name exists on the network.  ERROR_DUP_NAME
			pString = "ERROR_DUP_NAME";
			break;
		}

		case ERROR_BAD_NETPATH:
		{
			// 53 The network path was not found.  ERROR_BAD_NETPATH
			pString = "ERROR_BAD_NETPATH";
			break;
		}

		case ERROR_NETWORK_BUSY:
		{
			// 54 The network is busy.  ERROR_NETWORK_BUSY
			pString = "ERROR_NETWORK_BUSY";
			break;
		}

		case ERROR_DEV_NOT_EXIST:
		{
			// 55 The specified network resource or device is no longer available.  ERROR_DEV_NOT_EXIST
			pString = "ERROR_DEV_NOT_EXIST";
			break;
		}

		case ERROR_TOO_MANY_CMDS:
		{
			// 56 The network BIOS command limit has been reached.  ERROR_TOO_MANY_CMDS
			pString = "ERROR_TOO_MANY_CMDS";
			break;
		}

		case ERROR_ADAP_HDW_ERR:
		{
			// 57 A network adapter hardware error occurred.  ERROR_ADAP_HDW_ERR
			pString = "ERROR_ADAP_HDW_ERR";
			break;
		}

		case ERROR_BAD_NET_RESP:
		{
			// 58 The specified server cannot perform the requested operation.  ERROR_BAD_NET_RESP
			pString = "ERROR_BAD_NET_RESP";
			break;
		}

		case ERROR_UNEXP_NET_ERR:
		{
			// 59 An unexpected network error occurred.  ERROR_UNEXP_NET_ERR
			pString = "ERROR_UNEXP_NET_ERR";
			break;
		}

		case ERROR_BAD_REM_ADAP:
		{
			// 60 The remote adapter is not compatible.  ERROR_BAD_REM_ADAP
			pString = "ERROR_BAD_REM_ADAP";
			break;
		}

		case ERROR_PRINTQ_FULL:
		{
			// 61 The printer queue is full.  ERROR_PRINTQ_FULL
			pString = "ERROR_PRINTQ_FULL";
			break;
		}

		case ERROR_NO_SPOOL_SPACE:
		{
			// 62 Space to store the file waiting to be printed is not available on the server.  ERROR_NO_SPOOL_SPACE
			pString = "ERROR_NO_SPOOL_SPACE";
			break;
		}

		case ERROR_PRINT_CANCELLED:
		{
			// 63 Your file waiting to be printed was deleted.  ERROR_PRINT_CANCELLED
			pString = "ERROR_PRINT_CANCELLED";
			break;
		}

		case ERROR_NETNAME_DELETED:
		{
			// 64 The specified network name is no longer available.  ERROR_NETNAME_DELETED
			pString = "ERROR_NETNAME_DELETED";
			break;
		}

		case ERROR_NETWORK_ACCESS_DENIED:
		{
			// 65 Network access is denied.  ERROR_NETWORK_ACCESS_DENIED
			pString = "ERROR_NETWORK_ACCESS_DENIED";
			break;
		}

		case ERROR_BAD_DEV_TYPE:
		{
			// 66 The network resource type is not correct.  ERROR_BAD_DEV_TYPE
			pString = "ERROR_BAD_DEV_TYPE";
			break;
		}

		case ERROR_BAD_NET_NAME:
		{
			// 67 The network name cannot be found.  ERROR_BAD_NET_NAME
			pString = "ERROR_BAD_NET_NAME";
			break;
		}

		case ERROR_TOO_MANY_NAMES:
		{
			// 68 The name limit for the local computer network adapter card was exceeded.  ERROR_TOO_MANY_NAMES
			pString = "ERROR_TOO_MANY_NAMES";
			break;
		}

		case ERROR_TOO_MANY_SESS:
		{
			// 69 The network BIOS session limit was exceeded.  ERROR_TOO_MANY_SESS
			pString = "ERROR_TOO_MANY_SESS";
			break;
		}

		case ERROR_SHARING_PAUSED:
		{
			// 70 The remote server has been paused or is in the process of being started.  ERROR_SHARING_PAUSED
			pString = "ERROR_SHARING_PAUSED";
			break;
		}

		case ERROR_REQ_NOT_ACCEP:
		{
			// 71 No more connections can be made to this remote computer at this time because there are already as many connections as the computer can accept.  ERROR_REQ_NOT_ACCEP
			pString = "ERROR_REQ_NOT_ACCEP";
			break;
		}

		case ERROR_REDIR_PAUSED:
		{
			// 72 The specified printer or disk device has been paused.  ERROR_REDIR_PAUSED
			pString = "ERROR_REDIR_PAUSED";
			break;
		}

		case ERROR_FILE_EXISTS:
		{
			// 80 The file exists.  ERROR_FILE_EXISTS
			pString = "ERROR_FILE_EXISTS";
			break;
		}

		case ERROR_CANNOT_MAKE:
		{
			// 82 The directory or file cannot be created.  ERROR_CANNOT_MAKE
			pString = "ERROR_CANNOT_MAKE";
			break;
		}

		case ERROR_FAIL_I24:
		{
			// 83 Fail on INT 24.  ERROR_FAIL_I24
			pString = "ERROR_FAIL_I24";
			break;
		}

		case ERROR_OUT_OF_STRUCTURES:
		{
			// 84 Storage to process this request is not available.  ERROR_OUT_OF_STRUCTURES
			pString = "ERROR_OUT_OF_STRUCTURES";
			break;
		}

		case ERROR_ALREADY_ASSIGNED:
		{
			// 85 The local device name is already in use.  ERROR_ALREADY_ASSIGNED
			pString = "ERROR_ALREADY_ASSIGNED";
			break;
		}

		case ERROR_INVALID_PASSWORD:
		{
			// 86 The specified network password is not correct.  ERROR_INVALID_PASSWORD
			pString = "ERROR_INVALID_PASSWORD";
			break;
		}

		case ERROR_INVALID_PARAMETER:
		{
			// 87 The parameter is incorrect.  ERROR_INVALID_PARAMETER
			pString = "ERROR_INVALID_PARAMETER";
			break;
		}

		case ERROR_NET_WRITE_FAULT:
		{
			// 88 A write fault occurred on the network.  ERROR_NET_WRITE_FAULT
			pString = "ERROR_NET_WRITE_FAULT";
			break;
		}

		case ERROR_NO_PROC_SLOTS:
		{
			// 89 The system cannot start another process at this time.  ERROR_NO_PROC_SLOTS
			pString = "ERROR_NO_PROC_SLOTS";
			break;
		}

		case ERROR_TOO_MANY_SEMAPHORES:
		{
			// 100 Cannot create another system semaphore.  ERROR_TOO_MANY_SEMAPHORES
			pString = "ERROR_TOO_MANY_SEMAPHORES";
			break;
		}

		case ERROR_EXCL_SEM_ALREADY_OWNED:
		{
			// 101 The exclusive semaphore is owned by another process.  ERROR_EXCL_SEM_ALREADY_OWNED
			pString = "ERROR_EXCL_SEM_ALREADY_OWNED";
			break;
		}

		case ERROR_SEM_IS_SET:
		{
			// 102 The semaphore is set and cannot be closed.  ERROR_SEM_IS_SET
			pString = "ERROR_SEM_IS_SET";
			break;
		}

		case ERROR_TOO_MANY_SEM_REQUESTS:
		{
			// 103 The semaphore cannot be set again.  ERROR_TOO_MANY_SEM_REQUESTS
			pString = "ERROR_TOO_MANY_SEM_REQUESTS";
			break;
		}

		case ERROR_INVALID_AT_INTERRUPT_TIME:
		{
			// 104 Cannot request exclusive semaphores at interrupt time.  ERROR_INVALID_AT_INTERRUPT_TIME
			pString = "ERROR_INVALID_AT_INTERRUPT_TIME";
			break;
		}

		case ERROR_SEM_OWNER_DIED:
		{
			// 105 The previous ownership of this semaphore has ended.  ERROR_SEM_OWNER_DIED
			pString = "ERROR_SEM_OWNER_DIED";
			break;
		}

		case ERROR_SEM_USER_LIMIT:
		{
			// 106 Insert the diskette for drive %1.  ERROR_SEM_USER_LIMIT
			pString = "ERROR_SEM_USER_LIMIT";
			break;
		}

		case ERROR_DISK_CHANGE:
		{
			// 107 The program stopped because an alternate diskette was not inserted.  ERROR_DISK_CHANGE
			pString = "ERROR_DISK_CHANGE";
			break;
		}

		case ERROR_DRIVE_LOCKED:
		{
			// 108 The disk is in use or locked by another process.  ERROR_DRIVE_LOCKED
			pString = "ERROR_DRIVE_LOCKED";
			break;
		}

		case ERROR_BROKEN_PIPE:
		{
			// 109 The pipe has been ended.  ERROR_BROKEN_PIPE
			pString = "ERROR_BROKEN_PIPE";
			break;
		}

		case ERROR_OPEN_FAILED:
		{
			// 110 The system cannot open the device or file specified.  ERROR_OPEN_FAILED
			pString = "ERROR_OPEN_FAILED";
			break;
		}

		case ERROR_BUFFER_OVERFLOW:
		{
			// 111 The file name is too long.  ERROR_BUFFER_OVERFLOW
			pString = "ERROR_BUFFER_OVERFLOW";
			break;
		}

		case ERROR_DISK_FULL:
		{
			// 112 There is not enough space on the disk.  ERROR_DISK_FULL
			pString = "ERROR_DISK_FULL";
			break;
		}

		case ERROR_NO_MORE_SEARCH_HANDLES:
		{
			// 113 No more internal file identifiers available.  ERROR_NO_MORE_SEARCH_HANDLES
			pString = "ERROR_NO_MORE_SEARCH_HANDLES";
			break;
		}

		case ERROR_INVALID_TARGET_HANDLE:
		{
			// 114 The target internal file identifier is incorrect.  ERROR_INVALID_TARGET_HANDLE
			pString = "ERROR_INVALID_TARGET_HANDLE";
			break;
		}

		case ERROR_INVALID_CATEGORY:
		{
			// 117 The IOCTL call made by the application program is not correct.  ERROR_INVALID_CATEGORY
			pString = "ERROR_INVALID_CATEGORY";
			break;
		}

		case ERROR_INVALID_VERIFY_SWITCH:
		{
			// 118 The verify-on-write switch parameter value is not correct.  ERROR_INVALID_VERIFY_SWITCH
			pString = "ERROR_INVALID_VERIFY_SWITCH";
			break;
		}

		case ERROR_BAD_DRIVER_LEVEL:
		{
			// 119 The system does not support the command requested.  ERROR_BAD_DRIVER_LEVEL
			pString = "ERROR_BAD_DRIVER_LEVEL";
			break;
		}

		case ERROR_CALL_NOT_IMPLEMENTED:
		{
			// 120 This function is not supported on this system.  ERROR_CALL_NOT_IMPLEMENTED
			pString = "ERROR_CALL_NOT_IMPLEMENTED";
			break;
		}

		case ERROR_SEM_TIMEOUT:
		{
			// 121 The semaphore timeout period has expired.  ERROR_SEM_TIMEOUT
			pString = "ERROR_SEM_TIMEOUT";
			break;
		}

		case ERROR_INSUFFICIENT_BUFFER:
		{
			// 122 The data area passed to a system call is too small.  ERROR_INSUFFICIENT_BUFFER
			pString = "ERROR_INSUFFICIENT_BUFFER";
			break;
		}

		case ERROR_INVALID_NAME:
		{
			// 123 The filename, directory name, or volume label syntax is incorrect.  ERROR_INVALID_NAME
			pString = "ERROR_INVALID_NAME";
			break;
		}

		case ERROR_INVALID_LEVEL:
		{
			// 124 The system call level is not correct.  ERROR_INVALID_LEVEL
			pString = "ERROR_INVALID_LEVEL";
			break;
		}

		case ERROR_NO_VOLUME_LABEL:
		{
			// 125 The disk has no volume label.  ERROR_NO_VOLUME_LABEL
			pString = "ERROR_NO_VOLUME_LABEL";
			break;
		}

		case ERROR_MOD_NOT_FOUND:
		{
			// 126 The specified module could not be found.  ERROR_MOD_NOT_FOUND
			pString = "ERROR_MOD_NOT_FOUND";
			break;
		}

		case ERROR_PROC_NOT_FOUND:
		{
			// 127 The specified procedure could not be found.  ERROR_PROC_NOT_FOUND
			pString = "ERROR_PROC_NOT_FOUND";
			break;
		}

		case ERROR_WAIT_NO_CHILDREN:
		{
			// 128 There are no child processes to wait for.  ERROR_WAIT_NO_CHILDREN
			pString = "ERROR_WAIT_NO_CHILDREN";
			break;
		}

		case ERROR_CHILD_NOT_COMPLETE:
		{
			// 129 The %1 application cannot be run in Win32 mode.  ERROR_CHILD_NOT_COMPLETE
			pString = "ERROR_CHILD_NOT_COMPLETE";
			break;
		}

		case ERROR_DIRECT_ACCESS_HANDLE:
		{
			// 130 Attempt to use a file handle to an open disk partition for an operation other than raw disk I/O.  ERROR_DIRECT_ACCESS_HANDLE
			pString = "ERROR_DIRECT_ACCESS_HANDLE";
			break;
		}

		case ERROR_NEGATIVE_SEEK:
		{
			// 131 An attempt was made to move the file pointer before the beginning of the file.  ERROR_NEGATIVE_SEEK
			pString = "ERROR_NEGATIVE_SEEK";
			break;
		}

		case ERROR_SEEK_ON_DEVICE:
		{
			// 132 The file pointer cannot be set on the specified device or file.  ERROR_SEEK_ON_DEVICE
			pString = "ERROR_SEEK_ON_DEVICE";
			break;
		}

		case ERROR_IS_JOIN_TARGET:
		{
			// 133 A JOIN or SUBST command cannot be used for a drive that contains previously joined drives.  ERROR_IS_JOIN_TARGET
			pString = "ERROR_IS_JOIN_TARGET";
			break;
		}

		case ERROR_IS_JOINED:
		{
			// 134 An attempt was made to use a JOIN or SUBST command on a drive that has already been joined.  ERROR_IS_JOINED
			pString = "ERROR_IS_JOINED";
			break;
		}

		case ERROR_IS_SUBSTED:
		{
			// 135 An attempt was made to use a JOIN or SUBST command on a drive that has already been substituted.  ERROR_IS_SUBSTED
			pString = "ERROR_IS_SUBSTED";
			break;
		}

		case ERROR_NOT_JOINED:
		{
			// 136 The system tried to delete the JOIN of a drive that is not joined.  ERROR_NOT_JOINED
			pString = "ERROR_NOT_JOINED";
			break;
		}

		case ERROR_NOT_SUBSTED:
		{
			// 137 The system tried to delete the substitution of a drive that is not substituted.  ERROR_NOT_SUBSTED
			pString = "ERROR_NOT_SUBSTED";
			break;
		}

		case ERROR_JOIN_TO_JOIN:
		{
			// 138 The system tried to join a drive to a directory on a joined drive.  ERROR_JOIN_TO_JOIN
			pString = "ERROR_JOIN_TO_JOIN";
			break;
		}

		case ERROR_SUBST_TO_SUBST:
		{
			// 139 The system tried to substitute a drive to a directory on a substituted drive.  ERROR_SUBST_TO_SUBST
			pString = "ERROR_SUBST_TO_SUBST";
			break;
		}

		case ERROR_JOIN_TO_SUBST:
		{
			// 140 The system tried to join a drive to a directory on a substituted drive.  ERROR_JOIN_TO_SUBST
			pString = "ERROR_JOIN_TO_SUBST";
			break;
		}

		case ERROR_SUBST_TO_JOIN:
		{
			// 141 The system tried to SUBST a drive to a directory on a joined drive.  ERROR_SUBST_TO_JOIN
			pString = "ERROR_SUBST_TO_JOIN";
			break;
		}

		case ERROR_BUSY_DRIVE:
		{
			// 142 The system cannot perform a JOIN or SUBST at this time.  ERROR_BUSY_DRIVE
			pString = "ERROR_BUSY_DRIVE";
			break;
		}

		case ERROR_SAME_DRIVE:
		{
			// 143 The system cannot join or substitute a drive to or for a directory on the same drive.  ERROR_SAME_DRIVE
			pString = "ERROR_SAME_DRIVE";
			break;
		}

		case ERROR_DIR_NOT_ROOT:
		{
			// 144 The directory is not a subdirectory of the root directory.  ERROR_DIR_NOT_ROOT
			pString = "ERROR_DIR_NOT_ROOT";
			break;
		}

		case ERROR_DIR_NOT_EMPTY:
		{
			// 145 The directory is not empty.  ERROR_DIR_NOT_EMPTY
			pString = "ERROR_DIR_NOT_EMPTY";
			break;
		}

		case ERROR_IS_SUBST_PATH:
		{
			// 146 The path specified is being used in a substitute.  ERROR_IS_SUBST_PATH
			pString = "ERROR_IS_SUBST_PATH";
			break;
		}

		case ERROR_IS_JOIN_PATH:
		{
			// 147 Not enough resources are available to process this command.  ERROR_IS_JOIN_PATH
			pString = "ERROR_IS_JOIN_PATH";
			break;
		}

		case ERROR_PATH_BUSY:
		{
			// 148 The path specified cannot be used at this time.  ERROR_PATH_BUSY
			pString = "ERROR_PATH_BUSY";
			break;
		}

		case ERROR_IS_SUBST_TARGET:
		{
			// 149 An attempt was made to join or substitute a drive for which a directory on the drive is the target of a previous substitute.  ERROR_IS_SUBST_TARGET
			pString = "ERROR_IS_SUBST_TARGET";
			break;
		}

		case ERROR_SYSTEM_TRACE:
		{
			// 150 System trace information was not specified in your CONFIG.SYS file, or tracing is disallowed.  ERROR_SYSTEM_TRACE
			pString = "ERROR_SYSTEM_TRACE";
			break;
		}

		case ERROR_INVALID_EVENT_COUNT:
		{
			// 151 The number of specified semaphore events for DosMuxSemWait is not correct.  ERROR_INVALID_EVENT_COUNT
			pString = "ERROR_INVALID_EVENT_COUNT";
			break;
		}

		case ERROR_TOO_MANY_MUXWAITERS:
		{
			// 152 DosMuxSemWait did not execute; too many semaphores are already set.  ERROR_TOO_MANY_MUXWAITERS
			pString = "ERROR_TOO_MANY_MUXWAITERS";
			break;
		}

		case ERROR_INVALID_LIST_FORMAT:
		{
			// 153 The DosMuxSemWait list is not correct.  ERROR_INVALID_LIST_FORMAT
			pString = "ERROR_INVALID_LIST_FORMAT";
			break;
		}

		case ERROR_LABEL_TOO_LONG:
		{
			// 154 The volume label you entered exceeds the label character limit of the target file system.  ERROR_LABEL_TOO_LONG
			pString = "ERROR_LABEL_TOO_LONG";
			break;
		}

		case ERROR_TOO_MANY_TCBS:
		{
			// 155 Cannot create another thread.  ERROR_TOO_MANY_TCBS
			pString = "ERROR_TOO_MANY_TCBS";
			break;
		}

		case ERROR_SIGNAL_REFUSED:
		{
			// 156 The recipient process has refused the signal.  ERROR_SIGNAL_REFUSED
			pString = "ERROR_SIGNAL_REFUSED";
			break;
		}

		case ERROR_DISCARDED:
		{
			// 157 The segment is already discarded and cannot be locked.  ERROR_DISCARDED
			pString = "ERROR_DISCARDED";
			break;
		}

		case ERROR_NOT_LOCKED:
		{
			// 158 The segment is already unlocked.  ERROR_NOT_LOCKED
			pString = "ERROR_NOT_LOCKED";
			break;
		}

		case ERROR_BAD_THREADID_ADDR:
		{
			// 159 The address for the thread ID is not correct.  ERROR_BAD_THREADID_ADDR
			pString = "ERROR_BAD_THREADID_ADDR";
			break;
		}

		case ERROR_BAD_ARGUMENTS:
		{
			// 160 The argument string passed to DosExecPgm is not correct.  ERROR_BAD_ARGUMENTS
			pString = "ERROR_BAD_ARGUMENTS";
			break;
		}

		case ERROR_BAD_PATHNAME:
		{
			// 161 The specified path is invalid.  ERROR_BAD_PATHNAME
			pString = "ERROR_BAD_PATHNAME";
			break;
		}

		case ERROR_SIGNAL_PENDING:
		{
			// 162 A signal is already pending.  ERROR_SIGNAL_PENDING
			pString = "ERROR_SIGNAL_PENDING";
			break;
		}

		case ERROR_MAX_THRDS_REACHED:
		{
			// 164 No more threads can be created in the system.  ERROR_MAX_THRDS_REACHED
			pString = "ERROR_MAX_THRDS_REACHED";
			break;
		}

		case ERROR_LOCK_FAILED:
		{
			// 167 Unable to lock a region of a file.  ERROR_LOCK_FAILED
			pString = "ERROR_LOCK_FAILED";
			break;
		}

		case ERROR_BUSY:
		{
			// 170 The requested resource is in use.  ERROR_BUSY
			pString = "ERROR_BUSY";
			break;
		}

		case ERROR_CANCEL_VIOLATION:
		{
			// 173 A lock request was not outstanding for the supplied cancel region.  ERROR_CANCEL_VIOLATION
			pString = "ERROR_CANCEL_VIOLATION";
			break;
		}

		case ERROR_ATOMIC_LOCKS_NOT_SUPPORTED:
		{
			// 174 The file system does not support atomic changes to the lock type.  ERROR_ATOMIC_LOCKS_NOT_SUPPORTED
			pString = "ERROR_ATOMIC_LOCKS_NOT_SUPPORTED";
			break;
		}

		case ERROR_INVALID_SEGMENT_NUMBER:
		{
			// 180 The system detected a segment number that was not correct.  ERROR_INVALID_SEGMENT_NUMBER
			pString = "ERROR_INVALID_SEGMENT_NUMBER";
			break;
		}

		case ERROR_INVALID_ORDINAL:
		{
			// 182 The operating system cannot run %1.  ERROR_INVALID_ORDINAL
			pString = "ERROR_INVALID_ORDINAL";
			break;
		}

		case ERROR_ALREADY_EXISTS:
		{
			// 183 Cannot create a file when that file already exists.  ERROR_ALREADY_EXISTS
			pString = "ERROR_ALREADY_EXISTS";
			break;
		}

		case ERROR_INVALID_FLAG_NUMBER:
		{
			// 186 The flag passed is not correct.  ERROR_INVALID_FLAG_NUMBER
			pString = "ERROR_INVALID_FLAG_NUMBER";
			break;
		}

		case ERROR_SEM_NOT_FOUND:
		{
			// 187 The specified system semaphore name was not found.  ERROR_SEM_NOT_FOUND
			pString = "ERROR_SEM_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_STARTING_CODESEG:
		{
			// 188 The operating system cannot run %1.  ERROR_INVALID_STARTING_CODESEG
			pString = "ERROR_INVALID_STARTING_CODESEG";
			break;
		}

		case ERROR_INVALID_STACKSEG:
		{
			// 189 The operating system cannot run %1.  ERROR_INVALID_STACKSEG
			pString = "ERROR_INVALID_STACKSEG";
			break;
		}

		case ERROR_INVALID_MODULETYPE:
		{
			// 190 The operating system cannot run %1.  ERROR_INVALID_MODULETYPE
			pString = "ERROR_INVALID_MODULETYPE";
			break;
		}

		case ERROR_INVALID_EXE_SIGNATURE:
		{
			// 191 Cannot run %1 in Win32 mode.  ERROR_INVALID_EXE_SIGNATURE
			pString = "ERROR_INVALID_EXE_SIGNATURE";
			break;
		}

		case ERROR_EXE_MARKED_INVALID:
		{
			// 192 The operating system cannot run %1.  ERROR_EXE_MARKED_INVALID
			pString = "ERROR_EXE_MARKED_INVALID";
			break;
		}

		case ERROR_BAD_EXE_FORMAT:
		{
			// 193 is not a valid Win32 application.  ERROR_BAD_EXE_FORMAT
			pString = "ERROR_BAD_EXE_FORMAT";
			break;
		}

		case ERROR_ITERATED_DATA_EXCEEDS_64k:
		{
			// 194 The operating system cannot run %1.  ERROR_ITERATED_DATA_EXCEEDS_64k
			pString = "ERROR_ITERATED_DATA_EXCEEDS_64k";
			break;
		}

		case ERROR_INVALID_MINALLOCSIZE:
		{
			// 195 The operating system cannot run %1.  ERROR_INVALID_MINALLOCSIZE
			pString = "ERROR_INVALID_MINALLOCSIZE";
			break;
		}

		case ERROR_DYNLINK_FROM_INVALID_RING:
		{
			// 196 The operating system cannot run this application program.  ERROR_DYNLINK_FROM_INVALID_RING
			pString = "ERROR_DYNLINK_FROM_INVALID_RING";
			break;
		}

		case ERROR_IOPL_NOT_ENABLED:
		{
			// 197 The operating system is not presently configured to run this application.  ERROR_IOPL_NOT_ENABLED
			pString = "ERROR_IOPL_NOT_ENABLED";
			break;
		}

		case ERROR_INVALID_SEGDPL:
		{
			// 198 The operating system cannot run %1.  ERROR_INVALID_SEGDPL
			pString = "ERROR_INVALID_SEGDPL";
			break;
		}

		case ERROR_AUTODATASEG_EXCEEDS_64k:
		{
			// 199 The operating system cannot run this application program.  ERROR_AUTODATASEG_EXCEEDS_64k
			pString = "ERROR_AUTODATASEG_EXCEEDS_64k";
			break;
		}

		case ERROR_RING2SEG_MUST_BE_MOVABLE:
		{
			// 200 The code segment cannot be greater than or equal to 64K.  ERROR_RING2SEG_MUST_BE_MOVABLE
			pString = "ERROR_RING2SEG_MUST_BE_MOVABLE";
			break;
		}

		case ERROR_RELOC_CHAIN_XEEDS_SEGLIM:
		{
			// 201 The operating system cannot run %1.  ERROR_RELOC_CHAIN_XEEDS_SEGLIM
			pString = "ERROR_RELOC_CHAIN_XEEDS_SEGLIM";
			break;
		}

		case ERROR_INFLOOP_IN_RELOC_CHAIN:
		{
			// 202 The operating system cannot run %1.  ERROR_INFLOOP_IN_RELOC_CHAIN
			pString = "ERROR_INFLOOP_IN_RELOC_CHAIN";
			break;
		}

		case ERROR_ENVVAR_NOT_FOUND:
		{
			// 203 The system could not find the environment option that was entered.  ERROR_ENVVAR_NOT_FOUND
			pString = "ERROR_ENVVAR_NOT_FOUND";
			break;
		}

		case ERROR_NO_SIGNAL_SENT:
		{
			// 205 No process in the command subtree has a signal handler.  ERROR_NO_SIGNAL_SENT
			pString = "ERROR_NO_SIGNAL_SENT";
			break;
		}

		case ERROR_FILENAME_EXCED_RANGE:
		{
			// 206 The filename or extension is too long.  ERROR_FILENAME_EXCED_RANGE
			pString = "ERROR_FILENAME_EXCED_RANGE";
			break;
		}

		case ERROR_RING2_STACK_IN_USE:
		{
			// 207 The ring 2 stack is in use.  ERROR_RING2_STACK_IN_USE
			pString = "ERROR_RING2_STACK_IN_USE";
			break;
		}

		case ERROR_META_EXPANSION_TOO_LONG:
		{
			// 208 The global filename characters, * or ?, are entered incorrectly or too many global filename characters are specified.  ERROR_META_EXPANSION_TOO_LONG
			pString = "ERROR_META_EXPANSION_TOO_LONG";
			break;
		}

		case ERROR_INVALID_SIGNAL_NUMBER:
		{
			// 209 The signal being posted is not correct.  ERROR_INVALID_SIGNAL_NUMBER
			pString = "ERROR_INVALID_SIGNAL_NUMBER";
			break;
		}

		case ERROR_THREAD_1_INACTIVE:
		{
			// 210 The signal handler cannot be set.  ERROR_THREAD_1_INACTIVE
			pString = "ERROR_THREAD_1_INACTIVE";
			break;
		}

		case ERROR_LOCKED:
		{
			// 212 The segment is locked and cannot be reallocated.  ERROR_LOCKED
			pString = "ERROR_LOCKED";
			break;
		}

		case ERROR_TOO_MANY_MODULES:
		{
			// 214 Too many dynamic-link modules are attached to this program or dynamic-link module.  ERROR_TOO_MANY_MODULES
			pString = "ERROR_TOO_MANY_MODULES";
			break;
		}

		case ERROR_NESTING_NOT_ALLOWED:
		{
			// 215 Can't nest calls to LoadModule.  ERROR_NESTING_NOT_ALLOWED
			pString = "ERROR_NESTING_NOT_ALLOWED";
			break;
		}

		case ERROR_EXE_MACHINE_TYPE_MISMATCH:
		{
			// 216 The image file %1 is valid, but is for a machine type other than the current machine.  ERROR_EXE_MACHINE_TYPE_MISMATCH
			pString = "ERROR_EXE_MACHINE_TYPE_MISMATCH";
			break;
		}

		case ERROR_BAD_PIPE:
		{
			// 230 The pipe state is invalid.  ERROR_BAD_PIPE
			pString = "ERROR_BAD_PIPE";
			break;
		}

		case ERROR_PIPE_BUSY:
		{
			// 231 All pipe instances are busy.  ERROR_PIPE_BUSY
			pString = "ERROR_PIPE_BUSY";
			break;
		}

		case ERROR_NO_DATA:
		{
			// 232 The pipe is being closed.  ERROR_NO_DATA
			pString = "ERROR_NO_DATA";
			break;
		}

		case ERROR_PIPE_NOT_CONNECTED:
		{
			// 233 No process is on the other end of the pipe.  ERROR_PIPE_NOT_CONNECTED
			pString = "ERROR_PIPE_NOT_CONNECTED";
			break;
		}

		case ERROR_MORE_DATA:
		{
			// 234 More data is available.  ERROR_MORE_DATA
			pString = "ERROR_MORE_DATA";
			break;
		}

		case ERROR_VC_DISCONNECTED:
		{
			// 240 The session was canceled.  ERROR_VC_DISCONNECTED
			pString = "ERROR_VC_DISCONNECTED";
			break;
		}

		case ERROR_INVALID_EA_NAME:
		{
			// 254 The specified extended attribute name was invalid.  ERROR_INVALID_EA_NAME
			pString = "ERROR_INVALID_EA_NAME";
			break;
		}

		case ERROR_EA_LIST_INCONSISTENT:
		{
			// 255 The extended attributes are inconsistent.  ERROR_EA_LIST_INCONSISTENT
			pString = "ERROR_EA_LIST_INCONSISTENT";
			break;
		}

		case ERROR_NO_MORE_ITEMS:
		{
			// 259 No more data is available.  ERROR_NO_MORE_ITEMS
			pString = "ERROR_NO_MORE_ITEMS";
			break;
		}

		case ERROR_CANNOT_COPY:
		{
			// 266 The copy functions cannot be used.  ERROR_CANNOT_COPY
			pString = "ERROR_CANNOT_COPY";
			break;
		}

		case ERROR_DIRECTORY:
		{
			// 267 The directory name is invalid.  ERROR_DIRECTORY
			pString = "ERROR_DIRECTORY";
			break;
		}

		case ERROR_EAS_DIDNT_FIT:
		{
			// 275 The extended attributes did not fit in the buffer.  ERROR_EAS_DIDNT_FIT
			pString = "ERROR_EAS_DIDNT_FIT";
			break;
		}

		case ERROR_EA_FILE_CORRUPT:
		{
			// 276 The extended attribute file on the mounted file system is corrupt.  ERROR_EA_FILE_CORRUPT
			pString = "ERROR_EA_FILE_CORRUPT";
			break;
		}

		case ERROR_EA_TABLE_FULL:
		{
			// 277 The extended attribute table file is full.  ERROR_EA_TABLE_FULL
			pString = "ERROR_EA_TABLE_FULL";
			break;
		}

		case ERROR_INVALID_EA_HANDLE:
		{
			// 278 The specified extended attribute handle is invalid.  ERROR_INVALID_EA_HANDLE
			pString = "ERROR_INVALID_EA_HANDLE";
			break;
		}

		case ERROR_EAS_NOT_SUPPORTED:
		{
			// 282 The mounted file system does not support extended attributes.  ERROR_EAS_NOT_SUPPORTED
			pString = "ERROR_EAS_NOT_SUPPORTED";
			break;
		}

		case ERROR_NOT_OWNER:
		{
			// 288 Attempt to release mutex not owned by caller.  ERROR_NOT_OWNER
			pString = "ERROR_NOT_OWNER";
			break;
		}

		case ERROR_TOO_MANY_POSTS:
		{
			// 298 Too many posts were made to a semaphore.  ERROR_TOO_MANY_POSTS
			pString = "ERROR_TOO_MANY_POSTS";
			break;
		}

		case ERROR_PARTIAL_COPY:
		{
			// 299 Only part of a ReadProcessMemoty or WriteProcessMemory request was completed.  ERROR_PARTIAL_COPY
			pString = "ERROR_PARTIAL_COPY";
			break;
		}

		case ERROR_OPLOCK_NOT_GRANTED:
		{
			// 300 The oplock request is denied.  ERROR_OPLOCK_NOT_GRANTED
			pString = "ERROR_OPLOCK_NOT_GRANTED";
			break;
		}

		case ERROR_INVALID_OPLOCK_PROTOCOL:
		{
			// 301 An invalid oplock acknowledgment was received by the system.  ERROR_INVALID_OPLOCK_PROTOCOL
			pString = "ERROR_INVALID_OPLOCK_PROTOCOL";
			break;
		}

		case ERROR_MR_MID_NOT_FOUND:
		{
			// 317 The system cannot find message text for message number 0x%1 in the message file for %2.  ERROR_MR_MID_NOT_FOUND
			pString = "ERROR_MR_MID_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_ADDRESS:
		{
			// 487 Attempt to access invalid address.  ERROR_INVALID_ADDRESS
			pString = "ERROR_INVALID_ADDRESS";
			break;
		}

		case ERROR_ARITHMETIC_OVERFLOW:
		{
			// 534 Arithmetic result exceeded 32 bits.  ERROR_ARITHMETIC_OVERFLOW
			pString = "ERROR_ARITHMETIC_OVERFLOW";
			break;
		}

		case ERROR_PIPE_CONNECTED:
		{
			// 535 There is a process on other end of the pipe.  ERROR_PIPE_CONNECTED
			pString = "ERROR_PIPE_CONNECTED";
			break;
		}

		case ERROR_PIPE_LISTENING:
		{
			// 536 Waiting for a process to open the other end of the pipe.  ERROR_PIPE_LISTENING
			pString = "ERROR_PIPE_LISTENING";
			break;
		}

		case ERROR_EA_ACCESS_DENIED:
		{
			// 994 Access to the extended attribute was denied.  ERROR_EA_ACCESS_DENIED
			pString = "ERROR_EA_ACCESS_DENIED";
			break;
		}

		case ERROR_OPERATION_ABORTED:
		{
			// 995 The I/O operation has been aborted because of either a thread exit or an application request.  ERROR_OPERATION_ABORTED
			pString = "ERROR_OPERATION_ABORTED";
			break;
		}

		case ERROR_IO_INCOMPLETE:
		{
			// 996 Overlapped I/O event is not in a signaled state.  ERROR_IO_INCOMPLETE
			pString = "ERROR_IO_INCOMPLETE";
			break;
		}

		case ERROR_IO_PENDING:
		{
			// 997 Overlapped I/O operation is in progress.  ERROR_IO_PENDING
			pString = "ERROR_IO_PENDING";
			break;
		}

		case ERROR_NOACCESS:
		{
			// 998 Invalid access to memory location.  ERROR_NOACCESS
			pString = "ERROR_NOACCESS";
			break;
		}

		case ERROR_SWAPERROR:
		{
			// 999 Error performing inpage operation.  ERROR_SWAPERROR
			pString = "ERROR_SWAPERROR";
			break;
		}

		case ERROR_STACK_OVERFLOW:
		{
			// 1001 Recursion too deep; the stack overflowed.  ERROR_STACK_OVERFLOW
			pString = "ERROR_STACK_OVERFLOW";
			break;
		}

		case ERROR_INVALID_MESSAGE:
		{
			// 1002 The window cannot act on the sent message.  ERROR_INVALID_MESSAGE
			pString = "ERROR_INVALID_MESSAGE";
			break;
		}

		case ERROR_CAN_NOT_COMPLETE:
		{
			// 1003 Cannot complete this function.  ERROR_CAN_NOT_COMPLETE
			pString = "ERROR_CAN_NOT_COMPLETE";
			break;
		}

		case ERROR_INVALID_FLAGS:
		{
			// 1004 Invalid flags.  ERROR_INVALID_FLAGS
			pString = "ERROR_INVALID_FLAGS";
			break;
		}

		case ERROR_UNRECOGNIZED_VOLUME:
		{
			// 1005 The volume does not contain a recognized file system. Please make sure that all required file system drivers are loaded and that the volume is not corrupted.  ERROR_UNRECOGNIZED_VOLUME
			pString = "ERROR_UNRECOGNIZED_VOLUME";
			break;
		}

		case ERROR_FILE_INVALID:
		{
			// 1006 The volume for a file has been externally altered so that the opened file is no longer valid.  ERROR_FILE_INVALID
			pString = "ERROR_FILE_INVALID";
			break;
		}

		case ERROR_FULLSCREEN_MODE:
		{
			// 1007 The requested operation cannot be performed in full-screen mode.  ERROR_FULLSCREEN_MODE
			pString = "ERROR_FULLSCREEN_MODE";
			break;
		}

		case ERROR_NO_TOKEN:
		{
			// 1008 An attempt was made to reference a token that does not exist.  ERROR_NO_TOKEN
			pString = "ERROR_NO_TOKEN";
			break;
		}

		case ERROR_BADDB:
		{
			// 1009 The configuration registry database is corrupt.  ERROR_BADDB
			pString = "ERROR_BADDB";
			break;
		}

		case ERROR_BADKEY:
		{
			// 1010 The configuration registry key is invalid.  ERROR_BADKEY
			pString = "ERROR_BADKEY";
			break;
		}

		case ERROR_CANTOPEN:
		{
			// 1011 The configuration registry key could not be opened.  ERROR_CANTOPEN
			pString = "ERROR_CANTOPEN";
			break;
		}

		case ERROR_CANTREAD:
		{
			// 1012 The configuration registry key could not be read.  ERROR_CANTREAD
			pString = "ERROR_CANTREAD";
			break;
		}

		case ERROR_CANTWRITE:
		{
			// 1013 The configuration registry key could not be written.  ERROR_CANTWRITE
			pString = "ERROR_CANTWRITE";
			break;
		}

		case ERROR_REGISTRY_RECOVERED:
		{
			// 1014 One of the files in the registry database had to be recovered by use of a log or alternate copy. The recovery was successful.  ERROR_REGISTRY_RECOVERED
			pString = "ERROR_REGISTRY_RECOVERED";
			break;
		}

		case ERROR_REGISTRY_CORRUPT:
		{
			// 1015 The registry is corrupted. The structure of one of the files that contains registry data is corrupted, or the system's image of the file in memory is corrupted, or the file could not be recovered because the alternate copy or log was absent or corrupted.  ERROR_REGISTRY_CORRUPT
			pString = "ERROR_REGISTRY_CORRUPT";
			break;
		}

		case ERROR_REGISTRY_IO_FAILED:
		{
			// 1016 An I/O operation initiated by the registry failed unrecoverably. The registry could not read in, or write out, or flush, one of the files that contain the system's image of the registry.  ERROR_REGISTRY_IO_FAILED
			pString = "ERROR_REGISTRY_IO_FAILED";
			break;
		}

		case ERROR_NOT_REGISTRY_FILE:
		{
			// 1017 The system has attempted to load or restore a file into the registry, but the specified file is not in a registry file format.  ERROR_NOT_REGISTRY_FILE
			pString = "ERROR_NOT_REGISTRY_FILE";
			break;
		}

		case ERROR_KEY_DELETED:
		{
			// 1018 Illegal operation attempted on a registry key that has been marked for deletion.  ERROR_KEY_DELETED
			pString = "ERROR_KEY_DELETED";
			break;
		}

		case ERROR_NO_LOG_SPACE:
		{
			// 1019 System could not allocate the required space in a registry log.  ERROR_NO_LOG_SPACE
			pString = "ERROR_NO_LOG_SPACE";
			break;
		}

		case ERROR_KEY_HAS_CHILDREN:
		{
			// 1020 Cannot create a symbolic link in a registry key that already has subkeys or values.  ERROR_KEY_HAS_CHILDREN
			pString = "ERROR_KEY_HAS_CHILDREN";
			break;
		}

		case ERROR_CHILD_MUST_BE_VOLATILE:
		{
			// 1021 Cannot create a stable subkey under a volatile parent key.  ERROR_CHILD_MUST_BE_VOLATILE
			pString = "ERROR_CHILD_MUST_BE_VOLATILE";
			break;
		}

		case ERROR_NOTIFY_ENUM_DIR:
		{
			// 1022 A notify change request is being completed and the information is not being returned in the caller's buffer. The caller now needs to enumerate the files to find the changes.  ERROR_NOTIFY_ENUM_DIR
			pString = "ERROR_NOTIFY_ENUM_DIR";
			break;
		}

		case ERROR_DEPENDENT_SERVICES_RUNNING:
		{
			// 1051 A stop control has been sent to a service that other running services are dependent on.  ERROR_DEPENDENT_SERVICES_RUNNING
			pString = "ERROR_DEPENDENT_SERVICES_RUNNING";
			break;
		}

		case ERROR_INVALID_SERVICE_CONTROL:
		{
			// 1052 The requested control is not valid for this service.  ERROR_INVALID_SERVICE_CONTROL
			pString = "ERROR_INVALID_SERVICE_CONTROL";
			break;
		}

		case ERROR_SERVICE_REQUEST_TIMEOUT:
		{
			// 1053 The service did not respond to the start or control request in a timely fashion.  ERROR_SERVICE_REQUEST_TIMEOUT
			pString = "ERROR_SERVICE_REQUEST_TIMEOUT";
			break;
		}

		case ERROR_SERVICE_NO_THREAD:
		{
			// 1054 A thread could not be created for the service.  ERROR_SERVICE_NO_THREAD
			pString = "ERROR_SERVICE_NO_THREAD";
			break;
		}

		case ERROR_SERVICE_DATABASE_LOCKED:
		{
			// 1055 The service database is locked.  ERROR_SERVICE_DATABASE_LOCKED
			pString = "ERROR_SERVICE_DATABASE_LOCKED";
			break;
		}

		case ERROR_SERVICE_ALREADY_RUNNING:
		{
			// 1056 An instance of the service is already running.  ERROR_SERVICE_ALREADY_RUNNING
			pString = "ERROR_SERVICE_ALREADY_RUNNING";
			break;
		}

		case ERROR_INVALID_SERVICE_ACCOUNT:
		{
			// 1057 The account name is invalid or does not exist.  ERROR_INVALID_SERVICE_ACCOUNT
			pString = "ERROR_INVALID_SERVICE_ACCOUNT";
			break;
		}

		case ERROR_SERVICE_DISABLED:
		{
			// 1058 The service cannot be started, either because it is disabled or because it has no enabled devices associated with it.  ERROR_SERVICE_DISABLED
			pString = "ERROR_SERVICE_DISABLED";
			break;
		}

		case ERROR_CIRCULAR_DEPENDENCY:
		{
			// 1059 Circular service dependency was specified.  ERROR_CIRCULAR_DEPENDENCY
			pString = "ERROR_CIRCULAR_DEPENDENCY";
			break;
		}

		case ERROR_SERVICE_DOES_NOT_EXIST:
		{
			// 1060 The specified service does not exist as an installed service.  ERROR_SERVICE_DOES_NOT_EXIST
			pString = "ERROR_SERVICE_DOES_NOT_EXIST";
			break;
		}

		case ERROR_SERVICE_CANNOT_ACCEPT_CTRL:
		{
			// 1061 The service cannot accept control messages at this time.  ERROR_SERVICE_CANNOT_ACCEPT_CTRL
			pString = "ERROR_SERVICE_CANNOT_ACCEPT_CTRL";
			break;
		}

		case ERROR_SERVICE_NOT_ACTIVE:
		{
			// 1062 The service has not been started.  ERROR_SERVICE_NOT_ACTIVE
			pString = "ERROR_SERVICE_NOT_ACTIVE";
			break;
		}

		case ERROR_FAILED_SERVICE_CONTROLLER_CONNECT:
		{
			// 1063 The service process could not connect to the service controller.  ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
			pString = "ERROR_FAILED_SERVICE_CONTROLLER_CONNECT";
			break;
		}

		case ERROR_EXCEPTION_IN_SERVICE:
		{
			// 1064 An exception occurred in the service when handling the control request.  ERROR_EXCEPTION_IN_SERVICE
			pString = "ERROR_EXCEPTION_IN_SERVICE";
			break;
		}

		case ERROR_DATABASE_DOES_NOT_EXIST:
		{
			// 1065 The database specified does not exist.  ERROR_DATABASE_DOES_NOT_EXIST
			pString = "ERROR_DATABASE_DOES_NOT_EXIST";
			break;
		}

		case ERROR_SERVICE_SPECIFIC_ERROR:
		{
			// 1066 The service has returned a service-specific error code.  ERROR_SERVICE_SPECIFIC_ERROR
			pString = "ERROR_SERVICE_SPECIFIC_ERROR";
			break;
		}

		case ERROR_PROCESS_ABORTED:
		{
			// 1067 The process terminated unexpectedly.  ERROR_PROCESS_ABORTED
			pString = "ERROR_PROCESS_ABORTED";
			break;
		}

		case ERROR_SERVICE_DEPENDENCY_FAIL:
		{
			// 1068 The dependency service or group failed to start.  ERROR_SERVICE_DEPENDENCY_FAIL
			pString = "ERROR_SERVICE_DEPENDENCY_FAIL";
			break;
		}

		case ERROR_SERVICE_LOGON_FAILED:
		{
			// 1069 The service did not start due to a logon failure.  ERROR_SERVICE_LOGON_FAILED
			pString = "ERROR_SERVICE_LOGON_FAILED";
			break;
		}

		case ERROR_SERVICE_START_HANG:
		{
			// 1070 After starting, the service hung in a start-pending state.  ERROR_SERVICE_START_HANG
			pString = "ERROR_SERVICE_START_HANG";
			break;
		}

		case ERROR_INVALID_SERVICE_LOCK:
		{
			// 1071 The specified service database lock is invalid.  ERROR_INVALID_SERVICE_LOCK
			pString = "ERROR_INVALID_SERVICE_LOCK";
			break;
		}

		case ERROR_SERVICE_MARKED_FOR_DELETE:
		{
			// 1072 The specified service has been marked for deletion.  ERROR_SERVICE_MARKED_FOR_DELETE
			pString = "ERROR_SERVICE_MARKED_FOR_DELETE";
			break;
		}

		case ERROR_SERVICE_EXISTS:
		{
			// 1073 The specified service already exists.  ERROR_SERVICE_EXISTS
			pString = "ERROR_SERVICE_EXISTS";
			break;
		}

		case ERROR_ALREADY_RUNNING_LKG:
		{
			// 1074 The system is currently running with the last-known-good configuration.  ERROR_ALREADY_RUNNING_LKG
			pString = "ERROR_ALREADY_RUNNING_LKG";
			break;
		}

		case ERROR_SERVICE_DEPENDENCY_DELETED:
		{
			// 1075 The dependency service does not exist or has been marked for deletion.  ERROR_SERVICE_DEPENDENCY_DELETED
			pString = "ERROR_SERVICE_DEPENDENCY_DELETED";
			break;
		}

		case ERROR_BOOT_ALREADY_ACCEPTED:
		{
			// 1076 The current boot has already been accepted for use as the last-known-good control set.  ERROR_BOOT_ALREADY_ACCEPTED
			pString = "ERROR_BOOT_ALREADY_ACCEPTED";
			break;
		}

		case ERROR_SERVICE_NEVER_STARTED:
		{
			// 1077 No attempts to start the service have been made since the last boot.  ERROR_SERVICE_NEVER_STARTED
			pString = "ERROR_SERVICE_NEVER_STARTED";
			break;
		}

		case ERROR_DUPLICATE_SERVICE_NAME:
		{
			// 1078 The name is already in use as either a service name or a service display name.  ERROR_DUPLICATE_SERVICE_NAME
			pString = "ERROR_DUPLICATE_SERVICE_NAME";
			break;
		}

		case ERROR_DIFFERENT_SERVICE_ACCOUNT:
		{
			// 1079 The account specified for this service is different from the account specified for other services running in the same process.  ERROR_DIFFERENT_SERVICE_ACCOUNT
			pString = "ERROR_DIFFERENT_SERVICE_ACCOUNT";
			break;
		}

		case ERROR_CANNOT_DETECT_DRIVER_FAILURE:
		{
			// 1080 Failure actions can only be set for Win32 services, not for drivers.  ERROR_CANNOT_DETECT_DRIVER_FAILURE
			pString = "ERROR_CANNOT_DETECT_DRIVER_FAILURE";
			break;
		}

		case ERROR_CANNOT_DETECT_PROCESS_ABORT:
		{
			// 1081 This service runs in the same process as the service control manager. Therefore, the service control manager cannot take action if this service's process terminates unexpectedly.  ERROR_CANNOT_DETECT_PROCESS_ABORT
			pString = "ERROR_CANNOT_DETECT_PROCESS_ABORT";
			break;
		}

		case ERROR_NO_RECOVERY_PROGRAM:
		{
			// 1082 No recovery program has been configured for this service.  ERROR_NO_RECOVERY_PROGRAM
			pString = "ERROR_NO_RECOVERY_PROGRAM";
			break;
		}

		case ERROR_END_OF_MEDIA:
		{
			// 1100 The physical end of the tape has been reached.  ERROR_END_OF_MEDIA
			pString = "ERROR_END_OF_MEDIA";
			break;
		}

		case ERROR_FILEMARK_DETECTED:
		{
			// 1101 A tape access reached a filemark.  ERROR_FILEMARK_DETECTED
			pString = "ERROR_FILEMARK_DETECTED";
			break;
		}

		case ERROR_BEGINNING_OF_MEDIA:
		{
			// 1102 The beginning of the tape or a partition was encountered.  ERROR_BEGINNING_OF_MEDIA
			pString = "ERROR_BEGINNING_OF_MEDIA";
			break;
		}

		case ERROR_SETMARK_DETECTED:
		{
			// 1103 A tape access reached the end of a set of files.  ERROR_SETMARK_DETECTED
			pString = "ERROR_SETMARK_DETECTED";
			break;
		}

		case ERROR_NO_DATA_DETECTED:
		{
			// 1104 No more data is on the tape.  ERROR_NO_DATA_DETECTED
			pString = "ERROR_NO_DATA_DETECTED";
			break;
		}

		case ERROR_PARTITION_FAILURE:
		{
			// 1105 Tape could not be partitioned.  ERROR_PARTITION_FAILURE
			pString = "ERROR_PARTITION_FAILURE";
			break;
		}

		case ERROR_INVALID_BLOCK_LENGTH:
		{
			// 1106 When accessing a new tape of a multivolume partition, the current blocksize is incorrect.  ERROR_INVALID_BLOCK_LENGTH
			pString = "ERROR_INVALID_BLOCK_LENGTH";
			break;
		}

		case ERROR_DEVICE_NOT_PARTITIONED:
		{
			// 1107 Tape partition information could not be found when loading a tape.  ERROR_DEVICE_NOT_PARTITIONED
			pString = "ERROR_DEVICE_NOT_PARTITIONED";
			break;
		}

		case ERROR_UNABLE_TO_LOCK_MEDIA:
		{
			// 1108 Unable to lock the media eject mechanism.  ERROR_UNABLE_TO_LOCK_MEDIA
			pString = "ERROR_UNABLE_TO_LOCK_MEDIA";
			break;
		}

		case ERROR_UNABLE_TO_UNLOAD_MEDIA:
		{
			// 1109 Unable to unload the media.  ERROR_UNABLE_TO_UNLOAD_MEDIA
			pString = "ERROR_UNABLE_TO_UNLOAD_MEDIA";
			break;
		}

		case ERROR_MEDIA_CHANGED:
		{
			// 1110 The media in the drive may have changed.  ERROR_MEDIA_CHANGED
			pString = "ERROR_MEDIA_CHANGED";
			break;
		}

		case ERROR_BUS_RESET:
		{
			// 1111 The I/O bus was reset.  ERROR_BUS_RESET
			pString = "ERROR_BUS_RESET";
			break;
		}

		case ERROR_NO_MEDIA_IN_DRIVE:
		{
			// 1112 No media in drive.  ERROR_NO_MEDIA_IN_DRIVE
			pString = "ERROR_NO_MEDIA_IN_DRIVE";
			break;
		}

		case ERROR_NO_UNICODE_TRANSLATION:
		{
			// 1113 No mapping for the Unicode character exists in the target multi-byte code page.  ERROR_NO_UNICODE_TRANSLATION
			pString = "ERROR_NO_UNICODE_TRANSLATION";
			break;
		}

		case ERROR_DLL_INIT_FAILED:
		{
			// 1114 A dynamic link library (DLL) initialization routine failed.  ERROR_DLL_INIT_FAILED
			pString = "ERROR_DLL_INIT_FAILED";
			break;
		}

		case ERROR_SHUTDOWN_IN_PROGRESS:
		{
			// 1115 A system shutdown is in progress.  ERROR_SHUTDOWN_IN_PROGRESS
			pString = "ERROR_SHUTDOWN_IN_PROGRESS";
			break;
		}

		case ERROR_NO_SHUTDOWN_IN_PROGRESS:
		{
			// 1116 Unable to abort the system shutdown because no shutdown was in progress.  ERROR_NO_SHUTDOWN_IN_PROGRESS
			pString = "ERROR_NO_SHUTDOWN_IN_PROGRESS";
			break;
		}

		case ERROR_IO_DEVICE:
		{
			// 1117 The request could not be performed because of an I/O device error.  ERROR_IO_DEVICE
			pString = "ERROR_IO_DEVICE";
			break;
		}

		case ERROR_SERIAL_NO_DEVICE:
		{
			// 1118 No serial device was successfully initialized. The serial driver will unload.  ERROR_SERIAL_NO_DEVICE
			pString = "ERROR_SERIAL_NO_DEVICE";
			break;
		}

		case ERROR_IRQ_BUSY:
		{
			// 1119 Unable to open a device that was sharing an interrupt request (IRQ) with other devices. At least one other device that uses that IRQ was already opened.  ERROR_IRQ_BUSY
			pString = "ERROR_IRQ_BUSY";
			break;
		}

		case ERROR_MORE_WRITES:
		{
			// 1120 A serial I/O operation was completed by another write to the serial port. The IOCTL_SERIAL_XOFF_COUNTER reached zero.)  ERROR_MORE_WRITES
			pString = "ERROR_MORE_WRITES";
			break;
		}

		case ERROR_COUNTER_TIMEOUT:
		{
			// 1121 A serial I/O operation completed because the timeout period expired. The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)  ERROR_COUNTER_TIMEOUT
			pString = "ERROR_COUNTER_TIMEOUT";
			break;
		}

		case ERROR_FLOPPY_ID_MARK_NOT_FOUND:
		{
			// 1122 No ID address mark was found on the floppy disk.  ERROR_FLOPPY_ID_MARK_NOT_FOUND
			pString = "ERROR_FLOPPY_ID_MARK_NOT_FOUND";
			break;
		}

		case ERROR_FLOPPY_WRONG_CYLINDER:
		{
			// 1123 Mismatch between the floppy disk sector ID field and the floppy disk controller track address.  ERROR_FLOPPY_WRONG_CYLINDER
			pString = "ERROR_FLOPPY_WRONG_CYLINDER";
			break;
		}

		case ERROR_FLOPPY_UNKNOWN_ERROR:
		{
			// 1124 The floppy disk controller reported an error that is not recognized by the floppy disk driver.  ERROR_FLOPPY_UNKNOWN_ERROR
			pString = "ERROR_FLOPPY_UNKNOWN_ERROR";
			break;
		}

		case ERROR_FLOPPY_BAD_REGISTERS:
		{
			// 1125 The floppy disk controller returned inconsistent results in its registers.  ERROR_FLOPPY_BAD_REGISTERS
			pString = "ERROR_FLOPPY_BAD_REGISTERS";
			break;
		}

		case ERROR_DISK_RECALIBRATE_FAILED:
		{
			// 1126 While accessing the hard disk, a recalibrate operation failed, even after retries.  ERROR_DISK_RECALIBRATE_FAILED
			pString = "ERROR_DISK_RECALIBRATE_FAILED";
			break;
		}

		case ERROR_DISK_OPERATION_FAILED:
		{
			// 1127 While accessing the hard disk, a disk operation failed even after retries.  ERROR_DISK_OPERATION_FAILED
			pString = "ERROR_DISK_OPERATION_FAILED";
			break;
		}

		case ERROR_DISK_RESET_FAILED:
		{
			// 1128 While accessing the hard disk, a disk controller reset was needed, but even that failed.  ERROR_DISK_RESET_FAILED
			pString = "ERROR_DISK_RESET_FAILED";
			break;
		}

		case ERROR_EOM_OVERFLOW:
		{
			// 1129 Physical end of tape encountered.  ERROR_EOM_OVERFLOW
			pString = "ERROR_EOM_OVERFLOW";
			break;
		}

		case ERROR_NOT_ENOUGH_SERVER_MEMORY:
		{
			// 1130 Not enough server storage is available to process this command.  ERROR_NOT_ENOUGH_SERVER_MEMORY
			pString = "ERROR_NOT_ENOUGH_SERVER_MEMORY";
			break;
		}

		case ERROR_POSSIBLE_DEADLOCK:
		{
			// 1131 A potential deadlock condition has been detected.  ERROR_POSSIBLE_DEADLOCK
			pString = "ERROR_POSSIBLE_DEADLOCK";
			break;
		}

		case ERROR_MAPPED_ALIGNMENT:
		{
			// 1132 The base address or the file offset specified does not have the proper alignment.  ERROR_MAPPED_ALIGNMENT
			pString = "ERROR_MAPPED_ALIGNMENT";
			break;
		}

		case ERROR_SET_POWER_STATE_VETOED:
		{
			// 1140 An attempt to change the system power state was vetoed by another application or driver.  ERROR_SET_POWER_STATE_VETOED
			pString = "ERROR_SET_POWER_STATE_VETOED";
			break;
		}

		case ERROR_SET_POWER_STATE_FAILED:
		{
			// 1141 The system BIOS failed an attempt to change the system power state.  ERROR_SET_POWER_STATE_FAILED
			pString = "ERROR_SET_POWER_STATE_FAILED";
			break;
		}

		case ERROR_TOO_MANY_LINKS:
		{
			// 1142 An attempt was made to create more links on a file than the file system supports.  ERROR_TOO_MANY_LINKS
			pString = "ERROR_TOO_MANY_LINKS";
			break;
		}

		case ERROR_OLD_WIN_VERSION:
		{
			// 1150 The specified program requires a newer version of Windows.  ERROR_OLD_WIN_VERSION
			pString = "ERROR_OLD_WIN_VERSION";
			break;
		}

		case ERROR_APP_WRONG_OS:
		{
			// 1151 The specified program is not a Windows or MS-DOS program.  ERROR_APP_WRONG_OS
			pString = "ERROR_APP_WRONG_OS";
			break;
		}

		case ERROR_SINGLE_INSTANCE_APP:
		{
			// 1152 Cannot start more than one instance of the specified program.  ERROR_SINGLE_INSTANCE_APP
			pString = "ERROR_SINGLE_INSTANCE_APP";
			break;
		}

		case ERROR_RMODE_APP:
		{
			// 1153 The specified program was written for an earlier version of Windows.  ERROR_RMODE_APP
			pString = "ERROR_RMODE_APP";
			break;
		}

		case ERROR_INVALID_DLL:
		{
			// 1154 One of the library files needed to run this application is damaged.  ERROR_INVALID_DLL
			pString = "ERROR_INVALID_DLL";
			break;
		}

		case ERROR_NO_ASSOCIATION:
		{
			// 1155 No application is associated with the specified file for this operation.  ERROR_NO_ASSOCIATION
			pString = "ERROR_NO_ASSOCIATION";
			break;
		}

		case ERROR_DDE_FAIL:
		{
			// 1156 An error occurred in sending the command to the application.  ERROR_DDE_FAIL
			pString = "ERROR_DDE_FAIL";
			break;
		}

		case ERROR_DLL_NOT_FOUND:
		{
			// 1157 One of the library files needed to run this application cannot be found.  ERROR_DLL_NOT_FOUND
			pString = "ERROR_DLL_NOT_FOUND";
			break;
		}

		case ERROR_NO_MORE_USER_HANDLES:
		{
			// 1158 The current process has used all of its system allowance of handles for Window Manager objects.  ERROR_NO_MORE_USER_HANDLES
			pString = "ERROR_NO_MORE_USER_HANDLES";
			break;
		}

		case ERROR_MESSAGE_SYNC_ONLY:
		{
			// 1159 The message can be used only with synchronous operations.  ERROR_MESSAGE_SYNC_ONLY
			pString = "ERROR_MESSAGE_SYNC_ONLY";
			break;
		}

		case ERROR_SOURCE_ELEMENT_EMPTY:
		{
			// 1160 The indicated source element has no media.  ERROR_SOURCE_ELEMENT_EMPTY
			pString = "ERROR_SOURCE_ELEMENT_EMPTY";
			break;
		}

		case ERROR_DESTINATION_ELEMENT_FULL:
		{
			// 1161 The indicated destination element already contains media.  ERROR_DESTINATION_ELEMENT_FULL
			pString = "ERROR_DESTINATION_ELEMENT_FULL";
			break;
		}

		case ERROR_ILLEGAL_ELEMENT_ADDRESS:
		{
			// 1162 The indicated element does not exist.  ERROR_ILLEGAL_ELEMENT_ADDRESS
			pString = "ERROR_ILLEGAL_ELEMENT_ADDRESS";
			break;
		}

		case ERROR_MAGAZINE_NOT_PRESENT:
		{
			// 1163 The indicated element is part of a magazine that is not present.  ERROR_MAGAZINE_NOT_PRESENT
			pString = "ERROR_MAGAZINE_NOT_PRESENT";
			break;
		}

		case ERROR_DEVICE_REINITIALIZATION_NEEDED:
		{
			// 1164 The indicated device requires reinitialization due to hardware errors.  ERROR_DEVICE_REINITIALIZATION_NEEDED
			pString = "ERROR_DEVICE_REINITIALIZATION_NEEDED";
			break;
		}

		case ERROR_DEVICE_REQUIRES_CLEANING:
		{
			// 1165 The device has indicated that cleaning is required before further operations are attempted.  ERROR_DEVICE_REQUIRES_CLEANING
			pString = "ERROR_DEVICE_REQUIRES_CLEANING";
			break;
		}

		case ERROR_DEVICE_DOOR_OPEN:
		{
			// 1166 The device has indicated that its door is open.  ERROR_DEVICE_DOOR_OPEN
			pString = "ERROR_DEVICE_DOOR_OPEN";
			break;
		}

		case ERROR_DEVICE_NOT_CONNECTED:
		{
			// 1167 The device is not connected.  ERROR_DEVICE_NOT_CONNECTED
			pString = "ERROR_DEVICE_NOT_CONNECTED";
			break;
		}

		case ERROR_NOT_FOUND:
		{
			// 1168 Element not found.  ERROR_NOT_FOUND
			pString = "ERROR_NOT_FOUND";
			break;
		}

		case ERROR_NO_MATCH:
		{
			// 1169 There was no match for the specified key in the index.  ERROR_NO_MATCH
			pString = "ERROR_NO_MATCH";
			break;
		}

		case ERROR_SET_NOT_FOUND:
		{
			// 1170 The property set specified does not exist on the object.  ERROR_SET_NOT_FOUND
			pString = "ERROR_SET_NOT_FOUND";
			break;
		}

		case ERROR_POINT_NOT_FOUND:
		{
			// 1171 The point passed to GetMouseMovePoints is not in the buffer.  ERROR_POINT_NOT_FOUND
			pString = "ERROR_POINT_NOT_FOUND";
			break;
		}

		case ERROR_NO_TRACKING_SERVICE:
		{
			// 1172 The tracking (workstation) service is not running.  ERROR_NO_TRACKING_SERVICE
			pString = "ERROR_NO_TRACKING_SERVICE";
			break;
		}

		case ERROR_NO_VOLUME_ID:
		{
			// 1173 The Volume ID could not be found.  ERROR_NO_VOLUME_ID
			pString = "ERROR_NO_VOLUME_ID";
			break;
		}

		case ERROR_BAD_DEVICE:
		{
			// 1200 The specified device name is invalid.  ERROR_BAD_DEVICE
			pString = "ERROR_BAD_DEVICE";
			break;
		}

		case ERROR_CONNECTION_UNAVAIL:
		{
			// 1201 The device is not currently connected but it is a remembered connection.  ERROR_CONNECTION_UNAVAIL
			pString = "ERROR_CONNECTION_UNAVAIL";
			break;
		}

		case ERROR_DEVICE_ALREADY_REMEMBERED:
		{
			// 1202 An attempt was made to remember a device that had previously been remembered.  ERROR_DEVICE_ALREADY_REMEMBERED
			pString = "ERROR_DEVICE_ALREADY_REMEMBERED";
			break;
		}

		case ERROR_NO_NET_OR_BAD_PATH:
		{
			// 1203 No network provider accepted the given network path.  ERROR_NO_NET_OR_BAD_PATH
			pString = "ERROR_NO_NET_OR_BAD_PATH";
			break;
		}

		case ERROR_BAD_PROVIDER:
		{
			// 1204 The specified network provider name is invalid.  ERROR_BAD_PROVIDER
			pString = "ERROR_BAD_PROVIDER";
			break;
		}

		case ERROR_CANNOT_OPEN_PROFILE:
		{
			// 1205 Unable to open the network connection profile.  ERROR_CANNOT_OPEN_PROFILE
			pString = "ERROR_CANNOT_OPEN_PROFILE";
			break;
		}

		case ERROR_BAD_PROFILE:
		{
			// 1206 The network connection profile is corrupted.  ERROR_BAD_PROFILE
			pString = "ERROR_BAD_PROFILE";
			break;
		}

		case ERROR_NOT_CONTAINER:
		{
			// 1207 Cannot enumerate a noncontainer.  ERROR_NOT_CONTAINER
			pString = "ERROR_NOT_CONTAINER";
			break;
		}

		case ERROR_EXTENDED_ERROR:
		{
			// 1208 An extended error has occurred.  ERROR_EXTENDED_ERROR
			pString = "ERROR_EXTENDED_ERROR";
			break;
		}

		case ERROR_INVALID_GROUPNAME:
		{
			// 1209 The format of the specified group name is invalid.  ERROR_INVALID_GROUPNAME
			pString = "ERROR_INVALID_GROUPNAME";
			break;
		}

		case ERROR_INVALID_COMPUTERNAME:
		{
			// 1210 The format of the specified computer name is invalid.  ERROR_INVALID_COMPUTERNAME
			pString = "ERROR_INVALID_COMPUTERNAME";
			break;
		}

		case ERROR_INVALID_EVENTNAME:
		{
			// 1211 The format of the specified event name is invalid.  ERROR_INVALID_EVENTNAME
			pString = "ERROR_INVALID_EVENTNAME";
			break;
		}

		case ERROR_INVALID_DOMAINNAME:
		{
			// 1212 The format of the specified domain name is invalid.  ERROR_INVALID_DOMAINNAME
			pString = "ERROR_INVALID_DOMAINNAME";
			break;
		}

		case ERROR_INVALID_SERVICENAME:
		{
			// 1213 The format of the specified service name is invalid.  ERROR_INVALID_SERVICENAME
			pString = "ERROR_INVALID_SERVICENAME";
			break;
		}

		case ERROR_INVALID_NETNAME:
		{
			// 1214 The format of the specified network name is invalid.  ERROR_INVALID_NETNAME
			pString = "ERROR_INVALID_NETNAME";
			break;
		}

		case ERROR_INVALID_SHARENAME:
		{
			// 1215 The format of the specified share name is invalid.  ERROR_INVALID_SHARENAME
			pString = "ERROR_INVALID_SHARENAME";
			break;
		}

		case ERROR_INVALID_PASSWORDNAME:
		{
			// 1216 The format of the specified password is invalid.  ERROR_INVALID_PASSWORDNAME
			pString = "ERROR_INVALID_PASSWORDNAME";
			break;
		}

		case ERROR_INVALID_MESSAGENAME:
		{
			// 1217 The format of the specified message name is invalid.  ERROR_INVALID_MESSAGENAME
			pString = "ERROR_INVALID_MESSAGENAME";
			break;
		}

		case ERROR_INVALID_MESSAGEDEST:
		{
			// 1218 The format of the specified message destination is invalid.  ERROR_INVALID_MESSAGEDEST
			pString = "ERROR_INVALID_MESSAGEDEST";
			break;
		}

		case ERROR_SESSION_CREDENTIAL_CONFLICT:
		{
			// 1219 The credentials supplied conflict with an existing set of credentials.  ERROR_SESSION_CREDENTIAL_CONFLICT
			pString = "ERROR_SESSION_CREDENTIAL_CONFLICT";
			break;
		}

		case ERROR_REMOTE_SESSION_LIMIT_EXCEEDED:
		{
			// 1220 An attempt was made to establish a session to a network server, but there are already too many sessions established to that server.  ERROR_REMOTE_SESSION_LIMIT_EXCEEDED
			pString = "ERROR_REMOTE_SESSION_LIMIT_EXCEEDED";
			break;
		}

		case ERROR_DUP_DOMAINNAME:
		{
			// 1221 The workgroup or domain name is already in use by another computer on the network.  ERROR_DUP_DOMAINNAME
			pString = "ERROR_DUP_DOMAINNAME";
			break;
		}

		case ERROR_NO_NETWORK:
		{
			// 1222 The network is not present or not started.  ERROR_NO_NETWORK
			pString = "ERROR_NO_NETWORK";
			break;
		}

		case ERROR_CANCELLED:
		{
			// 1223 The operation was canceled by the user.  ERROR_CANCELLED
			pString = "ERROR_CANCELLED";
			break;
		}

		case ERROR_USER_MAPPED_FILE:
		{
			// 1224 The requested operation cannot be performed on a file with a user-mapped section open.  ERROR_USER_MAPPED_FILE
			pString = "ERROR_USER_MAPPED_FILE";
			break;
		}

		case ERROR_CONNECTION_REFUSED:
		{
			// 1225 The remote system refused the network connection.  ERROR_CONNECTION_REFUSED
			pString = "ERROR_CONNECTION_REFUSED";
			break;
		}

		case ERROR_GRACEFUL_DISCONNECT:
		{
			// 1226 The network connection was gracefully closed.  ERROR_GRACEFUL_DISCONNECT
			pString = "ERROR_GRACEFUL_DISCONNECT";
			break;
		}

		case ERROR_ADDRESS_ALREADY_ASSOCIATED:
		{
			// 1227 The network transport endpoint already has an address associated with it.  ERROR_ADDRESS_ALREADY_ASSOCIATED
			pString = "ERROR_ADDRESS_ALREADY_ASSOCIATED";
			break;
		}

		case ERROR_ADDRESS_NOT_ASSOCIATED:
		{
			// 1228 An address has not yet been associated with the network endpoint.  ERROR_ADDRESS_NOT_ASSOCIATED
			pString = "ERROR_ADDRESS_NOT_ASSOCIATED";
			break;
		}

		case ERROR_CONNECTION_INVALID:
		{
			// 1229 An operation was attempted on a nonexistent network connection.  ERROR_CONNECTION_INVALID
			pString = "ERROR_CONNECTION_INVALID";
			break;
		}

		case ERROR_CONNECTION_ACTIVE:
		{
			// 1230 An invalid operation was attempted on an active network connection.  ERROR_CONNECTION_ACTIVE
			pString = "ERROR_CONNECTION_ACTIVE";
			break;
		}

		case ERROR_NETWORK_UNREACHABLE:
		{
			// 1231 The remote network is not reachable by the transport.  ERROR_NETWORK_UNREACHABLE
			pString = "ERROR_NETWORK_UNREACHABLE";
			break;
		}

		case ERROR_HOST_UNREACHABLE:
		{
			// 1232 The remote system is not reachable by the transport.  ERROR_HOST_UNREACHABLE
			pString = "ERROR_HOST_UNREACHABLE";
			break;
		}

		case ERROR_PROTOCOL_UNREACHABLE:
		{
			// 1233 The remote system does not support the transport protocol.  ERROR_PROTOCOL_UNREACHABLE
			pString = "ERROR_PROTOCOL_UNREACHABLE";
			break;
		}

		case ERROR_PORT_UNREACHABLE:
		{
			// 1234 No service is operating at the destination network endpoint on the remote system.  ERROR_PORT_UNREACHABLE
			pString = "ERROR_PORT_UNREACHABLE";
			break;
		}

		case ERROR_REQUEST_ABORTED:
		{
			// 1235 The request was aborted.  ERROR_REQUEST_ABORTED
			pString = "ERROR_REQUEST_ABORTED";
			break;
		}

		case ERROR_CONNECTION_ABORTED:
		{
			// 1236 The network connection was aborted by the local system.  ERROR_CONNECTION_ABORTED
			pString = "ERROR_CONNECTION_ABORTED";
			break;
		}

		case ERROR_RETRY:
		{
			// 1237 The operation could not be completed. A retry should be performed.  ERROR_RETRY
			pString = "ERROR_RETRY";
			break;
		}

		case ERROR_CONNECTION_COUNT_LIMIT:
		{
			// 1238 A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.  ERROR_CONNECTION_COUNT_LIMIT
			pString = "ERROR_CONNECTION_COUNT_LIMIT";
			break;
		}

		case ERROR_LOGIN_TIME_RESTRICTION:
		{
			// 1239 Attempting to log in during an unauthorized time of day for this account.  ERROR_LOGIN_TIME_RESTRICTION
			pString = "ERROR_LOGIN_TIME_RESTRICTION";
			break;
		}

		case ERROR_LOGIN_WKSTA_RESTRICTION:
		{
			// 1240 The account is not authorized to log in from this station.  ERROR_LOGIN_WKSTA_RESTRICTION
			pString = "ERROR_LOGIN_WKSTA_RESTRICTION";
			break;
		}

		case ERROR_INCORRECT_ADDRESS:
		{
			// 1241 The network address could not be used for the operation requested.  ERROR_INCORRECT_ADDRESS
			pString = "ERROR_INCORRECT_ADDRESS";
			break;
		}

		case ERROR_ALREADY_REGISTERED:
		{
			// 1242 The service is already registered.  ERROR_ALREADY_REGISTERED
			pString = "ERROR_ALREADY_REGISTERED";
			break;
		}

		case ERROR_SERVICE_NOT_FOUND:
		{
			// 1243 The specified service does not exist.  ERROR_SERVICE_NOT_FOUND
			pString = "ERROR_SERVICE_NOT_FOUND";
			break;
		}

		case ERROR_NOT_AUTHENTICATED:
		{
			// 1244 The operation being requested was not performed because the user has not been authenticated.  ERROR_NOT_AUTHENTICATED
			pString = "ERROR_NOT_AUTHENTICATED";
			break;
		}

		case ERROR_NOT_LOGGED_ON:
		{
			// 1245 The operation being requested was not performed because the user has not logged on to the network. The specified service does not exist.  ERROR_NOT_LOGGED_ON
			pString = "ERROR_NOT_LOGGED_ON";
			break;
		}

		case ERROR_CONTINUE:
		{
			// 1246 Continue with work in progress.  ERROR_CONTINUE
			pString = "ERROR_CONTINUE";
			break;
		}

		case ERROR_ALREADY_INITIALIZED:
		{
			// 1247 An attempt was made to perform an initialization operation when initialization has already been completed.  ERROR_ALREADY_INITIALIZED
			pString = "ERROR_ALREADY_INITIALIZED";
			break;
		}

		case ERROR_NO_MORE_DEVICES:
		{
			// 1248 No more local devices.  ERROR_NO_MORE_DEVICES
			pString = "ERROR_NO_MORE_DEVICES";
			break;
		}

		case ERROR_NO_SUCH_SITE:
		{
			// 1249 The specified site does not exist.  ERROR_NO_SUCH_SITE
			pString = "ERROR_NO_SUCH_SITE";
			break;
		}

		case ERROR_DOMAIN_CONTROLLER_EXISTS:
		{
			// 1250 A domain controller with the specified name already exists.  ERROR_DOMAIN_CONTROLLER_EXISTS
			pString = "ERROR_DOMAIN_CONTROLLER_EXISTS";
			break;
		}

		case ERROR_DS_NOT_INSTALLED:
		{
			// 1251 An error occurred while installing the Windows NT directory service. Please view the event log for more information.  ERROR_DS_NOT_INSTALLED
			pString = "ERROR_DS_NOT_INSTALLED";
			break;
		}

		case ERROR_NOT_ALL_ASSIGNED:
		{
			// 1300 Not all privileges referenced are assigned to the caller.  ERROR_NOT_ALL_ASSIGNED
			pString = "ERROR_NOT_ALL_ASSIGNED";
			break;
		}

		case ERROR_SOME_NOT_MAPPED:
		{
			// 1301 Some mapping between account names and security IDs was not done.  ERROR_SOME_NOT_MAPPED
			pString = "ERROR_SOME_NOT_MAPPED";
			break;
		}

		case ERROR_NO_QUOTAS_FOR_ACCOUNT:
		{
			// 1302 No system quota limits are specifically set for this account.  ERROR_NO_QUOTAS_FOR_ACCOUNT
			pString = "ERROR_NO_QUOTAS_FOR_ACCOUNT";
			break;
		}

		case ERROR_LOCAL_USER_SESSION_KEY:
		{
			// 1303 No encryption key is available. A well-known encryption key was returned.  ERROR_LOCAL_USER_SESSION_KEY
			pString = "ERROR_LOCAL_USER_SESSION_KEY";
			break;
		}

		case ERROR_NULL_LM_PASSWORD:
		{
			// 1304 The Windows NT password is too complex to be converted to a LAN Manager password. The LAN Manager password returned is a NULL string.  ERROR_NULL_LM_PASSWORD
			pString = "ERROR_NULL_LM_PASSWORD";
			break;
		}

		case ERROR_UNKNOWN_REVISION:
		{
			// 1305 The revision level is unknown.  ERROR_UNKNOWN_REVISION
			pString = "ERROR_UNKNOWN_REVISION";
			break;
		}

		case ERROR_REVISION_MISMATCH:
		{
			// 1306 Indicates two revision levels are incompatible.  ERROR_REVISION_MISMATCH
			pString = "ERROR_REVISION_MISMATCH";
			break;
		}

		case ERROR_INVALID_OWNER:
		{
			// 1307 This security ID may not be assigned as the owner of this object.  ERROR_INVALID_OWNER
			pString = "ERROR_INVALID_OWNER";
			break;
		}

		case ERROR_INVALID_PRIMARY_GROUP:
		{
			// 1308 This security ID may not be assigned as the primary group of an object.  ERROR_INVALID_PRIMARY_GROUP
			pString = "ERROR_INVALID_PRIMARY_GROUP";
			break;
		}

		case ERROR_NO_IMPERSONATION_TOKEN:
		{
			// 1309 An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client.  ERROR_NO_IMPERSONATION_TOKEN
			pString = "ERROR_NO_IMPERSONATION_TOKEN";
			break;
		}

		case ERROR_CANT_DISABLE_MANDATORY:
		{
			// 1310 The group may not be disabled.  ERROR_CANT_DISABLE_MANDATORY
			pString = "ERROR_CANT_DISABLE_MANDATORY";
			break;
		}

		case ERROR_NO_LOGON_SERVERS:
		{
			// 1311 There are currently no logon servers available to service the logon request.  ERROR_NO_LOGON_SERVERS
			pString = "ERROR_NO_LOGON_SERVERS";
			break;
		}

		case ERROR_NO_SUCH_LOGON_SESSION:
		{
			// 1312 A specified logon session does not exist. It may already have been terminated.  ERROR_NO_SUCH_LOGON_SESSION
			pString = "ERROR_NO_SUCH_LOGON_SESSION";
			break;
		}

		case ERROR_NO_SUCH_PRIVILEGE:
		{
			// 1313 A specified privilege does not exist.  ERROR_NO_SUCH_PRIVILEGE
			pString = "ERROR_NO_SUCH_PRIVILEGE";
			break;
		}

		case ERROR_PRIVILEGE_NOT_HELD:
		{
			// 1314 A required privilege is not held by the client.  ERROR_PRIVILEGE_NOT_HELD
			pString = "ERROR_PRIVILEGE_NOT_HELD";
			break;
		}

		case ERROR_INVALID_ACCOUNT_NAME:
		{
			// 1315 The name provided is not a properly formed account name.  ERROR_INVALID_ACCOUNT_NAME
			pString = "ERROR_INVALID_ACCOUNT_NAME";
			break;
		}

		case ERROR_USER_EXISTS:
		{
			// 1316 The specified user already exists.  ERROR_USER_EXISTS
			pString = "ERROR_USER_EXISTS";
			break;
		}

		case ERROR_NO_SUCH_USER:
		{
			// 1317 The specified user does not exist.  ERROR_NO_SUCH_USER
			pString = "ERROR_NO_SUCH_USER";
			break;
		}

		case ERROR_GROUP_EXISTS:
		{
			// 1318 The specified group already exists.  ERROR_GROUP_EXISTS
			pString = "ERROR_GROUP_EXISTS";
			break;
		}

		case ERROR_NO_SUCH_GROUP:
		{
			// 1319 The specified group does not exist.  ERROR_NO_SUCH_GROUP
			pString = "ERROR_NO_SUCH_GROUP";
			break;
		}

		case ERROR_MEMBER_IN_GROUP:
		{
			// 1320 Either the specified user account is already a member of the specified group, or the specified group cannot be deleted because it contains a member.  ERROR_MEMBER_IN_GROUP
			pString = "ERROR_MEMBER_IN_GROUP";
			break;
		}

		case ERROR_MEMBER_NOT_IN_GROUP:
		{
			// 1321 The specified user account is not a member of the specified group account.  ERROR_MEMBER_NOT_IN_GROUP
			pString = "ERROR_MEMBER_NOT_IN_GROUP";
			break;
		}

		case ERROR_LAST_ADMIN:
		{
			// 1322 The last remaining administration account cannot be disabled or deleted.  ERROR_LAST_ADMIN
			pString = "ERROR_LAST_ADMIN";
			break;
		}

		case ERROR_WRONG_PASSWORD:
		{
			// 1323 Unable to update the password. The value provided as the current password is incorrect.  ERROR_WRONG_PASSWORD
			pString = "ERROR_WRONG_PASSWORD";
			break;
		}

		case ERROR_ILL_FORMED_PASSWORD:
		{
			// 1324 Unable to update the password. The value provided for the new password contains values that are not allowed in passwords.  ERROR_ILL_FORMED_PASSWORD
			pString = "ERROR_ILL_FORMED_PASSWORD";
			break;
		}

		case ERROR_PASSWORD_RESTRICTION:
		{
			// 1325 Unable to update the password because a password update rule has been violated.  ERROR_PASSWORD_RESTRICTION
			pString = "ERROR_PASSWORD_RESTRICTION";
			break;
		}

		case ERROR_LOGON_FAILURE:
		{
			// 1326 Logon failure: unknown user name or bad password.  ERROR_LOGON_FAILURE
			pString = "ERROR_LOGON_FAILURE";
			break;
		}

		case ERROR_ACCOUNT_RESTRICTION:
		{
			// 1327 Logon failure: user account restriction.  ERROR_ACCOUNT_RESTRICTION
			pString = "ERROR_ACCOUNT_RESTRICTION";
			break;
		}

		case ERROR_INVALID_LOGON_HOURS:
		{
			// 1328 Logon failure: account logon time restriction violation.  ERROR_INVALID_LOGON_HOURS
			pString = "ERROR_INVALID_LOGON_HOURS";
			break;
		}

		case ERROR_INVALID_WORKSTATION:
		{
			// 1329 Logon failure: user not allowed to log on to this computer.  ERROR_INVALID_WORKSTATION
			pString = "ERROR_INVALID_WORKSTATION";
			break;
		}

		case ERROR_PASSWORD_EXPIRED:
		{
			// 1330 Logon failure: the specified account password has expired.  ERROR_PASSWORD_EXPIRED
			pString = "ERROR_PASSWORD_EXPIRED";
			break;
		}

		case ERROR_ACCOUNT_DISABLED:
		{
			// 1331 Logon failure: account currently disabled.  ERROR_ACCOUNT_DISABLED
			pString = "ERROR_ACCOUNT_DISABLED";
			break;
		}

		case ERROR_NONE_MAPPED:
		{
			// 1332 No mapping between account names and security IDs was done.  ERROR_NONE_MAPPED
			pString = "ERROR_NONE_MAPPED";
			break;
		}

		case ERROR_TOO_MANY_LUIDS_REQUESTED:
		{
			// 1333 Too many local user identifiers (LUIDs) were requested at one time.  ERROR_TOO_MANY_LUIDS_REQUESTED
			pString = "ERROR_TOO_MANY_LUIDS_REQUESTED";
			break;
		}

		case ERROR_LUIDS_EXHAUSTED:
		{
			// 1334 No more local user identifiers (LUIDs) are available.  ERROR_LUIDS_EXHAUSTED
			pString = "ERROR_LUIDS_EXHAUSTED";
			break;
		}

		case ERROR_INVALID_SUB_AUTHORITY:
		{
			// 1335 The subauthority part of a security ID is invalid for this particular use.  ERROR_INVALID_SUB_AUTHORITY
			pString = "ERROR_INVALID_SUB_AUTHORITY";
			break;
		}

		case ERROR_INVALID_ACL:
		{
			// 1336 The access control list (ACL) structure is invalid.  ERROR_INVALID_ACL
			pString = "ERROR_INVALID_ACL";
			break;
		}

		case ERROR_INVALID_SID:
		{
			// 1337 The security ID structure is invalid.  ERROR_INVALID_SID
			pString = "ERROR_INVALID_SID";
			break;
		}

		case ERROR_INVALID_SECURITY_DESCR:
		{
			// 1338 The security descriptor structure is invalid.  ERROR_INVALID_SECURITY_DESCR
			pString = "ERROR_INVALID_SECURITY_DESCR";
			break;
		}

		case ERROR_BAD_INHERITANCE_ACL:
		{
			// 1340 The inherited access control list (ACL) or access control entry (ACE) could not be built.  ERROR_BAD_INHERITANCE_ACL
			pString = "ERROR_BAD_INHERITANCE_ACL";
			break;
		}

		case ERROR_SERVER_DISABLED:
		{
			// 1341 The server is currently disabled.  ERROR_SERVER_DISABLED
			pString = "ERROR_SERVER_DISABLED";
			break;
		}

		case ERROR_SERVER_NOT_DISABLED:
		{
			// 1342 The server is currently enabled.  ERROR_SERVER_NOT_DISABLED
			pString = "ERROR_SERVER_NOT_DISABLED";
			break;
		}

		case ERROR_INVALID_ID_AUTHORITY:
		{
			// 1343 The value provided was an invalid value for an identifier authority.  ERROR_INVALID_ID_AUTHORITY
			pString = "ERROR_INVALID_ID_AUTHORITY";
			break;
		}

		case ERROR_ALLOTTED_SPACE_EXCEEDED:
		{
			// 1344 No more memory is available for security information updates.  ERROR_ALLOTTED_SPACE_EXCEEDED
			pString = "ERROR_ALLOTTED_SPACE_EXCEEDED";
			break;
		}

		case ERROR_INVALID_GROUP_ATTRIBUTES:
		{
			// 1345 The specified attributes are invalid, or incompatible with the attributes for the group as a whole.  ERROR_INVALID_GROUP_ATTRIBUTES
			pString = "ERROR_INVALID_GROUP_ATTRIBUTES";
			break;
		}

		case ERROR_BAD_IMPERSONATION_LEVEL:
		{
			// 1346 Either a required impersonation level was not provided, or the provided impersonation level is invalid.  ERROR_BAD_IMPERSONATION_LEVEL
			pString = "ERROR_BAD_IMPERSONATION_LEVEL";
			break;
		}

		case ERROR_CANT_OPEN_ANONYMOUS:
		{
			// 1347 Cannot open an anonymous level security token.  ERROR_CANT_OPEN_ANONYMOUS
			pString = "ERROR_CANT_OPEN_ANONYMOUS";
			break;
		}

		case ERROR_BAD_VALIDATION_CLASS:
		{
			// 1348 The validation information class requested was invalid.  ERROR_BAD_VALIDATION_CLASS
			pString = "ERROR_BAD_VALIDATION_CLASS";
			break;
		}

		case ERROR_BAD_TOKEN_TYPE:
		{
			// 1349 The type of the token is inappropriate for its attempted use.  ERROR_BAD_TOKEN_TYPE
			pString = "ERROR_BAD_TOKEN_TYPE";
			break;
		}

		case ERROR_NO_SECURITY_ON_OBJECT:
		{
			// 1350 Unable to perform a security operation on an object that has no associated security.  ERROR_NO_SECURITY_ON_OBJECT
			pString = "ERROR_NO_SECURITY_ON_OBJECT";
			break;
		}

		case ERROR_CANT_ACCESS_DOMAIN_INFO:
		{
			// 1351 Indicates a Windows NT Server could not be contacted or that objects within the domain are protected such that necessary information could not be retrieved.  ERROR_CANT_ACCESS_DOMAIN_INFO
			pString = "ERROR_CANT_ACCESS_DOMAIN_INFO";
			break;
		}

		case ERROR_INVALID_SERVER_STATE:
		{
			// 1352 The security account manager (SAM) or local security authority (LSA) server was in the wrong state to perform the security operation.  ERROR_INVALID_SERVER_STATE
			pString = "ERROR_INVALID_SERVER_STATE";
			break;
		}

		case ERROR_INVALID_DOMAIN_STATE:
		{
			// 1353 The domain was in the wrong state to perform the security operation.  ERROR_INVALID_DOMAIN_STATE
			pString = "ERROR_INVALID_DOMAIN_STATE";
			break;
		}

		case ERROR_INVALID_DOMAIN_ROLE:
		{
			// 1354 This operation is only allowed for the Primary Domain Controller of the domain.  ERROR_INVALID_DOMAIN_ROLE
			pString = "ERROR_INVALID_DOMAIN_ROLE";
			break;
		}

		case ERROR_NO_SUCH_DOMAIN:
		{
			// 1355 The specified domain did not exist.  ERROR_NO_SUCH_DOMAIN
			pString = "ERROR_NO_SUCH_DOMAIN";
			break;
		}

		case ERROR_DOMAIN_EXISTS:
		{
			// 1356 The specified domain already exists.  ERROR_DOMAIN_EXISTS
			pString = "ERROR_DOMAIN_EXISTS";
			break;
		}

		case ERROR_DOMAIN_LIMIT_EXCEEDED:
		{
			// 1357 An attempt was made to exceed the limit on the number of domains per server.  ERROR_DOMAIN_LIMIT_EXCEEDED
			pString = "ERROR_DOMAIN_LIMIT_EXCEEDED";
			break;
		}

		case ERROR_INTERNAL_DB_CORRUPTION:
		{
			// 1358 Unable to complete the requested operation because of either a catastrophic media failure or a data structure corruption on the disk.  ERROR_INTERNAL_DB_CORRUPTION
			pString = "ERROR_INTERNAL_DB_CORRUPTION";
			break;
		}

		case ERROR_INTERNAL_ERROR:
		{
			// 1359 The security account database contains an internal inconsistency.  ERROR_INTERNAL_ERROR
			pString = "ERROR_INTERNAL_ERROR";
			break;
		}

		case ERROR_GENERIC_NOT_MAPPED:
		{
			// 1360 Generic access types were contained in an access mask which should already be mapped to nongeneric types.  ERROR_GENERIC_NOT_MAPPED
			pString = "ERROR_GENERIC_NOT_MAPPED";
			break;
		}

		case ERROR_BAD_DESCRIPTOR_FORMAT:
		{
			// 1361 A security descriptor is not in the right format (absolute or self-relative).  ERROR_BAD_DESCRIPTOR_FORMAT
			pString = "ERROR_BAD_DESCRIPTOR_FORMAT";
			break;
		}

		case ERROR_NOT_LOGON_PROCESS:
		{
			// 1362 The requested action is restricted for use by logon processes only. The calling process has not registered as a logon process.  ERROR_NOT_LOGON_PROCESS
			pString = "ERROR_NOT_LOGON_PROCESS";
			break;
		}

		case ERROR_LOGON_SESSION_EXISTS:
		{
			// 1363 Cannot start a new logon session with an ID that is already in use.  ERROR_LOGON_SESSION_EXISTS
			pString = "ERROR_LOGON_SESSION_EXISTS";
			break;
		}

		case ERROR_NO_SUCH_PACKAGE:
		{
			// 1364 A specified authentication package is unknown.  ERROR_NO_SUCH_PACKAGE
			pString = "ERROR_NO_SUCH_PACKAGE";
			break;
		}

		case ERROR_BAD_LOGON_SESSION_STATE:
		{
			// 1365 The logon session is not in a state that is consistent with the requested operation.  ERROR_BAD_LOGON_SESSION_STATE
			pString = "ERROR_BAD_LOGON_SESSION_STATE";
			break;
		}

		case ERROR_LOGON_SESSION_COLLISION:
		{
			// 1366 The logon session ID is already in use.  ERROR_LOGON_SESSION_COLLISION
			pString = "ERROR_LOGON_SESSION_COLLISION";
			break;
		}

		case ERROR_INVALID_LOGON_TYPE:
		{
			// 1367 A logon request contained an invalid logon type value.  ERROR_INVALID_LOGON_TYPE
			pString = "ERROR_INVALID_LOGON_TYPE";
			break;
		}

		case ERROR_CANNOT_IMPERSONATE:
		{
			// 1368 Unable to impersonate using a named pipe until data has been read from that pipe.  ERROR_CANNOT_IMPERSONATE
			pString = "ERROR_CANNOT_IMPERSONATE";
			break;
		}

		case ERROR_RXACT_INVALID_STATE:
		{
			// 1369 The transaction state of a registry subtree is incompatible with the requested operation.  ERROR_RXACT_INVALID_STATE
			pString = "ERROR_RXACT_INVALID_STATE";
			break;
		}

		case ERROR_RXACT_COMMIT_FAILURE:
		{
			// 1370 An internal security database corruption has been encountered.  ERROR_RXACT_COMMIT_FAILURE
			pString = "ERROR_RXACT_COMMIT_FAILURE";
			break;
		}

		case ERROR_SPECIAL_ACCOUNT:
		{
			// 1371 Cannot perform this operation on built-in accounts.  ERROR_SPECIAL_ACCOUNT
			pString = "ERROR_SPECIAL_ACCOUNT";
			break;
		}

		case ERROR_SPECIAL_GROUP:
		{
			// 1372 Cannot perform this operation on this built-in special group.  ERROR_SPECIAL_GROUP
			pString = "ERROR_SPECIAL_GROUP";
			break;
		}

		case ERROR_SPECIAL_USER:
		{
			// 1373 Cannot perform this operation on this built-in special user.  ERROR_SPECIAL_USER
			pString = "ERROR_SPECIAL_USER";
			break;
		}

		case ERROR_MEMBERS_PRIMARY_GROUP:
		{
			// 1374 The user cannot be removed from a group because the group is currently the user's primary group.  ERROR_MEMBERS_PRIMARY_GROUP
			pString = "ERROR_MEMBERS_PRIMARY_GROUP";
			break;
		}

		case ERROR_TOKEN_ALREADY_IN_USE:
		{
			// 1375 The token is already in use as a primary token.  ERROR_TOKEN_ALREADY_IN_USE
			pString = "ERROR_TOKEN_ALREADY_IN_USE";
			break;
		}

		case ERROR_NO_SUCH_ALIAS:
		{
			// 1376 The specified local group does not exist.  ERROR_NO_SUCH_ALIAS
			pString = "ERROR_NO_SUCH_ALIAS";
			break;
		}

		case ERROR_MEMBER_NOT_IN_ALIAS:
		{
			// 1377 The specified account name is not a member of the local group.  ERROR_MEMBER_NOT_IN_ALIAS
			pString = "ERROR_MEMBER_NOT_IN_ALIAS";
			break;
		}

		case ERROR_MEMBER_IN_ALIAS:
		{
			// 1378 The specified account name is already a member of the local group.  ERROR_MEMBER_IN_ALIAS
			pString = "ERROR_MEMBER_IN_ALIAS";
			break;
		}

		case ERROR_ALIAS_EXISTS:
		{
			// 1379 The specified local group already exists.  ERROR_ALIAS_EXISTS
			pString = "ERROR_ALIAS_EXISTS";
			break;
		}

		case ERROR_LOGON_NOT_GRANTED:
		{
			// 1380 Logon failure: the user has not been granted the requested logon type at this computer.  ERROR_LOGON_NOT_GRANTED
			pString = "ERROR_LOGON_NOT_GRANTED";
			break;
		}

		case ERROR_TOO_MANY_SECRETS:
		{
			// 1381 The maximum number of secrets that may be stored in a single system has been exceeded.  ERROR_TOO_MANY_SECRETS
			pString = "ERROR_TOO_MANY_SECRETS";
			break;
		}

		case ERROR_SECRET_TOO_LONG:
		{
			// 1382 The length of a secret exceeds the maximum length allowed.  ERROR_SECRET_TOO_LONG
			pString = "ERROR_SECRET_TOO_LONG";
			break;
		}

		case ERROR_INTERNAL_DB_ERROR:
		{
			// 1383 The local security authority database contains an internal inconsistency.  ERROR_INTERNAL_DB_ERROR
			pString = "ERROR_INTERNAL_DB_ERROR";
			break;
		}

		case ERROR_TOO_MANY_CONTEXT_IDS:
		{
			// 1384 During a logon attempt, the user's security context accumulated too many security IDs.  ERROR_TOO_MANY_CONTEXT_IDS
			pString = "ERROR_TOO_MANY_CONTEXT_IDS";
			break;
		}

		case ERROR_LOGON_TYPE_NOT_GRANTED:
		{
			// 1385 Logon failure: the user has not been granted the requested logon type at this computer.  ERROR_LOGON_TYPE_NOT_GRANTED
			pString = "ERROR_LOGON_TYPE_NOT_GRANTED";
			break;
		}

		case ERROR_NT_CROSS_ENCRYPTION_REQUIRED:
		{
			// 1386 A cross-encrypted password is necessary to change a user password.  ERROR_NT_CROSS_ENCRYPTION_REQUIRED
			pString = "ERROR_NT_CROSS_ENCRYPTION_REQUIRED";
			break;
		}

		case ERROR_NO_SUCH_MEMBER:
		{
			// 1387 A new member could not be added to a local group because the member does not exist.  ERROR_NO_SUCH_MEMBER
			pString = "ERROR_NO_SUCH_MEMBER";
			break;
		}

		case ERROR_INVALID_MEMBER:
		{
			// 1388 A new member could not be added to a local group because the member has the wrong account type.  ERROR_INVALID_MEMBER
			pString = "ERROR_INVALID_MEMBER";
			break;
		}

		case ERROR_TOO_MANY_SIDS:
		{
			// 1389 Too many security IDs have been specified.  ERROR_TOO_MANY_SIDS
			pString = "ERROR_TOO_MANY_SIDS";
			break;
		}

		case ERROR_LM_CROSS_ENCRYPTION_REQUIRED:
		{
			// 1390 A cross-encrypted password is necessary to change this user password.  ERROR_LM_CROSS_ENCRYPTION_REQUIRED
			pString = "ERROR_LM_CROSS_ENCRYPTION_REQUIRED";
			break;
		}

		case ERROR_NO_INHERITANCE:
		{
			// 1391 Indicates an ACL contains no inheritable components.  ERROR_NO_INHERITANCE
			pString = "ERROR_NO_INHERITANCE";
			break;
		}

		case ERROR_FILE_CORRUPT:
		{
			// 1392 The file or directory is corrupted and unreadable.  ERROR_FILE_CORRUPT
			pString = "ERROR_FILE_CORRUPT";
			break;
		}

		case ERROR_DISK_CORRUPT:
		{
			// 1393 The disk structure is corrupted and unreadable.  ERROR_DISK_CORRUPT
			pString = "ERROR_DISK_CORRUPT";
			break;
		}

		case ERROR_NO_USER_SESSION_KEY:
		{
			// 1394 There is no user session key for the specified logon session.  ERROR_NO_USER_SESSION_KEY
			pString = "ERROR_NO_USER_SESSION_KEY";
			break;
		}

		case ERROR_LICENSE_QUOTA_EXCEEDED:
		{
			// 1395 The service being accessed is licensed for a particular number of connections. No more connections can be made to the service at this time because there are already as many connections as the service can accept.  ERROR_LICENSE_QUOTA_EXCEEDED
			pString = "ERROR_LICENSE_QUOTA_EXCEEDED";
			break;
		}

		case ERROR_INVALID_WINDOW_HANDLE:
		{
			// 1400 Invalid window handle.  ERROR_INVALID_WINDOW_HANDLE
			pString = "ERROR_INVALID_WINDOW_HANDLE";
			break;
		}

		case ERROR_INVALID_MENU_HANDLE:
		{
			// 1401 Invalid menu handle.  ERROR_INVALID_MENU_HANDLE
			pString = "ERROR_INVALID_MENU_HANDLE";
			break;
		}

		case ERROR_INVALID_CURSOR_HANDLE:
		{
			// 1402 Invalid cursor handle.  ERROR_INVALID_CURSOR_HANDLE
			pString = "ERROR_INVALID_CURSOR_HANDLE";
			break;
		}

		case ERROR_INVALID_ACCEL_HANDLE:
		{
			// 1403 Invalid accelerator table handle.  ERROR_INVALID_ACCEL_HANDLE
			pString = "ERROR_INVALID_ACCEL_HANDLE";
			break;
		}

		case ERROR_INVALID_HOOK_HANDLE:
		{
			// 1404 Invalid hook handle.  ERROR_INVALID_HOOK_HANDLE
			pString = "ERROR_INVALID_HOOK_HANDLE";
			break;
		}

		case ERROR_INVALID_DWP_HANDLE:
		{
			// 1405 Invalid handle to a multiple-window position structure.  ERROR_INVALID_DWP_HANDLE
			pString = "ERROR_INVALID_DWP_HANDLE";
			break;
		}

		case ERROR_TLW_WITH_WSCHILD:
		{
			// 1406 Cannot create a top-level child window.  ERROR_TLW_WITH_WSCHILD
			pString = "ERROR_TLW_WITH_WSCHILD";
			break;
		}

		case ERROR_CANNOT_FIND_WND_CLASS:
		{
			// 1407 Cannot find window class.  ERROR_CANNOT_FIND_WND_CLASS
			pString = "ERROR_CANNOT_FIND_WND_CLASS";
			break;
		}

		case ERROR_WINDOW_OF_OTHER_THREAD:
		{
			// 1408 Invalid window; it belongs to other thread.  ERROR_WINDOW_OF_OTHER_THREAD
			pString = "ERROR_WINDOW_OF_OTHER_THREAD";
			break;
		}

		case ERROR_HOTKEY_ALREADY_REGISTERED:
		{
			// 1409 Hot key is already registered.  ERROR_HOTKEY_ALREADY_REGISTERED
			pString = "ERROR_HOTKEY_ALREADY_REGISTERED";
			break;
		}

		case ERROR_CLASS_ALREADY_EXISTS:
		{
			// 1410 Class already exists.  ERROR_CLASS_ALREADY_EXISTS
			pString = "ERROR_CLASS_ALREADY_EXISTS";
			break;
		}

		case ERROR_CLASS_DOES_NOT_EXIST:
		{
			// 1411 Class does not exist.  ERROR_CLASS_DOES_NOT_EXIST
			pString = "ERROR_CLASS_DOES_NOT_EXIST";
			break;
		}

		case ERROR_CLASS_HAS_WINDOWS:
		{
			// 1412 Class still has open windows.  ERROR_CLASS_HAS_WINDOWS
			pString = "ERROR_CLASS_HAS_WINDOWS";
			break;
		}

		case ERROR_INVALID_INDEX:
		{
			// 1413 Invalid index.  ERROR_INVALID_INDEX
			pString = "ERROR_INVALID_INDEX";
			break;
		}

		case ERROR_INVALID_ICON_HANDLE:
		{
			// 1414 Invalid icon handle.  ERROR_INVALID_ICON_HANDLE
			pString = "ERROR_INVALID_ICON_HANDLE";
			break;
		}

		case ERROR_PRIVATE_DIALOG_INDEX:
		{
			// 1415 Using private DIALOG window words.  ERROR_PRIVATE_DIALOG_INDEX
			pString = "ERROR_PRIVATE_DIALOG_INDEX";
			break;
		}

		case ERROR_LISTBOX_ID_NOT_FOUND:
		{
			// 1416 The list box identifier was not found.  ERROR_LISTBOX_ID_NOT_FOUND
			pString = "ERROR_LISTBOX_ID_NOT_FOUND";
			break;
		}

		case ERROR_NO_WILDCARD_CHARACTERS:
		{
			// 1417 No wildcards were found.  ERROR_NO_WILDCARD_CHARACTERS
			pString = "ERROR_NO_WILDCARD_CHARACTERS";
			break;
		}

		case ERROR_CLIPBOARD_NOT_OPEN:
		{
			// 1418 Thread does not have a clipboard open.  ERROR_CLIPBOARD_NOT_OPEN
			pString = "ERROR_CLIPBOARD_NOT_OPEN";
			break;
		}

		case ERROR_HOTKEY_NOT_REGISTERED:
		{
			// 1419 Hot key is not registered.  ERROR_HOTKEY_NOT_REGISTERED
			pString = "ERROR_HOTKEY_NOT_REGISTERED";
			break;
		}

		case ERROR_WINDOW_NOT_DIALOG:
		{
			// 1420 The window is not a valid dialog window.  ERROR_WINDOW_NOT_DIALOG
			pString = "ERROR_WINDOW_NOT_DIALOG";
			break;
		}

		case ERROR_CONTROL_ID_NOT_FOUND:
		{
			// 1421 Control ID not found.  ERROR_CONTROL_ID_NOT_FOUND
			pString = "ERROR_CONTROL_ID_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_COMBOBOX_MESSAGE:
		{
			// 1422 Invalid message for a combo box because it does not have an edit control.  ERROR_INVALID_COMBOBOX_MESSAGE
			pString = "ERROR_INVALID_COMBOBOX_MESSAGE";
			break;
		}

		case ERROR_WINDOW_NOT_COMBOBOX:
		{
			// 1423 The window is not a combo box.  ERROR_WINDOW_NOT_COMBOBOX
			pString = "ERROR_WINDOW_NOT_COMBOBOX";
			break;
		}

		case ERROR_INVALID_EDIT_HEIGHT:
		{
			// 1424 Height must be less than 256.  ERROR_INVALID_EDIT_HEIGHT
			pString = "ERROR_INVALID_EDIT_HEIGHT";
			break;
		}

		case ERROR_DC_NOT_FOUND:
		{
			// 1425 Invalid device context (DC) handle.  ERROR_DC_NOT_FOUND
			pString = "ERROR_DC_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_HOOK_FILTER:
		{
			// 1426 Invalid hook procedure type.  ERROR_INVALID_HOOK_FILTER
			pString = "ERROR_INVALID_HOOK_FILTER";
			break;
		}

		case ERROR_INVALID_FILTER_PROC:
		{
			// 1427 Invalid hook procedure.  ERROR_INVALID_FILTER_PROC
			pString = "ERROR_INVALID_FILTER_PROC";
			break;
		}

		case ERROR_HOOK_NEEDS_HMOD:
		{
			// 1428 Cannot set nonlocal hook without a module handle.  ERROR_HOOK_NEEDS_HMOD
			pString = "ERROR_HOOK_NEEDS_HMOD";
			break;
		}

		case ERROR_GLOBAL_ONLY_HOOK:
		{
			// 1429 This hook procedure can only be set globally.  ERROR_GLOBAL_ONLY_HOOK
			pString = "ERROR_GLOBAL_ONLY_HOOK";
			break;
		}

		case ERROR_JOURNAL_HOOK_SET:
		{
			// 1430 The journal hook procedure is already installed.  ERROR_JOURNAL_HOOK_SET
			pString = "ERROR_JOURNAL_HOOK_SET";
			break;
		}

		case ERROR_HOOK_NOT_INSTALLED:
		{
			// 1431 The hook procedure is not installed.  ERROR_HOOK_NOT_INSTALLED
			pString = "ERROR_HOOK_NOT_INSTALLED";
			break;
		}

		case ERROR_INVALID_LB_MESSAGE:
		{
			// 1432 Invalid message for single-selection list box.  ERROR_INVALID_LB_MESSAGE
			pString = "ERROR_INVALID_LB_MESSAGE";
			break;
		}

		case ERROR_SETCOUNT_ON_BAD_LB:
		{
			// 1433 LB_SETCOUNT sent to non-lazy list box.  ERROR_SETCOUNT_ON_BAD_LB
			pString = "ERROR_SETCOUNT_ON_BAD_LB";
			break;
		}

		case ERROR_LB_WITHOUT_TABSTOPS:
		{
			// 1434 This list box does not support tab stops.  ERROR_LB_WITHOUT_TABSTOPS
			pString = "ERROR_LB_WITHOUT_TABSTOPS";
			break;
		}

		case ERROR_DESTROY_OBJECT_OF_OTHER_THREAD:
		{
			// 1435 Cannot destroy object created by another thread.  ERROR_DESTROY_OBJECT_OF_OTHER_THREAD
			pString = "ERROR_DESTROY_OBJECT_OF_OTHER_THREAD";
			break;
		}

		case ERROR_CHILD_WINDOW_MENU:
		{
			// 1436 Child windows cannot have menus.  ERROR_CHILD_WINDOW_MENU
			pString = "ERROR_CHILD_WINDOW_MENU";
			break;
		}

		case ERROR_NO_SYSTEM_MENU:
		{
			// 1437 The window does not have a system menu.  ERROR_NO_SYSTEM_MENU
			pString = "ERROR_NO_SYSTEM_MENU";
			break;
		}

		case ERROR_INVALID_MSGBOX_STYLE:
		{
			// 1438 Invalid message box style.  ERROR_INVALID_MSGBOX_STYLE
			pString = "ERROR_INVALID_MSGBOX_STYLE";
			break;
		}

		case ERROR_INVALID_SPI_VALUE:
		{
			// 1439 Invalid system-wide (SPI_*) parameter.  ERROR_INVALID_SPI_VALUE
			pString = "ERROR_INVALID_SPI_VALUE";
			break;
		}

		case ERROR_SCREEN_ALREADY_LOCKED:
		{
			// 1440 Screen already locked.  ERROR_SCREEN_ALREADY_LOCKED
			pString = "ERROR_SCREEN_ALREADY_LOCKED";
			break;
		}

		case ERROR_HWNDS_HAVE_DIFF_PARENT:
		{
			// 1441 All handles to windows in a multiple-window position structure must have the same parent.  ERROR_HWNDS_HAVE_DIFF_PARENT
			pString = "ERROR_HWNDS_HAVE_DIFF_PARENT";
			break;
		}

		case ERROR_NOT_CHILD_WINDOW:
		{
			// 1442 The window is not a child window.  ERROR_NOT_CHILD_WINDOW
			pString = "ERROR_NOT_CHILD_WINDOW";
			break;
		}

		case ERROR_INVALID_GW_COMMAND:
		{
			// 1443 Invalid GW_* command.  ERROR_INVALID_GW_COMMAND
			pString = "ERROR_INVALID_GW_COMMAND";
			break;
		}

		case ERROR_INVALID_THREAD_ID:
		{
			// 1444 Invalid thread identifier.  ERROR_INVALID_THREAD_ID
			pString = "ERROR_INVALID_THREAD_ID";
			break;
		}

		case ERROR_NON_MDICHILD_WINDOW:
		{
			// 1445 Cannot process a message from a window that is not a multiple document interface (MDI) window.  ERROR_NON_MDICHILD_WINDOW
			pString = "ERROR_NON_MDICHILD_WINDOW";
			break;
		}

		case ERROR_POPUP_ALREADY_ACTIVE:
		{
			// 1446 Popup menu already active.  ERROR_POPUP_ALREADY_ACTIVE
			pString = "ERROR_POPUP_ALREADY_ACTIVE";
			break;
		}

		case ERROR_NO_SCROLLBARS:
		{
			// 1447 The window does not have scroll bars.  ERROR_NO_SCROLLBARS
			pString = "ERROR_NO_SCROLLBARS";
			break;
		}

		case ERROR_INVALID_SCROLLBAR_RANGE:
		{
			// 1448 Scroll bar range cannot be greater than 0x7FFF.  ERROR_INVALID_SCROLLBAR_RANGE
			pString = "ERROR_INVALID_SCROLLBAR_RANGE";
			break;
		}

		case ERROR_INVALID_SHOWWIN_COMMAND:
		{
			// 1449 Cannot show or remove the window in the way specified.  ERROR_INVALID_SHOWWIN_COMMAND
			pString = "ERROR_INVALID_SHOWWIN_COMMAND";
			break;
		}

		case ERROR_NO_SYSTEM_RESOURCES:
		{
			// 1450 Insufficient system resources exist to complete the requested service.  ERROR_NO_SYSTEM_RESOURCES
			pString = "ERROR_NO_SYSTEM_RESOURCES";
			break;
		}

		case ERROR_NONPAGED_SYSTEM_RESOURCES:
		{
			// 1451 Insufficient system resources exist to complete the requested service.  ERROR_NONPAGED_SYSTEM_RESOURCES
			pString = "ERROR_NONPAGED_SYSTEM_RESOURCES";
			break;
		}

		case ERROR_PAGED_SYSTEM_RESOURCES:
		{
			// 1452 Insufficient system resources exist to complete the requested service.  ERROR_PAGED_SYSTEM_RESOURCES
			pString = "ERROR_PAGED_SYSTEM_RESOURCES";
			break;
		}

		case ERROR_WORKING_SET_QUOTA:
		{
			// 1453 Insufficient quota to complete the requested service.  ERROR_WORKING_SET_QUOTA
			pString = "ERROR_WORKING_SET_QUOTA";
			break;
		}

		case ERROR_PAGEFILE_QUOTA:
		{
			// 1454 Insufficient quota to complete the requested service.  ERROR_PAGEFILE_QUOTA
			pString = "ERROR_PAGEFILE_QUOTA";
			break;
		}

		case ERROR_COMMITMENT_LIMIT:
		{
			// 1455 The paging file is too small for this operation to complete.  ERROR_COMMITMENT_LIMIT
			pString = "ERROR_COMMITMENT_LIMIT";
			break;
		}

		case ERROR_MENU_ITEM_NOT_FOUND:
		{
			// 1456 A menu item was not found.  ERROR_MENU_ITEM_NOT_FOUND
			pString = "ERROR_MENU_ITEM_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_KEYBOARD_HANDLE:
		{
			// 1457 Invalid keyboard layout handle.  ERROR_INVALID_KEYBOARD_HANDLE
			pString = "ERROR_INVALID_KEYBOARD_HANDLE";
			break;
		}

		case ERROR_HOOK_TYPE_NOT_ALLOWED:
		{
			// 1458 Hook type not allowed.  ERROR_HOOK_TYPE_NOT_ALLOWED
			pString = "ERROR_HOOK_TYPE_NOT_ALLOWED";
			break;
		}

		case ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION:
		{
			// 1459 This operation requires an interactive window station.  ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION
			pString = "ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION";
			break;
		}

		case ERROR_TIMEOUT:
		{
			// 1460 This operation returned because the timeout period expired.  ERROR_TIMEOUT
			pString = "ERROR_TIMEOUT";
			break;
		}

		case ERROR_INVALID_MONITOR_HANDLE:
		{
			// 1461 Invalid monitor handle.  ERROR_INVALID_MONITOR_HANDLE
			pString = "ERROR_INVALID_MONITOR_HANDLE";
			break;
		}

		case ERROR_EVENTLOG_FILE_CORRUPT:
		{
			// 1500 The event log file is corrupted.  ERROR_EVENTLOG_FILE_CORRUPT
			pString = "ERROR_EVENTLOG_FILE_CORRUPT";
			break;
		}

		case ERROR_EVENTLOG_CANT_START:
		{
			// 1501 No event log file could be opened, so the event logging service did not start.  ERROR_EVENTLOG_CANT_START
			pString = "ERROR_EVENTLOG_CANT_START";
			break;
		}

		case ERROR_LOG_FILE_FULL:
		{
			// 1502 The event log file is full.  ERROR_LOG_FILE_FULL
			pString = "ERROR_LOG_FILE_FULL";
			break;
		}

		case ERROR_EVENTLOG_FILE_CHANGED:
		{
			// 1503 The event log file has changed between read operations.  ERROR_EVENTLOG_FILE_CHANGED
			pString = "ERROR_EVENTLOG_FILE_CHANGED";
			break;
		}

		#pragma TODO(vanceo, "Temporarily commented out INSTALL_SERVICE so NT build environment will work, figure this out.")
		/*
		//
		case ERROR_INSTALL_SERVICE:
		{
			// 1601 Failure accessing install service.  ERROR_INSTALL_SERVICE
			pString = "ERROR_INSTALL_SERVICE";
			break;
		}
		*/

		case ERROR_INSTALL_USEREXIT:
		{
			// 1602 The user canceled the installation.  ERROR_INSTALL_USEREXIT
			pString = "ERROR_INSTALL_USEREXIT";
			break;
		}

		case ERROR_INSTALL_FAILURE:
		{
			// 1603 Fatal error during installation.  ERROR_INSTALL_FAILURE
			pString = "ERROR_INSTALL_FAILURE";
			break;
		}

		case ERROR_INSTALL_SUSPEND:
		{
			// 1604 Installation suspended, incomplete.  ERROR_INSTALL_SUSPEND
			pString = "ERROR_INSTALL_SUSPEND";
			break;
		}

		case ERROR_UNKNOWN_PRODUCT:
		{
			// 1605 Product code not registered.  ERROR_UNKNOWN_PRODUCT
			pString = "ERROR_UNKNOWN_PRODUCT";
			break;
		}

		case ERROR_UNKNOWN_FEATURE:
		{
			// 1606 Feature ID not registered.  ERROR_UNKNOWN_FEATURE
			pString = "ERROR_UNKNOWN_FEATURE";
			break;
		}

		case ERROR_UNKNOWN_COMPONENT:
		{
			// 1607 Component ID not registered.  ERROR_UNKNOWN_COMPONENT
			pString = "ERROR_UNKNOWN_COMPONENT";
			break;
		}

		case ERROR_UNKNOWN_PROPERTY:
		{
			// 1608 Unknown property.  ERROR_UNKNOWN_PROPERTY
			pString = "ERROR_UNKNOWN_PROPERTY";
			break;
		}

		case ERROR_INVALID_HANDLE_STATE:
		{
			// 1609 Handle is in an invalid state.  ERROR_INVALID_HANDLE_STATE
			pString = "ERROR_INVALID_HANDLE_STATE";
			break;
		}

		case ERROR_BAD_CONFIGURATION:
		{
			// 1610 Configuration data corrupt.  ERROR_BAD_CONFIGURATION
			pString = "ERROR_BAD_CONFIGURATION";
			break;
		}

		case ERROR_INDEX_ABSENT:
		{
			// 1611 Language not available.  ERROR_INDEX_ABSENT
			pString = "ERROR_INDEX_ABSENT";
			break;
		}

		case ERROR_INSTALL_SOURCE_ABSENT:
		{
			// 1612 Install source unavailable.  ERROR_INSTALL_SOURCE_ABSENT
			pString = "ERROR_INSTALL_SOURCE_ABSENT";
			break;
		}

		#pragma TODO(vanceo, "Temporarily commented out BAD_DATABASE_VERSION so NT build environment will work, figure this out.")
		/*
		case ERROR_BAD_DATABASE_VERSION:
		{
			// 1613 Database version unsupported.  ERROR_BAD_DATABASE_VERSION
			pString = "ERROR_BAD_DATABASE_VERSION";
			break;
		}
		*/

		case ERROR_PRODUCT_UNINSTALLED:
		{
			// 1614 Product is uninstalled.  ERROR_PRODUCT_UNINSTALLED
			pString = "ERROR_PRODUCT_UNINSTALLED";
			break;
		}

		case ERROR_BAD_QUERY_SYNTAX:
		{
			// 1615 SQL query syntax invalid or unsupported.  ERROR_BAD_QUERY_SYNTAX
			pString = "ERROR_BAD_QUERY_SYNTAX";
			break;
		}

		case ERROR_INVALID_FIELD:
		{
			// 1616 Record field does not exist.  ERROR_INVALID_FIELD
			pString = "ERROR_INVALID_FIELD";
			break;
		}

		case RPC_S_INVALID_STRING_BINDING:
		{
			// 1700 The string binding is invalid.  RPC_S_INVALID_STRING_BINDING
			pString = "RPC_S_INVALID_STRING_BINDING";
			break;
		}

		case RPC_S_WRONG_KIND_OF_BINDING:
		{
			// 1701 The binding handle is not the correct type.  RPC_S_WRONG_KIND_OF_BINDING
			pString = "RPC_S_WRONG_KIND_OF_BINDING";
			break;
		}

		case RPC_S_INVALID_BINDING:
		{
			// 1702 The binding handle is invalid.  RPC_S_INVALID_BINDING
			pString = "RPC_S_INVALID_BINDING";
			break;
		}

		case RPC_S_PROTSEQ_NOT_SUPPORTED:
		{
			// 1703 The RPC protocol sequence is not supported.  RPC_S_PROTSEQ_NOT_SUPPORTED
			pString = "RPC_S_PROTSEQ_NOT_SUPPORTED";
			break;
		}

		case RPC_S_INVALID_RPC_PROTSEQ:
		{
			// 1704 The RPC protocol sequence is invalid.  RPC_S_INVALID_RPC_PROTSEQ
			pString = "RPC_S_INVALID_RPC_PROTSEQ";
			break;
		}

		case RPC_S_INVALID_STRING_UUID:
		{
			// 1705 The string universal unique identifier (UUID) is invalid.  RPC_S_INVALID_STRING_UUID
			pString = "RPC_S_INVALID_STRING_UUID";
			break;
		}

		case RPC_S_INVALID_ENDPOINT_FORMAT:
		{
			// 1706 The endpoint format is invalid.  RPC_S_INVALID_ENDPOINT_FORMAT
			pString = "RPC_S_INVALID_ENDPOINT_FORMAT";
			break;
		}

		case RPC_S_INVALID_NET_ADDR:
		{
			// 1707 The network address is invalid.  RPC_S_INVALID_NET_ADDR
			pString = "RPC_S_INVALID_NET_ADDR";
			break;
		}

		case RPC_S_NO_ENDPOINT_FOUND:
		{
			// 1708 No endpoint was found.  RPC_S_NO_ENDPOINT_FOUND
			pString = "RPC_S_NO_ENDPOINT_FOUND";
			break;
		}

		case RPC_S_INVALID_TIMEOUT:
		{
			// 1709 The timeout value is invalid.  RPC_S_INVALID_TIMEOUT
			pString = "RPC_S_INVALID_TIMEOUT";
			break;
		}

		case RPC_S_OBJECT_NOT_FOUND:
		{
			// 1710 The object universal unique identifier (UUID) was not found.  RPC_S_OBJECT_NOT_FOUND
			pString = "RPC_S_OBJECT_NOT_FOUND";
			break;
		}

		case RPC_S_ALREADY_REGISTERED:
		{
			// 1711 The object universal unique identifier (UUID) has already been registered.  RPC_S_ALREADY_REGISTERED
			pString = "RPC_S_ALREADY_REGISTERED";
			break;
		}

		case RPC_S_TYPE_ALREADY_REGISTERED:
		{
			// 1712 The type universal unique identifier (UUID) has already been registered.  RPC_S_TYPE_ALREADY_REGISTERED
			pString = "RPC_S_TYPE_ALREADY_REGISTERED";
			break;
		}

		case RPC_S_ALREADY_LISTENING:
		{
			// 1713 The RPC server is already listening.  RPC_S_ALREADY_LISTENING
			pString = "RPC_S_ALREADY_LISTENING";
			break;
		}

		case RPC_S_NO_PROTSEQS_REGISTERED:
		{
			// 1714 No protocol sequences have been registered.  RPC_S_NO_PROTSEQS_REGISTERED
			pString = "RPC_S_NO_PROTSEQS_REGISTERED";
			break;
		}

		case RPC_S_NOT_LISTENING:
		{
			// 1715 The RPC server is not listening.  RPC_S_NOT_LISTENING
			pString = "RPC_S_NOT_LISTENING";
			break;
		}

		case RPC_S_UNKNOWN_MGR_TYPE:
		{
			// 1716 The manager type is unknown.  RPC_S_UNKNOWN_MGR_TYPE
			pString = "RPC_S_UNKNOWN_MGR_TYPE";
			break;
		}

		case RPC_S_UNKNOWN_IF:
		{
			// 1717 The interface is unknown.  RPC_S_UNKNOWN_IF
			pString = "RPC_S_UNKNOWN_IF";
			break;
		}

		case RPC_S_NO_BINDINGS:
		{
			// 1718 There are no bindings.  RPC_S_NO_BINDINGS
			pString = "RPC_S_NO_BINDINGS";
			break;
		}

		case RPC_S_NO_PROTSEQS:
		{
			// 1719 There are no protocol sequences.  RPC_S_NO_PROTSEQS
			pString = "RPC_S_NO_PROTSEQS";
			break;
		}

		case RPC_S_CANT_CREATE_ENDPOINT:
		{
			// 1720 The endpoint cannot be created.  RPC_S_CANT_CREATE_ENDPOINT
			pString = "RPC_S_CANT_CREATE_ENDPOINT";
			break;
		}

		case RPC_S_OUT_OF_RESOURCES:
		{
			// 1721 Not enough resources are available to complete this operation.  RPC_S_OUT_OF_RESOURCES
			pString = "RPC_S_OUT_OF_RESOURCES";
			break;
		}

		case RPC_S_SERVER_UNAVAILABLE:
		{
			// 1722 The RPC server is unavailable.  RPC_S_SERVER_UNAVAILABLE
			pString = "RPC_S_SERVER_UNAVAILABLE";
			break;
		}

		case RPC_S_SERVER_TOO_BUSY:
		{
			// 1723 The RPC server is too busy to complete this operation.  RPC_S_SERVER_TOO_BUSY
			pString = "RPC_S_SERVER_TOO_BUSY";
			break;
		}

		case RPC_S_INVALID_NETWORK_OPTIONS:
		{
			// 1724 The network options are invalid.  RPC_S_INVALID_NETWORK_OPTIONS
			pString = "RPC_S_INVALID_NETWORK_OPTIONS";
			break;
		}

		case RPC_S_NO_CALL_ACTIVE:
		{
			// 1725 There are no remote procedure calls active on this thread.  RPC_S_NO_CALL_ACTIVE
			pString = "RPC_S_NO_CALL_ACTIVE";
			break;
		}

		case RPC_S_CALL_FAILED:
		{
			// 1726 The remote procedure call failed.  RPC_S_CALL_FAILED
			pString = "RPC_S_CALL_FAILED";
			break;
		}

		case RPC_S_CALL_FAILED_DNE:
		{
			// 1727 The remote procedure call failed and did not execute.  RPC_S_CALL_FAILED_DNE
			pString = "RPC_S_CALL_FAILED_DNE";
			break;
		}

		case RPC_S_PROTOCOL_ERROR:
		{
			// 1728 A remote procedure call (RPC) protocol error occurred.  RPC_S_PROTOCOL_ERROR
			pString = "RPC_S_PROTOCOL_ERROR";
			break;
		}

		case RPC_S_UNSUPPORTED_TRANS_SYN:
		{
			// 1730 The transfer syntax is not supported by the RPC server.  RPC_S_UNSUPPORTED_TRANS_SYN
			pString = "RPC_S_UNSUPPORTED_TRANS_SYN";
			break;
		}

		case RPC_S_UNSUPPORTED_TYPE:
		{
			// 1732 The universal unique identifier (UUID) type is not supported.  RPC_S_UNSUPPORTED_TYPE
			pString = "RPC_S_UNSUPPORTED_TYPE";
			break;
		}

		case RPC_S_INVALID_TAG:
		{
			// 1733 The tag is invalid.  RPC_S_INVALID_TAG
			pString = "RPC_S_INVALID_TAG";
			break;
		}

		case RPC_S_INVALID_BOUND:
		{
			// 1734 The array bounds are invalid.  RPC_S_INVALID_BOUND
			pString = "RPC_S_INVALID_BOUND";
			break;
		}

		case RPC_S_NO_ENTRY_NAME:
		{
			// 1735 The binding does not contain an entry name.  RPC_S_NO_ENTRY_NAME
			pString = "RPC_S_NO_ENTRY_NAME";
			break;
		}

		case RPC_S_INVALID_NAME_SYNTAX:
		{
			// 1736 The name syntax is invalid.  RPC_S_INVALID_NAME_SYNTAX
			pString = "RPC_S_INVALID_NAME_SYNTAX";
			break;
		}

		case RPC_S_UNSUPPORTED_NAME_SYNTAX:
		{
			// 1737 The name syntax is not supported.  RPC_S_UNSUPPORTED_NAME_SYNTAX
			pString = "RPC_S_UNSUPPORTED_NAME_SYNTAX";
			break;
		}

		case RPC_S_UUID_NO_ADDRESS:
		{
			// 1739 No network address is available to use to construct a universal unique identifier (UUID).  RPC_S_UUID_NO_ADDRESS
			pString = "RPC_S_UUID_NO_ADDRESS";
			break;
		}

		case RPC_S_DUPLICATE_ENDPOINT:
		{
			// 1740 The endpoint is a duplicate.  RPC_S_DUPLICATE_ENDPOINT
			pString = "RPC_S_DUPLICATE_ENDPOINT";
			break;
		}

		case RPC_S_UNKNOWN_AUTHN_TYPE:
		{
			// 1741 The authentication type is unknown.  RPC_S_UNKNOWN_AUTHN_TYPE
			pString = "RPC_S_UNKNOWN_AUTHN_TYPE";
			break;
		}

		case RPC_S_MAX_CALLS_TOO_SMALL:
		{
			// 1742 The maximum number of calls is too small.  RPC_S_MAX_CALLS_TOO_SMALL
			pString = "RPC_S_MAX_CALLS_TOO_SMALL";
			break;
		}

		case RPC_S_STRING_TOO_LONG:
		{
			// 1743 The string is too long.  RPC_S_STRING_TOO_LONG
			pString = "RPC_S_STRING_TOO_LONG";
			break;
		}

		case RPC_S_PROTSEQ_NOT_FOUND:
		{
			// 1744 The RPC protocol sequence was not found.  RPC_S_PROTSEQ_NOT_FOUND
			pString = "RPC_S_PROTSEQ_NOT_FOUND";
			break;
		}

		case RPC_S_PROCNUM_OUT_OF_RANGE:
		{
			// 1745 The procedure number is out of range.  RPC_S_PROCNUM_OUT_OF_RANGE
			pString = "RPC_S_PROCNUM_OUT_OF_RANGE";
			break;
		}

		case RPC_S_BINDING_HAS_NO_AUTH:
		{
			// 1746 The binding does not contain any authentication information.  RPC_S_BINDING_HAS_NO_AUTH
			pString = "RPC_S_BINDING_HAS_NO_AUTH";
			break;
		}

		case RPC_S_UNKNOWN_AUTHN_SERVICE:
		{
			// 1747 The authentication service is unknown.  RPC_S_UNKNOWN_AUTHN_SERVICE
			pString = "RPC_S_UNKNOWN_AUTHN_SERVICE";
			break;
		}

		case RPC_S_UNKNOWN_AUTHN_LEVEL:
		{
			// 1748 The authentication level is unknown.  RPC_S_UNKNOWN_AUTHN_LEVEL
			pString = "RPC_S_UNKNOWN_AUTHN_LEVEL";
			break;
		}

		case RPC_S_INVALID_AUTH_IDENTITY:
		{
			// 1749 The security context is invalid.  RPC_S_INVALID_AUTH_IDENTITY
			pString = "RPC_S_INVALID_AUTH_IDENTITY";
			break;
		}

		case RPC_S_UNKNOWN_AUTHZ_SERVICE:
		{
			// 1750 The authorization service is unknown.  RPC_S_UNKNOWN_AUTHZ_SERVICE
			pString = "RPC_S_UNKNOWN_AUTHZ_SERVICE";
			break;
		}

		case EPT_S_INVALID_ENTRY:
		{
			// 1751 The entry is invalid.  EPT_S_INVALID_ENTRY
			pString = "EPT_S_INVALID_ENTRY";
			break;
		}

		case EPT_S_CANT_PERFORM_OP:
		{
			// 1752 The server endpoint cannot perform the operation.  EPT_S_CANT_PERFORM_OP
			pString = "EPT_S_CANT_PERFORM_OP";
			break;
		}

		case EPT_S_NOT_REGISTERED:
		{
			// 1753 There are no more endpoints available from the endpoint mapper.  EPT_S_NOT_REGISTERED
			pString = "EPT_S_NOT_REGISTERED";
			break;
		}

		case RPC_S_NOTHING_TO_EXPORT:
		{
			// 1754 No interfaces have been exported.  RPC_S_NOTHING_TO_EXPORT
			pString = "RPC_S_NOTHING_TO_EXPORT";
			break;
		}

		case RPC_S_INCOMPLETE_NAME:
		{
			// 1755 The entry name is incomplete.  RPC_S_INCOMPLETE_NAME
			pString = "RPC_S_INCOMPLETE_NAME";
			break;
		}

		case RPC_S_INVALID_VERS_OPTION:
		{
			// 1756 The version option is invalid.  RPC_S_INVALID_VERS_OPTION
			pString = "RPC_S_INVALID_VERS_OPTION";
			break;
		}

		case RPC_S_NO_MORE_MEMBERS:
		{
			// 1757 There are no more members.  RPC_S_NO_MORE_MEMBERS
			pString = "RPC_S_NO_MORE_MEMBERS";
			break;
		}

		case RPC_S_NOT_ALL_OBJS_UNEXPORTED:
		{
			// 1758 There is nothing to unexport.  RPC_S_NOT_ALL_OBJS_UNEXPORTED
			pString = "RPC_S_NOT_ALL_OBJS_UNEXPORTED";
			break;
		}

		case RPC_S_INTERFACE_NOT_FOUND:
		{
			// 1759 The interface was not found.  RPC_S_INTERFACE_NOT_FOUND
			pString = "RPC_S_INTERFACE_NOT_FOUND";
			break;
		}

		case RPC_S_ENTRY_ALREADY_EXISTS:
		{
			// 1760 The entry already exists.  RPC_S_ENTRY_ALREADY_EXISTS
			pString = "RPC_S_ENTRY_ALREADY_EXISTS";
			break;
		}

		case RPC_S_ENTRY_NOT_FOUND:
		{
			// 1761 The entry is not found.  RPC_S_ENTRY_NOT_FOUND
			pString = "RPC_S_ENTRY_NOT_FOUND";
			break;
		}

		case RPC_S_NAME_SERVICE_UNAVAILABLE:
		{
			// 1762 The name service is unavailable.  RPC_S_NAME_SERVICE_UNAVAILABLE
			pString = "RPC_S_NAME_SERVICE_UNAVAILABLE";
			break;
		}

		case RPC_S_INVALID_NAF_ID:
		{
			// 1763 The network address family is invalid.  RPC_S_INVALID_NAF_ID
			pString = "RPC_S_INVALID_NAF_ID";
			break;
		}

		case RPC_S_CANNOT_SUPPORT:
		{
			// 1764 The requested operation is not supported.  RPC_S_CANNOT_SUPPORT
			pString = "RPC_S_CANNOT_SUPPORT";
			break;
		}

		case RPC_S_NO_CONTEXT_AVAILABLE:
		{
			// 1765 No security context is available to allow impersonation.  RPC_S_NO_CONTEXT_AVAILABLE
			pString = "RPC_S_NO_CONTEXT_AVAILABLE";
			break;
		}

		case RPC_S_INTERNAL_ERROR:
		{
			// 1766 An internal error occurred in a remote procedure call (RPC).  RPC_S_INTERNAL_ERROR
			pString = "RPC_S_INTERNAL_ERROR";
			break;
		}

		case RPC_S_ZERO_DIVIDE:
		{
			// 1767 The RPC server attempted an integer division by zero.  RPC_S_ZERO_DIVIDE
			pString = "RPC_S_ZERO_DIVIDE";
			break;
		}

		case RPC_S_ADDRESS_ERROR:
		{
			// 1768 An addressing error occurred in the RPC server.  RPC_S_ADDRESS_ERROR
			pString = "RPC_S_ADDRESS_ERROR";
			break;
		}

		case RPC_S_FP_DIV_ZERO:
		{
			// 1769 A floating-point operation at the RPC server caused a division by zero.  RPC_S_FP_DIV_ZERO
			pString = "RPC_S_FP_DIV_ZERO";
			break;
		}

		case RPC_S_FP_UNDERFLOW:
		{
			// 1770 A floating-point underflow occurred at the RPC server.  RPC_S_FP_UNDERFLOW
			pString = "RPC_S_FP_UNDERFLOW";
			break;
		}

		case RPC_S_FP_OVERFLOW:
		{
			// 1771 A floating-point overflow occurred at the RPC server.  RPC_S_FP_OVERFLOW
			pString = "RPC_S_FP_OVERFLOW";
			break;
		}

		case RPC_X_NO_MORE_ENTRIES:
		{
			// 1772 The list of RPC servers available for the binding of auto handles has been exhausted.  RPC_X_NO_MORE_ENTRIES
			pString = "RPC_X_NO_MORE_ENTRIES";
			break;
		}

		case RPC_X_SS_CHAR_TRANS_OPEN_FAIL:
		{
			// 1773 Unable to open the character translation table file.  RPC_X_SS_CHAR_TRANS_OPEN_FAIL
			pString = "RPC_X_SS_CHAR_TRANS_OPEN_FAIL";
			break;
		}

		case RPC_X_SS_CHAR_TRANS_SHORT_FILE:
		{
			// 1774 The file containing the character translation table has fewer than bytes.  RPC_X_SS_CHAR_TRANS_SHORT_FILE
			pString = "RPC_X_SS_CHAR_TRANS_SHORT_FILE";
			break;
		}

		case RPC_X_SS_IN_NULL_CONTEXT:
		{
			// 1775 A null context handle was passed from the client to the host during a remote procedure call.  RPC_X_SS_IN_NULL_CONTEXT
			pString = "RPC_X_SS_IN_NULL_CONTEXT";
			break;
		}

		case RPC_X_SS_CONTEXT_DAMAGED:
		{
			// 1777 The context handle changed during a remote procedure call.  RPC_X_SS_CONTEXT_DAMAGED
			pString = "RPC_X_SS_CONTEXT_DAMAGED";
			break;
		}

		case RPC_X_SS_HANDLES_MISMATCH:
		{
			// 1778 The binding handles passed to a remote procedure call do not match.  RPC_X_SS_HANDLES_MISMATCH
			pString = "RPC_X_SS_HANDLES_MISMATCH";
			break;
		}

		case RPC_X_SS_CANNOT_GET_CALL_HANDLE:
		{
			// 1779 The stub is unable to get the remote procedure call handle.  RPC_X_SS_CANNOT_GET_CALL_HANDLE
			pString = "RPC_X_SS_CANNOT_GET_CALL_HANDLE";
			break;
		}

		case RPC_X_NULL_REF_POINTER:
		{
			// 1780 A null reference pointer was passed to the stub.  RPC_X_NULL_REF_POINTER
			pString = "RPC_X_NULL_REF_POINTER";
			break;
		}

		case RPC_X_ENUM_VALUE_OUT_OF_RANGE:
		{
			// 1781 The enumeration value is out of range.  RPC_X_ENUM_VALUE_OUT_OF_RANGE
			pString = "RPC_X_ENUM_VALUE_OUT_OF_RANGE";
			break;
		}

		case RPC_X_BYTE_COUNT_TOO_SMALL:
		{
			// 1782 The byte count is too small.  RPC_X_BYTE_COUNT_TOO_SMALL
			pString = "RPC_X_BYTE_COUNT_TOO_SMALL";
			break;
		}

		case RPC_X_BAD_STUB_DATA:
		{
			// 1783 The stub received bad data.  RPC_X_BAD_STUB_DATA
			pString = "RPC_X_BAD_STUB_DATA";
			break;
		}

		case ERROR_INVALID_USER_BUFFER:
		{
			// 1784 The supplied user buffer is not valid for the requested operation.  ERROR_INVALID_USER_BUFFER
			pString = "ERROR_INVALID_USER_BUFFER";
			break;
		}

		case ERROR_UNRECOGNIZED_MEDIA:
		{
			// 1785 The disk media is not recognized. It may not be formatted.  ERROR_UNRECOGNIZED_MEDIA
			pString = "ERROR_UNRECOGNIZED_MEDIA";
			break;
		}

		case ERROR_NO_TRUST_LSA_SECRET:
		{
			// 1786 The workstation does not have a trust secret.  ERROR_NO_TRUST_LSA_SECRET
			pString = "ERROR_NO_TRUST_LSA_SECRET";
			break;
		}

		case ERROR_NO_TRUST_SAM_ACCOUNT:
		{
			// 1787 The SAM database on the Windows NT Server does not have a computer account for this workstation trust relationship.  ERROR_NO_TRUST_SAM_ACCOUNT
			pString = "ERROR_NO_TRUST_SAM_ACCOUNT";
			break;
		}

		case ERROR_TRUSTED_DOMAIN_FAILURE:
		{
			// 1788 The trust relationship between the primary domain and the trusted domain failed.  ERROR_TRUSTED_DOMAIN_FAILURE
			pString = "ERROR_TRUSTED_DOMAIN_FAILURE";
			break;
		}

		case ERROR_TRUSTED_RELATIONSHIP_FAILURE:
		{
			// 1789 The trust relationship between this workstation and the primary domain failed.  ERROR_TRUSTED_RELATIONSHIP_FAILURE
			pString = "ERROR_TRUSTED_RELATIONSHIP_FAILURE";
			break;
		}

		case ERROR_TRUST_FAILURE:
		{
			// 1790 The network logon failed.  ERROR_TRUST_FAILURE
			pString = "ERROR_TRUST_FAILURE";
			break;
		}

		case RPC_S_CALL_IN_PROGRESS:
		{
			// 1791 A remote procedure call is already in progress for this thread.  RPC_S_CALL_IN_PROGRESS
			pString = "RPC_S_CALL_IN_PROGRESS";
			break;
		}

		case ERROR_NETLOGON_NOT_STARTED:
		{
			// 1792 An attempt was made to logon, but the network logon service was not started.  ERROR_NETLOGON_NOT_STARTED
			pString = "ERROR_NETLOGON_NOT_STARTED";
			break;
		}

		case ERROR_ACCOUNT_EXPIRED:
		{
			// 1793 The user's account has expired.  ERROR_ACCOUNT_EXPIRED
			pString = "ERROR_ACCOUNT_EXPIRED";
			break;
		}

		case ERROR_REDIRECTOR_HAS_OPEN_HANDLES:
		{
			// 1794 The redirector is in use and cannot be unloaded.  ERROR_REDIRECTOR_HAS_OPEN_HANDLES
			pString = "ERROR_REDIRECTOR_HAS_OPEN_HANDLES";
			break;
		}

		case ERROR_PRINTER_DRIVER_ALREADY_INSTALLED:
		{
			// 1795 The specified printer driver is already installed.  ERROR_PRINTER_DRIVER_ALREADY_INSTALLED
			pString = "ERROR_PRINTER_DRIVER_ALREADY_INSTALLED";
			break;
		}

		case ERROR_UNKNOWN_PORT:
		{
			// 1796 The specified port is unknown.  ERROR_UNKNOWN_PORT
			pString = "ERROR_UNKNOWN_PORT";
			break;
		}

		case ERROR_UNKNOWN_PRINTER_DRIVER:
		{
			// 1797 The printer driver is unknown.  ERROR_UNKNOWN_PRINTER_DRIVER
			pString = "ERROR_UNKNOWN_PRINTER_DRIVER";
			break;
		}

		case ERROR_UNKNOWN_PRINTPROCESSOR:
		{
			// 1798 The print processor is unknown.  ERROR_UNKNOWN_PRINTPROCESSOR
			pString = "ERROR_UNKNOWN_PRINTPROCESSOR";
			break;
		}

		case ERROR_INVALID_SEPARATOR_FILE:
		{
			// 1799 The specified separator file is invalid.  ERROR_INVALID_SEPARATOR_FILE
			pString = "ERROR_INVALID_SEPARATOR_FILE";
			break;
		}

		case ERROR_INVALID_PRIORITY:
		{
			// 1800 The specified priority is invalid.  ERROR_INVALID_PRIORITY
			pString = "ERROR_INVALID_PRIORITY";
			break;
		}

		case ERROR_INVALID_PRINTER_NAME:
		{
			// 1801 The printer name is invalid.  ERROR_INVALID_PRINTER_NAME
			pString = "ERROR_INVALID_PRINTER_NAME";
			break;
		}

		case ERROR_PRINTER_ALREADY_EXISTS:
		{
			// 1802 The printer already exists.  ERROR_PRINTER_ALREADY_EXISTS
			pString = "ERROR_PRINTER_ALREADY_EXISTS";
			break;
		}

		case ERROR_INVALID_PRINTER_COMMAND:
		{
			// 1803 The printer command is invalid.  ERROR_INVALID_PRINTER_COMMAND
			pString = "ERROR_INVALID_PRINTER_COMMAND";
			break;
		}

		case ERROR_INVALID_DATATYPE:
		{
			// 1804 The specified datatype is invalid.  ERROR_INVALID_DATATYPE
			pString = "ERROR_INVALID_DATATYPE";
			break;
		}

		case ERROR_INVALID_ENVIRONMENT:
		{
			// 1805 The environment specified is invalid.  ERROR_INVALID_ENVIRONMENT
			pString = "ERROR_INVALID_ENVIRONMENT";
			break;
		}

		case RPC_S_NO_MORE_BINDINGS:
		{
			// 1806 There are no more bindings.  RPC_S_NO_MORE_BINDINGS
			pString = "RPC_S_NO_MORE_BINDINGS";
			break;
		}

		case ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT:
		{
			// 1807 The account used is an interdomain trust account. Use your global user account or local user account to access this server.  ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
			pString = "ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT";
			break;
		}

		case ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT:
		{
			// 1808 The account used is a computer account. Use your global user account or local user account to access this server.  ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT
			pString = "ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT";
			break;
		}

		case ERROR_NOLOGON_SERVER_TRUST_ACCOUNT:
		{
			// 1809 The account used is a server trust account. Use your global user account or local user account to access this server.  ERROR_NOLOGON_SERVER_TRUST_ACCOUNT
			pString = "ERROR_NOLOGON_SERVER_TRUST_ACCOUNT";
			break;
		}

		case ERROR_DOMAIN_TRUST_INCONSISTENT:
		{
			// 1810 The name or security ID (SID) of the domain specified is inconsistent with the trust information for that domain.  ERROR_DOMAIN_TRUST_INCONSISTENT
			pString = "ERROR_DOMAIN_TRUST_INCONSISTENT";
			break;
		}

		case ERROR_SERVER_HAS_OPEN_HANDLES:
		{
			// 1811 The server is in use and cannot be unloaded.  ERROR_SERVER_HAS_OPEN_HANDLES
			pString = "ERROR_SERVER_HAS_OPEN_HANDLES";
			break;
		}

		case ERROR_RESOURCE_DATA_NOT_FOUND:
		{
			// 1812 The specified image file did not contain a resource section.  ERROR_RESOURCE_DATA_NOT_FOUND
			pString = "ERROR_RESOURCE_DATA_NOT_FOUND";
			break;
		}

		case ERROR_RESOURCE_TYPE_NOT_FOUND:
		{
			// 1813 The specified resource type cannot be found in the image file.  ERROR_RESOURCE_TYPE_NOT_FOUND
			pString = "ERROR_RESOURCE_TYPE_NOT_FOUND";
			break;
		}

		case ERROR_RESOURCE_NAME_NOT_FOUND:
		{
			// 1814 The specified resource name cannot be found in the image file.  ERROR_RESOURCE_NAME_NOT_FOUND
			pString = "ERROR_RESOURCE_NAME_NOT_FOUND";
			break;
		}

		case ERROR_RESOURCE_LANG_NOT_FOUND:
		{
			// 1815 The specified resource language ID cannot be found in the image file.  ERROR_RESOURCE_LANG_NOT_FOUND
			pString = "ERROR_RESOURCE_LANG_NOT_FOUND";
			break;
		}

		case ERROR_NOT_ENOUGH_QUOTA:
		{
			// 1816 Not enough quota is available to process this command.  ERROR_NOT_ENOUGH_QUOTA
			pString = "ERROR_NOT_ENOUGH_QUOTA";
			break;
		}

		case RPC_S_NO_INTERFACES:
		{
			// 1817 No interfaces have been registered.  RPC_S_NO_INTERFACES
			pString = "RPC_S_NO_INTERFACES";
			break;
		}

		case RPC_S_CALL_CANCELLED:
		{
			// 1818 The remote procedure call was cancelled.  RPC_S_CALL_CANCELLED
			pString = "RPC_S_CALL_CANCELLED";
			break;
		}

		case RPC_S_BINDING_INCOMPLETE:
		{
			// 1819 The binding handle does not contain all required information.  RPC_S_BINDING_INCOMPLETE
			pString = "RPC_S_BINDING_INCOMPLETE";
			break;
		}

		case RPC_S_COMM_FAILURE:
		{
			// 1820 A communications failure occurred during a remote procedure call.  RPC_S_COMM_FAILURE
			pString = "RPC_S_COMM_FAILURE";
			break;
		}

		case RPC_S_UNSUPPORTED_AUTHN_LEVEL:
		{
			// 1821 The requested authentication level is not supported.  RPC_S_UNSUPPORTED_AUTHN_LEVEL
			pString = "RPC_S_UNSUPPORTED_AUTHN_LEVEL";
			break;
		}

		case RPC_S_NO_PRINC_NAME:
		{
			// 1822 No principal name registered.  RPC_S_NO_PRINC_NAME
			pString = "RPC_S_NO_PRINC_NAME";
			break;
		}

		case RPC_S_NOT_RPC_ERROR:
		{
			// 1823 The error specified is not a valid Windows RPC error code.  RPC_S_NOT_RPC_ERROR
			pString = "RPC_S_NOT_RPC_ERROR";
			break;
		}

		case RPC_S_UUID_LOCAL_ONLY:
		{
			// 1824 A UUID that is valid only on this computer has been allocated.  RPC_S_UUID_LOCAL_ONLY
			pString = "RPC_S_UUID_LOCAL_ONLY";
			break;
		}

		case RPC_S_SEC_PKG_ERROR:
		{
			// 1825 A security package specific error occurred.  RPC_S_SEC_PKG_ERROR
			pString = "RPC_S_SEC_PKG_ERROR";
			break;
		}

		case RPC_S_NOT_CANCELLED:
		{
			// 1826 Thread is not canceled.  RPC_S_NOT_CANCELLED
			pString = "RPC_S_NOT_CANCELLED";
			break;
		}

		case RPC_X_INVALID_ES_ACTION:
		{
			// 1827 Invalid operation on the encoding/decoding handle.  RPC_X_INVALID_ES_ACTION
			pString = "RPC_X_INVALID_ES_ACTION";
			break;
		}

		case RPC_X_WRONG_ES_VERSION:
		{
			// 1828 Incompatible version of the serializing package.  RPC_X_WRONG_ES_VERSION
			pString = "RPC_X_WRONG_ES_VERSION";
			break;
		}

		case RPC_X_WRONG_STUB_VERSION:
		{
			// 1829 Incompatible version of the RPC stub.  RPC_X_WRONG_STUB_VERSION
			pString = "RPC_X_WRONG_STUB_VERSION";
			break;
		}

		case RPC_X_INVALID_PIPE_OBJECT:
		{
			// 1830 The RPC pipe object is invalid or corrupted.  RPC_X_INVALID_PIPE_OBJECT
			pString = "RPC_X_INVALID_PIPE_OBJECT";
			break;
		}

		case RPC_X_WRONG_PIPE_ORDER:
		{
			// 1831 An invalid operation was attempted on an RPC pipe object.  RPC_X_WRONG_PIPE_ORDER
			pString = "RPC_X_WRONG_PIPE_ORDER";
			break;
		}

		case RPC_X_WRONG_PIPE_VERSION:
		{
			// 1832 Unsupported RPC pipe version.  RPC_X_WRONG_PIPE_VERSION
			pString = "RPC_X_WRONG_PIPE_VERSION";
			break;
		}

		case RPC_S_GROUP_MEMBER_NOT_FOUND:
		{
			// 1898 The group member was not found.  RPC_S_GROUP_MEMBER_NOT_FOUND
			pString = "RPC_S_GROUP_MEMBER_NOT_FOUND";
			break;
		}

		case EPT_S_CANT_CREATE:
		{
			// 1899 The endpoint mapper database entry could not be created.  EPT_S_CANT_CREATE
			pString = "EPT_S_CANT_CREATE";
			break;
		}

		case RPC_S_INVALID_OBJECT:
		{
			// 1900 The object universal unique identifier (UUID) is the nil UUID.  RPC_S_INVALID_OBJECT
			pString = "RPC_S_INVALID_OBJECT";
			break;
		}

		case ERROR_INVALID_TIME:
		{
			// 1901 The specified time is invalid.  ERROR_INVALID_TIME
			pString = "ERROR_INVALID_TIME";
			break;
		}

		case ERROR_INVALID_FORM_NAME:
		{
			// 1902 The specified form name is invalid.  ERROR_INVALID_FORM_NAME
			pString = "ERROR_INVALID_FORM_NAME";
			break;
		}

		case ERROR_INVALID_FORM_SIZE:
		{
			// 1903 The specified form size is invalid.  ERROR_INVALID_FORM_SIZE
			pString = "ERROR_INVALID_FORM_SIZE";
			break;
		}

		case ERROR_ALREADY_WAITING:
		{
			// 1904 The specified printer handle is already being waited on  ERROR_ALREADY_WAITING
			pString = "ERROR_ALREADY_WAITING";
			break;
		}

		case ERROR_PRINTER_DELETED:
		{
			// 1905 The specified printer has been deleted.  ERROR_PRINTER_DELETED
			pString = "ERROR_PRINTER_DELETED";
			break;
		}

		case ERROR_INVALID_PRINTER_STATE:
		{
			// 1906 The state of the printer is invalid.  ERROR_INVALID_PRINTER_STATE
			pString = "ERROR_INVALID_PRINTER_STATE";
			break;
		}

		case ERROR_PASSWORD_MUST_CHANGE:
		{
			// 1907 The user must change his password before he logs on the first time.  ERROR_PASSWORD_MUST_CHANGE
			pString = "ERROR_PASSWORD_MUST_CHANGE";
			break;
		}

		case ERROR_DOMAIN_CONTROLLER_NOT_FOUND:
		{
			// 1908 Could not find the domain controller for this domain.  ERROR_DOMAIN_CONTROLLER_NOT_FOUND
			pString = "ERROR_DOMAIN_CONTROLLER_NOT_FOUND";
			break;
		}

		case ERROR_ACCOUNT_LOCKED_OUT:
		{
			// 1909 The referenced account is currently locked out and may not be logged on to.  ERROR_ACCOUNT_LOCKED_OUT
			pString = "ERROR_ACCOUNT_LOCKED_OUT";
			break;
		}

		case OR_INVALID_OXID:
		{
			// 1910 The object exporter specified was not found.  OR_INVALID_OXID
			pString = "OR_INVALID_OXID";
			break;
		}

		case OR_INVALID_OID:
		{
			// 1911 The object specified was not found.  OR_INVALID_OID
			pString = "OR_INVALID_OID";
			break;
		}

		case OR_INVALID_SET:
		{
			// 1912 The object resolver set specified was not found.  OR_INVALID_SET
			pString = "OR_INVALID_SET";
			break;
		}

		case RPC_S_SEND_INCOMPLETE:
		{
			// 1913 Some data remains to be sent in the request buffer.  RPC_S_SEND_INCOMPLETE
			pString = "RPC_S_SEND_INCOMPLETE";
			break;
		}

		case RPC_S_INVALID_ASYNC_HANDLE:
		{
			// 1914 Invalid asynchronous remote procedure call handle.  RPC_S_INVALID_ASYNC_HANDLE
			pString = "RPC_S_INVALID_ASYNC_HANDLE";
			break;
		}

		case RPC_S_INVALID_ASYNC_CALL:
		{
			// 1915 Invalid asynchronous RPC call handle for this operation.  RPC_S_INVALID_ASYNC_CALL
			pString = "RPC_S_INVALID_ASYNC_CALL";
			break;
		}

		case RPC_X_PIPE_CLOSED:
		{
			// 1916 The RPC pipe object has already been closed.  RPC_X_PIPE_CLOSED
			pString = "RPC_X_PIPE_CLOSED";
			break;
		}

		case RPC_X_PIPE_DISCIPLINE_ERROR:
		{
			// 1917 The RPC call completed before all pipes were processed.  RPC_X_PIPE_DISCIPLINE_ERROR
			pString = "RPC_X_PIPE_DISCIPLINE_ERROR";
			break;
		}

		case RPC_X_PIPE_EMPTY:
		{
			// 1918 No more data is available from the RPC pipe.  RPC_X_PIPE_EMPTY
			pString = "RPC_X_PIPE_EMPTY";
			break;
		}

		case ERROR_NO_SITENAME:
		{
			// 1919 No site name is available for this machine.  ERROR_NO_SITENAME
			pString = "ERROR_NO_SITENAME";
			break;
		}

		case ERROR_CANT_ACCESS_FILE:
		{
			// 1920 The file can not be accessed by the system.  ERROR_CANT_ACCESS_FILE
			pString = "ERROR_CANT_ACCESS_FILE";
			break;
		}

		case ERROR_CANT_RESOLVE_FILENAME:
		{
			// 1921 The name of the file cannot be resolved by the system.  ERROR_CANT_RESOLVE_FILENAME
			pString = "ERROR_CANT_RESOLVE_FILENAME";
			break;
		}

		case ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY:
		{
			// 1922 The directory service evaluated group memberships locally.  ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY
			pString = "ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY";
			break;
		}

		case ERROR_DS_NO_ATTRIBUTE_OR_VALUE:
		{
			// 1923 The specified directory service attribute or value does not exist.  ERROR_DS_NO_ATTRIBUTE_OR_VALUE
			pString = "ERROR_DS_NO_ATTRIBUTE_OR_VALUE";
			break;
		}

		case ERROR_DS_INVALID_ATTRIBUTE_SYNTAX:
		{
			// 1924 The attribute syntax specified to the directory service is invalid.  ERROR_DS_INVALID_ATTRIBUTE_SYNTAX
			pString = "ERROR_DS_INVALID_ATTRIBUTE_SYNTAX";
			break;
		}

		case ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED:
		{
			// 1925 The attribute type specified to the directory service is not defined.  ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED
			pString = "ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED";
			break;
		}

		case ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS:
		{
			// 1926 The specified directory service attribute or value already exists.  ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS
			pString = "ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS";
			break;
		}

		case ERROR_DS_BUSY:
		{
			// 1927 The directory service is busy.  ERROR_DS_BUSY
			pString = "ERROR_DS_BUSY";
			break;
		}

		case ERROR_DS_UNAVAILABLE:
		{
			// 1928 The directory service is unavailable.  ERROR_DS_UNAVAILABLE
			pString = "ERROR_DS_UNAVAILABLE";
			break;
		}

		case ERROR_DS_NO_RIDS_ALLOCATED:
		{
			// 1929 The directory service was unable to allocate a relative identifier.  ERROR_DS_NO_RIDS_ALLOCATED
			pString = "ERROR_DS_NO_RIDS_ALLOCATED";
			break;
		}

		case ERROR_DS_NO_MORE_RIDS:
		{
			// 1930 The directory service has exhausted the pool of relative identifiers.  ERROR_DS_NO_MORE_RIDS
			pString = "ERROR_DS_NO_MORE_RIDS";
			break;
		}

		case ERROR_DS_INCORRECT_ROLE_OWNER:
		{
			// 1931 The requested operation could not be performed because the directory service is not the master for that type of operation.  ERROR_DS_INCORRECT_ROLE_OWNER
			pString = "ERROR_DS_INCORRECT_ROLE_OWNER";
			break;
		}

		case ERROR_DS_RIDMGR_INIT_ERROR:
		{
			// 1932 The directory service was unable to initialize the subsystem that allocates relative identifiers.  ERROR_DS_RIDMGR_INIT_ERROR
			pString = "ERROR_DS_RIDMGR_INIT_ERROR";
			break;
		}

		case ERROR_DS_OBJ_CLASS_VIOLATION:
		{
			// 1933 The requested operation did not satisfy one or more constraints associated with the class of the object.  ERROR_DS_OBJ_CLASS_VIOLATION
			pString = "ERROR_DS_OBJ_CLASS_VIOLATION";
			break;
		}

		case ERROR_DS_CANT_ON_NON_LEAF:
		{
			// 1934 The directory service can perform the requested operation only on a leaf object.  ERROR_DS_CANT_ON_NON_LEAF
			pString = "ERROR_DS_CANT_ON_NON_LEAF";
			break;
		}

		case ERROR_DS_CANT_ON_RDN:
		{
			// 1935 The directory service cannot perform the requested operation on the RDN attribute of an object.  ERROR_DS_CANT_ON_RDN
			pString = "ERROR_DS_CANT_ON_RDN";
			break;
		}

		case ERROR_DS_CANT_MOD_OBJ_CLASS:
		{
			// 1936 The directory service detected an attempt to modify the object class of an object.  ERROR_DS_CANT_MOD_OBJ_CLASS
			pString = "ERROR_DS_CANT_MOD_OBJ_CLASS";
			break;
		}

		case ERROR_DS_CROSS_DOM_MOVE_ERROR:
		{
			// 1937 The requested cross domain move operation could not be performed.  ERROR_DS_CROSS_DOM_MOVE_ERROR
			pString = "ERROR_DS_CROSS_DOM_MOVE_ERROR";
			break;
		}

		case ERROR_DS_GC_NOT_AVAILABLE:
		{
			// 1938 Unable to contact the global catalog server.  ERROR_DS_GC_NOT_AVAILABLE
			pString = "ERROR_DS_GC_NOT_AVAILABLE";
			break;
		}

		case ERROR_INVALID_PIXEL_FORMAT:
		{
			// 2000 The pixel format is invalid.  ERROR_INVALID_PIXEL_FORMAT
			pString = "ERROR_INVALID_PIXEL_FORMAT";
			break;
		}

		case ERROR_BAD_DRIVER:
		{
			// 2001 The specified driver is invalid.  ERROR_BAD_DRIVER
			pString = "ERROR_BAD_DRIVER";
			break;
		}

		case ERROR_INVALID_WINDOW_STYLE:
		{
			// 2002 The window style or class attribute is invalid for this operation.  ERROR_INVALID_WINDOW_STYLE
			pString = "ERROR_INVALID_WINDOW_STYLE";
			break;
		}

		case ERROR_METAFILE_NOT_SUPPORTED:
		{
			// 2003 The requested metafile operation is not supported.  ERROR_METAFILE_NOT_SUPPORTED
			pString = "ERROR_METAFILE_NOT_SUPPORTED";
			break;
		}

		case ERROR_TRANSFORM_NOT_SUPPORTED:
		{
			// 2004 The requested transformation operation is not supported.  ERROR_TRANSFORM_NOT_SUPPORTED
			pString = "ERROR_TRANSFORM_NOT_SUPPORTED";
			break;
		}

		case ERROR_CLIPPING_NOT_SUPPORTED:
		{
			// 2005 The requested clipping operation is not supported.  ERROR_CLIPPING_NOT_SUPPORTED
			pString = "ERROR_CLIPPING_NOT_SUPPORTED";
			break;
		}

		case ERROR_CONNECTED_OTHER_PASSWORD:
		{
			// 2108 The network connection was made successfully, but the user had to be prompted for a password other than the one originally specified.  ERROR_CONNECTED_OTHER_PASSWORD
			pString = "ERROR_CONNECTED_OTHER_PASSWORD";
			break;
		}

		case ERROR_BAD_USERNAME:
		{
			// 2202 The specified username is invalid.  ERROR_BAD_USERNAME
			pString = "ERROR_BAD_USERNAME";
			break;
		}

		case ERROR_NOT_CONNECTED:
		{
			// 2250 This network connection does not exist.  ERROR_NOT_CONNECTED
			pString = "ERROR_NOT_CONNECTED";
			break;
		}

		case ERROR_INVALID_CMM:
		{
			// 2300 The specified color management module is invalid.  ERROR_INVALID_CMM
			pString = "ERROR_INVALID_CMM";
			break;
		}

		case ERROR_INVALID_PROFILE:
		{
			// 2301 The specified color profile is invalid.  ERROR_INVALID_PROFILE
			pString = "ERROR_INVALID_PROFILE";
			break;
		}

		case ERROR_TAG_NOT_FOUND:
		{
			// 2302 The specified tag was not found.  ERROR_TAG_NOT_FOUND
			pString = "ERROR_TAG_NOT_FOUND";
			break;
		}

		case ERROR_TAG_NOT_PRESENT:
		{
			// 2303 A required tag is not present.  ERROR_TAG_NOT_PRESENT
			pString = "ERROR_TAG_NOT_PRESENT";
			break;
		}

		case ERROR_DUPLICATE_TAG:
		{
			// 2304 The specified tag is already present.  ERROR_DUPLICATE_TAG
			pString = "ERROR_DUPLICATE_TAG";
			break;
		}

		case ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE:
		{
			// 2305 The specified color profile is not associated with any device.  ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE
			pString = "ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE";
			break;
		}

		case ERROR_PROFILE_NOT_FOUND:
		{
			// 2306 The specified color profile was not found.  ERROR_PROFILE_NOT_FOUND
			pString = "ERROR_PROFILE_NOT_FOUND";
			break;
		}

		case ERROR_INVALID_COLORSPACE:
		{
			// 2307 The specified color space is invalid.  ERROR_INVALID_COLORSPACE
			pString = "ERROR_INVALID_COLORSPACE";
			break;
		}

		case ERROR_ICM_NOT_ENABLED:
		{
			// 2308 Image Color Management is not enabled.  ERROR_ICM_NOT_ENABLED
			pString = "ERROR_ICM_NOT_ENABLED";
			break;
		}

		case ERROR_DELETING_ICM_XFORM:
		{
			// 2309 There was an error while deleting the color transform.  ERROR_DELETING_ICM_XFORM
			pString = "ERROR_DELETING_ICM_XFORM";
			break;
		}

		case ERROR_INVALID_TRANSFORM:
		{
			// 2310 The specified color transform is invalid.  ERROR_INVALID_TRANSFORM
			pString = "ERROR_INVALID_TRANSFORM";
			break;
		}

		case ERROR_OPEN_FILES:
		{
			// 2401 This network connection has files open or requests pending.  ERROR_OPEN_FILES
			pString = "ERROR_OPEN_FILES";
			break;
		}

		case ERROR_ACTIVE_CONNECTIONS:
		{
			// 2402 Active connections still exist.  ERROR_ACTIVE_CONNECTIONS
			pString = "ERROR_ACTIVE_CONNECTIONS";
			break;
		}

		case ERROR_DEVICE_IN_USE:
		{
			// 2404 The device is in use by an active process and cannot be disconnected.  ERROR_DEVICE_IN_USE
			pString = "ERROR_DEVICE_IN_USE";
			break;
		}

		case ERROR_UNKNOWN_PRINT_MONITOR:
		{
			// 3000 The specified print monitor is unknown.  ERROR_UNKNOWN_PRINT_MONITOR
			pString = "ERROR_UNKNOWN_PRINT_MONITOR";
			break;
		}

		case ERROR_PRINTER_DRIVER_IN_USE:
		{
			// 3001 The specified printer driver is currently in use.  ERROR_PRINTER_DRIVER_IN_USE
			pString = "ERROR_PRINTER_DRIVER_IN_USE";
			break;
		}

		case ERROR_SPOOL_FILE_NOT_FOUND:
		{
			// 3002 The spool file was not found.  ERROR_SPOOL_FILE_NOT_FOUND
			pString = "ERROR_SPOOL_FILE_NOT_FOUND";
			break;
		}

		case ERROR_SPL_NO_STARTDOC:
		{
			// 3003 A StartDocPrinter call was not issued.  ERROR_SPL_NO_STARTDOC
			pString = "ERROR_SPL_NO_STARTDOC";
			break;
		}

		case ERROR_SPL_NO_ADDJOB:
		{
			// 3004 An AddJob call was not issued.  ERROR_SPL_NO_ADDJOB
			pString = "ERROR_SPL_NO_ADDJOB";
			break;
		}

		case ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED:
		{
			// 3005 The specified print processor has already been installed.  ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED
			pString = "ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED";
			break;
		}

		case ERROR_PRINT_MONITOR_ALREADY_INSTALLED:
		{
			// 3006 The specified print monitor has already been installed.  ERROR_PRINT_MONITOR_ALREADY_INSTALLED
			pString = "ERROR_PRINT_MONITOR_ALREADY_INSTALLED";
			break;
		}

		case ERROR_INVALID_PRINT_MONITOR:
		{
			// 3007 The specified print monitor does not have the required functions.  ERROR_INVALID_PRINT_MONITOR
			pString = "ERROR_INVALID_PRINT_MONITOR";
			break;
		}

		case ERROR_PRINT_MONITOR_IN_USE:
		{
			// 3008 The specified print monitor is currently in use.  ERROR_PRINT_MONITOR_IN_USE
			pString = "ERROR_PRINT_MONITOR_IN_USE";
			break;
		}

		case ERROR_PRINTER_HAS_JOBS_QUEUED:
		{
			// 3009 The requested operation is not allowed when there are jobs queued to the printer.  ERROR_PRINTER_HAS_JOBS_QUEUED
			pString = "ERROR_PRINTER_HAS_JOBS_QUEUED";
			break;
		}

		case ERROR_SUCCESS_REBOOT_REQUIRED:
		{
			// 3010 The requested operation is successful. Changes will not be effective until the system is rebooted.  ERROR_SUCCESS_REBOOT_REQUIRED
			pString = "ERROR_SUCCESS_REBOOT_REQUIRED";
			break;
		}

		case ERROR_SUCCESS_RESTART_REQUIRED:
		{
			// 3011 The requested operation is successful. Changes will not be effective until the service is restarted.  ERROR_SUCCESS_RESTART_REQUIRED
			pString = "ERROR_SUCCESS_RESTART_REQUIRED";
			break;
		}

		case ERROR_WINS_INTERNAL:
		{
			// 4000 WINS encountered an error while processing the command.  ERROR_WINS_INTERNAL
			pString = "ERROR_WINS_INTERNAL";
			break;
		}

		case ERROR_CAN_NOT_DEL_LOCAL_WINS:
		{
			// 4001 The local WINS can not be deleted.  ERROR_CAN_NOT_DEL_LOCAL_WINS
			pString = "ERROR_CAN_NOT_DEL_LOCAL_WINS";
			break;
		}

		case ERROR_STATIC_INIT:
		{
			// 4002 The importation from the file failed.  ERROR_STATIC_INIT
			pString = "ERROR_STATIC_INIT";
			break;
		}

		case ERROR_INC_BACKUP:
		{
			// 4003 The backup failed. Was a full backup done before?  ERROR_INC_BACKUP
			pString = "ERROR_INC_BACKUP";
			break;
		}

		case ERROR_FULL_BACKUP:
		{
			// 4004 The backup failed. Check the directory to which you are backing the database.  ERROR_FULL_BACKUP
			pString = "ERROR_FULL_BACKUP";
			break;
		}

		case ERROR_REC_NON_EXISTENT:
		{
			// 4005 The name does not exist in the WINS database.  ERROR_REC_NON_EXISTENT
			pString = "ERROR_REC_NON_EXISTENT";
			break;
		}

		case ERROR_RPL_NOT_ALLOWED:
		{
			// 4006 Replication with a nonconfigured partner is not allowed.  ERROR_RPL_NOT_ALLOWED
			pString = "ERROR_RPL_NOT_ALLOWED";
			break;
		}

		case ERROR_DHCP_ADDRESS_CONFLICT:
		{
			// 4100 The DHCP client has obtained an IP address that is already in use on the network. The local interface will be disabled until the DHCP client can obtain a new address.  ERROR_DHCP_ADDRESS_CONFLICT
			pString = "ERROR_DHCP_ADDRESS_CONFLICT";
			break;
		}

		case ERROR_WMI_GUID_NOT_FOUND:
		{
			// 4200 The GUID passed was not recognized as valid by a WMI data provider.  ERROR_WMI_GUID_NOT_FOUND
			pString = "ERROR_WMI_GUID_NOT_FOUND";
			break;
		}

		case ERROR_WMI_INSTANCE_NOT_FOUND:
		{
			// 4201 The instance name passed was not recognized as valid by a WMI data provider.  ERROR_WMI_INSTANCE_NOT_FOUND
			pString = "ERROR_WMI_INSTANCE_NOT_FOUND";
			break;
		}

		case ERROR_WMI_ITEMID_NOT_FOUND:
		{
			// 4202 The data item ID passed was not recognized as valid by a WMI data provider.  ERROR_WMI_ITEMID_NOT_FOUND
			pString = "ERROR_WMI_ITEMID_NOT_FOUND";
			break;
		}

		case ERROR_WMI_TRY_AGAIN:
		{
			// 4203 The WMI request could not be completed and should be retried.  ERROR_WMI_TRY_AGAIN
			pString = "ERROR_WMI_TRY_AGAIN";
			break;
		}

		case ERROR_WMI_DP_NOT_FOUND:
		{
			// 4204 The WMI data provider could not be located.  ERROR_WMI_DP_NOT_FOUND
			pString = "ERROR_WMI_DP_NOT_FOUND";
			break;
		}

		case ERROR_WMI_UNRESOLVED_INSTANCE_REF:
		{
			// 4205 The WMI data provider references an instance set that has not been registered.  ERROR_WMI_UNRESOLVED_INSTANCE_REF
			pString = "ERROR_WMI_UNRESOLVED_INSTANCE_REF";
			break;
		}

		case ERROR_WMI_ALREADY_ENABLED:
		{
			// 4206 The WMI data block or event notification has already been enabled.  ERROR_WMI_ALREADY_ENABLED
			pString = "ERROR_WMI_ALREADY_ENABLED";
			break;
		}

		case ERROR_WMI_GUID_DISCONNECTED:
		{
			// 4207 The WMI data block is no longer available.  ERROR_WMI_GUID_DISCONNECTED
			pString = "ERROR_WMI_GUID_DISCONNECTED";
			break;
		}

		case ERROR_WMI_SERVER_UNAVAILABLE:
		{
			// 4208 The WMI data service is not available.  ERROR_WMI_SERVER_UNAVAILABLE
			pString = "ERROR_WMI_SERVER_UNAVAILABLE";
			break;
		}

		case ERROR_WMI_DP_FAILED:
		{
			// 4209 The WMI data provider failed to carry out the request.  ERROR_WMI_DP_FAILED
			pString = "ERROR_WMI_DP_FAILED";
			break;
		}

		case ERROR_WMI_INVALID_MOF:
		{
			// 4210 The WMI MOF information is not valid.  ERROR_WMI_INVALID_MOF
			pString = "ERROR_WMI_INVALID_MOF";
			break;
		}

		case ERROR_WMI_INVALID_REGINFO:
		{
			// 4211 The WMI registration information is not valid.  ERROR_WMI_INVALID_REGINFO
			pString = "ERROR_WMI_INVALID_REGINFO";
			break;
		}

		case ERROR_INVALID_MEDIA:
		{
			// 4300 The media identifier does not represent a valid medium.  ERROR_INVALID_MEDIA
			pString = "ERROR_INVALID_MEDIA";
			break;
		}

		case ERROR_INVALID_LIBRARY:
		{
			// 4301 The library identifier does not represent a valid library.  ERROR_INVALID_LIBRARY
			pString = "ERROR_INVALID_LIBRARY";
			break;
		}

		case ERROR_INVALID_MEDIA_POOL:
		{
			// 4302 The media pool identifier does not represent a valid media pool.  ERROR_INVALID_MEDIA_POOL
			pString = "ERROR_INVALID_MEDIA_POOL";
			break;
		}

		case ERROR_DRIVE_MEDIA_MISMATCH:
		{
			// 4303 The drive and medium are not compatible or exist in different libraries.  ERROR_DRIVE_MEDIA_MISMATCH
			pString = "ERROR_DRIVE_MEDIA_MISMATCH";
			break;
		}

		case ERROR_MEDIA_OFFLINE:
		{
			// 4304 The medium currently exists in an offline library and must be online to perform this operation.  ERROR_MEDIA_OFFLINE
			pString = "ERROR_MEDIA_OFFLINE";
			break;
		}

		case ERROR_LIBRARY_OFFLINE:
		{
			// 4305 The operation cannot be performed on an offline library.  ERROR_LIBRARY_OFFLINE
			pString = "ERROR_LIBRARY_OFFLINE";
			break;
		}

		case ERROR_EMPTY:
		{
			// 4306 The library, drive, or media pool is empty.  ERROR_EMPTY
			pString = "ERROR_EMPTY";
			break;
		}

		case ERROR_NOT_EMPTY:
		{
			// 4307 The library, drive, or media pool must be empty to perform this operation.  ERROR_NOT_EMPTY
			pString = "ERROR_NOT_EMPTY";
			break;
		}

		case ERROR_MEDIA_UNAVAILABLE:
		{
			// 4308 No media is currently available in this media pool or library.  ERROR_MEDIA_UNAVAILABLE
			pString = "ERROR_MEDIA_UNAVAILABLE";
			break;
		}

		case ERROR_RESOURCE_DISABLED:
		{
			// 4309 A resource required for this operation is disabled.  ERROR_RESOURCE_DISABLED
			pString = "ERROR_RESOURCE_DISABLED";
			break;
		}

		case ERROR_INVALID_CLEANER:
		{
			// 4310 The media identifier does not represent a valid cleaner.  ERROR_INVALID_CLEANER
			pString = "ERROR_INVALID_CLEANER";
			break;
		}

		case ERROR_UNABLE_TO_CLEAN:
		{
			// 4311 The drive cannot be cleaned or does not support cleaning.  ERROR_UNABLE_TO_CLEAN
			pString = "ERROR_UNABLE_TO_CLEAN";
			break;
		}

		case ERROR_OBJECT_NOT_FOUND:
		{
			// 4312 The object identifier does not represent a valid object.  ERROR_OBJECT_NOT_FOUND
			pString = "ERROR_OBJECT_NOT_FOUND";
			break;
		}

		case ERROR_DATABASE_FAILURE:
		{
			// 4313 Unable to read from or write to the database.  ERROR_DATABASE_FAILURE
			pString = "ERROR_DATABASE_FAILURE";
			break;
		}

		case ERROR_DATABASE_FULL:
		{
			// 4314 The database is full.  ERROR_DATABASE_FULL
			pString = "ERROR_DATABASE_FULL";
			break;
		}

		case ERROR_MEDIA_INCOMPATIBLE:
		{
			// 4315 The medium is not compatible with the device or media pool.  ERROR_MEDIA_INCOMPATIBLE
			pString = "ERROR_MEDIA_INCOMPATIBLE";
			break;
		}

		case ERROR_RESOURCE_NOT_PRESENT:
		{
			// 4316 The resource required for this operation does not exist.  ERROR_RESOURCE_NOT_PRESENT
			pString = "ERROR_RESOURCE_NOT_PRESENT";
			break;
		}

		case ERROR_INVALID_OPERATION:
		{
			// 4317 The operation identifier is not valid.  ERROR_INVALID_OPERATION
			pString = "ERROR_INVALID_OPERATION";
			break;
		}

		case ERROR_MEDIA_NOT_AVAILABLE:
		{
			// 4318 The media is not mounted or ready for use.  ERROR_MEDIA_NOT_AVAILABLE
			pString = "ERROR_MEDIA_NOT_AVAILABLE";
			break;
		}

		case ERROR_DEVICE_NOT_AVAILABLE:
		{
			// 4319 The device is not ready for use.  ERROR_DEVICE_NOT_AVAILABLE
			pString = "ERROR_DEVICE_NOT_AVAILABLE";
			break;
		}

		case ERROR_REQUEST_REFUSED:
		{
			// 4320 The operator or administrator has refused the request.  ERROR_REQUEST_REFUSED
			pString = "ERROR_REQUEST_REFUSED";
			break;
		}

		case ERROR_FILE_OFFLINE:
		{
			// 4350 The remote storage service was not able to recall the file.  ERROR_FILE_OFFLINE
			pString = "ERROR_FILE_OFFLINE";
			break;
		}

		case ERROR_REMOTE_STORAGE_NOT_ACTIVE:
		{
			// 4351 The remote storage service is not operational at this time.  ERROR_REMOTE_STORAGE_NOT_ACTIVE
			pString = "ERROR_REMOTE_STORAGE_NOT_ACTIVE";
			break;
		}

		case ERROR_REMOTE_STORAGE_MEDIA_ERROR:
		{
			// 4352 The remote storage service encountered a media error.  ERROR_REMOTE_STORAGE_MEDIA_ERROR
			pString = "ERROR_REMOTE_STORAGE_MEDIA_ERROR";
			break;
		}

		case ERROR_NOT_A_REPARSE_POINT:
		{
			// 4390 The file or directory is not a reparse point.  ERROR_NOT_A_REPARSE_POINT
			pString = "ERROR_NOT_A_REPARSE_POINT";
			break;
		}

		case ERROR_REPARSE_ATTRIBUTE_CONFLICT:
		{
			// 4391 The reparse point attribute cannot be set because it conflicts with an existing attribute.  ERROR_REPARSE_ATTRIBUTE_CONFLICT
			pString = "ERROR_REPARSE_ATTRIBUTE_CONFLICT";
			break;
		}

		case ERROR_DEPENDENT_RESOURCE_EXISTS:
		{
			// 5001 The cluster resource cannot be moved to another group because other resources are dependent on it.  ERROR_DEPENDENT_RESOURCE_EXISTS
			pString = "ERROR_DEPENDENT_RESOURCE_EXISTS";
			break;
		}

		case ERROR_DEPENDENCY_NOT_FOUND:
		{
			// 5002 The cluster resource dependency cannot be found.  ERROR_DEPENDENCY_NOT_FOUND
			pString = "ERROR_DEPENDENCY_NOT_FOUND";
			break;
		}

		case ERROR_DEPENDENCY_ALREADY_EXISTS:
		{
			// 5003 The cluster resource cannot be made dependent on the specified resource because it is already dependent.  ERROR_DEPENDENCY_ALREADY_EXISTS
			pString = "ERROR_DEPENDENCY_ALREADY_EXISTS";
			break;
		}

		case ERROR_RESOURCE_NOT_ONLINE:
		{
			// 5004 The cluster resource is not online.  ERROR_RESOURCE_NOT_ONLINE
			pString = "ERROR_RESOURCE_NOT_ONLINE";
			break;
		}

		case ERROR_HOST_NODE_NOT_AVAILABLE:
		{
			// 5005 A cluster node is not available for this operation.  ERROR_HOST_NODE_NOT_AVAILABLE
			pString = "ERROR_HOST_NODE_NOT_AVAILABLE";
			break;
		}

		case ERROR_RESOURCE_NOT_AVAILABLE:
		{
			// 5006 The cluster resource is not available.  ERROR_RESOURCE_NOT_AVAILABLE
			pString = "ERROR_RESOURCE_NOT_AVAILABLE";
			break;
		}

		case ERROR_RESOURCE_NOT_FOUND:
		{
			// 5007 The cluster resource could not be found.  ERROR_RESOURCE_NOT_FOUND
			pString = "ERROR_RESOURCE_NOT_FOUND";
			break;
		}

		case ERROR_SHUTDOWN_CLUSTER:
		{
			// 5008 The cluster is being shut down.  ERROR_SHUTDOWN_CLUSTER
			pString = "ERROR_SHUTDOWN_CLUSTER";
			break;
		}

		case ERROR_CANT_EVICT_ACTIVE_NODE:
		{
			// 5009 A cluster node cannot be evicted from the cluster while it is online.  ERROR_CANT_EVICT_ACTIVE_NODE
			pString = "ERROR_CANT_EVICT_ACTIVE_NODE";
			break;
		}

		case ERROR_OBJECT_ALREADY_EXISTS:
		{
			// 5010 The object already exists.  ERROR_OBJECT_ALREADY_EXISTS
			pString = "ERROR_OBJECT_ALREADY_EXISTS";
			break;
		}

		case ERROR_OBJECT_IN_LIST:
		{
			// 5011 The object is already in the list.  ERROR_OBJECT_IN_LIST
			pString = "ERROR_OBJECT_IN_LIST";
			break;
		}

		case ERROR_GROUP_NOT_AVAILABLE:
		{
			// 5012 The cluster group is not available for any new requests.  ERROR_GROUP_NOT_AVAILABLE
			pString = "ERROR_GROUP_NOT_AVAILABLE";
			break;
		}

		case ERROR_GROUP_NOT_FOUND:
		{
			// 5013 The cluster group could not be found.  ERROR_GROUP_NOT_FOUND
			pString = "ERROR_GROUP_NOT_FOUND";
			break;
		}

		case ERROR_GROUP_NOT_ONLINE:
		{
			// 5014 The operation could not be completed because the cluster group is not online.  ERROR_GROUP_NOT_ONLINE
			pString = "ERROR_GROUP_NOT_ONLINE";
			break;
		}

		case ERROR_HOST_NODE_NOT_RESOURCE_OWNER:
		{
			// 5015 The cluster node is not the owner of the resource.  ERROR_HOST_NODE_NOT_RESOURCE_OWNER
			pString = "ERROR_HOST_NODE_NOT_RESOURCE_OWNER";
			break;
		}

		case ERROR_HOST_NODE_NOT_GROUP_OWNER:
		{
			// 5016 The cluster node is not the owner of the group.  ERROR_HOST_NODE_NOT_GROUP_OWNER
			pString = "ERROR_HOST_NODE_NOT_GROUP_OWNER";
			break;
		}

		case ERROR_RESMON_CREATE_FAILED:
		{
			// 5017 The cluster resource could not be created in the specified resource monitor.  ERROR_RESMON_CREATE_FAILED
			pString = "ERROR_RESMON_CREATE_FAILED";
			break;
		}

		case ERROR_RESMON_ONLINE_FAILED:
		{
			// 5018 The cluster resource could not be brought online by the resource monitor.  ERROR_RESMON_ONLINE_FAILED
			pString = "ERROR_RESMON_ONLINE_FAILED";
			break;
		}

		case ERROR_RESOURCE_ONLINE:
		{
			// 5019 The operation could not be completed because the cluster resource is online.  ERROR_RESOURCE_ONLINE
			pString = "ERROR_RESOURCE_ONLINE";
			break;
		}

		case ERROR_QUORUM_RESOURCE:
		{
			// 5020 The cluster resource could not be deleted or brought offline because it is the quorum resource.  ERROR_QUORUM_RESOURCE
			pString = "ERROR_QUORUM_RESOURCE";
			break;
		}

		case ERROR_NOT_QUORUM_CAPABLE:
		{
			// 5021 The cluster could not make the specified resource a quorum resource because it is not capable of being a quorum resource.  ERROR_NOT_QUORUM_CAPABLE
			pString = "ERROR_NOT_QUORUM_CAPABLE";
			break;
		}

		case ERROR_CLUSTER_SHUTTING_DOWN:
		{
			// 5022 The cluster software is shutting down.  ERROR_CLUSTER_SHUTTING_DOWN
			pString = "ERROR_CLUSTER_SHUTTING_DOWN";
			break;
		}

		case ERROR_INVALID_STATE:
		{
			// 5023 The group or resource is not in the correct state to perform the requested operation.  ERROR_INVALID_STATE
			pString = "ERROR_INVALID_STATE";
			break;
		}

		case ERROR_RESOURCE_PROPERTIES_STORED:
		{
			// 5024 The properties were stored but not all changes will take effect until the next time the resource is brought online.  ERROR_RESOURCE_PROPERTIES_STORED
			pString = "ERROR_RESOURCE_PROPERTIES_STORED";
			break;
		}

		case ERROR_NOT_QUORUM_CLASS:
		{
			// 5025 The cluster could not make the specified resource a quorum resource because it does not belong to a shared storage class.  ERROR_NOT_QUORUM_CLASS
			pString = "ERROR_NOT_QUORUM_CLASS";
			break;
		}

		case ERROR_CORE_RESOURCE:
		{
			// 5026 The cluster resource could not be deleted since it is a core resource.  ERROR_CORE_RESOURCE
			pString = "ERROR_CORE_RESOURCE";
			break;
		}

		case ERROR_QUORUM_RESOURCE_ONLINE_FAILED:
		{
			// 5027 The quorum resource failed to come online.  ERROR_QUORUM_RESOURCE_ONLINE_FAILED
			pString = "ERROR_QUORUM_RESOURCE_ONLINE_FAILED";
			break;
		}

		case ERROR_QUORUMLOG_OPEN_FAILED:
		{
			// 5028 The quorum log could not be created or mounted successfully.  ERROR_QUORUMLOG_OPEN_FAILED
			pString = "ERROR_QUORUMLOG_OPEN_FAILED";
			break;
		}

		case ERROR_CLUSTERLOG_CORRUPT:
		{
			// 5029 The cluster log is corrupt.  ERROR_CLUSTERLOG_CORRUPT
			pString = "ERROR_CLUSTERLOG_CORRUPT";
			break;
		}

		case ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE:
		{
			// 5030 The record could not be written to the cluster log since it exceeds the maximum size.  ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE
			pString = "ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE";
			break;
		}

		case ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE:
		{
			// 5031 The cluster log exceeds its maximum size.  ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE
			pString = "ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE";
			break;
		}

		case ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND:
		{
			// 5032 No checkpoint record was found in the cluster log.  ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND
			pString = "ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND";
			break;
		}

		case ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE:
		{
			// 5033 The minimum required disk space needed for logging is not available.  ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE
			pString = "ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE";
			break;
		}

		case ERROR_ENCRYPTION_FAILED:
		{
			// 6000 The specified file could not be encrypted.  ERROR_ENCRYPTION_FAILED
			pString = "ERROR_ENCRYPTION_FAILED";
			break;
		}

		case ERROR_DECRYPTION_FAILED:
		{
			// 6001 The specified file could not be decrypted.  ERROR_DECRYPTION_FAILED
			pString = "ERROR_DECRYPTION_FAILED";
			break;
		}

		case ERROR_FILE_ENCRYPTED:
		{
			// 6002 The specified file is encrypted and the user does not have the ability to decrypt it.  ERROR_FILE_ENCRYPTED
			pString = "ERROR_FILE_ENCRYPTED";
			break;
		}

		case ERROR_NO_RECOVERY_POLICY:
		{
			// 6003 There is no encryption recovery policy configured for this system.  ERROR_NO_RECOVERY_POLICY
			pString = "ERROR_NO_RECOVERY_POLICY";
			break;
		}

		case ERROR_NO_EFS:
		{
			// 6004 The required encryption driver is not loaded for this system.  ERROR_NO_EFS
			pString = "ERROR_NO_EFS";
			break;
		}

		case ERROR_WRONG_EFS:
		{
			// 6005 The file was encrypted with a different encryption driver than is currently loaded.  ERROR_WRONG_EFS
			pString = "ERROR_WRONG_EFS";
			break;
		}

		case ERROR_NO_USER_KEYS:
		{
			// 6006 There are no EFS keys defined for the user.  ERROR_NO_USER_KEYS
			pString = "ERROR_NO_USER_KEYS";
			break;
		}

		case ERROR_FILE_NOT_ENCRYPTED:
		{
			// 6007 The specified file is not encrypted.  ERROR_FILE_NOT_ENCRYPTED
			pString = "ERROR_FILE_NOT_ENCRYPTED";
			break;
		}

		case ERROR_NOT_EXPORT_FORMAT:
		{
			// 6008 The specified file is not in the defined EFS export format.  ERROR_NOT_EXPORT_FORMAT
			pString = "ERROR_NOT_EXPORT_FORMAT";
			break;
		}

		case ERROR_NO_BROWSER_SERVERS_FOUND:
		{
			// 6118 The list of servers for this workgroup is not currently available  ERROR_NO_BROWSER_SERVERS_FOUND
			pString = "ERROR_NO_BROWSER_SERVERS_FOUND";
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			pString = "Unknown error code!";
			break;
		}
	}

	return	pString;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// GetWIN32ErrorString - convert system error to a string
//
// Entry:		Error code
//
// Exit:		Pointer to string
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "GetWinsockErrorString"

static	char	*GetWinsockErrorString( const DWORD WinsockError )
{
	char	*pString = NULL;


	// what was the error code?
	switch ( WinsockError )
	{
		case WSAEINTR:
		{
			pString = "WSAEINTR";
			break;
		}

		case WSAEBADF:
		{
			pString = "WSAEBADF";
			break;
		}

		case WSAEACCES:
		{
			pString = "WSAEACCES";
			break;
		}

		case WSAEFAULT:
		{
			pString = "WSAEFAULT";
			break;
		}

		case WSAEINVAL:
		{
			pString = "WSAEINVAL";
			break;
		}

		case WSAEMFILE:
		{
			pString = "WSAEMFILE";
			break;
		}

		case WSAEWOULDBLOCK:
		{
			pString = "WSAEWOULDBLOCK";
			break;
		}

		case WSAEINPROGRESS:
		{
			pString = "WSAEINPROGRESS";
			break;
		}

		case WSAEALREADY:
		{
			pString = "WSAEALREADY";
			break;
		}

		case WSAENOTSOCK:
		{
			pString = "WSAENOTSOCK";
			break;
		}

		case WSAEDESTADDRREQ:
		{
			pString = "WSAEDESTADDRREQ";
			break;
		}

		case WSAEMSGSIZE:
		{
			pString = "WSAEMSGSIZE";
			break;
		}

		case WSAEPROTOTYPE:
		{
			pString = "WSAEPROTOTYPE";
			break;
		}

		case WSAENOPROTOOPT:
		{
			pString = "WSAENOPROTOOPT";
			break;
		}

		case WSAEPROTONOSUPPORT:
		{
			pString = "WSAEPROTONOSUPPORT";
			break;
		}

		case WSAESOCKTNOSUPPORT:
		{
			pString = "WSAESOCKTNOSUPPORT";
			break;
		}

		case WSAEOPNOTSUPP:
		{
			pString = "WSAEOPNOTSUPP";
			break;
		}

		case WSAEPFNOSUPPORT:
		{
			pString = "WSAEPFNOSUPPORT";
			break;
		}

		case WSAEAFNOSUPPORT:
		{
			pString = "WSAEAFNOSUPPORT";
			break;
		}

		case WSAEADDRINUSE:
		{
			pString = "WSAEADDRINUSE";
			break;
		}

		case WSAEADDRNOTAVAIL:
		{
			pString = "WSAEADDRNOTAVAIL";
			break;
		}

		case WSAENETDOWN:
		{
			pString = "WSAENETDOWN";
			break;
		}

		case WSAENETUNREACH:
		{
			pString = "WSAENETUNREACH";
			break;
		}

		case WSAENETRESET:
		{
			pString = "WSAENETRESET";
			break;
		}

		case WSAECONNABORTED:
		{
			pString = "WSAECONNABORTED";
			break;
		}

		case WSAECONNRESET:
		{
			pString = "WSAECONNRESET";
			break;
		}

		case WSAENOBUFS:
		{
			pString = "WSAENOBUFS";
			break;
		}

		case WSAEISCONN:
		{
			pString = "WSAEISCONN";
			break;
		}

		case WSAENOTCONN:
		{
			pString = "WSAENOTCONN";
			break;
		}

		case WSAESHUTDOWN:
		{
			pString = "WSAESHUTDOWN";
			break;
		}

		case WSAETOOMANYREFS:
		{
			pString = "WSAETOOMANYREFS";
			break;
		}

		case WSAETIMEDOUT:
		{
			pString = "WSAETIMEDOUT";
			break;
		}

		case WSAECONNREFUSED:
		{
			pString = "WSAECONNREFUSED";
			break;
		}

		case WSAELOOP:
		{
			pString = "WSAELOOP";
			break;
		}

		case WSAENAMETOOLONG:
		{
			pString = "WSAENAMETOOLONG";
			break;
		}

		case WSAEHOSTDOWN:
		{
			pString = "WSAEHOSTDOWN";
			break;
		}

		case WSAEHOSTUNREACH:
		{
			pString = "WSAEHOSTUNREACH";
			break;
		}

		case WSAENOTEMPTY:
		{
			pString = "WSAENOTEMPTY";
			break;
		}

		case WSAEPROCLIM:
		{
			pString = "WSAEPROCLIM";
			break;
		}

		case WSAEUSERS:
		{
			pString = "WSAEUSERS";
			break;
		}

		case WSAEDQUOT:
		{
			pString = "WSAEDQUOT";
			break;
		}

		case WSAESTALE:
		{
			pString = "WSAESTALE";
			break;
		}

		case WSAEREMOTE:
		{
			pString = "WSAEREMOTE";
			break;
		}

		case WSASYSNOTREADY:
		{
			pString = "WSASYSNOTREADY";
			break;
		}

		case WSAVERNOTSUPPORTED:
		{
			pString = "WSAVERNOTSUPPORTED";
			break;
		}

		case WSANOTINITIALISED:
		{
			pString = "WSANOTINITIALISED";
			break;
		}

		case WSAEDISCON:
		{
			pString = "WSAEDISCON";
			break;
		}

		case WSAENOMORE:
		{
			pString = "WSAENOMORE";
			break;
		}

		case WSAECANCELLED:
		{
			pString = "WSAECANCELLED";
			break;
		}

		case WSAEINVALIDPROCTABLE:
		{
			pString = "WSAEINVALIDPROCTABLE";
			break;
		}

		case WSAEINVALIDPROVIDER:
		{
			pString = "WSAEINVALIDPROVIDER";
			break;
		}

		case WSAEPROVIDERFAILEDINIT:
		{
			pString = "WSAEPROVIDERFAILEDINIT";
			break;
		}

		case WSASYSCALLFAILURE:
		{
			pString = "WSASYSCALLFAILURE";
			break;
		}

		case WSASERVICE_NOT_FOUND:
		{
			pString = "WSASERVICE_NOT_FOUND";
			break;
		}

		case WSATYPE_NOT_FOUND:
		{
			pString = "WSATYPE_NOT_FOUND";
			break;
		}

		case WSA_E_NO_MORE:
		{
			pString = "WSA_E_NO_MORE";
			break;
		}

		case WSA_E_CANCELLED:
		{
			pString = "WSA_E_CANCELLED";
			break;
		}

		case WSAEREFUSED:
		{
			pString = "WSAEREFUSED";
			break;
		}

		/* Authoritative Answer: Host not found */
		case WSAHOST_NOT_FOUND:
		{
			pString = "WSAHOST_NOT_FOUND";
			break;
		}

		/* Non-Authoritative: Host not found, or SERVERFAIL */
		case WSATRY_AGAIN:
		{
			pString = "WSATRY_AGAIN";
			break;
		}

		/* Non-recoverable errors, FORMERR, REFUSED, NOTIMP */
		case WSANO_RECOVERY:
		{
			pString = "WSANO_RECOVERY";
			break;
		}

		/* Valid name, no data record of requested type */
		case WSANO_DATA:
		{
			pString = "WSANO_DATA";
			break;
		}

// same error value as WSANO_DATA
//		/* no address, look for MX record */
//		case WSANO_ADDRESS:
//		{
//			pString = "WSANO_ADDRESS";
//			break;
//		}

		/* at least one Reserve has arrived */
		case WSA_QOS_RECEIVERS:
		{
			pString = "WSA_QOS_RECEIVERS";
			break;
		}

		/* at least one Path has arrived */
		case WSA_QOS_SENDERS:
		{
			pString = "WSA_QOS_SENDERS";
			break;
		}

		/* there are no senders */
		case WSA_QOS_NO_SENDERS:
		{
			pString = "WSA_QOS_NO_SENDERS";
			break;
		}

		/* there are no receivers */
		case WSA_QOS_NO_RECEIVERS:
		{
			pString = "WSA_QOS_NO_RECEIVERS";
			break;
		}

		/* Reserve has been confirmed */
		case WSA_QOS_REQUEST_CONFIRMED:
		{
			pString = "WSA_QOS_REQUEST_CONFIRMED";
			break;
		}

		/* error due to lack of resources */
		case WSA_QOS_ADMISSION_FAILURE:
		{
			pString = "WSA_QOS_ADMISSION_FAILURE";
			break;
		}

		/* rejected for administrative reasons - bad credentials */
		case WSA_QOS_POLICY_FAILURE:
		{
			pString = "WSA_QOS_POLICY_FAILURE";
			break;
		}

		/* unknown or conflicting style */
		case WSA_QOS_BAD_STYLE:
		{
			pString = "WSA_QOS_BAD_STYLE";
			break;
		}

		/* problem with some part of the filterspec or providerspecific
		 * buffer in general */
		 case WSA_QOS_BAD_OBJECT:
		{
			pString = "WSA_QOS_BAD_OBJECT";
			break;
		}

		/* problem with some part of the flowspec */
		case WSA_QOS_TRAFFIC_CTRL_ERROR:
		{
			pString = "WSA_QOS_TRAFFIC_CTRL_ERROR";
			break;
		}

		/* general error */
		case WSA_QOS_GENERIC_ERROR:
		{
			pString = "WSA_QOS_GENERIC_ERROR";
			break;
		}

		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}

	return	pString;
}
//**********************************************************************



#endif	// _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\dvcslock.h ===
/*==========================================================================
 * Copyright (C) 1999, 2000 Microsoft Corporation.  All Rights Reserved.
 *
 * File:       dvcslock.h
 * Content:    Class to handle auto-leave of critical sections
 * History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/05/00	rodtoll	Created It
 *
 ***************************************************************************/
#ifndef __DVCSLOCK_H
#define __DVCSLOCK_H

// CDVCSLock
//
// A class to provide automatic unlocking of critical sections when the object
// passes out of scope.
//
class CDVCSLock
{
	STDNEWDELETE

public:
	CDVCSLock( CRITICAL_SECTION *pcs ): m_pcs( pcs ), m_fLocked( FALSE )
	{
	};

	~CDVCSLock() 
	{ 
		if( m_fLocked ) LeaveCriticalSection( m_pcs ); 
	}

	void Lock()
	{
		EnterCriticalSection( m_pcs );
		m_fLocked = TRUE;
	}

	void Unlock()
	{
		LeaveCriticalSection( m_pcs );
		m_fLocked = FALSE;
	}

private:

	CRITICAL_SECTION *m_pcs;
	BOOL m_fLocked;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\fpm.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       FPM.cpp
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97	aarono	Original
 *	11-06-98	ejs		Add custom handler for Release function
 *	04-12-99	jtk		Trimmed unused functions and parameters, added size assert
 *	11-22-99	jtk		Converted to .CPP
 *	01-31-2000	jtk		Changed to use DNCriticalSections.  Added code to check
 *						for items already being in the pool on Release().
 *	04-11-2000	ejs		Put ASSERTs back into service.  They had been MACRO'd away to nothing
 ***************************************************************************/

#include "commoni.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

#define	DPMEM_ALLOC		DNMalloc
#define	DPMEM_FREE		DNFree

//#define	CHECK_FOR_DUPLICATE_FPM_RELEASE


//**********************************************************************
// ------------------------------
// FN_BOOL_DUMMY - place-holder function to return a Boolean
//
// Entry:		Pointer
//
// Exit:		Boolean
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FN_BOOL_DUMMY"
BOOL FN_BOOL_DUMMY(void *pvItem)
{
	return TRUE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FN_VOID_DUMMY - place-holder function
//
// Entry:		Pointer
//
// Exit:		Boolean
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FN_VOID_DUMMY"
VOID FN_VOID_DUMMY(void *pvItem)
{
	return;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FPM_Get - get an item from the pool
//
// Entry:		Pointer to pool
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FPM_Get"
void * FPM_Get( FPOOL *pPool )
{
	void * pvItem;

	DNEnterCriticalSection(&pPool->cs);

	DNASSERT(pPool->pPoolElements == 0 || !IsBadReadPtr(pPool->pPoolElements, 4));
	if(!pPool->pPoolElements){

		DNLeaveCriticalSection(&pPool->cs);
		pvItem = DPMEM_ALLOC(pPool->cbItemSize);

		if((pvItem) && !(*pPool->fnBlockInitAlloc)(pvItem) ){
			DPMEM_FREE(pvItem);
			pvItem=NULL;
		}

		DNEnterCriticalSection(&pPool->cs);

		if(pvItem){	
			pPool->nAllocated++;
		}

	} else {
		pvItem=pPool->pPoolElements;
		pPool->pPoolElements=*((void **)pvItem);
		DNASSERT(pPool->pPoolElements == 0 || !IsBadReadPtr(pPool->pPoolElements, 4));
	}

	if(pvItem){

		pPool->nInUse++;

		DNLeaveCriticalSection(&pPool->cs);

		(*pPool->fnBlockInit)(pvItem);

	}
	else {
		DNLeaveCriticalSection(&pPool->cs);
	}

	return pvItem;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FPM_Release - return element to pool
//
// Entry:		Pointer to pool
//				Pointer to element
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FPM_Release"
void FPM_Release( FPOOL *pPool, void *pvItem)
{
	(*pPool->fnBlockRelease)(pvItem);

	DNEnterCriticalSection(&pPool->cs);

#if defined(CHECK_FOR_DUPLICATE_FPM_RELEASE) && defined(DEBUG)
	{
		void	*pTemp;

		pTemp = pPool->pPoolElements;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pvItem );
			pTemp = *((void**)pTemp);
		}
	}
#endif	// CHECK_FOR_DUPLICATE_FPM_RELEASE

	pPool->nInUse--;
	*((void**)pvItem)=pPool->pPoolElements;
	pPool->pPoolElements=pvItem;
	DNASSERT(pPool->pPoolElements == 0 || !IsBadReadPtr(pPool->pPoolElements, 4));
	DNLeaveCriticalSection(&pPool->cs);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FPM_Fini - destroy pool
//
// Entry:		Pointer to pool
//
// Exit:		Nothing
//
// Note:		This function frees the pool memory, the pointer passed in is
//				then invalid!
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FPM_Fini"
VOID FPM_Fini( FPOOL *pPool )
{
	FPM_Deinitialize( pPool );

	DPMEM_FREE( pPool );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FPM_Deinitialize - deinitialize pool
//
// Entry:		Pointer to pool
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FPM_Deinitialize"
VOID FPM_Deinitialize( FPOOL *pPool)
{
	void *pvItem;


	while(pPool->pPoolElements){
		pvItem = pPool->pPoolElements;
		pPool->pPoolElements=*((void **)pvItem);
		DNASSERT(pPool->pPoolElements == 0 || !IsBadReadPtr(pPool->pPoolElements, 4));
		(*pPool->fnBlockFini)(pvItem);
		DPMEM_FREE(pvItem);
		pPool->nAllocated--;
	}
	if(pPool->nAllocated){
		ASSERT(0);
	}
	DNDeleteCriticalSection(&pPool->cs);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FPM_Create - Allocate a new pool
//
// Entry:		Size of pool element
// 				Pointer to function for initializing element on alloc
// 				Pointer to function for initializing element on get
//				Pointer to function for deinitializing element on release
//				Pointer to function for deinitializing element on free
//
// Exit:		Pointer to new pool
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FPM_Create"
FPOOL	*FPM_Create( unsigned int 		size,
					 FN_BLOCKINITALLOC	fnBlockInitAlloc,
					 FN_BLOCKINIT		fnBlockInit,
					 FN_BLOCKRELEASE	fnBlockRelease,
					 FN_BLOCKFINI		fnBlockFini
					 )
{
	LPFPOOL pPool;


	pPool=static_cast<FPOOL*>( DPMEM_ALLOC( sizeof( *pPool ) ) );
	if ( pPool == NULL )
	{
	  return NULL;
	}

	if ( FPM_Initialize( pPool,					// pointer to fixed pool
						 size,					// size of pool element
						 fnBlockInitAlloc,		// pointer to function for initializing element on alloc
						 fnBlockInit,			// pointer to function for initializing element on get
						 fnBlockRelease,		// pointer to function for deinitializing element on release
						 fnBlockFini			// pointer to function for deinitializing element on free
						 ) == FALSE )
	{
		DPMEM_FREE( pPool );
		pPool = NULL;
	}

	return pPool;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// FPM_Initialize - initialize an instance of a pool
//
// Entry:		Pointer to pool
//				Size of pool element
// 				Pointer to function for initializing element on alloc
// 				Pointer to function for initializing element on get
//				Pointer to function for deinitializing element on release
//				Pointer to function for deinitializing element on free
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"FPM_Initialize"
BOOL	FPM_Initialize( LPFPOOL				pPool,				// pointer to pool to initialize
						DWORD				dwElementSize,		// size of blocks in pool
						FN_BLOCKINITALLOC	fnBlockInitAlloc,	// fn called for each new alloc
						FN_BLOCKINIT		fnBlockInit,		// fn called each time block used
						FN_BLOCKRELEASE		fnBlockRelease,		// fn called each time block released
						FN_BLOCKFINI		fnBlockFini			// fn called before releasing mem
						)
{
	BOOL	fReturn;


	fReturn = TRUE;

	if ( DNInitializeCriticalSection(&pPool->cs) == FALSE )
	{
		fReturn = FALSE;
		goto Exit;
	}
	DebugSetCriticalSectionRecursionCount( &pPool->cs, 0 );

	pPool->pPoolElements      = NULL;
	pPool->nAllocated = 0;
	pPool->nInUse     = 0;

	if(fnBlockInitAlloc){
		pPool->fnBlockInitAlloc = fnBlockInitAlloc;
	} else {
		pPool->fnBlockInitAlloc = FN_BOOL_DUMMY;
	}
	if(fnBlockInit){
		pPool->fnBlockInit      = fnBlockInit;
	} else {
		pPool->fnBlockInit      = FN_VOID_DUMMY;
	}
	if(fnBlockRelease){
		pPool->fnBlockRelease	= fnBlockRelease;
	} else {
		pPool->fnBlockRelease	= FN_VOID_DUMMY;
	}
	if(fnBlockFini){
		pPool->fnBlockFini      = fnBlockFini;
	} else {
		pPool->fnBlockFini      = FN_VOID_DUMMY;
	}

	pPool->Get    = FPM_Get;
	pPool->Release= FPM_Release;
	pPool->Fini   = FPM_Fini;

	// FPM reuses the item memory as a linked list when not in use,
	// make sure the items are large enough
	ASSERT( dwElementSize >= sizeof( void* ) );
	pPool->cbItemSize = dwElementSize;

Exit:
	return	fReturn;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\fpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.h
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97	aarono	Original
 *	11-06-98	ejs		Add custom handler for Release function
 *	04-12-99	jtk		Trimmed unused functions and parameters, added size assert
 *	11-22-99	jtk		Modified to be .CPP compiliant
 *	01-21-2000	jtk		Modified to use DNCriticalSections.  Added code to check for
 *						items already being in the pool.
***************************************************************************/

#ifndef _FPM_H_
#define _FPM_H_

typedef struct FPOOL *PFPOOL, *LPFPOOL;

typedef BOOL (*FN_BLOCKINITALLOC)(void * pvItem);
typedef VOID (*FN_BLOCKINIT)(void * pvItem);
typedef VOID (*FN_BLOCKRELEASE)(void * pvItem);
typedef VOID (*FN_BLOCKFINI)(void *pvItem);

LPFPOOL FPM_Create(
	unsigned int		size,				// size of blocks in pool
	FN_BLOCKINITALLOC	fnBlockInitAlloc,	// fn called for each new alloc
	FN_BLOCKINIT		fnBlockInit,		// fn called each time block used
	FN_BLOCKRELEASE		fnBlockRelease,		// fn called each time block released
	FN_BLOCKFINI		fnBlockFini			// fn called before releasing mem
	);

BOOL	FPM_Initialize( LPFPOOL				pPool,				// pointer to pool to initialize
						DWORD				dwElementSize,		// size of blocks in pool
						FN_BLOCKINITALLOC	fnBlockInitAlloc,	// fn called for each new alloc
						FN_BLOCKINIT		fnBlockInit,		// fn called each time block used
						FN_BLOCKRELEASE		fnBlockRelease,		// fn called each time block released
						FN_BLOCKFINI		fnBlockFini			// fn called before releasing mem
						);

void	FPM_Deinitialize( LPFPOOL pPool );

typedef void * (*FPM_GET)(LPFPOOL pPool);						// get new item from pool
typedef void   (*FPM_RELEASE)(LPFPOOL pPool, void *pvItem);		// return item to pool
typedef void   (*FPM_FINI)(LPFPOOL pPool);						// close pool (this frees the pPool parameter!)

typedef struct FPOOL {
	// external
	FPM_GET		Get;
	FPM_RELEASE Release;
	FPM_FINI    Fini;

	// internal
	FN_BLOCKINITALLOC fnBlockInitAlloc;
	FN_BLOCKINIT      fnBlockInit;
	FN_BLOCKRELEASE	  fnBlockRelease;
	FN_BLOCKFINI      fnBlockFini;

	int		cbItemSize;
	void	*pPoolElements;
	int		nAllocated;
	int		nInUse;

	DNCRITICAL_SECTION cs;

} FPOOL, *LPFPOOL, *PFPOOL;

#endif	// _FPM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\guidutil.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       guidutil.h
 *  Content:    Some GUID related utility functions
 *
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 ***************************************************************************/

#ifndef _GUIDUTIL_H_
#define _GUIDUTIL_H_

#include <windows.h>

#define GUID_STRING_LEN 39

HRESULT DVStringFromGUID(const GUID* lpguid, WCHAR* wszBuf, DWORD dwNumChars);
HRESULT DVGUIDFromString(const WCHAR* wszBuf, GUID* lpguid);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\in_def.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		in_def.h
 *  Content:	Definition of common structs for voice instrumentation
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 02/17/2000	rodtoll	Created it
 ***************************************************************************/
#ifndef __IN_DEF_H
#define __IN_DEF_H

struct DVINSTRUMENT_INFO
{
	DVINSTRUMENT_INFO( DWORD dwLevel, DWORD dwDefaultLevel, const char *szProfileName ):	m_dwLevel(dwLevel), m_dwDefaultLevel(dwDefaultLevel), m_szProfileName(szProfileName) {};	
	DWORD	m_dwLevel;
	DWORD m_dwDefaultLevel;
	const char *m_szProfileName;
};

typedef DVINSTRUMENT_INFO *PDVINSTRUMENT_INFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\guidutil.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       guidutil.cpp
 *  Content:    Some GUID related utility functions
 *
 *  History:
 *	Date   By  Reason
 *	============
 *	08/19/99	pnewson		created
 ***************************************************************************/

#include "commoni.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DVStringFromGUID"
HRESULT DVStringFromGUID(const GUID* lpguid, WCHAR* swzBuf, DWORD dwNumChars)
{
	if (dwNumChars < GUID_STRING_LEN)
	{
		return E_FAIL;
	}
	
    swprintf( 
    	swzBuf, 
    	L"{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}", 
    	lpguid->Data1, 
    	lpguid->Data2, 
    	lpguid->Data3, 
        lpguid->Data4[0], 
        lpguid->Data4[1], 
        lpguid->Data4[2], 
        lpguid->Data4[3],
        lpguid->Data4[4], 
        lpguid->Data4[5], 
        lpguid->Data4[6], 
        lpguid->Data4[7] );
        
    return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DVGUIDFromString"
HRESULT DVGUIDFromString(const WCHAR* wszBuf, GUID* lpguid)
{
    UINT aiTmp[10];

    if( swscanf( wszBuf, L"{%8X-%4X-%4X-%2X%2X-%2X%2X%2X%2X%2X%2X}",
                    &lpguid->Data1, 
                    &aiTmp[0], &aiTmp[1], 
                    &aiTmp[2], &aiTmp[3],
                    &aiTmp[4], &aiTmp[5],
                    &aiTmp[6], &aiTmp[7],
                    &aiTmp[8], &aiTmp[9] ) != 11 )
    {
    	ZeroMemory(lpguid, sizeof(GUID));
        return FALSE;
    }
    else
    {
        lpguid->Data2       = (USHORT) aiTmp[0];
        lpguid->Data3       = (USHORT) aiTmp[1];
        lpguid->Data4[0]    = (BYTE) aiTmp[2];
        lpguid->Data4[1]    = (BYTE) aiTmp[3];
        lpguid->Data4[2]    = (BYTE) aiTmp[4];
        lpguid->Data4[3]    = (BYTE) aiTmp[5];
        lpguid->Data4[4]    = (BYTE) aiTmp[6];
        lpguid->Data4[5]    = (BYTE) aiTmp[7];
        lpguid->Data4[6]    = (BYTE) aiTmp[8];
        lpguid->Data4[7]    = (BYTE) aiTmp[9];
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\lockedccfpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ContextCFPM.h
 *  Content:	fixed pool manager for classes that takes into account contexts
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97	aarono	Original
 *	11-06-98	ejs		Add custom handler for Release function
 *	04-12-99	jtk		Trimmed unused functions and parameters, added size assert
 *	01-31-2000	jtk		Added code to check for items already being in the pool on Release().
 *	02-08-2000	jtk		Derived from ClassFPM.h
***************************************************************************/

#ifndef __LOCKED_CONTEXT_CLASS_FPM_H__
#define __LOCKED_CONTEXT_CLASS_FPM_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

#ifdef	_WIN64
#define	BLANK_NODE_VALUE	0xAA55817E6D5C4B3A
#else	// _WIN64
#define	BLANK_NODE_VALUE	0xAA55817E
#endif	// _WIN64

#define	CHECK_FOR_DUPLICATE_LOCKEDCCFPM_RELEASE

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

// class to act as a link in the pool
template< class T >
class	CLockedContextClassFPMPoolNode
{
	STDNEWDELETE

	public:
		CLockedContextClassFPMPoolNode() { m_pNext = NULL; }
		~CLockedContextClassFPMPoolNode() {};

		CLockedContextClassFPMPoolNode	*m_pNext;
		void	*m_pContext;
		T		m_Item;

	protected:
	private:
};

// class to manage the pool
template< class T >
class	CLockedContextClassFixedPool
{
	STDNEWDELETE

	public:
		CLockedContextClassFixedPool();
		~CLockedContextClassFixedPool();


typedef BOOL (T::*PBOOLCALLBACK)( void *const pContext );
typedef void (T::*PVOIDCALLBACK)( void *const pContext );

		BOOL	Initialize( PBOOLCALLBACK pAllocFunction,
							PBOOLCALLBACK pInitFunction,
							PVOIDCALLBACK pReleaseFunction,
							PVOIDCALLBACK pDeallocFunction );

		void	Deinitialize( void );

		T		*Get( void *const pContext );
		void	Release( T *const pItem );

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;

		PBOOLCALLBACK	m_pAllocFunction;
		PBOOLCALLBACK	m_pInitFunction;
		PVOIDCALLBACK	m_pReleaseFunction;
		PVOIDCALLBACK	m_pDeallocFunction;

		CLockedContextClassFPMPoolNode< T >	*volatile m_pPool;		// pointer to list of available elements

		BOOL			m_fInitialized;					// Initialized ?

		DEBUG_ONLY( LONG	volatile m_lOutstandingItemCount );
};

//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextClassFixedPool::CLockedContextClassFixedPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
template< class T >
CLockedContextClassFixedPool< T >::CLockedContextClassFixedPool():
	m_pAllocFunction( NULL ),
	m_pInitFunction( NULL ),
	m_pReleaseFunction( NULL ),
	m_pDeallocFunction( NULL ),
	m_pPool( NULL ),
	m_fInitialized( FALSE )
{
	DEBUG_ONLY( m_lOutstandingItemCount = 0 );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextClassFixedPool::~CLockedContextClassFixedPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCFPM::CCFPM"

template< class T >
CLockedContextClassFixedPool< T >::~CLockedContextClassFixedPool()
{
	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextClassFixedPool::Initialize - initialize pool
//
// Entry:		Pointer to function to call when a new entry is allocated
//				Pointer to function to call when a new entry is removed from the pool
//				Pointer to function to call when an entry is returned to the pool
//				Pointer to function to call when an entry is deallocated
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCFPM::Initialize"

template< class T >
BOOL	CLockedContextClassFixedPool< T >::Initialize( PBOOLCALLBACK pAllocFunction, PBOOLCALLBACK pInitFunction, PVOIDCALLBACK pReleaseFunction, PVOIDCALLBACK pDeallocFunction )
{
	BOOL	fReturn;

	DNASSERT( m_fInitialized == FALSE );

	DNASSERT( pAllocFunction != NULL );
	DNASSERT( pInitFunction != NULL );
	DNASSERT( pReleaseFunction != NULL );
	DNASSERT( pDeallocFunction != NULL );

	fReturn = TRUE;

	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		fReturn = FALSE;
		goto Exit;
	}

	m_pAllocFunction = pAllocFunction;
	m_pInitFunction = pInitFunction;
	m_pReleaseFunction = pReleaseFunction;
	m_pDeallocFunction = pDeallocFunction;

	m_fInitialized = TRUE;

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextClassFixedPool::Deinitialize - deinitialize pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCFPM::Deinitialize"

template< class T >
void	CLockedContextClassFixedPool< T >::Deinitialize( void )
{
	DNASSERT( m_fInitialized == TRUE );

	DNEnterCriticalSection(&m_Lock);
	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	while ( m_pPool != NULL )
	{
		CLockedContextClassFPMPoolNode< T >	*pNode;
		T*	pItem;

		pNode = m_pPool;
		m_pPool = m_pPool->m_pNext;
		(pNode->m_Item.*this->m_pDeallocFunction)( pNode->m_pContext );
		delete	pNode;
	}
	DNLeaveCriticalSection(&m_Lock);

	DNDeleteCriticalSection(&m_Lock);

	m_fInitialized = FALSE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextClassFixedPool::Get - get an item from the pool
//
// Entry:		Pointer to user context
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCFPM::Get"

template< class T >
T	*CLockedContextClassFixedPool< T >::Get( void *const pContext )
{
	CLockedContextClassFPMPoolNode< T >	*pNode;
	T	*pReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
	pReturn = NULL;

	DNEnterCriticalSection(&m_Lock);

	//
	// if the pool is empty, try to allocate a new entry, otherwise grab
	// the first item from the pool
	//
	if ( m_pPool == NULL )
	{
		DNLeaveCriticalSection(&m_Lock);
		pNode = new CLockedContextClassFPMPoolNode< T >;
		if ( pNode != NULL )
		{
			if ( (pNode->m_Item.*this->m_pAllocFunction)( pContext ) == FALSE )
			{
				delete pNode;
				pNode = NULL;
			}
		}
	}
	else
	{
		pNode = m_pPool;
		m_pPool = m_pPool->m_pNext;
		DNLeaveCriticalSection(&m_Lock);
	}


	//
	// if we have an entry (it was freshly created, or removed from the pool),
	// attempt to initialize it before passing it to the user
	//
	if ( pNode != NULL )
	{
		if ( (pNode->m_Item.*this->m_pInitFunction)( pContext ) == FALSE )
		{
			DNEnterCriticalSection(&m_Lock);

			pNode->m_pNext = m_pPool;
			m_pPool = pNode;

			DNLeaveCriticalSection(&m_Lock);

			pNode = NULL;
		}
		else
		{
			pNode->m_pContext = pContext;
			pReturn = &pNode->m_Item;

			DEBUG_ONLY( pNode->m_pNext = (CLockedContextClassFPMPoolNode<T>*) BLANK_NODE_VALUE );
			DEBUG_ONLY( InterlockedIncrement(const_cast<LONG*>(&m_lOutstandingItemCount)) );
		}
	}

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextClassFixedPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CCFPM::Release"

template< class T >
void	CLockedContextClassFixedPool< T >::Release( T *const pItem )
{
	CLockedContextClassFPMPoolNode< T >	*pNode;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );
	DBG_CASSERT( sizeof( CLockedContextClassFPMPoolNode< T >* ) == sizeof( BYTE* ) );
	pNode = reinterpret_cast<CLockedContextClassFPMPoolNode< T >*>( &reinterpret_cast<BYTE*>( pItem )[ -OFFSETOF( CLockedContextClassFPMPoolNode< T >, m_Item ) ] );

	DEBUG_ONLY( DNASSERT( pNode->m_pNext == (CLockedContextClassFPMPoolNode< T >*)BLANK_NODE_VALUE ) );
	(pNode->m_Item.*this->m_pReleaseFunction)( pNode->m_pContext );
	DNEnterCriticalSection(&m_Lock);

#if defined(CHECK_FOR_DUPLICATE_LOCKEDCCFPM_RELEASE) && defined(DEBUG)
	{
		CLockedContextClassFPMPoolNode< T >	*pTemp;


		pTemp = m_pPool;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pNode );
			pTemp = pTemp->m_pNext;
		}
	}
#endif	// CHECK_FOR_DUPLICATE_LOCKEDCCFPM_RELEASE
	
	pNode->m_pNext = m_pPool;
	m_pPool = pNode;
	DEBUG_ONLY( InterlockedDecrement(const_cast<LONG*>(&m_lOutstandingItemCount)) );
	DNLeaveCriticalSection(&m_Lock);
}
//**********************************************************************

#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__

#undef DPF_MODNAME
#undef DPF_SUBCOMP

#endif	// __LOCKED_CONTEXT_CLASS_FPM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\lockedcontextfixedpool.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       LockedContextFixedPool.h
 *  Content:	fixed pool manager for classes that takes into account contexts
 *
 *  History:
 *   Date		By			Reason
 *   ======		==			======
 *  12-18-97	aarono		Original
 *	11-06-98	ejs			Add custom handler for Release function
 *	04-12-99	johnkan		Trimmed unused functions and parameters, added size assert
 *	01-31-2000	johnkan		Added code to check for items already being in the pool on Release().
 *	02-08-2000	johnkan		Derived from ClassFPM.h
 *	03-26-2000	johnkan		Renamed to avoid collisions with other classes
 *	04-06-2000	johnkan		Modified to have a base class to derive pool items from
***************************************************************************/

#ifndef __LOCKED_CONTEXT_FIXED_POOL__
#define __LOCKED_CONTEXT_FIXED_POOL__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	CHECK_FOR_DUPLICATE_LOCKED_CONTEXT_FPM_RELEASE

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward reference
//
template< class S > class	CLockedContextFixedPoolItem;
template< class T, class S > class	CLockedContextFixedPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class to act as a link in the pool
//
template< class S >
class	CLockedContextFixedPoolItem
{
	STDNEWDELETE

	public:
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedContextFixedPoolItem::CLockedContextFixedPoolItem"
		CLockedContextFixedPoolItem()
		{
			m_iRefCount = 0;
			m_pNext = NULL;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedContextFixedPoolItem::~CLockedContextFixedPoolItem"
		virtual	~CLockedContextFixedPoolItem() { DNASSERT( m_iRefCount == 0 ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedContextFixedPoolItem::AddRef"
		void	AddRef( void )
		{
			DNASSERT( m_iRefCount != -1 );
			InterlockedIncrement( const_cast<LONG*>( &m_iRefCount ) );
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedContextFixedPoolItem::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_iRefCount != 0 );
			if ( InterlockedDecrement( const_cast<LONG*>( &m_iRefCount ) ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		CLockedContextFixedPoolItem	*GetNext( void ) const { return m_pNext; }
		void	InvalidateNext( void ) { m_pNext = NULL; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedContextFixedPoolItem::LinkToPool"
		void	LinkToPool( CLockedContextFixedPoolItem *volatile *const ppPoolItems )
		{
			DNASSERT( ppPoolItems != NULL );
			m_pNext = *ppPoolItems;
			*ppPoolItems = this;
		}

		//
		// Default initialization and deinitialization functions.  These can
		// be overridden by the derived classes.
		//
		virtual	BOOL	PoolAllocFunction( S Context ){ return TRUE; }
		virtual	BOOL	PoolInitFunction( S Context ){ return TRUE; }
		virtual void	PoolReleaseFunction( void ){};
		virtual void	PoolDeallocFunction( void ){};

	protected:
	
	private:
		//
		// reference count used to return this item to the pool
		//
		volatile LONG	m_iRefCount;	

		//
		// pointer used to link this item to the rest of the pool
		//
		CLockedContextFixedPoolItem		*m_pNext;

		virtual void	ReturnSelfToPool( void ) = 0;

		//
		// prevent unwarranted copies
		//
		CLockedContextFixedPoolItem< S >( const CLockedContextFixedPoolItem< S > & );
		CLockedContextFixedPoolItem< S >& operator=( const CLockedContextFixedPoolItem< S > & );
};


//
// class to manage the pool
//
template< class T, class S >
class	CLockedContextFixedPool
{
	STDNEWDELETE

	public:
		CLockedContextFixedPool();
		~CLockedContextFixedPool();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		BOOL	Initialize( void );
		void	Deinitialize( void );

		T		*Get( S Context );
		void	Release( T *const pItem );

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;

		CLockedContextFixedPoolItem< S >	*volatile m_pPool;		// pointer to list of available elements

		DEBUG_ONLY( BOOL			m_fInitialized );
		DEBUG_ONLY( volatile LONG	m_lOutstandingItemCount );

		T	*RemoveNode( void )
		{
			T	*pReturn;


			if ( m_pPool != NULL )
			{
				pReturn = static_cast<T*>( m_pPool );
				m_pPool = m_pPool->GetNext();
				DEBUG_ONLY( pReturn->InvalidateNext() );
			}
			else
			{
				pReturn = NULL;
			}

			return	pReturn;
		}
		
		//
		// prevent unwarranted copies
		//
		CLockedContextFixedPool< T, S >( const CLockedContextFixedPool< T, S > & );
		CLockedContextFixedPool< T, S >& operator=( const CLockedContextFixedPool< T, S > & );
};


//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextFixedPool::CLockedContextFixedPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
template< class T, class S >
CLockedContextFixedPool< T, S >::CLockedContextFixedPool():
	m_pPool( NULL )
{
	DEBUG_ONLY( m_fInitialized = FALSE );
	DEBUG_ONLY( m_lOutstandingItemCount = 0 );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextFixedPool::~CLockedContextFixedPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
template< class T, class S >
CLockedContextFixedPool< T, S >::~CLockedContextFixedPool()
{
	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextFixedPool::Initialize - initialize pool
//
// Entry:		Nothing
//				Pointer to function to call when a new entry is removed from the pool
//				Pointer to function to call when an entry is returned to the pool
//				Pointer to function to call when an entry is deallocated
//
// Exit:		Boolean indicating success
//				TRUE = initialization succeeded
//				FALSE = initialization failed
// ------------------------------
template< class T, class S >
BOOL	CLockedContextFixedPool< T, S >::Initialize( void )
{
	BOOL	fReturn;

	
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );

	fReturn = TRUE;

	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		fReturn = FALSE;
		goto Exit;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );

	DEBUG_ONLY( m_fInitialized = TRUE );

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextFixedPool::Deinitialize - deinitialize pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
template< class T, class S >
void	CLockedContextFixedPool< T, S >::Deinitialize( void )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	Lock();

	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	while ( m_pPool != NULL )
	{
		CLockedContextFixedPoolItem< S >	*pNode;

		
		pNode = RemoveNode();
		pNode->PoolDeallocFunction();
		delete	pNode;
	}
	
	Unlock();

	DNDeleteCriticalSection( &m_Lock );

	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextFixedPool::Get - get an item from the pool
//
// Entry:		Pointer to user context
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
template< class T, class S >
T	*CLockedContextFixedPool< T, S >::Get( S Context )
{
	T	*pReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
	pReturn = NULL;

	Lock();

	//
	// if the pool is empty, try to allocate a new entry, otherwise grab
	// the first item from the pool
	//
	if ( m_pPool == NULL )
	{
		Unlock();
		
		pReturn = new T;
		if ( pReturn != NULL )
		{
			if ( pReturn->PoolAllocFunction( Context ) == FALSE )
			{
				delete pReturn;
				pReturn = NULL;
			}
		}
	}
	else
	{
		pReturn = RemoveNode();
		Unlock();
	}


	//
	// if we have an entry (it was freshly created, or removed from the pool),
	// attempt to initialize it before passing it to the user
	//
	if ( pReturn != NULL )
	{
		if ( pReturn->PoolInitFunction( Context ) == FALSE )
		{
			Lock();
			
			pReturn->LinkToPool( &m_pPool );
			
			Unlock();
			
			pReturn = NULL;
		}
		else
		{
			pReturn->SetOwningPool( this );
			pReturn->AddRef();
			DEBUG_ONLY( InterlockedIncrement( const_cast<LONG*>( &m_lOutstandingItemCount ) ) );
		}
	}

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedContextFixedPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
template< class T, class S >
void	CLockedContextFixedPool< T, S >::Release( T *const pItem )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( pItem != NULL );

	
	DEBUG_ONLY( DNASSERT( pItem->GetNext() == NULL ) );
	pItem->PoolReleaseFunction();
	
	Lock();
#if defined(CHECK_FOR_DUPLICATE_LOCKED_CONTEXT_FPM_RELEASE) && defined(DEBUG)
	{
		CLockedContextFixedPoolItem< S >	*pTemp;


		pTemp = m_pPool;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pItem );
			pTemp = pTemp->GetNext();
		}
	}
#endif	// CHECK_FOR_DUPLICATE_LOCKED_CONTEXT_FPM_RELEASE
	DEBUG_ONLY( pItem->SetOwningPool( NULL ) );
	pItem->LinkToPool( &m_pPool );
	Unlock();
	
	DEBUG_ONLY( InterlockedDecrement( const_cast<LONG*>( &m_lOutstandingItemCount ) ) );
}
//**********************************************************************

#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__

#undef DPF_SUBCOMP
#undef DPF_MODNAME

#endif	// __LOCKED_CONTEXT_FIXED_POOL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\osind.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       OSInd.cpp
 *  Content:	OS indirection functions to abstract OS specific items.
 *
 *  History:
 *   Date		By	Reason
 *   ====		==	======
 *	07/12/99	jtk	Created
 *	09/21/99	rodtoll	Fixed for retail builds
 *	09/22/99	jtk	Added callstacks to memory allocations
 *	08/28/2000	masonb	Voice Merge: Allow new and delete with size of 0
 ***************************************************************************/

#include "commoni.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

#define PROF_SECT		"DirectPlay8"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//
// Macro to compute the offset of an element inside of a larger structure.
// Copied from MSDEV's STDLIB.H and modified to return INT_PTR
//
#ifdef OFFSETOF
#undef OFFSETOF
#endif
#define OFFSETOF(s,m)	( ( INT_PTR ) &( ( (s*) 0 )->m ) )

//
// macro for length of array
//
#define	LENGTHOF( arg )		( sizeof( arg ) / sizeof( arg[ 0 ] ) )

//
// ASSERT macro
//

#ifdef ASSERT
#undef ASSERT
#endif

#ifdef	_DEBUG

#define	ASSERT( arg )	if ( arg == FALSE ) { _asm { int 3 }; }

#else	// _DEBUG

#define	ASSERT( arg )

#endif	//_DEBUG

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// time variables
//
static	DNCRITICAL_SECTION	g_TimeLock;
static	DWORD				g_dwLastTimeCall = 0;

DWORD g_dwCurrentMem = 0;
DWORD g_dwMaxMem = 0;

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// DNOSIndirectionInit - initialize the OS indirection layer
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization unsuccessful
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIndirectionInit"

BOOL	DNOSIndirectionInit( void )
{
	//
	// get initial time for timebase
	//
	g_dwLastTimeCall = timeGetTime();
	if ( DNInitializeCriticalSection( &g_TimeLock ) == FALSE )
	{
		goto Failure;
	}

	goto Exit;

Exit:
	return	TRUE;

Failure:
	DNOSIndirectionDeinit();

	return FALSE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNOSIndirectionDeinit - deinitialize OS indirection layer
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIndirectionDeinit"

void	DNOSIndirectionDeinit( void )
{
	//
	// clean up time management resources
	//
	DNDeleteCriticalSection( &g_TimeLock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNTimeGet - get time in milliseconds
//
// Entry:		Pointer to destination time
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNTimeGet"

void	DNTimeGet( DN_TIME *const pTimeDestination )
{
static	DN_TIME	Time = { 0 };
	DN_TIME		DeltaT;
	DWORD		dwCurrentTime;


	DNASSERT( pTimeDestination != NULL );

#pragma	BUGBUG( johnkan, "Fix this!  We shouldn't call timeGetTime() for time each function call!" )
#pragma	TODO( johnkan, "Should this be inlined?" )

	DNEnterCriticalSection( &g_TimeLock );

	//
	// we'll assume that we're getting called more than once every 40 days
	// so time wraps can be easily accounted for
	//
	dwCurrentTime = timeGetTime();
	DeltaT.Time32.TimeHigh = 0;
	DeltaT.Time32.TimeLow = dwCurrentTime - g_dwLastTimeCall;
	if ( DeltaT.Time32.TimeLow > 0x7FFFFFFFF )
	{
		DNASSERT( FALSE );
		DeltaT.Time32.TimeLow = -static_cast<INT>( DeltaT.Time32.TimeLow );
	}

	g_dwLastTimeCall = dwCurrentTime;
	DNTimeAdd( &Time, &DeltaT, &Time );

	DBG_CASSERT( sizeof( *pTimeDestination ) == sizeof( Time ) );
	memcpy( pTimeDestination, &Time, sizeof( *pTimeDestination ) );

	DNLeaveCriticalSection( &g_TimeLock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNTimeCompare - compare two times
//
// Entry:		Pointer to time1
//				Pointer to time2
//
// Exit:		Value indicating relative magnitude
//				-1 = *pTime1 < *pTime2
//				0 = *pTime1 == *pTime2
//				1 = *pTime1 > *pTime2
//
// Notes:	This function comes in 32-bit and 64-bit flavors.  This function
//			will result in a compile error if compiled on an unsupported platform.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNTimeCompare"

INT_PTR	DNTimeCompare( const DN_TIME *const pTime1, const DN_TIME *const pTime2 )
{
	UINT_PTR	iReturnValue;


	DNASSERT( pTime1 != NULL );
	DNASSERT( pTime2 != NULL );

#pragma	TODO( johnkan, "Should this be inlined?" )

//#ifdef	_WIN32
	if ( pTime1->Time32.TimeHigh < pTime2->Time32.TimeHigh )
	{
		iReturnValue = -1;
	}
	else
	{
		if ( pTime1->Time32.TimeHigh > pTime2->Time32.TimeHigh )
		{
			iReturnValue = 1;
		}
		else
		{
			if ( pTime1->Time32.TimeLow < pTime2->Time32.TimeLow )
			{
				iReturnValue = -1;
			}
			else
			{
				if ( pTime1->Time32.TimeLow == pTime2->Time32.TimeLow )
				{
					iReturnValue = 0;
				}
				else
				{
					iReturnValue = 1;
				}
			}
		}
	}
//#endif	// _WIN32


//#ifdef	_WIN64
//	// debug me!
//	DNASSERT( FALSE );
//
//	if ( pTime1->Time < pTime2->Time )
//	{
//		iReturnValue = -1;
//	}
//	else
//	{
//		if ( pTime1->Time == pTime2->Time )
//		{
//			iReturnValue = 0;
//		}
//		else
//		{
//			iReturnValue = 1;
//		}
//	}
//#endif	// _WIN64

	return	iReturnValue;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNTimeAdd - add two times
//
// Entry:		Pointer to time1
//				Pointer to time2
//				Pointer to time result
//
// Exit:		Nothing
//
// Note:	This function assumes that the time calculation won't wrap!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNTimeAdd"

void	DNTimeAdd( const DN_TIME *const pTime1, const DN_TIME *const pTime2, DN_TIME *const pTimeResult )
{
	DNASSERT( pTime1 != NULL );
	DNASSERT( pTime2 != NULL );
	DNASSERT( pTimeResult != NULL );

#pragma	TODO( johnkan, "Should this be inlined?" )

	_asm { mov ecx, pTime1
		   mov eax, ( DN_TIME [ ecx ] ).Time32.TimeLow;
		   mov edx, ( DN_TIME [ ecx ] ).Time32.TimeHigh

		   mov ecx, pTime2
		   add eax, ( DN_TIME [ ecx ] ).Time32.TimeLow
		   adc edx, ( DN_TIME [ ecx ] ).Time32.TimeHigh

		   mov ecx, pTimeResult
		   mov ( DN_TIME [ ecx ] ).Time32.TimeLow, eax
		   mov ( DN_TIME [ ecx ] ).Time32.TimeHigh, edx
		   };
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNTimeSubtract - subtract two times
//
// Entry:		Pointer to time1
//				Pointer to time2
//				Pointer to time result
//
// Exit:		Nothing
//
// Notes:	This function assumes no underflow!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNTimeSubtract"

void	DNTimeSubtract( const DN_TIME *const pTime1, const DN_TIME *const pTime2, DN_TIME *const pTimeResult )
{
	DNASSERT( pTime1 != NULL );
	DNASSERT( pTime2 != NULL );
	DNASSERT( pTimeResult != NULL );


#pragma	TODO( johnkan, "Should this be inlined?" )


	_asm { mov ecx, pTime1
		   mov eax, ( DN_TIME [ ecx ] ).Time32.TimeLow
		   mov edx, ( DN_TIME [ ecx ] ).Time32.TimeHigh

		   mov ecx, pTime2
		   sub eax, ( DN_TIME [ ecx ] ).Time32.TimeLow
		   sbb edx, ( DN_TIME [ ecx ] ).Time32.TimeHigh

		   mov ecx, pTimeResult
		   mov ( DN_TIME [ ecx ] ).Time32.TimeLow, eax
		   mov ( DN_TIME [ ecx ] ).Time32.TimeHigh, edx
		   };
}
//**********************************************************************


void* DNMalloc( size_t size )
{
	void *pBuffer = NULL;

	if (size+g_dwCurrentMem <= g_dwMaxMem)
	{
		pBuffer = (void*) LocalAlloc(LMEM_ZEROINIT, size);
		if (pBuffer != NULL)
		{
			g_dwCurrentMem += size;
		}
	}

	return pBuffer;
}

void DNFree( void *pData )
{
	if (pData != NULL)
	{
		g_dwCurrentMem -= LocalSize((HLOCAL) pData);
		LocalFree( (HLOCAL) pData );
	}
}

void * DNRealloc( void *pData, size_t newsize )
{
	void *pBuffer = NULL;

	pBuffer = (void*) LocalReAlloc( (HLOCAL) pData, newsize, 0 );

	if (pBuffer != NULL)
	{
		g_dwCurrentMem -= LocalSize((HLOCAL)pData);
		g_dwCurrentMem += newsize;
	}

	return pBuffer;

/*
// OLD REALLOC
	VOID *pNewData = NULL;
	UINT oldsize = 0;

	oldsize = LocalSize((HLOCAL)pData);

	if (newsize+g_dwCurrentMem <= g_dwMaxMem)
	{
		pNewData = (void*) LocalAlloc(LMEM_ZEROINIT, newsize);
	
		if (pNewData != NULL)
		{
			memcpy(pNewData, pData, (oldsize < newsize) ? oldsize : newsize );
			DNFree(pData);

			if (newsize > oldsize)
			{
				g_dwCurrentMem += (newsize - oldsize);
			}
			else
			{
				g_dwCurrentMem -= (oldsize - newsize);
			}
		}
	}

	return pNewData;
*/
}

//**********************************************************************
// ------------------------------
// DNInitializeCriticalSection - initialize a critical section
//
// Entry:		Pointer to critical section
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failue
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNInitializeCriticalSection"

BOOL	DNInitializeCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	BOOL	fReturn;


	DNASSERT( pCriticalSection != NULL );
	fReturn = TRUE;

	memset( pCriticalSection, 0x00, sizeof( *pCriticalSection ) );

	InitializeCriticalSection( pCriticalSection );

	//
	// attempt to enter the critical section once
	//
	_try
	{
		EnterCriticalSection( pCriticalSection );
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		fReturn = FALSE;
	}

	//
	// if we didn't fail on entering the critical section, make sure
	// we release it
	//
	if ( fReturn != FALSE )
	{
		LeaveCriticalSection( pCriticalSection );
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNDeleteCriticalSection - delete a critical section
//
// Entry:		Pointer to critical section
//
// Exit:		Nothing
//
// Notes:	This function wrapping is overkill, but we're closing down so
//			the overhead is negligible.
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNDeleteCriticalSection"

void	DNDeleteCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	DNASSERT( pCriticalSection != NULL );

	DeleteCriticalSection( pCriticalSection );
	memset( pCriticalSection, 0x00, sizeof( *pCriticalSection ) );
}
//**********************************************************************

/*
//**********************************************************************
// ------------------------------
// operator new - allocate memory for a C++ class
//
// Entry:		Size of memory to allocate
//
// Exit:		Pointer to memory
//				NULL = no memory available
//
// Notes:	This function is for classes only and will ASSERT on zero sized
//			allocations!  This function also doesn't do the whole proper class
//			thing of checking for replacement 'new handlers' and will not throw
//			an exception if allocation fails.
// ------------------------------
inline	void*	__cdecl operator new( size_t size )
{
	DPF(0,"New called");
	
	return DNMalloc( size );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// operator delete - deallocate memory for a C++ class
//
// Entry:		Pointer to memory
//
// Exit:		Nothing
//
// Notes:	This function is for classes only and will ASSERT on NULL frees!
// ------------------------------
inline	void	__cdecl operator delete( void *pData )
{
	if( pData == NULL )
		return;

	DNFree( pData );
}
//**********************************************************************
*/


#ifdef	_DEBUG
//**********************************************************************
//**
//** THIS IS THE DEBUG-ONLY SECTION.  DON'T ADD FUNCTIONS HERE THAT ARE
//** REQUIRED FOR THE RELEASE BUILD!!
//**
//**********************************************************************

//**********************************************************************
//**
//** THIS IS THE DEBUG-ONLY SECTION.  DON'T ADD FUNCTIONS HERE THAT ARE
//** REQUIRED FOR THE RELEASE BUILD!!
//**
//**********************************************************************
#endif	// _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\lockedcfpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       LockedCFPM.h
 *  Content:	fixed size pool manager for classes that has its own locking mechanism
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97	aarono	Original
 *	11-06-98	ejs		Add custom handler for Release function
 *	04-12-99	jtk		Trimmed unused functions and parameters, added size assert
 *	01-31-2000	jtk		Added code to check for items already being in the pool on Release().
 *	02-09-2000	jtk		Dereived from ClassFPM.h
***************************************************************************/

#ifndef __LOCKED_CLASS_FPM_H__
#define __LOCKED_CLASS_FPM_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	LOCKEDCFPM_BLANK_NODE_VALUE		0x5A5A817E

#define	CHECK_FOR_DUPLICATE_LOCKEDCFPM_RELEASE

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

// class to act as a link in the pool
template< class T >
class	CLockedPoolNode
{
	STDNEWDELETE

	public:
		CLockedPoolNode() { m_pNext = NULL; }
		~CLockedPoolNode() {};

		T			m_Item;
		CLockedPoolNode	*m_pNext;

	protected:
	private:
};

// class to manage the pool
template< class T >
class	CLockedFixedPool
{
	STDNEWDELETE

	public:
		CLockedFixedPool();
		~CLockedFixedPool();

		BOOL	Initialize( void );
		void	Deinitialize( void );

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		T		*Get( void );
		void	Release( T *const pItem );

	protected:

	private:
		DNCRITICAL_SECTION		m_Lock;			// critical section		
		CLockedPoolNode< T >	*m_pPool;		// pointer to list of available elements
		DEBUG_ONLY( UINT_PTR	m_uOutstandingItemCount );
		DEBUG_ONLY( BOOL		m_fInitialized );
};

//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedFixedPool::CLockedFixedPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedFixedPool::CLockedFixedPool"

template< class T >
CLockedFixedPool< T >::CLockedFixedPool():m_pPool( NULL )
{
	DEBUG_ONLY( m_uOutstandingItemCount = 0 );
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedFixedPool::~CLockedFixedPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedFixedPool::~CLockedFixedPool"

template< class T >
CLockedFixedPool< T >::~CLockedFixedPool()
{
	DEBUG_ONLY( DNASSERT( m_uOutstandingItemCount == 0 ) );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
	while ( m_pPool != NULL )
	{
		CLockedPoolNode< T >	*pTemp;


		pTemp = m_pPool;
		m_pPool = m_pPool->m_pNext;
		delete	pTemp;
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedFixedPool::Initialize - initialize this pool
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedFixedPool::Initialize"

template< class T >
BOOL	CLockedFixedPool< T >::Initialize( void )
{
	BOOL	fReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
	fReturn = TRUE;
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		fReturn = FALSE;
	}
	else
	{
		DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );
	}

	DEBUG_ONLY( m_fInitialized = TRUE );

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedFixedPool::Deinitialize - deinitialize pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedFixedPool::Deinitialize"

template< class T >
void	CLockedFixedPool< T >::Deinitialize( void  )
{
	DNDeleteCriticalSection( &m_Lock );
	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedFixedPool::Get - get an item from the pool
//
// Entry:		Nothing
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedFixedPool::Get"

template< class T >
T	*CLockedFixedPool< T >::Get( void )
{
	CLockedPoolNode< T >	*pNode;
	T	*pReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
	pReturn = NULL;

	Lock();

	//
	// If the pool is empty, create a new item.  If the pool isn't empty, use
	// the first item in the pool
	//
	if ( m_pPool == NULL )
	{
		pNode = new CLockedPoolNode< T >;
	}
	else
	{
		pNode = m_pPool;
		m_pPool = m_pPool->m_pNext;
	}
	Unlock();

	if ( pNode != NULL )
	{
		DEBUG_ONLY( pNode->m_pNext = (CLockedPoolNode<T>*) LOCKEDCFPM_BLANK_NODE_VALUE );
		pReturn = &pNode->m_Item;
		DEBUG_ONLY( m_uOutstandingItemCount++ );
	}

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedFixedPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedFixedPool::Release"

template< class T >
void	CLockedFixedPool< T >::Release( T *const pItem )
{
	CLockedPoolNode< T >	*pNode;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( pItem != NULL );
	DBG_CASSERT( sizeof( BYTE* ) == sizeof( pItem ) );
	DBG_CASSERT( sizeof( CLockedPoolNode< T >* ) == sizeof( BYTE* ) );
	pNode = reinterpret_cast<CLockedPoolNode< T >*>( &reinterpret_cast<BYTE*>( pItem )[ -OFFSETOF( CLockedPoolNode< T >, m_Item ) ] );

	Lock();
#if defined(CHECK_FOR_DUPLICATE_LOCKEDCFPM_RELEASE) && defined(DEBUG)
	{
		CLockedPoolNode< T >	*pTemp;


		pTemp = m_pPool;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pNode );
			pTemp = pTemp->m_pNext;
		}
	}
#endif	// CHECK_FOR_DUPLICATE_LOCKEDCFPM_RELEASE

	DNASSERT( pNode->m_pNext == (CLockedPoolNode< T >*)LOCKEDCFPM_BLANK_NODE_VALUE );

	pNode->m_pNext = m_pPool;
	m_pPool = pNode;

	DEBUG_ONLY( m_uOutstandingItemCount-- );

	Unlock();
}
//**********************************************************************

#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__

#undef DPF_MODNAME
#undef DPF_SUBCOMP

#endif	// __LOCKED_CLASS_FPM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\lockedpool.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       LockedPool.h
 *  Content:	Pool manager for classes
 *
 *  History:
 *   Date		By			Reason
 *   ======		==			======
 *  12-18-97	aarono		Original
 *	11-06-98	ejs			Add custom handler for Release function
 *	04-12-99	johnkan		Trimmed unused functions and parameters, added size assert
 *	01-31-2000	johnkan		Added code to check for items already being in the pool on Release().
 *	02-08-2000	johnkan		Derived from ClassFPM.h
 *	03-26-2000	johnkan		Renamed to avoid collisions with other classes
 *	04-06-2000	johnkan		Modified to have a base class to derive pool items from
***************************************************************************/

#ifndef __LOCKED_POOL__
#define __LOCKED_POOL__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	CHECK_FOR_DUPLICATE_LOCKED_POOL_RELEASE

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
// Macro to compute the offset of an element inside of a larger structure (copied from MSDEV's STDLIB.H)
#define OFFSETOF(s,m)	( (INT_PTR) &(((s *)0)->m) )
#define	__LOCAL_OFFSETOF_DEFINED__
#endif	// OFFSETOF

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward reference
//
class	CLockedPoolItem;
template< class T > class	CLockedPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class to act as a link in the pool
//
class	CLockedPoolItem
{
	STDNEWDELETE

	public:
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedPoolItem::CLockedPoolItem"
		CLockedPoolItem()
		{
			m_iRefCount = 0;
			m_pNext = NULL;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedPoolItem::~CLockedPoolItem"
		virtual	~CLockedPoolItem() { DNASSERT( m_iRefCount == 0 ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedPoolItem::AddRef"
		void	AddRef( void )
		{
			DNASSERT( m_iRefCount != -1 );
			InterlockedIncrement( const_cast<LONG*>( &m_iRefCount ) );
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedPoolItem::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_iRefCount != 0 );
			if ( InterlockedDecrement( const_cast<LONG*>( &m_iRefCount ) ) == 0 )
			{
				ReturnSelfToPool();
			}
		}

		CLockedPoolItem	*GetNext( void ) const { return m_pNext; }
		void	InvalidateNext( void ) { m_pNext = NULL; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CLockedPoolItem::LinkToPool"
		void	LinkToPool( CLockedPoolItem *volatile *const ppPoolItems )
		{
			DNASSERT( ppPoolItems != NULL );
			m_pNext = *ppPoolItems;
			*ppPoolItems = this;
		}

		//
		// Default initialization and deinitialization functions.  These can
		// be overridden by the derived classes.
		//
		virtual	BOOL	PoolAllocFunction( void ){ return TRUE; }
		virtual	BOOL	PoolInitFunction( void ){ return TRUE; }
		virtual void	PoolReleaseFunction( void ){};
		virtual void	PoolDeallocFunction( void ){};

	protected:
	
	private:
		//
		// reference count used to return this item to the pool
		//
		volatile LONG	m_iRefCount;	

		//
		// pointer used to link this item to the rest of the pool
		//
		CLockedPoolItem		*m_pNext;

		virtual void	ReturnSelfToPool( void ) = 0;

		//
		// prevent unwarranted copies
		//
		CLockedPoolItem( const CLockedPoolItem & );
		CLockedPoolItem& operator=( const CLockedPoolItem & );
};


//
// class to manage the pool
//
template< class T >
class	CLockedPool
{
	STDNEWDELETE

	public:
		CLockedPool();
		~CLockedPool();

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		BOOL	Initialize( void );
		void	Deinitialize( void );

		T		*Get( void );
		void	Release( T *const pItem );

	protected:

	private:
		DNCRITICAL_SECTION	m_Lock;

		CLockedPoolItem	*volatile m_pPool;		// pointer to list of available elements

		DEBUG_ONLY( BOOL			m_fInitialized );
		DEBUG_ONLY( volatile LONG	m_lOutstandingItemCount );

		T	*RemoveNode( void )
		{
			T	*pReturn;


			if ( m_pPool != NULL )
			{
				pReturn = static_cast<T*>( m_pPool );
				m_pPool = m_pPool->GetNext();
				DEBUG_ONLY( pReturn->InvalidateNext() );
			}
			else
			{
				pReturn = NULL;
			}

			return	pReturn;
		}
		
		//
		// prevent unwarranted copies
		//
		CLockedPool< T >( const CLockedPool< T > & );
		CLockedPool< T >& operator=( const CLockedPool< T > & );
};


//**********************************************************************
// Class function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedPool::CLockedPool - constructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedPool::CLockedPool"

template< class T >
CLockedPool< T >::CLockedPool():
	m_pPool( NULL )
{
	DEBUG_ONLY( m_fInitialized = FALSE );
	DEBUG_ONLY( m_lOutstandingItemCount = 0 );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedPool::~CLockedPool - destructor
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedPool::~CLockedPool"

template< class T >
CLockedPool< T >::~CLockedPool()
{
	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedPool::Initialize - initialize pool
//
// Entry:		Nothing
//				Pointer to function to call when a new entry is removed from the pool
//				Pointer to function to call when an entry is returned to the pool
//				Pointer to function to call when an entry is deallocated
//
// Exit:		Boolean indicating success
//				TRUE = initialization succeeded
//				FALSE = initialization failed
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedPool::Initialize"

template< class T >
BOOL	CLockedPool< T >::Initialize( void )
{
	BOOL	fReturn;

	
	DEBUG_ONLY( DNASSERT( m_fInitialized == FALSE ) );

	fReturn = TRUE;

	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		fReturn = FALSE;
		goto Exit;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );

	DEBUG_ONLY( m_fInitialized = TRUE );

Exit:
	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedPool::Deinitialize - deinitialize pool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedPool::Deinitialize"

template< class T >
void	CLockedPool< T >::Deinitialize( void )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	Lock();

	DEBUG_ONLY( DNASSERT( m_lOutstandingItemCount == 0 ) );
	while ( m_pPool != NULL )
	{
		CLockedPoolItem	*pNode;

		
		pNode = RemoveNode();
		pNode->PoolDeallocFunction();
		delete	pNode;
	}
	
	Unlock();

	DNDeleteCriticalSection( &m_Lock );

	DEBUG_ONLY( m_fInitialized = FALSE );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedPool::Get - get an item from the pool
//
// Entry:		Nothing
//
// Exit:		Pointer to item
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedPool::Get"

template< class T >
T	*CLockedPool< T >::Get( void )
{
	T	*pReturn;


	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );

	//
	// initialize
	//
	pReturn = NULL;

	Lock();

	//
	// if the pool is empty, try to allocate a new entry, otherwise grab
	// the first item from the pool
	//
	if ( m_pPool == NULL )
	{
		Unlock();
		
		pReturn = new T;
		if ( pReturn != NULL )
		{
			if ( pReturn->PoolAllocFunction() == FALSE )
			{
				delete pReturn;
				pReturn = NULL;
			}
		}
	}
	else
	{
		pReturn = RemoveNode();
		Unlock();
	}


	//
	// if we have an entry (it was freshly created, or removed from the pool),
	// attempt to initialize it before passing it to the user
	//
	if ( pReturn != NULL )
	{
		if ( pReturn->PoolInitFunction() == FALSE )
		{
			Lock();
			
			pReturn->LinkToPool( &m_pPool );
			
			Unlock();
			
			pReturn = NULL;
		}
		else
		{
			pReturn->SetOwningPool( this );
			pReturn->AddRef();
			DEBUG_ONLY( InterlockedIncrement( const_cast<LONG*>( &m_lOutstandingItemCount ) ) );
		}
	}

	return	 pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CLockedPool::Release - return item to pool
//
// Entry:		Pointer to item
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CLockedPool::Release"

template< class T >
void	CLockedPool< T >::Release( T *const pItem )
{
	DEBUG_ONLY( DNASSERT( m_fInitialized != FALSE ) );
	DNASSERT( pItem != NULL );

	
	DEBUG_ONLY( DNASSERT( pItem->GetNext() == NULL ) );
	pItem->PoolReleaseFunction();
	
	Lock();
	
#if defined(CHECK_FOR_DUPLICATE_LOCKED_POOL_RELEASE) && defined(DEBUG)
	{
		CLockedPoolItem	*pTemp;


		pTemp = m_pPool;
		while ( pTemp != NULL )
		{
			DNASSERT( pTemp != pItem );
			pTemp = pTemp->GetNext();
		}
	}
#endif	// CHECK_FOR_DUPLICATE_LOCKED_POOL_RELEASE

	DEBUG_ONLY( pItem->SetOwningPool( NULL ) );
	pItem->LinkToPool( &m_pPool );
	Unlock();
	
	DEBUG_ONLY( InterlockedDecrement( const_cast<LONG*>( &m_lOutstandingItemCount ) ) );
}
//**********************************************************************

#ifdef	__LOCAL_OFFSETOF_DEFINED__
#undef	__LOCAL_OFFSETOF_DEFINED__
#undef	OFFSETOF
#endif	// __LOCAL_OFFSETOF_DEFINED__


#undef DPF_SUBCOMP
#undef DPF_MODNAME

#endif	// __LOCKED_POOL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\packbuff.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       PackBuff.h
 *  Content:	Packed Buffers
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/11/00	mjn		Created
 *  06/15/2000  rmt     Added func to add string to packbuffer
 ***************************************************************************/

#ifndef __PACK_BUFF_H__
#define __PACK_BUFF_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for packed buffer

class CPackedBuffer
{
	STDNEWDELETE

public:
	CPackedBuffer() { };	// Constructor

	~CPackedBuffer() { };	// Destructor

	void	Initialize(	void *const pvBuffer,
						const DWORD dwBufferSize );

	HRESULT AddToFront( const void *const pvBuffer,
						const DWORD dwBufferSize );

	HRESULT AddToBack( const void *const pvBuffer,
						const DWORD dwBufferSize );

	PVOID GetStartAddress( void ) { return m_pStart; };

    HRESULT AddWCHARStringToBack( const wchar_t * const pwszString );					

	PVOID GetHeadAddress( void ) const { return( m_pHead ); }

	PVOID GetTailAddress( void ) const { return( m_pTail ); }

	DWORD GetHeadOffset( void ) const
	{
		return( (DWORD)(m_pHead - m_pStart) );
	}

	DWORD GetTailOffset( void ) const
	{
		return( (DWORD)(m_pTail - m_pStart) );
	}

	DWORD GetSpaceRemaining( void ) const { return( m_dwRemaining ); }

	DWORD GetSizeRequired( void ) const { return( m_dwRequired ); }

private:
	BYTE	*m_pStart;			// Start of the buffer
	BYTE	*m_pHead;			// Pointer to head of free buffer
	BYTE	*m_pTail;			// Pointer to tail of free buffer
	DWORD	m_dwRemaining;		// bytes remaining in buffer
	DWORD	m_dwRequired;		// bytes required so far
	BOOL	m_bBufferTooSmall;	// buffer has run out of space
};



#endif	// __PACK_BUFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\osind.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       OSInd.h
 *  Content:	OS indirection functions to abstract OS specific items.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/12/99	jtk		Created
 * 	09/21/99	rodtoll		Fixed for retail build
 *   	08/28/2000	masonb		Voice Merge: Fix for code that only defines one of DEBUG, DBG, _DEBUG
 *   	08/28/2000	masonb		Voice Merge: Added IsUnicodePlatform macro
 *
 ***************************************************************************/

#ifndef	__OSIND_H__
#define	__OSIND_H__


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// critical section
//
#define DNCRITICAL_SECTION	CRITICAL_SECTION

//
// DirectNet time variable.  Currently 64-bit, but can be made larger
//
typedef	union
{
	UINT_PTR	Time64;

	struct
	{
		DWORD	TimeLow;
		DWORD	TimeHigh;
	} Time32;
} DN_TIME;

//**********************************************************************
// Variable definitions
//**********************************************************************
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

extern DWORD g_dwCurrentMem;
extern DWORD g_dwMaxMem;

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// initialization functions
//
BOOL	DNOSIndirectionInit( void );
void	DNOSIndirectionDeinit( void );

//
// time functions
//
void		DNTimeGet( DN_TIME *const pTimeDestination );
INT_PTR		DNTimeCompare( const DN_TIME *const pTime1, const DN_TIME *const pTime2 );
void		DNTimeAdd( const DN_TIME *const pTime1, const DN_TIME *const pTime2, DN_TIME *const pTimeResult );
void		DNTimeSubtract( const DN_TIME *const pTime1, const DN_TIME *const pTime2, DN_TIME *const pTimeResult );

//
// CriticalSection functions
//
#define	AssertCriticalSectionIsTakenByThisThread( pCS, Flag )
#define	DebugSetCriticalSectionRecursionCount( pCS, Count )
#define	DNEnterCriticalSection( arg )	EnterCriticalSection( arg )
#define	DNLeaveCriticalSection( arg )	LeaveCriticalSection( arg )

BOOL	DNInitializeCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNDeleteCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );


//
// Memory functions
//
#define STDNEWDELETE \
    public: __inline void *__cdecl operator new(size_t size) { return DNMalloc( size ); } \
    public: __inline void *__cdecl operator new[](size_t size) { return DNMalloc( size ); } \
    public: __inline void __cdecl operator delete(void *pData) { DNFree( pData ); } \
    public: __inline void __cdecl operator delete[](void *pData) { DNFree( pData ); }

void * DNMalloc( size_t size );
void DNFree( void *pData );
void * DNRealloc( void *pData, size_t newsize );


#endif	// __OSIND_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\queue.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Queue.h
 *  Content:	Queue manipulation functions.  This queue will not accept NULL
 *				as an argument because it is used to indicate an empty queue on
 *				Queue_DeQ.
 *
 *	Note:	This queue implementation requires the Fixed Pool manager found
 *			in FPM.h and FPM.c
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/15/98	jwo		Created it.
 *	04/16/99	jtk		Removed reliance on STL
 ***************************************************************************/

#ifndef __QUEUE_H__
#define __QUEUE_H__

#ifdef __cplusplus
extern "C" {
#endif

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef	struct	_QUEUE_ENTRY
{
	void			*pData;
	_QUEUE_ENTRY	*pNext;

} QUEUE_ENTRY;

typedef struct _QUEUE
{
	DNCRITICAL_SECTION	Lock;			// critical section
	HANDLE				hIsEmptyEvent;	// event signalled when queue is empty

	QUEUE_ENTRY		*pHead;		// pointer to head
	QUEUE_ENTRY		*pTail;		// pointer to tail

	FPOOL			Pool;		// pool of queue entries
} QUEUE;


//**********************************************************************
// Variable prototypes
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT	Queue_New( QUEUE **ppQueue, const HANDLE hIsEmptyEvent );
HRESULT	Queue_Delete( QUEUE *const pQueue );

BOOL	Queue_Initialize( QUEUE *const pQueue, const HANDLE hIsEmptyEvent );
void	Queue_Deinitialize( QUEUE *const pQueue );

HRESULT	Queue_EnQ( QUEUE *const pQueue, void *const lpvItem );
void	*Queue_DeQ( QUEUE *const pQueue );
BOOL	Queue_IsEmpty( const QUEUE *const pQueue );

void	Queue_Lock( QUEUE *const pQueue );
void	Queue_Unlock( QUEUE *const pQueue );

#ifdef __cplusplus
}
#endif


#endif	// __QUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\packbuff.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       PackBuff.cpp
 *  Content:	Packed Buffers
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/01/00	mjn		Created
 *  06/15/2000  rmt     Added func to add string to packbuffer
 ***************************************************************************/

#include "commoni.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CPackedBuffer::Initialize
//
// Entry:		void *const	pvBuffer		- Buffer to fill up (may be NULL)
//				const DWORD	dwBufferSize	- Size of buffer (may be 0)
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CPackedBuffer::Initialize"
void CPackedBuffer::Initialize(void *const pvBuffer,
								  const DWORD dwBufferSize)
{
	if (pvBuffer == NULL || dwBufferSize == 0)
	{
		m_pStart = NULL;
		m_pHead = NULL;
		m_pTail = NULL;
		m_dwRemaining = 0;
		m_bBufferTooSmall = TRUE;
	}
	else
	{
		m_pStart = reinterpret_cast<BYTE*>(pvBuffer);
		m_pHead = m_pStart;
		m_pTail = m_pStart + dwBufferSize;
		m_dwRemaining = dwBufferSize;
		m_bBufferTooSmall = FALSE;
	}
	m_dwRequired = 0;
}


//**********************************************************************
// ------------------------------
// CPackedBuffer::AddToFront
//
// Entry:		void *const	pvBuffer		- Buffer to add (may be NULL)
//				const DWORD	dwBufferSize	- Size of buffer (may be 0)
//
// Exit:		Error Code:	DPN_OK					if able to add
//							DPNERR_BUFFERTOOSMALL	if buffer is full
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CPackedBuffer::AddToFront"
HRESULT CPackedBuffer::AddToFront(const void *const pvBuffer,
								  const DWORD dwBufferSize)
{
	m_dwRequired += dwBufferSize;
	if (!m_bBufferTooSmall)
	{
		if (m_dwRemaining >= dwBufferSize)
		{
			if (pvBuffer)
			{
				memcpy(m_pHead,pvBuffer,dwBufferSize);
			}
			m_pHead += dwBufferSize;
			m_dwRemaining -= dwBufferSize;
		}
		else
		{
			m_bBufferTooSmall = TRUE;
		}
	}

	if (m_bBufferTooSmall)
		return(DPNERR_BUFFERTOOSMALL);

	return(DPN_OK);
}

//**********************************************************************
// ------------------------------
// CPackedBuffer::AddWCHARStringToBack
//
// Entry:		const wchar_t * const pwszString - String to add (may be NULL)
//
// Exit:		Error Code:	DPN_OK					if able to add
//							DPNERR_BUFFERTOOSMALL	if buffer is full
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CPackedBuffer::AddWCHARStringToBack"
HRESULT CPackedBuffer::AddWCHARStringToBack( const wchar_t * const pwszString )
{
    return AddToBack( pwszString, sizeof( wchar_t ) * (wcslen( pwszString )+1) );
}

//**********************************************************************
// ------------------------------
// CPackedBuffer::AddToBack
//
// Entry:		void *const	pvBuffer		- Buffer to add (may be NULL)
//				const DWORD	dwBufferSize	- Size of buffer (may be 0)
//
// Exit:		Error Code:	DPN_OK					if able to add
//							DPNERR_BUFFERTOOSMALL	if buffer is full
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CPackedBuffer::AddToBack"
HRESULT CPackedBuffer::AddToBack(const void *const pvBuffer,
								 const DWORD dwBufferSize)
{
	m_dwRequired += dwBufferSize;
	if (!m_bBufferTooSmall)
	{
		if (m_dwRemaining >= dwBufferSize)
		{
			m_pTail -= dwBufferSize;
			m_dwRemaining -= dwBufferSize;
			if (pvBuffer)
			{
				memcpy(m_pTail,pvBuffer,dwBufferSize);
			}
		}
		else
		{
			m_bBufferTooSmall = TRUE;
		}
	}

	if (m_bBufferTooSmall)
		return(DPNERR_BUFFERTOOSMALL);

	return(DPN_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\queue.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cq.cpp
 *  Content:	Implementation of a queue
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/19/98	jwo		Created it.
 *	04/16/99	jtk		Removed reliance on STL
***************************************************************************/

#include "commoni.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable prototypes
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// Queue_New - creates new queue
//
// Entry:		Pointer to pointer to queue to be created
//				Handle of event signalled when queue is empty
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Queue_New"

HRESULT	Queue_New( QUEUE **ppQueue, const HANDLE hIsEmptyEvent )
{
	HRESULT	hr;


	DNASSERT( ppQueue != NULL );

	// initialize
	hr = DPN_OK;
	*ppQueue = static_cast<QUEUE*>( DNMalloc( sizeof( QUEUE ) ) );
	if ( *ppQueue == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Exit;
	}

	memset( *ppQueue, 0x00, sizeof( **ppQueue ) );

	if ( Queue_Initialize( *ppQueue, hIsEmptyEvent ) == FALSE )
	{
		DPF( 0, "Failed to initialize queue!" );
		DNFree( *ppQueue );
		*ppQueue = NULL;
		hr = DPNERR_OUTOFMEMORY;
		goto Exit;
	}

Exit:
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// Queue_Delete - deletes a queue
//
// Entry:		Pointer to the queue to initialize
//				Pointer to initialization data
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Queue_Delete"

HRESULT	Queue_Delete( QUEUE *const pQueue )
{
	HRESULT	hr;


	DNASSERT( pQueue != NULL );
	DNASSERT( Queue_IsEmpty( pQueue ) != FALSE );

	// initialize
	hr = DPN_OK;

	Queue_Deinitialize( pQueue );
	DNFree( pQueue );

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// Queue_Initialize - intialize a queue
//
// Entry:		Pointer to queue
//				Handle of event signalled when the queue is empty
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Queue_Initialize"

BOOL	Queue_Initialize( QUEUE *const pQueue, const HANDLE hIsEmptyEvent )
{
	BOOL	fReturn;
	BOOL	fCriticalSectionInitialized;


	DNASSERT( pQueue != NULL );
	fReturn = TRUE;
	fCriticalSectionInitialized = FALSE;

	//
	// set internals
	//
	if ( DNInitializeCriticalSection( &pQueue->Lock ) == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &pQueue->Lock, 0 );

	pQueue->hIsEmptyEvent = hIsEmptyEvent;
	pQueue->pHead = NULL;
	pQueue->pTail = NULL;

	if ( FPM_Initialize( &pQueue->Pool,					// pointer to pool
						 sizeof( *(pQueue->pHead) ),	// size of item in pool
						 NULL,							// function called on item alloc (none)
						 NULL,							// function called on get (none)
						 NULL,							// function called on release (none)
						 NULL							// function called on item free (none)
						 ) == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}

Exit:
	return	fReturn;

Failure:
	if ( fCriticalSectionInitialized != FALSE )
	{
		DNDeleteCriticalSection( &pQueue->Lock );
		fCriticalSectionInitialized = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// Queue_Deinitialize - deinitialize a queue
//
// Entry:		Pointer to queue
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Queue_Deinitialize"

void	Queue_Deinitialize( QUEUE *const pQueue )
{
	DNASSERT( pQueue != NULL );
	DNASSERT( pQueue->pHead == NULL );
	DNASSERT( pQueue->pTail == NULL );

	FPM_Deinitialize( &pQueue->Pool );
	DNDeleteCriticalSection( &pQueue->Lock );
	DEBUG_ONLY( memset( pQueue, 0x00, sizeof( *pQueue ) ) );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// Queue_Lock - lock queue
//
// Entry:		Pointer to queue
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Queue_Lock"

void	Queue_Lock( QUEUE *const pQueue )
{
	DNASSERT( pQueue != NULL );
	DNEnterCriticalSection( &pQueue->Lock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// Queue_Unlock - unlock queue
//
// Entry:		Pointer to queue
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Queue_Unlock"

void	Queue_Unlock( QUEUE *const pQueue )
{
	DNASSERT( pQueue != NULL );
	DNLeaveCriticalSection( &pQueue->Lock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// Queue_EnQ - add element to queue
//
// Entry:		Pointer to queue
//				Pointer to data to add
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Queue_EnQ"

HRESULT	Queue_EnQ( QUEUE *const pQueue, void *const pItem )
{
	HRESULT	hr;
	QUEUE_ENTRY	*pTempElement;


	DNASSERT( pQueue != NULL );

	// NULL is reserved as a return value for a dequeue from and empty queue
	DNASSERT( pItem != NULL );

	// initialize
	hr = DPN_OK;

	Queue_Lock( pQueue );

	pTempElement = static_cast<QUEUE_ENTRY*>( pQueue->Pool.Get( &pQueue->Pool ) );
	if ( pTempElement == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPF( 0, "Out of memory when attempting to add to queue!" );
		goto Exit;
	}

	pTempElement->pData = pItem;
	pTempElement->pNext = NULL;
	if ( pQueue->pHead == NULL )
	{
		DNASSERT( pQueue->pTail == NULL );
		pQueue->pHead = pTempElement;
	}
	else
	{
		DNASSERT( pQueue->pTail != NULL );
		pQueue->pTail->pNext = pTempElement;
	}
	pQueue->pTail = pTempElement;

Exit:
	Queue_Unlock( pQueue );

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// Queue_DeQ - remove element from queue
//
// Entry:		Pointer to queue
//
// Exit:		Pointer to removed element
//				NULL implies that the queue is empty
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Queue_DeQ"

void	*Queue_DeQ( QUEUE *const pQueue )
{
	void	*pReturn;
	QUEUE_ENTRY	*pTempEntry;


	DNASSERT( pQueue != NULL );

	// initialize
	pReturn = NULL;
	Queue_Lock( pQueue );

	// note the entry being removed
	pTempEntry = pQueue->pHead;
	if ( pTempEntry != NULL )
	{
		pReturn = pTempEntry->pData;
		DNASSERT( pReturn != NULL );

		pQueue->pHead = pQueue->pHead->pNext;
		if ( pQueue->pHead == NULL )
		{
			DNASSERT( pQueue->pTail != NULL );
			pQueue->pTail = NULL;

			if ( pQueue->hIsEmptyEvent != NULL )
			{
				if ( SetEvent( pQueue->hIsEmptyEvent ) == FALSE )
				{
					DPF( 0, "Problem setting empty event for Queue!" );
					DisplayErrorCode( 0, GetLastError() );
				}
			}
		}

		// return Queue item to the available pool
		pQueue->Pool.Release( &pQueue->Pool, pTempEntry );
	}

	Queue_Unlock( pQueue );

	return	pReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// Queue_IsEmpty - checks for empty queue
//
// Entry:		Pointer to queue
//
// Exit:		Boolean indicating that the queue is empty
//
// Note:	This function doesn't lock the queue!
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "Queue_IsEmpty"

BOOL	Queue_IsEmpty( const QUEUE *const pQueue )
{
	BOOL	fReturn;


	DNASSERT( pQueue != NULL );

	// initialize
	fReturn = FALSE;

	if ( pQueue->pHead == NULL )
	{
		DNASSERT( pQueue->pTail == NULL );
		fReturn = TRUE;
	}

	return	fReturn;
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\rcbuffer.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       RCBuff.h
 *  Content:	RefCount Buffers
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/12/00	mjn		Created
 *	01/15/00	mjn		Added GetBufferAddress and GetBufferSize
 *	01/31/00	mjn		Allow user defined Alloc and Free
 ***************************************************************************/

#ifndef __RCBUFF_H__
#define __RCBUFF_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef PVOID (*PFNALLOC_REFCOUNT_BUFFER)(void *const,const DWORD);
typedef void (*PFNFREE_REFCOUNT_BUFFER)(void *const,void *const);
template< class CRefCountBuffer > class CLockedContextClassFixedPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

PVOID RefCountBufferDefaultAlloc(void *const pv,const DWORD dwSize);
void RefCountBufferDefaultFree(void *const pv,void *const pvBuffer);

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for RefCount buffer

class CRefCountBuffer
{
	STDNEWDELETE

public:
	CRefCountBuffer() { };		// Constructor

	~CRefCountBuffer() { };		// Destructor

	#undef DPF_MODNAME
	#define DPF_MODNAME "FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			m_pvContext = pvContext;

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
//			DNASSERT(pvContext == m_pvContext);

			m_lRefCount = 1;
			m_pvContext = pvContext;
			m_dnBufferDesc.dwBufferSize = 0;
			m_dnBufferDesc.pBufferData = NULL;

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "FPMRelease"
	void FPMRelease( void *const pvContext ) { };

	#undef DPF_MODNAME
	#define DPF_MODNAME "FPMDealloc"
	void FPMDealloc( void *const pvContext ) { };

	HRESULT Initialize(	CLockedContextClassFixedPool <CRefCountBuffer> *pFPRefCountBuffer,
						PFNALLOC_REFCOUNT_BUFFER pfnAlloc,
						PFNFREE_REFCOUNT_BUFFER pfnFree,
						void *const pvContext,
						const DWORD dwBufferSize);

	#undef DPF_MODNAME
	#define DPF_MODNAME "ReturnSelfToPool"
	void ReturnSelfToPool()
		{
			DNASSERT(m_lRefCount == 0);
			m_pFPOOLRefCountBuffer->Release( this );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "AddRef"
	void AddRef()
		{
			DNASSERT(m_lRefCount >= 0);
			InterlockedIncrement( &m_lRefCount );
		};

	void Release();

	#undef DPF_MODNAME
	#define DPF_MODNAME "SetBufferDesc"
	HRESULT SetBufferDesc(	BYTE *const pBufferData,
							const DWORD dwBufferSize,
							PFNFREE_REFCOUNT_BUFFER pfnFree,
							void *const pvContext)
		{
			DNASSERT(m_lRefCount > 0);

			if (m_dnBufferDesc.dwBufferSize || m_dnBufferDesc.pBufferData)
				return(DPNERR_INVALIDPARAM);

			m_dnBufferDesc.dwBufferSize = dwBufferSize;
			m_dnBufferDesc.pBufferData = pBufferData;
			m_pfnFree = pfnFree;
			m_pvContext = pvContext;

			return(DPN_OK);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "BufferDescAddress"
	DPN_BUFFER_DESC *BufferDescAddress()
		{
			return(&m_dnBufferDesc);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "GetBufferAddress"
	BYTE *GetBufferAddress()
		{
			return(m_dnBufferDesc.pBufferData);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "GetBufferSize"
	DWORD GetBufferSize()
		{
			return(m_dnBufferDesc.dwBufferSize);
		};


private:
	LONG						m_lRefCount;
	DPN_BUFFER_DESC				m_dnBufferDesc;		// Buffer
	CLockedContextClassFixedPool< CRefCountBuffer >	*m_pFPOOLRefCountBuffer;	// source FP of RefCountBuffers
	PFNFREE_REFCOUNT_BUFFER		m_pfnFree;			// Function to free buffer when released
	PFNALLOC_REFCOUNT_BUFFER	m_pfnAlloc;
	PVOID						m_pvContext;	// Context provided to free buffer call
};

#undef DPF_SUBCOMP
#undef DPF_MODNAME

#endif	// __RCBUFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\sources.inc ===
!include ..\..\sources.inc

TARGETNAME=common
TARGETPATH=obj
TARGETTYPE=LIBRARY

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\commoni.h
PRECOMPILED_PCH=commoni.pch
PRECOMPILED_OBJ=commoni.obj

!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DASSUME_VALID_PARAMETERS
!else
C_DEFINES=$(C_DEFINES) -DDEBUG
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Od
!endif

SOURCES=..\bilink.cpp \
        ..\comutil.cpp \
	..\dndbg.cpp \
	..\dneterrors.cpp \
	..\fpm.cpp \
	..\guidutil.cpp \
	..\osind.cpp \
	..\packbuff.cpp \
	..\queue.cpp \
	..\rcbuffer.cpp \
	..\strutils.cpp

USE_NOLIBS=1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\rcbuffer.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       RCBuffer.cpp
 *  Content:	RefCount Buffers
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/12/00	mjn		Created
 *	01/31/00	mjn		Allow user defined Alloc and Free
 ***************************************************************************/

#include "commoni.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CRefCountBuffer::Initialize
//
// Entry:		CFixedPool <CRefCountBuffer> *pFPRefCountBuffer
//				const DWORD dwBufferSize
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CRefCountBuffer::Initialize"

HRESULT CRefCountBuffer::Initialize(CLockedContextClassFixedPool <CRefCountBuffer> *pFPRefCountBuffer,
									PFNALLOC_REFCOUNT_BUFFER pfnAlloc,
									PFNFREE_REFCOUNT_BUFFER pfnFree,
									void *const pvContext,
									const DWORD dwBufferSize)
{
	DPF(3,"Entered");

	DNASSERT(pFPRefCountBuffer != NULL);
	DNASSERT((pfnAlloc == NULL && pfnFree == NULL) || (pfnAlloc != NULL && pfnFree != NULL));

	m_pFPOOLRefCountBuffer = pFPRefCountBuffer;

	if (dwBufferSize)
	{
		if (pfnAlloc)
		{
			m_pfnAlloc = pfnAlloc;
			m_pfnFree = pfnFree;
			m_pvContext = pvContext;
		}
		else
		{
			m_pfnAlloc = RefCountBufferDefaultAlloc;
			m_pfnFree = RefCountBufferDefaultFree;
		}
		m_dnBufferDesc.pBufferData = static_cast<BYTE*>((pfnAlloc)(m_pvContext,dwBufferSize));
		if (m_dnBufferDesc.pBufferData == NULL)
		{
			return(DPNERR_OUTOFMEMORY);
		}
		m_dnBufferDesc.dwBufferSize = dwBufferSize;
	}

	return(DPN_OK);
}

/*	REMOVE
//**********************************************************************
// ------------------------------
// CRefCountBuffer::ReturnSelfToPool
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CRefCountBuffer::ReturnSelfToPool"

void CRefCountBuffer::ReturnSelfToPool( void )
{
	DPF(3,"Entered");

	DNASSERT(m_lRefCount == 0);
	m_pFPOOLRefCountBuffer->Release( this );
}

*/	
//**********************************************************************
// ------------------------------
// CRefCountBuffer::Release
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "CRefCountBuffer::Release"

void CRefCountBuffer::Release( void )
{
	DNASSERT(m_lRefCount > 0);
	if ( InterlockedDecrement( &m_lRefCount ) == 0 )
	{
		if (m_pfnFree && m_dnBufferDesc.pBufferData)
		{
			(*m_pfnFree)(m_pvContext,m_dnBufferDesc.pBufferData);
			m_dnBufferDesc.pBufferData = NULL;
			m_dnBufferDesc.dwBufferSize = 0;
		}
		ReturnSelfToPool();
	}
}


PVOID RefCountBufferDefaultAlloc(void *const pv,const DWORD dwSize)
{
	return(DNMalloc(dwSize));
}


void RefCountBufferDefaultFree(PVOID pv,PVOID pvBuffer)
{
	DNFree(pvBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\strutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       StrUtils.h
 *  Content:    Defines the string utils
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/12/2000	rmt		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __STRUTILS_H
#define __STRUTILS_H

HRESULT STR_jkWideToAnsi(LPSTR lpStr,LPCWSTR lpWStr,int cchStr);
HRESULT STR_jkAnsiToWide(LPWSTR lpWStr,LPCSTR lpStr,int cchWStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\appdesc.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AppDesc.cpp
 *  Content:    Application Description Object
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/02/00	mjn		Created
 *  09/14/2000	rmt		Bug #44625 - CORE: Multihomed machines are not always enumerable (extra spew)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

#define UUID_TIME_HIGH_MASK    0x0FFF
#define UUID_VERSION           0x1000
#define RAND_UUID_VERSION      0x4000
#define UUID_RESERVED          0x80
#define UUID_CLOCK_SEQ_HI_MASK 0x3F

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

// This is the "true" OSF DCE format for Uuids.
//
typedef struct _UUID_GENERATE
{
    unsigned long  TimeLow;
    unsigned short TimeMid;
    unsigned short TimeHiAndVersion;
    unsigned char  ClockSeqHiAndReserved;
    unsigned char  ClockSeqLow;
    unsigned char  NodeId[6];
} UUID_GENERATE;


//**********************************************************************
// Variable definitions
//**********************************************************************

// Random seed -- remove when we pick a new random number generator
//
unsigned long g_ulSeed = 0;

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT XUuidCreate( GUID *Uuid );
int NewGenRandom( unsigned char **ppbRandSeed, unsigned long *pcbRandSeed, unsigned char *pbBuffer, unsigned long dwLength );
unsigned long IRand( void );

//**********************************************************************
// Function definitions
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::Initialize"

HRESULT CApplicationDesc::Initialize( void )
{
	if (!DNInitializeCriticalSection(&m_cs))
	{
		return( DPNERR_OUTOFMEMORY );
	}

	m_dwFlags = 0;

	m_dwMaxPlayers = 0;
	m_dwCurrentPlayers = 0;

	m_pwszSessionName = NULL;
	m_dwSessionNameSize = 0;

	m_pwszPassword = NULL;
	m_dwPasswordSize = 0;

	m_pvReservedData = NULL;
	m_dwReservedDataSize = 0;

	m_pvApplicationReservedData = NULL;
	m_dwApplicationReservedDataSize = 0;

	memset(&m_guidInstance,0,sizeof(GUID));
	memset(&m_guidApplication,0,sizeof(GUID));

	return( DPN_OK );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::Deinitialize"

void CApplicationDesc::Deinitialize( void )
{
	if (m_pwszSessionName)
	{
		DNFree(m_pwszSessionName);
		m_pwszSessionName = NULL;
		m_dwSessionNameSize = 0;
	}

	if (m_pwszPassword)
	{
		DNFree(m_pwszPassword);
		m_pwszPassword = NULL;
		m_dwPasswordSize = 0;
	}

	if (m_pvReservedData)
	{
		DNFree(m_pvReservedData);
		m_pvReservedData = NULL;
		m_dwReservedDataSize = 0;
	}

	if (m_pvApplicationReservedData)
	{
		DNFree(m_pvApplicationReservedData);
		m_pvApplicationReservedData = NULL;
		m_dwApplicationReservedDataSize = 0;
	}

	DNDeleteCriticalSection(&m_cs);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::Pack"

HRESULT	CApplicationDesc::Pack(CPackedBuffer *const pPackedBuffer,
							   const DWORD dwFlags)
{
	HRESULT		hResultCode;
	DPN_APPLICATION_DESC	*pdpnAppDesc;

	DPF(6,"Parameters: pPackedBuffer [0x%p], dwFlags [0x%lx]",pPackedBuffer,dwFlags);

	Lock();

	//
	//	Add structure
	//
	pdpnAppDesc = reinterpret_cast<DPN_APPLICATION_DESC*>(pPackedBuffer->GetHeadAddress());
	hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DPN_APPLICATION_DESC));

	//
	//	Add session name
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME) && (m_dwSessionNameSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pwszSessionName,m_dwSessionNameSize);
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pwszSessionName = static_cast<WCHAR*>(pPackedBuffer->GetTailAddress());
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pwszSessionName = NULL;
		}
	}

	//
	//	Add password
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_PASSWORD) && (m_dwPasswordSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pwszPassword,m_dwPasswordSize);
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pwszPassword = static_cast<WCHAR*>(pPackedBuffer->GetTailAddress());
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pwszPassword = NULL;
		}
	}

	//
	//	Add reserved data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA) && (m_dwReservedDataSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pvReservedData,m_dwReservedDataSize);
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pvReservedData = pPackedBuffer->GetTailAddress();
			pdpnAppDesc->dwReservedDataSize = m_dwReservedDataSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pvReservedData = NULL;
			pdpnAppDesc->dwReservedDataSize = 0;
		}
	}

	//
	//	Add app reserved data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA) && (m_dwApplicationReservedDataSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pvApplicationReservedData,m_dwApplicationReservedDataSize);
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pvApplicationReservedData = pPackedBuffer->GetTailAddress();
			pdpnAppDesc->dwApplicationReservedDataSize = m_dwApplicationReservedDataSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pdpnAppDesc->pvApplicationReservedData = NULL;
			pdpnAppDesc->dwApplicationReservedDataSize = 0;
		}
	}

	//
	//	Fill in remainder of structure (if space)
	//
	if (hResultCode == DPN_OK)
	{
		pdpnAppDesc->dwSize = sizeof(DPN_APPLICATION_DESC);
		pdpnAppDesc->dwFlags = m_dwFlags;
		pdpnAppDesc->dwMaxPlayers = m_dwMaxPlayers;
		pdpnAppDesc->dwCurrentPlayers = m_dwCurrentPlayers;
		memcpy(&pdpnAppDesc->guidInstance,&m_guidInstance,sizeof(GUID));
		memcpy(&pdpnAppDesc->guidApplication,&m_guidApplication,sizeof(GUID));
	}

	Unlock();

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDesc::PackInfo"

HRESULT CApplicationDesc::PackInfo(CPackedBuffer *const pPackedBuffer,
								   const DWORD dwFlags)
{
	HRESULT		hResultCode;
	DPN_APPLICATION_DESC_INFO	*pInfo;

	DPF(6,"Parameters: pPackedBuffer [0x%p], dwFlags [0x%lx]",pPackedBuffer,dwFlags);

	//
	//	Add structure
	//
	pInfo = reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(pPackedBuffer->GetHeadAddress());
	hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DPN_APPLICATION_DESC_INFO));

	Lock();

	//
	//	Add session name
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME) && (m_dwSessionNameSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pwszSessionName,m_dwSessionNameSize);
		if (hResultCode == DPN_OK)
		{
			pInfo->dwSessionNameOffset = pPackedBuffer->GetTailOffset();
			pInfo->dwSessionNameSize = m_dwSessionNameSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pInfo->dwSessionNameOffset = 0;
			pInfo->dwSessionNameSize = 0;
		}
	}

	//
	//	Add password
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_PASSWORD) && (m_dwPasswordSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pwszPassword,m_dwPasswordSize);
		if (hResultCode == DPN_OK)
		{
			pInfo->dwPasswordOffset = pPackedBuffer->GetTailOffset();
			pInfo->dwPasswordSize = m_dwPasswordSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pInfo->dwPasswordOffset = 0;
			pInfo->dwPasswordSize = 0;
		}
	}

	//
	//	Add reserved data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA) && (m_dwReservedDataSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pvReservedData,m_dwReservedDataSize);
		if (hResultCode == DPN_OK)
		{
			pInfo->dwReservedDataOffset = pPackedBuffer->GetTailOffset();
			pInfo->dwReservedDataSize = m_dwReservedDataSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pInfo->dwReservedDataOffset = 0;
			pInfo->dwReservedDataSize = 0;
		}
	}

	//
	//	Add app reserved data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA) && (m_dwApplicationReservedDataSize > 0))
	{
		hResultCode = pPackedBuffer->AddToBack(m_pvApplicationReservedData,m_dwApplicationReservedDataSize);
		if (hResultCode == DPN_OK)
		{
			pInfo->dwApplicationReservedDataOffset = pPackedBuffer->GetTailOffset();
			pInfo->dwApplicationReservedDataSize = m_dwApplicationReservedDataSize;
		}
	}
	else
	{
		if (hResultCode == DPN_OK)
		{
			pInfo->dwApplicationReservedDataOffset = 0;
			pInfo->dwApplicationReservedDataSize = 0;
		}
	}

	//
	//	Fill in remainder of structure (if space)
	//
	if (hResultCode == DPN_OK)
	{
		pInfo->dwFlags = m_dwFlags;
		pInfo->dwMaxPlayers = m_dwMaxPlayers;
		pInfo->dwCurrentPlayers = m_dwCurrentPlayers;
		memcpy(&pInfo->guidInstance,&m_guidInstance,sizeof(GUID));
		memcpy(&pInfo->guidApplication,&m_guidApplication,sizeof(GUID));
	}

	Unlock();

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDecs::UnpackInfo"

HRESULT CApplicationDesc::UnpackInfo(DPN_APPLICATION_DESC_INFO *const pdnAppDescInfo,
									 void *const pBufferStart,
									 const DWORD dwFlags)
{
	HRESULT		hResultCode;
	WCHAR		*pwszSessionName;
	WCHAR		*pwszPassword;
	void		*pvReservedData;
	void		*pvApplicationReservedData;

	DPF(6,"Parameters: pdnAppDescInfo [0x%p], pBufferStart [0x%p], dwFlags [0x%lx]",pdnAppDescInfo,pBufferStart,dwFlags);

	pwszSessionName = NULL;
	pwszPassword = NULL;
	pvReservedData = NULL;
	pvApplicationReservedData = NULL;

	//
	//	We will allocate the required memory for the data fields first.
	//	If everything succeeds, we will update the object
	//

	//
	//	Session Name
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME) && (pdnAppDescInfo->dwSessionNameSize))
	{
		if ((pwszSessionName = static_cast<WCHAR*>(DNMalloc(pdnAppDescInfo->dwSessionNameSize))) == NULL)
		{
			DPFERR("Could not allocate application desc session name");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pwszSessionName,
				static_cast<BYTE*>(pBufferStart) + pdnAppDescInfo->dwSessionNameOffset,
				pdnAppDescInfo->dwSessionNameSize);
	}

	//
	//	Password
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_PASSWORD) && (pdnAppDescInfo->dwPasswordSize))
	{
		if ((pwszPassword = static_cast<WCHAR*>(DNMalloc(pdnAppDescInfo->dwPasswordSize))) == NULL)
		{
			DPFERR("Could not allocate application desc password");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pwszPassword,
				static_cast<BYTE*>(pBufferStart) + pdnAppDescInfo->dwPasswordOffset,
				pdnAppDescInfo->dwPasswordSize);
	}

	//
	//	Reserved Data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA) && (pdnAppDescInfo->dwReservedDataSize))
	{
		if ((pvReservedData = DNMalloc(pdnAppDescInfo->dwReservedDataSize)) == NULL)
		{
			DPFERR("Could not allocate application desc reserved data");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pvReservedData,
				static_cast<BYTE*>(pBufferStart) + pdnAppDescInfo->dwReservedDataOffset,
				pdnAppDescInfo->dwReservedDataSize);
	}

	//
	//	Application Reserved Data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA) && (pdnAppDescInfo->dwApplicationReservedDataSize))
	{
		if ((pvApplicationReservedData = DNMalloc(pdnAppDescInfo->dwApplicationReservedDataSize)) == NULL)
		{
			DPFERR("Could not allocate application desc app reserved data");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pvApplicationReservedData,
				static_cast<BYTE*>(pBufferStart) + pdnAppDescInfo->dwApplicationReservedDataOffset,
				pdnAppDescInfo->dwApplicationReservedDataSize);
	}


	//
	//	Replace old values in object
	//

	Lock();

	//
	//	Session Name
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME)
	{
		if (m_pwszSessionName)
		{
			DNFree(m_pwszSessionName);
			m_pwszSessionName = NULL;
			m_dwSessionNameSize = 0;
		}
		m_pwszSessionName = pwszSessionName;
		m_dwSessionNameSize = pdnAppDescInfo->dwSessionNameSize;
	}

	//
	//	Password
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_PASSWORD)
	{
		if (m_pwszPassword)
		{
			DNFree(m_pwszPassword);
			m_pwszPassword = NULL;
			m_dwPasswordSize = 0;
		}
		m_pwszPassword = pwszPassword;
		m_dwPasswordSize = pdnAppDescInfo->dwPasswordSize;
	}

	//
	//	Reserved Data
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA)
	{
		if (m_pvReservedData)
		{
			DNFree(m_pvReservedData);
			m_pvReservedData = NULL;
			m_dwReservedDataSize = 0;
		}
		m_pvReservedData = pvReservedData;
		m_dwReservedDataSize = pdnAppDescInfo->dwReservedDataSize;
	}

	//
	//	Application Reserved Data
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA)
	{
		if (m_pvApplicationReservedData)
		{
			DNFree(m_pvApplicationReservedData);
			m_pvApplicationReservedData = NULL;
			m_dwApplicationReservedDataSize = 0;
		}
		m_pvApplicationReservedData = pvApplicationReservedData;
		m_dwApplicationReservedDataSize = pdnAppDescInfo->dwApplicationReservedDataSize;
	}

	//
	//	Remaining fields
	//
	m_dwMaxPlayers = pdnAppDescInfo->dwMaxPlayers;
	m_dwFlags = pdnAppDescInfo->dwFlags;
	memcpy(&m_guidInstance,&pdnAppDescInfo->guidInstance,sizeof(GUID));
	memcpy(&m_guidApplication,&pdnAppDescInfo->guidApplication,sizeof(GUID));

	Unlock();

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pwszSessionName)
	{
		DNFree(pwszSessionName);
		pwszSessionName = NULL;
	}
	if (pwszPassword)
	{
		DNFree(pwszPassword);
		pwszPassword = NULL;
	}
	if (pvReservedData)
	{
		DNFree(pvReservedData);
		pvReservedData = NULL;
	}
	if (pvApplicationReservedData)
	{
		DNFree(pvApplicationReservedData);
		pvApplicationReservedData = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDecs::Update"

HRESULT CApplicationDesc::Update(const DPN_APPLICATION_DESC *const pdnAppDesc,
								 const DWORD dwFlags)
{
	HRESULT		hResultCode;
	WCHAR		*pwszSessionName;
	DWORD		dwSessionNameSize;
	WCHAR		*pwszPassword;
	DWORD		dwPasswordSize;
	void		*pvReservedData;
	void		*pvApplicationReservedData;

	DPF(6,"Parameters: pdnAppDesc [0x%p], dwFlags [0x%lx]",pdnAppDesc,dwFlags);

	pwszSessionName = NULL;
	dwSessionNameSize = 0;
	pwszPassword = NULL;
	dwPasswordSize = 0;
	pvReservedData = NULL;
	pvApplicationReservedData = NULL;

	//
	//	We will allocate the required memory for the data fields first.
	//	If everything succeeds, we will update the object
	//

	//
	//	Session Name
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME) && (pdnAppDesc->pwszSessionName))
	{
		dwSessionNameSize = (wcslen(pdnAppDesc->pwszSessionName) + 1) * sizeof(WCHAR);
		if ((pwszSessionName = static_cast<WCHAR*>(DNMalloc(dwSessionNameSize))) == NULL)
		{
			DPFERR("Could not allocate application desc session name");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pwszSessionName,
				pdnAppDesc->pwszSessionName,
				dwSessionNameSize);
	}

	//
	//	Password
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_PASSWORD) && (pdnAppDesc->pwszPassword))
	{
		dwPasswordSize = (wcslen(pdnAppDesc->pwszPassword) + 1) * sizeof(WCHAR);
		if ((pwszPassword = static_cast<WCHAR*>(DNMalloc(dwPasswordSize))) == NULL)
		{
			DPFERR("Could not allocate application desc password");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pwszPassword,
				pdnAppDesc->pwszPassword,
				dwPasswordSize);
	}

	//
	//	Reserved Data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA) && (pdnAppDesc->pvReservedData))
	{
		if ((pvReservedData = DNMalloc(pdnAppDesc->dwReservedDataSize)) == NULL)
		{
			DPFERR("Could not allocate application desc reserved data");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pvReservedData,
				pdnAppDesc->pvReservedData,
				pdnAppDesc->dwReservedDataSize);
	}

	//
	//	Application Reserved Data
	//
	if ((dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA) && (pdnAppDesc->pvApplicationReservedData))
	{
		if ((pvApplicationReservedData = DNMalloc(pdnAppDesc->dwApplicationReservedDataSize)) == NULL)
		{
			DPFERR("Could not allocate application desc app reserved data");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(	pvApplicationReservedData,
				pdnAppDesc->pvApplicationReservedData,
				pdnAppDesc->dwApplicationReservedDataSize);
	}


	//
	//	Replace old values in object
	//

	//
	//	Session Name
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_SESSIONNAME)
	{
		if (m_pwszSessionName)
		{
			DNFree(m_pwszSessionName);
			m_pwszSessionName = NULL;
			m_dwSessionNameSize = 0;
		}
		m_pwszSessionName = pwszSessionName;
		m_dwSessionNameSize = dwSessionNameSize;
	}

	//
	//	Password
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_PASSWORD)
	{
		if (m_pwszPassword)
		{
			DNFree(m_pwszPassword);
			m_pwszPassword = NULL;
			m_dwPasswordSize = 0;
		}
		m_pwszPassword = pwszPassword;
		m_dwPasswordSize = dwPasswordSize;
	}

	//
	//	Reserved Data
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_RESERVEDDATA)
	{
		if (m_pvReservedData)
		{
			DNFree(m_pvReservedData);
			m_pvReservedData = NULL;
			m_dwReservedDataSize = 0;
		}
		m_pvReservedData = pvReservedData;
		m_dwReservedDataSize = pdnAppDesc->dwReservedDataSize;
	}

	//
	//	Application Reserved Data
	//
	if (dwFlags & DN_APPDESCINFO_FLAG_APPRESERVEDDATA)
	{
		if (m_pvApplicationReservedData)
		{
			DNFree(m_pvApplicationReservedData);
			m_pvApplicationReservedData = NULL;
			m_dwApplicationReservedDataSize = 0;
		}
		m_pvApplicationReservedData = pvApplicationReservedData;
		m_dwApplicationReservedDataSize = pdnAppDesc->dwApplicationReservedDataSize;
	}

	//
	//	Remaining fields
	//
	m_dwMaxPlayers = pdnAppDesc->dwMaxPlayers;
	m_dwFlags = pdnAppDesc->dwFlags;
	memcpy(&m_guidInstance,&pdnAppDesc->guidInstance,sizeof(GUID));
	memcpy(&m_guidApplication,&pdnAppDesc->guidApplication,sizeof(GUID));

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pwszSessionName)
	{
		DNFree(pwszSessionName);
		pwszSessionName = NULL;
	}
	if (pwszPassword)
	{
		DNFree(pwszPassword);
		pwszPassword = NULL;
	}
	if (pvReservedData)
	{
		DNFree(pvReservedData);
		pvReservedData = NULL;
	}
	if (pvApplicationReservedData)
	{
		DNFree(pvApplicationReservedData);
		pvApplicationReservedData = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDecs::CreateNewInstanceGuid"

HRESULT	CApplicationDesc::CreateNewInstanceGuid( void )
{
	HRESULT		hResultCode;

	hResultCode = XUuidCreate(&m_guidInstance);

	return(hResultCode);
}

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDecs::IncPlayerCount"

HRESULT	CApplicationDesc::IncPlayerCount(const BOOL fCheckLimit)
{
	HRESULT		hResultCode;

	Lock();

	if ((fCheckLimit) && (m_dwMaxPlayers) && (m_dwCurrentPlayers >= m_dwMaxPlayers))
	{
		hResultCode = DPNERR_SESSIONFULL;
	}
	else
	{
		m_dwCurrentPlayers++;
		hResultCode = DPN_OK;
	}

	Unlock();

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CApplicationDecs::DecPlayerCount"

void CApplicationDesc::DecPlayerCount( void )
{
	Lock();
	m_dwCurrentPlayers--;
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessUpdateAppDesc"

HRESULT	DNProcessUpdateAppDesc(DIRECTNETOBJECT *const pdnObject,
							   DPN_APPLICATION_DESC_INFO *const pv)
{
	HRESULT				hResultCode;

	DPF(6,"Parameters: pv [0x%p]",pv);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);

	hResultCode = pdnObject->ApplicationDesc.UnpackInfo(pv,
														pv,
														DN_APPDESCINFO_FLAG_SESSIONNAME | DN_APPDESCINFO_FLAG_PASSWORD |
														DN_APPDESCINFO_FLAG_RESERVEDDATA | DN_APPDESCINFO_FLAG_APPRESERVEDDATA);

	hResultCode = DNUserUpdateAppDesc(pdnObject);

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


// *****************************************************
// XUuidCreate()
//
// Generate an UUID with RC4 algorithm.
//
// *****************************************************

HRESULT XUuidCreate( GUID *Uuid )
{
    UUID_GENERATE *UuidGen = (UUID_GENERATE *) Uuid;
    BYTE newSeed[256];

    // Get a new seed if it hasn't been set yet
    //
    if ( g_ulSeed == 0 )
    {
        g_ulSeed = NtGetTickCount();
    }

    // Calculate a 256 byte seed key for the RC4 algorithm
    //
    NewGenRandom( NULL, NULL, (unsigned char *) Uuid, sizeof(GUID) );

    // Overwrite some bits of the UUID (not sure why -- it's like that in the W2k source)
    //
    UuidGen->TimeHiAndVersion = (UuidGen->TimeHiAndVersion & UUID_TIME_HIGH_MASK) | RAND_UUID_VERSION;
    UuidGen->ClockSeqHiAndReserved = (UuidGen->ClockSeqHiAndReserved & UUID_CLOCK_SEQ_HI_MASK) | UUID_RESERVED;

    return S_OK;
}

// *****************************************************
// NewGenRandom()
//
// Fill a buffer with random data up to dwLength size.
//
// ASSUMPTION:  dwLength is a multiple of 4 bytes.  We
// can assume this because UuidCreate is our only
// client.  When we switch to a real NewGenRandom()
// function (the RC4 one), then this will not matter.
//
// *****************************************************

int NewGenRandom( unsigned char **ppbRandSeed, unsigned long *pcbRandSeed, unsigned char *pbBuffer, unsigned long dwLength )
{
    int i, nMax;

    nMax = dwLength / sizeof(unsigned long);

    for ( i = 0; i < nMax; i += 1 )
    {
        ((unsigned long *)pbBuffer)[i] = IRand();
    }

    return 1;
}

// *****************************************************
// IRand()
//
// Generate a random unsigned long.  Will be replaced
// when real RC4 NewGenRandom is used.
//
// *****************************************************

unsigned long IRand( void )
{
    g_ulSeed =  1664525 * g_ulSeed + 1013904223;

    return g_ulSeed;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\common\strutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       StrUtils.cpp
 *  Content:    Implements the string utils
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/12/2000	rmt		Created
 *   08/28/2000	masonb	Voice Merge: Added check of return code of MultiByteToWideChar in STR_jkAnsiToWide
 *   09/16/2000 aarono  fix STR_AllocAndConvertToANSI, ANSI doesn't mean 1 byte per DBCS character so we
 *                       must allow up to 2 bytes per char when allocating buffer (B#43286)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "commoni.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON



#undef DPF_MODNAME
#define DPF_MODNAME "UnicodeToMultiByteN"

HRESULT
UnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG LoopCount;
    ULONG CharsInUnicodeString;

    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                 CharsInUnicodeString : MaxBytesInMultiByteString;

    while (LoopCount) {

        *MultiByteString = (*UnicodeString < 256) ? (UCHAR)*UnicodeString : '?';

        UnicodeString++;
        MultiByteString++;
        LoopCount--;
    }

    return DPN_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "MultiByteToUnicodeN"

HRESULT
MultiByteToUnicodeN(
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    IN PCH MultiByteString,
    IN ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    ANSI Code Page (ACP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the ansi source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of MultiByteString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    MultiByteString - Supplies the ansi source string that is to be
        converted to unicode.  For single-byte character sets, this address
        CAN be the same as UnicodeString.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful.


--*/

{
    ULONG LoopCount;
    ULONG MaxCharsInUnicodeString;

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
                 MaxCharsInUnicodeString : BytesInMultiByteString;

    while (LoopCount) {

        *UnicodeString = (WCHAR)(UCHAR)(*MultiByteString);

        UnicodeString++;
        MultiByteString++;
        LoopCount--;
    }

    return DPN_OK;
}


/*
 ** WideToAnsi
 *
 *  CALLED BY:	everywhere
 *
 *  PARAMETERS: lpStr - destination string
 *				lpWStr - string to convert
 *				cchStr - size of dest buffer
 *
 *  DESCRIPTION:
 *				converts unicode lpWStr to ansi lpStr.
 *				fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-"
 *				
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "STR_jkWideToAnsi"
HRESULT STR_jkWideToAnsi(LPSTR lpStr,LPCWSTR lpWStr,int cchStr)
{
	if (!lpWStr && cchStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DNASSERT(FALSE);
		return DPNERR_INVALIDPARAM;
	}
	
	UnicodeToMultiByteN( lpStr, cchStr, (PWCH) lpWStr, cchStr*sizeof(WCHAR));
	
	return DPN_OK;

} // WideToAnsi




#undef DPF_MODNAME
#define DPF_MODNAME "STR_jkAnsiToWide"
/*
 ** AnsiToWide
 *
 *  CALLED BY: everywhere
 *
 *  PARAMETERS: lpWStr - dest string
 *				lpStr  - string to convert
 *				cchWstr - size of dest buffer
 *
 *  DESCRIPTION: converts Ansi lpStr to Unicode lpWstr
 *
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
HRESULT STR_jkAnsiToWide(LPWSTR lpWStr,LPCSTR lpStr,int cchWStr)
{
	if (!lpStr && cchWStr)
	{
		// can't call us w/ null pointer & non-zero cch
		DNASSERT(FALSE);
		return DPNERR_INVALIDPOINTER;
	}

	MultiByteToUnicodeN( lpWStr, cchWStr*sizeof(WCHAR), (CHAR *) lpStr, cchWStr );

	return DPN_OK;
}  // AnsiToWide
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\asyncop.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AsyncOp.cpp
 *  Content:    Async Operation routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/08/00	mjn		Created
 *	04/11/00	mjn		Added DIRECTNETOBJECT bilink for CAsyncOps
 *	05/02/00	mjn		Added m_pConnection to track Connection over life of AsyncOp
 *	07/27/00	mjn		Changed locking for parent/child bilinks
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"



//	CAsyncOp::ReturnSelfToPool
//
//	Return object to FPM

#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::ReturnSelfToPool"

void CAsyncOp::ReturnSelfToPool( void )
{
	m_pdnObject->m_pFPOOLAsyncOp->Release( this );
}



#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::Release"

void CAsyncOp::Release(void)
{
	LONG	lRefCount;

	DNASSERT(m_lRefCount > 0);
	lRefCount = InterlockedDecrement(const_cast<LONG*>(&m_lRefCount));

	DPF(3,"CAsyncOp::Release [0x%p] RefCount [0x%lx]",this,lRefCount);

	if (lRefCount == 0)
	{
		DNASSERT( m_bilinkActiveList.IsEmpty() );

		//
		//	Remove from the bilink of outstanding AsyncOps
		//
		DNEnterCriticalSection(&m_pdnObject->csAsyncOperations);
		Lock();
		m_bilinkAsyncOps.RemoveFromList();
		DNLeaveCriticalSection(&m_pdnObject->csAsyncOperations);
		Unlock();

		if (m_pfnCompletion)
		{
			(m_pfnCompletion)(m_pdnObject,this);
			m_pfnCompletion = NULL;
		}
		if (m_phr)
		{
			*m_phr = m_hr;
		}
		if (m_pSyncEvent)
		{
			m_pSyncEvent->Set();
			m_pSyncEvent = NULL;
		}
		if (m_pRefCountBuffer)
		{
			m_pRefCountBuffer->Release();
			m_pRefCountBuffer = NULL;
		}
		if (m_pConnection)
		{
			m_pConnection->Release();
			m_pConnection = NULL;
		}
		if (m_pSP)
		{
			m_pSP->Release();
			m_pSP = NULL;
		}
		if (m_pParent)
		{
			Orphan();
			m_pParent->Release();
			m_pParent = NULL;
		}
		m_dwFlags = 0;
		m_lRefCount = 0;
		ReturnSelfToPool();
	}
};



#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::Orphan"

void CAsyncOp::Orphan( void )
{
	if (m_pParent)
	{
		m_pParent->Lock();
		m_bilinkChildren.RemoveFromList();
		m_pParent->Unlock();
	}
}



#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::SetConnection"

void CAsyncOp::SetConnection( CConnection *const pConnection )
{
	if (pConnection)
	{
		pConnection->AddRef();
	}
	m_pConnection = pConnection;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::SetSP"

void CAsyncOp::SetSP( CServiceProvider *const pSP )
{
	if (pSP)
	{
		pSP->AddRef();
	}
	m_pSP = pSP;
}



#undef DPF_MODNAME
#define DPF_MODNAME "CAsyncOp::SetRefCountBuffer"

void CAsyncOp::SetRefCountBuffer( CRefCountBuffer *const pRefCountBuffer )
{
	if (pRefCountBuffer)
	{
		pRefCountBuffer->AddRef();
	}
	m_pRefCountBuffer = pRefCountBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\async.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Async.cpp
 *  Content:    Async operation FPM routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/27/99	mjn		Created
 *  12/23/99	mjn		Added HOST_MIGRATE functionality
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Handle NULL buffer descriptors during sends
 *	01/09/00	mjn		Transfer Application Description at connect
 *	01/10/00	mjn		Added support for DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC
 *	01/12/00	jtk		Added simple code to handle enum and enum response messages.
 *	01/11/00	mjn		Moved AppDesc stuff to AppDesc.h
 *						Moved connect/disconnect stuff to Connect.h
 *	01/14/00	mjn		Added pvUserContext to DN_PerformListen
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/17/00	mjn		Fixed ConnectToPeer function names
 *	01/17/00	mjn		Implemented send time
 *	01/19/00	mjn		Fixed Parent Op refCount bug in MultiSend
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/20/00	mjn		Route NameTable operations through NameTable operation list
 *	01/21/00	mjn		Added DNProcessInternalOperation
 *	01/23/00	mjn		Added support for DN_MSG_INTERNAL_HOST_DESTROY_PLAYER
 *	01/24/00	mjn		Added support for DN_MSG_INTERNAL_NAMETABLE_VERSION
 *							and DN_MSG_INTERNAL_RESYNC_VERSION
 *	01/25/00	mjn		Added support for DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE
 *	01/26/00	mjn		Implemented NameTable re-sync at host migration
 *	01/27/00	mjn		Cleaned up switch/case statements
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *	03/23/00	mjn		Added phrSync and pvInternal
 *	03/24/00	mjn		Add guidSP to DN_ASYNC_OP
 *  03/25/00    rmt     Added code to unregister ourselves when listens are terminated
 *  04/04/00	rmt		Added check for DPNSVR disable before attempting to unregister
 *	04/04/00	mjn		Added DNProcessTerminateSession and related code
 *  04/06/00    rmt     Added code to complete nocopy voice sends
 *	04/10/00	mjn		Use CAsyncOp for CONNECTs, LISTENs and DISCONNECTs
 *	04/11/00	mjn		Use CAsyncOp for ENUMs
 *	04/13/00	mjn		Use Protocol Interface VTBL (replaces some functions)
 *	04/14/00	mjn		DNPerformListen performs synchronous LISTENs
 *	04/16/00	mjn		Use CAsyncOp for SENDs
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	04/17/00	mjn		Added DNCompleteAsyncHandle
 *	04/20/00	mjn		DNPerformChildSend set's child op flags to the parent's op flags
 *	04/21/00	mjn		Added DNPerformDisconnect
 *	04/23/00	mjn		Optionally return child AsyncOp in DNPerformChildSend()
 *				mjn		Removed DNSendCompleteOnProcess (better implementation)
 *	04/24/00	mjn		Added DNCreateUserHandle()
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	04/28/00	mjn		Clear unused buffer descriptions in DN_SendTo()
 *	05/02/00	mjn		Keep a reference on the Connection during SEND's
 *	05/05/00	mjn		Return DPN_OK from DNReceiveCompleteOnProcess() to prevent holding the buffer
 *	05/08/00	vpo		Removed asserts when protocol returns non PENDING
 *	06/05/00	mjn		Removed assert in DNSendMessage
 *	06/21/00	mjn		Modified DNSendMessage() and DNCreateSendParent() to use protocol voice bit
 *	06/24/00	mjn		Added CONNECT completions and fixed DN_MSG_INTERNAL_CONNECT_FAILED processing
 *				mjn		Added code to process DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED
 *	07/02/00	mjn		Added DNSendGroupMessage() *@@END_MSINTERNAL
 *	07/05/00	mjn		Removed references to DN_MSG_INTERNAL_ENUM_WITH_APPLICATION_GUID,DN_MSG_INTERNAL_ENUM,DN_MSG_INTERNAL_ENUM_RESPONSE
 *	07/06/00	mjn		Only use CONNECTED connections in group sends
 *				mjn		Use SP handle instead of interface
 *	07/10/00	mjn		Added DNPerformEnumQuery()
 *				mjn		Correctly flag parent ops in groups sends and added DPNIDs to async ops for better tracking
 *	07/11/00	mjn		Added fNoLoopBack to DNSendGroupMessage()
 *				mjn		Added DNPerformNextEnumQuery(),DNPerformSPListen(),DNPerformNextListen(),DNEnumAdapterGuids(),DNPerformNextConnect()
 *	07/20/00	mjn		Fixed DN_TerminateAllListens() to better use locks
 *				mjn		Fixed connect completions and added DNCompleteConnectOperation() and DNCompleteSendConnectInfo()
 *				mjn		Changed DNPerformDisconnect() to take a CConnection and hEndPt
 *				mjn		Revamped CONNECT process and associated refcounts
 *	07/21/00	mjn		Process DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED
 *	07/25/00	mjn		Save result code on parent only if failure in DNCompleteSendConnectInfo()
 *	07/26/00	mjn		DNPerformSPListen() fails if no valid device adapters
 *	07/26/00	mjn		Fixed locking problem with CAsyncOp::MakeChild()
 *	07/28/00	mjn		Added code to track send queue info on CConnection
 *	07/29/00	mjn		Use DNUserConnectionTerminated() rather than DN_TerminateSession()
 *				mjn		Added HRESULT to DNUserReturnBuffer()
 *				mjn		Added fUseCachedCaps to DN_SPEnsureLoaded()
 *	07/30/00	mjn		Use DNUserTerminateSession() rather than DNUserConnectionTerminated()
 *	07/31/00	mjn		Removed DN_MSG_INTERNAL_HOST_DESTROY_PLAYER
 *	07/31/00	mjn		Change DN_MSG_INTERNAL_DELETE_PLAYER to DN_MSG_INTERNAL_DESTROY_PLAYER
 *	08/02/00	mjn		Added dwFlags to DNReceiveUserData()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Ensure cancelled operations don't proceed
 *				mjn		Added m_bilinkActiveList to CAsyncOp
 *				mjn		Added fInternal to DNPerformChildSend()
 *				mjn		Removed DN_TerminateAllListens()
 *				mjn		Added DNProcessFailedRequest() 
 *				mjn		Added DNCompleteRequest()
 *	08/07/00	mjn		Added code to handle peer-peer integrity checking
 *	08/08/00	mjn		Perform LISTENs on worker thread in DNPerformNextListen()
 *	08/14/00	mjn		Handle failed LISTENs in DNPerformListen()
 *	08/15/00	mjn		Changed registration with DPNSVR
 *				mjn		Allow NULL CConnection object pointer for DNPerformRequest()
 *	08/20/00	mjn		Removed fUseCachedCaps from DN_SPEnsureLoaded()
 *	08/24/00	mjn		Replace DN_NAMETABLE_OP with CNameTableOp
 *				mjn		DN_MSG_INTERNAL_INSTRUCT_CONNECT gets routed through DNNTAddOperation() in DNProcessInternalOperation()
 *	08/31/00	mjn		Release DirectNetLock for failure cases in DNPerformRequest()
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/06/00	mjn		Fixed register with DPNSVR problem
 *  09/14/2000	rmt		Bug #44625: DPLAY8: CORE: Multihomed machines cannot always be enumerated
 *						Moved registration to after point where listen completes.  
 *	09/14/00	mjn		AddRef Protocol refcount when invoking protocol
 *	09/21/00	mjn		Allow NULL CConnection in DNPerformDisconnect()
 *	09/23/00	mjn		Added CSyncEvent to DN_LISTEN_OP_DATA
 *	09/27/00	mjn		Inform lobby of successfull connects from DNCompleteConnectOperation()
 *	10/11/00	mjn		Save protocol handle on AsyncOp earlier in DNPerformListen()
 *				mjn		Clean up DirectNet object in failure cases in DNCompleteConnectToHost() and DNCompleteSendConnectInfo()
 *	10/17/00	mjn		Fixed clean up for unreachable players
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE


#undef DPF_MODNAME
#define DPF_MODNAME "DNCreateUserHandle"

HRESULT DNCreateUserHandle(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp **const ppAsyncOp)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;

	DPF(6,"Parameters: ppAsyncOp [0x%p]",ppAsyncOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppAsyncOp != NULL);

	pAsyncOp = NULL;

	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_USER_HANDLE );
	pAsyncOp->MakeParent();

	if ((hResultCode = pdnObject->HandleTable.Create(pAsyncOp,NULL)) != DPN_OK)
	{
		DPFERR("Could not create Handle");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	pAsyncOp->AddRef();
	*ppAsyncOp = pAsyncOp;

	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DNPerformSPListen
//
//	LISTEN on a particular SP

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformSPListen"

HRESULT DNPerformSPListen(DIRECTNETOBJECT *const pdnObject,
						  IDirectPlay8Address *const pDeviceAddr,
						  CAsyncOp *const pListenParent,
						  CAsyncOp **const ppParent)
{
	HRESULT				hResultCode;
	CAsyncOp			*pParent;
	GUID				guidAdapter;
	CServiceProvider	*pSP;
	CSyncEvent			*pSyncEvent;

	DPF(6,"Parameters: pDeviceAddr [0x%p], pListenParent [0x%p], ppParent [0x%p]",
			pDeviceAddr,pListenParent,ppParent);

	DNASSERT(pdnObject != NULL);

	pParent = NULL;
	pSP = NULL;
	pSyncEvent = NULL;

	//
	//	Create a parent op for LISTENs on this SP
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pParent)) != DPN_OK)
	{
		DPFERR("Could not create SP parent listen op");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pParent->SetOpType( ASYNC_OP_LISTEN );
	pParent->SetCompletion( DNCompleteListen );
	pParent->MakeParent();

	if (pListenParent)
	{
		pListenParent->Lock();
		if (pListenParent->IsCancelled())
		{
			pListenParent->Unlock();
			pParent->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pParent->MakeChild( pListenParent );
		pListenParent->Unlock();
	}

	//
	//	Ensure SP specified in Device address is loaded
	//
	if ((hResultCode = DN_SPEnsureLoaded(pdnObject,&GUID_NULL,&pSP)) != DPN_OK)
	{
		DPFERR("Could not ensure SP is loaded!" );
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pParent->SetSP( pSP );
	pSP->Release();
	pSP = NULL;

	hResultCode = DNPerformListen(pdnObject,pDeviceAddr,pParent);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not perform LISTEN");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	If there is a SyncEvent, wait for it to be set and then return it
	//
	if (pSyncEvent)
	{
		pSyncEvent->WaitForEvent(INFINITE, pdnObject);
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}

	if (ppParent)
	{
		pParent->AddRef();
		*ppParent = pParent;
	}

	pParent->Release();
	pParent = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}


//	DNPerformListen
//
//	IDirectPlayAddress8	*pDeviceInfo
//	CAsyncOp			*pParent

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformListen"

HRESULT DNPerformListen(DIRECTNETOBJECT *const pdnObject,
						IDirectPlay8Address *const pDeviceInfo,
						CAsyncOp *const pParent)
{
	HANDLE			hProtocol;
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	CSyncEvent		*pSyncEvent;
	HRESULT			hrListen;
#ifdef	DEBUG
	CHAR			DP8ABuffer[512];
	DWORD			DP8ASize;
#endif

	DPF(6,"Parameters: pDeviceInfo [0x%p], pParent [0x%p]",pDeviceInfo,pParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pParent != NULL);

	hProtocol = NULL;
	pAsyncOp = NULL;
	pSyncEvent = NULL;

	// Try an initial check (might get lucky :)
	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
	{
		DPFERR("Not initialized");
		return(DPNERR_UNINITIALIZED);
	}

#ifdef	DEBUG
	DP8ASize = 512;
	pDeviceInfo->GetURLA(DP8ABuffer,&DP8ASize);
	DPF(7,"Device Info [%s]",DP8ABuffer);
#endif
	//
	//	Set up for LISTEN
	//

	// HRESULT
	hrListen = DPNERR_GENERIC;

	// SyncEvent
	if ((hResultCode = SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
	{
		DPFERR("Could not create SyncEvent");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Async op for LISTEN
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_LISTEN );
	pAsyncOp->SetSyncEvent(pSyncEvent);
	pAsyncOp->SetResultPointer( &hrListen );

	pParent->Lock();
	if (pParent->IsCancelled())
	{
		pParent->Unlock();
		pAsyncOp->SetResult( DPNERR_USERCANCEL );
		hResultCode = DPNERR_USERCANCEL;
		goto Failure;
	}
	pAsyncOp->MakeChild(pParent);
	pParent->Unlock();

	//
	//	Add to active async op list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Perform LISTEN
	//
	pAsyncOp->AddRef();
	hResultCode = DNPListen(pdnObject->pdnProtocolData,
							pDeviceInfo,
							pParent->GetSP()->GetHandle(),
							0,
							static_cast<void*>(pAsyncOp),
							&hProtocol);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not Listen at Protocol layer !");
		DisplayDNError(0,hResultCode);
		pAsyncOp->Release();
		goto Failure;
	}

	//
	//	Save Protocol handle
	//
	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled())
	{
		HRESULT		hrCancel;

		pAsyncOp->Unlock();
		DPF(7,"Operation marked for cancel");
		if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
		{
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		DPFERR("Could not cancel operation");
		DisplayDNError(0,hrCancel);
		pAsyncOp->Lock();
	}
	pAsyncOp->SetProtocolHandle(hProtocol);
	pAsyncOp->Unlock();

	//
	//	Wait for LISTEN to complete.
	//	DNPICompleteListen() will set pSyncEvent and hrListen.
	//	Clean up.
	//
	pSyncEvent->WaitForEvent(INFINITE, pdnObject);
	pAsyncOp->SetSyncEvent(NULL);
	pAsyncOp->SetResultPointer(NULL);

	if (hrListen != DPN_OK)
	{
		DPFERR("LISTEN did not succeed");
		DisplayDNError(0,hrListen);
		hResultCode = hrListen;
		goto Failure;
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;

	pSyncEvent->ReturnSelfToPool();
	pSyncEvent = NULL;

	//
	//	Flag object as LISTENing
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags |= DN_OBJECT_FLAG_LISTENING;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	DNASSERT( hResultCode == DPNERR_PENDING );

	hResultCode = DPNERR_PENDING;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	goto Exit;
}


//	DNPerformNextListen
//
//	This will attempt to perform the next LISTEN if multiple adapters were requested

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformNextListen"
// BUGBUG: [mgere] [xbox] This shouldn't be needed since we don't have multiple adapters.

HRESULT DNPerformNextListen(DIRECTNETOBJECT *const pdnObject,
							CAsyncOp *const pAsyncOp,
							IDirectPlay8Address *const pDeviceAddr)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	CWorkerJob	*pWorkerJob;
	DN_LISTEN_OP_DATA	*pListenOpData;

	DPF(6,"Parameters: pAsyncOp [0x%p], pDeviceAddr [0x%p]",pAsyncOp,pDeviceAddr);

	pParent = NULL;
	pWorkerJob = NULL;

	pAsyncOp->Lock();
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->AddRef();
		pParent = pAsyncOp->GetParent();
	}
	pAsyncOp->Unlock();

	//
	//	If there are any LISTENs left to perform, we will move on to the next one
	//
	// BUGBUG: [mgere] [xbox] Not needed
	
	if (pParent)
	{
		if (pParent->GetOpData())
		{
			pListenOpData = static_cast<DN_LISTEN_OP_DATA*>(pParent->GetOpData());
			if (pListenOpData->dwCurrentAdapter < pListenOpData->dwNumAdapters)
			{
				GUID	*pguid;

				pguid = reinterpret_cast<GUID*>(pListenOpData + 1);
				pguid += pListenOpData->dwCurrentAdapter;
				if ((hResultCode = pDeviceAddr->SetDevice(pguid)) != DPN_OK)
				{
					DPFERR("Could not set device for next adapter");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pListenOpData->dwCurrentAdapter++;

				//
				//	Perform LISTEN on worker thread
				//
				if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
				{
					DPFERR("Could not create WorkerJob");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pWorkerJob->SetJobType( WORKER_JOB_PERFORM_LISTEN );
				pWorkerJob->SetAddress( pDeviceAddr );
				pWorkerJob->SetAsyncOp( pParent );
				DNQueueWorkerJob(pdnObject,pWorkerJob);
			}
		}

		pParent->Release();
		pParent = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (pWorkerJob)
	{
		pWorkerJob->ReturnSelfToPool();
		pWorkerJob = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteListen"

void DNCompleteListen(DIRECTNETOBJECT *const pdnObject,
					  CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	pAsyncOp->Lock();
	if (pAsyncOp->GetOpData() != NULL)
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}
	pAsyncOp->Unlock();

	if (pAsyncOp->IsChild())
	{
		DNASSERT(pAsyncOp->GetParent() != NULL);
		pAsyncOp->Orphan();
	}
	else
	{
		if (pAsyncOp->IsParent())
		{
			DNEnterCriticalSection(&pdnObject->csDirectNetObject);
			pdnObject->dwFlags &= (~DN_OBJECT_FLAG_LISTENING);
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		}
	}
}


//	DNPerformEnumQuery
//
//	Initiate an ENUM and take care of the book keeping

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformEnumQuery"

HRESULT DNPerformEnumQuery(DIRECTNETOBJECT *const pdnObject,
						   IDirectPlay8Address *const pHost,
						   IDirectPlay8Address *const pDevice,
						   const HANDLE hSPHandle,
						   DPN_BUFFER_DESC *const rgdnBufferDesc,
						   const DWORD cBufferDesc,
						   const DWORD dwRetryCount,
						   const DWORD dwRetryInterval,
						   const DWORD dwTimeOut,
						   const DWORD dwFlags,
						   void *const pvContext,
						   CAsyncOp *const pParent)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	HANDLE		hProtocol;

	DPF(6,"Parameters: pHost [0x%p], pDevice [0x%p], hSPHandle [0x%p], rgdnBufferDesc [0x%p], cBufferDesc [%ld], dwRetryCount [%ld], dwRetryInterval [%ld], dwTimeOut [%ld], dwFlags [0x%lx], pvContext [0x%p], pParent [0x%p]",
			pHost,pDevice,hSPHandle,rgdnBufferDesc,cBufferDesc,dwRetryCount,dwRetryInterval,dwTimeOut,dwFlags,pvContext,pParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(hSPHandle != NULL);

	pAsyncOp = NULL;

	//
	//	Create AsyncOp for ENUM
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_ENUM_QUERY );
	pAsyncOp->SetResult( DPNERR_GENERIC );
	pAsyncOp->SetCompletion( DNCompleteEnumQuery );
	pAsyncOp->SetContext( pvContext );

	if (pParent)
	{
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pAsyncOp->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pAsyncOp->MakeChild(pParent);
		pParent->Unlock();
	}

	//
	//	Add to active AsyncOp list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	AddRef Protocol so that it won't go away until this completes
	//
	DNProtocolAddRef(pdnObject);

	pAsyncOp->AddRef();
	hResultCode = DNPEnumQuery(pdnObject->pdnProtocolData,
							   pHost,
							   pDevice,
							   hSPHandle,
							   rgdnBufferDesc,
							   cBufferDesc,
							   dwRetryCount,				// count of enumerations to send
							   dwRetryInterval,				// interval between enumerations
							   dwTimeOut,					// linger time after last enumeration is sent
							   dwFlags,
							   reinterpret_cast<void*>(pAsyncOp),
							   &hProtocol);
	if ( hResultCode != DPNERR_PENDING )
	{
		DPFERR( "Failed to start enuming!" );
		pAsyncOp->Release();
		DNProtocolRelease(pdnObject);
		goto Failure;
	}

	//
	//	Setup for proper clean-up
	//
	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled())
	{
		HRESULT		hrCancel;

		pAsyncOp->Unlock();
		DPF(7,"Operation marked for cancel");
		if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
		{
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		DPFERR("Could not cancel operation");
		DisplayDNError(0,hrCancel);
		pAsyncOp->Lock();
	}
	pAsyncOp->SetProtocolHandle( hProtocol );
	pAsyncOp->Unlock();

	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DNPerformNextEnumQuery
//
//	This will attempt to perform the next ENUM if multiple adapters were requested

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteEnumQuery"

HRESULT DNPerformNextEnumQuery(DIRECTNETOBJECT *const pdnObject,
							   CAsyncOp *const pAsyncOp,
							   IDirectPlay8Address *const pHostAddr,
							   IDirectPlay8Address *const pDeviceAddr)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	DN_ENUM_QUERY	*pEnumQuery;

	DPF(6,"Parameters: pAsyncOp [0x%p], pHostAddr [0x%p], pDeviceAddr [0x%p]",pAsyncOp,pHostAddr,pDeviceAddr);

	pParent = NULL;

	pAsyncOp->Lock();
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->AddRef();
		pParent = pAsyncOp->GetParent();
	}
	pAsyncOp->Unlock();

	//
	//	If there are any ENUMs left to perform, we will move on to the next one
	//
	if (pParent)
	{
		if (pParent->GetOpData())
		{
			pEnumQuery = static_cast<DN_ENUM_QUERY*>(pParent->GetOpData());
			if (pEnumQuery->dwCurrentAdapter < pEnumQuery->dwNumAdapters)
			{
				GUID	*pguid;

				pguid = reinterpret_cast<GUID*>(pEnumQuery + 1);
				pguid += pEnumQuery->dwCurrentAdapter;
				if ((hResultCode = pDeviceAddr->SetDevice(pguid)) != DPN_OK)
				{
					DPFERR("Could not set device for next adapter");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pEnumQuery->dwCurrentAdapter++;

				hResultCode = DNPerformEnumQuery(	pdnObject,
													pHostAddr,
													pDeviceAddr,
													pParent->GetSP()->GetHandle(),
													&pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD],
													DN_ENUM_BUFFERDESC_QUERY_COUNT,
													pEnumQuery->dwRetryCount,
													pEnumQuery->dwRetryInterval,
													pEnumQuery->dwTimeOut,
													pEnumQuery->dwFlags,
													pParent->GetContext(),
													pParent );
				if (hResultCode != DPN_OK)
				{
					DPFERR("Could not start ENUM");
					DisplayDNError(0,hResultCode);
					goto Failure;
				}
			}
		}

		pParent->Release();
		pParent = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	goto Exit;
}


//	DNCompleteEnumQuery
//
//	Completion for AsyncOps for EnumQuery.
//	This will:
//		- free up the EnumQuery memory block associated with this AsyncOp

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteEnumQuery"

void DNCompleteEnumQuery(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	if (pAsyncOp->GetOpData())
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}

	if ( pAsyncOp->IsChild() )
	{
		DNASSERT(pAsyncOp->GetParent() != NULL);

		pAsyncOp->GetParent()->Lock();

		//
		//	Save HRESULT
		//
		if (pAsyncOp->GetParent()->GetResult() != DPN_OK)
		{
			pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		}

		//
		//	Release parent Handle if it exists
		//
		if (pAsyncOp->GetParent()->GetHandle() != 0)
		{
			pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle() );
		}

		pAsyncOp->GetParent()->Unlock();
	}
}


//	DNCompleteEnumResponse
//
//	Completion for AsyncOps for EnumResponse.
//	This will:
//		- generate a RETURN_BUFFER message if there was a user payload
//		- free up the EnumResponse memory block associated with this AsyncOp

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteEnumResponse"

void DNCompleteEnumResponse(DIRECTNETOBJECT *const pdnObject,
							CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	if (pAsyncOp->GetOpData())
	{
		DN_ENUM_RESPONSE	*pEnumResponse;

		//
		//	Was there a user payload on the response ?   If so, we'll need to
		//	generate a completion for the buffer.
		//
		pEnumResponse = static_cast<DN_ENUM_RESPONSE*>(pAsyncOp->GetOpData());
		if (pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].pBufferData != NULL)
		{
			DNUserReturnBuffer(	pdnObject,
								DPN_OK,
								pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].pBufferData,
								pEnumResponse->pvUserContext);
		}
		pEnumResponse = NULL;	// Not used any more

		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}
}



//	DNPerformConnect
//
//	Initiate a connection and take care of the book keeping (create handle).
//
//	DPNID				dpnid				Target player (for ExistingPlayers connect calls)
//	IDirectPlayAddress8	*pDeviceInfo		(may be NULL - no connect performed)
//	IDirectPlayAddress8	*pRemoteAddr		(may be NULL - no connect performed)
//	DWORD				dwFlags				CONNECT op flags
//	CAsyncOp			*pParent			Parent Async Op (if it exists)

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformConnect"

HRESULT DNPerformConnect(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 IDirectPlay8Address *const pDeviceInfo,
						 IDirectPlay8Address *const pRemoteAddr,
						 const DWORD dwConnectFlags,
						 CAsyncOp *const pParent)
{
	HANDLE			hProtocol;
	HRESULT			hResultCode;
	CServiceProvider	*pSP;
	CAsyncOp		*pAsyncOp;
#ifdef	DEBUG
	CHAR			DP8ABuffer[512];
	CHAR			DP8ABuffer2[512];
	DWORD			DP8ASize;
#endif

	DPF(6,"Parameters: dpnid [0x%p], pDeviceInfo [0x%p], pRemoteAddr [0x%p], dwConnectFlags [0x%lx], pParent [0x%p]",
		dpnid,pDeviceInfo,pRemoteAddr,dwConnectFlags,pParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pDeviceInfo != NULL);
	DNASSERT(pRemoteAddr != NULL);

	pAsyncOp = NULL;
	pSP = NULL;

#ifdef	DEBUG
	DP8ASize = 512;
	pRemoteAddr->GetURLA(DP8ABuffer,&DP8ASize);
	DPF(7,"Remote Address [%s]",DP8ABuffer);
	DP8ASize = 512;
	pDeviceInfo->GetURLA(DP8ABuffer2,&DP8ASize);
	DPF(7,"Device Info [%s]",DP8ABuffer2);
#endif

	if ((hResultCode = DN_SPEnsureLoaded(pdnObject,&GUID_NULL,&pSP)) != DPN_OK)
	{
		DPFERR("SP not loaded");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		return(hResultCode);
	}

	//
	//	Create AsyncOp for CONNECT
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_CONNECT );
	pAsyncOp->SetDPNID( dpnid );
	pAsyncOp->SetOpFlags( dwConnectFlags );
	pAsyncOp->SetSP(pSP);
	pAsyncOp->SetResult( DPNERR_NOCONNECTION );
	pAsyncOp->SetCompletion( DNCompleteConnect );
	pSP->Release();
	pSP = NULL;

	if (pParent)
	{
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pAsyncOp->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pAsyncOp->MakeChild(pParent);
		pParent->Unlock();
	}

	//
	//	Add to active async op list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	AddRef Protocol so that it won't go away until this completes
	//
	DNProtocolAddRef(pdnObject);

	//
	//	Perform CONNECT
	//
	DPF(7,"Performing connect");
	pAsyncOp->AddRef();
	hResultCode = DNPConnect(	pdnObject->pdnProtocolData,
								pDeviceInfo,
								pRemoteAddr,
								pAsyncOp->GetSP()->GetHandle(),
								0,
								dwConnectFlags,
								pAsyncOp,
								&hProtocol);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not CONNECT");
		DisplayDNError(0,hResultCode);
		pAsyncOp->Release();
		DNProtocolRelease(pdnObject);
		goto Failure;
	}

	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled())
	{
		HRESULT		hrCancel;

		pAsyncOp->Unlock();
		DPF(7,"Operation marked for cancel");
		if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
		{
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		DPFERR("Could not cancel operation");
		DisplayDNError(0,hrCancel);
		pAsyncOp->Lock();
	}
	pAsyncOp->SetProtocolHandle(hProtocol);
	pAsyncOp->Unlock();

	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}


//	DNPerformNextConnect
//
//	This will attempt to perform the next CONNECT if multiple adapters were requested

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformNextConnect"

HRESULT DNPerformNextConnect(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp,
							 IDirectPlay8Address *const pHostAddr,
							 IDirectPlay8Address *const pDeviceAddr)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	DN_CONNECT_OP_DATA	*pConnectOpData;

	DPF(6,"Parameters: pAsyncOp [0x%p], pHostAddr [0x%p], pDeviceAddr [0x%p]",pAsyncOp,pHostAddr,pDeviceAddr);

	pParent = NULL;

	pAsyncOp->Lock();
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->AddRef();
		pParent = pAsyncOp->GetParent();
	}
	pAsyncOp->Unlock();

	//
	//	If there are any ENUMs left to perform, we will move on to the next one
	//
	if (pParent)
	{
		if (pParent->GetOpData())
		{
			pConnectOpData = static_cast<DN_CONNECT_OP_DATA*>(pParent->GetOpData());
			if (pConnectOpData->dwCurrentAdapter < pConnectOpData->dwNumAdapters)
			{
				GUID	*pguid;

				pguid = reinterpret_cast<GUID*>(pConnectOpData + 1);
				pguid += pConnectOpData->dwCurrentAdapter;
				if ((hResultCode = pDeviceAddr->SetDevice(pguid)) != DPN_OK)
				{
					DPFERR("Could not set device for next adapter");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					goto Failure;
				}
				pConnectOpData->dwCurrentAdapter++;

				hResultCode = DNPerformConnect(	pdnObject,
												NULL,
												pDeviceAddr,
												pHostAddr,
												pParent->GetOpFlags(),
												pParent);
				if (hResultCode != DPN_OK)
				{
					DPFERR("Could not perform CONNECT");
					DisplayDNError(0,hResultCode);
					goto Failure;
				}
			}
		}

		pParent->Release();
		pParent = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteConnect"

void DNCompleteConnect(DIRECTNETOBJECT *const pdnObject,
					   CAsyncOp *const pAsyncOp)
{
	//
	//	Save the result code on the parent if it hasn't already been set (DPN_OK or DPNERR_HOSTREJECTEDCONNECTION)
	//
	if (pAsyncOp->GetParent() && (pAsyncOp->GetResult() != DPNERR_NOCONNECTION))
	{
		pAsyncOp->GetParent()->Lock();
		if ((pAsyncOp->GetParent()->GetResult() != DPN_OK)
				&& (pAsyncOp->GetParent()->GetResult() != DPNERR_HOSTREJECTEDCONNECTION))
		{
			pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		}
		pAsyncOp->GetParent()->Unlock();
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteConnectToHost"

void DNCompleteConnectToHost(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp)
{
	//
	//	Save the result code on the parent if there was a problem (this should be the connect operation parent)
	//
	if ((pAsyncOp->GetResult() != DPN_OK) && (pAsyncOp->GetResult() != DPNERR_NOCONNECTION))
	{
		if (pAsyncOp->GetParent())
		{
			pAsyncOp->GetParent()->Lock();
			if ((pAsyncOp->GetParent()->GetResult() != DPN_OK) && (pAsyncOp->GetParent()->GetResult() != DPNERR_HOSTREJECTEDCONNECTION))
			{
				pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
			}
			pAsyncOp->GetParent()->Unlock();
		}
	}

	//
	//	Clean up DirectNet object if this fails
	//
	if (pAsyncOp->GetResult() != DPN_OK)
	{
		CAsyncOp	*pConnectParent;

		pConnectParent = NULL;

		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_HOST_CONNECTED));
		if (pdnObject->pConnectParent)
		{
			pConnectParent = pdnObject->pConnectParent;
			pdnObject->pConnectParent = NULL;
		}
		if( pdnObject->pIDP8ADevice )
		{
			pdnObject->pIDP8ADevice->Release();
			pdnObject->pIDP8ADevice = NULL;
		}
		if( pdnObject->pConnectAddress )
		{
			pdnObject->pConnectAddress->Release();
			pdnObject->pConnectAddress = NULL;
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		if (pConnectParent)
		{
			pConnectParent->Release();
			pConnectParent = NULL;
		}

		DNASSERT(pConnectParent == NULL);
	}

	//
	//	Clean up CONNECT op data
	//
	if (pAsyncOp->GetOpData() != NULL)
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}

	//
	//	Detach from parent
	//	I'm not sure why we need to do this !
	//
	DNASSERT(pAsyncOp->IsChild());
	DNASSERT(pAsyncOp->GetParent());
	pAsyncOp->Orphan();
}


//
//	Completion for connect parent
//
#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteConnectOperation"

void DNCompleteConnectOperation(DIRECTNETOBJECT *const pdnObject,
								CAsyncOp *const pAsyncOp)
{
	//
	//	Save the result code on the parent (if it exists - it will be the CONNECT handle)
	//
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->Lock();
		pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		pAsyncOp->GetParent()->SetRefCountBuffer( pAsyncOp->GetRefCountBuffer() );
		pAsyncOp->GetParent()->Unlock();

		if (pAsyncOp->GetParent()->GetHandle() != 0)
		{
			pdnObject->HandleTable.Destroy(pAsyncOp->GetParent()->GetHandle());
		}
	}

	//
	//	If the OpData of this AsyncOp is set it is a pointer to a RefCountBuffer pointer
	//	(sync connect call) and we will fill it in
	//
	if (pAsyncOp->GetOpData() && pAsyncOp->GetRefCountBuffer())
	{
		pAsyncOp->GetRefCountBuffer()->AddRef();
		*(static_cast<CRefCountBuffer**>(pAsyncOp->GetOpData())) = pAsyncOp->GetRefCountBuffer();
	}

	//
	//	Clear DISCONNECTING flag (in case this was aborted)
	//
	DPF(8,"Clearing DISCONNECTING flag");
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_DISCONNECTING);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
}


//
//	Completion for connect handle given to user if Connect was called asynchronously
//
#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteUserConnect"

void DNCompleteUserConnect(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp)
{
	//
	//	No longer connecting
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTING);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Generate connect completion for player
	//
	DNUserConnectComplete(	pdnObject,
							pAsyncOp->GetHandle(),
							pAsyncOp->GetContext(),
							pAsyncOp->GetResult(),
							pAsyncOp->GetRefCountBuffer() );

	//
	//	Cancel ENUMs if the CONNECT succeeded
	//
	if (pAsyncOp->GetResult() == DPN_OK)
	{
		DNCancelActiveCommands(pdnObject,DN_CANCEL_FLAG_ENUM_QUERY);
	}
}


//
//	Completion for NewPlayer sending connect data to the Host
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteSendConnectInfo"

void DNCompleteSendConnectInfo(DIRECTNETOBJECT *const pdnObject,
							   CAsyncOp *const pAsyncOp)
{
	//
	//	Update result of this send on the CONNECT operation parent
	//
	DNASSERT(pAsyncOp->GetParent() != NULL);
	pAsyncOp->GetParent()->Lock();
	if (pAsyncOp->GetResult() != DPN_OK)
	{
		pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		//
		//	Clean up CONNECT response buffer from Host
		//
		if (pAsyncOp->GetParent()->GetRefCountBuffer())
		{
			pAsyncOp->GetParent()->GetRefCountBuffer()->Release();
			pAsyncOp->GetParent()->SetRefCountBuffer( NULL );
		}
	}
	pAsyncOp->GetParent()->Unlock();

	//
	//	Clean up DirectNet object if this fails
	//
	if (pAsyncOp->GetResult() != DPN_OK)
	{
		CAsyncOp	*pConnectParent;

		pConnectParent = NULL;

		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_HOST_CONNECTED));
		if (pdnObject->pConnectParent)
		{
			pConnectParent = pdnObject->pConnectParent;
			pdnObject->pConnectParent = NULL;
		}
		if( pdnObject->pIDP8ADevice )
		{
			pdnObject->pIDP8ADevice->Release();
			pdnObject->pIDP8ADevice = NULL;
		}
		if( pdnObject->pConnectAddress )
		{
			pdnObject->pConnectAddress->Release();
			pdnObject->pConnectAddress = NULL;
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		if (pConnectParent)
		{
			pConnectParent->Release();
			pConnectParent = NULL;
		}

		DNASSERT(pConnectParent == NULL);
	}

	//
	//	Clean up op data
	//
	if (pAsyncOp->GetOpData())
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformDisconnect"

HRESULT DNPerformDisconnect(DIRECTNETOBJECT *const pdnObject,
							CConnection *const pConnection,
							const HANDLE hEndPt)
{
	HRESULT		hResultCode;
	HANDLE		hProtocol;
	CAsyncOp	*pAsyncOp;

	DPF(6,"Parameters: pConnection [0x%p]",pConnection);

	DNASSERT(pdnObject != NULL);

	pAsyncOp = NULL;

	if (hEndPt == NULL)
	{
		DPFERR("Ignoring NULL endpoint");
		hResultCode = DPN_OK;
		goto Failure;
	}

	//
	//	Create AsyncOp for this operation
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_DISCONNECT );
	pAsyncOp->SetConnection( pConnection );

	//
	//	AddRef Protocol so that it won't go away until this completes
	//
	DNProtocolAddRef(pdnObject);

	//
	//	Perform DISCONNECT
	//
	pAsyncOp->AddRef();
	hResultCode = DNPDisconnectEndPoint(pdnObject->pdnProtocolData,
										hEndPt,
										static_cast<void*>(pAsyncOp),
										&hProtocol);
	if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
	{
		DPFERR("Could not issue DISCONNECT");
		DisplayDNError(0,hResultCode);
		DNProtocolRelease(pdnObject);
		pAsyncOp->Release();
		goto Failure;
	}

	pAsyncOp->Lock();
	pAsyncOp->SetProtocolHandle( hProtocol );
	pAsyncOp->Unlock();

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteAsyncHandle"

void DNCompleteAsyncHandle(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	DNUserAsyncComplete(pdnObject,
						pAsyncOp->GetHandle(),
						pAsyncOp->GetContext(),
						pAsyncOp->GetResult() );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteSendHandle"

void DNCompleteSendHandle(DIRECTNETOBJECT *const pdnObject,
						  CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	DNUserSendComplete(	pdnObject,
						pAsyncOp->GetHandle(),
						pAsyncOp->GetContext(),
						pAsyncOp->GetStartTime(),
						pAsyncOp->GetResult() );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteSendAsyncOp"

void DNCompleteSendAsyncOp(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	//
	//	Update outstanding queue info - this is only performed on children or stand-alone ops (i.e. no parent)
	//
	if ( !pAsyncOp->IsParent() && (pAsyncOp->GetConnection() != NULL))
	{
		DN_SEND_OP_DATA	*pSendOpData;

		pSendOpData = NULL;
		if (pAsyncOp->GetOpData())
		{
			pSendOpData = static_cast<DN_SEND_OP_DATA*>(pAsyncOp->GetOpData());
		}
		else
		{
			if (pAsyncOp->IsChild() && pAsyncOp->GetParent())
			{
				if (pAsyncOp->GetParent()->GetOpData())
				{
					pSendOpData = static_cast<DN_SEND_OP_DATA*>(pAsyncOp->GetParent()->GetOpData());
				}
			}
		}

		if (pSendOpData && pSendOpData->dwMsgId == DN_MSG_USER_SEND)
		{
			pAsyncOp->GetConnection()->Lock();
			if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_HIGH_PRIORITY)
			{
				pAsyncOp->GetConnection()->RemoveFromHighQueue( pSendOpData->BufferDesc[0].dwBufferSize );
			}
			else if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_LOW_PRIORITY)
			{
				pAsyncOp->GetConnection()->RemoveFromLowQueue( pSendOpData->BufferDesc[0].dwBufferSize );
			}
			else
			{
				pAsyncOp->GetConnection()->RemoveFromNormalQueue( pSendOpData->BufferDesc[0].dwBufferSize );
			}
			pAsyncOp->GetConnection()->Unlock();
		}
	}

	//
	//	Clean up
	//
	if (pAsyncOp->GetOpData())
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
	}

	if ( pAsyncOp->IsChild() )
	{
		DNASSERT(pAsyncOp->GetParent() != NULL);

		pAsyncOp->GetParent()->Lock();

		//
		//	Save HRESULT.  Overwrite the parent's error while it's not DPN_OK.
		//
		if (pAsyncOp->GetParent()->GetResult() != DPN_OK)
		{
			pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		}

		//
		//	Release parent Handle if it exists
		//
		if ((pAsyncOp->GetParent()->GetOpType() == ASYNC_OP_USER_HANDLE) && (pAsyncOp->GetParent()->GetHandle() != 0))
		{
			pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle() );
		}

		pAsyncOp->GetParent()->Unlock();
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteRequest"

void DNCompleteRequest(DIRECTNETOBJECT *const pdnObject,
					   CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	//
	//	Clean up op data
	//
	if (pAsyncOp->GetOpData() != NULL)
	{
		MemoryBlockFree(pdnObject,pAsyncOp->GetOpData());
		pAsyncOp->SetOpData( NULL );
	}

	//
	//	If the parent exists, copy the result up, and then remove them from the HandleTable
	//
	if (pAsyncOp->GetParent() != NULL)
	{
		pAsyncOp->GetParent()->Lock();
		pAsyncOp->GetParent()->SetResult( pAsyncOp->GetResult() );
		pAsyncOp->GetParent()->Unlock();

		if (pAsyncOp->GetParent()->GetHandle() != 0)
		{
			pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle() );
		}
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteSendRequest"

void DNCompleteSendRequest(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp)
{
	DNASSERT(pdnObject != NULL);
	DNASSERT(pAsyncOp != NULL);

	DNASSERT(pAsyncOp->GetParent() != NULL);
	if (pAsyncOp->GetResult() != DPN_OK)
	{
		//
		//	If this operation failed, remove the parent (RequestChild) AsyncOp.
		//	There should be (at least) two references on the parent.
		//	One will be for this Child, which will be removed automatically.
		//	The second is for the HANDLE which should be on the parent.  Remove it.
		//
		if ((pAsyncOp->GetResult() == DPNERR_USERCANCEL) || !pAsyncOp->IsInternal())
		{
			DNASSERT(pAsyncOp->GetParent()->GetHandle() != 0);

			pdnObject->HandleTable.Destroy( pAsyncOp->GetParent()->GetHandle() );
		}
	}
	else
	{
		//
		//	Mark this operation as PLAYERLOST. If we do get an operation complete message,
		//	this result will get overwritten.
		//
		pAsyncOp->GetParent()->Lock();
		if (pAsyncOp->GetParent()->GetResult() == DPNERR_GENERIC)
		{
			pAsyncOp->GetParent()->SetResult( DPNERR_PLAYERLOST );
		}
		pAsyncOp->GetParent()->Unlock();
	}

//	DNCompleteSendAsyncOp(pdnObject,pAsyncOp);
}


//	DNSendMessage
//
//	Send structured message to given endpoint.  Internally generated sends have a header
//	associated with them.  The first few bytes of this header are a signature, indicating
//	an internal message.  User generated sends do not have a header, unless they contain
//	the signature.  In this case, the user message is escaped with a header indicating this.
//
//	For internal sends:
//	- Create message header (dwMsgId,dwParam1,dwParam2)
//	- Send message header and supplied data buffer (lpBuffDesc)
//	- Save Async Operation info to be unwound when send completes
//	- If pdnCountBuffer is specified, pBuffDesc may or may not point to its contents.
//
//	CConnection		*pConnection	Connection to send to
//	DWORD			uMsgId			Message ID
//	DNID			dnidTarget		DNID of target of this send (may be NULL)
//	DPN_BUFFER_DESC	*pBuffDesc		Pointer to array (1 or 2) buffer descriptors
//	CRefCountBuffer	*pRefCountBuffer RefCountBuffer to be AddRef'd and released on complete (may be NULL)
//	DWORD			dwTimeOut		Time Out
//	DWORD			dwSendFlags		Send flags
//	CAsyncOp		**ppAsyncOp		AsyncOp for this SEND (will be AddRef'd before returned)

#undef DPF_MODNAME
#define DPF_MODNAME "DNSendMessage"

HRESULT DNSendMessage(DIRECTNETOBJECT *const pdnObject,
					  CConnection *const pConnection,
					  const DWORD dwMsgId,
					  const DPNID dpnidTarget,
					  const DPN_BUFFER_DESC *const pdnBufferDesc,
					  CRefCountBuffer *const pRefCountBuffer,
					  const DWORD dwTimeOut,
					  const DWORD dwSendFlags,
					  CAsyncOp *const pParent,
					  CAsyncOp **const ppAsyncOp)
{
	HANDLE			hProtocol;
	HRESULT			hResultCode;
	HANDLE			hEndPt;
	CAsyncOp		*pAsyncOp;
	void			*pvBlock;
	DN_SEND_OP_DATA	*pSendOpData;


	// 7/28/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers, addresses, and handles.
	DPF(6,"Parameters: pConnection [0x%p], dwMsgId [0x%x], dpnidTarget [0x%x], pRefCountBuffer [0x%p], pdnBufferDesc [0x%p], dwTimeOut [%ld], dwSendFlags [0x%lx], ppAsyncOp [0x%p]",
		pConnection,dwMsgId,dpnidTarget,pRefCountBuffer,pdnBufferDesc,dwTimeOut,dwSendFlags,ppAsyncOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	pAsyncOp = NULL;
	pvBlock = NULL;

	//
	//	Create AsyncOp for SEND
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_SEND );
	pAsyncOp->SetDPNID( dpnidTarget );
	pAsyncOp->SetRefCountBuffer( pRefCountBuffer );
	pAsyncOp->SetStartTime( timeGetTime() );
	if (dwMsgId & DN_MSG_INTERNAL)
	{
		//
		//	We have to set this early (before it's in the active list or a child) so that it won't
		//	be prematurely cancelled (before we get a chance to mark it INTERNAL).
		//
		pAsyncOp->SetInternal();
	}

	//
	//	Make child if parent was supplied
	//
	if (pParent)
	{
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pAsyncOp->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pAsyncOp->MakeChild( pParent );
		pParent->Unlock();
	}

	//
	//	Add to active async op list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Set-up SEND op data block
	//
	if ((pvBlock = MemoryBlockAlloc(pdnObject,sizeof(DN_SEND_OP_DATA))) == NULL)
	{
		DPFERR("Could not allocate memory block");
		DNASSERT(FALSE);
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	pAsyncOp->SetOpData( pvBlock );

	pSendOpData = static_cast<DN_SEND_OP_DATA*>(pvBlock);
	pSendOpData->dwMsgId = dwMsgId;
	if (dwMsgId & DN_MSG_INTERNAL)
	{
#ifdef ENABLE_DPLAY_VOICE
		if (dwMsgId == DN_MSG_INTERNAL_VOICE_SEND)
		{
			DNASSERT(pdnBufferDesc != NULL);
			pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
			pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
			pSendOpData->BufferDesc[1].pBufferData = NULL;
			pSendOpData->BufferDesc[1].dwBufferSize = 0;
			pSendOpData->dwNumBuffers = 1;

			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO );
		}
		else
		{
#endif
			pSendOpData->BufferDesc[0].pBufferData = reinterpret_cast<BYTE*>( &(pSendOpData->dwMsgId) );
			pSendOpData->BufferDesc[0].dwBufferSize = sizeof( DWORD );
			if (pdnBufferDesc)
			{
				pSendOpData->BufferDesc[1].pBufferData = pdnBufferDesc->pBufferData;
				pSendOpData->BufferDesc[1].dwBufferSize = pdnBufferDesc->dwBufferSize;
				pSendOpData->dwNumBuffers = 2;
			}
			else
			{
				pSendOpData->BufferDesc[1].pBufferData = NULL;
				pSendOpData->BufferDesc[1].dwBufferSize = 0;
				pSendOpData->dwNumBuffers = 1;
			}

			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG );
#ifdef ENABLE_DPLAY_VOICE
		}
#endif
	}
	else
	{
		DNASSERT(pdnBufferDesc != NULL);
		pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
		pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
		pSendOpData->BufferDesc[1].pBufferData = NULL;
		pSendOpData->BufferDesc[1].dwBufferSize = 0;
		pSendOpData->dwNumBuffers = 1;

		pAsyncOp->SetOpFlags( dwSendFlags );

		//
		//	Update outstanding queue info - this will get cleaned up by the completion
		//
		pConnection->Lock();
		if (dwSendFlags & DN_SENDFLAGS_HIGH_PRIORITY)
		{
			pConnection->AddToHighQueue( pdnBufferDesc->dwBufferSize );
		}
		else if (dwSendFlags & DN_SENDFLAGS_LOW_PRIORITY)
		{
			pConnection->AddToLowQueue( pdnBufferDesc->dwBufferSize );
		}
		else
		{
			pConnection->AddToNormalQueue( pdnBufferDesc->dwBufferSize );
		}
		pConnection->Unlock();
	}

	if ((hResultCode = pConnection->GetEndPt(&hEndPt,TRUE)) != DPN_OK)
	{
		DPFERR("Could not get end point from connection");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_CONNECTIONLOST;	// re-map this
		goto Failure;
	}
	pAsyncOp->SetConnection( pConnection );

	if (hEndPt == NULL)		//	Message for local player - Put on local message queue
	{
		//
		//	INTERNAL Message
		//
		DPF(5,"INTERNAL Message");

		//
		//	AddRef Protocol as SendComplete will release this reference
		//
		DNProtocolAddRef(pdnObject);

		pAsyncOp->AddRef();
		hResultCode = DNWTSendInternal(	pdnObject,
										&pSendOpData->BufferDesc[0],
										pAsyncOp );

		pConnection->Release();

		DNASSERT( hResultCode == DPNERR_PENDING );
	}
	else
	{
		//
		//	EXTERNAL Message
		//
		DPF(5,"EXTERNAL Message");

		//
		//	AddRef Protocol so that it won't go away until this completes
		//
		DNProtocolAddRef(pdnObject);

		pAsyncOp->AddRef();
		hResultCode = DNPSendData(	pdnObject->pdnProtocolData,
									hEndPt,
									pSendOpData->dwNumBuffers,
									&pSendOpData->BufferDesc[0],
									0,
									dwTimeOut,
									pAsyncOp->GetOpFlags(),
									reinterpret_cast<void*>(pAsyncOp),
									&hProtocol);

		pConnection->Release();

		if (hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not send data");
			DisplayDNError(0,hResultCode);
			pAsyncOp->Release();
			DNProtocolRelease(pdnObject);
			goto Failure;
		}

		pAsyncOp->Lock();
		pAsyncOp->SetProtocolHandle( hProtocol );
		pAsyncOp->Unlock();
	}

	if (hResultCode == DPNERR_PENDING)
	{
		//
		//	Completion
		//
		pAsyncOp->SetCompletion( DNCompleteSendAsyncOp );
		pvBlock = NULL;		// Completion will clean this up

		if (ppAsyncOp != NULL)
		{
			pAsyncOp->AddRef();
			*ppAsyncOp = pAsyncOp;
		}
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:
	// Temporary debugging purposes only, shouldn't be checked in!
#if	0
	DNMemoryTrackingValidateMemory();
#endif

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pvBlock)
	{
		MemoryBlockFree(pdnObject,pvBlock);
		pvBlock = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNSendGroupMessage"

HRESULT DNSendGroupMessage(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pGroup,
						   const DWORD dwMsgId,
						   const DPN_BUFFER_DESC *const pdnBufferDesc,
						   CRefCountBuffer *const pRefCountBuffer,
						   const DWORD dwTimeOut,
						   const DWORD dwSendFlags,
						   const BOOL fNoLoopBack,
						   const BOOL fRequest,
						   CAsyncOp *const pParent,
						   CAsyncOp **const ppGroupSendParent)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	*pGroupSendParent;
	CBilink		*pBilink;
	CConnection	*pConnection;
	CGroupConnection	*pGroupConnection;
	DN_GROUP_SEND_OP	*pSendOp;
	DN_GROUP_SEND_OP	*pTemp;
	DPNID				dpnidLocalPlayer;

	DPF(4,"Parameters: pGroup [0x%p], dwMsgId [0x%lx], pdnBufferDesc [0x%p], pRefCountBuffer [0x%p], dwTimeOut [%ld], dwSendFlags [0x%lx], fNoLoopBack [%ld], fRequest [%ld], pParent [0x%p], ppGroupSendParent [0x%p]",
			pGroup,dwMsgId,pdnBufferDesc,pRefCountBuffer,dwTimeOut,dwSendFlags,fNoLoopBack,fRequest,pParent,ppGroupSendParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pGroup != NULL);

	pAsyncOp = NULL;
	pGroupSendParent = NULL;
	pConnection = NULL;
	pGroupConnection = NULL;

	if (fNoLoopBack)
	{
		CNameTableEntry		*pLocalPlayer;

		pLocalPlayer = NULL;
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
		{
			DPFERR("Could not get local player reference");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		dpnidLocalPlayer = pLocalPlayer->GetDPNID();
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		dpnidLocalPlayer = 0;
	}

	//
	//	Create group send target list
	//
	pSendOp = NULL;
	pGroup->Lock();
	pBilink = pGroup->m_bilinkConnections.GetNext();
	while (pBilink != &pGroup->m_bilinkConnections)
	{
		pGroupConnection = CONTAINING_OBJECT(pBilink,CGroupConnection,m_bilink);
		if ((hResultCode = pGroupConnection->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			//
			//	We will only use CONNECTED connections (not CONNECTING,DISCONNECTING, or INVALID ones)
			//
			if (pConnection->IsConnected())
			{
				if ((!fNoLoopBack) || (pConnection->GetDPNID() != dpnidLocalPlayer))
				{
					//
					//	Save this connection
					//
					pTemp = static_cast<DN_GROUP_SEND_OP*>(MemoryBlockAlloc(pdnObject,sizeof(DN_GROUP_SEND_OP)));
					if (pTemp == NULL)
					{
						pGroup->Unlock();
						DPFERR("Could not create DN_GROUP_SEND_OP");
						hResultCode = DPNERR_OUTOFMEMORY;
						goto Failure;
					}
					pConnection->AddRef();
					pTemp->pConnection = pConnection;
					pTemp->pNext = pSendOp;
					pSendOp = pTemp;
				}
			}
			pConnection->Release();
			pConnection = NULL;
		}
		pBilink = pBilink->GetNext();
	}
	pGroup->Unlock();

	//
	//	Create group send parent
	//
	if ((hResultCode = DNCreateSendParent(pdnObject,dwMsgId,pdnBufferDesc,dwSendFlags,&pGroupSendParent)) != DPN_OK)
	{
		DPFERR("Could not create SEND parent");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pRefCountBuffer)
	{
		pGroupSendParent->SetRefCountBuffer( pRefCountBuffer );
	}
	pGroupSendParent->SetDPNID( pGroup->GetDPNID() );

	//
	//	Make child if parent specified
	//
	if (pParent)
	{
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pGroupSendParent->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pGroupSendParent->MakeChild( pParent );
		pParent->Unlock();
	}

	//
	//	Traverse send list and perform sends
	//
	while (pSendOp)
	{
		if (fRequest)
		{
			hResultCode = DNPerformRequest(	pdnObject,
											DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION,
											pdnBufferDesc,
											pSendOp->pConnection,
											pGroupSendParent,
											&pAsyncOp);
		}
		else
		{
			hResultCode = DNPerformChildSend(	pdnObject,
												pGroupSendParent,
												pSendOp->pConnection,
												dwTimeOut,
												&pAsyncOp,
												FALSE);
		}

		if (pAsyncOp != NULL)
		{
			pAsyncOp->SetDPNID( pSendOp->pConnection->GetDPNID() );
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}

		//
		//	Destroy old group send op
		//
		pTemp = pSendOp;
		pSendOp = pSendOp->pNext;
		pTemp->pConnection->Release();
		pTemp->pConnection = NULL;
		MemoryBlockFree(pdnObject,pTemp);
	}

	//
	//	Pass back group send parent (if required)
	//
	if (ppGroupSendParent)
	{
		pGroupSendParent->AddRef();
		*ppGroupSendParent = pGroupSendParent;
	}

	pGroupSendParent->Release();
	pGroupSendParent = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pGroupSendParent)
	{
		pGroupSendParent->Release();
		pGroupSendParent = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCreateSendParent"

HRESULT DNCreateSendParent(DIRECTNETOBJECT *const pdnObject,
						   const DWORD dwMsgId,
						   const DPN_BUFFER_DESC *const pdnBufferDesc,
						   const DWORD dwSendFlags,
						   CAsyncOp **const ppParent)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	void			*pvBlock;
	DN_SEND_OP_DATA	*pSendOpData;

	DPF(4,"Parameters: dwMsgId [0x%lx], pdnBufferDesc [0x%p], ppParent [0x%p]",
			dwMsgId,pdnBufferDesc,ppParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppParent != NULL);

	pAsyncOp = NULL;
	pvBlock = NULL;

	if ((pvBlock = MemoryBlockAlloc(pdnObject,sizeof(DN_SEND_OP_DATA))) == NULL)
	{
		DPFERR("Could not allocate MemoryBlock");
		DNASSERT(FALSE);
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_SEND );
	pAsyncOp->SetOpData( pvBlock );
	pAsyncOp->MakeParent();

	pSendOpData = static_cast<DN_SEND_OP_DATA*>(pvBlock);
	pSendOpData->dwMsgId = dwMsgId;
	if (dwMsgId & DN_MSG_INTERNAL)
	{
#ifdef ENABLE_DPLAY_VOICE
		if (dwMsgId == DN_MSG_INTERNAL_VOICE_SEND)
		{
			DNASSERT(pdnBufferDesc != NULL);
			pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
			pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
			pSendOpData->BufferDesc[1].pBufferData = NULL;
			pSendOpData->BufferDesc[1].dwBufferSize = 0;
			pSendOpData->dwNumBuffers = 1;

			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG | DN_SENDFLAGS_SET_USER_FLAG_TWO );
		}
		else
		{
#endif
			pSendOpData->BufferDesc[0].pBufferData = reinterpret_cast<BYTE*>( &(pSendOpData->dwMsgId) );
			pSendOpData->BufferDesc[0].dwBufferSize = sizeof( DWORD );
			if (pdnBufferDesc)
			{
				pSendOpData->BufferDesc[1].pBufferData = pdnBufferDesc->pBufferData;
				pSendOpData->BufferDesc[1].dwBufferSize = pdnBufferDesc->dwBufferSize;
				pSendOpData->dwNumBuffers = 2;
			}
			else
			{
				pSendOpData->BufferDesc[1].pBufferData = NULL;
				pSendOpData->BufferDesc[1].dwBufferSize = 0;
				pSendOpData->dwNumBuffers = 1;
			}

			pAsyncOp->SetOpFlags( dwSendFlags | DN_SENDFLAGS_SET_USER_FLAG );
#ifdef ENABLE_DPLAY_VOICE
		}
#endif
	}
	else
	{
		DNASSERT(pdnBufferDesc != NULL);
		pSendOpData->BufferDesc[0].pBufferData = pdnBufferDesc->pBufferData;
		pSendOpData->BufferDesc[0].dwBufferSize = pdnBufferDesc->dwBufferSize;
		pSendOpData->BufferDesc[1].pBufferData = NULL;
		pSendOpData->BufferDesc[1].dwBufferSize = 0;
		pSendOpData->dwNumBuffers = 1;

		pAsyncOp->SetOpFlags( dwSendFlags );
	}

	//
	//	Completion
	//
	pAsyncOp->SetCompletion( DNCompleteSendAsyncOp );
	pvBlock = NULL;		// Completion will clean this up

	pAsyncOp->AddRef();
	*ppParent = pAsyncOp;

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pvBlock)
	{
		MemoryBlockFree(pdnObject,pvBlock);
		pvBlock = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformChildSend"

HRESULT DNPerformChildSend(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pParent,
						   CConnection *const pConnection,
						   const DWORD dwTimeOut,
						   CAsyncOp **const ppChild,
						   const BOOL fInternal)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DN_SEND_OP_DATA	*pSendOpData;
	HANDLE			hEndPt;
	HANDLE			hProtocol;

	DPF(4,"Parameters: pParent [0x%p], pConnection [0x%p], dwTimeOut [%ld]",
			pParent,pConnection,dwTimeOut);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pParent != NULL);
	DNASSERT(pConnection != NULL);

	pAsyncOp = NULL;
	pSendOpData = static_cast<DN_SEND_OP_DATA*>(pParent->GetOpData());

	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_SEND );
	pAsyncOp->SetCompletion( DNCompleteSendAsyncOp );
	pAsyncOp->SetOpFlags( pParent->GetOpFlags() );
	if (fInternal)
	{
		pAsyncOp->SetInternal();
	}

	pParent->Lock();
	if (pParent->IsCancelled())
	{
		pParent->Unlock();
		pAsyncOp->SetResult( DPNERR_USERCANCEL );
		hResultCode = DPNERR_USERCANCEL;
		goto Failure;
	}
	pAsyncOp->MakeChild( pParent );
	pParent->Unlock();

	//
	//	Add to active async op list
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.InsertBefore(&pdnObject->m_bilinkActiveList);
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Update outstanding queue info - this will get cleaned up by the completion
	//
	if (pSendOpData->dwMsgId == DN_MSG_USER_SEND)
	{
		pConnection->Lock();
		if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_HIGH_PRIORITY)
		{
			pConnection->AddToHighQueue( pSendOpData->BufferDesc[0].dwBufferSize );
		}
		else if (pAsyncOp->GetOpFlags() & DN_SENDFLAGS_LOW_PRIORITY)
		{
			pConnection->AddToLowQueue( pSendOpData->BufferDesc[0].dwBufferSize );
		}
		else
		{
			pConnection->AddToNormalQueue( pSendOpData->BufferDesc[0].dwBufferSize );
		}
		pConnection->Unlock();
	}

	//
	//	Save connection and get end point
	//
	if ((hResultCode = pConnection->GetEndPt(&hEndPt,TRUE)) != DPN_OK)
	{
		DPFERR("Could not retrieve EndPt");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pAsyncOp->SetConnection( pConnection );

	if (hEndPt == NULL)
	{
		//
		//	INTERNAL Message
		//
		DPF(5,"INTERNAL Message");

		//
		//	AddRef Protocol as SendComplete will release this reference
		//
		DNProtocolAddRef(pdnObject);

		pAsyncOp->AddRef();
		hResultCode = DNWTSendInternal(	pdnObject,
										&pSendOpData->BufferDesc[0],
										pAsyncOp );

		pConnection->Release();

		DNASSERT(hResultCode == DPNERR_PENDING);
	}
	else
	{
		//
		//	EXTERNAL Message
		//
		DPF(5,"EXTERNAL Message");

		//
		//	AddRef Protocol so that it won't go away until this completes
		//
		DNProtocolAddRef(pdnObject);

		pAsyncOp->AddRef();
		hResultCode = DNPSendData(	pdnObject->pdnProtocolData,
									hEndPt,
									pSendOpData->dwNumBuffers,
									&pSendOpData->BufferDesc[0],
									0,
									dwTimeOut,
									pParent->GetOpFlags(),
									reinterpret_cast<void*>(pAsyncOp),
									&hProtocol);
		pConnection->Release();

		if (hResultCode != DPNERR_PENDING)
		{
			DPFERR("SEND failed at Protocol layer");
			DisplayDNError(0,hResultCode);
			pAsyncOp->Release();
			DNProtocolRelease(pdnObject);
			goto Failure;
		}

		pAsyncOp->Lock();
		if (pAsyncOp->IsCancelled())
		{
			HRESULT		hrCancel;

			pAsyncOp->Unlock();
			DPF(7,"Operation marked for cancel");
			if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
			{
				hResultCode = DPNERR_USERCANCEL;
				goto Failure;
			}
			DPFERR("Could not cancel operation");
			DisplayDNError(0,hrCancel);
			pAsyncOp->Lock();
		}
		pAsyncOp->SetProtocolHandle( hProtocol );
		pAsyncOp->Unlock();
	}

	//
	//	If the caller wants a reference on this operation, give it to them
	//
	if (ppChild != NULL)
	{
		pAsyncOp->AddRef();
		*ppChild = pAsyncOp;
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:
	// Temporary debugging purposes only, shouldn't be checked in!
#if	0
	DNMemoryTrackingValidateMemory();
#endif

	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DN_ProcessInternalOperation
//
//	Process an internal operation
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ProcessInternalOperation"

HRESULT DNProcessInternalOperation(DIRECTNETOBJECT *const pdnObject,
								   const DWORD dwMsgId,
								   void *const pOpBuffer,
								   const DWORD dwOpBufferSize,
								   CConnection *const pConnection,
								   const HANDLE hProtocol,
								   CRefCountBuffer *const pRefCountBuffer)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRCBuffer;
	CWorkerJob			*pWorkerJob;

	DPF(6,"Parameters: dwMsgId [0x%lx], pOpBuffer [0x%p], dwOpBufferSize [%ld], pConnection [0x%p], hProtocol [0x%p], pRefCountBuffer [0x%p]",
			dwMsgId,pOpBuffer,dwOpBufferSize,pConnection,hProtocol,pRefCountBuffer);

	pRCBuffer = NULL;
	pWorkerJob = NULL;

	switch(dwMsgId)
	{
		case DN_MSG_INTERNAL_PLAYER_CONNECT_INFO:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_PLAYER_CONNECT_INFO");
				// Perform validations and send name table to player
				hResultCode = DNHostConnect1(pdnObject,pOpBuffer,dwOpBufferSize,pConnection);

				hResultCode = DPN_OK;	// Ignore return code

				break;
			}

		case DN_MSG_INTERNAL_SEND_CONNECT_INFO:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_SEND_CONNECT_INFO");

				//
				//	We will pass this stage off to the worker thread since there is a threading
				//	issue, and we cannot keep the SP's thread which was passed up to here.
				//

				if ((hResultCode = RefCountBufferNew(pdnObject,dwOpBufferSize,&pRCBuffer)) != DPN_OK)
				{
					DPFERR("Could not allocate RefCountBuffer");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					hResultCode = DPN_OK;
					goto Failure;
				}
				memcpy(pRCBuffer->GetBufferAddress(),pOpBuffer,dwOpBufferSize);

				if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
				{
					DPFERR("Could not create WorkerJob");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					hResultCode = DPN_OK;
					goto Failure;
				}
				pWorkerJob->SetJobType( WORKER_JOB_INSTALL_NAMETABLE );
				pWorkerJob->SetConnection( pConnection );
				pWorkerJob->SetRefCountBuffer( pRCBuffer );

				DNQueueWorkerJob(pdnObject,pWorkerJob);
				pWorkerJob = NULL;

				pRCBuffer->Release();
				pRCBuffer = NULL;

				break;
			}

		case DN_MSG_INTERNAL_ACK_CONNECT_INFO:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_ACK_CONNECT_INFO");
				// Process connect info acknowledge by host
				hResultCode = DNHostConnect2(pdnObject,pConnection);	// Ignore errors

				break;
			}

		case DN_MSG_INTERNAL_SEND_PLAYER_DNID:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_SEND_PLAYER_DNID");
				// Send this player's DNID to the connecting player to enable name table entry
				hResultCode = DNPlayerConnect1(pdnObject,pOpBuffer,pConnection);	// Ignore errors

				break;
			}

		case DN_MSG_INTERNAL_CONNECT_FAILED:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_CONNECT_FAILED");

				//
				//	Save reply buffer and clean up
				//
				DNConnectToHostFailed(pdnObject,pOpBuffer,dwOpBufferSize);

				//
				//	Release the reference on the connection since we will be dropping the link.
				//	We are safe releasing the connection here, since the protocol will prevent
				//	the Host's DISCONNECT from being passed up to us until after this thread
				//	has returned back down.
				//
				pConnection->Disconnect();

				hResultCode = DPN_OK;

				break;
			}

		case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_INSTRUCT_CONNECT");
				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_INSTRUCT_CONNECT,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol);

				break;
			}

		case DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED");
				hResultCode = DNHostDropPlayer(pdnObject,pConnection->GetDPNID(),pOpBuffer);	// Ignore errors
				break;
			}

		case DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED:
			{
				DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED	*pInfo;

				DPF(7,"Received: DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED");

				pInfo = static_cast<DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED*>(pOpBuffer);
				DPF(7,"Player [0x%lx] could not connect to us",pInfo->dpnid);

				hResultCode = DNAbortConnect(pdnObject,DPNERR_PLAYERNOTREACHABLE);		// Ignore errors
				break;
			}

		case DN_MSG_INTERNAL_NAMETABLE_VERSION:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_NAMETABLE_VERSION");
				hResultCode = DNNTHostReceiveVersion(pdnObject,pConnection->GetDPNID(),pOpBuffer);

				break;
			}

		case DN_MSG_INTERNAL_RESYNC_VERSION:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_RESYNC_VERSION");
				hResultCode = DNNTPlayerResyncVersion(pdnObject,pOpBuffer);

				break;
			}

		case DN_MSG_INTERNAL_REQ_NAMETABLE_OP:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_REQ_NAMETABLE_OP");
				hResultCode = DNProcessHostMigration2(pdnObject,pOpBuffer);

				break;
			}

		case DN_MSG_INTERNAL_ACK_NAMETABLE_OP:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_ACK_NAMETABLE_OP");
				hResultCode = DNPerformHostMigration3(pdnObject,pOpBuffer);

				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_HOST_MIGRATE");
				hResultCode = DNProcessHostMigration1(pdnObject,pOpBuffer);

				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE");
				hResultCode = DNProcessHostMigration3(pdnObject);

				break;
			}

		case DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC");
				hResultCode = DNProcessUpdateAppDesc(pdnObject,static_cast<DPN_APPLICATION_DESC_INFO*>(pOpBuffer));

				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_ADD_PLAYER");
				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_ADD_PLAYER,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol);

				break;
			}

		case DN_MSG_INTERNAL_DESTROY_PLAYER:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_DESTROY_PLAYER");
				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_DESTROY_PLAYER,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol);

				break;
			}

		case DN_MSG_INTERNAL_CREATE_GROUP:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_CREATE_GROUP");
				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_CREATE_GROUP,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol);

				break;
			}

		case DN_MSG_INTERNAL_DESTROY_GROUP:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_DESTROY_GROUP");
				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_DESTROY_GROUP,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol);

				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP");
				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol);

				break;
			}

		case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP");
				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol);

				break;
			}

		case DN_MSG_INTERNAL_UPDATE_INFO:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_UPDATE_INFO");
				hResultCode = DNNTAddOperation(	pdnObject,
												DN_MSG_INTERNAL_UPDATE_INFO,
												pOpBuffer,
												dwOpBufferSize,
												hProtocol);

				break;
			}

		case DN_MSG_INTERNAL_REQ_CREATE_GROUP:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_REQ_CREATE_GROUP");
				hResultCode = DNHostProcessRequest(pdnObject,DN_MSG_INTERNAL_REQ_CREATE_GROUP,
						pOpBuffer,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_REQ_DESTROY_GROUP:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_REQ_DESTROY_GROUP");
				hResultCode = DNHostProcessRequest(pdnObject,DN_MSG_INTERNAL_REQ_DESTROY_GROUP,
						pOpBuffer,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP");
				hResultCode = DNHostProcessRequest(pdnObject,
						DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP,pOpBuffer,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP");
				hResultCode = DNHostProcessRequest(pdnObject,
						DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP,pOpBuffer,pConnection->GetDPNID());

				break;
			}

		case DN_MSG_INTERNAL_REQ_UPDATE_INFO:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_REQ_UPDATE_INFO");
				hResultCode = DNHostProcessRequest(pdnObject,DN_MSG_INTERNAL_REQ_UPDATE_INFO,
						pOpBuffer,pConnection->GetDPNID());

				break;
			}

#ifdef ENABLE_DPLAY_VOICE
		case DN_MSG_INTERNAL_VOICE_SEND:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_VOICE_SEND");

				hResultCode = Voice_Receive( pdnObject, pConnection->GetDPNID(), 0, pOpBuffer, dwOpBufferSize );	

				break;
			}
#endif

		case DN_MSG_INTERNAL_BUFFER_IN_USE:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_BUFFER_IN_USE - INVALID !");
				DNASSERT(FALSE);
				break;
			}

		case DN_MSG_INTERNAL_REQUEST_FAILED:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_REQUEST_FAILED - INVALID !");
				
				hResultCode = DNProcessFailedRequest(pdnObject,pOpBuffer);

				break;
			}

		case DN_MSG_INTERNAL_TERMINATE_SESSION:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_TERMINATE_SESSION");

				hResultCode = DNProcessTerminateSession(pdnObject,pOpBuffer,dwOpBufferSize);

				break;
			}

		case DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION");

				//
				//	Ensure requesting player in NameTable
				//
				hResultCode = DNReceiveCompleteOnProcess(pdnObject,pConnection,pOpBuffer,
						dwOpBufferSize,hProtocol,pRefCountBuffer);

				if (hResultCode != DPNERR_PENDING)
				{
					hResultCode = DPN_OK;	// Ignore errors
				}
				break;
			}

		case DN_MSG_INTERNAL_PROCESS_COMPLETION:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_PROCESS_COMPLETION");

				hResultCode = DNReceiveCompleteOnProcessReply(pdnObject,pOpBuffer,dwOpBufferSize);

				break;
			}

		case DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK");
				hResultCode = DNHostProcessRequest(pdnObject,DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK,
						pOpBuffer,pConnection->GetDPNID());

				hResultCode = DPN_OK;

				break;
			}

		case DN_MSG_INTERNAL_INTEGRITY_CHECK:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_INTEGRITY_CHECK");
				hResultCode = DNProcessCheckIntegrity(pdnObject,pOpBuffer);

				hResultCode = DPN_OK;	// Ignore errors

				break;
			}

		case DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE:
			{
				DPF(7,"Received: DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE");
				hResultCode = DNHostFixIntegrity(pdnObject,pOpBuffer);

				hResultCode = DPN_OK;	// Ignore errors

				break;
			}

		default:
			{
				DPF(7,"Received: DN_MSG_INTERNAL (UNKNOWN!)");
				DNASSERT(FALSE);
				hResultCode = DPNERR_UNSUPPORTED;
				break;
			}
	}

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRCBuffer)
	{
		pRCBuffer->Release();
		pRCBuffer = NULL;
	}
	if (pWorkerJob)
	{
		pWorkerJob->ReturnSelfToPool();
		pWorkerJob = NULL;
	}
	goto Exit;
}



#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformRequest"

HRESULT DNPerformRequest(DIRECTNETOBJECT *const pdnObject,
						 const DWORD dwMsgId,
						 const DPN_BUFFER_DESC *const pBufferDesc,
						 CConnection *const pConnection,
						 CAsyncOp *const pParent,
						 CAsyncOp **const ppRequest)
{
	HRESULT			hResultCode;
	BOOL			fInternal;
	BOOL			fReleaseLock;
	void			*pvBlock;
	CAsyncOp		*pRequest;
	CAsyncOp		*pSend;
	CRefCountBuffer	*pRefCountBuffer;
	DN_SEND_OP_DATA	*pSendOpData;
	DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION	*pMsg;

	DPF(6,"Parameters: dwMsgId [0x%lx], pBufferDesc [0x%p], pConnection [0x%p], pParent [0x%p], ppRequest [0x%p]",
			dwMsgId,pBufferDesc,pConnection,pParent,ppRequest);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pBufferDesc != NULL);

	pRequest = NULL;
	pSend = NULL;
	pRefCountBuffer = NULL;
	pvBlock = NULL;
	fReleaseLock = FALSE;

	//
	//	Create RefCountBuffer for this operation
	//
	hResultCode = RefCountBufferNew(pdnObject,
									pBufferDesc->dwBufferSize + sizeof(DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION),
									&pRefCountBuffer);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION*>(pRefCountBuffer->GetBufferAddress());
	memcpy(pMsg + 1,pBufferDesc->pBufferData,pBufferDesc->dwBufferSize);

	//
	//	Keep DirectNetObject from vanishing under us !
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		DPFERR("Aborting request - object is closing");
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

	//
	//	Create REQUEST
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pRequest)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pRequest->SetOpType( ASYNC_OP_REQUEST );
	if (pParent)
	{
		pParent->Lock();
		if (pParent->IsCancelled())
		{
			pParent->Unlock();
			pRequest->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pRequest->MakeChild( pParent );
		pParent->Unlock();
	}
	pRequest->MakeParent();
	pRequest->SetRefCountBuffer( pRefCountBuffer );

	//
	//	Need a handle for this op (to be sent to the other side who will pass it back)
	//
	if ((hResultCode = pdnObject->HandleTable.Create(pRequest,NULL)) != DPN_OK)
	{
		DPFERR("Could not create handle for this operation");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	DNASSERT(pRequest->GetHandle() != 0);

	//
	//	Set up SEND op data
	//
	if ((pvBlock = MemoryBlockAlloc(pdnObject,sizeof(DN_SEND_OP_DATA))) == NULL)
	{
		DPFERR("Could not allocate DN_REQUEST_OP_DATA");
		DNASSERT(FALSE);
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	pSendOpData = static_cast<DN_SEND_OP_DATA*>(pvBlock);
	pSendOpData->dwMsgId = dwMsgId;
	pSendOpData->BufferDesc[0].pBufferData = reinterpret_cast<BYTE*>(&pSendOpData->dwMsgId);
	pSendOpData->BufferDesc[0].dwBufferSize = sizeof(DWORD);
	pSendOpData->BufferDesc[1].pBufferData = pRefCountBuffer->GetBufferAddress();
	pSendOpData->BufferDesc[1].dwBufferSize = pRefCountBuffer->GetBufferSize();
	pSendOpData->dwNumBuffers = 2;

	pRequest->SetOpFlags( DN_SENDFLAGS_RELIABLE | DN_SENDFLAGS_SET_USER_FLAG );
	pRequest->SetCompletion( DNCompleteRequest );
	pRequest->SetOpData( pvBlock );
	pRequest->SetResult( DPNERR_PLAYERLOST );
	pvBlock = NULL;		// Completion will clean up

	pMsg->hCompletionOp = pRequest->GetHandle();

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	User messages sent with COMPLETE_ON_SEND should be allowed to be cancelled
	//
	if (dwMsgId == DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION)
	{
		fInternal = FALSE;
	}
	else
	{
		fInternal = TRUE;
	}

	//
	//	We will always hand back the request, even if the send fails
	//
	if (ppRequest)
	{
		pRequest->AddRef();
		*ppRequest = pRequest;
	}

	//
	//	Unlock DirectNetObject
	//
	DNDecRefLock(pdnObject);
	fReleaseLock = FALSE;

	//
	//	SEND REQUEST
	//
	if (pConnection)
	{
		hResultCode = DNPerformChildSend(	pdnObject,
											pRequest,
											pConnection,
											0,
											&pSend,
											fInternal );
		if (hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not perform child SEND");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		//
		//	Reset SEND AsyncOp to complete apropriately.
		//
		pSend->SetCompletion( DNCompleteSendRequest );

		pSend->Release();
		pSend = NULL;
	}

	pRequest->Release();
	pRequest = NULL;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}
	if (pRequest)
	{
		pRequest->Release();
		pRequest = NULL;
	}
	if (pSend)
	{
		pSend->Release();
		pSend = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pvBlock)
	{
		MemoryBlockFree(pdnObject,pvBlock);
		pvBlock = NULL;
	}
	goto Exit;
}


//	DNReceiveCompleteOnProcess
//
//	Receive a CompleteOnProcess message
//	Pass the message up to the application and then return a special completion message

#undef DPF_MODNAME
#define DPF_MODNAME "DNReceiveCompleteOnProcess"

HRESULT DNReceiveCompleteOnProcess(DIRECTNETOBJECT *const pdnObject,
								   CConnection *const pConnection,
								   void *const pBufferData,
								   const DWORD dwBufferSize,
								   const HANDLE hProtocol,
								   CRefCountBuffer *const pRefCountBuffer)
{
	HRESULT			hResultCode;
	PVOID			pvData;
	DWORD			dwDataSize;
	DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION	*pReq;

	DPF(4,"Parameters: pConnection [0x%p], pBufferData [0x%p], dwBufferSize [%ld], hProtocol [0x%p], pRefCountBuffer [0x%p]",
			pConnection,pBufferData,dwBufferSize,hProtocol,pRefCountBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	//
	//	Extract message
	//
	pReq = static_cast<DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION*>(pBufferData);
	pvData = static_cast<void*>(pReq + 1);
	dwDataSize = dwBufferSize - sizeof(DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION);

	//
	//	Pass data to application
	//
	hResultCode = DNReceiveUserData(pdnObject,
									pConnection->GetDPNID(),
									static_cast<BYTE*>(pvData),
									dwDataSize,
									hProtocol,
									pRefCountBuffer,
									pReq->hCompletionOp,
									0);

	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNReceiveCompleteOnProcessReply
//
//	Receive a CompleteOnProcess COMPLETION message
//	Complete the outstanding CompleteOnProcess operation

#undef DPF_MODNAME
#define DPF_MODNAME "DNReceiveCompleteOnProcessReply"

HRESULT DNReceiveCompleteOnProcessReply(DIRECTNETOBJECT *const pdnObject,
										void *const pBufferData,
										const DWORD dwBufferSize)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DN_INTERNAL_MESSAGE_PROCESS_COMPLETION	*pMsg;

	DPF(4,"Parameters: pBufferData [0x%p], dwBufferSize [%ld]",pBufferData,dwBufferSize);

	DNASSERT(pBufferData != NULL);

	pAsyncOp = NULL;

	pMsg = static_cast<DN_INTERNAL_MESSAGE_PROCESS_COMPLETION*>(pBufferData);

	//
	//	Retrieve AsyncOp from handle and remove handle from HandleTable
	//
	DPF(5,"Release completion operation [0x%lx]",pMsg->hCompletionOp);
	if ((hResultCode = pdnObject->HandleTable.Find(pMsg->hCompletionOp,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not find handle in HandleTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pdnObject->HandleTable.Destroy( pAsyncOp->GetHandle() );
//	pAsyncOp->SetHandle( 0 );

	//
	//	Mark this operation as completing okay
	//
	pAsyncOp->SetResult( DPN_OK );

	//
	//	This release should be the final release of the Request Child Async Op. and should
	//	DecRef the Request Parent Async Op.
	//
	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DNProcessTerminateSession
//
//	Process a TERMINATE_SESSION message from the Host player

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessTerminateSession"

HRESULT DNProcessTerminateSession(DIRECTNETOBJECT *const pdnObject,
								  void *const pvBuffer,
								  const DWORD dwBufferSize)
{
	HRESULT		hResultCode;
	void		*pvTerminateData;
	DN_INTERNAL_MESSAGE_TERMINATE_SESSION	*pMsg;

	DPF(4,"Parameters: pvBuffer [0x%p], dwBufferSize [%ld]",pvBuffer,dwBufferSize);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pMsg = static_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pvBuffer);
	if (pMsg->dwTerminateDataOffset)
	{
		pvTerminateData = static_cast<void*>(static_cast<BYTE*>(pvBuffer) + pMsg->dwTerminateDataOffset);
	}
	else
	{
		pvTerminateData = NULL;
	}

	//
	//	Inform user of termination
	//
	hResultCode = DNUserTerminateSession(pdnObject,DPNERR_HOSTTERMINATEDSESSION,pvTerminateData,pMsg->dwTerminateDataSize);

	// Terminate session
	hResultCode = DNTerminateSession(pdnObject,DPNERR_HOSTTERMINATEDSESSION);

	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\cancel.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Cancel.cpp
 *  Content:    DirectNet Cancel Operations
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/07/00	mjn		Created
 *	04/08/00	mjn		Added DNCancelEnum(), DNCancelSend()
 *	04/11/00	mjn		DNCancelEnum() uses CAsyncOp
 *	04/17/00	mjn		DNCancelSend() uses CAsyncOp
 *	04/25/00	mjn		Added DNCancelConnect()
 *	07/05/00	mjn		Added code to handle invalid async ops
 *	07/08/00	mjn		Fixed CAsyncOp to contain m_bilinkParent
 *	08/05/00	mjn		Added DNCancelChildren(),DNCancelActiveCommands(),DNCanCancelCommand()
 *				mjn		Removed DNCancelEnum(),DNCancelListen(),DNCancelSend(),DNCancelConnect()
 *	08/07/00	mjn		Added DNCancelRequestCommands()
 *	08/22/00	mjn		Remove cancelled receive buffers from the active list in DNDoCancelCommand()
 *	09/02/00	mjn		Cancel active commands in reverse order (to prevent out of order messages at protocol level)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DNCanCancelCommand
//
//	This will determine if an operation is cancelable based on the selection flags

#undef DPF_MODNAME
#define DPF_MODNAME "DNCanCancelCommand"

BOOL DNCanCancelCommand(CAsyncOp *const pAsyncOp,
						const DWORD dwFlags)
{
	BOOL	fReturnVal;

	DPF(8,"Parameters: pAsyncOp [0x%p], dwFlags [0x%lx]",pAsyncOp,dwFlags);

	DNASSERT(pAsyncOp != NULL);

	fReturnVal = FALSE;
	switch(pAsyncOp->GetOpType())
	{
		case ASYNC_OP_CONNECT:
			{
				if (dwFlags & DN_CANCEL_FLAG_CONNECT)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_DISCONNECT:
			{
				if (dwFlags & DN_CANCEL_FLAG_DISCONNECT)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_ENUM_QUERY:
			{
				if (dwFlags & DN_CANCEL_FLAG_ENUM_QUERY)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_ENUM_RESPONSE:
			{
				if (dwFlags & DN_CANCEL_FLAG_ENUM_RESPONSE)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_LISTEN:
			{
				if (dwFlags & DN_CANCEL_FLAG_LISTEN)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_SEND:
			{
				if (pAsyncOp->IsInternal())
				{
					if (dwFlags & DN_CANCEL_FLAG_INTERNAL_SEND)
					{
						fReturnVal = TRUE;
					}
				}
				else
				{
					if (dwFlags & DN_CANCEL_FLAG_USER_SEND)
					{
						fReturnVal = TRUE;
					}
				}
				break;
			}
		case ASYNC_OP_RECEIVE_BUFFER:
			{
				if (dwFlags & DN_CANCEL_FLAG_RECEIVE_BUFFER)
				{
					fReturnVal = TRUE;
				}
				break;
			}
		case ASYNC_OP_REQUEST:
			{
				break;
			}
		default:
			{
				break;
			}
	}
	DPF(8,"Returning: [%ld]",fReturnVal);
	return(fReturnVal);
}


//	DNDoCancelCommand
//
//	This will attempt to cancel a given operation based on its OpType

#undef DPF_MODNAME
#define DPF_MODNAME "DNDoCancelCommand"

HRESULT DNDoCancelCommand(DIRECTNETOBJECT *const pdnObject,
						  CAsyncOp *const pAsyncOp)
{
	HRESULT		hResultCode;

	DPF(8,"Parameters: pAsyncOp [0x%p]",pAsyncOp);

	hResultCode = DPNERR_CANNOTCANCEL;

	switch(pAsyncOp->GetOpType())
	{
		case ASYNC_OP_CONNECT:
		case ASYNC_OP_ENUM_QUERY:
		case ASYNC_OP_ENUM_RESPONSE:
		case ASYNC_OP_LISTEN:
		case ASYNC_OP_SEND:
			{
				DNASSERT(pdnObject->pdnProtocolData != NULL );

				if (pAsyncOp->GetProtocolHandle() != NULL)
				{
					DPF(9,"Attempting to cancel AsyncOp [0x%p]",pAsyncOp);
					hResultCode = DNPCancelCommand(pdnObject->pdnProtocolData,pAsyncOp->GetProtocolHandle());
					DPF(9,"Result of cancelling AsyncOp [0x%p] was [0x%lx]",pAsyncOp,hResultCode);
				}
				break;
			}
		case ASYNC_OP_RECEIVE_BUFFER:
			{
				if (pAsyncOp->GetHandle() != 0)
				{
					if ((hResultCode = pdnObject->HandleTable.Destroy( pAsyncOp->GetHandle() )) == DPN_OK)
					{
						//
						//	Remove from active list
						//
						DNEnterCriticalSection(&pdnObject->csActiveList);
						pAsyncOp->m_bilinkActiveList.RemoveFromList();
						DNLeaveCriticalSection(&pdnObject->csActiveList);
					}
					else
					{
						hResultCode = DPNERR_CANNOTCANCEL;
					}
				}
				break;
			}
//		case ASYNC_OP_DISCONNECT:
		case ASYNC_OP_REQUEST:
		default:
			{
				DNASSERT(FALSE);
				break;
			}
	}

	DPF(8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNCancelChildren
//
//	This will mark an operation as CANCELLED to prevent new children from attaching,
//	build a cancel list of any children, and recursively call itself to cancel those children.
//	At the bottom level, if there is a Protocol handle, we will actually call DNPCancelCommand() 

#undef DPF_MODNAME
#define DPF_MODNAME "DNCancelChildren"

HRESULT DNCancelChildren(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pParent)
{
	HRESULT		hResultCode;
	CBilink		*pBilink;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	**CancelList;
	DWORD		dwCount;
	DWORD		dwActual;

	DPF(6,"Parameters: pParent [0x%p]",pParent);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pParent != NULL);

	pAsyncOp = NULL;
	CancelList = NULL;

	//
	//	Mark the parent as cancelled so that no new children can attach
	//
	pParent->Lock();
	if (pParent->IsCancelled() || pParent->IsComplete())
	{
		pParent->Unlock();
		hResultCode = DPN_OK;
		goto Exit;
	}
	pParent->SetCancelled();

	//
	//	Determine size of cancel list
	//
	dwCount = 0;
	pBilink = pParent->m_bilinkParent.GetNext();
	while (pBilink != &pParent->m_bilinkParent)
	{
		pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
		pAsyncOp->Lock();
		if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
		{
			dwCount++;
		}
		pAsyncOp->Unlock();
		pBilink = pBilink->GetNext();
	}
	DPF(7,"Number of cancellable children [%ld]",dwCount);

	//
	//	Create cancel list
	//
	if (dwCount > 0)
	{
		if ((CancelList = static_cast<CAsyncOp**>(DNMalloc(dwCount * sizeof(CAsyncOp*)))) == NULL)
		{
#pragma BUGBUG( minara, "Should we unflag the cancel ?" )
			pParent->Unlock();
			DPFERR("Could not allocate space for cancel list");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		dwActual = 0;
		pBilink = pParent->m_bilinkParent.GetNext();
		while (pBilink != &pParent->m_bilinkParent)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);
			pAsyncOp->Lock();
			if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
			{
				DNASSERT(dwActual < dwCount);	// This list should NEVER grow !
				pAsyncOp->AddRef();
				CancelList[dwActual] = pAsyncOp;
				dwActual++;
			}
			pAsyncOp->Unlock();
			pBilink = pBilink->GetNext();
		}
		DPF(7,"Actual number of cancellable children [%ld]",dwActual);
	}
	pParent->Unlock();

	//
	//	Preset the return
	//
	hResultCode = DPN_OK;

	//
	//	Call ourselves with each of the children (if there are any)
	//	and clean up (release AsyncOp children and free list)
	//
	if (CancelList)
	{
		DWORD	dw;
		HRESULT	hr;

		for (dw = 0 ; dw < dwActual ; dw++ )
		{
			hr = DNCancelChildren(pdnObject,CancelList[dw]);
			if ((hr != DPN_OK) && (hResultCode == DPN_OK))
			{
				hResultCode = hr;
			}
			CancelList[dw]->Release();
			CancelList[dw] = NULL;
		}
		DNFree(CancelList);
		CancelList = NULL;
	}

	//
	//	Cancel this operation (if we can)
	//	This will only work for CONNECTs,DISCONNECTs,ENUM_QUERYs,ENUM_RESPONSEs,LISTENs,SENDs with a protocol handle
	//
	if (pParent->GetProtocolHandle() != NULL)
	{
		HRESULT	hr;

		hr = DNDoCancelCommand(pdnObject,pParent);
		if ((hr != DPN_OK) && (hResultCode == DPN_OK))
		{
			hResultCode = hr;
		}
	}

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (CancelList)
	{
		DNFree(CancelList);
		CancelList = NULL;
	}
	goto Exit;
}


//	DNCancelActiveCommands
//
//	This will attempt to cancel ALL operations in the active list.

#undef DPF_MODNAME
#define DPF_MODNAME "DNCancelActiveCommands"

HRESULT DNCancelActiveCommands(DIRECTNETOBJECT *const pdnObject,
							   const DWORD dwFlags)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	**CancelList;
	CBilink		*pBilink;
	DWORD		dwCount;
	DWORD		dwActual;

	DPF(6,"Parameters: (none) ");

	DNASSERT(pdnObject != NULL);

	CancelList = NULL;

	//
	//	Prevent changes
	//
	DNEnterCriticalSection(&pdnObject->csActiveList);

	//
	//	Determine size of cancel list
	//
	dwCount = 0;
	pBilink = pdnObject->m_bilinkActiveList.GetPrev();
	while (pBilink != &pdnObject->m_bilinkActiveList)
	{
		pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkActiveList);
		if (DNCanCancelCommand(pAsyncOp,dwFlags))
		{
			pAsyncOp->Lock();
			if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
			{
				dwCount++;
			}
			pAsyncOp->Unlock();
		}
		pBilink = pBilink->GetPrev();
	}
	DPF(7,"Number of cancellable ops [%ld]",dwCount);

	//
	//	Create cancel list
	//
	if (dwCount > 0)
	{
		if ((CancelList = static_cast<CAsyncOp**>(DNMalloc(dwCount * sizeof(CAsyncOp*)))) == NULL)
		{
			DNLeaveCriticalSection(&pdnObject->csActiveList);
			DPFERR("Could not allocate space for cancel list");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		dwActual = 0;
		pBilink = pdnObject->m_bilinkActiveList.GetPrev();
		while (pBilink != &pdnObject->m_bilinkActiveList)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkActiveList);
			if (DNCanCancelCommand(pAsyncOp,dwFlags))
			{
				pAsyncOp->Lock();
				if (!pAsyncOp->IsCancelled() && !pAsyncOp->IsComplete())
				{
					DNASSERT(dwActual < dwCount);	// This list should NEVER grow !
					pAsyncOp->AddRef();
					CancelList[dwActual] = pAsyncOp;
					dwActual++;
				}
				pAsyncOp->Unlock();
			}
			pBilink = pBilink->GetPrev();
		}
		DPF(7,"Actual number of cancellable ops [%ld]",dwActual);
	}

	//
	//	Allow changes, though the list should not grow any more here
	//
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	Preset the return
	//
	hResultCode = DPN_OK;

	//
	//	Cancel each operation in the cancel list operation (if we can)
	//	This will only work for CONNECTs,DISCONNECTs,ENUM_QUERYs,ENUM_RESPONSEs,LISTENs,SENDs with a protocol handle
	//
	if (CancelList)
	{
		DWORD	dw;
		HRESULT	hr;

		for (dw = 0 ; dw < dwActual ; dw++ )
		{
			//
			//	Ensure operation has not already been cancelled
			//
			DNASSERT( CancelList[dw] != NULL );
			CancelList[dw]->Lock();
			if (CancelList[dw]->IsCancelled() || CancelList[dw]->IsComplete())
			{
				CancelList[dw]->Unlock();
				CancelList[dw]->Release();
				CancelList[dw] = NULL;
				continue;
			}
			CancelList[dw]->SetCancelled();
			CancelList[dw]->Unlock();

			//
			//	Perform the actual cancel
			//
			hr = DNDoCancelCommand(pdnObject,CancelList[dw]);
			if ((hr != DPN_OK) && (hResultCode == DPN_OK))
			{
				hResultCode = hr;
			}
			CancelList[dw]->Release();
			CancelList[dw] = NULL;
		}
		DNFree(CancelList);
		CancelList = NULL;
	}

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (CancelList)
	{
		DNFree(CancelList);
		CancelList = NULL;
	}
	goto Exit;
}


//	DNCancelRequestCommands
//
//	This will attempt to cancel REQUEST operations in the HandleTable.
//	Requests have handles which are matched up against responses.  Since these
//	typically have SEND children (which may have completed and thus vanished),
//	there is no guarantee these are not orphaned off in the HandleTable.
//	We will look through the HandleTable for them and cancel them.

#undef DPF_MODNAME
#define DPF_MODNAME "DNCancelRequestCommands"

HRESULT DNCancelRequestCommands(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	DPNHANDLE	*HandleList;
	DWORD		dwCount;
	DWORD		dw;

	DPF(6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	pAsyncOp = NULL;
	HandleList = NULL;

	//
	//	Determine size of handle list
	//
	dwCount = 0;
	if ((hResultCode = pdnObject->HandleTable.Enum(NULL,&dwCount)) != DPNERR_BUFFERTOOSMALL)
	{
		DPFERR("Could not find any entries in the HandleTable");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	DPF(7,"Number of handles [%ld]",dwCount);

	//
	//	Create handle list
	//
	if ((HandleList = static_cast<DPNHANDLE*>(DNMalloc(dwCount * sizeof(DPNHANDLE)))) == NULL)
	{
		DPFERR("Could not allocate HandleList");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	if ((hResultCode = pdnObject->HandleTable.Enum(HandleList,&dwCount)) != DPN_OK)
	{
		DPFERR("Could not enum handles");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Remove non-REQUEST operations as these might vanish later
	//
	for ( dw = 0 ; dw < dwCount ; dw++ )
	{
		if ((hResultCode = pdnObject->HandleTable.Find(HandleList[dw],&pAsyncOp)) != DPN_OK)
		{
			HandleList[dw] = 0;
			continue;
		}
		if (pAsyncOp->GetOpType() != ASYNC_OP_REQUEST)
		{
			HandleList[dw] = 0;
		}
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}

	//
	//	Cancel REQUEST operations and remove from HandleTable
	//
	for ( dw = 0 ; dw < dwCount ; dw++ )
	{
		if (HandleList[dw] == 0)
		{
			continue;
		}
		if ((hResultCode = pdnObject->HandleTable.Find(HandleList[dw],&pAsyncOp)) != DPN_OK)
		{
			continue;
		}
		if (pAsyncOp->GetOpType() == ASYNC_OP_REQUEST)
		{
			pAsyncOp->Lock();
			pAsyncOp->SetResult( DPNERR_USERCANCEL );
			pAsyncOp->Unlock();
			pdnObject->HandleTable.Destroy( HandleList[dw] );
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}
	}

	DNFree(HandleList);
	HandleList = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (HandleList != NULL)
	{
		DNFree(HandleList);
		HandleList = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\async.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       async.h
 *  Content:    Asynchronous Operations Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/28/99	mjn		Created
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	01/14/00	mjn		Added pvUserContext to DN_PerformListen
 *	01/14/00	mjn		Changed DN_COUNT_BUFFER to CRefCountBuffer
 *	01/17/00	mjn		Added dwStartTime to async op structure
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/21/00	mjn		Added DNProcessInternalOperation
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *	03/23/00	mjn		Added phrSync and pvInternal
 *	03/24/00	mjn		Add guidSP to DN_ASYNC_OP
 *	04/04/00	mjn		Added DNProcessTerminateSession()
 *	04/10/00	mjn		Use CAsyncOp for CONNECTs, LISTENs and DISCONNECTs
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	04/17/00	mjn		Added DNCompleteAsyncHandle
 *	04/21/00	mjn		Added DNPerformDisconnect
 *	04/23/00	mjn		Optionally return child AsyncOp in DNPerformChildSend()
 *	04/24/00	mjn		Added DNCreateUserHandle()
 *	06/24/00	mjn		Added DNCompleteConnectToHost() and DNCompleteUserConnect()
 *	07/02/00	mjn		Added DNSendGroupMessage() and DN_GROUP_SEND_OP
 *	07/10/00	mjn		Added DNPerformEnumQuery()
 *	07/11/00	mjn		Added fNoLoopBack to DNSendGroupMessage()
 *				mjn		Added DNPerformNextEnumQuery(),DNPerformSPListen(),DNPerformNextListen(),DNEnumAdapterGuids(),DNPerformNextConnect
 *				mjn		Added DN_LISTEN_OP_DATA,DN_CONNECT_OP_DATA
 *	07/20/00	mjn		Added DNCompleteConnectOperation() and DNCompleteSendConnectInfo()
 *				mjn		Modified DNPerformDisconnect()
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Added fInternal to DNPerformChildSend()
 *				mjn		Removed DN_TerminateAllListens()
 *				mjn		Added DNCompleteRequest()
 *	09/23/00	mjn		Added CSyncEvent to DN_LISTEN_OP_DATA
 *	10/04/00	mjn		Added dwCompleteAdapters to DN_LISTEN_OP_DATA
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ASYNC_H__
#define	__ASYNC_H__


//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_ASYNC_OP_SIG							0xdece0003

#define	DN_ASYNC_OP_FLAG_MULTI_OP				0x0001
#define DN_ASYNC_OP_FLAG_MULTI_OP_PARENT		0x0002
#define	DN_ASYNC_OP_FLAG_SYNCHRONOUS_OP			0x0010
#define	DN_ASYNC_OP_FLAG_NO_COMPLETION			0x0100
#define	DN_ASYNC_OP_FLAG_RELEASE_SP				0x1000

//
// Enumerated values for buffer descriptions.  The value DN_ASYNC_BUFFERDESC_COUNT
// must be large enough to contain account for BUFFERDESC structres possibly
// passed with this async operation
//
#define	DN_ASYNC_BUFFERDESC_HEADER				0
#define	DN_ASYNC_BUFFERDESC_DATA				1
#define	DN_ASYNC_BUFFERDESC_COUNT				3

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#pragma pack( push, 1 )

typedef struct _DN_SEND_OP_DATA
{
	DWORD			dwMsgId;
	DPN_BUFFER_DESC	BufferDesc[2];
	DWORD			dwNumBuffers;
	DWORD			dwNumOutstanding;
} DN_SEND_OP_DATA;

#pragma pack( pop )


typedef struct _DN_GROUP_SEND_OP
{
	CConnection					*pConnection;
	struct _DN_GROUP_SEND_OP	*pNext;
} DN_GROUP_SEND_OP;


typedef struct _DN_LISTEN_OP_DATA
{
	DWORD		dwNumAdapters;
	DWORD		dwCurrentAdapter;
	DWORD		dwCompleteAdapters;
	CSyncEvent	*pSyncEvent;
} DN_LISTEN_OP_DATA;


typedef struct _DN_CONNECT_OP_DATA
{
	DWORD			dwNumAdapters;
	DWORD			dwCurrentAdapter;
} DN_CONNECT_OP_DATA;

class CAsyncOp;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNCreateUserHandle(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp **const ppAsyncOp);

HRESULT DNEnumAdapterGuids(DIRECTNETOBJECT *const pdnObject,
						   GUID *const pguidSP,
						   const DWORD dwEnumBufferMinimumSize,
						   void **const ppvEnumBuffer,
						   DWORD *const pdwNumAdapters);

HRESULT DNPerformSPListen(DIRECTNETOBJECT *const pdnObject,
						  IDirectPlay8Address *const pDeviceAddr,
						  CAsyncOp *const pListenParent,
						  CAsyncOp **const ppParent);

HRESULT DNPerformListen(DIRECTNETOBJECT *const pdnObject,
						IDirectPlay8Address *const pDeviceInfo,
						CAsyncOp *const pParent);

HRESULT DNPerformNextListen(DIRECTNETOBJECT *const pdnObject,
							CAsyncOp *const pAsyncOp,
							IDirectPlay8Address *const pDeviceAddr);

void DNCompleteListen(DIRECTNETOBJECT *const pdnObject,
					  CAsyncOp *const pAsyncOp);
/*	REMOVE
HRESULT DN_TerminateAllListens(DIRECTNETOBJECT *const pdnObject);
*/

HRESULT DNPerformEnumQuery(DIRECTNETOBJECT *const pdnObject,
						   IDirectPlay8Address *const pHost,
						   IDirectPlay8Address *const pDevice,
						   const HANDLE hSPHandle,
						   DPN_BUFFER_DESC *const rgdnBufferDesc,
						   const DWORD cBufferDesc,
						   const DWORD dwRetryCount,
						   const DWORD dwRetryInterval,
						   const DWORD dwTimeOut,
						   const DWORD dwFlags,
						   void *const pvContext,
						   CAsyncOp *const pParent);

HRESULT DNPerformNextEnumQuery(DIRECTNETOBJECT *const pdnObject,
							   CAsyncOp *const pAsyncOp,
							   IDirectPlay8Address *const pHostAddr,
							   IDirectPlay8Address *const pDeviceAddr);

void DNCompleteEnumQuery(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pAsyncOp);

void DNCompleteEnumResponse(DIRECTNETOBJECT *const pdnObject,
							CAsyncOp *const pAsyncOp);

HRESULT DNPerformConnect(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 IDirectPlay8Address *const pDeviceInfo,
						 IDirectPlay8Address *const pRemoteAddr,
						 const DWORD dwConnectFlags,
						 CAsyncOp *const pParent);

HRESULT DNPerformNextConnect(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp,
							 IDirectPlay8Address *const pHostAddr,
							 IDirectPlay8Address *const pDeviceAddr);

void DNCompleteConnect(DIRECTNETOBJECT *const pdnObject,
					   CAsyncOp *const pAsyncOp);

void DNCompleteConnectToHost(DIRECTNETOBJECT *const pdnObject,
							 CAsyncOp *const pAsyncOp);

void DNCompleteConnectOperation(DIRECTNETOBJECT *const pdnObject,
								CAsyncOp *const pAsyncOp);

void DNCompleteUserConnect(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp);

void DNCompleteSendConnectInfo(DIRECTNETOBJECT *const pdnObject,
							   CAsyncOp *const pAsyncOp);

HRESULT DNPerformDisconnect(DIRECTNETOBJECT *const pdnObject,
							CConnection *const pConnection,
							const HANDLE hEndPt);

void DNCompleteAsyncHandle(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp);

void DNCompleteSendHandle(DIRECTNETOBJECT *const pdnObject,
						  CAsyncOp *const pAsyncOp);

void DNCompleteSendAsyncOp(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp);

void DNCompleteRequest(DIRECTNETOBJECT *const pdnObject,
					   CAsyncOp *const pAsyncOp);

void DNCompleteSendRequest(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp);

HRESULT DNSendMessage(DIRECTNETOBJECT *const pdnObject,
					  CConnection *const pConnection,
					  const DWORD dwMsgId,
					  const DPNID dpnidTarget,
					  const DPN_BUFFER_DESC *const pdnBufferDesc,
					  CRefCountBuffer *const pRefCountBuffer,
					  const DWORD dwTimeOut,
					  const DWORD dwSendFlags,
					  CAsyncOp *const pParent,
					  CAsyncOp **const ppAsyncOp);

HRESULT DNSendGroupMessage(DIRECTNETOBJECT *const pdnObject,
						   CNameTableEntry *const pGroup,
						   const DWORD dwMsgId,
						   const DPN_BUFFER_DESC *const pdnBufferDesc,
						   CRefCountBuffer *const pRefCountBuffer,
						   const DWORD dwTimeOut,
						   const DWORD dwSendFlags,
						   const BOOL fNoLoopBack,
						   const BOOL fRequest,
						   CAsyncOp *const pParent,
						   CAsyncOp **const ppParent);

HRESULT DNPerformMultiSend(DIRECTNETOBJECT *const pdnObject,
						   const DPNHANDLE hParentOp,
						   CConnection *const pConnection,
						   const DWORD dwTimeOut);

HRESULT DNCreateSendParent(DIRECTNETOBJECT *const pdnObject,
						   const DWORD dwMsgId,
						   const DPN_BUFFER_DESC *const pdnBufferDesc,
						   const DWORD dwSendFlags,
						   CAsyncOp **const ppParent);

HRESULT DNPerformChildSend(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pParent,
						   CConnection *const pConnection,
						   const DWORD dwTimeOut,
						   CAsyncOp **const ppChild,
						   const BOOL fInternal);

HRESULT DNFinishMultiOp(DIRECTNETOBJECT *const pdnObject,const DPNHANDLE hRootOp);

HRESULT DNProcessInternalOperation(DIRECTNETOBJECT *const pdnObject,
								   const DWORD dwMsgId,
								   void *const pOpBuffer,
								   const DWORD dwOpBufferSize,
								   CConnection *const pConnection,
								   const HANDLE hProtocol,
								   CRefCountBuffer *const pRefCountBuffer);

HRESULT DNPerformRequest(DIRECTNETOBJECT *const pdnObject,
						 const DWORD dwMsgId,
						 const DPN_BUFFER_DESC *const pBufferDesc,
						 CConnection *const pConnection,
						 CAsyncOp *const pParent,
						 CAsyncOp **const ppRequest);

HRESULT DNReceiveCompleteOnProcess(DIRECTNETOBJECT *const pdnObject,
								   CConnection *const pConnection,
								   void *const pBufferData,
								   const DWORD dwBufferSize,
								   const HANDLE hProtocol,
								   CRefCountBuffer *const pOrigRefCountBuffer);

HRESULT DNReceiveCompleteOnProcessReply(DIRECTNETOBJECT *const pdnObject,
										void *const pBufferData,
										const DWORD dwBufferSize);

HRESULT DNProcessTerminateSession(DIRECTNETOBJECT *const pdnObject,
								  void *const pvBuffer,
								  const DWORD dwBufferSize);

//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __ASYNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\appdesc.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AppDesc.h
 *  Content:    Application Description Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/02/00	mjn		Created
 *	09/05/00	mjn		Added GetDPNIDMask()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__APPDESC_H__
#define	__APPDESC_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_APPDESCINFO_FLAG_SESSIONNAME		0x0001
#define DN_APPDESCINFO_FLAG_PASSWORD		0x0002
#define	DN_APPDESCINFO_FLAG_RESERVEDDATA	0x0004
#define DN_APPDESCINFO_FLAG_APPRESERVEDDATA	0x0008
#define	DN_APPDESCINFO_FLAG_CURRENTPLAYERS	0x0010

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT	DNProcessUpdateAppDesc(DIRECTNETOBJECT *const pdnObject,
							   DPN_APPLICATION_DESC_INFO *const pv);

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Application Description

class CApplicationDesc
{
	STDNEWDELETE

public:
	CApplicationDesc()		// Constructor
		{
			m_Sig[0] = 'A';
			m_Sig[1] = 'P';
			m_Sig[2] = 'P';
			m_Sig[3] = 'D';
		};

	~CApplicationDesc()		// Destructor
		{
		};

	HRESULT CApplicationDesc::Initialize( void );

	void CApplicationDesc::Deinitialize( void );

	void Lock( void )
		{
			DNEnterCriticalSection( &m_cs );
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection( &m_cs );
		};

	HRESULT	CApplicationDesc::Pack(CPackedBuffer *const pPackedBuffer,
								   const DWORD dwFlags);

	HRESULT CApplicationDesc::PackInfo(CPackedBuffer *const pPackedBuffer,
									   const DWORD dwFlags);

	HRESULT CApplicationDesc::UnpackInfo(DPN_APPLICATION_DESC_INFO *const pdnAppDescInfo,
										 void *const pBufferStart,
										 const DWORD dwFlags);

	HRESULT CApplicationDesc::Update(const DPN_APPLICATION_DESC *const pdnAppDesc,
									 const DWORD dwFlags);

	HRESULT	CApplicationDesc::CreateNewInstanceGuid( void );

	HRESULT	CApplicationDesc::IncPlayerCount(const BOOL fCheckLimit);

	void CApplicationDesc::DecPlayerCount( void );

	DWORD GetMaxPlayers( void )
		{
			return( m_dwMaxPlayers );
		};

	DWORD GetCurrentPlayers( void )
		{
			return( m_dwCurrentPlayers );
		};

	WCHAR *GetPassword( void )
		{
			return( m_pwszPassword );
		};

	GUID *GetInstanceGuid( void )
		{
			return( &m_guidInstance );
		};

	GUID *GetApplicationGuid( void )
		{
			return( &m_guidApplication );
		};

	BOOL IsClientServer( void )
		{
			if (m_dwFlags & DPNSESSION_CLIENT_SERVER)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	BOOL AllowHostMigrate( void )
		{
			if (m_dwFlags & DPNSESSION_MIGRATE_HOST)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	BOOL RequirePassword( void )
		{
			if (m_dwFlags & DPNSESSION_REQUIREPASSWORD)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CApplicationDesc::IsEqualInstanceGuid"
	BOOL IsEqualInstanceGuid( const GUID *const pguidInstance )
		{
			DNASSERT( pguidInstance != NULL );

			if (!memcmp(&m_guidInstance,pguidInstance,sizeof(GUID)))
			{
				return( TRUE );
			}
			return( FALSE );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CApplicationDesc::IsEqualApplicationGuid"
	BOOL IsEqualApplicationGuid( const GUID *const pguidApplication )
		{
			DNASSERT( pguidApplication != NULL );

			if (!memcmp(&m_guidApplication,pguidApplication,sizeof(GUID)))
			{
				return( TRUE );
			}
			return( FALSE );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CApplicationDesc::IsEqualPassword"
	BOOL IsEqualPassword( const WCHAR *const pwszPassword )
		{
			if ((pwszPassword == NULL) && (m_pwszPassword == NULL))
			{
				return(TRUE);
			}
			if ((pwszPassword == NULL) || (m_pwszPassword == NULL))
			{
				return(FALSE);
			}
			DNASSERT( pwszPassword != NULL );
			DNASSERT( m_pwszPassword != NULL);
			if (!wcscmp(m_pwszPassword,pwszPassword))
			{
				return( TRUE );
			}
			return( FALSE );
		};

	DPNID GetDPNIDMask( void )
		{
			DPNID	*pdpnid;

			pdpnid = reinterpret_cast<DPNID*>(&m_guidInstance);
			return( *pdpnid );
		};

private:
	BYTE		m_Sig[4];

	DWORD		m_dwFlags;

	DWORD		m_dwMaxPlayers;
	DWORD		m_dwCurrentPlayers;

	WCHAR		*m_pwszSessionName;
	DWORD		m_dwSessionNameSize;	// in bytes

	WCHAR		*m_pwszPassword;
	DWORD		m_dwPasswordSize;		// in bytes

	void		*m_pvReservedData;
	DWORD		m_dwReservedDataSize;

	void		*m_pvApplicationReservedData;
	DWORD		m_dwApplicationReservedDataSize;

	GUID		m_guidInstance;
	GUID		m_guidApplication;

	DNCRITICAL_SECTION		m_cs;
};

#undef DPF_MODNAME

#endif	// __APPDESC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\asyncop.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       AsyncOp.h
 *  Content:    Async Operation Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/08/00	mjn		Created
 *	04/11/00	mjn		Added DIRECTNETOBJECT bilink for CAsyncOps
 *	04/16/00	mjn		Added ASYNC_OP_SEND and ASYNC_OP_USER_HANDLE
 *				mjn		Added SetStartTime() and GetStartTime()
 *	04/20/00	mjn		Added ASYNC_OP_RECEIVE_BUFFER
 *	04/22/00	mjn		Added ASYNC_OP_REQUEST
 *	05/02/00	mjn		Added m_pConnection to track Connection over life of AsyncOp
 *	07/08/00	mjn		Added m_bilinkParent
 *	07/17/00	mjn		Added signature to CAsyncOp
 *	07/27/00	mjn		Added m_dwReserved and changed locking for parent/child bilinks
 *	08/05/00	mjn		Added ASYNC_OP_COMPLETE,ASYNC_OP_CANCELLED,ASYNC_OP_INTERNAL flags
 *				mjn		Added m_bilinkActiveList
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ASYNC_OP_H__
#define	__ASYNC_OP_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

class CServiceProvider;

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	ASYNC_OP_CHILD			0x0001
#define	ASYNC_OP_PARENT			0x0002
#define	ASYNC_OP_COMPLETE		0x0100
#define	ASYNC_OP_CANCELLED		0x0200
#define	ASYNC_OP_INTERNAL		0x8000

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

class CAsyncOp;
template< class CAsyncOp > class CLockedContextClassFixedPool;

typedef enum
{
	ASYNC_OP_CONNECT,
	ASYNC_OP_DISCONNECT,
	ASYNC_OP_ENUM_QUERY,
	ASYNC_OP_ENUM_RESPONSE,
	ASYNC_OP_LISTEN,
	ASYNC_OP_SEND,
	ASYNC_OP_RECEIVE_BUFFER,
	ASYNC_OP_REQUEST,
	ASYNC_OP_UNKNOWN,
	ASYNC_OP_USER_HANDLE
} ASYNC_OP_TYPE;

typedef void (*PFNASYNCOP_COMPLETE)(DIRECTNETOBJECT *const,CAsyncOp *const);

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Async Operations

class CAsyncOp
{
	STDNEWDELETE

public:
	CAsyncOp()					// Constructor
		{
			m_Sig[0] = 'A';
			m_Sig[1] = 'S';
			m_Sig[2] = 'Y';
			m_Sig[3] = 'N';

			m_dwReserved = 0;
		};

	~CAsyncOp() { };			// Destructor

	BOOL FPMAlloc(void *const pvContext)
		{
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			if (!DNInitializeCriticalSection(&m_cs))
			{
				return(FALSE);
			}

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAsyncOp::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);
			m_dwFlags = 0;
			m_lRefCount = 1;

			m_OpType = ASYNC_OP_UNKNOWN;

			m_pParent = NULL;

			m_handle = 0;
			m_dwOpFlags = 0;
			m_pvContext = NULL;
			m_hProtocol = NULL;
			m_pvOpData = NULL;

			m_dwStartTime = 0;
			m_dpnid = 0;

			m_hr = DPNERR_GENERIC;
			m_phr = NULL;

			m_pConnection = NULL;
			m_pSP = NULL;
			m_pRefCountBuffer = NULL;
			m_pSyncEvent = NULL;
			m_pfnCompletion = NULL;

//			m_dwReserved = 0;

			m_bilinkAsyncOps.Initialize();
			m_bilinkActiveList.Initialize();
			m_bilinkParent.Initialize();
			m_bilinkChildren.Initialize();

			return(TRUE);
		};

	void FPMRelease(void *const pvContext)
		{
			m_dwFlags |= 0xffff0000;
		};

	void FPMDealloc(void *const pvContext)
		{
			DNDeleteCriticalSection(&m_cs);
		};

	void ReturnSelfToPool( void );

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAsyncOp::AddRef"
	void AddRef(void)
		{
			LONG	lRefCount;

			DNASSERT(m_lRefCount > 0);
			lRefCount = InterlockedIncrement(const_cast<LONG*>(&m_lRefCount));
			DPF(3,"CAsyncOp::AddRef [0x%lx] RefCount [0x%lx]",this,lRefCount);
		};

	void CAsyncOp::Release( void );

	void Lock( void )
		{
			DNEnterCriticalSection( &m_cs );
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection( &m_cs );
		};

	void SetOpType( const ASYNC_OP_TYPE OpType )
		{
			m_OpType = OpType;
		};

	ASYNC_OP_TYPE GetOpType( void )
		{
			return( m_OpType );
		};

	void MakeParent( void )
		{
			m_dwFlags |= ASYNC_OP_PARENT;
		};

	BOOL IsParent( void )
		{
			if (m_dwFlags & ASYNC_OP_PARENT)
				return(TRUE);

			return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CAsyncOp::MakeChild"
	void MakeChild( CAsyncOp *const pParent )
		{
			DNASSERT(pParent != NULL);

			pParent->AddRef();
			m_pParent = pParent;

			m_bilinkChildren.InsertBefore(&m_pParent->m_bilinkParent);

			m_dwFlags |= ASYNC_OP_CHILD;
		};

	BOOL IsChild( void )
		{
			if (m_dwFlags & ASYNC_OP_CHILD)
				return(TRUE);

			return(FALSE);
		};

	CAsyncOp *GetParent( void )
		{
			return( m_pParent );
		};

	void CAsyncOp::Orphan( void );

	void SetHandle( const DPNHANDLE handle )
		{
			m_handle = handle;
		};

	DPNHANDLE GetHandle( void )
		{
			return( m_handle );
		};

	void SetOpFlags( const DWORD dwOpFlags )
		{
			m_dwOpFlags = dwOpFlags;
		};

	DWORD GetOpFlags( void )
		{
			return( m_dwOpFlags );
		};

	void SetContext( void *const pvContext )
		{
			m_pvContext = pvContext;
		};

	void *GetContext( void )
		{
			return( m_pvContext );
		};

	void SetProtocolHandle( const HANDLE hProtocol )
		{
			m_hProtocol = hProtocol;
		};

	HANDLE GetProtocolHandle( void )
		{
			return( m_hProtocol );
		};

	void SetOpData( void *const pvOpData )
		{
			m_pvOpData = pvOpData;
		};

	void *GetOpData( void )
		{
			return( m_pvOpData );
		};

	void SetStartTime( const DWORD dwStartTime )
		{
			m_dwStartTime = dwStartTime;
		};

	DWORD GetStartTime( void )
		{
			return( m_dwStartTime );
		};

	void SetDPNID( const DPNID dpnid )
		{
			m_dpnid = dpnid;
		};

	DPNID GetDPNID( void )
		{
			return( m_dpnid );
		};

	void SetResult( const HRESULT hr )
		{
			m_hr = hr;
		};

	HRESULT GetResult( void )
		{
			return( m_hr );
		};

	void SetResultPointer( volatile HRESULT *const phr )
		{
			m_phr = phr;
		};

	volatile HRESULT *GetResultPointer( void )
		{
			return( m_phr );
		};

	void CAsyncOp::SetConnection( CConnection *const pConnection );

	CConnection *GetConnection (void )
		{
			return( m_pConnection );
		};

	void CAsyncOp::SetSP( CServiceProvider *const pSP );

	CServiceProvider *GetSP( void )
		{
			return( m_pSP );
		};

	void CAsyncOp::SetRefCountBuffer( CRefCountBuffer *const pRefCountBuffer );

	CRefCountBuffer *GetRefCountBuffer( void )
		{
			return( m_pRefCountBuffer );
		};

	void SetSyncEvent( CSyncEvent *const pSyncEvent )
		{
			m_pSyncEvent = pSyncEvent;
		};

	CSyncEvent *GetSyncEvent( void )
		{
			return( m_pSyncEvent );
		};

	void SetCompletion( PFNASYNCOP_COMPLETE pfn )
		{
			m_pfnCompletion = pfn;
		};

	void SetReserved( const DWORD dw )
		{
			m_dwReserved = dw;
		};

	void SetComplete( void )
		{
			m_dwFlags |= ASYNC_OP_COMPLETE;
		};

	BOOL IsComplete( void )
		{
			if (m_dwFlags & ASYNC_OP_COMPLETE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetCancelled( void )
		{
			m_dwFlags |= ASYNC_OP_CANCELLED;
		};

	BOOL IsCancelled( void )
		{
			if (m_dwFlags & ASYNC_OP_CANCELLED)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetInternal( void )
		{
			m_dwFlags |= ASYNC_OP_INTERNAL;
		};

	BOOL IsInternal( void )
		{
			if (m_dwFlags & ASYNC_OP_INTERNAL)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	CBilink				m_bilinkAsyncOps;
	CBilink				m_bilinkActiveList;	// Active AsyncOps
	CBilink				m_bilinkParent;		// Starting point for children
	CBilink				m_bilinkChildren;	// Other children sharing this parent

private:
	BYTE				m_Sig[4];			// Signature
	DWORD	volatile	m_dwFlags;
	LONG	volatile	m_lRefCount;

	ASYNC_OP_TYPE		m_OpType;			// Operation Type

	CAsyncOp			*m_pParent;			// Parent Async Operation

	DPNHANDLE			m_handle;			// Async Operation Handle
	DWORD				m_dwOpFlags;
	PVOID				m_pvContext;
	HANDLE				m_hProtocol;		// Protocol Operation Handle
	PVOID				m_pvOpData;			// Operation specific data

	DWORD				m_dwStartTime;
	DPNID				m_dpnid;

	HRESULT	volatile	m_hr;
	volatile HRESULT	*m_phr;

	CConnection			*m_pConnection;		// Send Target connection - released

	CServiceProvider	*m_pSP;				// Service Provider - released

	CRefCountBuffer		*m_pRefCountBuffer;	// Refernce Count Buffer - released

	CSyncEvent			*m_pSyncEvent;		// Sync Event - set at release

	PFNASYNCOP_COMPLETE	m_pfnCompletion;	// Completion function - called

	DNCRITICAL_SECTION	m_cs;

	DIRECTNETOBJECT		*m_pdnObject;

	DWORD				m_dwReserved;		// INTERNAL - RESERVED FOR DEBUG !
};

#undef DPF_MODNAME

#endif	// __ASYNC_OP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\caps.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Caps.h
 *  Content:    DirectPlay8 Caps routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	03/17/00	rmt		Created
 *  03/25/00    rmt     Changed Get/SetActualSPCaps so takes interface instead of obj
 *	08/20/00	mjn		DNSetActualSPCaps() uses CServiceProvider object instead of GUID
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CAPS_H__
#define	__CAPS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

class CServiceProvider;

typedef struct _DN_SP_CAPS_ENTRY {
    GUID        guidSP;
    DPN_SP_CAPS dpnCaps;
    CBilink      blList;
} DN_SP_CAPS_ENTRY, *PDN_SP_CAPS_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DN_InitSPCapsList( DIRECTNETOBJECT *pdnObject );
HRESULT DN_FreeSPCapsList( DIRECTNETOBJECT *pdnObject );

HRESULT DNGetCachedSPCaps( DIRECTNETOBJECT *pdnObject, const GUID * const guidProvider, PDPN_SP_CAPS *ppCaps );
HRESULT DNSetCachedSPCaps( DIRECTNETOBJECT *pdnObject, const GUID * const guidProvider, const DPN_SP_CAPS * const pCaps );
HRESULT DNSetActualSPCaps( DIRECTNETOBJECT *pdnObject, CServiceProvider *const pSP, const DPN_SP_CAPS * const pCaps );
HRESULT DNGetActualSPCaps( DIRECTNETOBJECT *pdnObject, const GUID * const pguidSP, PDPN_SP_CAPS pCaps );


#endif	// __CONNECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\cancel.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Connect.h
 *  Content:    DirectNet Cancel Operation Header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	04/07/00	mjn		Created
 *	04/08/00	mjn		Added DNCancelEnum(), DNCancelSend()
 *	04/11/00	mjn		DNCancelEnum() uses CAsyncOp
 *	04/17/00	mjn		DNCancelSend() uses CAsyncOp
 *	04/25/00	mjn		Added DNCancelConnect()
 *	08/05/00	mjn		Added DNCancelChildren(),DNCancelActiveCommands(),DNCanCancelCommand()
 *				mjn		Added DN_CANCEL_FLAG's
 *				mjn		Removed DNCancelEnum(),DNCancelListen(),DNCancelSend(),DNCancelConnect()
 *	08/07/00	mjn		Added DNCancelRequestCommands()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CANCEL_H__
#define	__CANCEL_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_CANCEL_FLAG_CONNECT			0x0001
#define	DN_CANCEL_FLAG_DISCONNECT		0x0002
#define	DN_CANCEL_FLAG_ENUM_QUERY		0x0004
#define	DN_CANCEL_FLAG_ENUM_RESPONSE	0x0008
#define	DN_CANCEL_FLAG_LISTEN			0x0010
#define	DN_CANCEL_FLAG_USER_SEND		0x0020
#define	DN_CANCEL_FLAG_INTERNAL_SEND	0x0040
#define	DN_CANCEL_FLAG_RECEIVE_BUFFER	0x0080
#define	DN_CANCEL_FLAG_REQUEST			0x0100

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL DNCanCancelCommand(CAsyncOp *const pAsyncOp,
						const DWORD dwFlags);

HRESULT DNDoCancelCommand(DIRECTNETOBJECT *const pdnObject,
						  CAsyncOp *const pAsyncOp);

HRESULT DNCancelChildren(DIRECTNETOBJECT *const pdnObject,
						 CAsyncOp *const pParent);

HRESULT DNCancelActiveCommands(DIRECTNETOBJECT *const pdnObject,
							   const DWORD dwFlags);

HRESULT DNCancelRequestCommands(DIRECTNETOBJECT *const pdnObject);

//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __CANCEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\classfac.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.cpp
 *  Content:    DNET COM class factory
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	12/23/99	mjn		Fixed Host and AllPlayers short-cut pointer use
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/08/00	mjn		Fixed DN_APPLICATION_DESC in DIRECTNETOBJECT
 *	01/13/00	mjn		Added CFixedPools and CRefCountBuffers
 *	01/14/00	mjn		Removed pvUserContext from DN_NAMETABLE_ENTRY
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Removed User message fixed pool
 *  01/18/00	mjn		Fixed bug in ref count.
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/19/00	mjn		Initialize structures for NameTable Operation List
 *	01/25/00	mjn		Added NameTable pending operation list
 *	01/31/00	mjn		Added Internal FPM's for RefCountBuffers
 *  03/17/00    rmt     Added calls to init/free SP Caps cache
 *	03/23/00	mjn		Implemented RegisterLobby()
 *  04/04/00	rmt		Enabled "Enable Parameter Validation" flag on object by default
 *	04/09/00	mjn		Added support for CAsyncOp
 *	04/11/00	mjn		Added DIRECTNETOBJECT bilink for CAsyncOps
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	04/28/00	mjn		Code cleanup - removed hsAsyncHandles,blAsyncOperations
 *	05/04/00	mjn		Cleaned up and made multi-thread safe
 *  05/23/00    RichGr  IA64: Substituted %p format specifier whereever
 *                      %x was being used to format pointers.  %p is 32-bit
 *                      in a 32-bit build, and 64-bit in a 64-bit build.
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs
 *	06/20/00	mjn		Fixed QueryInterface bug
 *  06/27/00	rmt		Fixed bug which was causing interfaces to always be created as peer interfaces
 *  07/05/00	rmt		Bug #38478 - Could QI for peer interfaces from client object
 *						(All interfaces could be queried from all types of objects).
 *				mjn		Initialize pConnect element of DIRECNETOBJECT to NULL
 *	07/07/00	mjn		Added pNewHost for DirectNetObject
 *	07/08/00	mjn		Call DN_Close when object is about to be free'd
 *  07/09/00	rmt		Added code to free interface set by RegisterLobby (if there is one)
 *	07/17/00	mjn		Add signature to DirectNetObject
 *  07/21/00    RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *	07/26/00	mjn		DN_QueryInterface returns E_POINTER if NULL destination pointer specified
 *	07/28/00	mjn		Added m_bilinkConnections to DirectNetObject
 *	07/30/00	mjn		Added CPendingDeletion
 *	07/31/00	mjn		Added CQueuedMsg
 *	08/05/00	mjn		Added m_bilinkActiveList and csActiveList
 *	08/06/00	mjn		Added CWorkerJob
 *	08/23/00	mjn		Added CNameTableOp
 *	09/04/00	mjn		Added CApplicationDesc
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef	STDMETHODIMP IUnknownQueryInterface( IUnknown *pInterface, REFIID riid, LPVOID *ppvObj );
typedef	STDMETHODIMP_(ULONG)	IUnknownAddRef( IUnknown *pInterface );
typedef	STDMETHODIMP_(ULONG)	IUnknownRelease( IUnknown *pInterface );

//
// VTable for IUnknown interface
//
IUnknownVtbl  DN_UnknownVtbl =
{
	(IUnknownQueryInterface*)	DN_QueryInterface,
	(IUnknownAddRef*)			DN_AddRef,
	(IUnknownRelease*)			DN_Release
};


//**********************************************************************
// Variable definitions
//**********************************************************************

//
// Globals
//
extern	DWORD	GdwHLocks;
extern	DWORD	GdwHObjects;


//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "DN_CreateInterface"

static	HRESULT DN_CreateInterface(OBJECT_DATA *pObject,
								   REFIID riid,
								   INTERFACE_LIST **const ppv)
{
	INTERFACE_LIST	*pIntNew;
	PVOID			lpVtbl;
	HRESULT			hResultCode;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF(6,"Parameters: pObject [%p], ppv [%p]",pObject,ppv);

	DNASSERT(pObject != NULL);
	DNASSERT(ppv != NULL);

    DIRECTNETOBJECT *pdnObject = ((DIRECTNETOBJECT *)pObject->pvData);

		DPF(7,"riid = IID_IDirectPlay8Protocol");
		lpVtbl = &DN_ProtocolVtbl;

	if ((pIntNew = static_cast<INTERFACE_LIST*>(DNMalloc(sizeof(INTERFACE_LIST)))) == NULL)
	{
		DPFERR("Could not allocate interface");
		hResultCode = E_OUTOFMEMORY;
		goto Exit;
	}
	pIntNew->lpVtbl = lpVtbl;
	pIntNew->lRefCount = 0;
	pIntNew->pIntNext = NULL;
	pIntNew->pObject = pObject;

	*ppv = pIntNew;
    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF(7,"*ppv = [0x%p]",*ppv);

	hResultCode = S_OK;

Exit:
    DPF(6,"Returning: hResultCode = [%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_FindInterface"

INTERFACE_LIST *DN_FindInterface(void *pInterface,
								 REFIID riid)
{
	INTERFACE_LIST	*pIntList;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF(6,"Parameters: pInterface [%p]",pInterface);

	DNASSERT(pInterface != NULL);

	pIntList = (static_cast<INTERFACE_LIST*>(pInterface))->pObject->pIntList;	// Find first interface

	while (pIntList != NULL)
	{
			break;
	}

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF(6,"Returning: pIntList [0x%p]",pIntList);
	return(pIntList);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_QueryInterface"

STDMETHODIMP DN_QueryInterface(void *pInterface,
							   REFIID riid,
							   void **ppv)
{
	INTERFACE_LIST	*pIntList;
	INTERFACE_LIST	*pIntNew;
	HRESULT			hResultCode;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF(2,"Parameters: pInterface [0x%p], ppv [0x%p]",pInterface,ppv);

	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		hResultCode = E_INVALIDARG;
		goto Exit;
	}
	if (ppv == NULL)
	{
		DPFERR("Invalid target interface pointer specified");
		hResultCode = E_POINTER;
		goto Exit;
	}

	if ((pIntList = DN_FindInterface(pInterface,riid)) == NULL)
	{	// Interface must be created
		pIntList = (static_cast<INTERFACE_LIST*>(pInterface))->pObject->pIntList;
		if ((hResultCode = DN_CreateInterface(pIntList->pObject,riid,&pIntNew)) != S_OK)
		{
			goto Exit;
		}
		pIntNew->pIntNext = pIntList;
		pIntList->pObject->pIntList = pIntNew;
		pIntList = pIntNew;
	}
	if (pIntList->lRefCount == 0)		// New interface exposed
	{
		InterlockedIncrement( &pIntList->pObject->lRefCount );
	}
	InterlockedIncrement( &pIntList->lRefCount );
	*ppv = static_cast<void*>(pIntList);
    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF(5,"*ppv = [0x%p]", *ppv);

	hResultCode = S_OK;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_AddRef"

STDMETHODIMP_(ULONG) DN_AddRef(void *pInterface)
{
	INTERFACE_LIST	*pIntList;
	LONG			lRefCount;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF(2,"Parameters: pInterface [0x%p]",pInterface);

	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		lRefCount = 0;
		goto Exit;
	}

	pIntList = static_cast<INTERFACE_LIST*>(pInterface);
	lRefCount = InterlockedIncrement( &pIntList->lRefCount );
	DPF(5,"New lRefCount [%ld]",lRefCount);

Exit:
	DPF(2,"Returning: lRefCount [%ld]",lRefCount);
	return(lRefCount);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_Release"

STDMETHODIMP_(ULONG) DN_Release(void *pInterface)
{
	INTERFACE_LIST	*pIntList;
	INTERFACE_LIST	*pIntCurrent;
	LONG			lRefCount;
	LONG			lObjRefCount;

    // 5/23/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF(2,"Parameters: pInterface [%p]",pInterface);

	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		lRefCount = 0;
		goto Exit;
	}

	pIntList = static_cast<INTERFACE_LIST*>(pInterface);
	lRefCount = InterlockedDecrement( &pIntList->lRefCount );
	DPF(5,"New lRefCount [%ld]",lRefCount);

	if (lRefCount == 0)
	{
		//
		//	Decrease object's interface count
		//
		lObjRefCount = InterlockedDecrement( &pIntList->pObject->lRefCount );

		//
		//	Free object and interfaces
		//
		if (lObjRefCount == 0)
		{
			pIntList = pIntList->pObject->pIntList;	// Get head of interface list
			DNFree(pIntList->pObject);

			// Free Interfaces
			DPF(5,"Free interfaces");
			while(pIntList != NULL)
			{
				pIntCurrent = pIntList;
				pIntList = pIntList->pIntNext;
				DNFree(pIntCurrent);
			}

			GdwHObjects--;
		}
	}

Exit:
	DPF(2,"Returning: lRefCount [%ld]",lRefCount);
	return(lRefCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\classfac.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassFac.h
 *  Content:    DirectNet class factory header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	10/08/99	jtk		Created
 *	05/04/00	mjn		Cleaned up functions
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat and support external create funcs 
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CLASSFAC_H__
#define	__CLASSFAC_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// COM interface for class factory
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectNetClassFact
DECLARE_INTERFACE_(IDirectNetClassFact,IUnknown)
{
	STDMETHOD(QueryInterface)	(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)	(THIS) PURE;
	STDMETHOD_(ULONG,Release)	(THIS) PURE;
	STDMETHOD(CreateInstance)	(THIS_ LPUNKNOWN lpUnkOuter, REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD(LockServer)		(THIS_ BOOL bLock) PURE;
};


typedef struct _IDirectNetClassFact {	// Internal Implementation (overlay's external imp.)
	IDirectNetClassFactVtbl	*lpVtbl;		// lpVtbl Must be first element (to match external imp.)
	DWORD					dwRefCount;
	DWORD					dwLocks;
	GUID                    clsid;
} _IDirectNetClassFact, *_LPIDirectNetClassFact;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//
//	DirectNet - IUnknown
//
STDMETHODIMP DN_QueryInterface(void *pInterface,
							   REFIID riid,
							   void **ppv);

STDMETHODIMP_(ULONG) DN_AddRef(void *pInterface);

STDMETHODIMP_(ULONG) DN_Release(void *pInterface);

static	HRESULT DN_CreateInterface(OBJECT_DATA *pObject,
								   REFIID riid,
								   INTERFACE_LIST **const ppv);

INTERFACE_LIST *DN_FindInterface(void *pInterface,
								 REFIID riid);


#endif	// __CLASSFAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\caps.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Caps.cpp
 *  Content:    Dplay8 caps routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/17/00	rmt		Created
 *  03/23/00	rmt		Removed unused local variables
 *  03/25/00    rmt		Updated to make calls into SP's function
 *              rmt		Updated SP calls to Initialize SP (and create if required)
 *  03/31/00    rmt		Hooked up the GetCaps/SetCaps calls to call the protocol
 *  04/17/00    rmt		Strong param validation
 *	04/19/00	mjn		Removed AddRef() for NameTableEntry in DN_GetConnectionInfoHelper()
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	06/05/00	mjn		Fixed DN_GetConnectionInfoHelper() to use GetConnectionRef
 *  06/09/00    rmt     Updates to split CLSID and allow whistler compat
 *	07/06/00	mjn		Use GetInterfaceRef for SP interface
 *				mjn		Fixed up DN_SetActualSPCaps() and DN_GetActualSPCaps()
 *	07/29/00	mjn		Fixed SetSPCaps() recursion problem
 *	07/31/00	mjn		Renamed dwDefaultEnumRetryCount to dwDefaultEnumCount in DPN_SP_CAPS
 *  08/03/2000	rmt		Bug #41244 - Wrong return codes -- part 2
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added dwFlags to DN_GetConnectionInfoHelper()
 *	08/20/00	mjn		DNSetActualSPCaps() uses CServiceProvider object instead of GUID
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DN_SetCaps
//
//	Set caps
#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetCaps"

HRESULT DIRECTNETOBJECT::DN_SetCaps(PVOID pv,
						const DPN_CAPS *const pdnCaps,
						const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
    HRESULT             hResultCode;

	DPF(3,"Parameters: pdnCaps [0x%p] dwFlags [0x%lx]", pdnCaps, dwFlags );

	RIP_ON_NOT_TRUE( "SetCaps() Error validating params", SUCCEEDED( DN_ValidateSetCaps( pv, pdnCaps, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "SetCaps() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    hResultCode = DNPSetProtocolCaps( pdnObject->pdnProtocolData, pdnCaps );

	DPF_RETURN(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetCaps"
HRESULT DIRECTNETOBJECT::DN_GetCaps(PVOID pv,
						DPN_CAPS *const pdnCaps,
						const DWORD dwFlags)
{
	DPF(2,"Parameters: pdnCaps [0x%p], dwFlags [0x%lx]", pdnCaps,dwFlags);

	DIRECTNETOBJECT		*pdnObject = this;
	HRESULT hResultCode;

	RIP_ON_NOT_TRUE( "GetCaps() Error validating params", SUCCEEDED( DN_ValidateGetCaps( pv, pdnCaps, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "GetCaps() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    hResultCode = DNPGetProtocolCaps( pdnObject->pdnProtocolData, pdnCaps );

	DPF_RETURN(hResultCode);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetSPCaps"
HRESULT DIRECTNETOBJECT::DN_GetSPCaps(PVOID pv,
						  const GUID * const pguidSP,
						  DPN_SP_CAPS *const pdnSPCaps,
						  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	HRESULT             hResultCode;

	DPF(2,"Parameters: pdnSPCaps [0x%p], dwFlags [0x%lx]", pdnSPCaps, dwFlags );

	RIP_ON_NOT_TRUE( "GetSPCaps() Error validating params", SUCCEEDED( DN_ValidateGetSPCaps( pv, pguidSP, pdnSPCaps, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "GetSPCaps() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    if ((hResultCode = DNGetActualSPCaps( pdnObject, pguidSP, pdnSPCaps )) != DPN_OK)
    {
		DPFERR("Could not get actual SP caps");
		DisplayDNError(0,hResultCode);
    }

/*	REMOVE
    hResultCode = DN_SetCachedSPCaps( pdnObject, pguidSP, pdnSPCaps );

    if( FAILED( hResultCode ) )
    {
        DPF( 0, "Could not set cached SP caps hr=[0x%08x]", hResultCode );
        DNLeaveCriticalSection( &pdnObject->csDirectNetObject );
        DPF_RETURN(hResultCode);
    }
*/

	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetSPCaps"
HRESULT DIRECTNETOBJECT::DN_SetSPCaps(PVOID pv,const GUID * const pguidSP, const DPN_SP_CAPS *const pdnSPCaps, const DWORD dwFlags)
{
	DPF(2,"Parameters: pdnSPCaps [0x%p]", pdnSPCaps );

	DIRECTNETOBJECT		*pdnObject = this;
	CServiceProvider	*pSP;
    HRESULT             hResultCode;

	RIP_ON_NOT_TRUE( "SetSPCaps() Error validating params", SUCCEEDED( DN_ValidateSetSPCaps( pv, pguidSP, pdnSPCaps, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "SetSPCaps() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

	pSP = NULL;

	//
	//	If the SP is loaded, we will take a reference, otherwise, we will instantiate the SP for the
	//	life of this call, and release it when we're done.
	//
	if ((hResultCode = DN_SPFindEntry(pdnObject,pguidSP,&pSP)) == DPNERR_DOESNOTEXIST)
	{
		//
		//	Instantiate SP and add to Protocol
		//
		if ((hResultCode = DN_SPInstantiate(pdnObject,&GUID_NULL,&pSP)) != DPN_OK)
		{
			DPFERR("Could not load SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}
	else
	{
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not find SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}

	DNASSERT(pSP != NULL);

	//
	//	Set the SP's actual caps
	//
    if ((hResultCode = DNSetActualSPCaps(pdnObject,pSP,pdnSPCaps)) != DPN_OK)
    {
		DPFERR("Could not set actual SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
    }

	//
	//	Set the SP's cached caps
	//
    if ((hResultCode = DNSetCachedSPCaps( pdnObject, NULL, pdnSPCaps )) != DPN_OK)
    {
		DPFERR("Could not set cached SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
    }

	pSP->Release();
	pSP = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
    return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetConnectionInfoHelper"
HRESULT DIRECTNETOBJECT::DN_GetConnectionInfoHelper(PVOID pv,
										const DPNID dpnid,
										DPN_CONNECTION_INFO *const pdpConnectionInfo,
										BOOL fServerPlayer,
										const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
    HRESULT             hResultCode;
    CNameTableEntry     *pPlayerEntry;
    CConnection         *pConnection;
    HANDLE              hEndPoint;

	pPlayerEntry = NULL;
	pConnection = NULL;

	RIP_ON_NOT_TRUE( "GetConnectionInfo() Error validating params", SUCCEEDED( DN_ValidateGetConnectionInfoHelper( pv, dpnid, pdpConnectionInfo, fServerPlayer,dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "GetConnectionInfo() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to create a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}    	


	// Temporary debugging purposes only, shouldn't be checked in!
#if	0
	DNMemoryTrackingValidateMemory();
#endif


    if( fServerPlayer )
    {
		hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pPlayerEntry );
		if ( FAILED( hResultCode ) )
		{
            DPF( 0, "No host player present" );
            DPF_RETURN(DPNERR_INVALIDPLAYER);
		}
    }
    else
    {
        hResultCode = pdnObject->NameTable.FindEntry( dpnid, &pPlayerEntry );

        if( FAILED( hResultCode ) )
        {
            DPF( 0, "Could not find specified player" );
            DPF_RETURN(DPNERR_INVALIDPLAYER);
        }
    }

    if( pPlayerEntry == NULL )
    {
        DNASSERT(FALSE);
        DPF( 0, "Internal error" );
        DPF_RETURN(DPNERR_GENERIC);
    }

    if( pPlayerEntry->IsGroup() )
    {
        DPF( 0, "Cannot retrieve connection info on groups" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
    }

	if ((hResultCode = pPlayerEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get connection reference");
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}

    hResultCode = pConnection->GetEndPt(&hEndPoint, FALSE );

    if( FAILED( hResultCode ) )
    {
        DPF( 0, "Unable to get endpoint hr=[0x%08x]", hResultCode );
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
    }

    hResultCode = DNPGetEPCaps( hEndPoint, pdpConnectionInfo );

    if( FAILED( hResultCode ) )
    {
        DPF( 0, "Error getting connection info hr=[0x%08x]", hResultCode );
        hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
    }

    pConnection->Release();
    pPlayerEntry->Release();

	hResultCode = DPN_OK;

Exit:
    DPF_RETURN(hResultCode);

Failure:
	if (pPlayerEntry)
	{
		pPlayerEntry->Release();
		pPlayerEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetConnectionInfo"
HRESULT DIRECTNETOBJECT::DN_GetConnectionInfo(PVOID pv,
								  const DPNID dpnid,
								  DPN_CONNECTION_INFO *const pdpConnectionInfo,
								  const DWORD dwFlags)
{
	DPF(3,"Parameters: dpnid [0x%lx] pdpConnectionInfo [0x%p], dwFlags [0x%lx]", dpnid, pdpConnectionInfo,dwFlags );

    return DN_GetConnectionInfoHelper( pv, dpnid, pdpConnectionInfo, FALSE, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetConnectionInfo"
HRESULT DIRECTNETOBJECT::DN_GetServerConnectionInfo(PVOID pv,
										DPN_CONNECTION_INFO *const pdpConnectionInfo,
										const DWORD dwFlags)
{
	DPF(2,"Parameters: pdpConnectionInfo [0x%p], dwFlags [0x%lx]", pdpConnectionInfo, dwFlags);

    return DN_GetConnectionInfoHelper( pv, 0, pdpConnectionInfo, TRUE, dwFlags );
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_InitSPCapsList"
HRESULT DN_InitSPCapsList( DIRECTNETOBJECT *pdnObject )
{
    pdnObject->blSPCapsList.Initialize();

    return DPN_OK;
}

// This function destroys the list of SP_CAPS_ENTRY structures
#undef DPF_MODNAME
#define DPF_MODNAME "DN_FreeSPCapsList"
HRESULT DN_FreeSPCapsList( DIRECTNETOBJECT *pdnObject )
{
    CBilink *pblSearch;
    PDN_SP_CAPS_ENTRY pdpSPCaps;

    DNEnterCriticalSection( &pdnObject->csDirectNetObject );

    pblSearch = pdnObject->blSPCapsList.GetNext();

    while( pblSearch != &pdnObject->blSPCapsList )
    {
        pdpSPCaps = CONTAINING_RECORD( pblSearch, DN_SP_CAPS_ENTRY, blList );

        pblSearch->RemoveFromList();

        delete pdpSPCaps;

        pblSearch = pdnObject->blSPCapsList.GetNext();
    }

    DNLeaveCriticalSection( &pdnObject->csDirectNetObject );

    return DPN_OK;
}

// This function is a helper and assumes that you already have the global object lock
#undef DPF_MODNAME
#define DPF_MODNAME "DNGetCachedSPCaps"
HRESULT DNGetCachedSPCaps( DIRECTNETOBJECT *pdnObject, const GUID * const pguidSP, PDPN_SP_CAPS *ppCaps )
{
    CBilink *pblSearch;
    PDN_SP_CAPS_ENTRY pdpSPCaps;

    pblSearch = pdnObject->blSPCapsList.GetNext();

    if( pblSearch != &pdnObject->blSPCapsList )
    {
        pdpSPCaps = CONTAINING_RECORD( pblSearch, DN_SP_CAPS_ENTRY, blList );

            *ppCaps = &pdpSPCaps->dpnCaps;
            return DPN_OK;
    }

    return DPNERR_GENERIC;
}

// This function is a helper and assumes that you already have the global object lock
#undef DPF_MODNAME
#define DPF_MODNAME "DNSetCachedSPCaps"
HRESULT DNSetCachedSPCaps( DIRECTNETOBJECT *pdnObject, const GUID * const pguidSP, const DPN_SP_CAPS * const pCaps )
{
    PDN_SP_CAPS_ENTRY pdpSPCaps;
    PDPN_SP_CAPS dpnCaps;
    HRESULT hr;

    hr = DNGetCachedSPCaps( pdnObject, pguidSP, &dpnCaps );

    if( FAILED( hr ) )
    {
        DPF( 5, "Creating new cache entry for SP" );

        pdpSPCaps = new DN_SP_CAPS_ENTRY;

        if( pdpSPCaps == NULL )
        {
            DPF( 0, "Error allocating memory for SP caps" );
            return DPNERR_OUTOFMEMORY;
        }

        pdpSPCaps->blList.Initialize();

        if (pguidSP != NULL)
            pdpSPCaps->guidSP = *pguidSP;
        pdpSPCaps->dpnCaps.dwFlags = pCaps->dwFlags;
        pdpSPCaps->dpnCaps.dwSize = sizeof( DPN_SP_CAPS );
        pdpSPCaps->dpnCaps.dwNumThreads = pCaps->dwNumThreads;
		pdpSPCaps->dpnCaps.dwBuffersPerThread = pCaps->dwBuffersPerThread;
		pdpSPCaps->dpnCaps.dwSystemBufferSize = pCaps->dwSystemBufferSize;

        pdpSPCaps->blList.InsertAfter( &pdnObject->blSPCapsList );
    }
    else
    {
        DPF( 5, "Setting info on current cached SP entry" );

        dpnCaps->dwNumThreads = pCaps->dwNumThreads;
		dpnCaps->dwBuffersPerThread = pCaps->dwBuffersPerThread;
		dpnCaps->dwSystemBufferSize = pCaps->dwSystemBufferSize;
        dpnCaps->dwFlags = pCaps->dwFlags;
    }

    return DPN_OK;
}

HRESULT DNCAPS_QueryInterface( IDP8SPCallback *pSP, LPVOID * ppvObj )
{
    *ppvObj = pSP;
    return DPN_OK;
}

ULONG DNCAPS_AddRef( IDP8SPCallback *pSP )
{
    return 1;
}

ULONG DNCAPS_Release( IDP8SPCallback *pSP )
{
    return 1;
}

HRESULT DNCAPS_IndicateEvent( IDP8SPCallback *pSP, SP_EVENT_TYPE spetEvent,LPVOID pvData )
{
    return DPN_OK;
}

HRESULT DNCAPS_CommandComplete( IDP8SPCallback *pSP,HANDLE hCommand,HRESULT hrResult,LPVOID pvData )
{
    return DPN_OK;
}


LPVOID dncapsspInterface[] =
{
    (LPVOID)DNCAPS_QueryInterface,
    (LPVOID)DNCAPS_AddRef,
    (LPVOID)DNCAPS_Release,
	(LPVOID)DNCAPS_IndicateEvent,
	(LPVOID)DNCAPS_CommandComplete
};


#undef DPF_MODNAME
#define DPF_MODNAME "DNSetActualSPCaps"

HRESULT DNSetActualSPCaps(DIRECTNETOBJECT *pdnObject,
						  CServiceProvider *const pSP,
						  const DPN_SP_CAPS * const pCaps)
{
    HRESULT				hResultCode;
    SPSETCAPSDATA		spSetCapsData;
    IDP8ServiceProvider	*pIDP8SP;

	DPF(6,"Parameters: pSP [0x%p], pCaps [0x%p]",pSP,pCaps);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pSP != NULL);
	DNASSERT(pCaps != NULL);

	pIDP8SP = NULL;

	//
	//	Get SP interface
	//
	if ((hResultCode = pSP->GetInterfaceRef( &pIDP8SP )) != DPN_OK)
	{
		DPFERR("Could not get SP interface reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Set the SP caps
	//
    memset( &spSetCapsData, 0x00, sizeof( SPSETCAPSDATA ) );
    spSetCapsData.dwSize = sizeof( SPSETCAPSDATA );
    spSetCapsData.dwIOThreadCount = pCaps->dwNumThreads;
    spSetCapsData.dwBuffersPerThread = pCaps->dwBuffersPerThread;
	spSetCapsData.dwSystemBufferSize = pCaps->dwSystemBufferSize;

	if ((hResultCode = pIDP8SP->lpVtbl->SetCaps( pIDP8SP, &spSetCapsData )) != DPN_OK)
	{
		DPFERR("Could not set SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pIDP8SP->lpVtbl->Release( pIDP8SP );
	pIDP8SP = NULL;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
    return(hResultCode);

Failure:
	if (pIDP8SP)
	{
        pIDP8SP->lpVtbl->Release(pIDP8SP);
		pIDP8SP = NULL;
	}
	goto Exit;
}


// SP should be loaded
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNGetActualSPCaps"

HRESULT DNGetActualSPCaps(DIRECTNETOBJECT *pdnObject,
						  const GUID * const pguidSP,
						  PDPN_SP_CAPS pCaps)
{
    HRESULT				hResultCode;
    SPGETCAPSDATA		spGetCapsData;
    IDP8ServiceProvider	*pIDP8SP;
    CServiceProvider	*pSP;

	DPF(6,"Parameters: pguidSP [0x%p], pCaps [0x%p]",pguidSP,pCaps);

	DNASSERT(pdnObject != NULL);

	pIDP8SP = NULL;
	pSP = NULL;

	//
	//	Find SP interface - either we have already loaded it, in which case we will take a reference,
	//	or it has not been loaded yet, in which case we will instantiate it.  Either way, we will
	//	release it once we have the actual SP COM interface.
	//
	if ((hResultCode = DN_SPFindEntry(pdnObject,NULL,&pSP)) == DPNERR_DOESNOTEXIST)
	{
		//
		//	Instantiate SP and add to Protocol
		//
		if ((hResultCode = DN_SPInstantiate(pdnObject,&GUID_NULL,&pSP)) != DPN_OK)
		{
			DPFERR("Could not load SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}
	else
	{
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not find SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}

	DNASSERT(pSP != NULL);

	if ((hResultCode = pSP->GetInterfaceRef( &pIDP8SP )) != DPN_OK)
	{
		DPFERR("Could not get SP interface reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Get the SP caps
	//
    memset( &spGetCapsData, 0x00, sizeof( SPGETCAPSDATA ) );
    spGetCapsData.dwSize = sizeof( SPGETCAPSDATA );
	spGetCapsData.hEndpoint = INVALID_HANDLE_VALUE;
    if ((hResultCode = pIDP8SP->lpVtbl->GetCaps( pIDP8SP, &spGetCapsData )) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pIDP8SP->lpVtbl->Release( pIDP8SP );
	pIDP8SP = NULL;
	pSP->Release();
	pSP = NULL;

	//
    //	Map from SP structure to our own
	//
	pCaps->dwFlags = spGetCapsData.dwFlags;
    pCaps->dwNumThreads = spGetCapsData.dwIOThreadCount;
	pCaps->dwDefaultEnumCount = spGetCapsData.dwDefaultEnumRetryCount;
	pCaps->dwDefaultEnumRetryInterval = spGetCapsData.dwDefaultEnumRetryInterval;
	pCaps->dwDefaultEnumTimeout = spGetCapsData.dwDefaultEnumTimeout;
	pCaps->dwMaxEnumPayloadSize = spGetCapsData.dwEnumFrameSize - sizeof( DN_ENUM_QUERY_PAYLOAD );
	pCaps->dwBuffersPerThread = spGetCapsData.dwBuffersPerThread;
	pCaps->dwSystemBufferSize = spGetCapsData.dwSystemBufferSize;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
    return(hResultCode);

Failure:
	if (pIDP8SP)
	{
        pIDP8SP->lpVtbl->Release(pIDP8SP);
		pIDP8SP = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\client.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Client.cpp
 *  Content:    DNET client interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	01/06/99	mjn		Moved NameTable stuff to NameTable.h
 *	01/28/00	mjn		Implemented ReturnBuffer in API
 *	02/01/00	mjn		Implemented GetCaps and SetCaps in API
 *	02/15/00	mjn		Implement INFO flags in SetClientInfo
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *  03/17/00    rmt     Added new caps functions
 *	04/06/00	mjn		Added GetServerAddress to API
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *  04/17/00    rmt     Added more param validation
 *              rmt     Removed required for connection from Get/SetInfo / GetAddress
 *	04/19/00	mjn		Send API call accepts a range of DPN_BUFFER_DESCs and a count
 *	04/20/00	mjn		DN_Send() calls DN_SendTo() with DPNID=0
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	04/28/00	mjn		Updated DN_GetHostSendQueueInfo() to use CAsyncOp's
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	06/23/00	mjn		Removed dwPriority from Send() API call
 *	06/27/00	mjn		Allow priorities to be specified to GetSendQueueInfo() API call
 *	06/27/00	mjn		Added DN_ClientConnect() (without pvPlayerContext)
 *				mjn		Allow mix-n-match of priorities in GetSendQueueInfo() API call
 *	07/09/00	mjn		Cleaned up DN_SetClientInfo()
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *  07/21/2000  RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *	10/11/00	mjn		Take locks for CNameTableEntry::PackInfo()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

ULONG WINAPI IDirectPlay8Client_AddRef(LPDIRECTPLAY8CLIENT pDirectPlay8Client)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->AddRef();
}
ULONG WINAPI IDirectPlay8Client_Release(LPDIRECTPLAY8CLIENT pDirectPlay8Client)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->Release();
}

HRESULT WINAPI IDirectPlay8Client_Initialize(LPDIRECTPLAY8CLIENT pDirectPlay8Client, LPVOID const lpvUserContext, const PFNDPNMESSAGEHANDLER lpfn, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_Initialize(NULL, lpvUserContext, lpfn, dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_EnumServiceProviders(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const GUID *const pvoid,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,DWORD *const pcbEnumData,DWORD *const pcReturned,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_EnumServiceProviders(NULL, pvoid,pguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned,dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_EnumHosts(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DPN_APPLICATION_DESC *const pApplicationDesc,IDirectPlay8Address *const dnaddrHost,IDirectPlay8Address *const dnaddrDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwRetryCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_EnumHosts(NULL, pApplicationDesc,dnaddrHost,dnaddrDeviceInfo,pUserEnumData,dwUserEnumDataSize,dwRetryCount,dwRetryInterval,dwTimeOut,pvUserContext,pAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_CancelAsyncOperation(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPNHANDLE hAsyncHandle, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_CancelAsyncOperation(NULL, hAsyncHandle, dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_Connect(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_ClientConnect(NULL, pdnAppDesc,pHostAddr,pDeviceInfo,pdnSecurity,pdnCredentials,pvUserConnectData,dwUserConnectDataSize,pvAsyncContext,phAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_Send(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_Send(NULL, prgBufferDesc,cBufferDesc,dwTimeOut,pvAsyncContext,phAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_GetSendQueueInfo(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_GetHostSendQueueInfo(NULL, pdwNumMsgs,pdwNumBytes,dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_GetApplicationDesc(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DPN_APPLICATION_DESC *const pAppDescBuffer,DWORD *const lpcbDataSize,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_GetApplicationDesc( NULL, pAppDescBuffer, lpcbDataSize, dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_SetClientInfo(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_SetClientInfo( NULL, pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_GetServerInfo(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_GetServerInfo( NULL, pdpnPlayerInfo, pdwSize, dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_GetServerAddress(LPDIRECTPLAY8CLIENT pDirectPlay8Client, IDirectPlay8Address **const pAddress,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_GetServerAddress( NULL, pAddress, dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_Close(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_Close( NULL, dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_ReturnBuffer(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPNHANDLE hBufferHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_ReturnBuffer( NULL, hBufferHandle, dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_GetCaps(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DPN_CAPS *const pdnCaps,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_GetCaps( NULL, pdnCaps, dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_SetCaps(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPN_CAPS *const pdnCaps,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_SetCaps( NULL, pdnCaps, dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_SetSPCaps(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const GUID *const pvoid, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_SetSPCaps( NULL, pvoid, pdpspCaps, dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_GetSPCaps(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const GUID *const pvoid, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_GetSPCaps(NULL, pvoid,pdpspCaps,dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_GetConnectionInfo(LPDIRECTPLAY8CLIENT pDirectPlay8Client, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_GetServerConnectionInfo(NULL, pdpConnectionInfo,dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_RegisterLobby(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DN_RegisterLobby(NULL, dpnHandle,pIDP8LobbiedApplication,dwFlags);
}

HRESULT WINAPI IDirectPlay8Client_DoWork(LPDIRECTPLAY8CLIENT pDirectPlay8Client, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Client(pDirectPlay8Client)->DoWork(dwFlags);
}


//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "DN_Send"

HRESULT DIRECTNETOBJECT::DN_Send( IDirectPlay8Client *pInterface,
					  const DPN_BUFFER_DESC *const prgBufferDesc,
					  const DWORD cBufferDesc,
					  const DWORD dwTimeOut,
					  const PVOID pvAsyncContext,
					  DPNHANDLE *const phAsyncHandle,
					  const DWORD dwFlags)
{
	return(	DN_SendTo(	pInterface,
						0,					// DN_SendTo should translate this call to the Host player
						prgBufferDesc,
						cBufferDesc,
						dwTimeOut,
						pvAsyncContext,
						phAsyncHandle,
						dwFlags ) );
}


//	DN_ClientConnect
//
//	Call DN_Connect, but with no PlayerContext

HRESULT DIRECTNETOBJECT::DN_ClientConnect(IDirectPlay8Client *pInterface,
							  const DPN_APPLICATION_DESC *const pdnAppDesc,
							  IDirectPlay8Address *const pHostAddr,
							  IDirectPlay8Address *const pDeviceInfo,
							  const DPN_SECURITY_DESC *const pdnSecurity,
							  const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
							  const void *const pvUserConnectData,
							  const DWORD dwUserConnectDataSize,
							  void *const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	return(	DN_Connect(	pInterface,
						pdnAppDesc,
						pHostAddr,
						pDeviceInfo,
						pdnSecurity,
						pdnCredentials,
						pvUserConnectData,
						dwUserConnectDataSize,
						NULL,
						pvAsyncContext,
						phAsyncHandle,
						dwFlags ) );
}


//	DN_SetClientInfo
//
//	Set the info for the client player and propagate to server

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetClientInfo"

HRESULT DIRECTNETOBJECT::DN_SetClientInfo(IDirectPlay8Client *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  const PVOID pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;
	BOOL				fConnected;

	DPF(2,"Parameters: pInterface [0x%p], pdpnPlayerInfo [0x%p], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,pdpnPlayerInfo,pvAsyncContext,phAsyncHandle,dwFlags);

	RIP_ON_NOT_TRUE( "SetClientInfo() Error validating params", SUCCEEDED( DN_ValidateSetClientInfo( pInterface , pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "SetClientInfo() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

	pLocalPlayer = NULL;

	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnPlayerInfo->pwszName))
	{
		pwszName = pdpnPlayerInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnPlayerInfo->pvData) && (pdpnPlayerInfo->dwDataSize))
	{
		pvData = pdpnPlayerInfo->pvData;
		dwDataSize = pdpnPlayerInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	//
	//	If we are connected, we will request the Host to update us.
	//	Otherwise, we will just update the DefaultPlayer.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
		fConnected = TRUE;
	}
	else
	{
		fConnected = FALSE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (fConnected)
	{
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
		{
			DPFERR( "Could not get local player reference" );
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		DPF(3,"Request host to update client info");

		hResultCode = DNRequestUpdateInfo(	pdnObject,
											pLocalPlayer->GetDPNID(),
											pwszName,
											dwNameSize,
											pvData,
											dwDataSize,
											pdpnPlayerInfo->dwInfoFlags,
											pvAsyncContext,
											&hAsyncOp,
											dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to update client info");
		}
		else
		{
				DPF(3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
		}

		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		DNASSERT(pdnObject->NameTable.GetDefaultPlayer() != NULL);

		// This function takes the lock internally
		pdnObject->NameTable.GetDefaultPlayer()->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,pdpnPlayerInfo->dwInfoFlags, FALSE);

		hResultCode = DPN_OK;
	}

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DN_GetServerInfo
//
//	Retrieve server info from the local nametable.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetServerInfo"

HRESULT DIRECTNETOBJECT::DN_GetServerInfo(IDirectPlay8Client *pInterface,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT	*pdnObject = this;
	HRESULT			hResultCode;
	CPackedBuffer	packedBuffer;
	CNameTableEntry	*pHostPlayer;

	DPF(3,"Parameters: pInterface [0x%p], pdpnPlayerInfo [0x%p], pdwSize [%p], dwFlags [0x%lx]",
			pInterface,pdpnPlayerInfo,pdwSize,dwFlags);

	RIP_ON_NOT_TRUE( "GetServerInfo() Error validating params", SUCCEEDED( DN_ValidateGetServerInfo( pInterface , pdpnPlayerInfo, pdwSize, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "GetServerInfo() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) &&
    	   !(pdnObject->dwFlags & DN_OBJECT_FLAG_DISCONNECTING) )
    	{
    	    DPFERR("You must be connected / disconnecting to use this function" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	

	pHostPlayer = NULL;

	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef(&pHostPlayer)) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	packedBuffer.Initialize(pdpnPlayerInfo,*pdwSize);

	pHostPlayer->Lock();
	hResultCode = pHostPlayer->PackInfo(&packedBuffer);
	pHostPlayer->Unlock();

	pHostPlayer->Release();
	pHostPlayer = NULL;

	if ((hResultCode == DPN_OK) || (hResultCode == DPNERR_BUFFERTOOSMALL))
	{
		*pdwSize = packedBuffer.GetSizeRequired();
	}

Exit:
	DPF_RETURN(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetHostSendQueueInfo"

HRESULT DIRECTNETOBJECT::DN_GetHostSendQueueInfo(IDirectPlay8Client *pInterface,
									 DWORD *const pdwNumMsgs,
									 DWORD *const pdwNumBytes,
									 const DWORD dwFlags )
{
	DIRECTNETOBJECT		*pdnObject = this;
	DWORD				dwQueueFlags;
	DWORD				dwNumMsgs;
	DWORD				dwNumBytes;
	CNameTableEntry     *pNTEntry;
	CConnection			*pConnection;
	HRESULT				hResultCode;

	DPF(3,"Parameters : pInterface [0x%p], pdwNumMsgs [0x%p], pdwNumBytes [0x%p], dwFlags [0x%lx]",
		pInterface,pdwNumMsgs,pdwNumBytes,dwFlags);

	RIP_ON_NOT_TRUE( "GetHostSendQueueInfo() Error validating params", SUCCEEDED( DN_ValidateGetHostSendQueueInfo( pInterface , pdwNumMsgs, pdwNumBytes, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "GetHostSendQueueInfo() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR( "Object has not yet completed connecting / hosting" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("Object is not connected or hosting" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}
   	
	pNTEntry = NULL;
	pConnection = NULL;

	//
    //	Validate specified player ID and get CConnection
	//
	if((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )))
	{
		DPF(0,"Could not find Host Player in NameTable");
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Determine required queues
	//
	dwQueueFlags = dwFlags & (DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_LOW);
	if (dwQueueFlags == 0)
	{
		dwQueueFlags = (DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_LOW);
	}

	//
	//	Extract required info
	//
	dwNumMsgs = 0;
	dwNumBytes = 0;
	pConnection->Lock();
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_HIGH)
	{
		dwNumMsgs += pConnection->GetHighQueueNum();
		dwNumBytes += pConnection->GetHighQueueBytes();
	}
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_NORMAL)
	{
		dwNumMsgs += pConnection->GetNormalQueueNum();
		dwNumBytes += pConnection->GetNormalQueueBytes();
	}
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_LOW)
	{
		dwNumMsgs += pConnection->GetLowQueueNum();
		dwNumBytes += pConnection->GetLowQueueBytes();
	}
	pConnection->Unlock();
	pConnection->Release();
	pConnection = NULL;

	if (pdwNumMsgs)
	{
		*pdwNumMsgs = dwNumMsgs;
		DPF(3,"Setting: *pdwNumMsgs [%ld]",dwNumMsgs);
	}
	if (pdwNumBytes)
	{
		*pdwNumBytes = dwNumBytes;
		DPF(3,"Setting: *pdwNumBytes [%ld]",dwNumBytes);
	}

	hResultCode = DPN_OK;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetServerAddress"

HRESULT DIRECTNETOBJECT::DN_GetServerAddress(IDirectPlay8Client *pInterface,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	IDirectPlay8Address	*pAddress;
	HRESULT				hResultCode;
	CNameTableEntry		*pHostPlayer;

	DPF(3,"Parameters : pInterface [0x%p], ppAddress [0x%p], dwFlags [0x%lx]",
		pInterface,ppAddress,dwFlags);

	RIP_ON_NOT_TRUE( "GetServerAddress() Error validating params", SUCCEEDED( DN_ValidateGetServerAddress( pInterface,ppAddress,dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "GetServerAddress() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) &&
    	   !(pdnObject->dwFlags & DN_OBJECT_FLAG_DISCONNECTING) )
    	{
    	    DPFERR("You must be connected / disconnecting to use this function" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	
  	
	pHostPlayer = NULL;

	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pAddress = pHostPlayer->GetAddress();
	DNASSERT(pAddress != NULL);
	hResultCode = pAddress->Duplicate(ppAddress);

	pHostPlayer->Release();
	pHostPlayer = NULL;

Exit:
	DPF_RETURN(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\common.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Common.h
 *  Content:    DirectNet common code header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	10/08/99	jtk		Created
 *	01/14/00	mjn		Added pvUserContext to DN_Host
 *	01/23/00	mjn		Added DN_DestroyPlayer and DNTerminateSession
 *	01/28/00	mjn		Added DN_ReturnBuffer
 *	02/01/00	mjn		Added DN_GetCaps, DN_SetCaps
 *	02/15/00	mjn		Implement INFO flags in SetInfo and return context in GetInfo
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *	02/17/00	mjn		Reordered parameters in EnumServiceProviders,EnumHosts,Connect,Host
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *  03/17/00    rmt     Moved caps funcs to caps.h/caps.cpp
 *	04/06/00	mjn		Added DN_GetHostAddress()
 *	04/19/00	mjn		Changed DN_SendTo to accept a range of DPN_BUFFER_DESCs and a count
 *	06/23/00	mjn		Removed dwPriority from DN_SendTo()
 *	06/25/00	mjn		Added DNUpdateLobbyStatus()
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *	07/30/00	mjn		Added hrReason to DNTerminateSession()
 *	08/15/00	mjn		Added hProtocol tp DNRegisterWithDPNSVR()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__COMMON_H__
#define	__COMMON_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef	struct	_PROTOCOL_ENUM_DATA PROTOCOL_ENUM_DATA;

typedef	struct	_PROTOCOL_ENUM_RESPONSE_DATA PROTOCOL_ENUM_RESPONSE_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************


HRESULT DNTerminateSession(DIRECTNETOBJECT *const pdnObject,
						   const HRESULT hrReason);

HRESULT DNGetMaxEnumFrameSize(DIRECTNETOBJECT *const pdnObject,
							  DWORD *const pdwEnumFrameSize);

HRESULT DNAddRefLock(DIRECTNETOBJECT *const pdnObject);

void DNDecRefLock(DIRECTNETOBJECT *const pdnObject);

STDMETHODIMP DN_DumpNameTable(PVOID pInterface,char *const Buffer);

#endif	// __COMMON_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\common.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Common.cpp
 *  Content:    DNET common interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Fixed use of Host and AllPlayers short cut pointers
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	12/29/99	mjn		Added Instance GUID generation in DN_Host
 *	01/05/00	mjn		Return DPNERR_NOINTERFACE if CoCreateInstance fails
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Implemented DNSEND_NOCOPY flag in DN_SendTo
 *	01/07/00	mjn		Moved Misc Functions to DNMisc.h
 *	01/08/00	mjn		Implemented GetApplicationDesc
 *	01/09/00	mjn		Application Description stuff
 *	01/10/00	mjn		Implemented SetApplicationDesc
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/13/00	mjn		Removed DIRECTNETOBJECT from Pack/UnpackApplicationDesc
 *	01/14/00	mjn		Added pvUserContext to Host API call
 *	01/14/00	mjn		Removed pvUserContext from DN_NAMETABLE_ENTRY
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/18/00	mjn		Implemented DNGROUP_AUTODESTRUCT
 *  01/18/00	rmt		Added calls into voice layer for Close
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/20/00	mjn		Clean up NameTable operation list in DN_Close
 *	01/23/00	mjn		Added DN_DestroyPlayer and DNTerminateSession
 *	01/28/00	mjn		Added DN_ReturnBuffer
 *	02/01/00	mjn		Added DN_GetCaps, DN_SetCaps
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	02/15/00	mjn		Implement INFO flags in SetInfo and return context in GetInfo
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *	02/17/00	mjn		Reordered parameters in EnumServiceProviders,EnumHosts,Connect,Host
 *	02/18/00	mjn		Converted DNADDRESS to IDirectPlayAddress8
 *  03/17/00    rmt     Moved caps funcs to caps.h/caps.cpp
 *	03/23/00	mjn		Set group context through CreateGroup
 *				mjn		Set player context through Host and Connect
 *				mjn		Implemented RegisterLobby()
 *	03/24/00	mjn		Release SP when EnumHost completes
 *  03/25/00    rmt     Added call into DPNSVR when host begins
 *  04/04/00	rmt		Added flag to disable calls to DPNSVR and flag to disable
 *						parameter validation
 *	04/05/00	mjn		Fixed DestroyClient API call
 *	04/06/00	mjn		Added DN_GetHostAddress()
 *	04/07/00	mjn		Prevent Initialize() API from being called twice
 *				mjn		Ensure Host addresses have SP included
 *				mjn		Fixed DN_GetHostAddress() to get address
 *	04/09/00	mjn		Convert DN_Host() and DN_Connect() to use CAsyncOp
 *	04/10/00	mjn		Fixed DN_Close() to use flags
 *	04/11/00	mjn		Use CAsyncOp for ENUMs
 *				mjn		Moved ProcessEnumQuery and ProcessEnumResponse to EnumHosts.cpp
 *				mjn		DNCancelEnum() uses CAsyncOp
 *	04/12/00	mjn		DNTerminateSession() cancels outstanding ENUMs
 *				mjn		DN_Close() cancels ENUMs instead of DNTerminateSession
 *				mjn		DN_Close() clears DN_OBJECT_FLAG_DISCONNECTING
 *  04/13/00	rmt     More parameter validation
 *	04/14/00	mjn		Default Host SP to Device SP if not specified
 *				mjn		Crack LISTENs in DN_Host for DPNSVR
 *	04/16/00	mjn		DNSendMessage uses CAsyncOp
 *	04/17/00	mjn		DNCancelSend() uses CAsyncOp
 *	04/17/00	mjn		Fixed DN_EnumHosts to use Handle parent and SYNC operation
 *				mjn		DN_Close tries to cancel SENDs and ENUMs
 *	04/18/00	mjn		CConnection tracks connection status better
 *				mjn		Deinitialize HandleTable, and release addresses in DN_Close
 *				mjn		Fixed DN_GetApplicationDesc to return correct size
 *	04/19/00	mjn		Changed DN_SendTo to accept a range of DPN_BUFFER_DESCs and a count
 *				mjn		Shut down LISTENs earlier in Close sequence
 *	04/20/00	mjn		Convert ReceiveBuffers to CAsyncOp and reclaim at Close
 *				mjn		DN_SendTo() may be invoked by IDirectPlay8Client::DN_Send()
 *	04/23/00	mjn		Added parameter to DNPerformChildSend()
 *				mjn		Reimplemented SEND_COMPLETEONPROCESS
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	04/25/00	mjn		Added DNCancelConnect to DN_CancelAsyncOperation
 *	04/26/00	mjn		Fixed DN_GetSendQueueInfo to use CAsyncOp's
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	04/27/00	mjn		Cause DN_GetPlayerContext()/DN_GetGroupContext() to fail if disconnecting
 *	04/28/00	mjn		Allow a NULL Device Address in DN_Connect() - steal SP from Host Address
 *				mjn		Save user connect data to be passed during CONNECT sequence
 *				mjn		Prevent infinite loops in group SENDs
 *  05/01/00    rmt     Bug #33403 - Require DPNSESSION_CLIENT_SERVER mode in client/server mode
 *	05/01/00	mjn		Prevent unusable SPs from being enumerated.
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/04/00	mjn		Clean up address list in DN_Host()
 *	05/05/00	mjn		Free pvConnectData in DN_Close()
 *				mjn		Fixed leak in DN_GetHostAddress()
 *	05/16/00	mjn		Force return code from ASYNC DN_SendTo() to return DPNERR_PENDING
 *				mjn		Better locking for User notifications
 *	05/30/00	mjn		Modified logic for group sends to target connected players only
 *				mjn		ASSERT if operations cannot be cancelled in DN_Close()
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	05/31/00	mjn		Prevent ALL_PLAYERS group from being enum'd in DN_EnumClientsAndGroups()
 *				mjn		Skip invalid Host addresses
 *	06/05/00	mjn		Fixed DN_SendTo to handle some errors gracefully
 *	06/19/00	mjn		DN_Connect and DN_Host enumerate adapters if ALL_ADAPTERS specified
 *	06/20/00	mjn		Fixed DN_GetHostAddress() to extract host address from LISTENs
 *				mjn		DOH!  Forgot to change a line in DN_Host() so that LISTENs use enum'd adapter rather than ALL_ADAPTER
 *	06/22/00	mjn		Replace CConnection::MakeConnected() with SetStatus()
 *	06/23/00	mjn		Removed dwPriority from DN_SendTo()
 *	06/24/00	mjn		Added parent CONNECT AsyncOp to DN_Connect()
 *				mjn		Return DPNERR_UNINITIALIZED from DN_Close() if not initialized (called twice)
 *	06/25/00	mjn		Added DNUpdateLobbyStatus(), update status for CONNECTED,DISCONNECTED
 *				mjn		Set DirectNetObject as CONNECTED earlier in DN_Host()
 *	06/26/00	mjn		Replaced DPNADDCLIENTTOGROUP_SYNC DPNADDPLAYERTOGROUP_SYNC
 *				mjn		Replaced DPNREMOVECLIENTFROMGROUP_SYNC with DPNREMOVEPLAYERFROMGROUP_SYNC
 *				mjn		Fixed for() loop counter problem - nested counters used the same variable - DOH !
 *	06/27/00	mjn		Allow priorities to be specified to GetSendQueueInfo() API calls
 *				rmt		Added abstraction for COM_Co(Un)Initialize
 *				mjn		Removed ASSERT player not found in DN_GetPlayerContext()
 *				mjn		Added DPNSEND_NONSEQUENTIAL flag to Send/SendTo
 *				mjn		Allow mix-n-match of priorities in GetSendQueueInfo() API call
 *	07/02/00	mjn		Modified DN_SendTo() to use DNSendGroupMessage()
 *	07/06/00	mjn		Added missing completions for group sends
 *				mjn		Fixed locking problem in CNameTable::MakeLocalPlayer,MakeHostPlayer,MakeAllPlayersGroup
 *				mjn		Turned DPNSEND_NONSEQUENTIAL flag back on in DN_SendTo()
 *				mjn		Use SP handle instead of interface
 *	07/07/00	mjn		Cleanup pNewHost on DirectNetObject at close
 *	07/08/00	mjn		Fixed CAsyncOp to contain m_bilinkParent
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *	07/11/00	mjn		Added NOLOOPBACK capability to group sends
 *				mjn		Fixed DN_EnumHosts() to handle multiple adapters
 *	07/12/00	mjn		Copy user data on EnumHosts()
 *	07/17/00	mjn		Removed redundant SyncEvent->Reset() in DN_Initialize
 *				mjn		Clear DN_OBJECT_FLAG_HOST_CONNECTED in DN_Close()
 *				mjn		Check correct return value of DNSendGroupMessage() in DN_SendTo()
 *  07/19/00    aarono	Bug#39751 add CancelAsyncOperation flag support.
 *	07/20/00	mjn		Cleaned up DN_Connect()
 *  07/21/00    RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *	07/21/00	mjn		Cleaned up DN_Close() to release connection object reference
 *	07/23/00	mjn		Moved assertion in DN_CanceAsyncOperation
 *	07/25/00	mjn		Fail DN_EnumHosts() if no valid device adapters exist
 *	07/26/00	mjn		Fix error codes returned from DN_Connect(),DN_GetSendQueueInfo(),DN_DestroyGroup()
 *						DN_AddClientToGroup(),DN_RemoveClientFromGroup(),DN_SetGroupInfo()
 *						DN_GetGroupInfo(),DN_EnumGroupMembers()
 *				mjn		Fix DN_GetApplicationDesc() to always return buffer size
 *	07/26/00	mjn		Fixed locking problem with CAsyncOp::MakeChild()
 *	07/28/00	mjn		Revised DN_GetSendQueueInfo() to use queue info on CConnection objects
 *				mjn		Cleaned up DN_GetPlayerContext() and DN_GetGroupContext()
 *	07/29/00	mjn		Better clean up of pending Connect()'s during Close()
 *				mjn		Check user data size in DN_EnumHosts()
 *				mjn		Added fUseCachedCaps to DN_SPEnsureLoaded()
 *	07/30/00	mjn		Replaced DN_NAMETABLE_PENDING_OP with CPendingDeletion
 *	07/31/00	mjn		Added hrReason to DNTerminateSession()
 *				mjn		Added dwDestroyReason to DNHostDisconnect()
 *				mjn		Cleaned up DN_TerminateSession()
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2 
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Ensure cancelled operations don't proceed
 *				mjn		Prevent hosting players from calling DN_EnumHosts()
 *				mjn		Generate TERMINATE_SESSION notification for host player
 *	08/06/00	mjn		Added CWorkerJob
 *	08/09/00	mjn		Moved no-loop-back test in DN_SendTo()
 *  08/15/00	rmt		Bug #42506 - DPLAY8: LOBBY: Automatic connection settings not being sent
 *	08/15/00	mjn		Remapped DPNERR_INVALIDENDPOINT from DPNERR_INVALIDPLAYER to DPNERR_NOCONNECTION in DN_SendTo()
 *				mjn		Addef hProtocol to DNRegisterWithDPNSVR() and removed registration from DN_Host()
 *	08/16/00	mjn		Return DPNERR_INVALIDHOSTADDRESS from DN_EnumHosts() if host address is invalid
 *	08/20/00	mjn		Removed fUseCachedCaps from DN_SPEnsureLoaded()
 *	08/23/00	mjn		Flag DirectNetObject as registered with DPNSVR
 *	08/24/00	mjn		Replace DN_NAMETABLE_OP with CNameTableOp
 *	08/29/00	mjn		Remap DPNERR_INVALIDPLAYER to DPNERR_CONNECTIONLOST in DN_SendTo()
 *	09/01/00	masonb		Modified DN_Close to call CloseHandle on hWorkerThread
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/05/00	mjn		Set NameTable DPNID mask when hosting
 *	09/06/00	mjn		Fixed register with DPNSVR problem
 *  09/13/00	rmt		Bug #44625 - DPVOICE: Multihomed machines are not always enumerable
 *						Moved registration for DPNSVR into ListenComplete
 *	09/17/00	mjn		Split CNameTable.m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *	10/11/00	mjn		Take locks for CNameTableEntry::PackInfo()
 *	10/12/00	mjn		Set async handle completion after succeeding in DN_EnumHosts()
 *	10/17/00	mjn		Fixed clean up for unreachable players
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"
#include <xboxverp.h>

extern "C"
{
#pragma comment(linker, "/include:_DPlayBuildNumber")

#pragma data_seg(".XBLD$V")

#ifdef ENABLE_DPLAY_VOICE
#if DBG
unsigned short DPlayBuildNumber[8] = { 'D' | ('P' << 8), 'L' | ('A' << 8), 'Y' | ('8' << 8), 'V' | ('D' << 8),
                                        VER_PRODUCTVERSION | 0x8000 };
#else  // DBG
unsigned short DPlayBuildNumber[8] = { 'D' | ('P' << 8), 'L' | ('A' << 8), 'Y' | ('8' << 8), 'V',
                                        VER_PRODUCTVERSION };
#endif // DBG
#else  // ENABLE_DPLAY_VOICE
#if DBG
unsigned short DPlayBuildNumber[8] = { 'D' | ('P' << 8), 'L' | ('A' << 8), 'Y' | ('8' << 8), 'D',
                                        VER_PRODUCTVERSION | 0x8000 };
#else  // DBG
unsigned short DPlayBuildNumber[8] = { 'D' | ('P' << 8), 'L' | ('A' << 8), 'Y' | ('8' << 8), 0,
                                        VER_PRODUCTVERSION };
#endif // DBG
#endif // ENABLE_DPLAY_VOICE

#pragma data_seg()
}


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

extern DN_PROTOCOL_INTERFACE_VTBL g_ProtocolVTBL;
extern void GlobalInitialize(void);
extern HRESULT GlobalCleanup(void);
extern CThreadPool *g_pThreadPool2;
extern DWORD g_dwGlobalObjectCount;
extern BOOL g_fGlobalObjectInit;
#ifdef DPLAY_DOWORK_STATEMN
extern STMN_ID g_stmnID;
#endif

// BUGBUG: [mgere] [xbox] temporary fix for Close() call blocking
DIRECTNETOBJECT *g_DPlayInterfaces[16] = { NULL };
DNCRITICAL_SECTION g_csDPlayInterfaces;


//**********************************************************************
// Function prototypes
//**********************************************************************

HRESULT DNGetHostAddressHelper(DIRECTNETOBJECT *pdnObject, 
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress);


// Global DPlay Initialization
#undef DPF_MODNAME
#define DPF_MODNAME "DPlayInitialize"

HRESULT WINAPI DPlayInitialize(DWORD dwMaxMemUsage)
{
	g_dwMaxMem = dwMaxMemUsage;

	GlobalInitialize();

        if (!DNInitializeCriticalSection(&g_csDPlayInterfaces))
        {
            DPFERR( "Failed to initialize global critical section" );
            return E_FAIL;
        }

	return S_OK;
}

// Global DPlay Cleanup
#undef DPF_MODNAME
#define DPF_MODNAME "DPlayCleanup"

HRESULT WINAPI DPlayCleanup(void)
{
        DNDeleteCriticalSection(&g_csDPlayInterfaces);

	return GlobalCleanup();
}


#ifdef DPLAY_DOWORK_STATEMN

// State machine handler function
#undef DPF_MODNAME
#define DPF_MODNAME "StateMachineHandler"

HRESULT StateMachineHandler(PSTMN_ASYNC pstmnAsync, DWORD dwFlags)
{
	PDPLAY_STMN_ASYNC pdplaystmnAsync = (PDPLAY_STMN_ASYNC) pstmnAsync;

	pdplaystmnAsync->pDplayObject->DoWork(0);

	return S_OK;
}

#endif


/****************************************************************************
 *
 *  DirectPlay8Create
 *
 *  Description:
 *      Creates and initializes a DirectPlay8Peer object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_MODNAME
#define DPF_MODNAME "DirectPlay8Create"
HRESULT WINAPI
DirectPlay8Create
(
    DWORD dwIID,
    void **ppvInterface,
    void **pUnknown
)
{
    DIRECTNETOBJECT *          pDirectPlay8        = NULL;
    HRESULT                 hr                  = DPN_OK;

    RIP_ON_NOT_TRUE("DirectPlay8Create() pUnknown must be NULL", pUnknown == NULL );
    
    if (g_fGlobalObjectInit == FALSE)
    {
        return E_FAIL;
    }
    
    // Create the DIRECTNETOBJECT object
    if(SUCCEEDED(hr))
    {
        switch (dwIID)
        {
            case IID_IDirectPlay8Peer:
            {
                hr = (pDirectPlay8 = new DIRECTNETOBJECT(DN_OBJECT_FLAG_PEER)) ? S_OK : E_OUTOFMEMORY;
                break;
            }

            case IID_IDirectPlay8Client:
            {
                hr = (pDirectPlay8 = new DIRECTNETOBJECT(DN_OBJECT_FLAG_CLIENT)) ? S_OK : E_OUTOFMEMORY;
                break;
            }

            case IID_IDirectPlay8Server:
            {
                hr = (pDirectPlay8 = new DIRECTNETOBJECT(DN_OBJECT_FLAG_SERVER)) ? S_OK : E_OUTOFMEMORY;
                break;
            }

            default:
            {
                RIP("DirectPlay8Create() dwIID must be one of IID_IDirectPlay8Peer | IID_IDirectPlay8Client | IID_IDirectPlay8Server");
                return E_FAIL;
            }
        }

    }

    // Success
    if(SUCCEEDED(hr))
    {
        hr = pDirectPlay8->ObjectInit();
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *ppvInterface = ADDREF(pDirectPlay8);
        g_dwGlobalObjectCount += 1;
    }

    DNEnterCriticalSection(&g_csDPlayInterfaces);
    for (DWORD i = 0; i < 16; i += 1)
    {
        if (g_DPlayInterfaces[i] == NULL)
        {
            g_DPlayInterfaces[i] = pDirectPlay8;
            break;
        }
    }
    DNLeaveCriticalSection(&g_csDPlayInterfaces);

    // Clean up
    RELEASE(pDirectPlay8);

    return hr;
}




//
//	Store the user-supplied message handler and context value for call backs
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_Initialize"

HRESULT DIRECTNETOBJECT::DN_Initialize(PVOID pInterface,
						   PVOID const pvUserContext,
						   const PFNDPNMESSAGEHANDLER pfn,
						   const DWORD dwFlags)
{
	HRESULT				hResultCode = DPN_OK;
	DIRECTNETOBJECT		*pdnObject = this;
#ifndef DPLAY_DOWORK
	DWORD				dwThreadID;
#endif
	CSyncEvent			*pSyncEvent;
	BOOL				fApplicationDesc;
	BOOL				fNameTable;
	BOOL				fHandleTable;
	BOOL				fProtocol;

	DPF(2,"Parameters: pInterface [0x%p], pvUserContext [0x%p], pfn [0x%p], dwFlags [0x%lx]",
			pInterface,pvUserContext,pfn,dwFlags);

	RIP_ON_NOT_TRUE("Initialize() You must specify a callback function", pfn != NULL );
    	RIP_ON_NOT_TRUE("Initialize() Invalid flags specified", dwFlags == 0 );

    	// Ensure not already initialized
	RIP_ON_NOT_TRUE("Initialize() Initialize has already been called", !(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) );

	fApplicationDesc = FALSE;
	fNameTable = FALSE;
	fHandleTable = FALSE;
	fProtocol = FALSE;
	pSyncEvent = NULL;

	//
	//	Lock DirectNetObject in case someone's trying something funny
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Initialize ApplicationDescription
	//
	if ((hResultCode = pdnObject->ApplicationDesc.Initialize()) != DPN_OK)
	{
		DPFERR("Could not initialize ApplicationDesc");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	fApplicationDesc = TRUE;

	//
	//	Initialize NameTable
	//
	if ((hResultCode = pdnObject->NameTable.Initialize(pdnObject)) != DPN_OK)
	{
		DPFERR("Could not initialize NameTable");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	fNameTable = TRUE;

	//
	//	Initialize HandleTable
	//
	if ((hResultCode = pdnObject->HandleTable.Initialize()) != DPN_OK)
	{
		DPFERR("Could not initialize HandleTable");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	fHandleTable = TRUE;

	//
	//	Initialize protocol and create shut-down event
	//
	DNASSERT(pdnObject->lProtocolRefCount == 0);
	if ((hResultCode = DNPProtocolInitialize( pdnObject, pdnObject->pdnProtocolData, &g_ProtocolVTBL)) != DPN_OK)
	{
		DPFERR("DNPProtocolInitialize() failed");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pdnObject->lProtocolRefCount = 1;
	fProtocol = TRUE;

	DNASSERT( pdnObject->hProtocolShutdownEvent == NULL );
	if ((SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
	{
		DPFERR("Could not get protocol shutdown event");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pdnObject->hProtocolShutdownEvent = pSyncEvent;
	pSyncEvent = NULL;

#ifdef DPLAY_DOWORK
#ifdef DPLAY_DOWORK_STATEMN
	//
	// Xbox:  Add task to state machine handler
	//
	m_stmnAsync.stmnAsync.stmnid		= g_stmnID;
	m_stmnAsync.stmnAsync.wCurrentState	= 0;
	m_stmnAsync.stmnAsync.dwWorkFlags		= XON_ASYNCWORK_DPLAY;
	m_stmnAsync.stmnAsync.hr			= S_OK;
    m_stmnAsync.pDplayObject            = this;

	hResultCode = XONCreateAsyncTask( (PSTMN_ASYNC)&m_stmnAsync );
	if (FAILED(hResultCode))
	{
		// BUGBUG: [mgere] [xbox] Remove this once we get statemachine working
		__asm int 3;
		// E_OUTOFMEMORY can be returned...
	}
#endif
	DNASSERT( pdnObject->m_hWorkerCloseEvent == NULL );
	if ((SyncEventNew(pdnObject,&pSyncEvent)) != DPN_OK)
	{
		DPFERR("Could not get worker close event");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pdnObject->m_hWorkerCloseEvent = pSyncEvent;
	pSyncEvent = NULL;
#else
	//
	//	Spawn worker thread
	//
	DPF(3,"Spawning worker thread");
	if ((pdnObject->hWorkerThread = CreateThread(NULL,0,DNWorkerThreadProc,pdnObject,0,
			&dwThreadID)) == NULL)
	{
		DPFERR("DNPProtocolInitialize() failed");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	DPF(5,"Worker thread id [0x%lx]",dwThreadID);
#endif

	pdnObject->pfnDnUserMessageHandler = pfn;
	pdnObject->pvUserContext = pvUserContext;
	pdnObject->dwFlags |= DN_OBJECT_FLAG_INITIALIZED;

Exit:
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (fApplicationDesc)
	{
		pdnObject->ApplicationDesc.Deinitialize();
	}
	if (fNameTable)
	{
		pdnObject->NameTable.Deinitialize();
	}
	if (fHandleTable)
	{
		pdnObject->HandleTable.Deinitialize();
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (fProtocol)
	{
		DNProtocolRelease(pdnObject);
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_Close"

HRESULT DIRECTNETOBJECT::DN_Close(PVOID pInterface,const DWORD dwFlags)
{
	HRESULT				hResultCode = DPN_OK;
	DIRECTNETOBJECT		*pdnObject = this;
	CBilink				*pBilink;
	CAsyncOp			*pAsyncOp;
	CConnection			*pConnection;
	CPendingDeletion	*pPending;
	BOOL				fWaitForEvent;

	DPF(2,"Parameters: pInterface [0x%p], dwFlags [0x%lx]",pInterface,dwFlags);

	RIP_ON_NOT_TRUE( "Close() Invalid flags", dwFlags == 0 );

	// Ensure already initialized
    	RIP_ON_NOT_TRUE( "Close() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

	pAsyncOp = NULL;
	pConnection = NULL;

    //
	//	Flag as closing.   Make sure this hasn't already been called.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFERR("Already closing" );
		hResultCode = DPNERR_ALREADYCLOSING;
		goto Failure;
	}
	
	pdnObject->dwFlags |= DN_OBJECT_FLAG_CLOSING;
	if (pdnObject->dwLockCount == 0)
	{
		fWaitForEvent = FALSE;
	}
	else
	{
		fWaitForEvent = TRUE;
	}

	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	// XBOX:  Spin through DoWork() to make sure everything is done before closing
	//
	while (DoWork(0) != S_FALSE);

#ifdef	DEBUG
	{
		CNameTableEntry	*pLocalPlayer;

		if (pdnObject->NameTable.GetLocalPlayerRef(&pLocalPlayer) == DPN_OK)
		{
			DPF(0,"Local player was [0x%lx]",pLocalPlayer->GetDPNID());
			pLocalPlayer->Release();
		}
	}
#endif

	//
	//	If there are operations underway, we will wait for them to complete and release the lock count
	//
	if (fWaitForEvent)
	{
		if (WaitForSingleObject(pdnObject->hLockEvent,INFINITE) != WAIT_OBJECT_0)
		{
			DPFERR("WaitForSingleObject() terminated strangely");
			DNASSERT(FALSE);
		}
	}

/*	REMOVE
	//
	//	Shut down listen(s)
	//
	DPF(3,"Checking LISTENs");
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pAsyncOp = pdnObject->pListenParent;
	pdnObject->pListenParent = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pAsyncOp)
	{
		DPF(3,"Canceling LISTENs");
		hResultCode = DNCancelChildren(pdnObject,pAsyncOp);
		DPF(3,"Canceling LISTENs returned [0x%lx]",hResultCode);

		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
*/
	//
	//	Cancel connect
	//
	DPF(3,"Checking CONNECT");
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pAsyncOp = pdnObject->pConnectParent;
	pdnObject->pConnectParent = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pAsyncOp)
	{
		pAsyncOp->Lock();
		pConnection = pAsyncOp->GetConnection();
		pAsyncOp->SetConnection( NULL );
		pAsyncOp->Unlock();

		DPF(3,"Canceling CONNECT");
		hResultCode = DNCancelChildren(pdnObject,pAsyncOp);
		DPF(3,"Canceling CONNECT returned [0x%lx]",hResultCode);

		pAsyncOp->Release();
		pAsyncOp = NULL;

		if (pConnection)
		{
			pConnection->Disconnect();
			pConnection->Release();
			pConnection = NULL;
		}
	}

	//
	//	Remove outstanding ENUMs, SENDs, RECEIVE_BUFFERs
	//
	DPF(3,"Canceling outstanding operations");
	hResultCode = DNCancelActiveCommands(pdnObject,(  DN_CANCEL_FLAG_ENUM_QUERY
													| DN_CANCEL_FLAG_ENUM_RESPONSE
													| DN_CANCEL_FLAG_USER_SEND
													| DN_CANCEL_FLAG_INTERNAL_SEND
													| DN_CANCEL_FLAG_RECEIVE_BUFFER ) );
	DPF(3,"Canceling outstanding operations returned [0x%lx]",hResultCode);

	//
	//	Cancel any REQUESTs
	//
	DPF(3,"Canceling requests");
	hResultCode = DNCancelRequestCommands(pdnObject);
	DPF(3,"Canceling requests returned [0x%lx]",hResultCode);

	//
	//	Terminate session.  This will remove all players from the NameTable
	//
	DPF(3,"Terminate Session");
	if ((hResultCode = DNTerminateSession(pdnObject,DPN_OK)) != DPN_OK)
	{
		DPFERR("Could not terminate session");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
	}

	//
	//	Disconnect any indicated connections
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	while (pdnObject->m_bilinkIndicated.GetNext() != &pdnObject->m_bilinkIndicated)
	{
		pConnection = CONTAINING_OBJECT(pdnObject->m_bilinkIndicated.GetNext(),CConnection,m_bilinkIndicated);
		pConnection->m_bilinkIndicated.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csConnectionList);

		DNASSERT(pConnection->GetDPNID() == 0);

		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;

		DNEnterCriticalSection(&pdnObject->csConnectionList);
	}
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	//
	//	Release SP's
	//
	DPF(3,"Releasing SPs");
	DN_SPReleaseAll(pdnObject);

	//
	//	Shut down protocol
	//
	DPF(3,"Shutting down Protocol");
	DNProtocolRelease(pdnObject);
	pdnObject->hProtocolShutdownEvent->WaitForEvent(INFINITE, this);
	if ((hResultCode = DNPProtocolShutdown(pdnObject->pdnProtocolData)) != DPN_OK)
	{
		DPFERR("Could not shut down Protocol Layer !");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
	}
	pdnObject->hProtocolShutdownEvent->ReturnSelfToPool();
	pdnObject->hProtocolShutdownEvent = NULL;


#ifdef DPLAY_DOWORK
#ifdef DPLAY_DOWORK_STATEMN
	hResultCode = XONCancelAsyncTask( (PSTMN_ASYNC)&m_stmnAsync );
	if (FAILED(hResultCode))
	{
		// BUGBUG: [mgere] [xbox] Remove this once we get statemachine working
		__asm int 3;
		// E_OUTOFMEMORY can be returned...
	}
#endif
	DNWTTerminate(pdnObject);
	pdnObject->m_hWorkerCloseEvent->WaitForEvent(INFINITE, this);
	pdnObject->m_hWorkerCloseEvent->ReturnSelfToPool();
	pdnObject->m_hWorkerCloseEvent = NULL;
#else
	//
	//	Shut down worker thread
	//
	if (pdnObject->hWorkerThread)
	{
		DPF(3,"Terminating Worker Thread");
		DNWTTerminate(pdnObject);
		WaitForSingleObject(pdnObject->hWorkerThread,INFINITE);
		CloseHandle(pdnObject->hWorkerThread);
		pdnObject->hWorkerThread = NULL;
	}
#endif

	//
	//	Deinitialize HandleTable
	//
	DPF(3,"Deinitializing HandleTable");
	pdnObject->HandleTable.Deinitialize();

	//
	//	Deinitialize NameTable
	//
	DPF(3,"Deinitializing NameTable");
	pdnObject->NameTable.Deinitialize();

	//
	//	Deinitialize ApplicationDescription
	//
	DPF(3,"Deinitializing ApplicationDesc");
	pdnObject->ApplicationDesc.Deinitialize();

	//
	//	Any pending NameTable operations
	//
	pBilink = pdnObject->m_bilinkPendingDeletions.GetNext();
	while (pBilink != &pdnObject->m_bilinkPendingDeletions)
	{
		pPending = CONTAINING_OBJECT(pBilink,CPendingDeletion,m_bilinkPendingDeletions);
		pBilink = pBilink->GetNext();
		pPending->m_bilinkPendingDeletions.RemoveFromList();
		pPending->ReturnSelfToPool();
		pPending = NULL;
	}

	//
	//	Misc Clean Up
	//
	if (pdnObject->pIDP8ADevice)
	{
		pdnObject->pIDP8ADevice->Release();
		pdnObject->pIDP8ADevice = NULL;
	}
	if (pdnObject->pvConnectData)
	{
		DNFree(pdnObject->pvConnectData);
		pdnObject->pvConnectData = NULL;
		pdnObject->dwConnectDataSize = 0;
	}

	if( pdnObject->pConnectAddress )
	{
		pdnObject->pConnectAddress->Release();
		pdnObject->pConnectAddress = NULL;
	}

	if( pdnObject->pTargetList )
	{
		delete [] pdnObject->pTargetList;
		pdnObject->pTargetList = NULL;
	}

	if( pdnObject->pExpandedTargetList )
	{
		delete [] pdnObject->pExpandedTargetList;
		pdnObject->pExpandedTargetList = NULL;
	}	

	//
	//	Reset DirectNet object flag
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~( DN_OBJECT_FLAG_INITIALIZED
							| DN_OBJECT_FLAG_CLOSING
							| DN_OBJECT_FLAG_DISCONNECTING
							| DN_OBJECT_FLAG_HOST_CONNECTED
							| DN_OBJECT_FLAG_LOCALHOST ));
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}


//
// XBox: DoWork function.  Spins through work like the threads used to.
//

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECTNETOBJECT::DoWork"

HRESULT DIRECTNETOBJECT::DoWork( const DWORD dwFlags )
{
	HRESULT hr = S_FALSE;
#ifdef DPLAY_DOWORK
	DIRECTNETOBJECT    *pdnObject = this;
	DWORD dwNoMoreWork = 1;

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED) )
    	{
    	    DPF(1,"DoWork:  DPlay object is not initialized." );
    	    DPF_RETURN( DPNERR_UNINITIALIZED );
    	}    	

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);

        PeriodicTimer();
	while (TimerWorkerThread() == 0);

	if (g_pThreadPool2 != NULL)
	{
		dwNoMoreWork = g_pThreadPool2->PrimaryWin9xThread();
	}

	if (dwNoMoreWork)
	{
	dwNoMoreWork = DNWorkerThreadProc();
	}

	if ( dwNoMoreWork )
	{
		hr = S_FALSE;
	}
	else
	{
		hr = S_OK;
	}

	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
#endif

	return hr;
}


//
// Enumerate SP's if no SPGUID supplied, or SP Adapters if an SPGUID is supplied
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumServiceProviders"

HRESULT DIRECTNETOBJECT::DN_EnumServiceProviders( PVOID pInterface,
									  const GUID *const pguidServiceProvider,
									  const GUID *const pguidApplication,
									  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
									  DWORD *const pcbEnumData,
									  DWORD *const pcReturned,
									  const DWORD dwFlags )
{
	HRESULT		        hResultCode;
	DIRECTNETOBJECT    *pdnObject = this;

	DPF(2,"Parameters: pInterface [0x%p], pguidServiceProvider [0x%p], pguidApplication [0x%p], pSPInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p], dwFlags [0x%lx]",
		pInterface,pguidServiceProvider,pguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned,dwFlags);

	RIP_ON_NOT_TRUE( "EnumServiceProviders() Error validating params", SUCCEEDED( DN_ValidateEnumServiceProviders( pInterface, pguidServiceProvider, pguidApplication,
                                                                       pSPInfoBuffer, pcbEnumData, pcReturned, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "EnumServiceProviders() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    if (pguidServiceProvider == NULL)	// Enumerate all service providers
	{
		hResultCode = DN_EnumSP(pdnObject,dwFlags,pguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);
	}
	else	// Service provider specified - enumerate adaptors
	{
		hResultCode = DPNERR_UNSUPPORTED;
	}

	DPF(3,"Set: *pcbEnumData [%ld], *pcReturned [%ld]",*pcbEnumData,*pcReturned);

	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//
//	Cancel an outstanding Async Operation.  hAsyncHandle is the operation handle returned when
//	the operation was initiated.
//

#undef DPF_MODNAME
#define DPF_MODNAME "DN_CancelAsyncOperation"

HRESULT DIRECTNETOBJECT::DN_CancelAsyncOperation(PVOID pvInterface,
									 const DPNHANDLE hAsyncOp,
									 const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CAsyncOp			*pHandleParent;
	CAsyncOp			*pAsyncOp;
	DIRECTNETOBJECT		*pdnObject = this;

	DPF(2,"Parameters: pvInterface [0x%p], hAsyncOp [0x%lx], dwFlags [0x%lx]",
			pvInterface,hAsyncOp,dwFlags);

	RIP_ON_NOT_TRUE( "CancelAsyncOperation() Error validating params", SUCCEEDED( DN_ValidateCancelAsyncOperation( pvInterface, hAsyncOp, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "CancelAsyncOperation() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

	//
	//	If hAsyncOp is specified, we will cancel it.  Otherwise, we will rely on the flags to
	//	determine which operations to cancel.
	//
	if( hAsyncOp )
	{
		//
		//	Cancel single operation
		//

		pHandleParent = NULL;
		pAsyncOp = NULL;

		if ((hResultCode = pdnObject->HandleTable.Find(hAsyncOp,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Invalid USER Handle specified");
			hResultCode = DPNERR_INVALIDHANDLE;
			goto Failure;
		}
		if ( pHandleParent->GetOpType() != ASYNC_OP_USER_HANDLE )
		{
			DPFERR("Invalid USER Handle specified");
			hResultCode = DPNERR_INVALIDHANDLE;
			goto Failure;
		}

		hResultCode = DNCancelChildren(pdnObject,pHandleParent);

		pHandleParent->Release();
		pHandleParent = NULL;
	}
	else
	{
		DWORD	dwInternalFlags;
		HRESULT	hr;

		//
		//	Cancel many operations based on flags
		//

		//
		//	Re-map flags
		//
		dwInternalFlags = 0;
		if (dwFlags & DPNCANCEL_ALL_OPERATIONS)
		{
			dwInternalFlags = (	DN_CANCEL_FLAG_CONNECT | DN_CANCEL_FLAG_ENUM_QUERY | DN_CANCEL_FLAG_USER_SEND );
		}
		else if (dwFlags & DPNCANCEL_CONNECT)
		{
			dwInternalFlags = DN_CANCEL_FLAG_CONNECT;
		}
		else if (dwFlags & DPNCANCEL_ENUM)
		{
			dwInternalFlags = DN_CANCEL_FLAG_ENUM_QUERY;
		}
		else if (dwFlags & DPNCANCEL_SEND)
		{
			dwInternalFlags = DN_CANCEL_FLAG_USER_SEND;
		}
		else
		{
			DNASSERT(FALSE);	// Should never get here
		}
		DPF(3,"Re-mapped internal flags [0x%lx]",dwInternalFlags);

		//
		//	Pre-set error code
		hResultCode = DPN_OK;

		//
		//	To cancel a CONNECT, look at the DirectNetObject
		//
		if (dwInternalFlags & DN_CANCEL_FLAG_CONNECT)
		{
			DNEnterCriticalSection(&pdnObject->csDirectNetObject);
			if (pdnObject->pConnectParent)
			{
				if (pdnObject->pConnectParent->IsChild())
				{
					DNASSERT(pdnObject->pConnectParent->GetParent() != NULL);
					pdnObject->pConnectParent->GetParent()->AddRef();
					pAsyncOp = pdnObject->pConnectParent->GetParent();
				}
				else
				{
					pdnObject->pConnectParent->AddRef();
					pAsyncOp = pdnObject->pConnectParent;
				}
			}
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

			if (pAsyncOp)
			{
				DPF(3,"Canceling CONNECT");
				hr = DNCancelChildren(pdnObject,pAsyncOp);
				if (hr != DPN_OK)
				{
					hResultCode = DPNERR_CANNOTCANCEL;
					DPF(7,"Remapping: [0x%lx] returned by DNCancelChildren to: [0x%lx]",hr, hResultCode);
				}
				pAsyncOp->Release();
				pAsyncOp = NULL;
			}
		}

		//
		//	To cancel ENUMs and SENDs, cancel out of the active list
		//
		if (dwInternalFlags & (DN_CANCEL_FLAG_ENUM_QUERY | DN_CANCEL_FLAG_USER_SEND))
		{
			DPF(3,"Canceling ENUMs and SENDs");
			hr = DNCancelActiveCommands(pdnObject,dwInternalFlags);
			if (hr != DPN_OK)
			{
				hResultCode = DPNERR_CANNOTCANCEL;
				DPF(7,"Remapping: [0x%lx] returned by DNCancelActiveCommands to: [0x%lx]",hr, hResultCode);
			}
		}
	}

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_Connect"

HRESULT DIRECTNETOBJECT::DN_Connect( PVOID pInterface,
						 const DPN_APPLICATION_DESC *const pdnAppDesc,
						 IDirectPlay8Address *const pHostAddr,
						 IDirectPlay8Address *const pDeviceInfo,
						 const DPN_SECURITY_DESC *const pdnSecurity,
						 const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
						 const void *const pvUserConnectData,
						 const DWORD dwUserConnectDataSize,
						 void *const pvPlayerContext,
						 void *const pvAsyncContext,
						 DPNHANDLE *const phAsyncHandle,
						 const DWORD dwFlags)
{
	CAsyncOp			*pHandleParent;
	CAsyncOp			*pConnectParent;
	CAsyncOp			*pAsyncOp;
	HRESULT				hResultCode;
	DIRECTNETOBJECT		*pdnObject = this;
	CSyncEvent			*pSyncEvent;
	HRESULT	volatile	hrOperation;
	IDirectPlay8Address	*pIHost;
	IDirectPlay8Address	*pIDevice;
	IDirectPlay8Address	*pIAdapter;
	DWORD				dwConnectFlags;
//	DWORD				dw;
	GUID				guidSP;
	GUID				guidAdapter;
	void				*pvConnectData;
	void				*pvAdapterBuffer;
//	DWORD				dwAdapterBufferSize;
//	DWORD				dwAdapterBufferCount;
//	DPN_SERVICE_PROVIDER_INFO	*pSPInfo;
	DPN_SP_CAPS			dnSPCaps;
	DN_CONNECT_OP_DATA	*pConnectOpData;
	CRefCountBuffer		*pReply;

	DPF(2,"Parameters: pInterface [0x%p], pdnAppDesc [0x%p], pHostAddr [0x%p], pDeviceInfo [0x%p], pdnSecurity [0x%p], pdnCredentials [0x%p], pvUserConnectData [0x%p], dwUserConnectDataSize [%ld], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
		pInterface,pdnAppDesc,pHostAddr,pDeviceInfo,pdnSecurity,pdnCredentials,pvUserConnectData,dwUserConnectDataSize,pvAsyncContext,phAsyncHandle,dwFlags);

	RIP_ON_NOT_TRUE( "Connect() Error validating connect params", SUCCEEDED( DN_ValidateConnect( pInterface, pdnAppDesc, pHostAddr, pDeviceInfo,
                                                          pdnSecurity, pdnCredentials, pvUserConnectData,
                                                          dwUserConnectDataSize,pvPlayerContext,
                                                          pvAsyncContext,phAsyncHandle,dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "Connect() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	// Check to ensure not already connected/connecting
    	DNEnterCriticalSection(&pdnObject->csDirectNetObject);

    	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING)
    	{
    		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
    		DPFERR( "Object is already connecting" );
    		DPF_RETURN(DPNERR_CONNECTING);
    	}
    	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
    	{
    		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
    		DPFERR( "Object is already connected" );
    		DPF_RETURN(DPNERR_ALREADYCONNECTED);
    	}
		if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
		{
    		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
    		DPFERR( "Object is closing or disconnecting" );
    		DPF_RETURN(DPNERR_ALREADYCLOSING);
		}
    	pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTING;
    	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	
	// Preset these so that they are properly cleaned up
	pIHost = NULL;
	pIDevice = NULL;
	pIAdapter = NULL;
	pSyncEvent = NULL;
	pHandleParent = NULL;
	pConnectParent = NULL;
	pAsyncOp = NULL;
	pvConnectData = NULL;
	pvAdapterBuffer = NULL;
	hrOperation = DPNERR_GENERIC;
	pConnectOpData = NULL;
	pReply = NULL;

	if ((hResultCode = pHostAddr->Duplicate(&pIHost)) != DPN_OK)
	{
		DPFERR("Could not duplicate host address");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Duplicate specified Device Address, or create a blank one if NULL
	//
	if (pDeviceInfo != NULL)
	{
		if ((hResultCode = pDeviceInfo->Duplicate(&pIDevice)) != DPN_OK)
		{
			DPFERR("Could not duplicate device info");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
		if ((hResultCode = DirectPlay8AddressCreate( IID_IDirectPlay8Address, (void **) &pIDevice, NULL)) != S_OK)
		{
			DPFERR("Could not create Device Address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	//
	//	Get SP caps
	//
	if ((hResultCode = DNGetActualSPCaps(pdnObject,&guidSP,&dnSPCaps)) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Update DirectNet Application Description
	//
	pdnObject->ApplicationDesc.Lock();
	hResultCode = pdnObject->ApplicationDesc.Update(pdnAppDesc,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	pdnObject->ApplicationDesc.Unlock();

	// Connect flags to Protocol
	dwConnectFlags = 0;

	//
	//	Create parent async op, which will be released when the ENTIRE connection is finished
	//	including nametable transfer and installation on the local machine
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pConnectParent)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pConnectParent->SetOpType( ASYNC_OP_CONNECT );
	pConnectParent->MakeParent();
	pConnectParent->SetContext( pvPlayerContext );
	pConnectParent->SetResult( DPNERR_NOCONNECTION );
	pConnectParent->SetCompletion( DNCompleteConnectOperation );
	pConnectParent->SetReserved(1);

		DPF(5,"Async operation - create handle parent");
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create handle parent");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pHandleParent->SetContext( pvAsyncContext );

		pHandleParent->Lock();
		if (pHandleParent->IsCancelled())
		{
			pHandleParent->Unlock();
			pConnectParent->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pConnectParent->MakeChild( pHandleParent );
		pHandleParent->Unlock();

	//
	//	We will need a parent op for the CONNECTs to help with clean up when the initial CONNECT stage is done
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not create CONNECT parent");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_CONNECT );
	pAsyncOp->MakeParent();
	pAsyncOp->SetResult( DPNERR_NOCONNECTION );
	pAsyncOp->SetCompletion( DNCompleteConnectToHost );
	pAsyncOp->SetOpFlags( dwConnectFlags );

	pConnectParent->Lock();
	if (pConnectParent->IsCancelled())
	{
		pConnectParent->Unlock();
		pAsyncOp->SetResult( DPNERR_USERCANCEL );
		hResultCode = DPNERR_USERCANCEL;
		goto Failure;
	}
	pAsyncOp->MakeChild( pConnectParent );
	pConnectParent->Unlock();

	//
	//	Save CONNECT data (if supplied)
	//
	if (pvUserConnectData && dwUserConnectDataSize)
	{
		if ((pvConnectData = DNMalloc(dwUserConnectDataSize)) == NULL)
		{
			DPFERR("Could not allocate CONNECT data buffer");
			DNASSERT(FALSE);
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		memcpy(pvConnectData,pvUserConnectData,dwUserConnectDataSize);
	}

	//
	//	Update DirectNet object with relevant data
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pConnectParent->AddRef();
	pdnObject->pConnectParent = pConnectParent;
	if (pvConnectData)
	{
		pdnObject->pvConnectData = pvConnectData;
		pdnObject->dwConnectDataSize = dwUserConnectDataSize;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		if ((pConnectOpData = static_cast<DN_CONNECT_OP_DATA*>(MemoryBlockAlloc(pdnObject,sizeof(DN_CONNECT_OP_DATA)))) == NULL)
		{
			DPFERR("Could not allocate CONNECT op data block");
			hResultCode = DPNERR_OUTOFMEMORY;
			DNASSERT(FALSE);
			goto Failure;
		}
		pConnectOpData->dwNumAdapters = 0;
		pConnectOpData->dwCurrentAdapter = 0;

	pAsyncOp->SetOpData( pConnectOpData );

	pdnObject->pConnectAddress = pIHost;
	pdnObject->pConnectAddress->AddRef();

	//
	//	CONNECT !
	//
	hResultCode = DNPerformConnect(	pdnObject,
									NULL,
									pIDevice,
									pIHost,
									pAsyncOp->GetOpFlags(),
									pAsyncOp);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not connect");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;
	pConnectParent->Release();
	pConnectParent = NULL;

	pIHost->Release();
	pIHost = NULL;
	pIDevice->Release();
	pIDevice = NULL;

		pHandleParent->SetCompletion( DNCompleteUserConnect );
		if (phAsyncHandle)
		{
			*phAsyncHandle = pHandleParent->GetHandle();
		}
		pHandleParent->Release();
		pHandleParent = NULL;

		hResultCode = DPNERR_PENDING;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:

	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pConnectParent)
	{
		if (pConnectParent->GetHandle())
		{
			pdnObject->HandleTable.Destroy(pConnectParent->GetHandle());
		}
		pConnectParent->Release();
		pConnectParent = NULL;
	}
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pIHost)
	{
		pIHost->Release();
		pIHost = NULL;
	}
	if (pIDevice)
	{
		pIDevice->Release();
		pIDevice = NULL;
	}
	if (pIAdapter)
	{
		pIAdapter->Release();
		pIAdapter = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (pvAdapterBuffer)
	{
		DNFree(pvAdapterBuffer);
		pvAdapterBuffer = NULL;
	}

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pIDP8AEnum)
	{
		pdnObject->pIDP8AEnum->Release();
		pdnObject->pIDP8AEnum = NULL;
	}
	if (pdnObject->pIDP8ADevice)
	{
		pdnObject->pIDP8ADevice->Release();
		pdnObject->pIDP8ADevice = NULL;
	}
	if (pdnObject->pvConnectData)
	{
		DNFree(pdnObject->pvConnectData);
		pdnObject->pvConnectData = NULL;
		pdnObject->dwConnectDataSize = 0;
	}
	if( pdnObject->pConnectAddress )
	{
		pdnObject->pConnectAddress->Release();
		pdnObject->pConnectAddress = NULL;
	}
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTING);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	goto Exit;
}


//	DN_GetSendQueueInfo
//
//	Get info about the user send queue.
//	This will find the CConnection for a given player and extract the required queue infor from it.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetSendQueueInfo"

HRESULT DIRECTNETOBJECT::DN_GetSendQueueInfo(PVOID pInterface,
								 const DPNID dpnid,
								 DWORD *const pdwNumMsgs,
								 DWORD *const pdwNumBytes,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	DWORD				dwQueueFlags;
	DWORD				dwNumMsgs;
	DWORD				dwNumBytes;
	CNameTableEntry     *pNTEntry;
	CConnection			*pConnection;
	HRESULT				hResultCode;

	DPF(2,"Parameters : pInterface [0x%p], dpnid [0x%lx], pdwNumMsgs [0x%p], pdwNumBytes [0x%p], dwFlags [0x%lx]",
		pInterface,dpnid,pdwNumMsgs,pdwNumBytes,dwFlags);

	RIP_ON_NOT_TRUE( "GetSendQueueInfo() Error validating params", SUCCEEDED( DN_ValidateGetSendQueueInfo( pInterface, pdwNumMsgs, pdwNumBytes, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "GetSendQueueInfo() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    		DPFERR( "Object is already connecting" );
    		DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED ) )
    	{
    	    DPFERR("Object is not connected" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}    	

	pNTEntry = NULL;
	pConnection = NULL;

	//
    //	Validate specified player ID and get CConnection
	//
	if((hResultCode = pdnObject->NameTable.FindEntry( dpnid, &pNTEntry )))
	{
		DPF(0,"Could not find Player ID [0x%lx] in NameTable", dpnid );
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find entry in deleted list either");
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	if (pNTEntry->IsLocal() || pNTEntry->IsGroup())
	{
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Determine required queues
	//
	dwQueueFlags = dwFlags & (DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_LOW);
	if (dwQueueFlags == 0)
	{
		dwQueueFlags = (DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_LOW);
	}

	//
	//	Extract required info
	//
	dwNumMsgs = 0;
	dwNumBytes = 0;
	pConnection->Lock();
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_HIGH)
	{
		dwNumMsgs += pConnection->GetHighQueueNum();
		dwNumBytes += pConnection->GetHighQueueBytes();
	}
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_NORMAL)
	{
		dwNumMsgs += pConnection->GetNormalQueueNum();
		dwNumBytes += pConnection->GetNormalQueueBytes();
	}
	if (dwQueueFlags & DPNGETSENDQUEUEINFO_PRIORITY_LOW)
	{
		dwNumMsgs += pConnection->GetLowQueueNum();
		dwNumBytes += pConnection->GetLowQueueBytes();
	}
	pConnection->Unlock();
	pConnection->Release();
	pConnection = NULL;

	if (pdwNumMsgs)
	{
		*pdwNumMsgs = dwNumMsgs;
		DPF(3,"Setting: *pdwNumMsgs [%ld]",dwNumMsgs);
	}
	if (pdwNumBytes)
	{
		*pdwNumBytes = dwNumBytes;
		DPF(3,"Setting: *pdwNumBytes [%ld]",dwNumBytes);
	}

	hResultCode = DPN_OK;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetApplicationDesc"

HRESULT DIRECTNETOBJECT::DN_GetApplicationDesc(PVOID pInterface,
								   DPN_APPLICATION_DESC *const pAppDescBuffer,
								   DWORD *const pcbDataSize,
								   const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	HRESULT				hResultCode;
	CPackedBuffer		packedBuffer;

	DPF(2,"Parameters: pInterface [0x%p], pAppDescBuffer [0x%p], pcbDataSize [0x%p], dwFlags [0x%lx]",
			pInterface,pAppDescBuffer,pcbDataSize,dwFlags);

	RIP_ON_NOT_TRUE( "GetApplicationDesc() Failed validation getappdesc", SUCCEEDED( DN_ValidateGetApplicationDesc( pInterface, pAppDescBuffer, pcbDataSize, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "GetApplicationDesc() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("Object is not connected or hosting" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}    	

	//
	//	Initialize PackedBuffer
	//
	packedBuffer.Initialize(static_cast<void*>(pAppDescBuffer),*pcbDataSize);

	//
	//	Try to pack in the application description.
	//	If it won't fit, the required size will be in the PackedBuffer.
	//
	hResultCode = pdnObject->ApplicationDesc.Pack(&packedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);

	//
	//	Ensure we know what's going on
	//
	if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_BUFFERTOOSMALL))
	{
		DPFERR("Unknown error occurred packing application description");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_GENERIC;
		goto Failure;
	}

	//
	//	Size of buffer
	//
	*pcbDataSize = packedBuffer.GetSizeRequired();

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetApplicationDesc"

HRESULT DIRECTNETOBJECT::DN_SetApplicationDesc(PVOID pInterface,
								   const DPN_APPLICATION_DESC *const pdnApplicationDesc,
								   const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	HRESULT				hResultCode = DPN_OK;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	CWorkerJob			*pWorkerJob;
	DWORD				dwAppDescInfoSize;
	DWORD				dwEnumFrameSize;
	DPN_BUFFER_DESC		*pdnBufferDesc;
	CNameTableEntry     *pNTEntry;

	DPF(2,"Parameters: pInterface [0x%p], pdnApplicationDesc [0x%p], dwFlags [0x%lx]",
			pInterface,pdnApplicationDesc,dwFlags);

	RIP_ON_NOT_TRUE( "SetApplicationDesc() Error validating setappdesc params", SUCCEEDED( DN_ValidateSetApplicationDesc( pInterface, pdnApplicationDesc, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "SetApplicationDesc() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR( "Object has not yet completed connecting / hosting" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if ( !DN_CHECK_LOCALHOST( pdnObject ) )
    	{
    	    DPFERR("Object is not connected or hosting" );
    	    DPF_RETURN(DPNERR_NOTHOST);
    	}

	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pWorkerJob = NULL;

	//
	//	This can only be called by the host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pNTEntry )) != DPN_OK)
	{
		DPFERR("Could not get local player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	if (!pNTEntry->IsHost())
	{
		DPFERR("Not Host player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Determine max allowable enum frame size by examining the SPCaps for each SP
	//
	if ((hResultCode = DNGetMaxEnumFrameSize(pdnObject,&dwEnumFrameSize)) != DPN_OK)
	{
		DPFERR("Could not determine enum frame size");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	DNASSERT( dwEnumFrameSize >= (sizeof(DN_ENUM_RESPONSE_PAYLOAD) + sizeof(DPN_APPLICATION_DESC_INFO)) );
	if (dwEnumFrameSize < (sizeof(DN_ENUM_RESPONSE_PAYLOAD) + sizeof(DPN_APPLICATION_DESC_INFO) + pdnApplicationDesc->dwApplicationReservedDataSize))
	{
		DPFERR("Not enough room for the application reserved data");
		hResultCode = DPNERR_DATATOOLARGE;
		goto Failure;
	}

	//
	//	Update Host player's application desc first
	//
	pdnObject->ApplicationDesc.Lock();
	if (pdnApplicationDesc->dwMaxPlayers > 0)
	{
		if (pdnApplicationDesc->dwMaxPlayers < pdnObject->ApplicationDesc.GetCurrentPlayers())
		{
			DPFERR("Cannot set max players to less than the current number of players");
			pdnObject->ApplicationDesc.Unlock();
			hResultCode = DPNERR_SESSIONFULL;
			goto Failure;
		}
	}
	hResultCode = pdnObject->ApplicationDesc.Update(pdnApplicationDesc,DN_APPDESCINFO_FLAG_SESSIONNAME|
			DN_APPDESCINFO_FLAG_PASSWORD|DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	pdnObject->ApplicationDesc.Unlock();
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not update Application Desciption");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Inform host application
	//
	hResultCode = DNUserUpdateAppDesc(pdnObject);

	//
	//	Get Application Description Info size
	//
	packedBuffer.Initialize(NULL,0);
	hResultCode = pdnObject->ApplicationDesc.PackInfo(&packedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	DNASSERT(hResultCode == DPNERR_BUFFERTOOSMALL);
	dwAppDescInfoSize = packedBuffer.GetSizeRequired();

	//
	//	Create packed buffer to send to other players
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,dwAppDescInfoSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create CountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	hResultCode = pdnObject->ApplicationDesc.PackInfo(&packedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not pack Application Description into EnumBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Notify other players
	//
	DPF(5,"Adding UpdateApplicationDesc to Job Queue");
	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) == DPN_OK)
	{
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
		pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC );
		pWorkerJob->SetSendNameTableOperationVersion( 0 );
		pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;
	}
	else
	{
		DPFERR("Could not create worker job - ignore and continue");
		DisplayDNError(0,hResultCode);
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNTerminateSession"

HRESULT DNTerminateSession(DIRECTNETOBJECT *const pdnObject,
						   const HRESULT hrReason)
{
	HRESULT		hResultCode;
	BOOL		fWasConnected;
	CAsyncOp	*pAsyncOp;

	DPF(4,"Parameters: hrReason [0x%lx]",hrReason);

	DNASSERT(pdnObject != NULL);
	DNASSERT( (hrReason == DPN_OK) || (hrReason == DPNERR_HOSTTERMINATEDSESSION) || (hrReason == DPNERR_CONNECTIONLOST));

	pAsyncOp = NULL;

	//
	//	Shut down listen(s)
	//
	DPF(3,"Checking LISTENs");
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pAsyncOp = pdnObject->pListenParent;
	pdnObject->pListenParent = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pAsyncOp)
	{
		DPF(3,"Canceling LISTENs");
		hResultCode = DNCancelChildren(pdnObject,pAsyncOp);
		DPF(3,"Canceling LISTENs returned [0x%lx]",hResultCode);

		pAsyncOp->Release();
		pAsyncOp = NULL;
	}

	//
	//	Flag DirectNetObject as disconnecting.  This flag will be cleared when Close() finishes.
	//
	fWasConnected = FALSE;
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
		fWasConnected = TRUE;
		pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTED);
	}
#pragma BUGBUG( minara,"How usefull is this DN_OBJECT_FLAG_DISCONNECTING flag ?" )
	pdnObject->dwFlags |= DN_OBJECT_FLAG_DISCONNECTING;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

#ifdef ENABLE_DPLAY_VOICE
	//
	//	Notify Voice
	//
	Voice_Notify( pdnObject, DVEVENT_STOPSESSION, 0, 0 );
#endif

	//
	//	Remove host migration target
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pNewHost)
	{
		pdnObject->pNewHost->Release();
		pdnObject->pNewHost = NULL;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Delete all players from NameTable.  This will involve
	//	emptying the table and removing short-cut player pointers
	//
	DPF(5,"Removing players from NameTable");
	pdnObject->NameTable.EmptyTable(hrReason);

	//
	//	Clean up NameTable operation list
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		DPF(5,"Cleaning up NameTable operation list");
		DNNTRemoveOperations(pdnObject,0,TRUE);
	}

	hResultCode = DPN_OK;

	DNASSERT(pAsyncOp == NULL);

	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_SendTo"

HRESULT DIRECTNETOBJECT::DN_SendTo( PVOID pv,
						const DPNID dpnid,
						const DPN_BUFFER_DESC *const prgBufferDesc,
						const DWORD cBufferDesc,
						const DWORD dwTimeOut,
						void *const pvAsyncContext,
						DPNHANDLE *const phAsyncHandle,
						const DWORD dwFlags)
{
	HRESULT				hResultCode;
	HRESULT				hrSend;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pLocalPlayer;
	DIRECTNETOBJECT		*pdnObject = this;
	DPNHANDLE			hParentOp;
	DWORD				dwSendFlags;
	CSyncEvent			*pSyncEvent;
	const DPN_BUFFER_DESC		*pActualBufferDesc;
	CRefCountBuffer		*pRefCountBuffer;
	DPNHANDLE			handle;
	CAsyncOp			*pAsyncOp;
	CAsyncOp			*pParent;
	CAsyncOp			*pHandleParent;
	CConnection			*pConnection;

	DPF(2,"Parameters: dpnid [0x%lx], prgBufferDesc [0x%p], dwTimeOut [%ld], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			dpnid,prgBufferDesc,dwTimeOut,pvAsyncContext,phAsyncHandle,dwFlags);

	RIP_ON_NOT_TRUE( "SendTo() Error validating common send params", SUCCEEDED( hResultCode = DN_ValidateSendParams( pv , prgBufferDesc, cBufferDesc, dwTimeOut, pvAsyncContext, phAsyncHandle, dwFlags ) ) );

        // Check to ensure message handler registered
	RIP_ON_NOT_TRUE( "SendTo() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR( "Object has not yet completed connecting / hosting" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("Object is not connected or hosting" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}

	pRefCountBuffer = NULL;
	pSyncEvent = NULL;
	pNTEntry = NULL;
	pLocalPlayer = NULL;
	pAsyncOp = NULL;
	pParent = NULL;
	pHandleParent = NULL;
	pConnection = NULL;
	handle = 0;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pNTEntry )) != DPN_OK)
		{
			DPFERR("Could not find Host player");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
	}
	else
	{
		if (dpnid == 0)
		{
			if ((hResultCode = pdnObject->NameTable.GetAllPlayersGroupRef( &pNTEntry )) != DPN_OK)
			{
				DPFERR("Unable to get all players group");
				DisplayDNError(0,hResultCode);
				hResultCode = DPNERR_INVALIDGROUP;
				goto Failure;
			}
		}
		else
		{
			if (dwFlags & DPNSEND_NOLOOPBACK)
			{
				if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
				{
					DPFERR("Could not get local player reference");
					DisplayDNError(0,hResultCode);
					hResultCode = DPNERR_GENERIC;
					goto Failure;
				}
				if (dpnid == pLocalPlayer->GetDPNID())
				{
					hResultCode = DPNERR_INVALIDPARAM;
					goto Failure;
				}
				pLocalPlayer->Release();
				pLocalPlayer = NULL;
			}

			if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
			{
				DPFERR("Unable to find target player or group");
				DisplayDNError(0,hResultCode);
				//
				//	Try deleted list
				//
				if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
				{
					DPFERR("Could not find target in deleted list either");
					hResultCode = DPNERR_INVALIDPLAYER;
					goto Failure;
				}
				pNTEntry->Release();
				pNTEntry = NULL;

				//
				//	Target was found, but is not reachable
				//
				hResultCode = DPNERR_CONNECTIONLOST;
				goto Failure;
			}
		}
	}

	if (!(dwFlags & (DPNSEND_NOCOPY | DPNSEND_COMPLETEONPROCESS)))
	{
		if ((hResultCode = RefCountBufferNew(pdnObject,prgBufferDesc->dwBufferSize,&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not allocate buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pActualBufferDesc = pRefCountBuffer->BufferDescAddress();
		memcpy(pActualBufferDesc->pBufferData,prgBufferDesc->pBufferData,prgBufferDesc->dwBufferSize);
	}
	else
	{
		pRefCountBuffer = NULL;
		pActualBufferDesc = prgBufferDesc;
	}

	dwSendFlags = 0;
	if (dwFlags & DPNSEND_GUARANTEED)
	{
		dwSendFlags |= DN_SENDFLAGS_RELIABLE;
	}
	if (dwFlags & DPNSEND_NONSEQUENTIAL)
	{
		dwSendFlags |= DN_SENDFLAGS_NON_SEQUENTIAL;
	}
	if (dwFlags & DPNSEND_PRIORITY_HIGH)
	{
		dwSendFlags |= DN_SENDFLAGS_HIGH_PRIORITY;
	}
	if (dwFlags & DPNSEND_PRIORITY_LOW)
	{
		dwSendFlags |= DN_SENDFLAGS_LOW_PRIORITY;
	}
		//
		//	Create Handle for ASYNC operation
		//
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		pHandleParent->SetContext( pvAsyncContext );
		pHandleParent->SetStartTime( timeGetTime() );
		handle = pHandleParent->GetHandle();

	if (pNTEntry->IsGroup())
	{
		BOOL	fRequest;
		BOOL	fNoLoopBack;

		//
		//	Perform group sends and get parent AsyncOp
		//
		if (dwFlags & DPNSEND_COMPLETEONPROCESS)
		{
			fRequest = TRUE;
		}
		else
		{
			fRequest = FALSE;
		}
		if (dwFlags & DPNSEND_NOLOOPBACK)
		{
			fNoLoopBack = TRUE;
		}
		else
		{
			fNoLoopBack = FALSE;
		}
		hResultCode = DNSendGroupMessage(	pdnObject,
											pNTEntry,
											DN_MSG_USER_SEND,
											pActualBufferDesc,
											pRefCountBuffer,
											dwTimeOut,
											dwSendFlags,
											fNoLoopBack,
											fRequest,
											pHandleParent,
											&pParent);

		if (hResultCode != DPN_OK)
		{
			DPFERR("SEND failed");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

			//
			//	Set async completion (if required).  We will only need this if the SEND succeeded.
			//
			if (!(dwFlags & DPNSEND_NOCOMPLETE))
			{
				pHandleParent->SetCompletion( DNCompleteSendHandle );
			}
			pHandleParent->Release();
			pHandleParent = NULL;

		pParent->Release();
		pParent = NULL;
	}
	else
	{
		if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
		{
			DPFERR("Could not get Connection reference");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_CONNECTIONLOST;	// re-map this
			goto Failure;
		}

		if (dwFlags & DPNSEND_COMPLETEONPROCESS)
		{
			hResultCode = DNPerformRequest(	pdnObject,
											DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION,
											pActualBufferDesc,
											pConnection,
											pHandleParent,
											&pAsyncOp);
		}
		else
		{
			hResultCode = DNSendMessage(pdnObject,
										pConnection,
										DN_MSG_USER_SEND,
										dpnid,
										pActualBufferDesc,
										pRefCountBuffer,
										dwTimeOut,
										dwSendFlags,
										pHandleParent,
										&pAsyncOp);
		}

		pConnection->Release();
		pConnection = NULL;

		if (hResultCode != DPNERR_PENDING)
		{
			DPFERR("SEND failed");
			DisplayDNError(0,hResultCode);
			if (hResultCode == DPNERR_INVALIDENDPOINT)
			{
				hResultCode = DPNERR_CONNECTIONLOST;
			}
			goto Failure;
		}

			//
			//	Set async completion (if required).  We will only need this if the SEND succeeded.
			//
			if (!(dwFlags & DPNSEND_NOCOMPLETE))
			{
				pHandleParent->SetCompletion( DNCompleteSendHandle );
			}
			pHandleParent->Release();
			pHandleParent = NULL;

		pAsyncOp->Release();
		pAsyncOp = NULL;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

		if (phAsyncHandle != NULL)
		{
			*phAsyncHandle = handle;
		}
		hResultCode = DPNERR_PENDING;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (handle != 0)
	{
		pdnObject->HandleTable.Destroy( handle );
		handle = 0;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


//	DN_Host

#undef DPF_MODNAME
#define DPF_MODNAME "DN_Host"

HRESULT DIRECTNETOBJECT::DN_Host( PVOID pInterface,
					  const DPN_APPLICATION_DESC *const pdnAppDesc,
					  IDirectPlay8Address **const prgpDeviceInfo,
					  const DWORD cDeviceInfo,
					  const DPN_SECURITY_DESC *const pdnSecurity,
					  const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
					  void *const pvPlayerContext,
					  const DWORD dwFlags)
{
	CNameTableEntry		*pHostPlayer;
	CNameTableEntry		*pAllPlayersGroup;
	DWORD				dwCurrentAddress;
	DWORD				dwCurrentDevice;
	HRESULT				hResultCode;
	DIRECTNETOBJECT		*pdnObject = this;
	LPWSTR				lpwszPassword = NULL;
	PVOID				pvApplicationReservedData = NULL;
	IDirectPlay8Address	**prgIDevice;
	DWORD				dwListensRunning;
	CConnection			*pConnection;
	DWORD				dwVersion;
	GUID				guidSP;
	GUID				guidAdapter;
	CAsyncOp			*pListenParent;
	void				*pvAdapterBuffer;
	DWORD				dwEnumFrameSize;

	DPF(2,"Parameters: pInterface [0x%p], pdnAppDesc [0x%p], prgpDeviceInfo [0x%p], cDeviceInfo [%ld], pdnSecurity [0x%p], pdnCredentials [0x%p], dwFlags [0x%lx]",
		pInterface,pdnAppDesc,prgpDeviceInfo,cDeviceInfo,pdnSecurity,pdnCredentials,dwFlags);

	RIP_ON_NOT_TRUE( "Host() Error validating host params", SUCCEEDED( DN_ValidateHost( pInterface, pdnAppDesc, prgpDeviceInfo, cDeviceInfo,
                                                          pdnSecurity, pdnCredentials, pvPlayerContext,
                                                          dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "Host() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	// Check to ensure not already connected
    	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
    	{
    	    if( DN_CHECK_LOCALHOST( pdnObject ) )
    	    {
    	        DPFERR("Object is already hosting" );
    	    	DPF_RETURN(DPNERR_HOSTING);	
    	    }
    	    else
    	    {
        	    DPFERR("Object is already connected" );
                DPF_RETURN(DPNERR_ALREADYCONNECTED);
    	    }
    	}

    	RIP_ON_NOT_TRUE( "Host() You cannot specify the clientserver flag in peer mode", !((pdnObject->dwFlags & DN_OBJECT_FLAG_PEER) &&
										     	   (pdnAppDesc->dwFlags & DPNSESSION_CLIENT_SERVER) ) );
    	RIP_ON_NOT_TRUE( "Host() You MUST specify the client/server flag for client/server mode", !((pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER) &&
    	   											!(pdnAppDesc->dwFlags & DPNSESSION_CLIENT_SERVER) ) );

	prgIDevice = NULL;
	pListenParent = NULL;
	pConnection = NULL;
	pHostPlayer = NULL;
	pAllPlayersGroup = NULL;

	//
	//	Flag as CONNECTING to prevent other operations here
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTING | DN_OBJECT_FLAG_CONNECTED))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPNERR_ALREADYCONNECTED;
		goto Failure;
	}
	pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTING;

	// Adding local host flag
	pdnObject->dwFlags |= DN_OBJECT_FLAG_LOCALHOST;
	
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	
	//
	//	Copy application description to DirectNet object
	//
	pdnObject->ApplicationDesc.Lock();
	hResultCode = pdnObject->ApplicationDesc.Update(pdnAppDesc,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	pdnObject->ApplicationDesc.Unlock();
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not update application description");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	// Create Instance GUID
	//
	if ((hResultCode = pdnObject->ApplicationDesc.CreateNewInstanceGuid()) != DPN_OK)
	{
		DPFERR("Could not create instance GUID - ignore and continue");
		DisplayDNError(0,hResultCode);
	}

	//
	// Start listens
	//

	// Duplicate address interfaces
	if ((prgIDevice = static_cast<IDirectPlay8Address**>(DNMalloc(cDeviceInfo*sizeof(IDirectPlay8Address*)))) == NULL)
	{
		DPFERR("Could not create duplicate address interface array");
		DNASSERT(FALSE);
		goto Failure;
	}
	for (dwCurrentDevice = 0 ; dwCurrentDevice < cDeviceInfo ; dwCurrentDevice++)
	{
		if ((hResultCode = (prgpDeviceInfo[dwCurrentDevice])->Duplicate(&prgIDevice[dwCurrentDevice])) != DPN_OK)
		{
			DPFERR("Could not duplicate Host address info - skipping it");
			prgIDevice[dwCurrentDevice] = NULL;
			continue;
		}
	}

	// Parent Async Op
	if ((hResultCode = AsyncOpNew(pdnObject,&pListenParent)) != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pListenParent->SetOpType( ASYNC_OP_LISTEN );
	pListenParent->MakeParent();
	pListenParent->SetCompletion( DNCompleteListen );

	// Children op's
	dwListensRunning = 0;
	for (dwCurrentDevice = 0 ; dwCurrentDevice < cDeviceInfo ; dwCurrentDevice++)
	{
		hResultCode = DNPerformSPListen(pdnObject,prgIDevice[dwCurrentDevice],pListenParent,NULL);
		if (hResultCode == DPN_OK)
		{
			dwListensRunning++;
		}
	}

	// Make sure at least 1 listen started
	if (dwListensRunning == 0)
	{
		DPFERR("Could not start any LISTENs");
		hResultCode = DPNERR_INVALIDDEVICEADDRESS;
		goto Failure;
	}

	// Store parent LISTEN on DirectNet object
	pListenParent->AddRef();
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->pListenParent = pListenParent;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	pListenParent->Release();
	pListenParent = NULL;

	//
	//	Determine max allowable enum frame size by examining the SPCaps for each SP
	//
	if ((hResultCode = DNGetMaxEnumFrameSize(pdnObject,&dwEnumFrameSize)) != DPN_OK)
	{
		DPFERR("Could not determine enum frame size");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	DNASSERT( dwEnumFrameSize >= (sizeof(DN_ENUM_RESPONSE_PAYLOAD) + sizeof(DPN_APPLICATION_DESC_INFO)) );
	if (dwEnumFrameSize < (sizeof(DN_ENUM_RESPONSE_PAYLOAD) + sizeof(DPN_APPLICATION_DESC_INFO) + pdnAppDesc->dwApplicationReservedDataSize))
	{
		DPFERR("Not enough room for the application reserved data");
		hResultCode = DPNERR_DATATOOLARGE;
		goto Failure;
	}

	//
	//	Set NameTable DPNID mask
	//
	DPF(5,"DPNID Mask [0x%lx]",pdnObject->ApplicationDesc.GetDPNIDMask());
	pdnObject->NameTable.SetDPNIDMask( pdnObject->ApplicationDesc.GetDPNIDMask() );

	//
	// Create group "ALL PLAYERS"
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pAllPlayersGroup)) != DPN_OK)
	{
		DPFERR("Could not create NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pAllPlayersGroup->MakeGroup();

	// This function takes the lock internally
	pAllPlayersGroup->UpdateEntryInfo(	DN_ALL_PLAYERS_GROUP_NAME,
										DN_ALL_PLAYERS_GROUP_NAME_SIZE,
										NULL,
										0,
										DPNINFO_NAME|DPNINFO_DATA,
										FALSE);

	pdnObject->NameTable.MakeAllPlayersGroup(pAllPlayersGroup);

	//
	// Create local player
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pHostPlayer)) != DPN_OK)
	{
		DPFERR("Could not create NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// This function takes the lock internally
	pHostPlayer->UpdateEntryInfo(	pdnObject->NameTable.GetDefaultPlayer()->GetName(),
								pdnObject->NameTable.GetDefaultPlayer()->GetNameSize(),
								pdnObject->NameTable.GetDefaultPlayer()->GetData(),
								pdnObject->NameTable.GetDefaultPlayer()->GetDataSize(),
								DPNINFO_NAME|DPNINFO_DATA,
								FALSE);

	pHostPlayer->SetDNETVersion( DN_VERSION_CURRENT );

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		pHostPlayer->MakePeer();
	}
	else if (pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER)
	{
		pHostPlayer->MakeServer();
	}
	else
	{
		DNASSERT(FALSE);
	}

	pHostPlayer->SetContext(pvPlayerContext);
	pHostPlayer->StartConnecting();

	if ((hResultCode = pdnObject->NameTable.AddEntry(pHostPlayer)) != DPN_OK)
	{
		DPFERR("Could not add NameTableEntry to NameTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// Create Host's connection (NULL end point)
	if ((hResultCode = ConnectionNew(pdnObject,&pConnection)) != DPN_OK)
	{
		DPFERR("Could not create new connection");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pConnection->SetStatus( CONNECTED );
	pConnection->MakeLocal();
	pConnection->SetEndPt(NULL);
	pConnection->SetDPNID(pHostPlayer->GetDPNID());

	pdnObject->NameTable.MakeLocalPlayer(pHostPlayer);
	pdnObject->NameTable.MakeHostPlayer(pHostPlayer);

	//
	//	Make ALL_PLAYERS group available
	//
	pAllPlayersGroup->Lock();
	pAllPlayersGroup->MakeAvailable();
	pAllPlayersGroup->Unlock();
	pAllPlayersGroup->Release();
	pAllPlayersGroup = NULL;

	//
	//	Update DirectNet object to be connected
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING);
	pdnObject->dwFlags &= ~DN_OBJECT_FLAG_CONNECTING;
	pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTED;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	One player in game (Local/Host player)
	//
	pdnObject->ApplicationDesc.IncPlayerCount(TRUE);

	//
	//	Populate local player's connection
	//
	pConnection->SetDPNID(pHostPlayer->GetDPNID());
	pdnObject->NameTable.PopulateConnection(pConnection);
	pConnection->Release();
	pConnection = NULL;

	pHostPlayer->Release();
	pHostPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	//
	//	Clean up copies of device address
	//
	if (prgIDevice)
	{
		for (dwCurrentDevice = 0 ; dwCurrentDevice < cDeviceInfo ; dwCurrentDevice++)
		{
			if (prgIDevice[dwCurrentDevice])
			{
				(prgIDevice[dwCurrentDevice])->Release();
				prgIDevice[dwCurrentDevice] = NULL;
			}
		}
		DNFree(prgIDevice);
		prgIDevice = NULL;
	}

	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pListenParent)
	{
		pListenParent->Release();
		pListenParent = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pAllPlayersGroup)
	{
		pAllPlayersGroup->Release();
		pAllPlayersGroup = NULL;
	}
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pListenParent = pdnObject->pListenParent;
	pdnObject->pListenParent = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (pListenParent)
	{
		DNCancelChildren(pdnObject,pListenParent);
		pListenParent->Release();
		pListenParent = NULL;
	}

	pdnObject->NameTable.EmptyTable(DPNERR_HOSTTERMINATEDSESSION);

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= ~(DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_LOCALHOST);
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_CreateGroup"

HRESULT DIRECTNETOBJECT::DN_CreateGroup(PVOID pInterface,
							const DPN_GROUP_INFO *const pdpnGroupInfo,
							void *const pvGroupContext,
							void *const pvAsyncContext,
							DPNHANDLE *const phAsyncHandle,
							const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;

	DPF(2,"Parameters: pInterface [0x%p], pdpnGroupInfo [0x%p], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,pdpnGroupInfo,pvAsyncContext,phAsyncHandle,dwFlags);

	RIP_ON_NOT_TRUE( "CreateGroup() Error validating create group params", SUCCEEDED( DN_ValidateCreateGroup( pInterface, pdpnGroupInfo, pvGroupContext,
    	                                                      pvAsyncContext,phAsyncHandle, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "CreateGroup() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to create a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}    	

	pLocalPlayer = NULL;

	if ((pdpnGroupInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnGroupInfo->pwszName))
	{
		pwszName = pdpnGroupInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnGroupInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnGroupInfo->pvData) && (pdpnGroupInfo->dwDataSize))
	{
		pvData = pdpnGroupInfo->pvData;
		dwDataSize = pdpnGroupInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPF(3,"Host is creating group");
		hResultCode = DNHostCreateGroup(pdnObject,
										pwszName,
										dwNameSize,
										pvData,
										dwDataSize,
										pdpnGroupInfo->dwInfoFlags,
										pdpnGroupInfo->dwGroupFlags,
										pvGroupContext,
										pvAsyncContext,
										pLocalPlayer->GetDPNID(),
										0,
										&hAsyncOp,
										dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to create group");
		}
		else
		{
				DPF(3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
		}
	}
	else
	{
		DPF(3,"Request host to create group");

		hResultCode = DNRequestCreateGroup(	pdnObject,
											pwszName,
											dwNameSize,
											pvData,
											dwDataSize,
											pdpnGroupInfo->dwGroupFlags,
											pvGroupContext,
											pvAsyncContext,
											&hAsyncOp,
											dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to create group");
			hResultCode = DPNERR_GENERIC;
#pragma BUGBUG( minara, "This operation should be queued to re-try after host migration" )
		}
		else
		{
				DPF(3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
		}
	}

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_DestroyGroup"

HRESULT DIRECTNETOBJECT::DN_DestroyGroup(PVOID pInterface,
							 const DPNID dpnidGroup,
							 PVOID const pvAsyncContext,
							 DPNHANDLE *const phAsyncHandle,
							 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	CNameTableEntry		*pLocalPlayer;
	CNameTableEntry		*pNTEntry;

	DPF(2,"Parameters: pInterface [0x%p], dpnidGroup [0x%lx], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,dpnidGroup,pvAsyncContext,phAsyncHandle,dwFlags);

	RIP_ON_NOT_TRUE( "DestroyGroup() Error validating destroy group params", SUCCEEDED( DN_ValidateDestroyGroup( pInterface, dpnidGroup, pvAsyncContext,
    	                                                      phAsyncHandle, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "DestroyGroup() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to destroy a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	
    	
	pLocalPlayer = NULL;
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Could not find specified group" );
		DisplayDNError(0,hResultCode);
		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnidGroup,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;

	}
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPF(3,"Host is destroying group");
		hResultCode = DNHostDestroyGroup(	pdnObject,
											dpnidGroup,
											pvAsyncContext,
											pLocalPlayer->GetDPNID(),
											0,
											&hAsyncOp,
											dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to destroy group");
		}
		else
		{
				DPF(3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
		}
	}
	else
	{
		DPF(3,"Request host to destroy group");

		hResultCode = DNRequestDestroyGroup(pdnObject,
											dpnidGroup,
											pvAsyncContext,
											&hAsyncOp,
											dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to destroy group");
			hResultCode = DPNERR_GENERIC;
#pragma BUGBUG( minara, "This operation should be queued to re-try after host migration" )
		}
		else
		{
				DPF(3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
		}
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_AddClientToGroup"

HRESULT DIRECTNETOBJECT::DN_AddClientToGroup(PVOID pInterface,
								 const DPNID dpnidGroup,
								 const DPNID dpnidClient,
								 PVOID const pvAsyncContext,
								 DPNHANDLE *const phAsyncHandle,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	CNameTableEntry		*pLocalPlayer;
	CNameTableEntry		*pNTEntry;

	DPF(2,"Parameters: pInterface [0x%p], dpnidGroup [0x%lx], dpnidClient [0x%lx], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,dpnidGroup,dpnidClient,pvAsyncContext,phAsyncHandle,dwFlags);

	RIP_ON_NOT_TRUE( "AddClientToGroup() Error validating add client to group params", SUCCEEDED( DN_ValidateAddClientToGroup( pInterface, dpnidGroup, dpnidClient, pvAsyncContext,
    	                                                      phAsyncHandle, dwFlags ) ));

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "AddClientToGroup() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to add a player to a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}    	

	pLocalPlayer = NULL;
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pNTEntry)) != DPN_OK)
	{
        DPFERR( "Unable to find specified group" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
	    DPFERR( "Unable to specify client or all players group for group ID" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidClient,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Unable to find specified player" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if (pNTEntry->IsGroup())
	{
	    DPFERR( "Specified client is a group ID" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPF(3,"Host is adding player to group");
		hResultCode = DNHostAddPlayerToGroup(	pdnObject,
												dpnidGroup,
												dpnidClient,
												pvAsyncContext,
												pLocalPlayer->GetDPNID(),
												0,
												&hAsyncOp,
												dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to add player to group");
		}
		else
		{
				DPF(3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
		}
	}
	else
	{
		DPF(3,"Request host to add player to group");

		hResultCode = DNRequestAddPlayerToGroup(pdnObject,
												dpnidGroup,
												dpnidClient,
												pvAsyncContext,
												&hAsyncOp,
												dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to add player to group");
			hResultCode = DPNERR_GENERIC;
#pragma BUGBUG( minara, "This operation should be queued to re-try after host migration" )
		}
		else
		{
				DPF(3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
		}
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_RemoveClientFromGroup"

HRESULT DIRECTNETOBJECT::DN_RemoveClientFromGroup(PVOID pInterface,
									  const DPNID dpnidGroup,
									  const DPNID dpnidClient,
									  PVOID const pvAsyncContext,
									  DPNHANDLE *const phAsyncHandle,
									  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	CNameTableEntry		*pLocalPlayer;
	CNameTableEntry		*pNTEntry;

	DPF(2,"Parameters: pInterface [0x%p], dpnidGroup [0x%lx], dpnidClient [0x%lx], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pInterface,dpnidGroup,dpnidClient,pvAsyncContext,phAsyncHandle,dwFlags);

	RIP_ON_NOT_TRUE( "RemoveClientFromGroup() Error validating remove client from group params", SUCCEEDED( DN_ValidateRemoveClientFromGroup( pInterface, dpnidGroup, dpnidClient, pvAsyncContext, phAsyncHandle, dwFlags ) ));

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "RemoveClientFromGroup() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to remove a player from a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	

	pLocalPlayer = NULL;
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidGroup,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Could not find specified group in nametable" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
	    DPFERR( "Specified ID is not a valid group!" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidClient,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Specified client ID is not a valid client!" );
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if (pNTEntry->IsGroup())
	{
	    DPFERR( "Specified client ID is a group!" );	
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPF(3,"Host is deleting player from group");
		hResultCode = DNHostDeletePlayerFromGroup(	pdnObject,
													dpnidGroup,
													dpnidClient,
													pvAsyncContext,
													pLocalPlayer->GetDPNID(),
													0,
													&hAsyncOp,
													dwFlags);
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to delete player from group");
		}
		else
		{
				DPF(3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
		}
	}
	else
	{
		DPF(3,"Request host to delete player from group");

		hResultCode = DNRequestDeletePlayerFromGroup(pdnObject,
													dpnidGroup,
													dpnidClient,
													pvAsyncContext,
													&hAsyncOp,
													dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to delete player from group");
			hResultCode = DPNERR_GENERIC;
#pragma BUGBUG( minara, "This operation should be queued to re-try after host migration" )
		}
		else
		{
				DPF(3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
		}
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DN_SetGroupInfo

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetGroupInfo"

HRESULT DIRECTNETOBJECT::DN_SetGroupInfo( PVOID pv,
							  const DPNID dpnid,
							  DPN_GROUP_INFO *const pdpnGroupInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;
	CNameTableEntry		*pNTEntry;

	DPF(2,"Parameters: pv [0x%p], dpnid [0x%lx], pvAsyncContext [0x%p], phAsyncHandle [0x%p], dwFlags [0x%lx]",
			pv,dpnid,pdpnGroupInfo,pvAsyncContext,phAsyncHandle,dwFlags);

	RIP_ON_NOT_TRUE( "SetGroupInfo() Error validating set group info params", SUCCEEDED( DN_ValidateSetGroupInfo( pv, dpnid, pdpnGroupInfo, pvAsyncContext, phAsyncHandle, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "SetGroupInfo() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to set group info" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	
	
	pLocalPlayer = NULL;
	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Specified ID is not a group" );
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
	    DPFERR( "Specified ID is not a valid group" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((pdpnGroupInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnGroupInfo->pwszName))
	{
		pwszName = pdpnGroupInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnGroupInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnGroupInfo->pvData) && (pdpnGroupInfo->dwDataSize))
	{
		pvData = pdpnGroupInfo->pvData;
		dwDataSize = pdpnGroupInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->IsHost())
	{
		DPF(3,"Host is updating group info");
		hResultCode = DNHostUpdateInfo(	pdnObject,
										dpnid,
										pwszName,
										dwNameSize,
										pvData,
										dwDataSize,
										pdpnGroupInfo->dwInfoFlags,
										pvAsyncContext,
										pLocalPlayer->GetDPNID(),
										0,
										&hAsyncOp,
										dwFlags );
		if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
		{
			DPFERR("Could not request host to update info");
		}
		else
		{
				DPF(3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;

				//
				//	Release Async HANDLE since this operation has already completed (!)
				//
				pdnObject->HandleTable.Destroy( hAsyncOp );
				hAsyncOp = 0;
		}
	}
	else
	{
		DPF(3,"Request host to update group info");

		hResultCode = DNRequestUpdateInfo(	pdnObject,
											dpnid,
											pwszName,
											dwNameSize,
											pvData,
											dwDataSize,
											pdpnGroupInfo->dwInfoFlags,
											pvAsyncContext,
											&hAsyncOp,
											dwFlags);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not request host to update info");
		}
		else
		{
				DPF(3,"Async Handle [0x%lx]",hAsyncOp);
				*phAsyncHandle = hAsyncOp;
		}
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DN_GetGroupInfo
//
//	Retrieve group name and/or data from the local nametable.
//
//	lpwszGroupName may be NULL to avoid retrieving group name
//	pdwGroupFlags may be NULL to avoid retrieving group flags
//	pvGroupData may not by NULL if *pdwDataSize is non zero

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetGroupInfo"

HRESULT DIRECTNETOBJECT::DN_GetGroupInfo(PVOID pv,
							 const DPNID dpnid,
							 DPN_GROUP_INFO *const pdpnGroupInfo,
							 DWORD *const pdwSize,
							 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	CNameTableEntry		*pNTEntry;
	CPackedBuffer		packedBuffer;
	HRESULT				hResultCode;

	DPF(2,"Parameters: dpnid [0x%lx], pdpnGroupInfo [0x%p], dwFlags [0x%lx]",
			dpnid,pdpnGroupInfo,dwFlags);

	RIP_ON_NOT_TRUE( "GetGroupInfo() Error validating get group info params", SUCCEEDED( DN_ValidateGetGroupInfo( pv, dpnid, pdpnGroupInfo, pdwSize, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "GetGroupInfo() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_DISCONNECTING)) )
    	{
    	    DPFERR("You must be connected / hosting to get group info" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
	    DPFERR( "Specified group is not valid" );
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
	}
	packedBuffer.Initialize(pdpnGroupInfo,*pdwSize);

	pNTEntry->Lock();
	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
	    DPFERR( "Specified ID is not a group" );
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}

	hResultCode = pNTEntry->PackInfo(&packedBuffer);

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	if ((hResultCode == DPN_OK) || (hResultCode == DPNERR_BUFFERTOOSMALL))
	{
		*pdwSize = packedBuffer.GetSizeRequired();
	}

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumClientsAndGroups"

HRESULT DIRECTNETOBJECT::DN_EnumClientsAndGroups(PVOID pInterface,
									 DPNID *const prgdpnid,
									 DWORD *const pcdpnid,
									 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	CBilink				*pBilink;
	CNameTableEntry		*pNTEntry;
	DWORD				dwCount;
	DPNID				*pDPNID;
	BOOL				bEnum = TRUE;
	HRESULT             hResultCode;

	DPF(2,"Parameters: pInterface [0x%p], prgdpnid [0x%p], pcdpnid [0x%p], dwFlags [0x%lx]",
			pInterface,prgdpnid,pcdpnid,dwFlags);

	RIP_ON_NOT_TRUE( "EnumClientsAndGroups() Error validating enum clients and groups params", SUCCEEDED( DN_ValidateEnumClientsAndGroups( pInterface, prgdpnid, pcdpnid, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "EnumClientsAndGroups() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to create a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	
    	
	if (prgdpnid == NULL || *pcdpnid == 0)				// Don't enum if not asked to
	{
		bEnum = FALSE;
	}

	pdnObject->NameTable.Lock();

	dwCount = 0;
	pDPNID = prgdpnid;

	//
	//	Enum players
	//
	if (dwFlags & DPNENUM_PLAYERS)
	{
		pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);

			pNTEntry->Lock();
			if (pNTEntry->IsAvailable())
			{
				dwCount++;
				if (bEnum && (dwCount <= *pcdpnid))
				{
					*pDPNID++ = pNTEntry->GetDPNID();
				}
				else
				{
					bEnum = FALSE;
				}
			}
			pNTEntry->Unlock();
			pBilink = pBilink->GetNext();
		}
	}

	//
	//	Enum groups
	//
	if (dwFlags & DPNENUM_GROUPS)
	{
		pBilink = pdnObject->NameTable.m_bilinkGroups.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);

			pNTEntry->Lock();
			if (pNTEntry->IsAvailable() && !pNTEntry->IsAllPlayersGroup())
			{
				dwCount++;
				if (bEnum && (dwCount <= *pcdpnid))
				{
					*pDPNID++ = pNTEntry->GetDPNID();
				}
				else
				{
					bEnum = FALSE;
				}
			}
			pNTEntry->Unlock();
			pBilink = pBilink->GetNext();
		}
	}

	pdnObject->NameTable.Unlock();

	//
	//	This will NOT include players/groups in the deleted list.
	//	i.e. removed from the NameTable but for whom DESTROY_PLAYER/GROUP notifications have yet to be posted
	//
	*pcdpnid = dwCount;
	if (!bEnum && dwCount)
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
	}
	else
	{
		hResultCode = DPN_OK;
	}

	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumGroupMembers"

HRESULT DIRECTNETOBJECT::DN_EnumGroupMembers(PVOID pInterface,
								 const DPNID dpnid,
								 DPNID *const prgdpnid,
								 DWORD *const pcdpnid,
								 const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	CNameTableEntry		*pNTEntry;
	CGroupMember		*pGroupMember;
	CBilink				*pBilink;
	DWORD				dwCount;
	DPNID				*pDPNID;
	BOOL				bOutputBufferTooSmall = FALSE;
	HRESULT				hResultCode;

	DPF(2,"Parameters: pInterface [0x%p], dpnid [0x%lx], prgdpnid [0x%p], pcdpnid [0x%p], dwFlags [0x%lx]",
			pInterface,dpnid,prgdpnid,pcdpnid,dwFlags);

	RIP_ON_NOT_TRUE( "EnumGroupMembers() Error validating enum group params", SUCCEEDED( DN_ValidateEnumGroupMembers( pInterface, dpnid, prgdpnid, pcdpnid, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "EnumGroupMembers() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to create a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	

	pNTEntry = NULL;

	//
	// if the user didn't supply a buffer, assume that the
	// output buffer is too small
	//
	if ( ( prgdpnid == NULL ) || ( ( *pcdpnid ) == 0 ) )	
	{
		bOutputBufferTooSmall = TRUE;
	}

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}

	if (!pNTEntry->IsGroup() || pNTEntry->IsAllPlayersGroup())
	{
		DPFERR("Not a group dpnid!");
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}

	pNTEntry->Lock();

	dwCount = 0;
	pDPNID = prgdpnid;

	pBilink = pNTEntry->m_bilinkMembership.GetNext();
	while (pBilink != &pNTEntry->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
		dwCount++;
		if ( ( bOutputBufferTooSmall == FALSE ) && (dwCount <= *pcdpnid))
		{
			*pDPNID++ = pGroupMember->GetPlayer()->GetDPNID();
		}
		else
		{
			bOutputBufferTooSmall = TRUE;
		}
		pBilink = pBilink->GetNext();
	}

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	*pcdpnid = dwCount;

	//
	// if the user's output buffer appears to be incapable receiving
	// output, double-check to make sure that the output size requirement
	// isn't zero (which is really OK), before telling them that the
	// output buffer is too small
	//
	if ( ( bOutputBufferTooSmall ) && ( dwCount != 0 ) )
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
	}
	else
	{
		hResultCode = DPN_OK;
	}

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumHosts"

HRESULT DIRECTNETOBJECT::DN_EnumHosts( PVOID pv,
						   DPN_APPLICATION_DESC *const pApplicationDesc,
                           IDirectPlay8Address *const pAddrHost,
						   IDirectPlay8Address *const pDeviceInfo,
						   PVOID const pUserEnumData,
						   const DWORD dwUserEnumDataSize,
						   const DWORD dwRetryCount,
						   const DWORD dwRetryInterval,
						   const DWORD dwTimeOut,
						   PVOID const pvAsyncContext,
						   DPNHANDLE *const pAsyncHandle,
						   const DWORD dwFlags )
{
	DIRECTNETOBJECT	*pdnObject = this;
	HRESULT		hResultCode;
	HRESULT		hrEnum;
	GUID		guidAdapter;
	GUID		guidHostSP;
	GUID		*pguid;
	CAsyncOp	*pParent;
	CAsyncOp	*pHandleParent;
	CSyncEvent	*pSyncEvent;
	CServiceProvider	*pSP;
	CRefCountBuffer		*pRCBuffer;
	DN_ENUM_QUERY	*pEnumQuery;
	IDirectPlay8Address	*pIHost;
	IDirectPlay8Address	*pIDevice;
	DPNHANDLE	handle;
	DWORD		dw;
	DPN_SP_CAPS	dnSPCaps;
	BOOL		fHosting;
#ifdef	DEBUG
	CHAR			DP8ABuffer[512];
	DWORD			DP8ASize;
#endif

	DPF(2,"Parameters: pApplicationDesc [0x%p], pAddrHost [0x%p], pDeviceInfo [0x%p], pUserEnumData [0x%p], dwUserEnumDataSize [%ld], dwRetryCount [%ld], dwRetryInterval [%ld], dwTimeOut [%ld], pvAsyncContext [0x%p], pAsyncHandle [0x%p], dwFlags [0x%lx]",
		pApplicationDesc,pAddrHost,pDeviceInfo,pUserEnumData,dwUserEnumDataSize,dwRetryCount,dwRetryInterval,dwTimeOut,pvAsyncContext,pAsyncHandle,dwFlags);

	RIP_ON_NOT_TRUE( "EnumHosts() Error validating enum hosts params", SUCCEEDED( DN_ValidateEnumHosts( pv, pApplicationDesc, pAddrHost,
    	                                                    pDeviceInfo, pUserEnumData, dwUserEnumDataSize,
    	                                                    dwRetryCount, dwRetryInterval, dwTimeOut,
															pvAsyncContext, pAsyncHandle, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "EnumHosts() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

	//
	// initialize
	//
	hResultCode = DPN_OK;
	pParent = NULL;
	pHandleParent = NULL;
	pSyncEvent = NULL;
	pRCBuffer = NULL;
	pSP = NULL;
	pIHost = NULL;
	pIDevice = NULL;
	handle = 0;

#ifdef	DEBUG
	if (pAddrHost)
	{
		DP8ASize = 512;
		pAddrHost->GetURLA(DP8ABuffer,&DP8ASize);
		DPF(4,"Host address [%s]",DP8ABuffer);
	}

	if (pDeviceInfo)
	{
		DP8ASize = 512;
		pDeviceInfo->GetURLA(DP8ABuffer,&DP8ASize);
		DPF(4,"Device address [%s]",DP8ABuffer);
	}
#endif

	//
	//	Cannot ENUM if Hosting - I have no idea why, but VanceO insisted on it
	//
	fHosting = FALSE;
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_CONNECTING))
	{
		CNameTableEntry		*pLocalPlayer;

		pLocalPlayer = NULL;

		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) == DPN_OK)
		{
			if (pLocalPlayer->IsHost())
			{
				fHosting = TRUE;
			}
			pLocalPlayer->Release();
			pLocalPlayer = NULL;
		}
	}
	else
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	}

	if (fHosting)
	{
		hResultCode = DPNERR_HOSTING;
		goto Failure;
	}


	if ((hResultCode = DNGetActualSPCaps(pdnObject,NULL,&dnSPCaps)) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Ensure payload will fit
	//
	if (dwUserEnumDataSize > dnSPCaps.dwMaxEnumPayloadSize)
	{
		DPFERR("User enum data is too large");
		hResultCode = DPNERR_ENUMQUERYTOOLARGE;
		goto Failure;
	}

	//
	//	Duplicate addresses for local usage (so we can modify them if neccessary
	//
	if (pAddrHost)
	{
		// Use supplied Host address
		if ((hResultCode = pAddrHost->Duplicate(&pIHost)) != DPN_OK)
		{
			DPFERR("Could not duplicate Host address");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDHOSTADDRESS;
			goto Failure;
		}
	}
	else
	{
		//
		//	Create new Host address and use Device SP guid
		//
		if ((hResultCode = DirectPlay8AddressCreate( IID_IDirectPlay8Address, (void **) &pIHost, NULL)) != DPN_OK)
		{
			DPFERR("Could not create Host address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}

	if ((hResultCode = pDeviceInfo->Duplicate(&pIDevice)) != DPN_OK)
	{
		DPFERR("Could not duplicate Device address");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

#ifdef	DEBUG
	DP8ASize = 512;
	pIHost->GetURLA(DP8ABuffer,&DP8ASize);
	DPF(4,"Host address [%s]",DP8ABuffer);

	DP8ASize = 512;
	pIDevice->GetURLA(DP8ABuffer,&DP8ASize);
	DPF(4,"Device address [%s]",DP8ABuffer);
#endif

	//
	//	Parent for ENUMs
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pParent)) != DPN_OK)
	{
		DPFERR("Could not create ENUM parent AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pParent->MakeParent();
	pParent->SetOpType( ASYNC_OP_ENUM_QUERY );
	pParent->SetContext( pvAsyncContext );
	pParent->SetCompletion( DNCompleteEnumQuery );

	//
	//	Synchronous ?
	//
		//
		//	Create Handle parent AsyncOp (if required)
		//
		if ((hResultCode = DNCreateUserHandle(pdnObject,&pHandleParent)) != DPN_OK)
		{
			DPFERR("Could not create AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pHandleParent->SetContext( pvAsyncContext );
		pHandleParent->Lock();
		if (pHandleParent->IsCancelled())
		{
			pHandleParent->Unlock();
			pParent->SetResult( DPNERR_USERCANCEL );
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		pParent->MakeChild( pHandleParent );
		handle = pHandleParent->GetHandle();
		pHandleParent->Unlock();

	//
	//	Ensure SP specified in Device address is loaded
	//
	if ((hResultCode = DN_SPEnsureLoaded(pdnObject,&GUID_NULL,&pSP)) != DPN_OK)
	{
		DPFERR("Could not ensure SP is loaded!");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pParent->SetSP( pSP );
	pSP->Release();
	pSP = NULL;

		void	*pvBlock;

		if ((pvBlock = MemoryBlockAlloc(pdnObject,sizeof(DN_ENUM_QUERY))) == NULL)
		{
			DPFERR("Could not allocate MemoryBlock");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
		pEnumQuery = static_cast<DN_ENUM_QUERY*>(pvBlock);
		pEnumQuery->dwNumAdapters = 0;
		pEnumQuery->dwCurrentAdapter = 0;
		pParent->SetOpData( pvBlock );
		pvBlock = NULL;

	//
	//	Set up EnumQuery BufferDescriptions
	//
	//
	// When filling out the enum structure the SP requires an extra BUFFERDESC
	// to exist immediately before the one were passing with the user data.  The
	// SP will be using that extra buffer to prepend an optional header
	//

	pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD].pBufferData = reinterpret_cast<BYTE*>(&pEnumQuery->EnumQueryPayload);
	if (pApplicationDesc->guidApplication != GUID_NULL)
	{
		pEnumQuery->EnumQueryPayload.QueryType = DN_ENUM_QUERY_WITH_APPLICATION_GUID;
		memcpy(&pEnumQuery->EnumQueryPayload.guidApplication,&pApplicationDesc->guidApplication,sizeof(GUID));
		pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD].dwBufferSize = sizeof(DN_ENUM_QUERY_PAYLOAD);
	}
	else
	{
		pEnumQuery->EnumQueryPayload.QueryType = DN_ENUM_QUERY_WITHOUT_APPLICATION_GUID;
		pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD].dwBufferSize = sizeof(DN_ENUM_QUERY_PAYLOAD) - sizeof(GUID);
	}

	//
	//	Copy user data (if any)
	//
	if (pUserEnumData)
	{
		DNASSERT(dwUserEnumDataSize);
		if ((hResultCode = RefCountBufferNew(pdnObject,dwUserEnumDataSize,&pRCBuffer)) != DPN_OK)
		{
			DPFERR("Could not create RefCountBuffer");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		memcpy(pRCBuffer->GetBufferAddress(),pUserEnumData,dwUserEnumDataSize);
		pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD].pBufferData = reinterpret_cast<BYTE*>(pRCBuffer->GetBufferAddress());
		pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD].dwBufferSize = dwUserEnumDataSize;
		pParent->SetRefCountBuffer( pRCBuffer );

		pRCBuffer->Release();
		pRCBuffer = NULL;
	}
	else
	{
		pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD].pBufferData = NULL;
		pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD].dwBufferSize = 0;
	}


	//
	//	Set up EnumQuery misc fields
	//
	pEnumQuery->dwRetryCount = dwRetryCount;
	pEnumQuery->dwRetryInterval = dwRetryInterval;
	pEnumQuery->dwTimeOut = dwTimeOut;
	pEnumQuery->dwFlags = dwFlags;

#pragma TODO( minara, "We do not need to send each of these parameters individually - they are already in a structure !" )
	hResultCode = DNPerformEnumQuery(	pdnObject,
										pIHost,
										pIDevice,
										pParent->GetSP()->GetHandle(),
										&pEnumQuery->BufferDesc[DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD],
										DN_ENUM_BUFFERDESC_QUERY_COUNT,
										pEnumQuery->dwRetryCount,
										pEnumQuery->dwRetryInterval,
										pEnumQuery->dwTimeOut,
										pEnumQuery->dwFlags,
										pParent->GetContext(),
										pParent );
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not start ENUM");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
											
	pParent->Release();
	pParent = NULL;

	//
	//	Wait for SyncEvent or return Async Handle
	//
		//
		//	Blame vanceo if this EVER returns anything other than DPN_OK at this stage
		//
		pHandleParent->SetCompletion( DNCompleteAsyncHandle );
		pHandleParent->Release();
		pHandleParent = NULL;

		*pAsyncHandle = handle;
		hResultCode = DPNERR_PENDING;

	pIDevice->Release();
	pIDevice = NULL;

	pIHost->Release();
	pIHost = NULL;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (handle != 0)
	{
		pdnObject->HandleTable.Destroy( handle );
		handle = 0;
	}
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	if (pHandleParent)
	{
		pHandleParent->Release();
		pHandleParent = NULL;
	}
	if (pSyncEvent)
	{
		pSyncEvent->ReturnSelfToPool();
		pSyncEvent = NULL;
	}
	if (pRCBuffer)
	{
		pRCBuffer->Release();
		pRCBuffer = NULL;
	}
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	if (pIHost)
	{
		pIHost->Release();
		pIHost = NULL;
	}
	if (pIDevice)
	{
		pIDevice->Release();
		pIDevice = NULL;
	}
	goto Exit;
}


//**********************************************************************



//	DN_DestroyPlayer
//
//	Remove a player from this DirectNet session
//	This will send a termination message to the player.
//	Both the host and the player will terminate.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_DestroyPlayer"

HRESULT DIRECTNETOBJECT::DN_DestroyPlayer(PVOID pInterface,
							  const DPNID dpnid,
							  const void *const pvDestroyData,
							  const DWORD dwDestroyDataSize,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CNameTableEntry		*pNTEntry;
	CConnection			*pConnection;
	DN_INTERNAL_MESSAGE_TERMINATE_SESSION	*pMsg;

	DPF(3,"Parameters: pInterface [0x%p], dpnid [0x%lx], pvDestroyData [0x%p], dwDestroyDataSize [%ld], dwFlags [0x%lx]",
			pInterface,dpnid,pvDestroyData,dwDestroyDataSize,dwFlags);

	RIP_ON_NOT_TRUE( "DestroyPlayer() Error validating destroy player params", SUCCEEDED( DN_ValidateDestroyPlayer( pInterface, dpnid, pvDestroyData, dwDestroyDataSize, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "DestroyPlayer() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to create a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	

	pNTEntry = NULL;
	pRefCountBuffer = NULL;
	pConnection = NULL;

	if (!DN_CHECK_LOCALHOST(pdnObject))
	{
	    DPFERR( "Object is not session host, cannot destroy players" );
		DPF_RETURN(DPNERR_NOTHOST);
	}

	// Ensure DNID specified is valid
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find player entry");
		DisplayDNError(0,hResultCode);
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	if (pNTEntry->IsLocal() )
	{
		DPFERR( "Cannot destroy local player" );
		hResultCode = DPNERR_INVALIDPLAYER;		
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pNTEntry->IsGroup())
	{
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get connection ref");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_CONNECTIONLOST;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Build terminate message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,
			sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION) + dwDestroyDataSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pRefCountBuffer->GetBufferAddress());
	if (dwDestroyDataSize)
	{
		memcpy(pMsg+1,pvDestroyData,dwDestroyDataSize);
		pMsg->dwTerminateDataOffset = sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION);
	}
	else
	{
		pMsg->dwTerminateDataOffset = 0;
	}
	pMsg->dwTerminateDataSize = dwDestroyDataSize;

	//
	//	Send message to player to exit
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_TERMINATE_SESSION,
								dpnid,
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send DESTROY_CLIENT message to player");
		DisplayDNError(0,hResultCode);
		if (hResultCode == DPNERR_INVALIDENDPOINT)
		{
			hResultCode = DPNERR_INVALIDPLAYER;
		}
		goto Failure;
	}

	pConnection->Release();
	pConnection = NULL;

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Remove from NameTable and inform other players of disconnect
	//
	hResultCode = DNHostDisconnect(pdnObject,dpnid,DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);

	hResultCode = DPN_OK;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	DNASSERT(hResultCode != DPNERR_INVALIDENDPOINT);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}



//	DN_ReturnBuffer
//
//	Return a receive buffer which is no longer in use

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ReturnBuffer"

HRESULT DIRECTNETOBJECT::DN_ReturnBuffer(PVOID pv,
							 const DPNHANDLE hBufferHandle,
							 const DWORD dwFlags)
{
	DIRECTNETOBJECT	*pdnObject = this;
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;

	DPF(2,"Parameters: hBufferHandle [0x%lx], dwFlags [0x%lx]",hBufferHandle,dwFlags);

	RIP_ON_NOT_TRUE( "ReturnBuffer() Error validating return buffer params", SUCCEEDED( DN_ValidateReturnBuffer( pv, hBufferHandle, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "ReturnBuffer() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to create a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	

	pAsyncOp = NULL;

	//
	//	Find async op
	//
	if ((hResultCode = pdnObject->HandleTable.Find( hBufferHandle,&pAsyncOp )) != DPN_OK)
	{
		DPFERR("Could not find handle");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDHANDLE;
		goto Failure;
	}

	//
	//	Ensure it's not already cancelled
	//
	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled() || pAsyncOp->IsComplete())
	{
		pAsyncOp->Unlock();
		hResultCode = DPNERR_INVALIDHANDLE;
		goto Failure;
	}
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	if ((hResultCode = pdnObject->HandleTable.Destroy( hBufferHandle )) == DPN_OK)
	{
		//
		//	Remove from active list
		//
		DNEnterCriticalSection(&pdnObject->csActiveList);
		pAsyncOp->m_bilinkActiveList.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csActiveList);
	}

	pAsyncOp->Release();
	pAsyncOp = NULL;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	goto Exit;
}


//	DN_GetPlayerContext

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetPlayerContext"

HRESULT DIRECTNETOBJECT::DN_GetPlayerContext(PVOID pv,
								 const DPNID dpnid,
								 PVOID *const ppvPlayerContext,
								 const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	DIRECTNETOBJECT		*pdnObject = this;

	DPF(2,"Parameters: pv [0x%p], dpnid [0x%lx], ppvPlayerContext [0x%p], dwFlags [0x%lx]",
			pv, dpnid,ppvPlayerContext,dwFlags);

	RIP_ON_NOT_TRUE( "GetPlayerContext() Error validating getplayercontext params", SUCCEEDED( DN_ValidateGetPlayerContext( pv, dpnid, ppvPlayerContext, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "GetPlayerContext() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_DISCONNECTING)) )
    	{
    	    DPFERR("You must be connected / hosting to get player context" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not retrieve player entry");
		DisplayDNError(0,hResultCode);

		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in deleted list either");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
	}

	//
	//	Ensure player is available (ADD_PLAYER has been sent but not DELETE_PLAYER),
	//	and that this is not a group.
	//
	pNTEntry->Lock();
	if (!pNTEntry->IsCreated() || pNTEntry->IsGroup())
	{
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	*ppvPlayerContext = pNTEntry->GetContext();
	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DN_GetGroupContext

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetGroupContext"

HRESULT DIRECTNETOBJECT::DN_GetGroupContext(PVOID pv,
								const DPNID dpnid,
								PVOID *const ppvGroupContext,
								const DWORD dwFlags)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	DIRECTNETOBJECT		*pdnObject = this;

	DPF(2,"Parameters: pv [0x%p], dpnid [0x%lx], ppvGroupContext [0x%p], dwFlags [0x%lx]",
			pv, dpnid,ppvGroupContext,dwFlags);

	RIP_ON_NOT_TRUE( "GetGroupContext() Error validating getgroupcontext params", SUCCEEDED( DN_ValidateGetGroupContext( pv, dpnid, ppvGroupContext,dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "GetGroupContext() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTED | DN_OBJECT_FLAG_DISCONNECTING)) )
    	{
    	    DPFERR("You must be connected / hosting to get group context" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not retrieve group entry");
		DisplayDNError(0,hResultCode);

		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in deleted list either");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDGROUP;
			goto Failure;
		}
	}

	//
	//	Ensure that group is available (CREATE_GROUP has been sent, but not DESTROY_GROUP),
	//	and that this is a not a player.
	//
	pNTEntry->Lock();
	if (!pNTEntry->IsAvailable() || !pNTEntry->IsGroup())
	{
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}

	if( pNTEntry->IsAllPlayersGroup() )
	{
		pNTEntry->Unlock();
		DPFERR("Cannot getcontext for the all players group" );
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}

	*ppvGroupContext = pNTEntry->GetContext();
	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_RegisterLobby"

HRESULT DIRECTNETOBJECT::DN_RegisterLobby(PVOID pInterface,
							  const DPNHANDLE dpnhLobbyConnection, 
							  VOID *const pIDP8LobbiedApplication,
							  const DWORD dwFlags)
{
	return DPNERR_UNSUPPORTED;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_TerminateSession"

HRESULT DIRECTNETOBJECT::DN_TerminateSession(PVOID pInterface,
								 void *const pvTerminateData,
								 const DWORD dwTerminateDataSize,
								 const DWORD dwFlags)
{
	HRESULT				hResultCode;
	DIRECTNETOBJECT		*pdnObject = this;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_TERMINATE_SESSION	*pMsg;

	DPF(2,"Parameters: pInterface [0x%p], pvTerminateData [0x%p], dwTerminateDataSize [%ld], dwFlags [0x%lx]",
			pInterface,pvTerminateData,dwTerminateDataSize,dwFlags);

	RIP_ON_NOT_TRUE( "TerminateSession() Error validating terminatesession params", SUCCEEDED( DN_ValidateTerminateSession( pInterface, pvTerminateData, dwTerminateDataSize, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "TerminateSession() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to create a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	

	pRefCountBuffer = NULL;
	pWorkerJob = NULL;

	if (!DN_CHECK_LOCALHOST(pdnObject))
	{
	    DPFERR( "Object is not session host, cannot destroy players" );
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}	

	//
	//	Build terminate message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,
			sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION) + dwTerminateDataSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_TERMINATE_SESSION*>(pRefCountBuffer->GetBufferAddress());
	if (dwTerminateDataSize)
	{
		memcpy(pMsg+1,pvTerminateData,dwTerminateDataSize);
		pMsg->dwTerminateDataOffset = sizeof(DN_INTERNAL_MESSAGE_TERMINATE_SESSION);
	}
	else
	{
		pMsg->dwTerminateDataOffset = 0;
	}
	pMsg->dwTerminateDataSize = dwTerminateDataSize;

	//
	//	Worker job to send message to all players
	//
	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
	{
		DPFERR("Could not allocate new WorkerJob");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
	pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_TERMINATE_SESSION );
	pWorkerJob->SetSendNameTableOperationVersion( 0 );
	pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
	pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

	DNQueueWorkerJob(pdnObject,pWorkerJob);
	pWorkerJob = NULL;

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Terminate local session
	//
	hResultCode = DNUserTerminateSession(pdnObject,
										 DPNERR_HOSTTERMINATEDSESSION,
										 pvTerminateData,
										 dwTerminateDataSize);

	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
	{
		DPFERR("Could not create WorkerJob");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pWorkerJob->SetJobType( WORKER_JOB_TERMINATE_SESSION );
	pWorkerJob->SetTerminateSessionReason( DPNERR_HOSTTERMINATEDSESSION );

	DNQueueWorkerJob(pdnObject,pWorkerJob);
	pWorkerJob = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}

//
//	FUnction that performs work for DN_GetHostAddress and for Lobby informs
//
#undef DPF_MODNAME
#define DPF_MODNAME "DNGetHostAddressHelper"

HRESULT DNGetHostAddressHelper(DIRECTNETOBJECT *pdnObject, 
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress)
{
	CAsyncOp		*pListenParent;
	CAsyncOp		*pListenSP;
	CAsyncOp		*pListen;
	CBilink			*pBilinkSP;
	CBilink			*pBilink;
	DWORD			dwListenCount;
	SPGETADDRESSINFODATA	spInfoData;
	CNameTableEntry			*pLocalPlayer;
	IDirectPlay8Address		**ppAddress;
	HRESULT hResultCode;

	pListenParent = NULL;
	pListenSP = NULL;
	pListen = NULL;	
	pLocalPlayer = NULL;
	
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (	!(pdnObject->dwFlags & DN_OBJECT_FLAG_LISTENING)
		||	!pLocalPlayer->IsHost()
		||	(pdnObject->pListenParent == NULL))

	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFERR("Not listening or Host player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	pdnObject->pListenParent->AddRef();
	pListenParent = pdnObject->pListenParent;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Ensure that the address pointer buffer is large enough
	//
	dwListenCount = 0;
	pListenParent->Lock();	// Prevent changes while we run through
	pBilinkSP = pListenParent->m_bilinkParent.GetNext();
	while (pBilinkSP != &pListenParent->m_bilinkParent)
	{
		pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);

		pListenSP->Lock();

		pBilink = pListenSP->m_bilinkParent.GetNext();
		while (pBilink != &pListenSP->m_bilinkParent)
		{
			dwListenCount++;
			pBilink = pBilink->GetNext();
		}

		pListenSP->Unlock();
		pListenSP = NULL;

		pBilinkSP = pBilinkSP->GetNext();
	}

	if (dwListenCount > *pcAddress)
	{
		pListenParent->Unlock();
		*pcAddress = dwListenCount;
		hResultCode = DPNERR_BUFFERTOOSMALL;
		goto Failure;
	}

	//
	//	Get addresses of LISTENs
	//

	ppAddress = prgpAddress;
	dwListenCount = 0;
	pBilinkSP = pListenParent->m_bilinkParent.GetNext();
	while (pBilinkSP != &pListenParent->m_bilinkParent)
	{
		pListenSP = CONTAINING_OBJECT(pBilinkSP,CAsyncOp,m_bilinkChildren);

		pListenSP->Lock();

		pBilink = pListenSP->m_bilinkParent.GetNext();
		while (pBilink != &pListenSP->m_bilinkParent)
		{
			pListen = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkChildren);

			if (pListen->GetProtocolHandle() != NULL)
			{
				spInfoData.hEndpoint = pListen->GetProtocolHandle();
				spInfoData.Flags = SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES;
				pListen = NULL;
				if ((hResultCode = DNPGetListenAddressInfo(spInfoData.hEndpoint,&spInfoData)) != DPN_OK)
				{
					DPFERR("Could not get LISTEN address - ignore and continue");
					DisplayDNError(0,hResultCode);
					DNASSERT(FALSE);
					pBilink = pBilink->GetNext();
					continue;
				}
				*ppAddress++ = spInfoData.pAddress;
				dwListenCount++;
			}

			pBilink = pBilink->GetNext();
		}

		pListenSP->Unlock();
		pListenSP = NULL;

		pBilinkSP = pBilinkSP->GetNext();
	}
	pListenParent->Unlock();

	*pcAddress = dwListenCount;

	hResultCode = DPN_OK;

	pListenParent->Release();
	pListenParent = NULL;

Exit:
	DPF_RETURN(hResultCode);

Failure:
	if (pListenParent)
	{
		pListenParent->Release();
		pListenParent = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
	
}

//
//	DN_GetHostAddress
//
//	We will determine the host addresses by examining the LISTENs which are running.
//	We do this because after Host migration, we may not be running the same LISTEN
//	we started with.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetHostAddress"

HRESULT DIRECTNETOBJECT::DN_GetHostAddress(PVOID pInterface,
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress,
							   const DWORD dwFlags)
{
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject = this;

	DPF(3,"Parameters: pInterface [0x%p], prgpAddress [0x%p], pcAddress [0x%p], dwFlags [0x%lx]",
			pInterface,prgpAddress,pcAddress,dwFlags);

	RIP_ON_NOT_TRUE( "GetHostAddress() Error validating gethostaddress params", SUCCEEDED( DN_ValidateGetHostAddress( pInterface, prgpAddress, pcAddress, dwFlags ) ) );

    	// Check to ensure message handler registered
    	RIP_ON_NOT_TRUE( "GetHostAddress() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) )
    	{
    	    DPFERR("You must be connected / hosting to create a group" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	

	// Actually do the work and get the addresses  
	hResultCode = DNGetHostAddressHelper( pdnObject, prgpAddress, pcAddress );

	DPF_RETURN(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNGetMaxEnumFrameSize"

HRESULT DNGetMaxEnumFrameSize(DIRECTNETOBJECT *const pdnObject,
							  DWORD *const pdwEnumFrameSize)
{
	HRESULT				hResultCode;
	DWORD				dwMinMax;
	BOOL				fSet;
    SPGETCAPSDATA		spGetCapsData;
    IDP8ServiceProvider	*pIDP8SP;
	CBilink				*pBilink;
	CServiceProvider	*pSP;

	DPF(8,"Parameters: pdwEnumFrameSize [0x%p]",pdwEnumFrameSize);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pdwEnumFrameSize != NULL);

	dwMinMax = 0;
	fSet = FALSE;

	DNEnterCriticalSection(&pdnObject->csServiceProviders);
	pBilink = pdnObject->m_bilinkServiceProviders.GetNext();
	while (pBilink != &pdnObject->m_bilinkServiceProviders)
	{
		pSP = CONTAINING_OBJECT(pBilink,CServiceProvider,m_bilinkServiceProviders);

		//
		//	Get SPCaps for this SP
		//
		if ((hResultCode = pSP->GetInterfaceRef( &pIDP8SP )) == DPN_OK)
		{
			memset( &spGetCapsData, 0x00, sizeof( SPGETCAPSDATA ) );
			spGetCapsData.dwSize = sizeof( SPGETCAPSDATA );
			spGetCapsData.hEndpoint = INVALID_HANDLE_VALUE;
			if ((hResultCode = pIDP8SP->lpVtbl->GetCaps( pIDP8SP, &spGetCapsData )) == DPN_OK)
			{
				if (!fSet || (spGetCapsData.dwEnumFrameSize < dwMinMax))
				{
					dwMinMax = spGetCapsData.dwEnumFrameSize;
					fSet = TRUE;
				}
			}

			pIDP8SP->lpVtbl->Release( pIDP8SP );
			pIDP8SP = NULL;
		}

		pBilink = pBilink->GetNext();
	}
	DNLeaveCriticalSection(&pdnObject->csServiceProviders);

	if (fSet)
	{
		DPF(9,"Setting *pdwEnumFrameSize [%ld]",dwMinMax);
		*pdwEnumFrameSize = dwMinMax;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_GENERIC;
	}

	DPF(8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_DumpNameTable"

HRESULT DIRECTNETOBJECT::DN_DumpNameTable(PVOID pInterface,char *const Buffer)
{
	DIRECTNETOBJECT	*pdnObject = this;

	DNASSERT(pInterface != NULL);
	DNASSERT(Buffer != NULL);

	pdnObject->NameTable.DumpNameTable(Buffer);

#if 0
	//
	//	TEMP - for test purposes only
	//
/*	REMOVE start */
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
		if (pdnObject->NameTable.GetLocalPlayer()->GetDPNID() == (DPNID)0x400004)
		{
			CNameTableEntry	*pNTEntry = NULL;

			if (pdnObject->NameTable.FindEntry(0x300003,&pNTEntry) == DPN_OK)
			{
				pNTEntry->GetConnection()->Disconnect();
				pNTEntry->Release();
				pNTEntry = NULL;
			}
		}
	}
/*	REMOVE end */
#endif
	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNAddRefLock"

HRESULT DNAddRefLock(DIRECTNETOBJECT *const pdnObject)
{
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if ((pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING)) ||
			!(pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		return(DPNERR_ALREADYCLOSING);
	}
	pdnObject->dwLockCount++;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNDecRefLock"

void DNDecRefLock(DIRECTNETOBJECT *const pdnObject)
{
	BOOL	fSetEvent;

	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwLockCount--;
	if ((pdnObject->dwLockCount == 0) && (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING))
	{
		fSetEvent = TRUE;
	}
	else
	{
		fSetEvent = FALSE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (fSetEvent)
	{
		SetEvent(pdnObject->hLockEvent);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\comstuff.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comstuff.h
 *  Content:    COM interface and object definition header file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	??/??/00	mjn		Created
 *	05/04/00	mjn		Changed dwRefCount's to lRefCount's to use InterlockedIncrement/Decrement
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef COMSTUFF_H
#define COMSTUFF_H

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#define GET_OBJECT_FROM_INTERFACE(a)	((INTERFACE_LIST*)(a))->pObject->pvData

#if !defined(__cplusplus) && !defined(CINTERFACE)

#ifdef THIS_
#undef THIS_
#define THIS_   LPVOID this,
#endif

#ifdef THIS
#undef THIS
#define THIS    LPVOID this
#endif

#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _INTERFACE_LIST	INTERFACE_LIST;
typedef struct _OBJECT_DATA		OBJECT_DATA;

typedef struct _INTERFACE_LIST {
	void			*lpVtbl;
	LONG			lRefCount;
	IID				iid;
	INTERFACE_LIST	*pIntNext;
	OBJECT_DATA		*pObject;
} INTERFACE_LIST;

typedef struct _OBJECT_DATA {
	LONG			lRefCount;
	void			*pvData;
	INTERFACE_LIST	*pIntList;
} OBJECT_DATA;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#endif // COMSTUFF_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\connection.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       connection.cpp
 *  Content:    Connection routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/13/99	mjn		Created
 *	03/02/00	mjn		Conversion to class 
 *	04/08/00	mjn		Added ServiceProvider to Connection object
 *				mjn		Disconnect uses new CAsyncOp class
 *	04/18/00	mjn		CConnection tracks connection status better
 *	04/21/00	mjn		Disconnection through DNPerformDisconnect
 *	07/20/00	mjn		Changed Release() behaviour and beefed up Disconnect()
 *	07/28/00	mjn		Added m_bilinkConnections to CConnection
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"



//	CConnection::ReturnSelfToPool
//
//	Return object to FPM

#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::ReturnSelfToPool"

void CConnection::ReturnSelfToPool( void )
{
	DPF(8,"Parameters: (none)");

	m_pdnObject->m_pFPOOLConnection->Release( this );

	DPF(8,"Returning");
};



#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::Release"

void CConnection::Release(void)
{
	LONG	lRefCount;

	DPF(8,"Parameters: (none)");

	DNASSERT(m_lRefCount > 0);
	lRefCount = InterlockedDecrement(const_cast<LONG*>(&m_lRefCount));
	DPF(25,"Connection::Release [0x%p] RefCount [0x%lx]",this,lRefCount);

	if (lRefCount == 0)
	{
		//
		//	Remove from the bilink of outstanding CConnection objects
		//
		DNEnterCriticalSection(&m_pdnObject->csAsyncOperations);
		m_bilinkConnections.RemoveFromList();
		DNLeaveCriticalSection(&m_pdnObject->csAsyncOperations);

		if (m_pSP)
		{
			m_pSP->Release();
			m_pSP = NULL;
		}
		m_dwFlags = 0;
		m_lRefCount = 0;
		m_hEndPt = NULL;
		ReturnSelfToPool();
	}

	DPF(8,"Returning");
};



#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::SetSP"

void CConnection::SetSP( CServiceProvider *const pSP )
{
	DPF(8,"Parameters: pSP [0x%p]",pSP);

	DNASSERT( pSP != NULL );

	pSP->AddRef();
	m_pSP = pSP;

	DPF(8,"Returning");
}



//	CConnection::Disconnect
//
//	Initiate a disconnection.  If this is successful, eventually we will receive an IndicateConnectionTerminated
//	which we should use to remove a reference (from the Protocol).

#undef DPF_MODNAME
#define DPF_MODNAME "CConnection::Disconnect"

void CConnection::Disconnect( void )
{
	BOOL		fDisconnect;

	DPF(8,"Parameters: (none)");

	DNASSERT(m_pdnObject != NULL);

	fDisconnect = FALSE;
	Lock();
	if ((m_Status == CONNECTING) || (m_Status == CONNECTED))
	{
		if (m_hEndPt != NULL)
		{
			m_Status = DISCONNECTING;
			fDisconnect = TRUE;
		}
		else
		{
			m_Status = INVALID;
		}
	}
	Unlock();

	if (fDisconnect)
	{
		DNPerformDisconnect(m_pdnObject,this,m_hEndPt);
	}

	DPF(8,"Returning");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\connection.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Connection.h
 *  Content:    Connection Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/29/00	mjn		Created
 *	04/08/00	mjn		Added ServiceProvider to Connection object
 *	04/18/00	mjn		CConnection tracks connection status better
 *	06/22/00	mjn		Replaced MakeConnecting(), MakeConnected(), MakeDisconnecting(), MakeInvalid() with SetStatus()
 *	07/20/00	mjn		Modified CConnection::Disconnect()
 *	07/28/00	mjn		Added send queue info structures
 *				mjn		Added m_bilinkConnections to CConnection
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/09/00	mjn		Added m_bilinkIndicated to CConnection
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CONNECTION_H__
#define	__CONNECTION_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	CONNECTION_FLAG_INVALID			0x80000000
#define	CONNECTION_FLAG_DISCONNECTING	0x40000000
#define	CONNECTION_FLAG_LOCAL			0x00000001

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CConnection > class CLockedContextClassFixedPool;

typedef enum {
	INVALID,
	CONNECTING,
	CONNECTED,
	DISCONNECTING
} CONNECTION_STATUS;

typedef struct _USER_SEND_QUEUE_INFO
{
	DWORD	dwNumOutstanding;
	DWORD	dwBytesOutstanding;
} USER_SEND_QUEUE_INFO;

class CServiceProvider;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for RefCount buffer

class CConnection
{
	STDNEWDELETE

public:
	CConnection()				// Constructor
		{
			m_Sig[0] = 'C';
			m_Sig[1] = 'O';
			m_Sig[2] = 'N';
			m_Sig[3] = 'N';
		};

	~CConnection() { };			// Destructor

	BOOL FPMAlloc(void *const pvContext)
		{
			if (!DNInitializeCriticalSection(&m_cs))
			{
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&m_cs,0);
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CConnection::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);
//			m_dwFlags = CONNECTION_FLAG_INVALID;
			m_dwFlags = 0;
			m_lRefCount = 1;
			m_hEndPt = NULL;
			m_dpnid = 0;
			m_pSP = NULL;
			m_Status = INVALID;

			//
			//	Queue info
			//
			m_QueueInfoHigh.dwNumOutstanding = 0;
			m_QueueInfoHigh.dwBytesOutstanding = 0;
			m_QueueInfoNormal.dwNumOutstanding = 0;
			m_QueueInfoNormal.dwBytesOutstanding = 0;
			m_QueueInfoLow.dwNumOutstanding = 0;
			m_QueueInfoLow.dwBytesOutstanding = 0;

			m_bilinkConnections.Initialize();
			m_bilinkIndicated.Initialize();

			return(TRUE);
		};

	void FPMRelease(void *const pvContext) { };

	void FPMDealloc(void *const pvContext)
		{
			DNDeleteCriticalSection(&m_cs);
		};

	void CConnection::ReturnSelfToPool( void );

	#undef DPF_MODNAME
	#define DPF_MODNAME "CConnection::AddRef"
	void AddRef(void)
		{
			LONG	lRefCount;

			DNASSERT(m_lRefCount > 0);
			lRefCount = InterlockedIncrement(const_cast<LONG*>(&m_lRefCount));
			DPF(3,"Connection::AddRef [0x%p] RefCount [0x%lx]",this,lRefCount);
		};

	void CConnection::Release(void);

	void Lock( void )
		{
			DNEnterCriticalSection( &m_cs );
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection( &m_cs );
		};

	void SetEndPt(const HANDLE hEndPt)
		{
			m_hEndPt = hEndPt;
		};

	HRESULT GetEndPt(HANDLE *const phEndPt,const BOOL bAddRef)
		{
			HRESULT		hResultCode;

			DNASSERT(phEndPt != NULL);

			Lock();
			if ((m_Status == CONNECTED) || (m_Status == CONNECTING))
			{
				if (bAddRef)
				{
					AddRef();
				}
				*phEndPt = m_hEndPt;
				hResultCode = DPN_OK;
			}
			else
			{
				hResultCode = DPNERR_NOCONNECTION;
			}
			Unlock();

			return(hResultCode);
		};

	void SetStatus( const CONNECTION_STATUS status )
		{
			m_Status = status;
		};

	BOOL IsConnecting( void )
		{
			if (m_Status == CONNECTING)
				return( TRUE );

			return( FALSE );
		};

	BOOL IsConnected( void )
		{
			if (m_Status == CONNECTED)
				return( TRUE );

			return( FALSE );
		};

	BOOL IsDisconnecting( void )
		{
			if (m_Status == DISCONNECTING)
				return( TRUE );

			return( FALSE );
		};

	BOOL IsInvalid( void )
		{
			if (m_Status == INVALID)
				return( TRUE );

			return( FALSE );
		};

	void SetDPNID(const DPNID dpnid)
		{
			m_dpnid = dpnid;
		};

	DPNID GetDPNID(void)
		{
			return(m_dpnid);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CConnection::MakeLocal"
	void MakeLocal(void)
		{
			DNASSERT(m_hEndPt == NULL);
			m_dwFlags |= CONNECTION_FLAG_LOCAL;
		};

	BOOL IsLocal(void)
		{
			if (m_dwFlags & CONNECTION_FLAG_LOCAL)
				return(TRUE);
				
			return(FALSE);
		};

	void CConnection::SetSP( CServiceProvider *const pSP );

	CServiceProvider *GetSP( void )
		{
			return( m_pSP );
		};

	void CConnection::Disconnect(void);

	void CConnection::AddToHighQueue( const DWORD dwBytes )
		{
			m_QueueInfoHigh.dwNumOutstanding++;
			m_QueueInfoHigh.dwBytesOutstanding += dwBytes;
		};

	void CConnection::AddToNormalQueue( const DWORD dwBytes )
		{
			m_QueueInfoNormal.dwNumOutstanding++;
			m_QueueInfoNormal.dwBytesOutstanding += dwBytes;
		};

	void CConnection::AddToLowQueue( const DWORD dwBytes )
		{
			m_QueueInfoLow.dwNumOutstanding++;
			m_QueueInfoLow.dwBytesOutstanding += dwBytes;
		};

	void CConnection::RemoveFromHighQueue( const DWORD dwBytes )
		{
			m_QueueInfoHigh.dwNumOutstanding--;
			m_QueueInfoHigh.dwBytesOutstanding -= dwBytes;
		};

	void CConnection::RemoveFromNormalQueue( const DWORD dwBytes )
		{
			m_QueueInfoNormal.dwNumOutstanding--;
			m_QueueInfoNormal.dwBytesOutstanding -= dwBytes;
		};

	void CConnection::RemoveFromLowQueue( const DWORD dwBytes )
		{
			m_QueueInfoLow.dwNumOutstanding--;
			m_QueueInfoLow.dwBytesOutstanding -= dwBytes;
		};

	DWORD CConnection::GetHighQueueNum( void )
		{
			return( m_QueueInfoHigh.dwNumOutstanding );
		};

	DWORD CConnection::GetHighQueueBytes( void )
		{
			return( m_QueueInfoHigh.dwBytesOutstanding );
		};

	DWORD CConnection::GetNormalQueueNum( void )
		{
			return( m_QueueInfoNormal.dwNumOutstanding );
		};

	DWORD CConnection::GetNormalQueueBytes( void )
		{
			return( m_QueueInfoNormal.dwBytesOutstanding );
		};

	DWORD CConnection::GetLowQueueNum( void )
		{
			return( m_QueueInfoLow.dwNumOutstanding );
		};

	DWORD CConnection::GetLowQueueBytes( void )
		{
			return( m_QueueInfoLow.dwBytesOutstanding );
		};

	CBilink				m_bilinkConnections;
	CBilink				m_bilinkIndicated;		// Indicated connections without DPNID's (players entries)

private:
	BYTE				m_Sig[4];
	DWORD	volatile	m_dwFlags;
	LONG	volatile	m_lRefCount;
	HANDLE	volatile	m_hEndPt;
	DPNID				m_dpnid;
	CServiceProvider	*m_pSP;
	CONNECTION_STATUS	m_Status;
	USER_SEND_QUEUE_INFO	m_QueueInfoHigh;
	USER_SEND_QUEUE_INFO	m_QueueInfoNormal;
	USER_SEND_QUEUE_INFO	m_QueueInfoLow;
	DNCRITICAL_SECTION	m_cs;
	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __CONNECTION_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\disconnect.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Disconnect.cpp
 *  Content:    DNET disconnection routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/15/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Fixed PlayerDisconnect to prevent user notification of
 *							deletion from ALL_PLAYERS group
 *  12/23/99	mjn		Added basic host migration functionality
 *	12/28/99	mjn		Complete outstanding operations in DNPlayerDisconnectNew
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	01/03/00	mjn		Added DNPrepareToDeletePlayer
 *	01/04/00	mjn		Added code to allow outstanding ops to complete at host migration
 *	01/06/99	mjn		Moved NameTable stuff to NameTable.h
 *	01/09/00	mjn		Keep number of players in Application Description
 *	01/10/00	mjn		Check AppDesc for host migration
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/18/00	mjn		Added DNAutoDestructGroups
 *	01/19/00	mjn		Replaced DN_SYNC_EVENT with CSyncEvent
 *	01/20/00	mjn		Fixed CBilink usage problem in DNLocalDisconnect
 *	01/22/00	mjn		Added DNProcessHostDestroyPlayer
 *	01/23/00	mjn		Update NameTable version for instructed disconnects
 *	01/24/00	mjn		Use DNNTUpdateVersion to update NameTable version
 *	01/25/00	mjn		Changed Host Migration to multi-step affair
 *	02/01/00	mjn		Implement Player/Group context values
 *	04/05/00	mjn		Updated DNProcessHostDestroyPlayer()
 *	04/12/00	mjn		Removed DNAutoDestructGroups - covered in NameTable.DeletePlayer()
 *				mjn		Don't set DN_OBJECT_FLAG_DISCONNECTING in DNPlayerDisconnect()
 *	04/18/00	mjn		Fixed player count problem
 *	04/19/00	mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	05/16/00	mjn		Do not take locks when clearing NameTable short-cut pointers
 *	06/06/00	mjn		Fixed DNPlayerDisconnect to always check for host migration in peer-peer mode w/ host migration flag
 *	07/07/00	mjn		Clear host migration status if new host disconnects during migration process
 *	07/20/00	mjn		Use ClearHostWithDPNID() to clear HostPlayer in DNPlayerDisconnectNew()
 *	07/29/00	mjn		Fix calls to DNUserConnectionTerminated()
 *	07/30/00	mjn		Use DNUserTerminateSession() rather than DNUserConnectionTerminated()
 *	07/31/00	mjn		Added hrReason to DNTerminateSession()
 *				mjn		Added dwDestroyReason to DNHostDisconnect()
 *				mjn		Removed DNProcessHostDestroyPlayer()
 *	07/31/00	mjn		Change DN_MSG_INTERNAL_DELETE_PLAYER to DN_MSG_INTERNAL_DESTROY_PLAYER
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Prevent DN_MSG_INTERNAL_DESTROY_PLAYER from being sent out in client/server
 *	08/06/00	mjn		Added CWorkerJob
 *	08/07/00	mjn		Added code to request peer-peer integrity checks and clean up afterwards
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/26/00	mjn		Removed locking from CNameTable::SetVersion() and CNameTable::GetNewVersion()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


//	DNPlayerDisconnectNew
//
//	Another player has issued a disconnect with the local player.
//	- If the disconnecting player is still in the nametable
//		- prepare to delete player
//		- Save one refcount to be released by DELETE_PLAYER from host or Close
//	- check host migration

#undef DPF_MODNAME
#define DPF_MODNAME "DNPlayerDisconnectNew"

HRESULT DNPlayerDisconnectNew(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid)
{
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pLocalPlayer;
	HRESULT				hResultCode;
	DPNID				dpnidNewHost;
	BOOL				fWasHost;
	BOOL				fRequestIntegrityCheck;

	DPF(4,"Parameters: dpnid [0x%lx]",dpnid);

	DNASSERT(pdnObject != NULL);

	pNTEntry = NULL;
	pLocalPlayer = NULL;

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		//
		//	The Server has disconnected
		//	We will indicate the connection terminated and shut down
		//
		DPF(5,"Server has disconnected from this client");
		DNUserTerminateSession(pdnObject,DPNERR_CONNECTIONLOST,NULL,0);
		DNTerminateSession(pdnObject,DPNERR_CONNECTIONLOST);
	}
	else
	{
		//
		//	Another peer has disconnected from this peer
		//	We will delete this player from the NameTable
		//	We may have to ask the host to perform an integrity check
		//
		DPF(5,"Peer has disconnected from this peer");
		if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find disconnecting player in NameTable");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
		fRequestIntegrityCheck = FALSE;
		pNTEntry->Lock();
		if (pNTEntry->IsAvailable())
		{
			fRequestIntegrityCheck = TRUE;
		}
		pNTEntry->Unlock();
		if (fRequestIntegrityCheck)
		{
			DNRequestIntegrityCheck(pdnObject,dpnid);
		}
		pdnObject->NameTable.DeletePlayer(dpnid,0);

		//
		//	If this was the Host, clear the short-cut pointer
		//
		fWasHost = pdnObject->NameTable.ClearHostWithDPNID( dpnid );

		//
		//	May need to clear HOST_MIGRATING flag
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if ((pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING) && (pdnObject->pNewHost == pNTEntry))
		{
			pdnObject->dwFlags &= ~(DN_OBJECT_FLAG_HOST_MIGRATING);
			pdnObject->pNewHost->Release();
			pdnObject->pNewHost = NULL;
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		//
		//	If HostMigration flag is set, check to see if we are the new Host.
		//	Otherwise, if the disconnecting player was the Host, the session is lost.
		//
		if (pdnObject->ApplicationDesc.AllowHostMigrate())
		{
			DPF(5,"Host-Migration was set - check for new Host");
			dpnidNewHost = 0;
			if ((hResultCode = DNFindNewHost(pdnObject,&dpnidNewHost)) == DPN_OK)
			{
				DPF(5,"New Host [0x%lx]",dpnidNewHost);
				if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef(&pLocalPlayer)) == DPN_OK)
				{
					if (pLocalPlayer->GetDPNID() == dpnidNewHost)
					{
						DPF(5,"Local player is new Host");
						hResultCode = DNPerformHostMigration1(pdnObject,dpnid);
					}

					pLocalPlayer->Release();
					pLocalPlayer = NULL;
				}
			}
		}
		else if (fWasHost)
		{
			DPF(5,"Host-Migration was not set - terminating session");
			DNUserTerminateSession(pdnObject,DPNERR_CONNECTIONLOST,NULL,0);
			DNTerminateSession(pdnObject,DPNERR_CONNECTIONLOST);
		}

		pNTEntry->Release();
		pNTEntry = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DNHostDisconnect
//
//	A player has initiated a disconnect with the host.
//	- Remove player from the name table
//	- Propegate DELETE_PLAYER messages to each player
#pragma TODO(minara,"Use pConnection instead of dpnidDisconnecting ?")

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostDisconnect"

HRESULT DNHostDisconnect(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnidDisconnecting,
						 const DWORD dwDestroyReason)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CPendingDeletion	*pPending;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_DESTROY_PLAYER	*pMsg;

	DPF(4,"Parameters: pdnObject [0x%p], dpnidDisconnecting [0x%lx], dwDestroyReason [0x%lx]",
			pdnObject,dpnidDisconnecting,dwDestroyReason);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnidDisconnecting != 0);

	pRefCountBuffer = NULL;
	pPending = NULL;
	pWorkerJob = NULL;

	// Remove entry from NameTable and inform other players, only if Host is NOT migrating
	//	Otherwise, clean-up first and wait for migration to complete before informing others
	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING))
	{
		DWORD			dwVersion;
		CNameTableEntry	*pNTEntry;

		dwVersion = 0;
		pNTEntry = NULL;

		if ((hResultCode = pdnObject->NameTable.FindEntry(dpnidDisconnecting,&pNTEntry)) == DPN_OK)
		{
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( dwDestroyReason );
			}
			pNTEntry->Unlock();
			pNTEntry->Release();
			pNTEntry = NULL;
		}
		hResultCode = pdnObject->NameTable.DeletePlayer(dpnidDisconnecting,&dwVersion);

		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{
			//
			//	Prepare internal message
			//
			if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_DESTROY_PLAYER),
					&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not allocate message buffer");
				DisplayDNError(0,hResultCode);
				goto Failure;
			}
			pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_DESTROY_PLAYER*>(pRefCountBuffer->GetBufferAddress());
			pMsg->dpnidLeaving = dpnidDisconnecting;
			pMsg->dwVersion = dwVersion;
			pMsg->dwVersionNotUsed = 0;
			pMsg->dwDestroyReason = dwDestroyReason;

			if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
			{
				DPFERR("Could not create worker job");
				DisplayDNError(0,hResultCode);
				goto Failure;
			}
			pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
			pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_DESTROY_PLAYER );
			pWorkerJob->SetSendNameTableOperationVersion( dwVersion );
			pWorkerJob->SetSendNameTableOperationDPNIDExclude( dpnidDisconnecting );
			pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

			DNQueueWorkerJob(pdnObject,pWorkerJob);
			pWorkerJob = NULL;

			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
	}
	else
	{
		//
		//	Put this on the Outstanding operation list
		//
		if ((hResultCode = PendingDeletionNew(pdnObject,&pPending)) == DPN_OK)
		{
			pPending->SetDPNID( dpnidDisconnecting );

			DNEnterCriticalSection(&pdnObject->csNameTableOpList);
			pPending->m_bilinkPendingDeletions.InsertBefore(&pdnObject->m_bilinkPendingDeletions);
			DNLeaveCriticalSection(&pdnObject->csNameTableOpList);

			pPending = NULL;
		}

		// See if we can continue with Host migration
		DNCheckReceivedAllVersions(pdnObject);
	}

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]", hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pPending)
	{
		pPending->ReturnSelfToPool();
		pPending = NULL;
	}
	goto Exit;
}


//	DNInstructedDisconnect
//
//	The host has instructed the local player to delete another player from the nametable
//	- If already closing
//		- ignore this message and return
//	- Prepare to delete player
//	- Release refcount of player

#undef DPF_MODNAME
#define DPF_MODNAME "DNInstructedDisconnect"

HRESULT DNInstructedDisconnect(DIRECTNETOBJECT *const pdnObject,
							   PVOID pv)
{
	HRESULT				hResultCode;
	DN_INTERNAL_MESSAGE_DESTROY_PLAYER	*pInfo;
	CNameTableEntry		*pNTEntry;

	DPF(4,"Parameters: pv [0x%p]",pv);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);

	pNTEntry = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_DESTROY_PLAYER*>(pv);

	DNASSERT(pInfo != NULL);
	DNASSERT(pInfo->dpnidLeaving != NULL);
	DNASSERT(pInfo->dwVersion != 0);

	DPF(5,"Deleting player [0x%lx]",pInfo->dpnidLeaving);

	//
	//	If the player is still in the NameTable, we will preset the destroy reason.
	//	We will also use this "hint" to initiate a disconnect just in case the protocol
	//	
	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnidLeaving,&pNTEntry)) == DPN_OK)
	{
		CConnection		*pConnection;
		HANDLE			hEndPt;

		pConnection = NULL;
		hEndPt = NULL;

		pNTEntry->Lock();
		if (pNTEntry->GetDestroyReason() == 0)
		{
			pNTEntry->SetDestroyReason( pInfo->dwDestroyReason );
		}
		pNTEntry->Unlock();

		//
		//	Attempt a disconnect
		//
		if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			if ((hResultCode = pConnection->GetEndPt(&hEndPt,FALSE)) == DPN_OK)
			{
				DNPerformDisconnect(pdnObject,pConnection,hEndPt);
			}
			pConnection->Release();
			pConnection = NULL;
		}
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	else
	{
		//
		//	Scan oustanding op list for integrity check request for this player and remove it if it exists
		//
		CBilink		*pBilink;
		CAsyncOp	*pAsyncOp;

		pAsyncOp = NULL;
		DNEnterCriticalSection(&pdnObject->csAsyncOperations);
		pBilink = pdnObject->m_bilinkAsyncOps.GetNext();
		while (pBilink != &pdnObject->m_bilinkAsyncOps)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkAsyncOps);
			if (pAsyncOp->GetOpType() == ASYNC_OP_REQUEST)
			{
				DN_SEND_OP_DATA	*pSendOpData;

				pSendOpData = reinterpret_cast<DN_SEND_OP_DATA*>(pAsyncOp->GetOpData());
				if ((pSendOpData != NULL) && (pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK))
				{
					DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK	*pMsg;

					pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK*>
						(reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION*>(pSendOpData->BufferDesc[1].pBufferData) + 1);
					if (pMsg->dpnidTarget == pInfo->dpnidLeaving)
					{
						pAsyncOp->AddRef();
						break;
					}
				}
			}
			pAsyncOp = NULL;
			pBilink = pBilink->GetNext();
		}
		DNLeaveCriticalSection(&pdnObject->csAsyncOperations);
		if (pAsyncOp != NULL)
		{
			DNASSERT(pAsyncOp->GetHandle() != 0);
			pdnObject->HandleTable.Destroy( pAsyncOp->GetHandle() );
			pAsyncOp->Release();
			pAsyncOp = NULL;
		}
	}
	pdnObject->NameTable.DeletePlayer(pInfo->dpnidLeaving,&pInfo->dwVersion);

	//
	//	Update NameTable version
	//
	pdnObject->NameTable.Lock();
	pdnObject->NameTable.SetVersion(pInfo->dwVersion);
	pdnObject->NameTable.Unlock();

	hResultCode = DPN_OK;

	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\connect.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Connect.cpp
 *  Content:    DNET connection routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/01/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *	12/23/99	mjn		Fixed Host and AllPlayers short-cut pointer use
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	12/29/99	mjn		Reformed DN_ASYNC_OP to use hParentOp instead of lpvUserContext
 *	12/29/99	mjn		Turned off Instance GUID verification - TODO - turn back on !
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Moved Misc Functions to DNMisc.h
 *	01/07/00	mjn		DNHostVerifyConnect ensures connection to Host player only
 *	01/08/00	mjn		Failed connection returns HRESULT and buffer from Host
 *	01/08/00	mjn		Added group owner to NameTable
 *	01/08/00	mjn		Changed DNERR_INVALIDHOST to DNERR_NOTHOST
 *	01/08/00	mjn		Removed unused connection info
 *	01/09/00	mjn		Transfer Application Description at connect
 *	01/10/00	mjn		Fixed Application Description usage
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/13/00	mjn		Removed DIRECTNETOBJECT from Pack/UnpackApplicationDesc
 *	01/14/00	mjn		Removed pvUserContext from DN_NAMETABLE_ENTRY
 *	01/14/00	mjn		Added password to DN_APPLICATION_DESC_PACKED_INFO
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/17/00	mjn		Fixed ConnectToPeer function names
 *	01/18/00	mjn		Moved Pack/UnpackNameTableInfo to NameTable.cpp
 *	01/24/00	mjn		Replaced on-wire message pointers to offsets
 *	02/01/00	mjn		Implement Player/Group context values
 *	03/23/00	mjn		Set player context through Connect
 *	03/24/00	mjn		Set player context through INDICATE_CONNECT notification
 *	04/03/00	mjn		Verify DNET version on connect
 *	04/09/00	mjn		Modified Connect process to use CAsyncOp
 *	04/16/00	mjn		DNSendMessage() uses CAsyncOp
 *	04/18/00	mjn		CConnection tracks connection status better
 *				mjn		Fixed player count problem
 *				mjn		Return connect user reply buffer
 *	04/19/00	mjn		Fixed DNConnectToHost2 to set DirectNet object flags to CONNECTED
 *				mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	04/20/00	mjn		Host queries for connecting players' address if not specified
 *	05/03/00	mjn		Prevent unrequired RETURN_BUFFER message when CONNECT fails on Host player
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/08/00	mjn		Host sets connecting player's Connection as soon as player entry created
 *	05/09/00	mjn		Fixed New Player connection sequence to send NAMETABLE_ACK earlier
 *	05/23/00	mjn		Added DNConnectToPeerFailed()
 *	06/14/00	mjn		Added DNGetLocalAddress()
 *	06/19/00	mjn		Fixed connect process to better handle ALL_ADAPTERS case
 *	06/22/00	mjn		NameTable::UnpackNameTableInfo() returns local players DPNID
 *				mjn		Replace CConnection::MakeConnecting(),MakeConnected() with SetStatus()
 *	06/24/00	mjn		Added DNHostDropPlayer() to handle failed existing player connects to new players
 *	06/25/00	mjn		Added code to update lobby when DISCONNECTED
 *	06/26/00	mjn		Indicate COULDNOTCONNECT to lobby if connect to Host fails
 *	06/27/00	rmt		Added abstraction for COM_Co(Un)Initialize
 *				mjn		Host will attempt to determine connecting player's address if not specified in connect block
 *	07/05/00	mjn		More robust handling of disconnecting joining players during connection process
 *	07/06/00	mjn		More connect fixes
 *	07/20/00	mjn		The CONNECT process was revamped - new completions, asyncop structure, messages
 *				mjn		Better error handling for shutdown in DNHostVerifyConnect()
 *				mjn		Fixed up DNHostDropPlayer() to inform NewPlayer of drop
 *	07/21/00	mjn		Added code to handle unreachable players during connect process
 *	07/22/00	mjn		Extract connecting player's DNET version
 *	07/25/00	mjn		Update connect parent async op's result at end of DNConnectToHost2()
 *	07/27/00	mjn		Fixed locking problem with CAsyncOp::MakeChild()
 *	07/29/00	mjn		Save connection in DNConnectToHost1() on connect parent for better clean up
 *	07/30/00	mjn		Renamed DNGetLocalAddress() to DNGetLocalDeviceAddress()
 *	07/31/00	mjn		Added hrReason to DNTerminateSession()
 *				mjn		Added dwDestroyReason to DNHostDisconnect()
 *	08/02/00	mjn		Removed unused code
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *  08/05/00	rmt		Bug #41356 - DPLAY8: CORE: Connections refused by DPlay leak address objects
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *	08/06/00	mjn		Added CWorkerJob
 *	08/08/00	mjn		Mark groups created after CREATE_GROUP
 *  08/15/00	rmt		Bug #42506 - DPLAY8: LOBBY: Automatic connection settings not being sent
 *	08/25/00	mjn		Perform queued NameTable operations in DNConnectToHost2()
 *	08/28/00	mjn		Only compare major version numbers in DNHostVerifyConnect()
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/05/00	mjn		Set NameTable DPNID mask when connecting
 *	09/13/00	mjn		Perform queued operations after creating group in DNConnectToHost2()
 *	09/17/00	mjn		Split CNameTable.m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *	09/26/00	mjn		Removed locking from CNameTable::SetVersion() and CNameTable::GetNewVersion()
 *	09/27/00	mjn		ACK nametable to Host after creating groups and local and host players
 *	10/11/00	mjn		Fixed up DNAbortConnect() and use it instead of DNConnectToHostFailed()
 *	10/17/00	mjn		Fixed clean up for unreachable players
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Structure definitions
//**********************************************************************

#define CompareGuid(a,b)                                         \
    (memcmp((PVOID)(a), (PVOID)(b), sizeof(GUID)))


//
//	Accept a connection from a NewPlayer as the Host in peer-to-peer, or as the Server in
//	Client-Server modes.
//
//	The connection process is a multi part affair, requiring a bit of
//	synchronization between the Host and the NewPlayer.
//
//	In the first part:
//		The Host waits for the NewPlayer to send player game info
//		The Host verifies that everything is in order
//	If everything is okay:
//		The Host assigns the NewPlayer a DNID,
//		Adds the NewPlayer to the Host's NameTable,
//		Sends the NameTable to the NewPlayer,
//		Sends an ADD_PLAYER message to existing players to add NewPlayer to their NameTable's
//	Otherwise:
//		Inform NewPlayer that connection process failed
//
//	In the second part:
//		The Host awaits confirmation from the NewPlayer that the table was received AND installed.
//		The Host instructs existing players to connect to the NewPlayer
//


//	DNHostConnect1
//
//	Called once the connecting player has sent his player info.
//
//	- Verify NewPlayer and application info
//	- Assign a DNID to NewPlayer
//	- Add NewPlayer to Host's NameTable
//	- Send Name table to NewPlayer
//	- Send ADD_PLAYER message to existing players
//
//		LPVOID				lpvData			Player and application info
//		DWORD				dwBufferSize	Size of player and application info
//		HANDLE				hEndPt			End point handle

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostConnect1"

HRESULT DNHostConnect1(DIRECTNETOBJECT *const pdnObject,
					   const PVOID pvBuffer,
					   const DWORD dwBufferSize,
					   CConnection *const pConnection)
{
	HRESULT		hResultCode;
	PWSTR		pwszName;
	LPWSTR		lpwszPassword;
	PVOID		pvData;
	PVOID		pvConnectData;
	DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO	*pInfo;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pAllPlayersGroup;
	CPackedBuffer		packedBuffer;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	IDirectPlay8Address	*pAddress;
//	DWORD				dwVersion;
	CPackedBuffer		PackedBuffer;
	void				*pvPlayerContext;
	BOOL		bPlayerVerified;
	BOOL		fDisconnect;
	HANDLE		hEndPt;
	void		*pvReplyBuffer;
	DWORD		dwReplyBufferSize;
	void		*pvReplyBufferContext;
#ifdef	DEBUG
	CHAR				DP8ABuffer[512];
	DWORD				DP8ASize;
#endif

	DPF(4,"Parameters: pvBuffer [0x%p], dwBufferSize [%ld], pConnection [0x%p]",pvBuffer,dwBufferSize,pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);
	DNASSERT(pConnection != NULL);

	pAddress = NULL;
	pRefCountBuffer = NULL;
	pNTEntry = NULL;
	pAllPlayersGroup = NULL;
	pWorkerJob = NULL;
	bPlayerVerified = FALSE;
	pvReplyBuffer = NULL;
	dwReplyBufferSize = 0;
	pvReplyBufferContext = NULL;

	//
	//	Extract player and application info
	//
	pInfo = (DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO *)pvBuffer;
	if (pInfo->dwNameOffset)
	{
		pwszName = reinterpret_cast<WCHAR*>(static_cast<BYTE*>(pvBuffer) + pInfo->dwNameOffset);
	}
	else
	{
		pwszName = NULL;
	}

	if (pInfo->dwPasswordOffset)
	{
		lpwszPassword = (LPWSTR)((char *)pvBuffer + pInfo->dwPasswordOffset);
	}
	else
	{
		lpwszPassword = NULL;
	}

	if (pInfo->dwDataOffset)
	{
		pvData = static_cast<void*>(static_cast<BYTE*>(pvBuffer) + pInfo->dwDataOffset);
	}
	else
	{
		pvData = NULL;
	}

	if (pInfo->dwConnectDataOffset)
	{
		pvConnectData = (PVOID)((char *)pvBuffer + pInfo->dwConnectDataOffset);
	}
	else
	{
		pvConnectData = NULL;
	}

	if (pInfo->dwURLOffset)
	{
		if ((hResultCode = DirectPlay8AddressCreate( IID_IDirectPlay8Address, (void **) &pAddress, NULL)) != S_OK)
		{
			DPFERR("Could not create IDirectPlay8Address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			return(hResultCode);
		}

		DPF(5,"Connecting Player URL [%s]",static_cast<char*>(pvBuffer) + pInfo->dwURLOffset);
		if ((hResultCode = pAddress->BuildFromURLA(
															static_cast<char*>(pvBuffer) + pInfo->dwURLOffset )) != DPN_OK)
		{
			DPFERR("Could not build IDirectPlay8Address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
	}
	else
	{
		DPF(5,"No address URL specified - Host will have to determine it");
		if ((hResultCode = pConnection->GetEndPt(&hEndPt,FALSE)) != DPN_OK)
		{
			DPFERR("Could not retrieve EndPoint from Connection");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		if ((hResultCode = DNGetClearAddress(pdnObject,hEndPt,&pAddress,TRUE)) != DPN_OK)
		{
			DPFERR("Could not determine Clear Address");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
#ifdef	DEBUG
		DP8ASize = 512;
		pAddress->GetURLA(DP8ABuffer,&DP8ASize);
		DPF(5,"Remote Address [%s]",DP8ABuffer);
#endif
	}

	DPF(5,"Connecting Player: Name [%S], Data Size [%ld], Connect Data Size [%ld]",
			pwszName,pInfo->dwDataSize,pInfo->dwConnectDataSize);

	//
	//	Ensure this connect is valid
	//
	if ((hResultCode = DNHostVerifyConnect(	pdnObject,
											pConnection,
											pInfo->dwFlags,
											pInfo->dwDNETVersion,
											lpwszPassword,
											&pInfo->guidApplication,
											&pInfo->guidInstance,
											pvConnectData,
											pInfo->dwConnectDataSize,
											pAddress,
											&pvPlayerContext,
											&pvReplyBuffer,
											&dwReplyBufferSize,
											&pvReplyBufferContext)) != DPN_OK)
	{
		DPF(5,"Connect failed, hResultCode = [0x%lx]",hResultCode);

		//
		//	Disconnect this connection.   We will also remove it from the indicated list.
		//
		DNEnterCriticalSection(&pdnObject->csConnectionList);
		if (!pConnection->m_bilinkIndicated.IsEmpty())
		{
			pConnection->Release();
		}
		pConnection->m_bilinkIndicated.RemoveFromList();
		DNLeaveCriticalSection(&pdnObject->csConnectionList);

		pConnection->Disconnect();	// Terminate this connection

		hResultCode = DPN_OK;	// We handled everything okay !
		goto Failure;			// For clean up
	}

	bPlayerVerified = TRUE;

	//
	//	I am assuming that the player count has been updated by HostVerifyConnect.
	//	That means that until we flag the connection as CONNECTed, we will manually
	//	have to decrement it.
	//

	//
	// Create player entry
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not get new NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// This function takes the lock internally
	pNTEntry->UpdateEntryInfo(	pwszName,
								pInfo->dwNameSize,
								pvData,
								pInfo->dwDataSize,
								DPNINFO_NAME | DPNINFO_DATA,
								FALSE);

	pNTEntry->SetDNETVersion( pInfo->dwDNETVersion );
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		pNTEntry->MakePeer();
	}
	else
	{
		pNTEntry->MakeClient();
	}

	if (pvPlayerContext)
	{
		pNTEntry->SetContext(pvPlayerContext);
	}
	pNTEntry->StartConnecting();
	pNTEntry->SetIndicated();
	pNTEntry->NotifyAddRef();
	pNTEntry->SetAddress(pAddress);
	pAddress->Release();
	pAddress = NULL;

	//
	//	Add player to NameTable
	//
	pdnObject->NameTable.Lock();
	if ((hResultCode = pdnObject->NameTable.AddEntry(pNTEntry)) != DPN_OK)
	{
		pdnObject->NameTable.Unlock();
		DPFERR("Could not add entry to NameTable");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pdnObject->NameTable.Unlock();

	//
	//	Set up connection
	//	The connection should be "CONNECTING" or a disconnect has been issued since the NewPlayer sent
	//	their connect info.  Once the DPNID is set on the connection, the standard disconnect handler
	//	will take care of clean up.  If the DPNID is NOT set on the connection, the disconnect code
	//	will just release the connection, without cleaning up the NameTable or the NameTableEntry.
	//	Since the NameTable version may have changed since the NewPlayer was added, we will need to
	//	delete the player from the NameTable (and generate a new version number).  We will flag this
	//	case, and just send out the DELETE_PLAYER message after sending out the ADD_PLAYER
	//
	pConnection->Lock();
	if (pConnection->IsConnecting())
	{
		pConnection->SetStatus( CONNECTED );
		fDisconnect = FALSE;
	}
	else
	{
		DPF(5,"NewPlayer has disconnected while joining - send out ADD_PLAYER and then DELETE_PLAYER");
		fDisconnect = TRUE;
	}
	pConnection->SetDPNID( pNTEntry->GetDPNID() );
	pNTEntry->SetConnection( pConnection );
	pConnection->Unlock();

	//
	//	Now that this connection is part of the NameTableEntry, remove it from the indicated list.
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	if (!pConnection->m_bilinkIndicated.IsEmpty())
	{
		pConnection->Release();
	}
	pConnection->m_bilinkIndicated.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	//
	//	Send name table to player
	//
	if (!fDisconnect)
	{
		hResultCode = DNSendConnectInfo(pdnObject,pNTEntry,pConnection,pvReplyBuffer,dwReplyBufferSize);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
		{
			DPFERR("Could not send name table to player");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
#pragma TODO(minara,"Clean up here")
			goto Failure;
		}
	}
	if (pvReplyBuffer)
	{
		DNUserReturnBuffer(pdnObject,DPN_OK,pvReplyBuffer,pvReplyBufferContext);
		pvReplyBuffer = NULL;
		dwReplyBufferSize = 0;
		pvReplyBufferContext = NULL;
	}

	//
	// Setup name table entry to be passed to other players
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		packedBuffer.Initialize(NULL,0);
		if ((hResultCode = pNTEntry->PackEntryInfo(&packedBuffer)) != DPNERR_BUFFERTOOSMALL)
		{
			DPFERR("Unknown error encountered trying to pack NameTableEntry");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		if ((hResultCode = RefCountBufferNew(pdnObject,packedBuffer.GetSizeRequired(),&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not create new RefCountBuffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
		if ((hResultCode = pNTEntry->PackEntryInfo(&packedBuffer)) != DPN_OK)
		{
			DPFERR("Could not pack NameTableEntry");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		//
		//	Send ADD_PLAYER messages to other players (with lower versions)
		//
		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
		{
			DPFERR("Could not create worker thread job (add player)");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
		pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_ADD_PLAYER );
		pWorkerJob->SetSendNameTableOperationVersion( pNTEntry->GetVersion() );
		pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	//
	//	If we were in the process of disconnecting, we will need to clean up now
	//
	if (fDisconnect)
	{
		DNHostDisconnect(pdnObject,pNTEntry->GetDPNID(),0);
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	// Now, wait for synchronization (player has loaded name table)

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pvReplyBuffer)
	{
		//
		//	Return buffer to HostPlayer
		//
		DNUserReturnBuffer(pdnObject,DPN_OK,pvReplyBuffer,pvReplyBufferContext);
		pvReplyBuffer = NULL;
		dwReplyBufferSize = 0;
		pvReplyBufferContext = NULL;
	}
	if (bPlayerVerified)
	{
		pdnObject->ApplicationDesc.DecPlayerCount();
	}
	if (pAddress)
	{
		pAddress->Release();
		pAddress = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pAllPlayersGroup)
	{
		pAllPlayersGroup->Release();
		pAllPlayersGroup = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	goto Exit;
}


//	DNHostConnect2
//
//	Mark player as "available" in NameTable
//	Send INSTRUCT_CONNECT messages to the existing players to add new player
//
//		CConnection		*pConnection		Connection for connecting player
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostConnect2"

HRESULT DNHostConnect2(DIRECTNETOBJECT *const pdnObject,
					   CConnection *const pConnection)
{
	HRESULT				hResultCode;
	DPNID				dpnid;
	CRefCountBuffer		*pRefCountBuffer;
	CNameTableEntry		*pNTEntry;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT	*pInfo;

	DPF(4,"Parameters: pConnection [0x%p]",pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	pRefCountBuffer = NULL;
	pNTEntry = NULL;
	pWorkerJob = NULL;

	pConnection->Lock();
	dpnid = pConnection->GetDPNID();
	pConnection->Unlock();

	pdnObject->NameTable.PopulateConnection(pConnection);

	//
	// Instruct existing players to connect to NewPlayer
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		DPF(5,"Instruct existing players to connect to NewPlayer [0x%lx]",dpnid);

		// Need version number of this player
		if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not AddRef count buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT),
				&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not create CountBuffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT*>(pRefCountBuffer->GetBufferAddress());
		pInfo->dpnid = dpnid;

		pdnObject->NameTable.Lock();
		pdnObject->NameTable.GetNewVersion( &pInfo->dwVersion );
		pdnObject->NameTable.Unlock();
		pInfo->dwVersionNotUsed = 0;

		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
		{
			DPFERR("Could not create worker thread job (add player)");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
		pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_INSTRUCT_CONNECT );
		pWorkerJob->SetSendNameTableOperationVersion( pInfo->dwVersion );
		pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;

		pNTEntry->Release();
		pNTEntry = NULL;

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNHostVerifyConnect
//
//	Host connection verification.  Ensure that the player connecting meets ALL criteria
//	including:
//		correct mode (client/server or peer/peer)
//		correct instance guid
//		correct application (if specified)
//		correct password (if specified)
//		correct user spec (through call-back)
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostVerifyConnect"

HRESULT DNHostVerifyConnect(DIRECTNETOBJECT *const pdnObject,
							CConnection *const pConnection,
							const DWORD dwFlags,
							const DWORD dwDNETVersion,
							PWSTR const pwszPassword,
							GUID *const pguidApplication,
							GUID *const pguidInstance,
							PVOID const pvConnectData,
							const DWORD dwConnectDataSize,
							IDirectPlay8Address *const pAddress,
							void **const ppvPlayerContext,
							void **const ppvReplyBuffer,
							DWORD *const pdwReplyBufferSize,
							void **const ppvReplyBufferContext)
{
	HRESULT			hResultCode;
	HRESULT			hrFailure;
	PVOID			pvReplyData;
	DWORD			dwReplyDataSize;
	PVOID			pvReplyContext;
	DWORD			dwBufferSize;
	HANDLE			hEndPt;
	CNameTableEntry	*pLocalPlayer;
	CRefCountBuffer	*pRefCountBuffer;
	CPackedBuffer	packedBuffer;
	IDirectPlay8Address	*pDevice;
	DN_INTERNAL_MESSAGE_CONNECT_FAILED		*pInfo;
	BOOL			fDecPlayerCount;
#ifdef	DEBUG
	CHAR				DP8ABuffer[512];
	DWORD				DP8ASize;
#endif

	DPF(6,"Parameters: dwFlags [0x%lx], dwDPlay8Version [0x%lx], pwszPassword [0x%p], pguidApplication [0x%p], pguidInstance [0x%p], pvConnectData [0x%p], dwConnectDataSize [%ld]",
			dwFlags,dwDNETVersion,pwszPassword,pguidApplication,pguidInstance,pvConnectData,dwConnectDataSize);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppvReplyBuffer != NULL);
	DNASSERT(pdwReplyBufferSize != NULL);
	DNASSERT(ppvReplyBufferContext != NULL);

	pLocalPlayer = NULL;
	pRefCountBuffer = NULL;
	pvReplyData = NULL;
	dwReplyDataSize = 0;
	pvReplyContext = NULL;
	pDevice = NULL;
	fDecPlayerCount = FALSE;

	//
	//	Ensure we're not closing or host migrating
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPNERR_ALREADYCLOSING;
		goto CleanUp;
	}
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Ensure we are the Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Connection received by non-host player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	if (!pLocalPlayer->IsHost())
	{
		DPFERR("Connection received by non-host player");
		hResultCode = DPNERR_NOTHOST;
		goto Failure;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Verify Mode
	//
	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_PEER) && !(dwFlags & DN_OBJECT_FLAG_PEER))
	{
		DPF(7,"Non peer player attempting connection to peer");
		hResultCode = DPNERR_INVALIDINTERFACE;
		goto Failure;
	}
	if ((pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER) && !(dwFlags & DN_OBJECT_FLAG_CLIENT))
	{
		DPF(7,"Non client player attempting connection to server");
		hResultCode = DPNERR_INVALIDINTERFACE;
		goto Failure;
	}

	//
	//	Verify DNET version	- we will only compare the high 16-bits (major number)
	//						- we will allow different low 16-bits (minor number)
	//
	if ((dwDNETVersion & 0xffff0000) != (DN_VERSION_CURRENT & 0xffff0000))
	{
		DPF(7,"Invalid DPlay8 version!");
		hResultCode = DPNERR_INVALIDVERSION;
		goto Failure;
	}

	//
	//	Validate instance GUID
	//
	if (pguidInstance && CompareGuid(pguidInstance,&GUID_NULL))
	{
		if (!pdnObject->ApplicationDesc.IsEqualInstanceGuid(pguidInstance))
		{
			DPFERR("Invalid Instance GUID specified at connection");
			hResultCode = DPNERR_INVALIDINSTANCE;
			goto Failure;
		}
	}

	//
	//	Validate application (if specified)
	//
	if (pguidApplication && CompareGuid(pguidApplication,&GUID_NULL))
	{
		if (!pdnObject->ApplicationDesc.IsEqualApplicationGuid(pguidApplication))
		{
			DPFERR("Invalid Application GUID specified at connection");
			hResultCode = DPNERR_INVALIDAPPLICATION;
			goto Failure;
		}
	}

	//
	//	Validate password
	//
	if (!pdnObject->ApplicationDesc.IsEqualPassword(pwszPassword))
	{
		DPFERR("Incorrect password (required) specified at connection");
		hResultCode = DPNERR_INVALIDPASSWORD;
		goto Failure;
	}

	//
	//	Get device address this connection came in on
	//
	if ((hResultCode = pConnection->GetEndPt(&hEndPt,FALSE)) != DPN_OK)
	{
		DPFERR("Could not extract endpoint from CConnection");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_GENERIC;	// Is there a better one ?
		goto Failure;
	}
	if ((hResultCode = DNGetLocalDeviceAddress(pdnObject,hEndPt,&pDevice)) != DPN_OK)
	{
		DPFERR("Could not determine local device address");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_GENERIC;	// Is there a better one ?
		goto Failure;
	}
#ifdef	DEBUG
		DP8ASize = 512;
		pDevice->GetURLA(DP8ABuffer,&DP8ASize);
		DPF(5,"Local Device Address [%s]",DP8ABuffer);
#endif

	//
	//	Increment AppDesc count
	//
	hResultCode = pdnObject->ApplicationDesc.IncPlayerCount( TRUE );
	if (hResultCode != DPN_OK)
	{
		DPF(7,"Could not add player to game");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	fDecPlayerCount = TRUE;		// only for error handling

	//
	//	Validate user specified data (through call-back)
	//
	if (pvConnectData)
	{

		DPF(7,"dwConnectDataSize [%ld]",dwConnectDataSize);
	}
	else
	{
		DPF(7,"No connect data given");
	}

	if ((hResultCode = DNUserIndicateConnect(	pdnObject,
												pvConnectData,
												dwConnectDataSize,
												&pvReplyData,
												&dwReplyDataSize,
												&pvReplyContext,
												pAddress,
												pDevice,
												ppvPlayerContext)) != DPN_OK)
	{
		DPFERR("Application declined connection attempt");
		hResultCode = DPNERR_HOSTREJECTEDCONNECTION;
		goto Failure;
	}

	pDevice->Release();
	pDevice = NULL;

	//
	//	Save reply buffer
	//
	if ((pvReplyData) && (dwReplyDataSize != 0))
	{
		*ppvReplyBuffer = pvReplyData;
		*pdwReplyBufferSize = dwReplyDataSize;
		*ppvReplyBufferContext = pvReplyContext;
	}
	else
	{
		*ppvReplyBuffer = NULL;
		*pdwReplyBufferSize = 0;
		*ppvReplyBufferContext = NULL;
	}

Exit:

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:

	if (fDecPlayerCount)
	{
		pdnObject->ApplicationDesc.DecPlayerCount();
	}

	//
	//	Send a message back to the connecting player that this failed
	//
	DPF(7,"Connect failed [0x%lx]",hResultCode);
	hrFailure = hResultCode;
	if (pvReplyData == NULL)
	{
		dwReplyDataSize = 0;	// basic validation
	}
	dwBufferSize = sizeof(DN_INTERNAL_MESSAGE_CONNECT_FAILED) + dwReplyDataSize;
	DPF(7,"Failure buffer is [%ld] bytes",dwBufferSize);

	//
	//	Create and fill failure message buffer
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,dwBufferSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		goto CleanUp;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_CONNECT_FAILED*>(pRefCountBuffer->GetBufferAddress());
	if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CONNECT_FAILED))) != DPN_OK)
	{
		DPFERR("Could not add header to message buffer");
		DisplayDNError(0,hResultCode);
		goto CleanUp;
	}
	if (pvReplyData)
	{
		if ((hResultCode = packedBuffer.AddToBack(pvReplyData,dwReplyDataSize)) != DPN_OK)
		{
			DPFERR("Could not add reply to failure buffer");
			DisplayDNError(0,hResultCode);
			goto CleanUp;
		}
		pInfo->dwReplyOffset = packedBuffer.GetTailOffset();
		pInfo->dwReplySize = dwReplyDataSize;
		DNUserReturnBuffer(pdnObject,DPN_OK,pvReplyData,pvReplyContext);	// Return buffer
	}
	else
	{
		pInfo->dwReplyOffset = 0;
		pInfo->dwReplySize = 0;
	}
	pInfo->hResultCode = hrFailure;

	//
	//	Send failure message
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_CONNECT_FAILED,
								NULL,
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

CleanUp:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pDevice)
	{
		pDevice->Release();
		pDevice = NULL;
	}
	goto Exit;
}


//
//	DNHostDropPlayer
//
//	An existing player in a peer-peer game could not connect to a NewPlayer and is informing the
//	Host of this situation.  As a result, the Host will drop inform the NewPlayer of this and then
//	drop the NewPlayer from the game
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNHostDropPlayer"

HRESULT DNHostDropPlayer(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,		//	ExistingPlayer who could not connect to NewPlayer
						 void *const pvBuffer)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;
	DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED	*pInfo;
	DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED		*pMsg;

	DPF(4,"Parameters: pvBuffer [0x%p]",pvBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL);

	pRefCountBuffer = NULL;
	pNTEntry = NULL;
	pConnection = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED*>(pvBuffer);
	DPF(5,"Connection to [0x%lx] failed",pInfo->dpnid);

	//
	//	Get connection for NewPlayer
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("NewPlayer no longer in NameTable - not to worry");
		hResultCode = DPN_OK;
		goto Failure;
	}
	if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Connection for NewPlayer no longer valid - not to worry");
		hResultCode = DPN_OK;
		goto Failure;
	}
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	Send message to NewPlayer informing them of which existing player could not connect to them
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED*>(pRefCountBuffer->GetBufferAddress());
	pMsg->dpnid = dpnid;
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED,
								pInfo->dpnid,
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send message to NewPlayer - assume he is gone or going");
		hResultCode = DPN_OK;
		goto Failure;
	}
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	We will just drop (or at least attempt to drop) the connection
	//
	pConnection->Disconnect();
	pConnection->Release();
	pConnection = NULL;

	hResultCode = DNHostDisconnect(pdnObject,pInfo->dpnid,DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


//
//	Perform a connection to a host player (either host in peer-to-peer or server in client-server).
//	This processes the handshaking of the name table between the host and the player.
//	The first step is to send the player and application info to the host for verification
//	The second step is to receive and process the name table from the host
//	The last step is to wait for connections from other players and populate the name table
//	It assumes that the connection to the host has already been initiated.
//

//	DNPrepareConnectInfo
//
//	Prepare the connection info block which will be sent to the Host player once a connection
//	has been established.

#undef DPF_MODNAME
#define DPF_MODNAME "DNPrepareConnectInfo"

HRESULT DNPrepareConnectInfo(DIRECTNETOBJECT *const pdnObject,
							 CConnection *const pConnection,
							 CRefCountBuffer **const ppRefCountBuffer)
{
	HRESULT				hResultCode;
	DWORD				dwSize;
	DWORD				dwPasswordSize;
	DWORD				dwAddressSize;
	HANDLE				hEndPt;
	CRefCountBuffer		*pRefCountBuffer;
	CPackedBuffer		packedBuffer;
	IDirectPlay8Address		*pAddress;
	DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO *pInfo;
#ifdef	DEBUG
	CHAR				DP8ABuffer[512];
	DWORD				DP8ASize;
#endif

	DPF(4,"Parameters: pConnection [0x%p], ppRefCountBuffer [0x%p]",pConnection,ppRefCountBuffer);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);
	DNASSERT(ppRefCountBuffer != NULL);

	pRefCountBuffer = NULL;
	pAddress = NULL;
	dwAddressSize = 0;

	//
	//	Get clear address
	//
	dwAddressSize = 0;
	if ((hResultCode = pConnection->GetEndPt(&hEndPt,TRUE)) == DPN_OK)
	{
		if ((hResultCode = DNGetClearAddress(pdnObject,hEndPt,&pAddress,FALSE)) == DPN_OK)
		{
			if (pAddress != NULL)
			{
				// Get address URL size
				pAddress->GetURLA(NULL,&dwAddressSize);
				DNASSERT(dwAddressSize != 0);
#ifdef	DEBUG
				DP8ASize = 512;
				pAddress->GetURLA(DP8ABuffer,&DP8ASize);
				DPF(5,"Remote Address [%s]",DP8ABuffer);
#endif
			}
		}
		pConnection->Release();
	}

	// Determine total size of connection info buffer
	if (pdnObject->ApplicationDesc.GetPassword() != NULL)
		dwPasswordSize = (wcslen(pdnObject->ApplicationDesc.GetPassword()) + 1) * sizeof(WCHAR);
	else
		dwPasswordSize = 0;

	dwSize = sizeof(DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO)
			+ pdnObject->dwConnectDataSize
			+ dwAddressSize
			+ dwPasswordSize
			+ pdnObject->NameTable.GetDefaultPlayer()->GetDataSize()
			+ pdnObject->NameTable.GetDefaultPlayer()->GetNameSize();

	// Allocate connection info buffer
	DPF(7,"Need to allocate [%ld] bytes",dwSize);
	if ((hResultCode = RefCountBufferNew(pdnObject,dwSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate space for connection info");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pInfo = static_cast<DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO*>(packedBuffer.GetHeadAddress());

	// Type of interface
	pInfo->dwFlags = pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER | DN_OBJECT_FLAG_CLIENT | DN_OBJECT_FLAG_SERVER);

	// Version of DIRECTNET
	pInfo->dwDNETVersion = DN_VERSION_CURRENT;

	// Name
	if (pdnObject->NameTable.GetDefaultPlayer()->GetNameSize())
	{
		if ((hResultCode = packedBuffer.AddToBack(pdnObject->NameTable.GetDefaultPlayer()->GetName(),
				pdnObject->NameTable.GetDefaultPlayer()->GetNameSize())) != DPN_OK)
		{
			DPFERR("Could not add name to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwNameOffset = packedBuffer.GetTailOffset();
		pInfo->dwNameSize = pdnObject->NameTable.GetDefaultPlayer()->GetNameSize();
	}
	else
	{
		pInfo->dwNameOffset = 0;
		pInfo->dwNameSize = 0;
	}

	// Player data
	if (pdnObject->NameTable.GetDefaultPlayer()->GetData() && pdnObject->NameTable.GetDefaultPlayer()->GetDataSize())
	{
		if ((hResultCode = packedBuffer.AddToBack(pdnObject->NameTable.GetDefaultPlayer()->GetData(),
				pdnObject->NameTable.GetDefaultPlayer()->GetDataSize())) != DPN_OK)
		{
			DPFERR("Could not add connect data to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwDataOffset = packedBuffer.GetTailOffset();
		pInfo->dwDataSize = pdnObject->NameTable.GetDefaultPlayer()->GetDataSize();
	}
	else
	{
		pInfo->dwDataOffset = 0;
		pInfo->dwDataSize = 0;
	}

	// Password
	if (dwPasswordSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(pdnObject->ApplicationDesc.GetPassword(),dwPasswordSize)) != DPN_OK)
		{
			DPFERR("Could not add password to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwPasswordOffset = packedBuffer.GetTailOffset();
		pInfo->dwPasswordSize = dwPasswordSize;
	}
	else
	{
		pInfo->dwPasswordOffset = 0;
		pInfo->dwPasswordSize = 0;
	}

	// Connect data
	if (pdnObject->pvConnectData)
	{
		if ((hResultCode = packedBuffer.AddToBack(pdnObject->pvConnectData,pdnObject->dwConnectDataSize)) != DPN_OK)
		{
			DPFERR("Could not add connect data to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwConnectDataOffset = packedBuffer.GetTailOffset();
		pInfo->dwConnectDataSize = pdnObject->dwConnectDataSize;
	}
	else
	{
		pInfo->dwConnectDataOffset = 0;
		pInfo->dwConnectDataSize = 0;
	}

	// Clear address URL
	if (dwAddressSize)
	{
		if ((hResultCode = packedBuffer.AddToBack(NULL,dwAddressSize)) != DPN_OK)
		{
			DPFERR("Could not add address URL to connection buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		if ((hResultCode = pAddress->GetURLA(
													static_cast<char*>(packedBuffer.GetTailAddress()),
													&dwAddressSize)) != DPN_OK)
		{
			DPFERR("Could not get address URL");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo->dwURLOffset = packedBuffer.GetTailOffset();
		pInfo->dwURLSize = dwAddressSize;
	}
	else
	{
		pInfo->dwURLOffset = 0;
		pInfo->dwURLSize = 0;
	}

	// Instance and appplication GUIDs
	memcpy(&pInfo->guidInstance,pdnObject->ApplicationDesc.GetInstanceGuid(),sizeof(GUID));
	memcpy(&pInfo->guidApplication,pdnObject->ApplicationDesc.GetApplicationGuid(),sizeof(GUID));

	*ppRefCountBuffer = pRefCountBuffer;
	pRefCountBuffer = NULL;

	if (pAddress)
	{
		pAddress->Release();
		pAddress = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:

	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pAddress)
	{
		pAddress->Release();
		pAddress = NULL;
	}

	goto Exit;
}



//	DNConnectToHost1
//
//	After receiving protocol level connection acknowledgement, send player and application info
//		CConnection	*pConnection	Connection to host

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToHost1"

HRESULT DNConnectToHost1(DIRECTNETOBJECT *const pdnObject,
						 CConnection *const pConnection)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CAsyncOp			*pAsyncOp;
	CAsyncOp			*pConnectParent;

	DPF(4,"Parameters: pConnection [0x%p]",pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pConnection != NULL);

	pRefCountBuffer = NULL;
	pAsyncOp = NULL;
	pConnectParent = NULL;

	//
	//	Get connect parent (and make sure we're not closing)
	//	We will also store the CConnection on the connect parent for future clean up.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
		DPFERR("Object is CLOSING or DISCONNECTING");
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		pConnection->Disconnect();
		hResultCode = DPN_OK;
		goto Failure;
	}
	DNASSERT(pdnObject->pConnectParent != NULL);
	pdnObject->pConnectParent->SetConnection( pConnection );	
	pdnObject->pConnectParent->AddRef();
	pConnectParent = pdnObject->pConnectParent;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Prepare connect info
	//
	if ((hResultCode = DNPrepareConnectInfo(pdnObject,pConnection,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not prepare connect info");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	DNASSERT(pRefCountBuffer != NULL);

	//
	//	Send connect info
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_PLAYER_CONNECT_INFO,
								0,
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								pConnectParent,
								&pAsyncOp);

	if (hResultCode == DPNERR_PENDING)
	{
		pAsyncOp->SetCompletion( DNCompleteSendConnectInfo );
		pAsyncOp->Release();
		pAsyncOp = NULL;

		hResultCode = DPN_OK;
	}
	else
	{
		//
		//	Save error code, clean up DirectNetObject and fail
		//
		DNAbortConnect(pdnObject,hResultCode);
	}

	pConnectParent->Release();
	pConnectParent = NULL;
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}
	goto Exit;
}


//	DN_ConnectToHost2
//
//	Extract and install the host supplied name table
//	Send name table acknowledgement to the host
//	Propegate ADD_PLAYER messages to the application for host and local players
//	Propegate CREATE_GROUP messages to the application for groups in the name table
//
//		PVOID		pvData			NameTable buffer
//		CConnection	*pConnection	Connection to host

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToHost2"

HRESULT DNConnectToHost2(DIRECTNETOBJECT *const pdnObject,
						 const PVOID pvData,
						 CConnection *const pConnection)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pHostPlayer;
	CNameTableEntry		*pLocalPlayer;
	CNameTableOp		*pNTOp;
	CBilink				*pBilink;
	DPNID				dpnid;
	DWORD				dwFlags = NULL;
	CConnection			*pLocalConnection;
	BOOL				fNotify;
//	void				*pvContext;
	IDirectPlay8Address	*pIDevice;
	IDirectPlay8Address	*pIHost;
	CAsyncOp			*pListenParent;
	CAsyncOp			*pConnectParent;
	HANDLE				hEndPt;

	DPF(4,"Parameters: pvData [0x%p], pConnection [0x%p]",pvData,pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvData != NULL);
	DNASSERT(pConnection != NULL);

	pNTEntry = NULL;
	pHostPlayer = NULL;
	pLocalPlayer = NULL;
	pLocalConnection = NULL;
	pIDevice = NULL;
	pIHost = NULL;
	pListenParent = NULL;
	pConnectParent = NULL;

	//
	//	Initial try to catch a close
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Extract application description and name table
	//
	if ((hResultCode = DNReceiveConnectInfo(pdnObject,pvData,pConnection,&dpnid)) != DPN_OK)
	{
		DPFERR("Could not extract name table passed by host");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Get Connection object for local player
	//
	if ((hResultCode = ConnectionNew(pdnObject,&pLocalConnection)) != DPN_OK)
	{
		DPFERR("Could not create new Connection");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Get Host and Local players
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Local player");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	if ((hResultCode = pConnection->GetEndPt(&hEndPt,FALSE)) != DPN_OK)
	{
		DPFERR("Could not get end point from connection");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Ensure we have an address for the Host player
	//
	if (pHostPlayer->GetAddress() == NULL)
	{
		if ((hResultCode = DNGetClearAddress(pdnObject,hEndPt,&pIHost,TRUE)) != DPN_OK)
		{
			DPFERR("Could not get clear address for Host player");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pHostPlayer->SetAddress(pIHost);
		pIHost->Release();
		pIHost = NULL;
	}

	//
	//	Start LISTENs for CONNECTs from existing players in Peer-Peer mode
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		if ((hResultCode = DNGetLocalDeviceAddress(pdnObject,hEndPt,&pIDevice)) != DPN_OK)
		{
			DPFERR("Could not get LISTEN address from endpoint");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		// Parent Async Op
		if ((hResultCode = AsyncOpNew(pdnObject,&pListenParent)) != DPN_OK)
		{
			DPFERR("Could not create AsyncOp");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pListenParent->SetOpType( ASYNC_OP_LISTEN );
		pListenParent->MakeParent();
		pListenParent->SetCompletion( DNCompleteListen );

		// Perform child LISTEN
		hResultCode = DNPerformSPListen(pdnObject,
										pIDevice,
										pListenParent,
										NULL);
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not perform child LISTEN");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}

		// Store parent LISTEN on DirectNet object
#pragma BUGBUG( minara, "What if we are closing down and have already terminated all listens ?" )
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		pListenParent->AddRef();
		pdnObject->pListenParent = pListenParent;
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		pListenParent->Release();
		pListenParent = NULL;
		pIDevice->Release();
		pIDevice = NULL;
	}

	//
	//	Indicate player connected - we will perform this before notifying the host so that
	//	DN_OBJECT_FLAG_CONNECTED is set when existing player CONNECTs come in
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
#pragma TODO( minara, "Shut down listen" )
		hResultCode = DPN_OK;
		goto Failure;
	}
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_CONNECTING);
	pdnObject->dwFlags |= DN_OBJECT_FLAG_CONNECTED;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Inform application of groups and players.
	//	We will inform the application of
	//		- CREATE_GROUP
	//		- ADD_PLAYER (for Local and Host players)
	//		- ADD_PLAYER_TO_GROUP
	//

	pdnObject->NameTable.Lock();
	pBilink = pdnObject->NameTable.m_bilinkGroups.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkGroups)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->AddRef();
		pdnObject->NameTable.Unlock();

		fNotify = FALSE;
		pNTEntry->Lock();
		if (!pNTEntry->IsAvailable() && !pNTEntry->IsDisconnecting() && !pNTEntry->IsAutoDestructGroup())
		{
			pNTEntry->MakeAvailable();
			pNTEntry->NotifyAddRef();
			pNTEntry->NotifyAddRef();
			pNTEntry->SetInUse();
			fNotify = TRUE;
		}
		pNTEntry->Unlock();

		if (fNotify)
		{
			DNASSERT(!pNTEntry->IsAllPlayersGroup());
			DNUserCreateGroup(pdnObject,pNTEntry);

			pNTEntry->PerformQueuedOperations();

			pdnObject->NameTable.PopulateGroup( pNTEntry );
		}

		pNTEntry->Release();
		pNTEntry = NULL;

		pdnObject->NameTable.Lock();
		if (pBilink->IsEmpty())
		{
			pBilink = pdnObject->NameTable.m_bilinkGroups.GetNext();
		}
		else
		{
			pBilink = pBilink->GetNext();
		}
	}
	pNTEntry = NULL;
	pdnObject->NameTable.Unlock();

	//
	//	We will pre-set the Host connection, so that any operation from the CREATE_PLAYER notification call-back
	//	for the local player will be able to find the Host player's connection (to send messages to).  We will
	//	not, however, expose the Host player to the user yet.
	//
	pHostPlayer->Lock();
	pHostPlayer->SetConnection( pConnection );
	pHostPlayer->Unlock();

	//
	// Add Local player
	//
	pLocalConnection->SetStatus( CONNECTED );
	pLocalConnection->SetEndPt(NULL);
	pLocalConnection->MakeLocal();

	//
	//	Preset player context
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	DNASSERT(pdnObject->pConnectParent);
	if (pdnObject->pConnectParent)
	{
		pdnObject->pConnectParent->AddRef();
		pConnectParent = pdnObject->pConnectParent;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (pConnectParent)
	{
		pConnectParent->Lock();
		if (pConnectParent->GetContext())
		{
			pLocalPlayer->Lock();
			pLocalPlayer->SetContext(pConnectParent->GetContext());
			pLocalPlayer->Unlock();
		}
		pConnectParent->SetResult( DPN_OK );
		pConnectParent->Unlock();
		pConnectParent->Release();
		pConnectParent = NULL;
	}

	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER|DN_OBJECT_FLAG_SERVER))
	{
		pdnObject->ApplicationDesc.IncPlayerCount( FALSE );
		pLocalConnection->SetDPNID(pLocalPlayer->GetDPNID());
		pdnObject->NameTable.PopulateConnection(pLocalConnection);
	}
	else
	{
		pLocalPlayer->Lock();
		pLocalPlayer->SetConnection(pLocalConnection);
		pLocalPlayer->StopConnecting();
		pLocalPlayer->MakeAvailable();
		pLocalPlayer->Unlock();

		pdnObject->NameTable.DecOutstandingConnections();
	}
	pLocalConnection->Release();
	pLocalConnection = NULL;

	//
	// Add Host player
	//
	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER|DN_OBJECT_FLAG_SERVER))
	{
		pdnObject->ApplicationDesc.IncPlayerCount( FALSE );
		pConnection->SetDPNID(pHostPlayer->GetDPNID());
		pConnection->SetStatus( CONNECTED );
		pdnObject->NameTable.PopulateConnection(pConnection);
	}
	else
	{
		pConnection->SetStatus( CONNECTED );

		pHostPlayer->Lock();
//		pHostPlayer->SetConnection(pConnection);
		pHostPlayer->StopConnecting();
		pHostPlayer->MakeAvailable();
		pHostPlayer->Unlock();

		pdnObject->NameTable.DecOutstandingConnections();
	}

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Process any nametable operations that might have arrived
	//
	pdnObject->NameTable.Lock();
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		if ((pNTOp->GetVersion() == (pdnObject->NameTable.GetVersion() + 1))
				&& !pNTOp->IsInUse())
		{
			pNTOp->SetInUse();
			pdnObject->NameTable.Unlock();

			hResultCode = DNNTPerformOperation(	pdnObject,
												pNTOp->GetMsgId(),
												pNTOp->GetRefCountBuffer()->GetBufferAddress() );

			pdnObject->NameTable.Lock();
		}
		else
		{
			//
			//	Once we find an operation that we won't perform, there is no point continuing
			//
			break;
		}
		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	//
	//	Send conect info acknowledgement to host
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_ACK_CONNECT_INFO,
								pHostPlayer->GetDPNID(),
								NULL,
								NULL,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);

	pHostPlayer->Release();
	pHostPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pLocalConnection)
	{
		pLocalConnection->Release();
		pLocalConnection = NULL;
	}
	if (pIDevice)
	{
		pIDevice->Release();
		pIDevice = NULL;
	}
	if (pIHost)
	{
		pIHost->Release();
		pIHost = NULL;
	}
	if (pListenParent)
	{
		pListenParent->Release();
		pListenParent = NULL;
	}
	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}
	goto Exit;
}


//	DNConnectToHostFailed
//
//	Clean up if an attempt to connect to the HostPlayer fails

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToHostFailed"

HRESULT	DNConnectToHostFailed(DIRECTNETOBJECT *const pdnObject,
							  PVOID const pvBuffer,
							  const DWORD dwBufferSize)
{
	CAsyncOp		*pConnectParent;
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_CONNECT_FAILED			*pInfo;

	DPF(4,"Parameters: pvBuffer [0x%p], dwBufferSize [%ld]",pvBuffer,dwBufferSize);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvBuffer != NULL || dwBufferSize == 0);

	pRefCountBuffer = NULL;
	pConnectParent = NULL;

	if (pvBuffer != NULL)
	{
		pInfo = static_cast<DN_INTERNAL_MESSAGE_CONNECT_FAILED*>(pvBuffer);
		if ((pInfo->dwReplyOffset != 0) && (pInfo->dwReplySize != 0))
		{
			//
			//	Extract reply buffer
			//
			if ((hResultCode = RefCountBufferNew(pdnObject,pInfo->dwReplySize,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer - ignore and continue");
				DisplayDNError(0,hResultCode);
			}
			else
			{
				memcpy(	pRefCountBuffer->GetBufferAddress(),
						static_cast<BYTE*>(pvBuffer) + pInfo->dwReplyOffset,
						pInfo->dwReplySize );
			}
		}

		//
		//	Update connect operation parent with results
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		DNASSERT(pdnObject->pConnectParent);
		if (pdnObject->pConnectParent)
		{
			pdnObject->pConnectParent->Lock();
			pdnObject->pConnectParent->SetResult( pInfo->hResultCode );
			pdnObject->pConnectParent->SetRefCountBuffer( pRefCountBuffer );
			pdnObject->pConnectParent->Unlock();
		}
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		if (pRefCountBuffer)
		{
			pRefCountBuffer->Release();
			pRefCountBuffer = NULL;
		}
DPF(0,"ConnectToHostFailed: [0x%lx]",pInfo->hResultCode);
	}

	//
	//	Clean up DirectNetObject
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_HOST_CONNECTED));
	if (pdnObject->pConnectParent)
	{
		pConnectParent = pdnObject->pConnectParent;
		pdnObject->pConnectParent = NULL;
	}
	if( pdnObject->pIDP8ADevice )
	{
		pdnObject->pIDP8ADevice->Release();
		pdnObject->pIDP8ADevice = NULL;
	}
	if( pdnObject->pConnectAddress )
	{
		pdnObject->pConnectAddress->Release();
		pdnObject->pConnectAddress = NULL;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}

	DPF(4,"Returning: DPN_OK");
	return(DPN_OK);
}



//
//	DNAbortConnect
//
//	Abort the CONNECT process by cleaning up the DirectNet object and terminating the session
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNAbortConnect"

HRESULT DNAbortConnect(DIRECTNETOBJECT *const pdnObject,
					   const HRESULT hrConnect)
{
	HRESULT		hResultCode;
	CAsyncOp	*pConnectParent;

	DPF(4,"Parameters: hrConnect [0x%lx]",hrConnect);

	DNASSERT(pdnObject != NULL);

	pConnectParent = NULL;

	//
	//	Clean up DirectNetObject
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_HOST_CONNECTED));
	if (pdnObject->pConnectParent)
	{
		pConnectParent = pdnObject->pConnectParent;
		pdnObject->pConnectParent = NULL;
	}
	if( pdnObject->pIDP8ADevice )
	{
		pdnObject->pIDP8ADevice->Release();
		pdnObject->pIDP8ADevice = NULL;
	}
	if( pdnObject->pConnectAddress )
	{
		pdnObject->pConnectAddress->Release();
		pdnObject->pConnectAddress = NULL;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Set error code on connect operation completion
	//
	if (pConnectParent)
	{
		pConnectParent->Lock();
		pConnectParent->SetResult( hrConnect );
		pConnectParent->Unlock();
	}

	//
	//	Shut down
	//
	DNTerminateSession(pdnObject,DPN_OK);

	if (pConnectParent)
	{
		pConnectParent->Release();
		pConnectParent = NULL;
	}

	hResultCode = DPN_OK;

	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//	Player to player connection occurs at the direction of the host. (Peer-to-peer)
//
//	Once a NewPlayer has connected to the host,
//		The Host will send the NewPlayer's NameTable entry to all existing players
//	Once the NewPlayer has installed the NameTable, it informs the host
//		The Host will instruct the existing players to connect to the NewPlayer
//
//	When an existing player establishes a connection with the NewPlayer
//		The existing player send their DNID to the NewPlayer and an ADD_PLAYER to app
//		The NewPlayer activates the connecting (existing) player and sends ADD_PLAYER to app
//


//	DNPlayerConnect1
//
//	Receive an existing player's DNID.  This is called by the NewPlayer.  If valid, send an
//	ADD_PLAYER message to the application

#undef DPF_MODNAME
#define DPF_MODNAME "DNPlayerConnect1"

HRESULT	DNPlayerConnect1(DIRECTNETOBJECT *const pdnObject,
						 const PVOID pv,
						 CConnection *const pConnection)
{
	HRESULT						hResultCode;
	CNameTableEntry				*pPlayer;
	DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID	*pSend;

	DPF(4,"Parameters: pv [0x%p], pConnection [0x%p]",pv,pConnection);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);
	DNASSERT(pConnection != NULL);

	pPlayer = NULL;

	pSend = static_cast<DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID*>(pv);
	DNASSERT(pSend->dpnid != 0);

	DPF(5,"Player [0x%lx] has connected",pSend->dpnid);

	if ((hResultCode = pdnObject->NameTable.FindEntry(pSend->dpnid,&pPlayer)) != DPN_OK)
	{
		DPFERR("Could not find connecting player!");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Increment players in session
	//
	pdnObject->ApplicationDesc.IncPlayerCount( FALSE );

	// Associate DNID with player's connection
	pConnection->Lock();
	pConnection->SetDPNID(pSend->dpnid);
	pConnection->SetStatus( CONNECTED );
	pConnection->Unlock();

	// Populate connection
	pdnObject->NameTable.PopulateConnection(pConnection);

	//
	//	Now that this connection is part of a NameTableEntry, remove it from the indicated list
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	if (!pConnection->m_bilinkIndicated.IsEmpty())
	{
		pConnection->Release();
	}
	pConnection->m_bilinkIndicated.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	pPlayer->Release();
	pPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


//	DNConnectToPeer1
//
//	Accept the NameTable entry of the NewPlayer from the Host, and add it to the local
//	NameTable.  The Host will later provide an INSTRUCT_CONNECT message later.

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToPeer1"

HRESULT	DNConnectToPeer1(DIRECTNETOBJECT *const pdnObject,
						 PVOID const pv)
{
	HRESULT					hResultCode;
	DN_NAMETABLE_ENTRY_INFO	*pdnNTEInfo;
	CNameTableEntry			*pNTEntry;
//	DWORD					dwVersion;

	DPF(4,"Parameters: pv [0x%p]",pv);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);

	pNTEntry = NULL;

	//
	//	Create and unpack new entry
	//
	if ((hResultCode = NameTableEntryNew(pdnObject,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not create new NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pdnNTEInfo = static_cast<DN_NAMETABLE_ENTRY_INFO*>(pv);
	DPF(5,"New player DNID [0x%lx] - installing NameTable entry",pdnNTEInfo->dpnid);
	DPF(5,"Connecting Player URL [%s]",static_cast<char*>(pv) + pdnNTEInfo->dwURLOffset);
	if ((hResultCode = pNTEntry->UnpackEntryInfo(pdnNTEInfo,static_cast<BYTE*>(pv))) != DPN_OK)
	{
		DPFERR("Could not unpack NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pNTEntry->StartConnecting();

	//
	//	Add entry to NameTable
	//
	if ((hResultCode = pdnObject->NameTable.InsertEntry(pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not insert NameTableEntry into NameTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Update NameTableVersion
	//
	pdnObject->NameTable.Lock();
	pdnObject->NameTable.SetVersion( pdnNTEInfo->dwVersion );
	pdnObject->NameTable.Unlock();

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNConnectToPeer2
//
//	Perform a connection to the NewPlayer (as instructed by Host).
//	Once this connection has completed (DNConnectToPeer2) send this player's DNID

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToPeer2"

HRESULT DNConnectToPeer2(DIRECTNETOBJECT *const pdnObject,
						 PVOID const pv)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pLocalPlayer;
	DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT	*pInfo;

	DPF(4,"Parameters: pv [0x%p]", pv);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pv != NULL);

	pNTEntry = NULL;
	pLocalPlayer = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT*>(pv);

	//
	//	Update NameTable version
	//
	pdnObject->NameTable.Lock();
	pdnObject->NameTable.SetVersion( pInfo->dwVersion );
	pdnObject->NameTable.Unlock();

	//
	//	Determine if this is an instruction to connect to ourselves.
	//	If it is, don't do anything other than update the NameTable version
	//
	DPF(5,"Instructed to connect to [0x%lx]",pInfo->dpnid);
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if (pLocalPlayer->GetDPNID() == pInfo->dpnid)
	{
		DPF(5,"Ignoring instruction to connect to self");
		hResultCode = DPN_OK;
		goto Failure;
	}

	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find NameTableEntry");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	We will not connect to older players.  They will connect to us.
	//
	if (pNTEntry->GetVersion() < pLocalPlayer->GetVersion())
	{
		DPF(5,"Ignoring instruction to connect to older player");
		hResultCode = DPN_OK;
		goto Failure;
	}
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

#if 0
#pragma BUGBUG( minara, "REMOVE THIS" )
	//
	//	TEMPORARY !
	//
	hResultCode = DNConnectToPeerFailed(pdnObject,pNTEntry->GetDPNID());
	goto Failure;
#endif

	// Connect to new player
	DPF(5,"Performing Connect");
	DNASSERT(pdnObject->pIDP8ADevice != NULL);
	hResultCode = DNPerformConnect(	pdnObject,
									pNTEntry->GetDPNID(),
									pdnObject->pIDP8ADevice,
									pNTEntry->GetAddress(),
									0,
									NULL);

	if (hResultCode == DPNERR_PENDING)
		hResultCode = DPN_OK;

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DNConnectToPeer3
//
//	Finish the connection process to the NewPlayer.
//	Once the connection has completed send this player's DNID to NewPlayer and propegate
//	ADD_PLAYER message

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToPeer3"

HRESULT	DNConnectToPeer3(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 CConnection *const pConnection)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	CNameTableEntry		*pLocalPlayer;
	CRefCountBuffer		*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID	*pSend;

	DPF(4,"Parameters: dpnid [0x%lx], pConnection [0x%p]",dpnid,pConnection);

	DNASSERT(dpnid != NULL);
	DNASSERT(pConnection != NULL);

	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pRefCountBuffer = NULL;

	//
	//	increment players in session
	//
	pdnObject->ApplicationDesc.IncPlayerCount( FALSE );

	// Associate DNID with player's end point handle
	pConnection->Lock();
	pConnection->SetDPNID(dpnid);
	pConnection->SetStatus( CONNECTED );
	pConnection->Unlock();

	//
	//	Get New Players's entry
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find new player");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Get Local player's entry
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	// Setup buffer to pass local player's DNID
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID),
			&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate buffer to send connecting player DPNID");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pSend = reinterpret_cast<DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID*>(pRefCountBuffer->GetBufferAddress());
	pSend->dpnid = pLocalPlayer->GetDPNID();

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	// Send player's DNID to new player
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_SEND_PLAYER_DNID,
								dpnid,
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send connecting player DPNID");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//	Update NameTableEntry with Connection
	pdnObject->NameTable.PopulateConnection(pConnection);
	
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNConnectToPeerFailed
//
//	An existing player could not connect to a NewPlayer.
//	Send a message to the Host player that this connect attempt failed

#undef DPF_MODNAME
#define DPF_MODNAME "DNConnectToPeerFailed"

HRESULT DNConnectToPeerFailed(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pHost;
	CConnection		*pConnection;
	CRefCountBuffer	*pRCBuffer;
	DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED	*pMsg;

	DPF(4,"Parameters: dpnid [0x%lx]",dpnid);

	DNASSERT(pdnObject != NULL);
	DNASSERT(dpnid != 0);

	pHost = NULL;
	pConnection = NULL;
	pRCBuffer = NULL;

	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHost )) != DPN_OK)
	{
		DPFERR("Could not get Host player reference");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((hResultCode = pHost->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get Host Connection reference");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Create message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED),&pRCBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pMsg = reinterpret_cast<DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED*>(pRCBuffer->GetBufferAddress());
	pMsg->dpnid = dpnid;

	//
	//	Send message
	//
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED,
								pHost->GetDPNID(),
								pRCBuffer->BufferDescAddress(),
								pRCBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send CONNECT_FAILED message - maybe OUR connection is down !");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Clean up
	//
	pHost->Release();
	pHost = NULL;
	pConnection->Release();
	pConnection = NULL;
	pRCBuffer->Release();
	pRCBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHost)
	{
		pHost->Release();
		pHost = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRCBuffer)
	{
		pRCBuffer->Release();
		pRCBuffer = NULL;
	}
	goto Exit;
}


//	DNSendConnectInfo
//
//	Send connection info to a new player.
//	This is the Host Applcation Description and the NameTable
//	This uses an enumeration buffer.
//	The format of the buffer is:
//		<DN_INTERNAL_MESSAGE_CONNECT_INFO>
//		<DN_APPLICATION_DESC>
//		<DN_INTERNAL_MESSAGE_SEND_NAMETABLE>
//			<DN_NAMETABLE_ENTRY_INFO>
//			<DN_NAMETABLE_ENTRY_INFO>
//				:
//		<strings and data blocks>
//
//	DNID	dnId		DNID of new player

#undef DPF_MODNAME
#define DPF_MODNAME "DNSendConnectInfo"

HRESULT	DNSendConnectInfo(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry *const pNTEntry,
						  CConnection *const pConnection,
						  void *const pvReplyBuffer,
						  const DWORD dwReplyBufferSize)
{
	HRESULT					hResultCode;
	CPackedBuffer			packedBuffer;
	CRefCountBuffer			*pRefCountBuffer;
	DN_INTERNAL_MESSAGE_CONNECT_INFO	*pMsg;

	DPF(6,"Parameters: pNTEntry [0x%p], pConnection [0x%p], pvReplyBuffer [0x%p], dwReplyBufferSize [%ld]",
			pNTEntry,pConnection,pvReplyBuffer,dwReplyBufferSize);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pNTEntry != NULL);

	//
	//	Determine size of message
	//
	packedBuffer.Initialize(NULL,0);
	packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CONNECT_INFO));
	packedBuffer.AddToBack(NULL,dwReplyBufferSize);
	pdnObject->ApplicationDesc.PackInfo(&packedBuffer,
			DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	pdnObject->NameTable.PackNameTable(pNTEntry,&packedBuffer);

	//
	//	Create buffer
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,packedBuffer.GetSizeRequired(),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	packedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());

	//
	//	Fill in buffer
	//
	pMsg = static_cast<DN_INTERNAL_MESSAGE_CONNECT_INFO*>(packedBuffer.GetHeadAddress());
	if ((hResultCode = packedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_CONNECT_INFO))) != DPN_OK)
	{
		DPFERR("Could not add CONNECT_INFO struct to packed buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((pvReplyBuffer) && (dwReplyBufferSize != 0))
	{
		if ((hResultCode = packedBuffer.AddToBack(pvReplyBuffer,dwReplyBufferSize)) != DPN_OK)
		{
			DPFERR("Could not add reply buffer to packed buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pMsg->dwReplyOffset = packedBuffer.GetTailOffset();
		pMsg->dwReplySize = dwReplyBufferSize;
	}
	else
	{
		pMsg->dwReplyOffset = 0;
		pMsg->dwReplySize = 0;
	}

	hResultCode = pdnObject->ApplicationDesc.PackInfo(&packedBuffer,
			DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_PASSWORD|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not pack ApplicationDesc");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((hResultCode = pdnObject->NameTable.PackNameTable(pNTEntry,&packedBuffer)) != DPN_OK)
	{
		DPFERR("Could not pack NameTable");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	// Send the name table to target
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_SEND_CONNECT_INFO,
								pNTEntry->GetDPNID(),
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send connect info to joining player");
		DisplayDNError(0,hResultCode);
//		DNASSERT(FALSE);
		goto Failure;
	}

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}



//	DNReceiveConnectInfo
//
//	Receive connect info from the host/server player.
//	This is the Application Description and the NameTable
//	The name table is in an enum buffer, with relative pointer references which will have
//	to be turned into absolutes.  This process requires two passes of the buffer.
//	The first pass will extract PLAYERS, and the second pass will extract groups.
//
//	PVOID				pvNTBuffer		Pointer to name table enum buffer
//	DWORD				dwNumEntries	Number of entries in the name table

#undef DPF_MODNAME
#define DPF_MODNAME "DNReceiveConnectInfo"

HRESULT	DNReceiveConnectInfo(DIRECTNETOBJECT *const pdnObject,
							 void *const pvBuffer,
							 CConnection *const pHostConnection,
							 DPNID *const pdpnid)
{
	HRESULT		hResultCode;
	void		*pvReplyBuffer;
	DWORD		dwReplyBufferSize;
	DPN_APPLICATION_DESC_INFO	*pdnAppDescInfo;
	DN_NAMETABLE_INFO			*pdnNTInfo;
	CRefCountBuffer				*pRefCountBuffer;
	CAsyncOp					*pConnect;
	DN_INTERNAL_MESSAGE_CONNECT_INFO	*pMsg;

	DPF(6,"Parameters: pvBuffer [0x%p], pHostConnection [0x%p], pdpnid [0x%p]",
			pvBuffer,pHostConnection,pdpnid);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pdpnid != NULL);
	DNASSERT(pvBuffer != NULL);
	DNASSERT(pHostConnection != NULL);

	pRefCountBuffer = NULL;
	pConnect = NULL;

	//
	//	Pull fixed structures from front of buffer
	//
	pMsg = static_cast<DN_INTERNAL_MESSAGE_CONNECT_INFO*>(pvBuffer);
	pdnAppDescInfo = reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(pMsg + 1);
	pdnNTInfo = reinterpret_cast<DN_NAMETABLE_INFO*>(pdnAppDescInfo + 1);

	//
	//	Extract reply buffer
	//
	pvReplyBuffer = static_cast<void*>(static_cast<BYTE*>(pvBuffer) + pMsg->dwReplyOffset);
	dwReplyBufferSize = pMsg->dwReplySize;
	DPF(7,"Reply Buffer [0x%p]=[%s] [%ld]",pvReplyBuffer,pvReplyBuffer,dwReplyBufferSize);
	if ((hResultCode = RefCountBufferNew(pdnObject,dwReplyBufferSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCountBuffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	memcpy(pRefCountBuffer->GetBufferAddress(),pvReplyBuffer,dwReplyBufferSize);
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->pConnectParent)
	{
		pdnObject->pConnectParent->AddRef();
		pConnect = pdnObject->pConnectParent;
		pConnect->SetRefCountBuffer( pRefCountBuffer );
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	//
	//	Extract Application Description
	//
	DPF(7,"Extracting Application Description");
	hResultCode = pdnObject->ApplicationDesc.UnpackInfo(pdnAppDescInfo,pvBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME |
			DN_APPDESCINFO_FLAG_PASSWORD | DN_APPDESCINFO_FLAG_RESERVEDDATA | DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not unpack ApplicationDesc");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Set player count (Host and LocalPlayer)
	//
#pragma BUGBUG( minara,"What should happen here ?" )
//	dnAppDesc.dwCurrentPlayers = 2;

	//
	//	Extract NameTable
	//
	DPF(7,"Extracting NameTable");
	DPF(7,"Set DPNID mask to [0x%lx]",pdnObject->ApplicationDesc.GetDPNIDMask());
	pdnObject->NameTable.SetDPNIDMask( pdnObject->ApplicationDesc.GetDPNIDMask() );
	if ((hResultCode = pdnObject->NameTable.UnpackNameTableInfo(pdnNTInfo,static_cast<BYTE*>(pvBuffer),pdpnid)) != DPN_OK)
	{
		DPFERR("Could not unpack NameTable");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		//
		//	Create ALL_PLAYERS group
		//
		CNameTableEntry	*pAllPlayersGroup;

		pAllPlayersGroup = NULL;

		if ((hResultCode = NameTableEntryNew(pdnObject,&pAllPlayersGroup)) != DPN_OK)
		{
			DPFERR("Could not create NameTableEntry");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pAllPlayersGroup->MakeGroup();

		// This function takes the lock internally
		pAllPlayersGroup->UpdateEntryInfo(	DN_ALL_PLAYERS_GROUP_NAME,
											DN_ALL_PLAYERS_GROUP_NAME_SIZE,
											NULL,
											0,
											DPNINFO_NAME|DPNINFO_DATA,
											FALSE);
		
		pdnObject->NameTable.MakeAllPlayersGroup(pAllPlayersGroup);
		
		pAllPlayersGroup->Release();
		pAllPlayersGroup = NULL;

		DNASSERT(pAllPlayersGroup == NULL);
	}

	if (pConnect)
	{
		pConnect->Release();
		pConnect = NULL;
	}

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pConnect)
	{
		pConnect->SetResult( hResultCode );		// Try and salvage something !
		pConnect->Release();
		pConnect = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNGetClearAddress"

HRESULT DNGetClearAddress(DIRECTNETOBJECT *const pdnObject,
						  const HANDLE hEndPt,
						  IDirectPlay8Address **const ppAddress,
						  const BOOL fPartner)
{
	SPGETADDRESSINFODATA	spInfoData;
	HRESULT					hResultCode;
#ifdef	DEBUG
	CHAR					DP8ABuffer[512];
	DWORD					DP8ASize;
#endif

	DPF(6,"Parameters: hEndPt [0x%p], ppAddress [0x%p], fPartner [%ld]",hEndPt,ppAddress,fPartner);

	DNASSERT(pdnObject != NULL);
	DNASSERT(hEndPt != NULL);
	DNASSERT(ppAddress != NULL);

	if (fPartner)
	{
		spInfoData.Flags = SP_GET_ADDRESS_INFO_REMOTE_HOST;
	}
	else
	{
		spInfoData.Flags = SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS;
	}

	hResultCode = DNPCrackEndPointDescriptor(hEndPt,&spInfoData);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Unknown error from DNPCrackEndPointDescriptor");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Exit;
	}
	*ppAddress = spInfoData.pAddress;
	spInfoData.pAddress = NULL;

#ifdef	DEBUG
	if (*ppAddress)
	{
		DP8ASize = 512;
		(*ppAddress)->GetURLA(DP8ABuffer,&DP8ASize);
		DPF(5,"Remote Address [%s]",DP8ABuffer);
	}
#endif

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNGetLocalDeviceAddress"

HRESULT DNGetLocalDeviceAddress(DIRECTNETOBJECT *const pdnObject,
								const HANDLE hEndPt,
								IDirectPlay8Address **const ppAddress)
{
	SPGETADDRESSINFODATA	spInfoData;
	HRESULT					hResultCode;
#ifdef	DEBUG
	CHAR					DP8ABuffer[512];
	DWORD					DP8ASize;
#endif

	DPF(6,"Parameters: hEndPt [0x%p], ppAddress [0x%p]",hEndPt,ppAddress);

	DNASSERT(pdnObject != NULL);
	DNASSERT(hEndPt != NULL);
	DNASSERT(ppAddress != NULL);

	spInfoData.Flags = SP_GET_ADDRESS_INFO_LOCAL_ADAPTER;

	hResultCode = DNPCrackEndPointDescriptor(hEndPt,&spInfoData);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Unknown error from DNPCrackEndPointDescriptor");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Exit;
	}
	*ppAddress = spInfoData.pAddress;
	spInfoData.pAddress = NULL;

#ifdef	DEBUG
	if (*ppAddress)
	{
		DP8ASize = 512;
		(*ppAddress)->GetURLA(DP8ABuffer,&DP8ASize);
		DPF(7,"Remote Address [%s]",DP8ABuffer);
	}
#endif

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\dncorei.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dnaddri.h
 *  Content:    DirectPlayAddress master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/28/00    dereks  Created.
 *  09/11/00	mgere	Converted to DPlay
 *
 ***************************************************************************/

#ifndef __DNCOREI_H__
#define __DNCOREI_H__

//
// Public includes
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//#include <stddef.h>
#include <ntos.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#include <xtl.h>
#include <xobjbase.h>
#ifdef ENABLE_DPLAY_VOICE
#include <Dvoicep.h>
#endif
#include <xdbg.h>
#include <dplay8p.h>
#include <DPAddrp.h>
#include <DPSP8p.h>
#ifdef DPLAY_DOWORK_STATEMN
#include <statemn.h>
#endif

#ifdef __cplusplus

template <class type> type *__AddRef(type *p)
{
    if(p)
    {
        p->AddRef();
    }

    return p;
}

#define ADDREF(p) \
    __AddRef(p)

template <class type> void __Release(type **pp)
{
    type * p = *pp;

    if(p)
    {
        p->Release();
    }
}

#define RELEASE(p) \
    __Release(&(p))

#endif // __cplusplus

//
// Private includes
//

#include "dndbg.h"
#include "DNetErrors.h"
#include "OSInd.h"
#include "ClassBilink.h"
#include "fpm.h"
#include "PackBuff.h"
#include "LockedCCFPM.h"
#include "RCBuffer.h"
#include "dnpextern.h"
#include "dnprot.h"
#include "comstuff.h"
#include "comutil.h"

typedef	struct DPN_APPLICATION_DESC_INFO DPN_APPLICATION_DESC_INFO;
typedef struct _HANDLETABLE_ARRAY_ENTRY HANDLETABLE_ARRAY_ENTRY;
typedef struct IDirectPlay8Address	IDirectPlay8Address;

class DIRECTNETOBJECT;
class CPackedBuffer;
class CRefCountBuffer;
class CSyncEvent;
class CConnection;
class CGroupConnection;
class CGroupMember;
class CNameTableEntry;
class CNameTableOp;
class CAsyncOp;
class CPendingDeletion;
class CQueuedMsg;
class CWorkerJob;
class CMemoryBlockTiny;
class CMemoryBlockSmall;
class CMemoryBlockMedium;
class CMemoryBlockLarge;
class CMemoryBlockHuge;

#include "classfac.h"
#include "message.h"
#include "receive.h"
#include "NameTable.h"
#include "servprov.h"
#include "user.h"
#include "pools.h"
#include "worker.h"
#include "connect.h"
#include "ntoplist.h"
#include "request.h"
#include "common.h"
#include "dpprot.h"
#include "protocol.h"

#ifdef ENABLE_DPLAY_VOICE
#include "voice.h"
#endif

#include "spmessages.h"
#include "AppDesc.h"
#include "enum_sp.h"
#include "Async.h"
#include "AsyncOp.h"
#include "Caps.h"
#include "Connection.h"
#include "GroupCon.h"
#include "MemoryFPM.h"
#include "NTEntry.h"
#include "paramval.h"
#include "GroupMem.h"
#include "Cancel.h"
#include "EnumHosts.h"
#include "HandleTable.h"
#include "handles.h"
#include "DNCore.h"
#include "MessageStructures.h"
#include "jobqueue.h"
#include "locals.h"
#include "iodata.h"
#include "contextcfpm.h"
#include "threadpool.h"
#include "SyncEvent.h"
#include "WorkerJob.h"
#include "NTOp.h"
#include "PendingDel.h"
#include "QueuedMsg.h"

#endif // __DNCOREI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\connect.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Connect.h
 *  Content:    DirectNet connect and disconnect routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/11/00	mjn		Created
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/17/00	mjn		Fixed ConnectToPeer function names
 *	01/18/00	mjn		Moved Pack/UnpackNameTableInfo to NameTable.cpp
 *	01/18/00	mjn		Added DNAutoDestructGroups
 *	01/22/00	mjn		Added DNProcessHostDestroyPlayer
 *	03/24/00	mjn		Set player context through INDICATE_CONNECT notification
 *	04/03/00	mjn		Verify DNET version on connect
 *	04/12/00	mjn		Removed DNAutoDestructGroups - covered in NameTable.DeletePlayer()
 *	04/20/00	mjn		Added DNGetClearAddress
 *	05/23/00	mjn		Added DNConnectToPeerFailed()
 *	06/14/00	mjn		Added DNGetLocalAddress()
 *	06/24/00	mjn		Added DNHostDropPlayer()
 *	07/20/00	mjn		Structure changes and new function parameters
 *				mjn		Moved DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO and DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED to message.h
 *	07/30/00	mjn		Renamed DNGetLocalAddress() to DNGetLocalDeviceAddress()
 *	07/31/00	mjn		Added dwDestroyReason to DNHostDisconnect()
 *	10/11/00	mjn		DNAbortConnect() takes HRESULT parameters instead of PVOID
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__CONNECT_H__
#define	__CONNECT_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct {
	HRESULT	hResultCode;
} DN_RESULT_CONNECT;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

// DirectNet - Connect routines

HRESULT DNHostConnect1(DIRECTNETOBJECT *const pdnObject,
					   const PVOID pvBuffer,
					   const DWORD dwBufferSize,
					   CConnection *const pConnection);

HRESULT DNHostConnect2(DIRECTNETOBJECT *const pdnObject,
					   CConnection *const pConnection);

HRESULT DNHostVerifyConnect(DIRECTNETOBJECT *const pdnObject,
							CConnection *const pConnection,
							const DWORD dwFlags,
							const DWORD dwDNETVersion,
							PWSTR const pwszPassword,
							GUID *const pguidApplication,
							GUID *const pguidInstance,
							PVOID const pvConnectData,
							const DWORD dwConnectDataSize,
							IDirectPlay8Address *const pAddress,
							void **const ppvPlayerContext,
							void **const ppvReplyBuffer,
							DWORD *const pdwReplyBufferSize,
							void **const ppvReplyBufferContext);

HRESULT DNHostDropPlayer(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 void *const pvBuffer);

HRESULT DNPrepareConnectInfo(DIRECTNETOBJECT *const pdnObject,
							 CConnection *const pConnection,
							 CRefCountBuffer **const ppRefCountBuffer);

HRESULT DNConnectToHost1(DIRECTNETOBJECT *const pdnObject,
						 CConnection *const pConnection);

HRESULT DNConnectToHost2(DIRECTNETOBJECT *const pdnObject,
						 const PVOID pvData,
						 CConnection *const pConnection);

HRESULT	DNConnectToHostFailed(DIRECTNETOBJECT *const pdnObject,
							  PVOID const pvErrorBuffer,
							  const DWORD dwErrorBufferSize);

HRESULT DNAbortConnect(DIRECTNETOBJECT *const pdnObject,
					   const HRESULT hrConnect);

HRESULT	DNPlayerConnect1(DIRECTNETOBJECT *const pdnObject,
						 const PVOID pv,
						 CConnection *const pConnection);

HRESULT	DNConnectToPeer1(DIRECTNETOBJECT *const pdnObject,PVOID const pv);
HRESULT DNConnectToPeer2(DIRECTNETOBJECT *const pdnObject,PVOID const pv);

HRESULT	DNConnectToPeer3(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnid,
						 CConnection *const pConnection);

HRESULT DNConnectToPeerFailed(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnid);

HRESULT	DNSendConnectInfo(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry *const pNTEntry,
						  CConnection *const pConnection,
						  void *const pvReplyBuffer,
						  const DWORD dwReplyBufferSize);

HRESULT	DNReceiveConnectInfo(DIRECTNETOBJECT *const pdnObject,
							 void *const pvBuffer,
							 CConnection *const pHostConnection,
							 DPNID *const pdpnid);

HRESULT DNAbortLocalConnect(DIRECTNETOBJECT *const pdnObject);

// DirectNet - Disconnection routines
HRESULT DNLocalDisconnectNew(DIRECTNETOBJECT *const pdnObject);

HRESULT DNPlayerDisconnectNew(DIRECTNETOBJECT *const pdnObject,
							  const DPNID dpnidDisconnecting);

HRESULT DNHostDisconnect(DIRECTNETOBJECT *const pdnObject,
						 const DPNID dpnidDisconnecting,
						 const DWORD dwDestroyReason);

HRESULT DNInstructedDisconnect(DIRECTNETOBJECT *const pdnObject,
							   PVOID pv);

HRESULT DNProcessHostDestroyPlayer(DIRECTNETOBJECT *const pdnObject,void *const pv);

HRESULT DNGetClearAddress(DIRECTNETOBJECT *const pdnObject,
						  const HANDLE hEndPt,
						  IDirectPlay8Address **const ppAddress,
						  const BOOL fPartner);

HRESULT DNGetLocalDeviceAddress(DIRECTNETOBJECT *const pdnObject,
								const HANDLE hEndPt,
								IDirectPlay8Address **const ppAddress);

#endif	// __CONNECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\dncore.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dncore.cpp
 *  Content:    
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *  ====       ==      ======
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

extern DWORD g_dwGlobalObjectCount;
extern DIRECTNETOBJECT *g_DPlayInterfaces[16];
extern DNCRITICAL_SECTION g_csDPlayInterfaces;

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECTNETOBJECT::AddRef"
ULONG DIRECTNETOBJECT::AddRef(void)
{
    ULONG                   ulRefCount;

    DNASSERT(m_ulRefCount);

    ulRefCount = ++m_ulRefCount;

    return ulRefCount;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECTNETOBJECT::Release"
ULONG DIRECTNETOBJECT::Release(void)
{
    ULONG                   ulRefCount;

    DNASSERT(m_ulRefCount);
    
    if(!(ulRefCount = --m_ulRefCount))
    {
        delete this;
    }

    return ulRefCount;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECTNETOBJECT::DIRECTNETOBJECT"
DIRECTNETOBJECT::DIRECTNETOBJECT( DWORD dwDirectPlayType )
{
	DIRECTNETOBJECT *pdnObject = this;

	//
	//	Signature
	//
	pdnObject->Sig[0] = 'D';
	pdnObject->Sig[1] = 'N';
	pdnObject->Sig[2] = 'E';
	pdnObject->Sig[3] = 'T';

	//
	//	Set allocatable elements to NULL to simplify free'ing later on
	//
	pdnObject->dwLockCount = 0;
	pdnObject->hLockEvent = NULL;
	pdnObject->pdnProtocolData = NULL;
#ifndef DPLAY_DOWORK
	pdnObject->hWorkerEvent = NULL;
	pdnObject->hWorkerThread = NULL;
#endif
	pdnObject->pListenParent = NULL;
	pdnObject->pConnectParent = NULL;
	pdnObject->pvConnectData = NULL;
	pdnObject->dwConnectDataSize = 0;
	pdnObject->pIDP8ADevice = NULL;
	pdnObject->pIDP8AEnum = NULL;
	pdnObject->m_pFPOOLAsyncOp = NULL;
	pdnObject->m_pFPOOLConnection = NULL;
	pdnObject->m_pFPOOLGroupConnection = NULL;
	pdnObject->m_pFPOOLGroupMember = NULL;
	pdnObject->m_pFPOOLNameTableEntry = NULL;
	pdnObject->m_pFPOOLNameTableOp = NULL;
	pdnObject->m_pFPOOLPendingDeletion = NULL;
	pdnObject->m_pFPOOLQueuedMsg = NULL;
	pdnObject->m_pFPOOLRefCountBuffer = NULL;
	pdnObject->m_pFPOOLSyncEvent = NULL;
	pdnObject->m_pFPOOLWorkerJob = NULL;
	pdnObject->m_pFPOOLMemoryBlockTiny = NULL;
	pdnObject->m_pFPOOLMemoryBlockSmall = NULL;
	pdnObject->m_pFPOOLMemoryBlockMedium = NULL;
	pdnObject->m_pFPOOLMemoryBlockLarge = NULL;
	pdnObject->m_pFPOOLMemoryBlockHuge = NULL;
	pdnObject->pNewHost = NULL;
	pdnObject->pConnectAddress = NULL;
	pdnObject->nTargets = 0;
	pdnObject->nTargetListLen = 0;
	pdnObject->pTargetList = NULL;
	pdnObject->nExpandedTargets = 0;       
	pdnObject->nExpandedTargetListLen = 0;
	pdnObject->pExpandedTargetList = NULL;
	pdnObject->m_ulRefCount = 1;
	pdnObject->dwFlags = dwDirectPlayType;
	
#ifdef ENABLE_DPLAY_VOICE
	// Voice Additions
    pdnObject->lpDxVoiceNotifyClient = NULL;	
    pdnObject->lpDxVoiceNotifyServer = NULL;
	pdnObject->pTargetList = NULL;
	pdnObject->pExpandedTargetList = NULL;
#endif
}


#undef DPF_MODNAME
#define DPF_MODNAME "DIRECTNETOBJECT::ObjectInit"
HRESULT DIRECTNETOBJECT::ObjectInit( void )
{
	DIRECTNETOBJECT *pdnObject = this;

	// Initialize Critical Section
	if (!DNInitializeCriticalSection(&(pdnObject->csDirectNetObject)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csServiceProviders)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csNameTableOpList)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csAsyncOperations)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		return(E_OUTOFMEMORY);
	}

#ifdef ENABLE_DPLAY_VOICE
	if (!DNInitializeCriticalSection(&(pdnObject->csVoice)))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		return(E_OUTOFMEMORY);
	}
#endif

	if (!DNInitializeCriticalSection(&(pdnObject->csWorkerQueue)))
	{
		DPFERR("DNInitializeCriticalSection(worker queue) failed");
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csActiveList)))
	{
		DPFERR("DNInitializeCriticalSection(csActiveList) failed");
		return(E_OUTOFMEMORY);
	}

	if (!DNInitializeCriticalSection(&(pdnObject->csConnectionList)))
	{
		DPFERR("DNInitializeCriticalSection(csConnectionList) failed");
		return(E_OUTOFMEMORY);
	}

    DN_InitSPCapsList( pdnObject );

	// Initialize Fixed Pool for AsyncOps
	pdnObject->m_pFPOOLAsyncOp = new CLockedContextClassFixedPool< CAsyncOp >;
	DNASSERT(pdnObject->m_pFPOOLAsyncOp != NULL);
	pdnObject->m_pFPOOLAsyncOp->Initialize(	CAsyncOp::FPMAlloc,
											CAsyncOp::FPMInitialize,
											CAsyncOp::FPMRelease,
											CAsyncOp::FPMDealloc );

	// Initialize Fixed Pool for RefCountBuffers
	pdnObject->m_pFPOOLRefCountBuffer = new CLockedContextClassFixedPool< CRefCountBuffer >;
	DNASSERT(pdnObject->m_pFPOOLRefCountBuffer != NULL);
	pdnObject->m_pFPOOLRefCountBuffer->Initialize(	CRefCountBuffer::FPMAlloc,
													CRefCountBuffer::FPMInitialize,
													CRefCountBuffer::FPMRelease,
													CRefCountBuffer::FPMDealloc );

	// Initialize Fixed Pool for SyncEvents
	pdnObject->m_pFPOOLSyncEvent = new CLockedContextClassFixedPool< CSyncEvent >;
	DNASSERT(pdnObject->m_pFPOOLSyncEvent != NULL);
	pdnObject->m_pFPOOLSyncEvent->Initialize(	CSyncEvent::FPMAlloc,
												CSyncEvent::FPMInitialize,
												CSyncEvent::FPMRelease,
												CSyncEvent::FPMDealloc );

	// Initialize Fixed Pool for Connections
	pdnObject->m_pFPOOLConnection = new CLockedContextClassFixedPool< CConnection >;
	DNASSERT(pdnObject->m_pFPOOLConnection != NULL);
	pdnObject->m_pFPOOLConnection->Initialize(	CConnection::FPMAlloc,
												CConnection::FPMInitialize,
												CConnection::FPMRelease,
												CConnection::FPMDealloc );

	// Initialize Fixed Pool for Group Connections
	pdnObject->m_pFPOOLGroupConnection = new CLockedContextClassFixedPool< CGroupConnection >;
	DNASSERT(pdnObject->m_pFPOOLGroupConnection != NULL);
	pdnObject->m_pFPOOLGroupConnection->Initialize(	CGroupConnection::FPMAlloc,
													CGroupConnection::FPMInitialize,
													CGroupConnection::FPMRelease,
													CGroupConnection::FPMDealloc );

	// Initialize Fixed Pool for Group Members
	pdnObject->m_pFPOOLGroupMember = new CLockedContextClassFixedPool< CGroupMember >;
	DNASSERT(pdnObject->m_pFPOOLGroupMember != NULL);
	pdnObject->m_pFPOOLGroupMember->Initialize(	CGroupMember::FPMAlloc,
												CGroupMember::FPMInitialize,
												CGroupMember::FPMRelease,
												CGroupMember::FPMDealloc );

	// Initialize Fixed Pool for NameTable Entries
	pdnObject->m_pFPOOLNameTableEntry = new CLockedContextClassFixedPool< CNameTableEntry >;
	DNASSERT(pdnObject->m_pFPOOLNameTableEntry != NULL);
	pdnObject->m_pFPOOLNameTableEntry->Initialize(	CNameTableEntry::FPMAlloc,
													CNameTableEntry::FPMInitialize,
													CNameTableEntry::FPMRelease,
													CNameTableEntry::FPMDealloc );

	// Initialize Fixed Pool for NameTable Ops
	pdnObject->m_pFPOOLNameTableOp = new CLockedContextClassFixedPool< CNameTableOp >;
	DNASSERT(pdnObject->m_pFPOOLNameTableOp != NULL);
	pdnObject->m_pFPOOLNameTableOp->Initialize(	CNameTableOp::FPMAlloc,
												CNameTableOp::FPMInitialize,
												CNameTableOp::FPMRelease,
												CNameTableOp::FPMDealloc );

	// Initialize Fixed Pool for NameTable Pending Deletions
	pdnObject->m_pFPOOLPendingDeletion = new CLockedContextClassFixedPool< CPendingDeletion >;
	DNASSERT(pdnObject->m_pFPOOLPendingDeletion != NULL);
	pdnObject->m_pFPOOLPendingDeletion->Initialize(	CPendingDeletion::FPMAlloc,
													CPendingDeletion::FPMInitialize,
													CPendingDeletion::FPMRelease,
													CPendingDeletion::FPMDealloc );

	// Initialize Fixed Pool for Queued Messages
	pdnObject->m_pFPOOLQueuedMsg = new CLockedContextClassFixedPool< CQueuedMsg >;
	DNASSERT(pdnObject->m_pFPOOLQueuedMsg != NULL);
	pdnObject->m_pFPOOLQueuedMsg->Initialize(	CQueuedMsg::FPMAlloc,
												CQueuedMsg::FPMInitialize,
												CQueuedMsg::FPMRelease,
												CQueuedMsg::FPMDealloc );

	// Initialize Fixed Pool for Worker Thread Jobs
	pdnObject->m_pFPOOLWorkerJob = new CLockedContextClassFixedPool< CWorkerJob >;
	DNASSERT(pdnObject->m_pFPOOLWorkerJob != NULL);
	pdnObject->m_pFPOOLWorkerJob->Initialize(	CWorkerJob::FPMAlloc,
												CWorkerJob::FPMInitialize,
												CWorkerJob::FPMRelease,
												CWorkerJob::FPMDealloc );

	// Initialize Fixed Pool for memory blocks
	pdnObject->m_pFPOOLMemoryBlockTiny = new CLockedContextClassFixedPool< CMemoryBlockTiny >;
	DNASSERT(pdnObject->m_pFPOOLMemoryBlockTiny != NULL);
	pdnObject->m_pFPOOLMemoryBlockTiny->Initialize(	CMemoryBlockTiny::FPMAlloc,
													CMemoryBlockTiny::FPMInitialize,
													CMemoryBlockTiny::FPMRelease,
													CMemoryBlockTiny::FPMDealloc );

	pdnObject->m_pFPOOLMemoryBlockSmall = new CLockedContextClassFixedPool< CMemoryBlockSmall >;
	DNASSERT(pdnObject->m_pFPOOLMemoryBlockSmall != NULL);
	pdnObject->m_pFPOOLMemoryBlockSmall->Initialize(CMemoryBlockSmall::FPMAlloc,
													CMemoryBlockSmall::FPMInitialize,
													CMemoryBlockSmall::FPMRelease,
													CMemoryBlockSmall::FPMDealloc );

	pdnObject->m_pFPOOLMemoryBlockMedium = new CLockedContextClassFixedPool< CMemoryBlockMedium >;
	DNASSERT(pdnObject->m_pFPOOLMemoryBlockMedium != NULL);
	pdnObject->m_pFPOOLMemoryBlockMedium->Initialize(CMemoryBlockMedium::FPMAlloc,
													CMemoryBlockMedium::FPMInitialize,
													CMemoryBlockMedium::FPMRelease,
													CMemoryBlockMedium::FPMDealloc );

	pdnObject->m_pFPOOLMemoryBlockLarge = new CLockedContextClassFixedPool< CMemoryBlockLarge >;
	DNASSERT(pdnObject->m_pFPOOLMemoryBlockLarge != NULL);
	pdnObject->m_pFPOOLMemoryBlockLarge->Initialize(CMemoryBlockLarge::FPMAlloc,
													CMemoryBlockLarge::FPMInitialize,
													CMemoryBlockLarge::FPMRelease,
													CMemoryBlockLarge::FPMDealloc );

	pdnObject->m_pFPOOLMemoryBlockHuge = new CLockedContextClassFixedPool< CMemoryBlockHuge >;
	DNASSERT(pdnObject->m_pFPOOLMemoryBlockHuge != NULL);
	pdnObject->m_pFPOOLMemoryBlockHuge->Initialize(	CMemoryBlockHuge::FPMAlloc,
													CMemoryBlockHuge::FPMInitialize,
													CMemoryBlockHuge::FPMRelease,
													CMemoryBlockHuge::FPMDealloc );

	//
	//	Create Protocol Object
	//
	if ((pdnObject->pdnProtocolData = reinterpret_cast<PProtocolData>(DNMalloc(sizeof(ProtocolData)))) == NULL)
	{
		DPFERR("DNMalloc() failed");
		return(E_OUTOFMEMORY);
	}
	pdnObject->hProtocolShutdownEvent = NULL;
	pdnObject->lProtocolRefCount = 0;

	// Initialize SP List
	pdnObject->m_bilinkServiceProviders.Initialize();

	//
	//	Initialize AsyncOp List
	//
	pdnObject->m_bilinkAsyncOps.Initialize();

	//
	//	Initialize outstanding CConection list
	//
	pdnObject->m_bilinkConnections.Initialize();

	//
	//	Initialize pending deletion list
	//
	pdnObject->m_bilinkPendingDeletions.Initialize();

	//
	//	Initialize active AsyncOp list
	//
	pdnObject->m_bilinkActiveList.Initialize();

	//
	//	Initialize worker thread job list
	//
	pdnObject->m_bilinkWorkerJobs.Initialize();

	//
	//	Initialize indicated connection list
	//
	pdnObject->m_bilinkIndicated.Initialize();

#ifdef	DEBUG
	// Debug counts
	if (!DNInitializeCriticalSection(&(pdnObject->csDebugCount)))
	{
		DPFERR("DNInitializeCriticalSection(Debug Count) failed");
		return(E_OUTOFMEMORY);
	}
	pdnObject->dwWorkerJobCount = 0;

	pdnObject->bDebugUse = FALSE;
#endif

#ifdef DPLAY_DOWORK
	pdnObject->m_hWorkerCloseEvent = NULL;
#else
	//
	//	Create worker thread event
	//
	if ((pdnObject->hWorkerEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
	{
		DPFERR("Could not create worker thread event");
		return(DPNERR_OUTOFMEMORY);
	}
#endif

	//
	//	Create lock event
	//
	if ((pdnObject->hLockEvent = CreateEvent(NULL,TRUE,FALSE,NULL)) == NULL)
	{
		DPFERR("Unable to create lock event");
		return(DPNERR_OUTOFMEMORY);
	}

	return S_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DIRECTNETOBJECT::~DIRECTNETOBJECT"
DIRECTNETOBJECT::~DIRECTNETOBJECT( void )
{
	DIRECTNETOBJECT *pdnObject = this;

	//
	//	No outstanding listens
	//
	DNASSERT(pdnObject->pListenParent == NULL);

	//
	//	No outstanding connect
	//
	DNASSERT(pdnObject->pConnectParent == NULL);

	//
	//	Host migration target
	//
	DNASSERT(pdnObject->pNewHost == NULL);

	//
	//	Protocol shutdown event
	//
	DNASSERT(pdnObject->hProtocolShutdownEvent == NULL);

	//
	//	Worker close event
	//
	DNASSERT(pdnObject->m_hWorkerCloseEvent == NULL);

	//
	//	Lock event
	//
	CloseHandle(pdnObject->hLockEvent);

#ifndef DPLAY_DOWORK
	// Worker Thread Queue
	if (pdnObject->hWorkerEvent)
		CloseHandle(pdnObject->hWorkerEvent);
#endif
	DNDeleteCriticalSection(&pdnObject->csWorkerQueue);

#ifdef	DEBUG
	// Debug counts
	DPF(2,"Worker Job FPM Outstanding: [%ld]",pdnObject->dwWorkerJobCount);
	DNDeleteCriticalSection(&pdnObject->csDebugCount);
#endif

    DN_FreeSPCapsList( pdnObject );

	// Protocol
	if (pdnObject->pdnProtocolData != NULL)
		DNFree(pdnObject->pdnProtocolData);

	// Active AsyncOp List Critical Section
	DNDeleteCriticalSection(&pdnObject->csActiveList);

	// NameTable operation list Critical Section
	DNDeleteCriticalSection(&pdnObject->csNameTableOpList);

	// Async Ops Critical Section
	DNDeleteCriticalSection(&pdnObject->csAsyncOperations);

	// Connection Critical Section
	DNDeleteCriticalSection(&pdnObject->csConnectionList);

#ifdef ENABLE_DPLAY_VOICE
	// Voice Critical Section
	DNDeleteCriticalSection(&pdnObject->csVoice);
#endif

	//
	// Deinitialize and delete fixed pools
	//
	if (pdnObject->m_pFPOOLAsyncOp)
	{
		pdnObject->m_pFPOOLAsyncOp->Deinitialize();
		delete pdnObject->m_pFPOOLAsyncOp;
		pdnObject->m_pFPOOLAsyncOp = NULL;
	}

	if (pdnObject->m_pFPOOLRefCountBuffer)
	{
		pdnObject->m_pFPOOLRefCountBuffer->Deinitialize();
		delete pdnObject->m_pFPOOLRefCountBuffer;
		pdnObject->m_pFPOOLRefCountBuffer = NULL;
	}

	if (pdnObject->m_pFPOOLSyncEvent)
	{
		pdnObject->m_pFPOOLSyncEvent->Deinitialize();
		delete pdnObject->m_pFPOOLSyncEvent;
		pdnObject->m_pFPOOLSyncEvent = NULL;
	}

	if (pdnObject->m_pFPOOLConnection)
	{
		pdnObject->m_pFPOOLConnection->Deinitialize();
		delete pdnObject->m_pFPOOLConnection;
		pdnObject->m_pFPOOLConnection = NULL;
	}

	if (pdnObject->m_pFPOOLGroupConnection)
	{
		pdnObject->m_pFPOOLGroupConnection->Deinitialize();
		delete pdnObject->m_pFPOOLGroupConnection;
		pdnObject->m_pFPOOLGroupConnection = NULL;
	}

	if (pdnObject->m_pFPOOLGroupMember)
	{
		pdnObject->m_pFPOOLGroupMember->Deinitialize();
		delete pdnObject->m_pFPOOLGroupMember;
		pdnObject->m_pFPOOLGroupMember = NULL;
	}

	if (pdnObject->m_pFPOOLNameTableEntry)
	{
		pdnObject->m_pFPOOLNameTableEntry->Deinitialize();
		delete pdnObject->m_pFPOOLNameTableEntry;
		pdnObject->m_pFPOOLNameTableEntry = NULL;
	}

	if (pdnObject->m_pFPOOLNameTableOp)
	{
		pdnObject->m_pFPOOLNameTableOp->Deinitialize();
		delete pdnObject->m_pFPOOLNameTableOp;
		pdnObject->m_pFPOOLNameTableOp = NULL;
	}

	if (pdnObject->m_pFPOOLPendingDeletion)
	{
		pdnObject->m_pFPOOLPendingDeletion->Deinitialize();
		delete pdnObject->m_pFPOOLPendingDeletion;
		pdnObject->m_pFPOOLPendingDeletion = NULL;
	}

	if (pdnObject->m_pFPOOLQueuedMsg)
	{
		pdnObject->m_pFPOOLQueuedMsg->Deinitialize();
		delete pdnObject->m_pFPOOLQueuedMsg;
		pdnObject->m_pFPOOLQueuedMsg = NULL;
	}

	if (pdnObject->m_pFPOOLWorkerJob)
	{
		pdnObject->m_pFPOOLWorkerJob->Deinitialize();
		delete pdnObject->m_pFPOOLWorkerJob;
		pdnObject->m_pFPOOLWorkerJob = NULL;
	}

	if (pdnObject->m_pFPOOLMemoryBlockTiny)
	{
		pdnObject->m_pFPOOLMemoryBlockTiny->Deinitialize();
		delete pdnObject->m_pFPOOLMemoryBlockTiny;
		pdnObject->m_pFPOOLMemoryBlockTiny = NULL;
	}

	if (pdnObject->m_pFPOOLMemoryBlockSmall)
	{
		pdnObject->m_pFPOOLMemoryBlockSmall->Deinitialize();
		delete pdnObject->m_pFPOOLMemoryBlockSmall;
		pdnObject->m_pFPOOLMemoryBlockSmall = NULL;
	}

	if (pdnObject->m_pFPOOLMemoryBlockMedium)
	{
		pdnObject->m_pFPOOLMemoryBlockMedium->Deinitialize();
		delete pdnObject->m_pFPOOLMemoryBlockMedium;
		pdnObject->m_pFPOOLMemoryBlockMedium = NULL;
	}

	if (pdnObject->m_pFPOOLMemoryBlockLarge)
	{
		pdnObject->m_pFPOOLMemoryBlockLarge->Deinitialize();
		delete pdnObject->m_pFPOOLMemoryBlockLarge;
		pdnObject->m_pFPOOLMemoryBlockLarge = NULL;
	}

	if (pdnObject->m_pFPOOLMemoryBlockHuge)
	{
		pdnObject->m_pFPOOLMemoryBlockHuge->Deinitialize();
		delete pdnObject->m_pFPOOLMemoryBlockHuge;
		pdnObject->m_pFPOOLMemoryBlockHuge = NULL;
	}

	// Delete DirectNet critical section
	DNDeleteCriticalSection(&pdnObject->csDirectNetObject);

	// Enum listen address
	if (pdnObject->pIDP8AEnum != NULL)
	{
		pdnObject->pIDP8AEnum->Release();
		pdnObject->pIDP8AEnum = NULL;
	}

	DNEnterCriticalSection(&g_csDPlayInterfaces);
    for (DWORD i = 0; i < 16; i += 1)
    {
        if (g_DPlayInterfaces[i] == this)
        {
            g_DPlayInterfaces[i] = NULL;
            break;
        }
    }
	DNLeaveCriticalSection(&g_csDPlayInterfaces);

    g_dwGlobalObjectCount -= 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\dncore.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dncore.h
 *  Content:    DIRECT NET CORE HEADER FILE
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	10/08/99	jtk		Moved COM interfaces into separate files
 *	11/09/99	mjn		Moved Worker Thread constants/structures to separate file
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *  12/23/99	mjn		Added host migration structures and functions
 *	12/28/99	mjn		Added DNCompleteOutstandingOperations
 *	12/28/99	mjn		Added NameTable version to Host migration message
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/03/00	mjn		Added DNPrepareToDeletePlayer
 *	01/04/00	mjn		Added code to allow outstanding ops to complete at host migration
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/07/00	mjn		Moved Misc Functions to DNMisc.h
 *	01/08/00	mjn		Added DN_INTERNAL_MESSAGE_CONNECT_FAILED
 *	01/08/00	mjn		Removed unused connection info
 *	01/09/00	mjn		Added Application Description routines
 *						Changed SEND/ACK NAMETABLE to SEND/ACK CONNECT INFO
 *	01/10/00	mjn		Added DNSendUpdateAppDescMessage and DN_UserUpdateAppDesc
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *						Moved Application Description stuff to AppDesc.h
 *						Moved Connect/Disconnect stuff to Connect.h
 *	01/13/00	mjn		Added CFixedPools for CRefCountBuffers
 *	01/14/00	mjn		Removed pvUserContext from DN_NAMETABLE_ENTRY_INFO
 *	01/14/00	mjn		Moved Message stuff to Message.h
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Modified User message handler definition
 *						Moved User call back stuff to User.h
 *	01/17/00	mjn		Added DN_MSG_INTERNAL_VOICE_SEND and DN_MSG_INTERNAL_BUFFER_IN_USE
 *	01/18/00	mjn		Moved NameTable info structures to NameTable.h
 *	01/19/00	mjn		Added structures for NameTable Operation List
 *	01/20/00	mjn		Moved internal messages to Message.h
 *	01/21/00	mjn		Removed DNAcknowledgeHostRequest
 *	01/23/00	mjn		Added DN_MSG_INTERNAL_HOST_DESTROY_PLAYER
 *	01/24/00	mjn		Implemented NameTable operation list clean up
 *	01/25/00	mjn		Changed Host Migration to multi-step affair
 *	01/26/00	mjn		Implemented NameTable re-sync at host migration
 *	01/27/00	mjn		Reordered DN_MSG_INTERNAL's
 *	01/31/00	mjn		Added Internal FPM's for RefCountBuffers
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	03/23/00	mjn		Implemented RegisterLobby()
 *	04/04/00	mjn		Added DN_MSG_INTERNAL_TERMINATE_SESSION
 *	04/09/00	mjn		Added support for CAsyncOp
 *	04/11/00	mjn		Moved DN_INTERNAL_MESSAGE_HEADER from Async.h
 *	04/11/00	mjn		Added DIRECTNETOBJECT bilink for CAsyncOps
 *	04/23/00	mjn		Replaced DN_MSG_INTERNAL_SEND_PROCESSED with DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION
 *				mjn		Replaced DN_MSG_INTERNAL_SEND_PROCESSED_COMPLETE with DN_MSG_INTERNAL_PROCESS_COMPLETION
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	04/28/00	mjn		Code clean up - removed comments and unused consts/structs/funcs
 *	05/23/00	mjn		Added DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED
 *	07/05/00	mjn		Removed references to DN_MSG_INTERNAL_ENUM_WITH_APPLICATION_GUID,DN_MSG_INTERNAL_ENUM,DN_MSG_INTERNAL_ENUM_RESPONSE
 *	07/07/00	mjn		Added pNewHost as host migration target to DirectNetObject
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *	07/12/00	mjn		Moved internal messages back to Message.h
 *	07/17/00	mjn		Add signature to DirectNetObject
 *	07/28/00	mjn		Added m_bilinkConnections to DirectNetObject
 *	07/30/00	mjn		Added CPendingDeletion
 *	07/31/00	mjn		Added CQueuedMsg
 *	08/05/00	mjn		Added m_bilinkActiveList and csActiveList
 *	08/06/00	mjn		Added CWorkerJob
 *	08/09/00	mjn		Added csConnectionList and m_bilinkIndicated
 *	08/11/00	mjn		Added DN_OBJECT_FLAG_HOST_MIGRATING_2 flag (!)
 *	08/23/00	mjn		Added DN_OBJECT_FLAG_DPNSVR_REGISTERED
 *	08/23/00	mjn		Added CNameTableOp
 *	09/04/00	mjn		Added CApplicationDesc
  *  09/13/00	rmt		Bug #44625 - DPVOICE: Multihomed machines are not always enumerable (Added DN_OBJECT_FLAG_LOCALHOST flag).
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__DNCORE_H__
#define	__DNCORE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_VERSION_MAJOR					0x0000
#define	DN_VERSION_MINOR					0x0001
#define	DN_VERSION_CURRENT					((DN_VERSION_MAJOR << 16) | DN_VERSION_MINOR)

#define	DN_OBJECT_FLAG_INITIALIZED			0x80000000
#define	DN_OBJECT_FLAG_LOBBY_AWARE			0x40000000
#define DN_OBJECT_FLAG_LOCALHOST			0x10000000
#define	DN_OBJECT_FLAG_LISTENING			0x04000000
#define	DN_OBJECT_FLAG_ENUMERATING			0x02000000
#define	DN_OBJECT_FLAG_HOST_CONNECTED		0x01000000
#define	DN_OBJECT_FLAG_CONNECTING			0x00800000
#define	DN_OBJECT_FLAG_CONNECTED			0x00400000
#define	DN_OBJECT_FLAG_DISCONNECTING		0x00200000
#define	DN_OBJECT_FLAG_CLOSING				0x00100000
#define DN_OBJECT_FLAG_HOST_MIGRATING_2		0x00020000
#define DN_OBJECT_FLAG_HOST_MIGRATING		0x00010000
#define	DN_OBJECT_FLAG_PEER					0x00000004
#define	DN_OBJECT_FLAG_CLIENT				0x00000002
#define	DN_OBJECT_FLAG_SERVER				0x00000001

#define	DN_ALL_PLAYERS_GROUP_NAME			L"ALL PLAYERS"
#define	DN_ALL_PLAYERS_GROUP_NAME_SIZE		24

#undef DPF_SUBCOMP
#define DPF_SUBCOMP	DN_SUBCOMP_CORE // Used by Debug Logging to determine sub-component

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct IDP8ServiceProvider	IDP8ServiceProvider;				// DPSP8.h
typedef struct IDirectPlayVoiceNotify			*PDIRECTPLAYVOICENOTIFY;

template < class CRefCountBuffer > class CLockedContextClassFixedPool;
template < class CSyncEvent > class CLockedContextClassFixedPool;
template < class CConnection > class CLockedContextClassFixedPool;
template < class CGroupConnection > class CLockedContextClassFixedPool;
template < class CGroupMember > class CLockedContextClassFixedPool;
template < class CNameTableEntry > class CLockedContextClassFixedPool;
template < class CNameTableOp > class CLockedContextClassFixedPool;
template < class CAsyncOp > class CLockedContextClassFixedPool;
template < class CPendingDeletion > class CLockedContextClassFixedPool;
template < class CQueuedMsg > class CLockedContextClassFixedPool;
template < class CWorkerJob > class CLockedContextClassFixedPool;
template < class CMemoryBlockTiny > class CLockedContextClassFixedPool;
template < class CMemoryBlockSmall > class CLockedContextClassFixedPool;
template < class CMemoryBlockMedium > class CLockedContextClassFixedPool;
template < class CMemoryBlockLarge > class CLockedContextClassFixedPool;
template < class CMemoryBlockHuge > class CLockedContextClassFixedPool;

typedef struct protocoldata	*PProtocolData;

#ifdef DPLAY_DOWORK_STATEMN
typedef struct _DPLAY_STMN_ASYNC
{
	STMN_ASYNC stmnAsync;
	DIRECTNETOBJECT *pDplayObject;
} DPLAY_STMN_ASYNC, *PDPLAY_STMN_ASYNC;
#endif

//
// Voice Additions
//
// this is the number of clients of IDirectXVoice in this process
// this is actually a ridiculously large number of client slots.
//
#ifdef ENABLE_DPLAY_VOICE
#define MAX_VOICE_CLIENTS	32	
#endif

class DIRECTNETOBJECT
    : public IDirectPlay8Peer, public IDirectPlay8Client, public IDirectPlay8Server
#ifdef ENABLE_DPLAY_VOICE
    , IDirectPlayVoiceTransport
#endif
{
	STDNEWDELETE

protected:
	ULONG m_ulRefCount;	//object reference count

public:
	DIRECTNETOBJECT(DWORD dwDirectPlayType);
	~DIRECTNETOBJECT(void);
	HRESULT ObjectInit(void);

	// IUnknown interface
	ULONG AddRef(void);
	ULONG Release(void);

	// Client interface
	HRESULT DN_ClientConnect(IDirectPlay8Client *pInterface, const DPN_APPLICATION_DESC *const pdnAppDesc, IDirectPlay8Address *const pHostAddr, IDirectPlay8Address *const pDeviceInfo, const DPN_SECURITY_DESC *const pdnSecurity, const DPN_SECURITY_CREDENTIALS *const pdnCredentials, const void *const pvUserConnectData, const DWORD dwUserConnectDataSize, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
	HRESULT DN_Send( IDirectPlay8Client *pInterface, const DPN_BUFFER_DESC *const prgBufferDesc, const DWORD cBufferDesc, const DWORD dwTimeOut, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
	HRESULT DN_SetClientInfo(IDirectPlay8Client *pInterface, const DPN_PLAYER_INFO *const pdpnPlayerInfo, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
	HRESULT DN_GetServerInfo(IDirectPlay8Client *pInterface, DPN_PLAYER_INFO *const pdpnPlayerInfo, DWORD *const pdwSize, const DWORD dwFlags);
	HRESULT DN_GetHostSendQueueInfo(IDirectPlay8Client *pInterface, DWORD *const lpdwNumMsgs, DWORD *const lpdwNumBytes, const DWORD dwFlags );
	HRESULT DN_GetServerAddress(IDirectPlay8Client *pInterface, IDirectPlay8Address **const ppAddress, const DWORD dwFlags);

	// Peer interface
	HRESULT DN_SetPeerInfo( IDirectPlay8Peer *pInterface, const DPN_PLAYER_INFO *const pdpnPlayerInfo, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
	HRESULT DN_GetPeerInfo(IDirectPlay8Peer *pInterface, const DPNID dpnid, DPN_PLAYER_INFO *const pdpnPlayerInfo, DWORD *const pdwSize, const DWORD dwFlags);
	HRESULT DN_GetPeerAddress(IDirectPlay8Peer *pInterface, const DPNID dpnid, IDirectPlay8Address **const ppAddress, const DWORD dwFlags);

	// Server interface
	HRESULT DN_SetServerInfo(IDirectPlay8Server *pInterface, const DPN_PLAYER_INFO *const pdpnPlayerInfo, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
	HRESULT DN_GetClientInfo(IDirectPlay8Server *pInterface, const DPNID dpnid, DPN_PLAYER_INFO *const pdpnPlayerInfo, DWORD *const pdwSize, const DWORD dwFlags);
	HRESULT DN_GetClientAddress(IDirectPlay8Server *pInterface, const DPNID dpnid, IDirectPlay8Address **const ppAddress, const DWORD dwFlags);

	// Common interface methods
	HRESULT DN_Initialize(PVOID pInterface, PVOID const pvUserContext, const PFNDPNMESSAGEHANDLER pfn, const DWORD dwFlags);
	HRESULT DN_Close(PVOID pInterface, const DWORD dwFlags);
	HRESULT DN_EnumServiceProviders( PVOID pInterface, const GUID *const pguidServiceProvider, const GUID *const pguidApplication, DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer, DWORD *const pcbEnumData, DWORD *const pcReturned, const DWORD dwFlags );
	HRESULT DN_CancelAsyncOperation(PVOID pvInterface, const DPNHANDLE hAsyncOp, const DWORD dwFlags);
	HRESULT DN_Connect( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnAppDesc, IDirectPlay8Address *const pHostAddr, IDirectPlay8Address *const pDeviceInfo, const DPN_SECURITY_DESC *const pdnSecurity, const DPN_SECURITY_CREDENTIALS *const pdnCredentials, const void *const pvUserConnectData, const DWORD dwUserConnectDataSize, void *const pvPlayerContext, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
	HRESULT DN_GetSendQueueInfo(PVOID pInterface, const DPNID dpnid, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes, const DWORD dwFlags);
	HRESULT DN_GetApplicationDesc(PVOID pInterface, DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags);
	HRESULT DN_SetApplicationDesc(PVOID pInterface, const DPN_APPLICATION_DESC *const pdnApplicationDesc, const DWORD dwFlags);
	HRESULT DN_SendTo( PVOID pv, const DPNID dpnid, const DPN_BUFFER_DESC *const prgBufferDesc, const DWORD cBufferDesc, const DWORD dwTimeOut, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
	HRESULT DN_Host( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnAppDesc, IDirectPlay8Address **const prgpDeviceInfo, const DWORD cDeviceInfo, const DPN_SECURITY_DESC *const pdnSecurity, const DPN_SECURITY_CREDENTIALS *const pdnCredentials, void *const pvPlayerContext, const DWORD dwFlags);
	HRESULT DN_CreateGroup(PVOID pInterface, const DPN_GROUP_INFO *const pdpnGroupInfo, void *const pvGroupContext, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
	HRESULT DN_DestroyGroup(PVOID pInterface, const DPNID dpnidGroup, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
	HRESULT DN_AddClientToGroup(PVOID pInterface, const DPNID dpnidGroup, const DPNID dpnidClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
	HRESULT DN_RemoveClientFromGroup(PVOID pInterface, const DPNID dpnidGroup, const DPNID dpnidClient, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
	HRESULT DN_SetGroupInfo( PVOID pv, const DPNID dpnid, DPN_GROUP_INFO *const pdpnGroupInfo, PVOID const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);
	HRESULT DN_GetGroupInfo(PVOID pv, const DPNID dpnid, DPN_GROUP_INFO *const pdpnGroupInfo, DWORD *const pdwSize, const DWORD dwFlags);
	HRESULT DN_EnumClientsAndGroups(LPVOID lpv, DPNID *const lprgdpnid, DWORD *const lpcdpnid, const DWORD dwFlags);
	HRESULT DN_EnumGroupMembers(LPVOID lpv,DPNID dpnid, DPNID *const lprgdpnid, DWORD *const lpcdpnid, const DWORD dwFlags);
	HRESULT DN_EnumHosts( PVOID pv, DPN_APPLICATION_DESC *const pApplicationDesc, IDirectPlay8Address *const pAddrHost, IDirectPlay8Address *const pDeviceInfo, PVOID const pUserEnumData, const DWORD dwUserEnumDataSize, const DWORD dwRetryCount, const DWORD dwRetryInterval, const DWORD dwTimeOut, PVOID const pvUserContext, DPNHANDLE *const pAsyncHandle, const DWORD dwFlags );
	HRESULT DN_DestroyPlayer(PVOID pv, const DPNID dnid, const void *const pvDestroyData, const DWORD dwDestroyDataSize, const DWORD dwFlags);
	HRESULT DN_ReturnBuffer(PVOID pv, const DPNHANDLE hBufferHandle, const DWORD dwFlags);
	HRESULT DN_GetPlayerContext(PVOID pv, const DPNID dpnid, PVOID *const ppvPlayerContext, const DWORD dwFlags);
	HRESULT DN_GetGroupContext(PVOID pv, const DPNID dpnid, PVOID *const ppvGroupContext, const DWORD dwFlags);
	HRESULT DN_RegisterLobby(PVOID pInterface, const DPNHANDLE dpnhLobbyConnection, VOID *const pIDP8LobbiedApplication, const DWORD dwFlags);
	HRESULT DN_TerminateSession(PVOID pInterface, void *const pvTerminateData, const DWORD dwTerminateDataSize, const DWORD dwFlags);
	HRESULT DN_GetHostAddress(PVOID pInterface, IDirectPlay8Address **const prgpAddress, DWORD *const pcAddress, const DWORD dwFlags);
	HRESULT DN_DumpNameTable(PVOID pInterface,char *const Buffer);
	HRESULT DoWork( const DWORD dwFlags );

	// Caps
	HRESULT DN_SetCaps(PVOID pv, const DPN_CAPS *const pdnCaps, const DWORD dwFlags);
	HRESULT DN_GetCaps(PVOID pv, DPN_CAPS *const pdnCaps, const DWORD dwFlags);
	HRESULT DN_GetSPCaps(PVOID pv, const GUID * const pguidSP, DPN_SP_CAPS *const pdnSPCaps, const DWORD dwFlags);
	HRESULT DN_SetSPCaps(PVOID pv, const GUID * const pguidSP, const DPN_SP_CAPS *const pdnSPCaps, const DWORD dwFlags);
	HRESULT DN_GetConnectionInfo(PVOID pv, const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo, const DWORD dwFlags);
	HRESULT DN_GetServerConnectionInfo(PVOID pv, DPN_CONNECTION_INFO *const pdpConnectionInfo, const DWORD dwFlags);
	HRESULT DN_GetConnectionInfoHelper(PVOID pv, const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo, BOOL fServerPlayer, const DWORD dwFlags);

	// Voice methods
#ifdef ENABLE_DPLAY_VOICE
	HRESULT VoiceAdvise( IUnknown *pUnknown, DWORD dwObjectType );
	HRESULT VoiceUnAdvise( DWORD dwObjectType );
	HRESULT VoiceIsGroupMember( DVID dvidGroup, DVID dvidPlayer );
	HRESULT VoiceSendSpeech( DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags );
	HRESULT VoiceSendSpeechAsync( DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags );
	HRESULT VoiceSendSpeechSync( DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, void *pvUserContext, DWORD dwFlags );
	HRESULT VoiceGetSessionInfo( PDVTRANSPORTINFO pdvTransportInfo );
	HRESULT VoiceIsValidEntity( DVID dvidID, PBOOL pfIsValid );
	HRESULT VoiceSendSpeechEx( DVID dvidFrom, DWORD dwNumTargets, PDVID pdvidTargets, PDVTRANSPORT_BUFFERDESC, PVOID pvUserContext, DWORD dwFlags );
	HRESULT VoiceIsValidGroup( DVID dvidID, PBOOL pfIsValid );
	HRESULT VoiceIsValidPlayer( DVID dvidID, PBOOL pfIsValid );
#endif

	// Typecast
	static DIRECTNETOBJECT *STDMETHODCALLTYPE GetDirectPlay8Peer(IDirectPlay8Peer *pBuffer);
	static DIRECTNETOBJECT *STDMETHODCALLTYPE GetDirectPlay8Client(IDirectPlay8Client *pBuffer);
	static DIRECTNETOBJECT *STDMETHODCALLTYPE GetDirectPlay8Server(IDirectPlay8Server *pBuffer);
#ifdef ENABLE_DPLAY_VOICE
	static DIRECTNETOBJECT *STDMETHODCALLTYPE GetDirectPlayVoiceTransport(IDirectPlayVoiceTransport *pBuffer);
#endif

#ifdef DPLAY_DOWORK
	DWORD DNWorkerThreadProc(void);
#ifdef DPLAY_DOWORK_STATEMN
	DPLAY_STMN_ASYNC m_stmnAsync;
#endif
#endif

	BYTE					Sig[4];					// Signature
	DWORD					dwFlags;
	DNCRITICAL_SECTION		csDirectNetObject;		// access control critical section
	PVOID					pvUserContext;
	PFNDPNMESSAGEHANDLER	pfnDnUserMessageHandler;
	DWORD					dwLockCount;			// Count to prevent closing
	HANDLE					hLockEvent;				// Set when dwLockCount=0

	CNameTableEntry			*pNewHost;				// Host migration target

	CApplicationDesc		ApplicationDesc;

	CNameTable				NameTable;

	CHandleTable			HandleTable;

	DNCRITICAL_SECTION		csAsyncOperations;		// CS to protect outstanding async CBilink
	CBilink					m_bilinkAsyncOps;		// Outstanding CAsyncOps	(use csAsyncOperations)
	CBilink					m_bilinkConnections;	// Outstanding CConnections

	DNCRITICAL_SECTION		csActiveList;			// CS to protect active list of AsyncOps
	CBilink					m_bilinkActiveList;		// Active CAsyncOps (w/ protocol handles)

	DNCRITICAL_SECTION		csConnectionList;		// CS to guard the connection list
	CBilink					m_bilinkIndicated;		// Indicated connections

	DNCRITICAL_SECTION		csNameTableOpList;		// CS to protect NameTable operation list
	CBilink					m_bilinkPendingDeletions;// CBilink of NameTable pending deletions

	CAsyncOp				*pListenParent;			// LISTEN async op

	CAsyncOp				*pConnectParent;		// CONNECT async op
	PVOID					pvConnectData;			// Connect data
	DWORD					dwConnectDataSize;

	PProtocolData			pdnProtocolData;
	LONG					lProtocolRefCount;		// Protocol usage
	CSyncEvent				*hProtocolShutdownEvent;// No outstanding protocol operations

	CSyncEvent				*m_hWorkerCloseEvent;// No outstanding worker operations

	DNCRITICAL_SECTION		csServiceProviders;
	CBilink					m_bilinkServiceProviders;
    CBilink                  blSPCapsList;           // Cached SP settings structures -- used to cache SPCAPS settings

	IDirectPlay8Address		*pIDP8ADevice;			// SP Local Device
	IDirectPlay8Address		*pIDP8AEnum;			// Address to listen on for enums after host migration


	DNCRITICAL_SECTION		csWorkerQueue;			// CS to protect worker thread job queue
	CBilink					m_bilinkWorkerJobs;
#ifndef DPLAY_DOWORK
	HANDLE					hWorkerEvent;			// Handle of event to trigger worker thread
	HANDLE					hWorkerThread;			// Worker thread handle
#endif

	CLockedContextClassFixedPool< CRefCountBuffer >		*m_pFPOOLRefCountBuffer;

	CLockedContextClassFixedPool< CSyncEvent >			*m_pFPOOLSyncEvent;

	CLockedContextClassFixedPool< CConnection >			*m_pFPOOLConnection;

	CLockedContextClassFixedPool< CGroupConnection>		*m_pFPOOLGroupConnection;

	CLockedContextClassFixedPool< CGroupMember >		*m_pFPOOLGroupMember;

	CLockedContextClassFixedPool< CNameTableEntry >		*m_pFPOOLNameTableEntry;

	CLockedContextClassFixedPool< CNameTableOp >		*m_pFPOOLNameTableOp;

	CLockedContextClassFixedPool< CAsyncOp >			*m_pFPOOLAsyncOp;

	CLockedContextClassFixedPool< CPendingDeletion >	*m_pFPOOLPendingDeletion;

	CLockedContextClassFixedPool< CQueuedMsg >			*m_pFPOOLQueuedMsg;

	CLockedContextClassFixedPool< CWorkerJob >			*m_pFPOOLWorkerJob;

	CLockedContextClassFixedPool< CMemoryBlockTiny>		*m_pFPOOLMemoryBlockTiny;
	CLockedContextClassFixedPool< CMemoryBlockSmall>	*m_pFPOOLMemoryBlockSmall;
	CLockedContextClassFixedPool< CMemoryBlockMedium>	*m_pFPOOLMemoryBlockMedium;
	CLockedContextClassFixedPool< CMemoryBlockLarge>	*m_pFPOOLMemoryBlockLarge;
	CLockedContextClassFixedPool< CMemoryBlockHuge>		*m_pFPOOLMemoryBlockHuge;

#ifdef ENABLE_DPLAY_VOICE
	// Voice Additions
	PDIRECTPLAYVOICENOTIFY	lpDxVoiceNotifyServer;
	PDIRECTPLAYVOICENOTIFY  lpDxVoiceNotifyClient;
	DNCRITICAL_SECTION		csVoice;
#endif

	// Send Target Cache for voice targets on DV_SendSpeechEx
	DWORD					nTargets;			     // number of used entries in the target list
	DWORD					nTargetListLen;          // max number of target list entries list can hold
	PDPNID					pTargetList;	  	   // ptr to target list array
	DWORD					nExpandedTargets;        // simplified list of targets, removes dup's
	DWORD					nExpandedTargetListLen;  // max number of target list entries list can hold
	PDPNID					pExpandedTargetList;	// ptr to array of simplified list of targets

	// Lobby additions
	IDirectPlay8Address		*pConnectAddress;		// Connect Address (cached) for clients
	
	
#ifdef	DEBUG
	DNCRITICAL_SECTION		csDebugCount;			// DEBUG - CS to protect debug counts
	DWORD					dwWorkerJobCount;		// DEBUG - Count of worker jobs
	BOOL					bDebugUse;				// DEBUG - BOOLEAN
#endif
};

__inline DIRECTNETOBJECT *DIRECTNETOBJECT::GetDirectPlay8Peer(IDirectPlay8Peer *pBuffer)
{
    return (DIRECTNETOBJECT *)pBuffer;
}

__inline DIRECTNETOBJECT *DIRECTNETOBJECT::GetDirectPlay8Client(IDirectPlay8Client *pBuffer)
{
    return (DIRECTNETOBJECT *)((void*)pBuffer);
}

__inline DIRECTNETOBJECT *DIRECTNETOBJECT::GetDirectPlay8Server(IDirectPlay8Server *pBuffer)
{
    return (DIRECTNETOBJECT *)((void*)pBuffer);
}

#ifdef ENABLE_DPLAY_VOICE
__inline DIRECTNETOBJECT *DIRECTNETOBJECT::GetDirectPlayVoiceTransport(IDirectPlayVoiceTransport *pBuffer)
{
    return (DIRECTNETOBJECT *)((PVOID)pBuffer);
}
#endif


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//	DirectNet Core Message Handler
HRESULT	DN_CoreMessageHandler(PVOID const pv,
							  const DWORD dwMsgId,
							  const HANDLE hEndPt,
							  PBYTE const pData,
							  const DWORD dwDataSize,
							  PVOID const pvUserContext,
							  const HANDLE hProtocol,
							  const HRESULT hr);

//	Protocol Ref Counts
void DNProtocolAddRef(DIRECTNETOBJECT *const pdnObject);
void DNProtocolRelease(DIRECTNETOBJECT *const pdnObject);

// DirectNet - Host Migration routines
HRESULT	DNFindNewHost(DIRECTNETOBJECT *const pdnObject,
					  DPNID *const pdpnidNewHost);

HRESULT	DNPerformHostMigration1(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnidOldHost);

HRESULT	DNPerformHostMigration2(DIRECTNETOBJECT *const pdnObject);
HRESULT	DNPerformHostMigration3(DIRECTNETOBJECT *const pdnObject,void *const pMsg);
HRESULT	DNProcessHostMigration1(DIRECTNETOBJECT *const pdnObject,void *const pvMsg);
HRESULT	DNProcessHostMigration2(DIRECTNETOBJECT *const pdnObject,void *const pMsg);
HRESULT	DNProcessHostMigration3(DIRECTNETOBJECT *const pdnObject);
HRESULT DNCompleteOutstandingOperations(DIRECTNETOBJECT *const pdnObject);
HRESULT DNCheckReceivedAllVersions(DIRECTNETOBJECT *const pdnObject);
HRESULT DNCleanUpNameTable(DIRECTNETOBJECT *const pdnObject);

HRESULT	DNSendHostMigrateCompleteMessage(DIRECTNETOBJECT *const pdnObject);

/*********************/

HRESULT DNPIIndicateListenTerminated(void *const pvUserContext,
									 void *const pvEndPtContext,
									 const HRESULT hr);

HRESULT DNPIIndicateEnumQuery(void *const pvUserContext,
							  void *const pvEndPtContext,
							  const HANDLE hCommand,
							  void *const pvEnumQueryData,
							  const DWORD dwEnumQueryDataSize);

HRESULT DNPIIndicateEnumResponse(void *const pvUserContext,
								 const HANDLE hCommand,
								 void *const pvCommandContext,
								 void *const pvEnumResponseData,
								 const DWORD dwEnumResponseDataSize);

HRESULT DNPIIndicateConnect(void *const pvUserContext,
							void *const pvListenContext,
							const HANDLE hEndPt,
							void **const ppvEndPtContext);

HRESULT DNPIIndicateDisconnect(void *const pvUserContext,
							   void *const pvEndPtContext);

HRESULT DNPIIndicateConnectionTerminated(void *const pvUserContext,
										 void *const pvEndPtContext,
										 const HRESULT hr);

HRESULT DNPIIndicateReceive(void *const pvUserContext,
							void *const pvEndPtContext,
							void *const pvData,
							const DWORD dwDataSize,
							const HANDLE hBuffer,
							const DWORD dwFlags);

HRESULT DNPICompleteListen(void *const pvUserContext,
						   void **const ppvCommandContext,
						   const HRESULT hr,
						   const HANDLE hEndPt);

HRESULT DNPICompleteListenTerminate(void *const pvUserContext,
									void *const pvCommandContext,
									const HRESULT hr);

HRESULT DNPICompleteEnumQuery(void *const pvUserContext,
							  void *const pvCommandContext,
							  const HRESULT hr);

HRESULT DNPICompleteEnumResponse(void *const pvUserContext,
								 void *const pvCommandContext,
								 const HRESULT hr);

HRESULT DNPICompleteConnect(void *const pvUserContext,
							void *const pvCommandContext,
							const HRESULT hr,
							const HANDLE hEndPt,
							void **const ppvEndPtContext);

HRESULT DNPICompleteDisconnect(void *const pvUserContext,
							   void *const pvCommandContext,
							   const HRESULT hr);

HRESULT DNPICompleteSend(void *const pvUserContext,
						 void *const pvCommandContext,
						 const HRESULT hr);

HRESULT DNPIAddressInfoConnect(void *const pvUserContext,
							   void *const pvCommandContext,
							   const HRESULT hr,
							   IDirectPlay8Address *const pHostAddress,
							   IDirectPlay8Address *const pDeviceAddress );

HRESULT DNPIAddressInfoEnum(void *const pvUserContext,
							void *const pvCommandContext,
							const HRESULT hr,
							IDirectPlay8Address *const pHostAddress,
							IDirectPlay8Address *const pDeviceAddress );

HRESULT DNPIAddressInfoListen(void *const pvUserContext,
							  void *const pvCommandContext,
							  const HRESULT hr,
							  IDirectPlay8Address *const pDeviceAddress );


/*********************/

//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __DNCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\enumhosts.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Enum.cpp
 *  Content:    Enumeration routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/10/00	mjn		Created
 *	04/17/00	mjn		Fixed DNCompleteEnumQuery to clean up properly
 *	04/18/00	mjn		Return User Buffer in DNProcessEnumQuery
 *	04/19/00	mjn		Removed DPN_BUFFER_DESC from DPNMSG_ENUM_HOSTS_QUERY and DPNMSG_ENUM_HOSTS_RESPONSE structs
 *	05/02/00	mjn		Allow application to reject ENUM_QUERY's
 *	06/25/00	mjn		Fixed payload problem in DNProcessEnumQuery()
 *	07/10/00	mjn		Removed DNCompleteEnumQuery() and DNCompleteEnumResponse()
 *	07/12/00	mjn		Ensure connected before replying to ENUMs
 *	07/29/00	mjn		Verify enum responses sizes
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Ensure cancelled operations don't proceed
 *	08/29/00	mjn		Cancel EnumHosts if non-DPN_OK returned from response notification
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/14/00	mjn		AddRef Protocol refcount when invoking protocol
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"



//**********************************************************************
// ------------------------------
// DNProcessEnumQuery - process enum query
//
// Entry:		Pointer to this DNet interface object
//				Pointer to the associated listen operation
//				Pointer to protocol's enum data
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessEnumQuery"

void DNProcessEnumQuery(DIRECTNETOBJECT *const pdnObject,
						CAsyncOp *const pListen,
						const PROTOCOL_ENUM_DATA *const pEnumQueryData )
{
	HRESULT						hResultCode;
	DPNMSG_ENUM_HOSTS_QUERY		AppData;
	CPackedBuffer				PackedBuffer;
	CRefCountBuffer				*pRefCountBuffer;
	CAsyncOp					*pAsyncOp;
	HANDLE						hProtocol;
	const DN_ENUM_QUERY_PAYLOAD	*pEnumQueryPayload;
	PVOID						pvBlock;
	DN_ENUM_RESPONSE			*pEnumResponse;
	DN_ENUM_RESPONSE_PAYLOAD	*pEnumResponsePayload;
	DWORD						dwPayloadOffset;
    IDP8ServiceProvider			*pIDP8SP;
    SPGETCAPSDATA				spGetCapsData;

	DPF(6,"Parameters: pListen [0x%p], pEnumQueryData [0x%p]",pListen,pEnumQueryData);

	DNASSERT( pdnObject != NULL );
	DNASSERT( pListen != NULL );
	DNASSERT( pEnumQueryData != NULL );

	pAsyncOp = NULL;
	pRefCountBuffer = NULL;
	pvBlock = NULL;
	pIDP8SP = NULL;

	//
	//	Ensure we are in a position to reply to this message.
	//	We must be CONNECTED and not be HOST_MIGRATING
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (!(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) || (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	// Check to see if this message is for this game type.  Since the application
	// GUID cannot be changed while the session is running, there's no need to
	// enter a critical section.
	//
	pEnumQueryPayload = reinterpret_cast<DN_ENUM_QUERY_PAYLOAD*>( pEnumQueryData->ReceivedData.pBufferData );
	if ( pEnumQueryPayload == NULL )
	{
		//
		// no enum payload (there needs to be at least one byte!)
		//
		goto Failure;
	}

	dwPayloadOffset = 0;
	switch ( pEnumQueryPayload->QueryType )
	{
		//
		// an application guid was specified, make sure it matches this application's
		// guid before further processing
		//
		case DN_ENUM_QUERY_WITH_APPLICATION_GUID:
		{
			if ( pEnumQueryData->ReceivedData.dwBufferSize < sizeof( DN_ENUM_QUERY_PAYLOAD ) )
			{
				DNASSERT( FALSE );
				goto Failure;
			}

			if ( !pdnObject->ApplicationDesc.IsEqualApplicationGuid( &pEnumQueryPayload->guidApplication ) )
			{
				goto Failure;
			}

			dwPayloadOffset = sizeof( DN_ENUM_QUERY_PAYLOAD );

			break;
		}

		//
		// no application guid was specified, continue processing
		//
		case DN_ENUM_QUERY_WITHOUT_APPLICATION_GUID:
		{
			if ( pEnumQueryData->ReceivedData.dwBufferSize < ( sizeof( DN_ENUM_QUERY_PAYLOAD ) - sizeof( GUID ) ) )
			{
				DNASSERT( FALSE );
				goto Failure;
			}

			dwPayloadOffset = sizeof( DN_ENUM_QUERY_PAYLOAD ) - sizeof( GUID );

			break;
		}

		default:
		{
			DNASSERT( FALSE );
			goto Failure;
			break;
		}
	}


	//
	// buld message structure, be nice and clear the user payload pointer if
	// there is no payload
	//
	AppData.dwSize = sizeof( AppData );
	AppData.pAddressSender = pEnumQueryData->pSenderAddress;
	AppData.pAddressDevice = pEnumQueryData->pDeviceAddress;

	if (pEnumQueryData->ReceivedData.dwBufferSize > dwPayloadOffset)
	{
		DNASSERT( pEnumQueryData->ReceivedData.pBufferData );
		DNASSERT( pEnumQueryData->ReceivedData.dwBufferSize );

		AppData.pvReceivedData = static_cast<void*>(static_cast<BYTE*>(pEnumQueryData->ReceivedData.pBufferData) + dwPayloadOffset);
		AppData.dwReceivedDataSize = pEnumQueryData->ReceivedData.dwBufferSize - dwPayloadOffset;
	}
	else
	{
		AppData.pvReceivedData = NULL;
		AppData.dwReceivedDataSize = 0;
	}

	//
	//	Response Info
	//
	AppData.pvResponseData = NULL;
	AppData.dwResponseDataSize = 0;
	AppData.pvResponseContext = NULL;

	//
	//	Determine max size of response
	//		-	Get SP interface from listen SP (listen's parent)
	//		-	Get SP caps on the interface to determine the total available buffer size
	//		-	Figure out what the DNET enum response size will be
	//		-	Determine space available to user
	//
	DNASSERT(pListen->GetParent() != NULL);
	if ((hResultCode = pListen->GetParent()->GetSP()->GetInterfaceRef( &pIDP8SP )) != DPN_OK)
	{
		DPFERR("Could not get ListenSP SP interface");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
    memset( &spGetCapsData, 0x00, sizeof( SPGETCAPSDATA ) );
    spGetCapsData.dwSize = sizeof( SPGETCAPSDATA );
	spGetCapsData.hEndpoint = INVALID_HANDLE_VALUE;
    if ((hResultCode = pIDP8SP->lpVtbl->GetCaps( pIDP8SP, &spGetCapsData )) != DPN_OK)
	{
		DPFERR("Could not get SP caps");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pIDP8SP->lpVtbl->Release( pIDP8SP );
	pIDP8SP = NULL;
	PackedBuffer.Initialize(NULL,0);
	PackedBuffer.AddToFront(NULL,sizeof(DN_ENUM_RESPONSE_PAYLOAD));
	pdnObject->ApplicationDesc.PackInfo(&PackedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	AppData.dwMaxResponseDataSize = spGetCapsData.dwEnumFrameSize - PackedBuffer.GetSizeRequired();

	//
	// pass message to the user
	//
	hResultCode = DNUserEnumQuery(pdnObject,&AppData);

	//
	//	Only ENUMs which are accepted get responded to
	//
	if (hResultCode != DPN_OK)
	{
		DPF(9,"EnumQuery rejected");
		DisplayDNError(0,hResultCode);
		goto Exit;
	}

	//
	// get an async operation to track the progress of the response
	//
	if ((hResultCode = AsyncOpNew(pdnObject,&pAsyncOp)) != DPN_OK)
	{
		DPFERR("Could not allocate Async Op struct for enum response");
		DisplayDNError( 0, hResultCode );
		DNASSERT( FALSE );
		goto Failure;
	}
	pAsyncOp->SetOpType( ASYNC_OP_ENUM_RESPONSE );

	//
	// compute the size needed to pack up an application description with any
	// user data and send it back
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);

	PackedBuffer.Initialize(NULL,0);
	PackedBuffer.AddToFront(NULL,sizeof(DN_ENUM_RESPONSE_PAYLOAD));
	if ((AppData.pvResponseData != NULL) && (AppData.dwResponseDataSize != 0))
	{
		PackedBuffer.AddToBack(NULL,AppData.dwResponseDataSize);
	}
	hResultCode = pdnObject->ApplicationDesc.PackInfo(&PackedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|
			DN_APPDESCINFO_FLAG_RESERVEDDATA|DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	DNASSERT( hResultCode == DPNERR_BUFFERTOOSMALL );

	//
	//	Ensure this enum response will fit in SP enum frame - only indicate this if there was a response
	//
	if ((PackedBuffer.GetSizeRequired() > spGetCapsData.dwEnumFrameSize)
			&& ((AppData.pvResponseData != NULL) && (AppData.dwResponseDataSize != 0)))
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPFERR("Enum response is too large");
		DNUserReturnBuffer(pdnObject,DPNERR_ENUMRESPONSETOOLARGE,AppData.pvResponseData,AppData.pvResponseContext);
		goto Failure;
	}

	hResultCode = RefCountBufferNew(pdnObject,
								PackedBuffer.GetSizeRequired(),
								&pRefCountBuffer);
	if ( hResultCode != DPN_OK )
	{
		DNASSERT( FALSE );
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		goto Failure;
	}
	PackedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),
							pRefCountBuffer->GetBufferSize());
	pEnumResponsePayload = static_cast<DN_ENUM_RESPONSE_PAYLOAD*>(PackedBuffer.GetHeadAddress());
	hResultCode = PackedBuffer.AddToFront(NULL,sizeof(DN_ENUM_RESPONSE_PAYLOAD));
	if (hResultCode != DPN_OK)
	{
		DNASSERT(FALSE);
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		goto Failure;
	}
	if ((AppData.pvResponseData != NULL) && (AppData.dwResponseDataSize != 0))
	{
		hResultCode = PackedBuffer.AddToBack(AppData.pvResponseData,AppData.dwResponseDataSize);
		if (hResultCode != DPN_OK)
		{
			DNASSERT(FALSE);
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			goto Failure;
		}
		pEnumResponsePayload->dwResponseOffset = PackedBuffer.GetTailOffset();
		pEnumResponsePayload->dwResponseSize = AppData.dwResponseDataSize;
	}
	else
	{
		pEnumResponsePayload->dwResponseOffset = 0;
		pEnumResponsePayload->dwResponseSize = 0;
	}
	pdnObject->ApplicationDesc.PackInfo(&PackedBuffer,DN_APPDESCINFO_FLAG_SESSIONNAME|DN_APPDESCINFO_FLAG_RESERVEDDATA|
			DN_APPDESCINFO_FLAG_APPRESERVEDDATA);
	if ( hResultCode != DPN_OK )
	{
		DNASSERT( FALSE );
		goto Failure;
	}

	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Return user buffer (if one was supplied) since we don't need it any more now that we've copied it
	//
	if ((AppData.pvResponseData != NULL) && (AppData.dwResponseDataSize != 0))
	{
		DNUserReturnBuffer(pdnObject,DPN_OK,AppData.pvResponseData,AppData.pvResponseContext);
	}

	//
	// build enum response and send it down to the protocol
	//
	if ((pvBlock = MemoryBlockAlloc(pdnObject,sizeof(DN_ENUM_RESPONSE))) == NULL)
	{
		DPFERR("Could not allocate Response block");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	pEnumResponse = static_cast<DN_ENUM_RESPONSE*>(pvBlock);

	pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_DN_PAYLOAD].pBufferData = pRefCountBuffer->GetBufferAddress();
	pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_DN_PAYLOAD].dwBufferSize = pRefCountBuffer->GetBufferSize();

	pAsyncOp->SetRefCountBuffer( pRefCountBuffer );
	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	pAsyncOp->SetCompletion( DNCompleteEnumResponse );
	pAsyncOp->SetOpData(pvBlock);
	pvBlock = NULL;		// This will get cleaned up by completion

	pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].pBufferData = NULL;
	pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD].dwBufferSize = 0;
	pEnumResponse->pvUserContext = NULL;

	DNASSERT(pListen->GetParent() != NULL);
	DNASSERT(pListen->GetParent()->GetSP() != NULL);
	DNASSERT(pListen->GetParent()->GetSP()->GetHandle() != NULL);

	//
	//	AddRef Protocol so that it won't go away until this completes
	//
	DNProtocolAddRef(pdnObject);

	pAsyncOp->AddRef();
	hResultCode = DNPEnumRespond(	pdnObject->pdnProtocolData,
									pListen->GetParent()->GetSP()->GetHandle(),
									pEnumQueryData->hEnumQuery,
									&pEnumResponse->BufferDesc[DN_ENUM_BUFFERDESC_RESPONSE_DN_PAYLOAD],
									DN_ENUM_BUFFERDESC_RESPONSE_COUNT,
									0,
									reinterpret_cast<void*>(pAsyncOp),
									&hProtocol);
	if ( hResultCode != DPNERR_PENDING )
	{
		pAsyncOp->Release();
		DNProtocolRelease(pdnObject);
		goto Failure;
	}

	//
	//	Save Protocol Handle
	//
	pAsyncOp->Lock();
	if (pAsyncOp->IsCancelled())
	{
		HRESULT		hrCancel;

		pAsyncOp->Unlock();
		DPF(7,"Operation marked for cancel");
		if ((hrCancel = DNPCancelCommand(pdnObject->pdnProtocolData,hProtocol)) == DPN_OK)
		{
			hResultCode = DPNERR_USERCANCEL;
			goto Failure;
		}
		DPFERR("Could not cancel operation");
		DisplayDNError(0,hrCancel);
		pAsyncOp->Lock();
	}
	pAsyncOp->SetProtocolHandle(hProtocol);
	pAsyncOp->Unlock();

	pAsyncOp->Release();
	pAsyncOp = NULL;


Exit:
	DPF(6,"Returning");
	return;

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pvBlock)
	{
		MemoryBlockFree(pdnObject,pvBlock);
		pvBlock = NULL;
	}
	if (pIDP8SP)
	{
		pIDP8SP->lpVtbl->Release(pIDP8SP);
		pIDP8SP = NULL;
	}
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNProcessEnumResponse - process response to enum query
//
// Entry:		Pointer to this DNet interface object
//				Pointer to the associated enum operation
//				Pointer to protocol's enum response data
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessEnumResponse"

void DNProcessEnumResponse(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp,
						   const PROTOCOL_ENUM_RESPONSE_DATA *const pEnumResponseData )
{
	HRESULT						hResultCode;
	DPNMSG_ENUM_HOSTS_RESPONSE	AppData;
	BYTE						*pWorkingItem;
	DN_ENUM_RESPONSE_PAYLOAD	*pEnumResponsePayload;
	DPN_APPLICATION_DESC		dpnAppDesc;
	DPN_APPLICATION_DESC_INFO	*pInfo;


	DNASSERT( pdnObject != NULL );
	DNASSERT( pAsyncOp != NULL );
	DNASSERT( pEnumResponseData != NULL );

	pWorkingItem = pEnumResponseData->ReceivedData.pBufferData;

	//
	//	Unpack the ENUM response.
	//	It will be in the following format:
	//	<UserResponseOffset>
	//	<UserResponseSize>
	//	<AppDescInfo>
	//

	pEnumResponsePayload = reinterpret_cast<DN_ENUM_RESPONSE_PAYLOAD*>(pEnumResponseData->ReceivedData.pBufferData);

	//
	// Application Description
	//
	pInfo = reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(pEnumResponsePayload + 1);
	memset(&dpnAppDesc,0,sizeof(DPN_APPLICATION_DESC));
	if (pInfo->dwSessionNameOffset)
	{
		dpnAppDesc.pwszSessionName = reinterpret_cast<WCHAR*>(pWorkingItem + pInfo->dwSessionNameOffset);
	}
	if (pInfo->dwReservedDataOffset)
	{
		dpnAppDesc.pvReservedData = static_cast<void*>(pWorkingItem + pInfo->dwReservedDataOffset);
		dpnAppDesc.dwReservedDataSize = pInfo->dwReservedDataSize;
	}
	if (pInfo->dwApplicationReservedDataOffset)
	{
		dpnAppDesc.pvApplicationReservedData = static_cast<void*>(pWorkingItem + pInfo->dwApplicationReservedDataOffset);
		dpnAppDesc.dwApplicationReservedDataSize = pInfo->dwApplicationReservedDataSize;
	}
	dpnAppDesc.guidApplication = pInfo->guidApplication;
	dpnAppDesc.guidInstance = pInfo->guidInstance;
	dpnAppDesc.dwFlags = pInfo->dwFlags;
	dpnAppDesc.dwCurrentPlayers = pInfo->dwCurrentPlayers;
	dpnAppDesc.dwMaxPlayers = pInfo->dwMaxPlayers;
	dpnAppDesc.dwSize = sizeof(DPN_APPLICATION_DESC);

	//
	//	Fill in AppData
	//
	AppData.dwSize = sizeof( AppData );
	AppData.pAddressSender = pEnumResponseData->pSenderAddress;
	AppData.pAddressDevice = pEnumResponseData->pDeviceAddress;
	AppData.pApplicationDescription = &dpnAppDesc;
	AppData.dwRoundTripLatencyMS = pEnumResponseData->dwRoundTripTime;

	if (pEnumResponsePayload->dwResponseOffset)
	{
		AppData.pvResponseData = (pEnumResponseData->ReceivedData.pBufferData + pEnumResponsePayload->dwResponseOffset);
		AppData.dwResponseDataSize = pEnumResponsePayload->dwResponseSize;
	}
	else
	{
		AppData.pvResponseData = NULL;
		AppData.dwResponseDataSize = 0;
	}
	AppData.pvUserContext = pAsyncOp->GetContext();

	//
	// pass message to the user
	//
	hResultCode = DNUserEnumResponse(pdnObject,&AppData);

	//
	//	Check to see if this is to be cancelled
	//
	if (hResultCode != DPN_OK)
	{
		CAsyncOp	*pCancelOp = NULL;

		//
		//	Get top level operation (may be async op handle)
		//
		pAsyncOp->Lock();
		pCancelOp = pAsyncOp;
		while (pCancelOp->IsChild())
		{
			DNASSERT(pCancelOp->GetParent() != NULL);
			pCancelOp = pCancelOp->GetParent();
		}
		pCancelOp->AddRef();
		pAsyncOp->Unlock();

		//
		//	Cancel
		//
		DNCancelChildren(pdnObject,pCancelOp);
		pCancelOp->Release();
		pCancelOp = NULL;
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\dpprot.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		DPlay8.h
 *  Content:	DirectPlay8 include file
 *  History:
 *	Date		By		Reason
 *	==========================
 *	9/26/2000	maosnb		created - Removed from public header dplay8.h
 *
 ***************************************************************************/

#ifndef __DIRECTPLAY8PROT_H__
#define __DIRECTPLAY8PROT_H__

#ifdef __cplusplus
extern "C" {
#endif


/****************************************************************************
 *
 * DirectPlay8 CLSIDs
 *
 ****************************************************************************/

//// {EBFE7B84-628D-11D2-AE0F-006097B01411}
DEFINE_GUID(IID_IDirectPlay8Protocol,
0xebfe7b84, 0x628d, 0x11d2, 0xae, 0xf, 0x0, 0x60, 0x97, 0xb0, 0x14, 0x11);


/****************************************************************************
 *
 * DirectPlay8 Interface Definitions
 *
 ****************************************************************************/

typedef struct _DN_PROTOCOL_INTERFACE_VTBL DN_PROTOCOL_INTERFACE_VTBL, *PDN_PROTOCOL_INTERFACE_VTBL;

//
// COM definition for DirectPlay8 Protocol interface
//
#undef INTERFACE				// External COM Implementation
#define INTERFACE IDirectPlay8Protocol
DECLARE_INTERFACE_(IDirectPlay8Protocol,IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG,Release)			(THIS) PURE;
	/*** IDirectPlay8Protocol methods ***/
	STDMETHOD(Initialize)				(THIS_ PVOID, PDN_PROTOCOL_INTERFACE_VTBL pfVTBL) PURE;
	STDMETHOD(Shutdown)					(THIS) PURE;
	STDMETHOD(AddServiceProvider)		(THIS_ IDP8ServiceProvider *const, PHANDLE) PURE;
	STDMETHOD(RemoveServiceProvider)	(THIS_ const HANDLE) PURE;
	STDMETHOD(Connect)					(THIS_ IDirectPlay8Address *const, IDirectPlay8Address *const, const HANDLE, DWORD, ULONG, PVOID, PHANDLE) PURE;
	STDMETHOD(Listen)					(THIS_ IDirectPlay8Address *const, const HANDLE, ULONG, PVOID, PHANDLE) PURE;
	STDMETHOD(SendData)					(THIS_ HANDLE, UINT, PBUFFERDESC, UINT, UINT, ULONG, PVOID, PHANDLE) PURE;
	STDMETHOD(DisconnectEP)				(THIS_ HANDLE, PVOID, PHANDLE) PURE;
	STDMETHOD(AbortEP)					(THIS_ HANDLE) PURE;
	STDMETHOD(Cancel)					(THIS_ HANDLE) PURE;
	STDMETHOD(ReturnReceiveBuffers)		(THIS_ HANDLE) PURE;
	STDMETHOD(GetEndpointCaps)			(THIS_ HANDLE, PVOID) PURE;
	STDMETHOD(GetCaps)					(THIS_ PDPN_CAPS) PURE;
	STDMETHOD(SetCaps)					(THIS_ const PDPN_CAPS) PURE;
	STDMETHOD(EnumQuery)				(THIS_ IDirectPlay8Address *const, IDirectPlay8Address *const, const HANDLE, BUFFERDESC *const, const DWORD, const DWORD, const DWORD, const DWORD, const DWORD, void *const, HANDLE *const) PURE;
	STDMETHOD(EnumRespond)				(THIS_ const HANDLE, const HANDLE, BUFFERDESC *const, const DWORD, const DWORD, void *const, HANDLE *const) PURE;
	STDMETHOD(CrackEPD)					(THIS_ HANDLE hEndPoint, long Flags, IDirectPlay8Address** ppAddr) PURE;
	STDMETHOD(GetListenAddressInfo)		(THIS_ HANDLE hCommand, long Flags, IDirectPlay8Address** ppAddr) PURE;
	STDMETHOD(Debug)					(THIS_ UINT, HANDLE, PVOID) PURE;
};

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\globals.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Globals.cpp
 *  Content:    Definition of global variables.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *	04/13/00	mjn		Added g_ProtocolVTBL
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//
//	Global Variables
//

DWORD	GdwHLocks = 0;
DWORD	GdwHObjects = 0;


DN_PROTOCOL_INTERFACE_VTBL	g_ProtocolVTBL =
{
	DNPIIndicateListenTerminated,
	DNPIIndicateEnumQuery,
	DNPIIndicateEnumResponse,
	DNPIIndicateConnect,
	DNPIIndicateDisconnect,
	DNPIIndicateConnectionTerminated,
	DNPIIndicateReceive,
	DNPICompleteListen,
	DNPICompleteListenTerminate,
	DNPICompleteEnumQuery,
	DNPICompleteEnumResponse,
	DNPICompleteConnect,
	DNPICompleteDisconnect,
	DNPICompleteSend,
	DNPIAddressInfoConnect,
	DNPIAddressInfoEnum,
	DNPIAddressInfoListen
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\enumhosts.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Enum.h
 *  Content:    Enumeration Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/10/00	mjn		Created
 *	04/17/00	mjn		Replaced BUFFERDESC with DPN_BUFFER_DESC
 *	07/10/00	mjn		Removed DNCompleteEnumQuery() and DNCompleteEnumResponse()
 *	07/11/00	mjn		Added fields to DN_ENUM_QUERY
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ENUMHOSTS_H__
#define	__ENUMHOSTS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_ENUM_QUERY_WITH_APPLICATION_GUID			0x01
#define	DN_ENUM_QUERY_WITHOUT_APPLICATION_GUID		0x02

#define	DN_ENUM_BUFFERDESC_QUERY_SP_RESERVED		0
#define	DN_ENUM_BUFFERDESC_QUERY_DN_PAYLOAD			1
#define	DN_ENUM_BUFFERDESC_QUERY_USER_PAYLOAD		2
#define	DN_ENUM_BUFFERDESC_QUERY_COUNT				2

#define	DN_ENUM_BUFFERDESC_RESPONSE_SP_RESERVED		0
#define	DN_ENUM_BUFFERDESC_RESPONSE_DN_PAYLOAD		1
#define	DN_ENUM_BUFFERDESC_RESPONSE_USER_PAYLOAD	2
#define	DN_ENUM_BUFFERDESC_RESPONSE_COUNT			2

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#pragma pack( push, 1 )
typedef	struct	_DN_ENUM_QUERY_PAYLOAD
{
	BYTE	QueryType;
	GUID	guidApplication;
} DN_ENUM_QUERY_PAYLOAD;

typedef	struct	_DN_ENUM_RESPONSE_PAYLOAD
{
//	BYTE	ResponseType;
//	GUID	guidInstance;
	DWORD	dwResponseOffset;
	DWORD	dwResponseSize;
} DN_ENUM_RESPONSE_PAYLOAD;
#pragma pack( pop )

typedef struct _DN_ENUM_QUERY
{
	DWORD					dwNumAdapters;
	DWORD					dwCurrentAdapter;
	DWORD					dwRetryCount;
	DWORD					dwRetryInterval;
	DWORD					dwTimeOut;
	DWORD					dwFlags;
	DN_ENUM_QUERY_PAYLOAD	EnumQueryPayload;
	DPN_BUFFER_DESC			BufferDesc[3];
} DN_ENUM_QUERY,*PDN_ENUM_QUERY;

typedef struct _DN_ENUM_RESPONSE
{
	DN_ENUM_RESPONSE_PAYLOAD	EnumResponsePayload;
	DPN_BUFFER_DESC				BufferDesc[3];
	void						*pvUserContext;
} DN_ENUM_RESPONSE,*PDN_ENUM_RESPONSE;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

void DNProcessEnumQuery(DIRECTNETOBJECT *const pdnObject,
						CAsyncOp *const pAsyncOp,
						const PROTOCOL_ENUM_DATA *const pEnumQueryData );

void DNProcessEnumResponse(DIRECTNETOBJECT *const pdnObject,
						   CAsyncOp *const pAsyncOp,
						   const PROTOCOL_ENUM_RESPONSE_DATA *const pEnumResponseData );

//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __ENUMHOSTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\groupcon.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       GroupCon.cpp
 *  Content:    Group Connection object routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/02/00	mjn		Created
 *	04/18/00	mjn		CConnection tracks connection status better
 *	05/05/00	mjn		Added GetConnectionRef()
 *	08/15/00	mjn		Added SetGroup()
 *				mjn		Fixed Release() to take locks and cleanup m_pGroup
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


void CGroupConnection::ReturnSelfToPool( void )
{
	m_pdnObject->m_pFPOOLGroupConnection->Release( this );
}

#undef DPF_MODNAME
#define DPF_MODNAME "CGroupConnection::Release"

void CGroupConnection::Release(void)
{
	LONG	lRefCount;

	DNASSERT(m_lRefCount > 0);
	lRefCount = InterlockedDecrement(const_cast<LONG*>(&m_lRefCount));
	if (lRefCount == 0)
	{
		if (m_pGroup)
		{
			m_pGroup->Lock();
			RemoveFromConnectionList();
			m_pGroup->Unlock();

			m_pGroup->Release();
			m_pGroup = NULL;
		}
		if (m_pConnection)
		{
			m_pConnection->Release();
			m_pConnection = NULL;
		}
		m_dwFlags = 0;
		m_lRefCount = 0;
		ReturnSelfToPool();
	}
}


void CGroupConnection::SetConnection( CConnection *const pConnection )
{
	if (pConnection)
	{
		pConnection->Lock();
		if (pConnection->IsConnected())
		{
			pConnection->AddRef();
			m_pConnection = pConnection;
		}
		pConnection->Unlock();
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CGroupConnection::GetConnectionRef"

HRESULT	CGroupConnection::GetConnectionRef( CConnection **const ppConnection )
{
	HRESULT		hResultCode;

	DNASSERT( ppConnection != NULL);

	Lock();
	if ( m_pConnection && !m_pConnection->IsInvalid())
	{
		m_pConnection->AddRef();
		*ppConnection = m_pConnection;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_NOCONNECTION;
	}
	Unlock();

	return( hResultCode );
}


void CGroupConnection::SetGroup( CNameTableEntry *const pGroup )
{
	if (pGroup)
	{
		pGroup->AddRef();
	}
	m_pGroup = pGroup;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\enum_sp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Enum_SP.cpp
 *  Content:    DNET service provider enumeration routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/28/99	mjn		Created
 *	01/05/00	mjn		Return DPNERR_NOINTERFACE if CoCreateInstance fails
 *	01/07/00	mjn		Moved Misc Functions to DNMisc.h
 *	01/11/00	mjn		Use CPackedBuffers instead of DN_ENUM_BUFFER_INFOs
 *	01/18/00	mjn		Converted EnumAdapters registry interface to use CRegistry
 *	01/24/00	mjn		Converted EnumSP registry interface to use CRegistry
 *	04/07/00	mjn		Fixed MemoryHeap corruption problem in DN_EnumSP
 *	04/08/00	mjn		Added DN_SPCrackEndPoint()
 *	05/01/00	mjn		Prevent unusable SPs from being enumerated.
 *	05/02/00	mjn		Better clean-up for DN_SPEnsureLoaded()
 *	05/03/00	mjn		Added DPNENUMSERVICEPROVIDERS_ALL flag
 *	05/23/00	mjn		Fixed cast from LPGUID to GUID*
 *	06/27/00	rmt		Added COM abstraction
 *	07/20/00	mjn		Return SP count from DN_EnumSP() even when buffer is too small
 *	07/29/00	mjn		Added fUseCachedCaps to DN_SPEnsureLoaded()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/16/00	mjn		Removed DN_SPCrackEndPoint()
 *	08/20/00	mjn		Added DN_SPInstantiate(), DN_SPLoad()
 *				mjn		Removed fUseCachedCaps from DN_SPEnsureLoaded()
 *	09/25/00	mjn		Handle SP initialization failure in DN_EnumAdapters()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DN_EnumSP"

HRESULT DN_EnumSP(DIRECTNETOBJECT *const pdnObject,
				  const DWORD dwFlags,
				  const GUID *const lpguidApplication,
				  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
				  DWORD *const pcbEnumData,
				  DWORD *const pcReturned)
{
	HRESULT	hResultCode = DPN_OK;
	DWORD	dwSizeRequired;
	DPN_SERVICE_PROVIDER_INFO	dnSpInfo;
	CPackedBuffer				packedBuffer;
	WCHAR wszSP[] = L"DirectPlay8 TCP/IP Service Provider";
	GUID guidSP = { 0xEBFE7BA0, 0x628D, 0x11D2, { 0xAE, 0x0F, 0x00, 0x60, 0x97, 0xB0, 0x14, 0x11 } };

	DPF(4,"Parameters: dwFlags [0x%lx], lpguidApplication [0x%p], pSPInfoBuffer [0x%p], pcbEnumData [0x%p], pcReturned [0x%p]",
		dwFlags,lpguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned);

	
	DNASSERT(pcbEnumData != NULL);
	DNASSERT(pcReturned != NULL);

	dwSizeRequired = *pcbEnumData;
	packedBuffer.Initialize(static_cast<void*>(pSPInfoBuffer),dwSizeRequired);

	hResultCode = packedBuffer.AddToBack(wszSP,(wcslen(wszSP)+1)*sizeof(WCHAR));
	dnSpInfo.pwszName = static_cast<WCHAR*>(packedBuffer.GetTailAddress());

	memcpy(&dnSpInfo.guid,&guidSP,sizeof(GUID));

	dnSpInfo.dwFlags = 0;
	dnSpInfo.dwReserved = 0;
	dnSpInfo.pvReserved = NULL;
	hResultCode = packedBuffer.AddToFront(&dnSpInfo,sizeof(DPN_SERVICE_PROVIDER_INFO));

	dwSizeRequired = packedBuffer.GetSizeRequired();
	if (dwSizeRequired > *pcbEnumData)
	{
		DPF(5,"Buffer too small");
		*pcbEnumData = dwSizeRequired;
		*pcReturned = 1;
		hResultCode = DPNERR_BUFFERTOOSMALL;
		goto Exit;
	}
	else
	{
		*pcReturned = 1;
	}

	DPF(5,"*pcbEnumData [%ld], *pcReturned [%ld]",*pcbEnumData,*pcReturned);

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPReleaseAll"

void DN_SPReleaseAll(DIRECTNETOBJECT *const pdnObject)
{
	CBilink				*pBilink;
	CServiceProvider	*pSP;

	DPF(6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	DNEnterCriticalSection(&pdnObject->csServiceProviders);

	pBilink = pdnObject->m_bilinkServiceProviders.GetNext();
	while (pBilink != &pdnObject->m_bilinkServiceProviders)
	{
		pSP = CONTAINING_OBJECT(pBilink,CServiceProvider,m_bilinkServiceProviders);
		pBilink = pBilink->GetNext();
		pSP->m_bilinkServiceProviders.RemoveFromList();
		pSP->Release();
		pSP = NULL;
	}

	DNLeaveCriticalSection(&pdnObject->csServiceProviders);

	DPF(6,"Returning");
}



//	DN_SPFindEntry
//
//	Find a connected SP and AddRef it if it exists

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPFindEntry"

HRESULT DN_SPFindEntry(DIRECTNETOBJECT *const pdnObject,
					   const GUID *const pguid,
					   CServiceProvider **const ppSP)
{
	HRESULT				hResultCode;
	CBilink				*pBilink;
	CServiceProvider	*pSP;

	DPF(6,"Parameters: pguid [0x%p], ppSP [0x%p]",pguid,ppSP);

	DNEnterCriticalSection(&pdnObject->csServiceProviders);

	hResultCode = DPNERR_DOESNOTEXIST;
	pBilink = pdnObject->m_bilinkServiceProviders.GetNext();
	while (pBilink != &pdnObject->m_bilinkServiceProviders)
	{
		pSP = CONTAINING_OBJECT(pBilink,CServiceProvider,m_bilinkServiceProviders);
			pSP->AddRef();
			*ppSP = pSP;
			hResultCode = DPN_OK;
			break;
		pBilink = pBilink->GetNext();
	}

	DNLeaveCriticalSection(&pdnObject->csServiceProviders);

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DN_SPInstantiate
//
//	Instantiate an SP, regardless of whether it's loaded or not

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPInstantiate"

HRESULT DN_SPInstantiate(DIRECTNETOBJECT *const pdnObject,
						 const GUID *const pguid,
						 CServiceProvider **const ppSP)
{
	HRESULT		hResultCode;
	CServiceProvider	*pSP;

	DPF(6,"Parameters: pguid [0x%p], ppSP [0x%p]",pguid,ppSP);

	pSP = NULL;

	//
	//	Create and initialize SP
	//
	pSP = new CServiceProvider;
	if (pSP == NULL)
	{
		DPFERR("Could not create SP");
		hResultCode = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	if ((hResultCode = pSP->Initialize(pdnObject,pguid)) != DPN_OK)
	{
		DPFERR("Could not initialize SP");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	if (ppSP)
	{
		pSP->AddRef();
		*ppSP = pSP;
	}

	pSP->Release();
	pSP = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}


//	DN_SPLoad
//
//	Load an SP, and set caps

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPLoad"

HRESULT DN_SPLoad(DIRECTNETOBJECT *const pdnObject,
				  const GUID *const pguid,
				  CServiceProvider **const ppSP)
{
	HRESULT		hResultCode;
	DPN_SP_CAPS	*pCaps;
	CBilink		*pBilink;
	CServiceProvider	*pSP;

	DPF(6,"Parameters: pguid [0x%p], ppSP [0x%p]",pguid,ppSP);

	pSP = NULL;
	pCaps = NULL;

	//
	//	Instantiate SP
	//
	if ((hResultCode = DN_SPInstantiate(pdnObject,pguid,&pSP)) != DPN_OK)
	{
		DPFERR("Could not instantiate SP");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	Try to load SP caps (if they exist)
	//
	if ((hResultCode = DNGetCachedSPCaps(pdnObject,pguid,&pCaps)) == DPN_OK)
	{
		if ((hResultCode = DNSetActualSPCaps(pdnObject,pSP,pCaps)) != DPN_OK)
		{
			DPFERR("Could not set SP caps");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}

	DNASSERT(pSP != NULL);

	//
	//	Keep this loaded on the DirectNet object.  We will also check for duplicates.
	//
	DNEnterCriticalSection(&pdnObject->csServiceProviders);

	pBilink = pdnObject->m_bilinkServiceProviders.GetNext();
	while (pBilink != &pdnObject->m_bilinkServiceProviders)
	{
			DNLeaveCriticalSection(&pdnObject->csServiceProviders);
			DPFERR("SP is already loaded!");
			hResultCode = DPNERR_ALREADYINITIALIZED;
			goto Failure;
		pBilink = pBilink->GetNext();
	}

	pSP->AddRef();
	pSP->m_bilinkServiceProviders.InsertBefore(&pdnObject->m_bilinkServiceProviders);

	DNLeaveCriticalSection(&pdnObject->csServiceProviders);

	if (ppSP)
	{
		pSP->AddRef();
		*ppSP = pSP;
	}

	pSP->Release();
	pSP = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}


//	DN_SPEnsureLoaded
//
//	Ensure that an SP is loaded.  If the SP is not loaded,
//	it will be instantiated, and connected to the protocol.
//	If it is loaded, its RefCount will be increased.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SPEnsureLoaded"

HRESULT DN_SPEnsureLoaded(DIRECTNETOBJECT *const pdnObject,
						  const GUID *const pguid,
						  CServiceProvider **const ppSP)
{
	HRESULT				hResultCode;
	CServiceProvider	*pSP;

	DPF(6,"Parameters: pguid [0x%p], ppSP [0x%p]",pguid,ppSP);

	pSP = NULL;

	//
	//	Try to find the SP
	//
	if ((hResultCode = DN_SPFindEntry(pdnObject,pguid,&pSP)) == DPNERR_DOESNOTEXIST)
	{
		//
		//	Instantiate SP and add to Protocol
		//
		if ((hResultCode = DN_SPLoad(pdnObject,pguid,&pSP)) != DPN_OK)
		{
			DPFERR("Could not load SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}
	else
	{
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not find SP");
			DisplayDNError(0,hResultCode);
			goto Failure;
		}
	}

	DNASSERT(pSP != NULL);

	if (ppSP != NULL)
	{
		pSP->AddRef();
		*ppSP = pSP;
	}

	pSP->Release();
	pSP = NULL;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pSP)
	{
		pSP->Release();
		pSP = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\groupmem.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       GroupMem.cpp
 *  Content:    Group Membership object routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	03/03/00	mjn		Created
 *	08/05/99	mjn		Modified SetMembership to perform duplicate check and get NameTable version internally
 *	08/15/00	mjn		Allow NULL pGroupConnection in SetGroupConnection()
 *	09/17/00	mjn		Remove locks from SetMembership()
 *	09/26/00	mjn		Assume NameTable locks are taken for AddMembership() and RemoveMembership()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"


void CGroupMember::ReturnSelfToPool( void )
{
	m_pdnObject->m_pFPOOLGroupMember->Release( this );
};


#undef DPF_MODNAME
#define DPF_MODNAME "CGroupMember::Release"
void CGroupMember::Release( void )
{
	LONG	lRefCount;

	lRefCount = InterlockedDecrement(&m_lRefCount);

	if (lRefCount == 0)
	{
		DNASSERT(!(m_dwFlags & GROUP_MEMBER_FLAG_AVAILABLE));

		if (m_pGroup != NULL)
		{
			m_pGroup->Release();
			m_pGroup = NULL;
		}
		if (m_pPlayer != NULL)
		{
			m_pPlayer->Release();
			m_pPlayer = NULL;
		}
		if (m_pGroupConnection != NULL)
		{
			m_pGroupConnection->Release();
			m_pGroupConnection = NULL;
		}

		ReturnSelfToPool();
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CGroupMember::SetMembership"

HRESULT CGroupMember::SetMembership(CNameTableEntry *const pGroup,
									CNameTableEntry *const pPlayer,
									DWORD *const pdwVersion)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CGroupMember	*pGroupMember;

	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

	//
	//	THIS ASSUMES THAT LOCKS FOR NameTable,pGroup,pPlayer and 'this' are taken (in that order) !
	//

	//
	//	Scan group list to ensure this player is not a member already
	//
	pBilink = pGroup->m_bilinkMembership.GetNext();
	while (pBilink != &pGroup->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
		if (pGroupMember->GetPlayer() == pPlayer)
		{
			hResultCode = DPNERR_PLAYERALREADYINGROUP;
			goto Failure;
		}
		pBilink = pBilink->GetNext();
	}

	//
	//	Version stuff
	//
	if (pdwVersion)
	{
		if (*pdwVersion)
		{
			DPF(7,"Version already specified");
			m_dwVersion = *pdwVersion;
			m_pdnObject->NameTable.SetVersion(*pdwVersion);
		}
		else
		{
			DPF(7,"New version required");
			m_pdnObject->NameTable.GetNewVersion( &m_dwVersion );
			*pdwVersion = m_dwVersion;
		}
	}
	else
	{
		m_dwVersion = 0;
	}

	//
	//	Update
	//
	AddRef();
	pGroup->AddRef();
	m_pGroup = pGroup;

	AddRef();
	pPlayer->AddRef();
	m_pPlayer = pPlayer;

	m_bilinkGroups.InsertBefore(&pPlayer->m_bilinkMembership);
	m_bilinkPlayers.InsertBefore(&pGroup->m_bilinkMembership);

	if (m_pGroupConnection)
	{
		m_pGroupConnection->AddToConnectionList( &pGroup->m_bilinkConnections );
	}

	hResultCode = DPN_OK;

Exit:
	return(hResultCode);

Failure:
	goto Exit;
}


void CGroupMember::RemoveMembership( DWORD *const pdnVersion )
{
	//
	//	THIS ASSUMES THAT LOCKS FOR NameTable,pGroup,pPlayer and 'this' are taken (in that order) !
	//	Since there will be several Release()'d items, someone should keep a reference on them
	//		so that they don't get free'd with all of the locks taken !
	//

	m_pGroup->Release();
	m_pGroup = NULL;
	Release();

	m_pPlayer->Release();
	m_pPlayer = NULL;
	Release();

	m_bilinkGroups.RemoveFromList();
	m_bilinkPlayers.RemoveFromList();

	if (m_pGroupConnection)
	{
		m_pGroupConnection->RemoveFromConnectionList();
	}

	if (pdnVersion)
	{
		if (*pdnVersion != 0)
		{
			m_pdnObject->NameTable.SetVersion( *pdnVersion );
		}
		else
		{
			m_pdnObject->NameTable.GetNewVersion( pdnVersion );
		}
	}
};


void CGroupMember::SetGroupConnection( CGroupConnection *const pGroupConnection )
{
	if (pGroupConnection)
	{
		pGroupConnection->AddRef();
	}
	m_pGroupConnection = pGroupConnection;
}


HRESULT	CGroupMember::PackMembershipInfo(CPackedBuffer *const pPackedBuffer)
{
	HRESULT		hResultCode;
	DN_NAMETABLE_MEMBERSHIP_INFO	*pdnMembershipInfo;

	pdnMembershipInfo = static_cast<DN_NAMETABLE_MEMBERSHIP_INFO*>(pPackedBuffer->GetHeadAddress());
	if ((hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DN_NAMETABLE_MEMBERSHIP_INFO))) == DPN_OK)
	{
		pdnMembershipInfo->dpnidGroup = m_pGroup->GetDPNID();
		pdnMembershipInfo->dpnidPlayer = m_pPlayer->GetDPNID();
		pdnMembershipInfo->dwVersion = m_dwVersion;
		pdnMembershipInfo->dwVersionNotUsed = 0;
	}

	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\groupcon.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       GroupCon.h
 *  Content:    Group Connection Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/02/00	mjn		Created
 *	05/05/00	mjn		Added GetConnectionRef()
 *	08/15/00	mjn		Added m_pGroup,SetGroup(),GetGroup()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__GROUPCON_H__
#define	__GROUPCON_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	VALID		0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CGroupConnection > class CLockedContextClassFixedPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Group Connections

class CGroupConnection
{
	STDNEWDELETE

public:
	CGroupConnection()				// Constructor
		{
			m_Sig[0] = 'G';
			m_Sig[1] = 'C';
			m_Sig[2] = 'O';
			m_Sig[3] = 'N';
		};

	~CGroupConnection() { };			// Destructor

	BOOL FPMAlloc( void *const pvContext )
		{
			if (!DNInitializeCriticalSection(&m_cs))
			{
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&m_cs,0);
		
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	BOOL FPMInitialize( void *const pvContext )
		{
			m_dwFlags = 0;
			m_bilink.Initialize();
			m_pConnection = NULL;
			m_lRefCount = 1;
			m_pGroup = NULL;

			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
			DNDeleteCriticalSection(&m_cs);
		};

	void ReturnSelfToPool( void );

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupConnection::AddRef"
	void AddRef(void)
		{
			DNASSERT(m_lRefCount > 0);
			InterlockedIncrement(const_cast<LONG*>(&m_lRefCount));
		};

	void Release(void);

	void Lock( void )
		{
			DNEnterCriticalSection(&m_cs);
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection(&m_cs);
		};

	void AddToConnectionList( CBilink *const pBilink )
		{
			m_bilink.InsertBefore(pBilink);
		};

	void RemoveFromConnectionList( void )
		{
			m_bilink.RemoveFromList();
		};

	void SetConnection( CConnection *const pConnection );

	CConnection *GetConnection( void )
	{
		return(m_pConnection);
	};

	HRESULT	GetConnectionRef( CConnection **const ppConnection );

	void SetGroup( CNameTableEntry *const pGroup );

	CNameTableEntry *GetGroup( void )
		{
			return( m_pGroup );
		};

	void MakeValid( void )
		{
			m_dwFlags |= VALID;
		};

	void MakeInvalid( void )
		{
			m_dwFlags &= (~VALID);
		};

	BOOL IsConnected( void )
		{
			if (m_pConnection != NULL)
				return(TRUE);

			return(FALSE);
		};

	CBilink				m_bilink;

private:
	BYTE				m_Sig[4];
	DWORD	volatile	m_dwFlags;
	LONG	volatile	m_lRefCount;
	CConnection			*m_pConnection;
	CNameTableEntry		*m_pGroup;
	DNCRITICAL_SECTION	m_cs;
	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __GROUPCON_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\enum_sp.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Enum_SP.h
 *  Content:    DirectNet SP/Adapter Enumeration
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/15/00	mjn		Created
 *	04/08/00	mjn		Added DN_SPCrackEndPoint()
 *	05/01/00	mjn		Prevent unusable SPs from being enumerated.
 *	07/29/00	mjn		Added fUseCachedCaps to DN_SPEnsureLoaded()
 *	08/16/00	mjn		Removed DN_SPCrackEndPoint()
 *	08/20/00	mjn		Added DN_SPInstantiate(), DN_SPLoad()
 *				mjn		Removed fUseCachedCaps from DN_SPEnsureLoaded()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__ENUM_SP_H__
#define	__ENUM_SP_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#ifndef	GUID_STRING_LENGTH
#define	GUID_STRING_LENGTH	((sizeof(GUID) * 2) + 2 + 4)
#endif
//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//
//	Enumeration
//
HRESULT DN_EnumSP(DIRECTNETOBJECT *const pdnObject,
				  const DWORD dwFlags,
				  const GUID *const lpguidApplication,
				  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
				  DWORD *const pcbEnumData,
				  DWORD *const pcReturned);

void DN_SPReleaseAll(DIRECTNETOBJECT *const pdnObject);

HRESULT DN_SPFindEntry(DIRECTNETOBJECT *const pdnObject,
					   const GUID *const pguidSP,
					   CServiceProvider **const ppSP);

HRESULT DN_SPInstantiate(DIRECTNETOBJECT *const pdnObject,
						 const GUID *const pguid,
						 CServiceProvider **const ppSP);

HRESULT DN_SPLoad(DIRECTNETOBJECT *const pdnObject,
				  const GUID *const pguid,
				  CServiceProvider **const ppSP);

HRESULT DN_SPEnsureLoaded(DIRECTNETOBJECT *const pdnObject,
						  const GUID *const pguid,
						  CServiceProvider **const ppSP);


#endif	// __ENUM_SP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\handles.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       handles.h
 *  Content:    Handle manager header file
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/19/99	mjn		Created
 *	03/23/00	mjn		Revised to ensure 64-bit compliance
 *	03/24/00	mjn		Added H_Enum
 *
 ***************************************************************************/

#ifndef __HANDLES_H__
#define __HANDLES_H__

typedef struct
{
	DWORD	dwSerial;
	union
	{
		void	*pvData;
		DWORD	dwIndex;
	} Entry;
} HANDLEELEMENT;

typedef struct _HANDLESTRUCT
{
	DWORD				dwNumHandles;
	DWORD				dwFirstFreeHandle;
	DWORD				dwLastFreeHandle;
	DWORD				dwNumFreeHandles;
	DWORD				dwSerial;
	DNCRITICAL_SECTION	dncs;
	HANDLEELEMENT		*HandleArray;
} HANDLESTRUCT;

HRESULT H_Grow(HANDLESTRUCT *const phs,
			   const DWORD dwIncSize);

HRESULT	H_Initialize(HANDLESTRUCT *const phs,
					 const DWORD dwInitialNum);

void H_Terminate(HANDLESTRUCT *const phs);

HRESULT H_Create(HANDLESTRUCT *const phs,
				 void *const pvData,
				 DWORD *const pHandle);

HRESULT	H_Destroy(HANDLESTRUCT *const phs,
				  const DWORD handle);

HRESULT H_Retrieve(HANDLESTRUCT *const phs,
				   const DWORD handle,
				   void **const ppvData);

HRESULT H_Enum(HANDLESTRUCT *const phs,
			   DWORD *const pdwNumHandles,
			   DWORD *const rgHandles);

#endif	// __HANDLES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\groupmem.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       GroupMem.h
 *  Content:    Group Membership Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	03/03/00	mjn		Created
 *	08/05/99	mjn		Modified SetMembership to perform duplicate check and get NameTable version internally 
 *	09/17/99	mjn		Added GROUP_MEMBER_FLAG_NEED_TO_ADD,GROUP_MEMBER_FLAG_NEED_TO_REMOVE
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__GROUPMEM_H__
#define	__GROUPMEM_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	GROUP_MEMBER_FLAG_VALID				0x0001
#define	GROUP_MEMBER_FLAG_AVAILABLE			0x0002
#define	GROUP_MEMBER_FLAG_NEED_TO_ADD		0x0004
#define	GROUP_MEMBER_FLAG_NEED_TO_REMOVE	0x0008

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CGroupMember > class CLockedContextClassFixedPool;

//
//	Used to pass NameTable group membership
//
typedef struct _DN_NAMETABLE_MEMBERSHIP_INFO
{
	DPNID	dpnidPlayer;
	DPNID	dpnidGroup;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
} DN_NAMETABLE_MEMBERSHIP_INFO, *PDN_NAMETABLE_MEMBERSHIP_INFO;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Group Members

class CGroupMember
{
	STDNEWDELETE

public:
	CGroupMember()					// Constructor
		{
			m_Sig[0] = 'G';
			m_Sig[1] = 'M';
			m_Sig[2] = 'E';
			m_Sig[3] = 'M';
		};

	~CGroupMember() { };			// Destructor

	BOOL FPMAlloc( void *const pvContext )
		{
			if (!DNInitializeCriticalSection(&m_cs))
			{
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&m_cs,0);

			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	BOOL FPMInitialize( void *const pvContext )
		{
			m_dwFlags = 0;
			m_lRefCount = 1;
			m_pGroup = NULL;
			m_pPlayer = NULL;
			m_bilinkPlayers.Initialize();
			m_bilinkGroups.Initialize();
			m_pGroupConnection = NULL;

			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
			DNDeleteCriticalSection(&m_cs);
		};

	void MakeValid( void )
		{
			m_dwFlags |= GROUP_MEMBER_FLAG_VALID;
		};

	void MakeInvalid( void )
		{
			m_dwFlags &= (~GROUP_MEMBER_FLAG_VALID);
		};

	BOOL IsValid( void )
		{
			if (m_dwFlags & GROUP_MEMBER_FLAG_VALID)
				return(TRUE);

			return(FALSE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupMember::MakeAvailable"
	void MakeAvailable( void )
		{
			DNASSERT(m_pGroup != NULL);
			DNASSERT(m_pPlayer != NULL);

			m_dwFlags |= GROUP_MEMBER_FLAG_AVAILABLE;
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CGroupMember::MakeUnavailable"
	void MakeUnavailable( void )
		{
			m_dwFlags &= (~GROUP_MEMBER_FLAG_AVAILABLE);
		};

	BOOL IsAvailable( void )
		{
			if (m_dwFlags & GROUP_MEMBER_FLAG_AVAILABLE)
				return(TRUE);

			return(FALSE);
		};

	void SetNeedToAdd( void )
		{
			m_dwFlags |= GROUP_MEMBER_FLAG_NEED_TO_ADD;
		};

	void ClearNeedToAdd( void )
		{
			m_dwFlags &= (~GROUP_MEMBER_FLAG_NEED_TO_ADD);
		};

	BOOL IsNeedToAdd( void )
		{
			if (m_dwFlags & GROUP_MEMBER_FLAG_NEED_TO_ADD)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetNeedToRemove( void )
		{
			m_dwFlags |= GROUP_MEMBER_FLAG_NEED_TO_REMOVE;
		};

	void ClearNeedToRemove( void )
		{
			m_dwFlags &= (~GROUP_MEMBER_FLAG_NEED_TO_REMOVE);
		};

	BOOL IsNeedToRemove( void )
		{
			if (m_dwFlags & GROUP_MEMBER_FLAG_NEED_TO_REMOVE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void AddRef( void )
		{
			InterlockedIncrement(&m_lRefCount);
		};

	void Release( void );

	void ReturnSelfToPool( void );

	void Lock( void )
		{
			DNEnterCriticalSection(&m_cs);
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection(&m_cs);
		};

	void CGroupMember::RemoveMembership( DWORD *const pdnVersion );

	void SetVersion( const DWORD dwVersion )
		{
			m_dwVersion = dwVersion;
		};

	DWORD GetVersion( void )
		{
			return(m_dwVersion);
		};

	HRESULT CGroupMember::SetMembership(CNameTableEntry *const pGroup,
										CNameTableEntry *const pPlayer,
										DWORD *const pdwVersion);

	CNameTableEntry *GetGroup( void )
		{
			return(m_pGroup);
		};

	CNameTableEntry *GetPlayer( void )
		{
			return(m_pPlayer);
		};

	void SetGroupConnection( CGroupConnection *const pGroupConnection );

	CGroupConnection *GetGroupConnection( void )
		{
			return(m_pGroupConnection);
		};

	HRESULT	CGroupMember::PackMembershipInfo(CPackedBuffer *const pPackedBuffer);

	CBilink				m_bilinkPlayers;	// Players in this group
	CBilink				m_bilinkGroups;		// Groups this player belongs to

private:
	BYTE				m_Sig[4];
	DWORD				m_dwFlags;
	LONG				m_lRefCount;

	CNameTableEntry		*m_pPlayer;
	CNameTableEntry		*m_pGroup;
	CGroupConnection	*m_pGroupConnection;

	DWORD				m_dwVersion;
	DWORD				m_dwVersionNotUsed;

	DIRECTNETOBJECT		*m_pdnObject;

	DNCRITICAL_SECTION	m_cs;
};

#undef DPF_MODNAME

#endif	// __GROUPMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\handletable.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HandleTable.cpp
 *  Content:    HandleTable Object
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/08/00	mjn		Created
 *	04/16/00	mjn		Added Update() and allow NULL data for Handles
 *	05/05/00	mjn		Clean-up old array for GrowTable() and Deinitialize()
 *	07/07/00	mjn		Fixed validation error in Find()
 *	08/07/00	mjn		Fixed uninitialization problem in Grow()
 *	08/08/00	mjn		Better validation in Find()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

#define HANDLETABLE_INDEX_MASK				0x00FFFFFF
#define HANDLETABLE_VERSION_MASK			0xFF000000
#define HANDLETABLE_VERSION_SHIFT			24

//**********************************************************************
// Macro definitions
//**********************************************************************

#define	CONSTRUCT_DPNHANDLE(i,v)	((i & HANDLETABLE_INDEX_MASK) | ((v << HANDLETABLE_VERSION_SHIFT) & HANDLETABLE_VERSION_MASK))

#define	DECODE_HANDLETABLE_INDEX(h)			(h & HANDLETABLE_INDEX_MASK)

#define	VERIFY_HANDLETABLE_VERSION(h,v)		((h & HANDLETABLE_VERSION_MASK) == (v << HANDLETABLE_VERSION_SHIFT))

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _HANDLETABLE_ARRAY_ENTRY
{
	DWORD		dwVersion;
	union {
		CAsyncOp	*pAsyncOp;
		DWORD		dwIndex;
	} Entry;
} HANDLETABLE_ARRAY_ENTRY;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Initialize"
HRESULT CHandleTable::Initialize( void )
{
	if (!DNInitializeCriticalSection(&m_cs))
	{
		return(DPNERR_OUTOFMEMORY);
	}

	m_dwNumEntries = 0;
	m_dwNumFreeEntries = 0;
	m_dwFirstFreeEntry = 0;
	m_dwLastFreeEntry = 0;
	m_dwVersion = 1;

	m_pTable = NULL;

	m_dwFlags |= HANDLETABLE_FLAG_INITIALIZED;

	return(DPN_OK);
};


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Deinitialize"
void CHandleTable::Deinitialize( void )
{
	Lock();
	m_dwFlags &= (~HANDLETABLE_FLAG_INITIALIZED);
	if (m_pTable)
	{
		DNFree(m_pTable);
		m_pTable = NULL;
	}
	Unlock();

	DNDeleteCriticalSection(&m_cs);
};


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::GrowTable"
HRESULT CHandleTable::GrowTable( void )
{
	HANDLETABLE_ARRAY_ENTRY *pNewArray;
	DWORD			dwNewSize;
	DWORD			dw;

	DNASSERT(m_dwFlags & HANDLETABLE_FLAG_INITIALIZED);

	//
	//	Double table size or seed with 2 entries
	//
	if (m_dwNumEntries == 0)
	{
		dwNewSize = 2;
	}
	else
	{
		dwNewSize = m_dwNumEntries * 2;
	}

	//
	//	Allocate new array
	//
	pNewArray = static_cast<HANDLETABLE_ARRAY_ENTRY*>(DNMalloc(sizeof(HANDLETABLE_ARRAY_ENTRY) * dwNewSize));
	if (pNewArray == NULL)
	{
		return(DPNERR_OUTOFMEMORY);
	}

	//
	//	Copy old array to new array
	//
	if (m_pTable)
	{
		memcpy(pNewArray,m_pTable,m_dwNumEntries * sizeof(HANDLETABLE_ARRAY_ENTRY));
		DNFree(m_pTable);
		m_pTable = NULL;
	}
	m_pTable = pNewArray;

	//
	//	Free entries at end of new array
	//
	for (dw = m_dwNumEntries ; dw < dwNewSize - 1 ; dw++ )
	{
		m_pTable[dw].Entry.dwIndex = dw + 1;
		m_pTable[dw].dwVersion = 0;
	}
	m_pTable[dwNewSize-1].Entry.dwIndex = 0;
	m_pTable[dwNewSize-1].dwVersion = 0;

	m_dwFirstFreeEntry = m_dwNumEntries;
	if (m_dwFirstFreeEntry == 0)
	{
		m_dwFirstFreeEntry++;
	}
	m_dwLastFreeEntry = dwNewSize - 1;
	m_dwNumEntries = dwNewSize;
	m_dwNumFreeEntries = m_dwLastFreeEntry - m_dwFirstFreeEntry + 1;

	return(DPN_OK);
};



#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Create"

HRESULT CHandleTable::Create( CAsyncOp *const pAsyncOp,
							  DPNHANDLE *const pHandle )
{
	HRESULT		hResultCode;
	DWORD		dwIndex;
	DPNHANDLE	handle;

	DNASSERT( (pAsyncOp != NULL) || (pHandle != NULL) );

	DNASSERT(m_dwFlags & HANDLETABLE_FLAG_INITIALIZED);

	Lock();

	if (m_dwNumFreeEntries == 0)
	{
		if ((hResultCode = GrowTable()) != DPN_OK)
		{
			Unlock();
			return(hResultCode);
		}
	}
	DNASSERT(m_dwNumFreeEntries != 0);
	dwIndex = m_dwFirstFreeEntry;

	handle = CONSTRUCT_DPNHANDLE(dwIndex,m_dwVersion);

	m_dwFirstFreeEntry = m_pTable[m_dwFirstFreeEntry].Entry.dwIndex;

	if (pAsyncOp)
	{
		pAsyncOp->AddRef();
	}
	m_pTable[dwIndex].Entry.pAsyncOp = pAsyncOp;
	m_pTable[dwIndex].dwVersion = m_dwVersion;

	m_dwNumFreeEntries--;
	m_dwVersion++;
	if (m_dwVersion == 0)
	{
		m_dwVersion++;	// Don't allow 0
	}

	Unlock();

DPF(1,"Create handle [0x%lx]",handle);

	if (pAsyncOp)
	{
		pAsyncOp->Lock();
		pAsyncOp->SetHandle( handle );
		pAsyncOp->Unlock();
	}

	if (pHandle)
	{
		*pHandle = handle;
	}

	return(DPN_OK);
}



#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Destroy"

HRESULT CHandleTable::Destroy( const DPNHANDLE handle )
{
	DWORD	dwIndex;

DPF(1,"Create handle [0x%lx]",handle);

	DNASSERT(handle != 0);

	DNASSERT(m_dwFlags & HANDLETABLE_FLAG_INITIALIZED);

	dwIndex = DECODE_HANDLETABLE_INDEX( handle );

	if (dwIndex > m_dwNumEntries)
	{
		return(DPNERR_INVALIDHANDLE);
	}

	Lock();

	if (!VERIFY_HANDLETABLE_VERSION(handle,m_pTable[dwIndex].dwVersion))
	{
		Unlock();
		return(DPNERR_INVALIDHANDLE);
	}

	if (m_pTable[dwIndex].Entry.pAsyncOp)
	{
		m_pTable[dwIndex].Entry.pAsyncOp->Release();
	}

	m_pTable[dwIndex].Entry.dwIndex = 0;
	m_pTable[dwIndex].dwVersion = 0;

	if (m_dwNumFreeEntries == 0)
	{
		m_dwFirstFreeEntry = dwIndex;
	}
	else
	{
		m_pTable[m_dwLastFreeEntry].Entry.dwIndex = dwIndex;
	}
	m_dwLastFreeEntry = dwIndex;
	m_dwNumFreeEntries++;

	Unlock();

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Update"

HRESULT CHandleTable::Update( const DPNHANDLE handle,
							  CAsyncOp *const pAsyncOp )
{
	DWORD	dwIndex;

	DNASSERT(handle != 0);

	DNASSERT(m_dwFlags & HANDLETABLE_FLAG_INITIALIZED);

	dwIndex = DECODE_HANDLETABLE_INDEX( handle );

	if ((dwIndex == 0) || (dwIndex > m_dwNumEntries))
	{
		return(DPNERR_INVALIDHANDLE);
	}

	Lock();

	if (!VERIFY_HANDLETABLE_VERSION(handle,m_pTable[dwIndex].dwVersion))
	{
		Unlock();
		return(DPNERR_INVALIDHANDLE);
	}

	if (m_pTable[dwIndex].Entry.pAsyncOp)
	{
		m_pTable[dwIndex].Entry.pAsyncOp->Release();
		m_pTable[dwIndex].Entry.pAsyncOp = NULL;
	}

	m_pTable[dwIndex].Entry.pAsyncOp = pAsyncOp;
	if (pAsyncOp)
	{
		pAsyncOp->Lock();
		pAsyncOp->SetHandle( handle );
		pAsyncOp->Unlock();
	}

	Unlock();

	return(DPN_OK);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Find"

HRESULT CHandleTable::Find( const DPNHANDLE handle,
						    CAsyncOp **const ppAsyncOp )
{
	DWORD	dwIndex;

//	DNASSERT(handle != 0);
	DNASSERT(ppAsyncOp != NULL);

	DNASSERT(m_dwFlags & HANDLETABLE_FLAG_INITIALIZED);

	dwIndex = DECODE_HANDLETABLE_INDEX( handle );

	if ((dwIndex == 0) || (dwIndex >= m_dwNumEntries))
	{
		return(DPNERR_INVALIDHANDLE);
	}

	Lock();

/*
	if (!VERIFY_HANDLETABLE_VERSION(handle,m_pTable[dwIndex].dwVersion))
*/
	if ((m_pTable[dwIndex].dwVersion == 0)
			|| !VERIFY_HANDLETABLE_VERSION(handle,m_pTable[dwIndex].dwVersion)
			|| (m_pTable[dwIndex].Entry.pAsyncOp == NULL))
	{
		Unlock();
		return(DPNERR_INVALIDHANDLE);
	}

	m_pTable[dwIndex].Entry.pAsyncOp->AddRef();
	*ppAsyncOp = m_pTable[dwIndex].Entry.pAsyncOp;

	Unlock();

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CHandleTable::Enum"

HRESULT CHandleTable::Enum( DPNHANDLE *const rgHandles,
							DWORD *const cHandles )
{
	DWORD		dw;
	HRESULT		hResultCode;
	DPNHANDLE	*p;

	DNASSERT(cHandles != NULL);
	DNASSERT(rgHandles != NULL || *cHandles == 0);

	DNASSERT(m_dwFlags & HANDLETABLE_FLAG_INITIALIZED);

	Lock();

	if (*cHandles < (m_dwNumEntries - m_dwNumFreeEntries))
	{
		hResultCode = DPNERR_BUFFERTOOSMALL;
	}
	else
	{
		p = rgHandles;
		for (dw = 0 ; dw < m_dwNumEntries ; dw++)
		{
			if (m_pTable[dw].dwVersion != 0)
			{
				DNASSERT(m_pTable[dw].Entry.pAsyncOp != NULL);

				*p = CONSTRUCT_DPNHANDLE(dw,m_pTable[dw].dwVersion);
				p++;
			}
		}
		hResultCode = DPN_OK;
	}

	*cHandles = (m_dwNumEntries - m_dwNumFreeEntries);

	Unlock();

	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\memoryfpm.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryFPM.cpp
 *  Content:	Memory Block FPM
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/31/00	mjn		Created
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// MemoryBlockAlloc
//
// Entry:		DWORD dwSize
//
// Exit:		PVOID		NULL or pointer to memory block
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "MemoryBlockAlloc"

PVOID MemoryBlockAlloc(void *const pvContext,
					   const DWORD dwSize )
{
	DIRECTNETOBJECT		*pdnObject;
	CMemoryBlockTiny	*pMBTiny;
	CMemoryBlockSmall	*pMBSmall;
	CMemoryBlockMedium	*pMBMedium;
	CMemoryBlockLarge	*pMBLarge;
	CMemoryBlockHuge	*pMBHuge;
	DN_MEMORY_BLOCK_HEADER	*pMBHeader;
	PVOID				pv;

	DPF(8,"Parameters: pvContext [0x%p], dwSize [%ld]",pvContext,dwSize);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

	pv = NULL;
	if (dwSize <= DN_MEMORY_BLOCK_SIZE_TINY)
	{
		pMBTiny = pdnObject->m_pFPOOLMemoryBlockTiny->Get(pdnObject->m_pFPOOLMemoryBlockTiny);
		DPF(9,"Got TINY at [0x%p]",pMBTiny);
		if (pMBTiny != NULL)
			pv = pMBTiny->GetBuffer();
	}
	else if (dwSize <= DN_MEMORY_BLOCK_SIZE_SMALL)
	{
		pMBSmall = pdnObject->m_pFPOOLMemoryBlockSmall->Get(pdnObject->m_pFPOOLMemoryBlockSmall);
		DPF(9,"Got SMALL at [0x%p]",pMBSmall);
		if (pMBSmall != NULL)
			pv = pMBSmall->GetBuffer();
	}
	else if (dwSize <= DN_MEMORY_BLOCK_SIZE_MEDIUM)
	{
		pMBMedium = pdnObject->m_pFPOOLMemoryBlockMedium->Get(pdnObject->m_pFPOOLMemoryBlockMedium);
		DPF(9,"Got MEDIUM at [0x%p]",pMBMedium);
		if (pMBMedium != NULL)
			pv = pMBMedium->GetBuffer();
	}
	else if (dwSize <= DN_MEMORY_BLOCK_SIZE_LARGE)
	{
		pMBLarge = pdnObject->m_pFPOOLMemoryBlockLarge->Get(pdnObject->m_pFPOOLMemoryBlockLarge);
		DPF(9,"Got LARGE at [0x%p]",pMBLarge);
		if (pMBLarge != NULL)
			pv = pMBLarge->GetBuffer();
	}
	else if (dwSize <= DN_MEMORY_BLOCK_SIZE_HUGE)
	{
		pMBHuge = pdnObject->m_pFPOOLMemoryBlockHuge->Get(pdnObject->m_pFPOOLMemoryBlockHuge);
		DPF(9,"Got HUGE at [0x%p]",pMBHuge);
		if (pMBHuge != NULL)
			pv = pMBHuge->GetBuffer();
	}
	else
	{
		pMBHeader = static_cast<DN_MEMORY_BLOCK_HEADER*>(DNMalloc( dwSize + sizeof( DN_MEMORY_BLOCK_HEADER ) ));
		if (pMBHeader != NULL)
		{
			pMBHeader->dwSize = DN_MEMORY_BLOCK_SIZE_CUSTOM;
			pMBHeader->FixedPoolPlaceHolder = NULL;
			pv = pMBHeader + 1;
		}
		DPF(9,"malloc odd size at [0x%p]",pMBHeader);
	}

	DPF(8,"Returning: [0x%p]",pv);
	return(pv);
}


//**********************************************************************
// ------------------------------
// MemoryBlockFree
//
// Entry:		PVOID	pvMemoryBlock
//
// Exit:		Nothing
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "MemoryBlockFree"

void MemoryBlockFree(void *const pvContext,
					 void *const pvMemoryBlock)
{
	CMemoryBlockTiny	*pMBTiny;
	CMemoryBlockSmall	*pMBSmall;
	CMemoryBlockMedium	*pMBMedium;
	CMemoryBlockLarge	*pMBLarge;
	CMemoryBlockHuge	*pMBHuge;
	DN_MEMORY_BLOCK_HEADER	*pMBHeader;

	DPF(8,"Parameters: pvContext [0x%p], pvMemoryBlock [0x%p]",
			pvContext,pvMemoryBlock);

	pMBTiny = CMemoryBlockTiny::GetObjectFromBuffer(pvMemoryBlock);
	if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_TINY)
	{
		pMBTiny->ReturnSelfToPool();
	}
	else if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_SMALL)
	{
		pMBSmall = reinterpret_cast<CMemoryBlockSmall*>(pMBTiny);
		pMBSmall->ReturnSelfToPool();
	}
	else if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_MEDIUM)
	{
		pMBMedium = reinterpret_cast<CMemoryBlockMedium*>(pMBTiny);
		pMBMedium->ReturnSelfToPool();
	}
	else if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_LARGE)
	{
		pMBLarge = reinterpret_cast<CMemoryBlockLarge*>(pMBTiny);
		pMBLarge->ReturnSelfToPool();
	}
	else if (pMBTiny->GetSize() == DN_MEMORY_BLOCK_SIZE_HUGE)
	{
		pMBHuge = reinterpret_cast<CMemoryBlockHuge*>(pMBTiny);
		pMBHuge->ReturnSelfToPool();
	}
	else
	{
		pMBHeader = reinterpret_cast<DN_MEMORY_BLOCK_HEADER*>(pMBTiny);
		DNFree(pMBHeader);
	}

	DPF(8,"Returning: (nothing)");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\handles.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Handles.cpp
 *  Content:    Handle manager
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/19/99	mjn		Created
 *	03/23/00	mjn		Revised to ensure 64-bit compliance
 *	03/24/00	mjn		Added H_Enum
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *
 ***************************************************************************/



#include "dncorei.h"


#define	INC_SERIAL_COUNT(a)		if (++((a)->dwSerial) == 0)	((a)->dwSerial)++
#define	INDEX_MASK				0x000fffff
#define	SERIAL_MASK				0xfff00000
#define SERIAL_SHIFT				20
#define	GET_INDEX(h)			(h & INDEX_MASK)
#define	GET_SERIAL(h)			((h & SERIAL_MASK) >> SERIAL_SHIFT)
#define	MAKE_HANDLE(i,s)		((i & INDEX_MASK) | ((s << SERIAL_SHIFT) & SERIAL_MASK))
#define	VERIFY_HANDLE(p,h)		(((h & INDEX_MASK) < (p)->dwNumHandles) && ((p)->HandleArray[(h & INDEX_MASK)].dwSerial) && ((h & SERIAL_MASK) == ((p)->HandleArray[(h & INDEX_MASK)].dwSerial << SERIAL_SHIFT)))


#undef DPF_MODNAME
#define DPF_MODNAME "H_Grow"

HRESULT H_Grow(HANDLESTRUCT *const phs,
			   const DWORD dwIncSize)
{
	HRESULT		hResultCode = S_OK;
	DWORD		dw;

	DPF(9,"Parameters: phs [0x%p], dwIncSize [%ld]",phs,dwIncSize);

	if (dwIncSize == 0)
	{
		DPFERR("Must grow handles by at least 1");
		return(E_INVALIDARG);
	}

	// Grab CS
	DNEnterCriticalSection(&phs->dncs);

	if (phs->HandleArray == NULL || phs->dwNumHandles == 0)
	{
		if ((phs->HandleArray = static_cast<HANDLEELEMENT*>(DNMalloc((dwIncSize + phs->dwNumHandles) * sizeof(HANDLEELEMENT)))) == NULL)
		{
			DPFERR("Could not create handle array");
			hResultCode = E_OUTOFMEMORY;
			goto EXIT_H_Grow;
		}
	}
	else
	{
		if ((phs->HandleArray = static_cast<HANDLEELEMENT*>(DNRealloc(phs->HandleArray,(dwIncSize + phs->dwNumHandles) * sizeof(HANDLEELEMENT)))) == NULL)
		{
			DPFERR("Could not grow handle array");
			hResultCode = E_OUTOFMEMORY;
			goto EXIT_H_Grow;
		}
	}

	// Update Handle Structure
	phs->dwFirstFreeHandle = phs->dwNumHandles;
	phs->dwLastFreeHandle = phs->dwNumHandles + dwIncSize - 1;
	phs->dwNumFreeHandles = dwIncSize;
	phs->dwNumHandles += dwIncSize;

	// Setup free Handle Elements
	for (dw = 0 ; dw < dwIncSize - 1 ; dw++)
	{
		phs->HandleArray[phs->dwFirstFreeHandle + dw].dwSerial = 0;
		phs->HandleArray[phs->dwFirstFreeHandle + dw].Entry.dwIndex = phs->dwFirstFreeHandle + dw + 1;
	}
	phs->HandleArray[phs->dwFirstFreeHandle + dw].dwSerial = 0;
	phs->HandleArray[phs->dwFirstFreeHandle + dw].Entry.pvData = NULL;

EXIT_H_Grow:

	// Release CS
	DNLeaveCriticalSection(&phs->dncs);

	DPF(9,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "H_Initialize"

HRESULT	H_Initialize(HANDLESTRUCT *const phs,
					 const DWORD dwInitialNum)
{
	HRESULT		hResultCode = S_OK;

	DPF(9,"Parameters: phs [0x%p], dwInitialNum [%ld]",phs,dwInitialNum);

	if (dwInitialNum == 0)
	{
		DPFERR("Must initialize handles with at least 1");
		return(E_INVALIDARG);
	}

	if (!DNInitializeCriticalSection(&phs->dncs))
	{
		DPFERR("DNInitializeCriticalSection() failed");
		return(E_OUTOFMEMORY);
	}

	// Lock
	DNEnterCriticalSection(&phs->dncs);

	phs->HandleArray = NULL;
	phs->dwNumHandles = 0;
	phs->dwNumFreeHandles = 0;
	phs->dwFirstFreeHandle = 0;
	phs->dwLastFreeHandle = 0;
	phs->dwSerial = 1;

	if ((hResultCode = H_Grow(phs,dwInitialNum)) != S_OK)
	{
		DPFERR("H_Grow() failed");
		goto EXIT_H_Initialize;
	}

EXIT_H_Initialize:

	// Unlock
	DNLeaveCriticalSection(&phs->dncs);

	DPF(9,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "H_Terminate"

void H_Terminate(HANDLESTRUCT *const phs)
{
	DPF(9,"Parameters: phs [0x%p]",phs);

	if (phs->HandleArray != NULL)
		DNFree(phs->HandleArray);

	phs->dwNumHandles = 0;

	DNDeleteCriticalSection(&phs->dncs);

	DPF(9,"Returning");
}


#undef DPF_MODNAME
#define DPF_MODNAME "H_Create"

HRESULT H_Create(HANDLESTRUCT *const phs,
				 void *const pvData,
				 DWORD *const pHandle)
{
	DWORD	dwIndex;
	HRESULT	hResultCode = S_OK;

	DPF(9,"Parameters: phs [0x%p], pvData [0x%p], pHandle [0x%p]",phs,pvData,pHandle);

	if (pHandle == NULL)
	{
		DPFERR("Invalid handle pointer");
		return(E_INVALIDARG);
	}

	// Lock
	DNEnterCriticalSection(&phs->dncs);

	// If there are no free handles, double the handle array
	if (phs->dwNumFreeHandles == 0)
	{
		if ((hResultCode = H_Grow(phs,phs->dwNumHandles)) != S_OK)	// Double the size
		{
			DPFERR("H_Grow() failed");
			goto EXIT_H_Create;
		}
	}

	// Update internal handle pointers
	dwIndex = phs->dwFirstFreeHandle;
	phs->dwFirstFreeHandle = phs->HandleArray[dwIndex].Entry.dwIndex;
	phs->dwNumFreeHandles--;

	do
	{
		// Update handle information
		INC_SERIAL_COUNT(phs);
		phs->HandleArray[dwIndex].dwSerial = phs->dwSerial;
		phs->HandleArray[dwIndex].Entry.pvData = pvData;

		// Create user's handle
		*pHandle = MAKE_HANDLE(dwIndex,phs->dwSerial);
	} while (*pHandle == 0);		// Don't want 0 handle

	DPF(9,"Returning: *pHandle = [0x%lx]",*pHandle);

EXIT_H_Create:

	// Unlock
	DNLeaveCriticalSection(&phs->dncs);

	DPF(9,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "H_Destroy"

HRESULT	H_Destroy(HANDLESTRUCT *const phs,
				  const DWORD handle)
{
	DWORD	dwIndex;
	DWORD	dwSerial;
	HRESULT	hResultCode = S_OK;

	DPF(9,"Parameters: phs [0x%p], handle [0x%lx]",phs,handle);

	// Lock
	DNEnterCriticalSection(&phs->dncs);

	// Ensure valid handle supplied
	if (!VERIFY_HANDLE(phs,handle))
	{
		DPFERR("Invalid handle");
		hResultCode = E_INVALIDARG;
		goto EXIT_H_Destroy;
	}

	dwIndex = GET_INDEX(handle);
	dwSerial = GET_SERIAL(handle);

	// Add handle to end of free list
	if (phs->dwNumFreeHandles == 0)		// Only free handle
	{
		phs->dwFirstFreeHandle = phs->dwLastFreeHandle = dwIndex;
	}
	else									// Other handles, so add to end of list
	{
		phs->HandleArray[phs->dwLastFreeHandle].Entry.dwIndex = dwIndex;
		phs->dwLastFreeHandle = dwIndex;
	}

	// Clear out returned handle
	phs->HandleArray[dwIndex].dwSerial = 0;
	phs->HandleArray[dwIndex].Entry.pvData = NULL;

	// Update handle structure
	INC_SERIAL_COUNT(phs);
	phs->dwNumFreeHandles++;

EXIT_H_Destroy:

	// Unlock
	DNLeaveCriticalSection(&phs->dncs);

	DPF(9,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "H_Retrieve"

HRESULT H_Retrieve(HANDLESTRUCT *const phs,
				   const DWORD handle,
				   void **const ppvData)
{
	DWORD		dwIndex;
	DWORD		dwSerial;
	HRESULT		hResultCode = S_OK;

	DPF(9,"Parameters: phs [0x%p], handle [0x%lx], ppvData [0x%p]",phs,handle,ppvData);

	// Lock
	DNEnterCriticalSection(&phs->dncs);

	// Ensure valid handle supplied
	if (!VERIFY_HANDLE(phs,handle))
	{
//		DPFERR("Invalid handle");
		hResultCode = E_INVALIDARG;
		goto EXIT_H_Retrieve;
	}

	if (ppvData == NULL)
	{
		DPFERR("Invalid data return pointer");
		hResultCode = E_INVALIDARG;
		goto EXIT_H_Retrieve;
	}

	dwIndex = GET_INDEX(handle);
	dwSerial = GET_SERIAL(handle);

	*ppvData = phs->HandleArray[GET_INDEX(handle)].Entry.pvData;
	DPF(9,"Returning: *ppvData = [0x%p]",*ppvData);

EXIT_H_Retrieve:

	// Unlock
	DNLeaveCriticalSection(&phs->dncs);

	DPF(9,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "H_Enum"

HRESULT H_Enum(HANDLESTRUCT *const phs,
			   DWORD *const pdwNumHandles,
			   DWORD *const rgHandles)
{
	HRESULT		hResultCode;
	DWORD		dw;
	DWORD		dwNumHandles;
	DWORD		*pHandle;

	DPF(3,"Parameters: phs [0x%p], pdwNumHandles [0x%p], rgHandles [0x%p]",
			phs,pdwNumHandles,rgHandles);

	DNASSERT(phs != NULL);
	DNASSERT(pdwNumHandles != NULL);
	DNASSERT(rgHandles != NULL || *pdwNumHandles == 0);

	hResultCode = S_OK;
	dwNumHandles = 0;
	DNEnterCriticalSection(&phs->dncs);
	for (dw = 0 ; dw < phs->dwNumHandles ; dw++)
	{
		if (phs->HandleArray[dw].dwSerial != NULL)
		{
			DPF(5,"Found handle data at [%ld]",dw);
			dwNumHandles++;
		}
	}

	if (dwNumHandles)
	{
		if (dwNumHandles <= *pdwNumHandles)
		{
			pHandle = rgHandles;
			for (dw = 0 ; dw < phs->dwNumHandles ; dw++)
			{
				if (phs->HandleArray[dw].dwSerial != NULL)
				{
					*pHandle++ = MAKE_HANDLE(dw,phs->HandleArray[dw].dwSerial);
				}
			}
		}
		else
		{
			hResultCode = E_POINTER;
		}
	}
	*pdwNumHandles = dwNumHandles;

	DNLeaveCriticalSection(&phs->dncs);

	DPF(3,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\handletable.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HandleTable.h
 *  Content:    Handle Table Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/08/00	mjn		Created
 *	04/16/00	mjn		Added Update() and allow NULL data for Handles
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__HANDLETABLE_H__
#define	__HANDLETABLE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	HANDLETABLE_FLAG_INITIALIZED		0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for Handle Table

class CHandleTable
{
	STDNEWDELETE

public:
	CHandleTable()			// Constructor
		{
			m_dwFlags = 0;
		};

	~CHandleTable() { };	// Destructor

	HRESULT CHandleTable::Initialize( void );

	void CHandleTable::Deinitialize( void );

	void Lock( void )
		{
			DNEnterCriticalSection(&m_cs);
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection(&m_cs);
		};

	HRESULT CHandleTable::GrowTable( void );

	HRESULT CHandleTable::Create( CAsyncOp *const pAsyncOp,
								  DPNHANDLE *const pHandle );

	HRESULT CHandleTable::Destroy( const DPNHANDLE handle );

	HRESULT CHandleTable::Update( const DPNHANDLE handle,
								  CAsyncOp *const pAsyncOp );

	HRESULT CHandleTable::Find( const DPNHANDLE handle,
								CAsyncOp **const ppAsyncOp );

	HRESULT CHandleTable::Enum( DPNHANDLE *const rgHandles,
								DWORD *const cHandle );

private:
	DWORD	volatile	m_dwFlags;

	DWORD	volatile	m_dwNumEntries;
	DWORD	volatile	m_dwNumFreeEntries;
	DWORD	volatile	m_dwFirstFreeEntry;
	DWORD	volatile	m_dwLastFreeEntry;

	DWORD	volatile	m_dwVersion;

	HANDLETABLE_ARRAY_ENTRY	*m_pTable;

	DNCRITICAL_SECTION		m_cs;
};

#endif	// __HANDLETABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\memoryfpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryFPM.h
 *  Content:	Memory Block FPM
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/31/00	mjn		Created
 ***************************************************************************/

#ifndef __MEMORYFPM_H__
#define __MEMORYFPM_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_MEMORY_BLOCK_SIZE_CUSTOM		0

#define	DN_MEMORY_BLOCK_SIZE_TINY		128
#define	DN_MEMORY_BLOCK_SIZE_SMALL		256
#define	DN_MEMORY_BLOCK_SIZE_MEDIUM		512
#define	DN_MEMORY_BLOCK_SIZE_LARGE		1024
#define	DN_MEMORY_BLOCK_SIZE_HUGE		2048
/*
#define	DN_MEMORY_BLOCK_SIZE_TINY		1
#define	DN_MEMORY_BLOCK_SIZE_SMALL		2
#define	DN_MEMORY_BLOCK_SIZE_MEDIUM		4
#define	DN_MEMORY_BLOCK_SIZE_LARGE		8
#define	DN_MEMORY_BLOCK_SIZE_HUGE		16
*/
//**********************************************************************
// Macro definitions
//**********************************************************************

#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CMemoryBlockTiny > class CLockedContextClassFixedPool;
template< class CMemoryBlockSmall > class CLockedContextClassFixedPool;
template< class CMemoryBlockMedium > class CLockedContextClassFixedPool;
template< class CMemoryBlockLarge > class CLockedContextClassFixedPool;
template< class CMemoryBlockHuge > class CLockedContextClassFixedPool;

typedef struct _DN_MEMORY_BLOCK_HEADER
{
	DWORD	dwSize;
	void*	FixedPoolPlaceHolder;
} DN_MEMORY_BLOCK_HEADER;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

PVOID MemoryBlockAlloc(void *const pvContext,const DWORD dwSize);
void MemoryBlockFree(void *const pvContext,void *const pvMemoryBlock);

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for TINY memory block

class CMemoryBlockTiny
{
	STDNEWDELETE

public:
	CMemoryBlockTiny()		// Constructor
		{
			m_dwSize = DN_MEMORY_BLOCK_SIZE_TINY;
		};

	~CMemoryBlockTiny() { };		// Destructor

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockTiny::FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			DNASSERT(pvContext != NULL);
			m_pFPOOL = static_cast<CLockedContextClassFixedPool<CMemoryBlockTiny>*>(pvContext);
			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockTiny::FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
			DNASSERT(m_pFPOOL != NULL);
			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
		};

	DWORD GetSize(void)
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockTiny::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			DNASSERT(m_pFPOOL != NULL);
			m_pFPOOL->Release( this );
		};

	static CMemoryBlockTiny *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockTiny*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockTiny, m_pBuffer ) ] ) );
		};

private:
	DWORD	m_dwSize;
	CLockedContextClassFixedPool<CMemoryBlockTiny>	*m_pFPOOL;
	BYTE	m_pBuffer[DN_MEMORY_BLOCK_SIZE_TINY];
};


// class for SMALL memory block

class CMemoryBlockSmall
{
	STDNEWDELETE

public:
	CMemoryBlockSmall()		// Constructor
	{
		m_dwSize = DN_MEMORY_BLOCK_SIZE_SMALL;
	};

	~CMemoryBlockSmall() { };		// Destructor

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockSmall::FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			DNASSERT(pvContext != NULL);
			m_pFPOOL = static_cast<CLockedContextClassFixedPool<CMemoryBlockSmall>*>(pvContext);
			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockSmall::FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
			DNASSERT(m_pFPOOL != NULL);
			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
		};

	DWORD GetSize(void)
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockSmall::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			DNASSERT(m_pFPOOL != NULL);
			m_pFPOOL->Release( this );
		};

	static CMemoryBlockSmall *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockSmall*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockSmall, m_pBuffer ) ] ) );
		};

private:
	DWORD	m_dwSize;
	CLockedContextClassFixedPool<CMemoryBlockSmall>	*m_pFPOOL;
	BYTE	m_pBuffer[DN_MEMORY_BLOCK_SIZE_SMALL];	
};


// class for MEDIUM memory block

class CMemoryBlockMedium
{
	STDNEWDELETE

public:
	CMemoryBlockMedium()		// Constructor
	{
		m_dwSize = DN_MEMORY_BLOCK_SIZE_MEDIUM;
	};

	~CMemoryBlockMedium() { };		// Destructor

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockMedium::FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			DNASSERT(pvContext != NULL);
			m_pFPOOL = static_cast<CLockedContextClassFixedPool<CMemoryBlockMedium>*>(pvContext);
			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockMedium::FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
			DNASSERT(m_pFPOOL != NULL);
			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
		};

	DWORD GetSize(void)
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockMedium::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			DNASSERT(m_pFPOOL != NULL);
			m_pFPOOL->Release( this );
		};

	static CMemoryBlockMedium *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockMedium*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockMedium, m_pBuffer ) ] ) );
		};

private:
	DWORD	m_dwSize;
	CLockedContextClassFixedPool<CMemoryBlockMedium>	*m_pFPOOL;
	BYTE	m_pBuffer[DN_MEMORY_BLOCK_SIZE_MEDIUM];	
};


// class for LARGE memory block

class CMemoryBlockLarge
{
	STDNEWDELETE

public:
	CMemoryBlockLarge()		// Constructor
	{
		m_dwSize = DN_MEMORY_BLOCK_SIZE_LARGE;
	};

	~CMemoryBlockLarge() { };		// Destructor

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockLarge::FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			DNASSERT(pvContext != NULL);
			m_pFPOOL = static_cast<CLockedContextClassFixedPool<CMemoryBlockLarge>*>(pvContext);
			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockLarge::FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
			DNASSERT(m_pFPOOL != NULL);
			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
		};

	DWORD GetSize(void)
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockLarge::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			DNASSERT(m_pFPOOL != NULL);
			m_pFPOOL->Release( this );
		};

	static CMemoryBlockLarge *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockLarge*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockLarge, m_pBuffer ) ] ) );
		};

private:
	DWORD	m_dwSize;
	CLockedContextClassFixedPool<CMemoryBlockLarge>	*m_pFPOOL;
	BYTE	m_pBuffer[DN_MEMORY_BLOCK_SIZE_LARGE];	
};


// class for HUGE memory block

class CMemoryBlockHuge
{
	STDNEWDELETE

public:
	CMemoryBlockHuge()		// Constructor
	{
		m_dwSize = DN_MEMORY_BLOCK_SIZE_HUGE;
	};

	~CMemoryBlockHuge() { };		// Destructor

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockHuge::FPMAlloc"
	BOOL FPMAlloc( void *const pvContext )
		{
			DNASSERT(pvContext != NULL);
			m_pFPOOL = static_cast<CLockedContextClassFixedPool<CMemoryBlockHuge>*>(pvContext);
			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockHuge::FPMInitialize"
	BOOL FPMInitialize( void *const pvContext )
		{
			DNASSERT(m_pFPOOL != NULL);
			return(TRUE);
		};

	void FPMRelease( void *const pvContext )
		{
		};

	void FPMDealloc( void *const pvContext )
		{
		};

	DWORD GetSize(void)
		{
			return(m_dwSize);
		};

	void * GetBuffer(void)
		{
			return( m_pBuffer );
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CMemoryBlockHuge::ReturnSelfToPool"
	void ReturnSelfToPool( void )
		{
			DNASSERT(m_pFPOOL != NULL);
			m_pFPOOL->Release( this );
		};

	static CMemoryBlockHuge *GetObjectFromBuffer( void *const pvBuffer )
		{
			return( reinterpret_cast<CMemoryBlockHuge*>( &reinterpret_cast<BYTE*>( pvBuffer )[ -OFFSETOF( CMemoryBlockHuge, m_pBuffer ) ] ) );
		};

private:
	DWORD	m_dwSize;
	CLockedContextClassFixedPool<CMemoryBlockHuge>	*m_pFPOOL;
	BYTE	m_pBuffer[DN_MEMORY_BLOCK_SIZE_HUGE];	
};


#undef DPF_MODNAME

#endif	// __MEMORYFPM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\message.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Message.h
 *  Content:    DirectNet Internal Messages
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	01/14/00	mjn		Created
 *	01/20/00	mjn		Moved internal messages from DNCore.h
 *	01/24/00	mjn		Replaced on-wire message pointers to offsets
 *	01/24/00	mjn		Added messages for NameTable operation list clean-up
 *	01/25/00	mjn		Added DNSendHostMigrateCompleteMessage
 *	01/26/00	mjn		Implemented NameTable re-sync at host migration
 *	02/09/00	mjn		Implemented DNSEND_COMPLETEONPROCESS
 *	02/15/00	mjn		Added dwInfoFlags to UPDATE_INFO messages
 *	04/04/00	mjn		Added DNSendTerminateSession() and structure
 *	04/05/00	mjn		Modified DN_INTERNAL_MESSAGE_DESTROY_PLAYER
 *	04/23/00	mjn		Removed DN_INTERNAL_MESSAGE_SEND_PROCESSED and DN_INTERNAL_MESSAGE_SEND_PROCESSED_COMPLETE
 *				mjn		Added DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION and DN_INTERNAL_MESSAGE_PROCESS_COMPLETION
 *	04/25/00	mjn		Removed hCompletionOp from group/info REQUESTs
 *	07/12/00	mjn		Moved internal messages back from DNCore.h
 *	07/20/00	mjn		Changed SEND_PLAYER_INFO to PLAYER_CONNECT_INFO
 *				mjn		Added DN_INTERNAL_MESSAGE_CONNECT_INFO structure
 *				mjn		Modified DN_INTERNAL_MESSAGE_CONNECT_FAILED structure
 *				mjn		Moved DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO and DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED from connect.h
 *				mjn		Added DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED, DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED
 *	07/31/00	mjn		DN_INTERNAL_MESSAGE_DESTROY_PLAYER renamed to  DN_INTERNAL_MESSAGE_HOST_DESTROY_PLAYER
 *				mjn		DN_INTERNAL_MESSAGE_DELETE_PLAYER renamed to DN_INTERNAL_MESSAGE_DESTROY_PLAYER
 *				mjn		Added dwDestroyReason to DN_INTERNAL_MESSAGE_DESTROY_PLAYER
 *				mjn		Removed DN_MSG_INTERNAL_HOST_DESTROY_PLAYER and DN_INTERNAL_MESSAGE_HOST_DESTROY_PLAYER structure
 *	07/31/00	mjn		Change DN_MSG_INTERNAL_DELETE_PLAYER to DN_MSG_INTERNAL_DESTROY_PLAYER
 *	08/07/00	mjn		Added structures for peer-peer session integrity checking
 *	08/08/00	mjn		Moved DN_NAMETABLE_OP_INFO from Migration.cpp
 *	08/25/00	mjn		Added NameTable version to DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__MESSAGE_H__
#define	__MESSAGE_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_MSG_INTERNAL									0xc0
#define DN_MSG_INTERNAL_PLAYER_CONNECT_INFO				(0x01 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_SEND_CONNECT_INFO				(0x02 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_ACK_CONNECT_INFO				(0x03 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_SEND_PLAYER_DNID				(0x04 | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_CONNECT_FAILED					(0x05 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_INSTRUCT_CONNECT				(0x06 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED		(0x07 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_CONNECT_ATTEMPT_FAILED			(0x08 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_NAMETABLE_VERSION				(0x09 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_RESYNC_VERSION					(0x0a | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_NAMETABLE_OP				(0x0b | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_ACK_NAMETABLE_OP				(0x0c | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_HOST_MIGRATE					(0x0d | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE			(0x0e | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC			(0x0f | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_ADD_PLAYER						(0x10 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_DESTROY_PLAYER					(0x11 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_CREATE_GROUP				(0x12 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP			(0x13 | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP	(0x14 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_DESTROY_GROUP				(0x15 | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_REQ_UPDATE_INFO					(0x16 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_CREATE_GROUP					(0x17 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_DESTROY_GROUP					(0x18 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP				(0x19 | DN_MSG_INTERNAL)
#define DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP		(0x1a | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_UPDATE_INFO						(0x1b | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_VOICE_SEND						(0x1c | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_BUFFER_IN_USE					(0x1d | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQUEST_FAILED					(0x1e | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_TERMINATE_SESSION				(0x1f | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION			(0x20 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_PROCESS_COMPLETION				(0x21 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK				(0x22 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_INTEGRITY_CHECK					(0x23 | DN_MSG_INTERNAL)
#define	DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE		(0x24 | DN_MSG_INTERNAL)

#define	DN_MSG_USER_SEND					0x02

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO {
	DWORD	dwFlags;
	DWORD	dwDNETVersion;
	DWORD	dwNameOffset;
	DWORD	dwNameSize;
	DWORD	dwDataOffset;
	DWORD	dwDataSize;
	DWORD	dwPasswordOffset;
	DWORD	dwPasswordSize;
	DWORD	dwConnectDataOffset;
	DWORD	dwConnectDataSize;
	DWORD	dwURLOffset;
	DWORD	dwURLSize;
	GUID	guidInstance;
	GUID	guidApplication;
} DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO, *PDN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO;


typedef struct _DN_INTERNAL_MESSAGE_CONNECT_INFO {
	DWORD	dwReplyOffset;
	DWORD	dwReplySize;
} DN_INTERNAL_MESSAGE_CONNECT_INFO, *PDN_INTERNAL_MESSAGE_CONNECT_INFO;


typedef struct _DN_INTERNAL_MESSAGE_CONNECT_FAILED {
	HRESULT	hResultCode;
	DWORD	dwReplyOffset;
	DWORD	dwReplySize;
} DN_INTERNAL_MESSAGE_CONNECT_FAILED, *PDN_INTERNAL_MESSAGE_CONNECT_FAILED;


typedef struct _DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT {
	DPNID	dpnid;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
} DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT, *PDN_INTERNAL_MESSAGE_INSTRUCT_CONNECT;


typedef struct _DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED {
	DPNID	dpnid;
} DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED;


typedef struct _DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED {
	DPNID	dpnid;
} DN_INTERNAL_MESSAGE_CONNECT_ATTEMPT_FAILED;


typedef struct _DN_INTERNAL_MESSAGE_REQUEST_FAILED {
	DPNHANDLE	hCompletionOp;
	HRESULT		hResultCode;
} DN_INTERNAL_MESSAGE_REQUEST_FAILED;


typedef struct _DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID {
	DPNID	dpnid;
} DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID, *PDN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID;


typedef struct _DN_INTERNAL_MESSAGE_SEND_NAMETABLE {
	DWORD	dwNumEntries;		// Number of entries being passed
	DPNID	dpnidNewPlayer;		// DPNID of new player
} DN_INTERNAL_MESSAGE_SEND_NAMETABLE, *PDN_INTERNAL_MESSAGE_SEND_NAMETABLE;


typedef struct _DN_INTERNAL_MESSAGE_DESTROY_PLAYER {
	DPNID	dpnidLeaving;		// DPNID of leaving player
	DWORD	dwVersion;			// Name table version of this operation
	DWORD	dwVersionNotUsed;
	DWORD	dwDestroyReason;
} DN_INTERNAL_MESSAGE_DESTROY_PLAYER, *PDN_INTERNAL_MESSAGE_DESTROY_PLAYER;


typedef struct _DN_INTERNAL_MESSAGE_CREATE_GROUP {
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_CREATE_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_DESTROY_GROUP {
	DPNID		dpnidGroup;
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_DESTROY_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_ACK_HOST_REQUEST {
	DWORD		dwMsgId;
	DPNHANDLE	hCompletionOp;
	HRESULT		hResultCode;
} DN_INTERNAL_MESSAGE_ACK_HOST_REQUEST, *PDN_INTERNAL_MESSAGE_ACK_HOST_REQUEST;


typedef struct _DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP {
	DPNID		dpnidGroup;
	DPNID		dpnidPlayer;
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP, *PDN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP {
	DPNID		dpnidGroup;
	DPNID		dpnidPlayer;
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP, *PDN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_UPDATE_INFO {
	DPNID		dpnid;
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
	DWORD		dwInfoFlags;
	DWORD		dwNameOffset;
	DWORD		dwNameSize;
	DWORD		dwDataOffset;
	DWORD		dwDataSize;
	DPNID		dpnidRequesting;
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_UPDATE_INFO, *PDN_INTERNAL_MESSAGE_UPDATE_INFO;


typedef struct _DN_INTERNAL_MESSAGE_HOST_MIGRATE {
	DPNID		dpnidOldHost;
	DPNID		dpnidNewHost;
} DN_INTERNAL_MESSAGE_HOST_MIGRATE, *PDN_INTERNAL_MESSAGE_HOST_MIGRATE;


typedef struct _DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP {
	DWORD		dwGroupFlags;
	DWORD		dwInfoFlags;
	DWORD		dwNameOffset;
	DWORD		dwNameSize;
	DWORD		dwDataOffset;
	DWORD		dwDataSize;
} DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP, *PDN_INTERNAL_MESSAGE_REQ_CREATE_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP {
	DPNID		dpnidGroup;
} DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP, *PDN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP {
	DPNID		dpnidGroup;
	DPNID		dpnidPlayer;
} DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP, *PDN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP {
	DPNID		dpnidGroup;
	DPNID		dpnidPlayer;
} DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP, *PDN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO {
	DPNID		dpnid;
	DWORD		dwInfoFlags;
	DWORD		dwNameOffset;
	DWORD		dwNameSize;
	DWORD		dwDataOffset;
	DWORD		dwDataSize;
} DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO, *PDN_INTERNAL_MESSAGE_REQ_UPDATE_INFO;

typedef struct _DN_INTERNAL_MESSAGE_NAMETABLE_VERSION {
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
} DN_INTERNAL_MESSAGE_NAMETABLE_VERSION, *PDN_INTERNAL_MESSAGE_NAMETABLE_VERSION;


typedef struct _DN_INTERNAL_MESSAGE_RESYNC_VERSION {
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
} DN_INTERNAL_MESSAGE_RESYNC_VERSION, *PDN_INTERNAL_MESSAGE_RESYNC_VERSION;


typedef struct _DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP {
	DWORD		dwVersion;
	DWORD		dwVersionNotUsed;
} DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP, *PDN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP;


typedef struct _DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP {
	DWORD		dwNumEntries;
} DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP, *PDN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP;


typedef struct _DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION {
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION;


typedef struct _DN_INTERNAL_MESSAGE_PROCESS_COMPLETION {
	DPNHANDLE	hCompletionOp;
} DN_INTERNAL_MESSAGE_PROCESS_COMPLETION;


typedef struct _DN_INTERNAL_MESSAGE_TERMINATE_SESSION {
	DWORD		dwTerminateDataOffset;
	DWORD		dwTerminateDataSize;
} DN_INTERNAL_MESSAGE_TERMINATE_SESSION, *PDN_INTERNAL_MESSAGE_TERMINATE_SESSION;


typedef struct _DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK {
	DPNID		dpnidTarget;
} DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK;


typedef struct _DN_INTERNAL_MESSAGE_INTEGRITY_CHECK {
	DPNID		dpnidRequesting;
} DN_INTERNAL_MESSAGE_INTEGRITY_CHECK;


typedef struct _DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE {
	DPNID		dpnidRequesting;
} DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE;


typedef struct _DN_NAMETABLE_OP_INFO {
	DWORD	dwMsgId;
	DWORD	dwOpOffset;
	DWORD	dwOpSize;
} DN_NAMETABLE_OP_INFO, *PDN_NAMETABLE_OP_INFO;


// DN_APPLICATION_DESC_INFO - used to pack / send info
//		Force byte alignment as this may go out on the wire
#pragma pack( push, 1 )

typedef	struct DPN_APPLICATION_DESC_INFO {
	DWORD	dwSize;
	DWORD	dwFlags;
	DWORD	dwMaxPlayers;
	DWORD	dwCurrentPlayers;
	DWORD	dwSessionNameOffset;
	DWORD	dwSessionNameSize;
	DWORD	dwPasswordOffset;
	DWORD	dwPasswordSize;
	DWORD	dwReservedDataOffset;
	DWORD	dwReservedDataSize;
	DWORD	dwApplicationReservedDataOffset;
	DWORD	dwApplicationReservedDataSize;
	GUID	guidInstance;
	GUID	guidApplication;
} DPN_APPLICATION_DESC_INFO;
#pragma pack( pop )


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************


#endif	// __MESSAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\nametable.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NameTable.cpp
 *  Content:    NameTable Object
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/11/00	mjn		Created
 *	04/09/00	mjn		Track outstanding connections in NameTable
 *	04/18/00	mjn		CConnection tracks connection status better
 *	04/19/00	mjn		PopulateConnection makes the ALL_PLAYERS link valid before posting ADD_PLAYER
 *	05/03/00	mjn		Implemented GetHostPlayerRef, GetLocalPlayerRef, GetAllPlayersGroupRef
 *	05/08/00	mjn		PopulateConnection() only sets the player's connection if it was previously NULL
 *	05/10/00	mjn		Release NameTableEntry lock during notifications in PopulateConnection()
 *	05/16/00	mjn		Ensure dpnidGroup is actually a group in IsMember()
 *				mjn		Better use of locks when clearing short-cut pointers
 *	05/25/00	mjn		Fixed infinite loop in UpdateTable()
 *	06/01/00	mjn		Added code to validate NameTable array
 *	06/02/00	mjn		Fixed logic in GrowNameTable() to handle case of existing free entries
 *	06/07/00	mjn		Fixed logic in UpdateTable() to adjust m_dwLastFreeEntry correctly
 *	06/22/00	mjn		UnpackNameTableInfo() returns local players DPNID
 *	06/29/00	mjn		64-bit build fixes (2)
 *	07/06/00	mjn		Fixed locking problem in CNameTable::MakeLocalPlayer,MakeHostPlayer,MakeAllPlayersGroup
 *	07/07/00	mjn		Fixed validation error in FindEntry()
 *	07/20/00	mjn		Cleaned up CConnection refcounts and added attempted disconnects
 *				mjn		Added ClearHostWithDPNID()
 *	07/21/00	mjn		Fixed DeletePlayer() to properly handle deleted unconnected players
 *	07/26/00	mjn		Moved initialization code from contructor to Initialize()
 *				mjn		Allow DPNID=0 for FindEntry(), but return DPNERR_DOESNOTEXIST
 *	07/30/00	mjn		Set reason codes for destroying players and groups
 *				mjn		Added hrReason to CNameTable::EmptyTable() and extended clean-up to include short-cut pointers
 *	08/02/00	mjn		Dequeue queued messages when propagating CREATE_PLAYER message
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *				mjn		AddPlayerToGroup() does a duplicate check
 *	08/07/00	mjn		Wait until player to be  added to groups before reducing outstanding connections in PopulateConnection()
 *	08/15/00	mjn		Keep group on CGroupConnection objects
 *				mjn		Clear pGroupConnection from CGroupMembership when removing players from groups
 *	08/23/00	mjn		Added CNameTableOp
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/05/00	mjn		Added m_dpnidMask
 *				mjn		Removed dwIndex from InsertEntry()
 *	09/06/00	mjn		Remove queued messages in EmptyTable() and DeletePlayer()
 *	09/14/00	mjn		Added missing pGroupMember->AddRef() in PopulateConnection()
 *	09/17/00	mjn		Split m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *				mjn		Changed AddPlayerToGroup and RemovePlayerFromGroup to use NameTableEntry params
 *	09/26/00	mjn		Assume NameTable locks are taken for AddMembership() and RemoveMembership()
 *				mjn		Attempt to disconnect client from Host in EmptyTable()
 *	09/28/00	mjn		Autodestruct groups in DeletePlayer()
 *	10/18/00	mjn		Reset m_lOutstandingConnections in UnpackNameTableInfo()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::Initialize"

HRESULT CNameTable::Initialize(DIRECTNETOBJECT *const pdnObject)
{
	m_pdnObject = NULL;
	m_dpnidMask = 0;
	m_pDefaultPlayer = NULL;
	m_pLocalPlayer = NULL;
	m_pHostPlayer = NULL;
	m_pAllPlayersGroup = NULL;
	m_NameTableArray = NULL;
	m_dwNameTableSize = 0;
	m_dwFirstFreeEntry = 0;
	m_dwLastFreeEntry = 0;
	m_dwNumFreeEntries = 0;
	m_dwVersion = 1;
	m_dwLatestVersion = 0;
	m_dwConnectVersion = 0;
	m_lOutstandingConnections = 0;
	m_bilinkPlayers.Initialize();
	m_bilinkGroups.Initialize();
	m_bilinkDeleted.Initialize();
	m_bilinkNameTableOps.Initialize();

	if (!DNInitializeCriticalSection(&m_csNameTable))
	{
		return(DPNERR_OUTOFMEMORY);
	}

	if (NameTableEntryNew(pdnObject,&m_pDefaultPlayer) != DPN_OK)
	{
		return(DPNERR_OUTOFMEMORY);
	}

	m_pdnObject = pdnObject;

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::Deinitialize"

void CNameTable::Deinitialize( void )
{
	if (m_NameTableArray)
	{
		DNFree(m_NameTableArray);
		m_NameTableArray = NULL;
	}

	m_pDefaultPlayer->Release();
	m_pDefaultPlayer = NULL;

	DNASSERT(m_bilinkPlayers.IsEmpty());
	DNASSERT(m_bilinkGroups.IsEmpty());
	DNASSERT(m_bilinkDeleted.IsEmpty());
	DNASSERT(m_bilinkNameTableOps.IsEmpty());

	DNASSERT(m_pDefaultPlayer == NULL);
	DNASSERT(m_pLocalPlayer == NULL);
	DNASSERT(m_pHostPlayer == NULL);
	DNASSERT(m_NameTableArray == NULL);

	DNDeleteCriticalSection(&m_csNameTable);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ValidateArray"

void CNameTable::ValidateArray( void )
{
#ifdef	DEBUG
	DWORD	dw;
	DWORD	dwFreeEntries;

	Lock();

	//
	//	Ensure free entry count is correct
	//
	dwFreeEntries = 0;
#ifdef	VANCEO
	for (dw = 2 ; dw < m_dwNameTableSize ; dw++)
#else
	for (dw = 1 ; dw < m_dwNameTableSize ; dw++)
#endif
	{
		if (!(m_NameTableArray[dw].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID))
		{
			dwFreeEntries++;
		}
	}
	if (dwFreeEntries != m_dwNumFreeEntries)
	{
		DPFERR("Incorrect number of free entries in NameTable");
		DNASSERT(FALSE);
	}

	//
	//	Ensure free list integrity
	//
	if (m_dwNumFreeEntries)
	{
		dwFreeEntries = 0;
		dw = m_dwFirstFreeEntry;
		do
		{
			if (m_NameTableArray[dw].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID)
			{
				DPFERR("Valid entry in NameTable array free list");
				DNASSERT(FALSE);
			}
			dwFreeEntries++;
			dw = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[dw].pNameTableEntry));
		} while (dw != 0);

		if (dwFreeEntries != m_dwNumFreeEntries)
		{
			DPFERR("Incorrect number of free entries in NameTable array free list");
			DNASSERT(FALSE);
		}
	}

	Unlock();
#endif
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::GrowNameTable"

HRESULT CNameTable::GrowNameTable( void )
{
	NAMETABLE_ARRAY_ENTRY *pNewArray;
	DWORD			dwNewSize;
	DWORD			dw;

	if (m_dwNameTableSize == 0)
	{
		dwNewSize = 2;
	}
	else
	{
		dwNewSize = m_dwNameTableSize * 2;
	}

	// Allocate new array
	pNewArray = static_cast<NAMETABLE_ARRAY_ENTRY*>(DNMalloc(sizeof(NAMETABLE_ARRAY_ENTRY) * dwNewSize));
	if (pNewArray == NULL)
	{
		return(DPNERR_OUTOFMEMORY);
	}

	// Copy old array to new array
	for (dw = 0 ; dw < m_dwNameTableSize ; dw++)
	{
		pNewArray[dw].pNameTableEntry = m_NameTableArray[dw].pNameTableEntry;
		pNewArray[dw].dwFlags = m_NameTableArray[dw].dwFlags;
	}

	//
	//	If the array is being grown because there are no free entries, then all of the new free
	//	entries will be in the new part of the array.  Otherwise, we will need to link the old
	//	free list to the new one
	//
	if (m_dwNumFreeEntries == 0)
	{
		// All free entries at end of new array
		m_dwFirstFreeEntry = m_dwNameTableSize;
	}
	else
	{
		// Only new free entries at end of new array
		pNewArray[m_dwLastFreeEntry].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(static_cast<DWORD_PTR>(m_dwNameTableSize));
	}
	m_dwLastFreeEntry = dwNewSize-1;

	// Very last FREE entry will not wrap to 0
	pNewArray[m_dwLastFreeEntry].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(0);
	pNewArray[m_dwLastFreeEntry].dwFlags = 0;

	// Link new FREE entries
	for (dw = m_dwNameTableSize ; dw < m_dwLastFreeEntry ; dw++)
	{
		pNewArray[dw].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(static_cast<DWORD_PTR>(dw+1));
		pNewArray[dw].dwFlags = 0;
	}

	// Update NameTable
	m_dwNumFreeEntries += (dwNewSize - m_dwNameTableSize);
	m_dwNameTableSize = dwNewSize;

	// New array
	if (m_NameTableArray)
	{
		DNFree(m_NameTableArray);
	}
	m_NameTableArray = pNewArray;

	// We will never allocate 0
	if (m_dwFirstFreeEntry == 0)
	{
		m_dwFirstFreeEntry = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[m_dwFirstFreeEntry].pNameTableEntry));
		m_dwNumFreeEntries--;
	}

#ifdef	VANCEO
	if (m_dwFirstFreeEntry == 1)
	{
		m_dwFirstFreeEntry = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[m_dwFirstFreeEntry].pNameTableEntry));
		m_dwNumFreeEntries--;
	}
#endif

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::UpdateTable"

HRESULT CNameTable::UpdateTable(const DWORD dwIndex,
								CNameTableEntry *const pNameTableEntry)
{
	BOOL	bFound;
	DWORD	dw;

	DNASSERT(dwIndex < m_dwNameTableSize);
	DNASSERT(!(m_NameTableArray[dwIndex].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID));

	if (m_dwFirstFreeEntry == dwIndex)
	{
		m_dwFirstFreeEntry = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[m_dwFirstFreeEntry].pNameTableEntry));
		bFound = TRUE;
	}
	else
	{
		bFound = FALSE;
		dw = m_dwFirstFreeEntry;
		while (!bFound && (dw != m_dwLastFreeEntry))
		{
			if (m_NameTableArray[dw].pNameTableEntry == reinterpret_cast<CNameTableEntry*>(dwIndex))
			{
				m_NameTableArray[dw].pNameTableEntry = m_NameTableArray[dwIndex].pNameTableEntry;
				if (m_dwLastFreeEntry == dwIndex)
				{
					m_dwLastFreeEntry = dw;
				}
				bFound = TRUE;
			}
			else
			{
				dw = static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(m_NameTableArray[dw].pNameTableEntry));
			}
		}
	}

	if (!bFound)
	{
		return(DPNERR_GENERIC);
	}

	pNameTableEntry->AddRef();
	m_NameTableArray[dwIndex].pNameTableEntry = pNameTableEntry;
	m_NameTableArray[dwIndex].dwFlags |= NAMETABLE_ARRAY_ENTRY_FLAG_VALID;

	//
	//	Insert into entry bilink
	//
	if (pNameTableEntry->IsGroup())
	{
		pNameTableEntry->m_bilinkEntries.InsertBefore(&m_bilinkGroups);
	}
	else
	{
		pNameTableEntry->m_bilinkEntries.InsertBefore(&m_bilinkPlayers);
	}

	m_dwNumFreeEntries--;

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::InsertEntry"

HRESULT CNameTable::InsertEntry(CNameTableEntry *const pNameTableEntry)
{
	HRESULT	hResultCode;
	DWORD	dwIndex;

	DNASSERT(pNameTableEntry != NULL);
	DNASSERT(pNameTableEntry->GetDPNID() != 0);

	dwIndex = DECODE_INDEX(pNameTableEntry->GetDPNID());

	Lock();

	while (dwIndex >= m_dwNameTableSize)
	{
		if (GrowNameTable() != DPN_OK)
		{
			Unlock();
			return(DPNERR_OUTOFMEMORY);
		}
	}

	if ((hResultCode = UpdateTable(dwIndex,pNameTableEntry)) != DPN_OK)
	{
		Unlock();
		return(DPNERR_GENERIC);
	}

	Unlock();

#ifdef	DEBUG
	ValidateArray();
#endif

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ReleaseEntry"

void CNameTable::ReleaseEntry(const DWORD dwIndex)
{
	CNameTableEntry	*pNTEntry;

	DNASSERT(dwIndex != 0);

	pNTEntry = m_NameTableArray[dwIndex].pNameTableEntry;
	m_NameTableArray[dwIndex].pNameTableEntry = NULL;
	pNTEntry->m_bilinkEntries.RemoveFromList();
	pNTEntry->Release();

	if (m_dwNumFreeEntries == 0)
	{
		m_dwFirstFreeEntry = dwIndex;
	}
	else
	{
		m_NameTableArray[m_dwLastFreeEntry].pNameTableEntry = reinterpret_cast<CNameTableEntry*>(dwIndex);
	}
	m_dwLastFreeEntry = dwIndex;
	m_NameTableArray[m_dwLastFreeEntry].dwFlags &= (~NAMETABLE_ARRAY_ENTRY_FLAG_VALID);
	m_dwNumFreeEntries++;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::EmptyTable"

void CNameTable::EmptyTable( const HRESULT hrReason )
{
	DWORD			dw;
	CNameTableEntry	*pNTEntry;
	DWORD			dwGroupReason;
	DWORD			dwPlayerReason;
	CBilink			*pBilink;
	CQueuedMsg		*pQueuedMsg;

	DPF(6,"Parameters: hrReason [0x%lx]",hrReason);

	DNASSERT( (hrReason == DPN_OK) || (hrReason == DPNERR_HOSTTERMINATEDSESSION) || (hrReason == DPNERR_CONNECTIONLOST));

	if (!(m_pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
	{
		//
		//	Determine destruction reason to pass to application
		//
		switch (hrReason)
		{
			case DPN_OK:
				{
					dwPlayerReason = DPNDESTROYPLAYERREASON_NORMAL;
					dwGroupReason = DPNDESTROYGROUPREASON_NORMAL;
					break;
				}
			case DPNERR_HOSTTERMINATEDSESSION:
				{
					dwPlayerReason = DPNDESTROYPLAYERREASON_SESSIONTERMINATED;
					dwGroupReason = DPNDESTROYGROUPREASON_SESSIONTERMINATED;
					break;
				}
			case DPNERR_CONNECTIONLOST:
				{
					dwPlayerReason = DPNDESTROYPLAYERREASON_CONNECTIONLOST;
					dwGroupReason = DPNDESTROYGROUPREASON_NORMAL;
					break;
				}
			default:
				{
					DNASSERT( FALSE );	// Should never get here !
					dwPlayerReason = DPNDESTROYPLAYERREASON_NORMAL;
					dwGroupReason = DPNDESTROYGROUPREASON_NORMAL;
					break;
				}
		}

		//
		//	To make VanceO happy, I've agreed to pre-mark the group destructions as NORMAL,
		//	rather than AUTODESTRUCT
		//
		Lock();
		pBilink = m_bilinkGroups.GetNext();
		while (pBilink != &m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( dwGroupReason );
			}
			pNTEntry->Unlock();
			pNTEntry = NULL;

			pBilink = pBilink->GetNext();
		}
		Unlock();

		for (dw = 0 ; dw < m_dwNameTableSize ; dw++)
		{
			pNTEntry = NULL;
			Lock();
			if ((m_NameTableArray[dw].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID) &&
				(m_NameTableArray[dw].pNameTableEntry))
			{
				//
				//	Cleanup this entry (if it's not disconnecting) and then release it
				//
				m_NameTableArray[dw].pNameTableEntry->Lock();
				if (!m_NameTableArray[dw].pNameTableEntry->IsDisconnecting())
				{
					m_NameTableArray[dw].pNameTableEntry->AddRef();
					pNTEntry = m_NameTableArray[dw].pNameTableEntry;
				}
				m_NameTableArray[dw].pNameTableEntry->Unlock();
				Unlock();

				if (pNTEntry)
				{
					//
					//	Set destroy reason if required
					//
					pNTEntry->Lock();
					if (pNTEntry->GetDestroyReason() == 0)
					{
						if (pNTEntry->IsGroup())
						{
							pNTEntry->SetDestroyReason( dwGroupReason );
						}
						else
						{
							pNTEntry->SetDestroyReason( dwPlayerReason );
						}
					}
					pNTEntry->Unlock();

					//
					//	Delete entry
					//
					if (pNTEntry->IsGroup())
					{
						if (!pNTEntry->IsAllPlayersGroup())
						{
							DeleteGroup(pNTEntry->GetDPNID(),NULL);
						}
					}
					else
					{
						CConnection	*pConnection;

						pConnection = NULL;

						pNTEntry->GetConnectionRef( &pConnection );
						if (pConnection)
						{
							pConnection->Disconnect();
							pConnection->Release();
							pConnection = NULL;
						}
						DeletePlayer(pNTEntry->GetDPNID(),NULL);
					}

					pNTEntry->Release();
					pNTEntry = NULL;
				}
			}
			else
			{
				Unlock();
			}
		}


		//
		//	Set reason for short-cut pointers (if required)
		//
		Lock();
		if (m_pLocalPlayer)
		{
			m_pLocalPlayer->Lock();
			if (m_pLocalPlayer->GetDestroyReason() == 0)
			{
				m_pLocalPlayer->SetDestroyReason( dwPlayerReason );
			}
			m_pLocalPlayer->Unlock();
		}
		if (m_pHostPlayer)
		{
			m_pHostPlayer->Lock();
			if (m_pHostPlayer->GetDestroyReason() == 0)
			{
				m_pHostPlayer->SetDestroyReason( dwPlayerReason );
			}
			m_pHostPlayer->Unlock();
		}
		if (m_pAllPlayersGroup)
		{
			m_pAllPlayersGroup->Lock();
			if (m_pAllPlayersGroup->GetDestroyReason() == 0)
			{
				m_pAllPlayersGroup->SetDestroyReason( dwGroupReason );
			}
			m_pAllPlayersGroup->Unlock();
		}
		Unlock();
	}
	else
	{
		//
		//	Disconnect from Host and remove any queued messages from Host player (on Client)
		//
		if (GetHostPlayerRef(&pNTEntry) == DPN_OK)
		{
			CConnection	*pConnection;

			pConnection = NULL;

			pNTEntry->GetConnectionRef( &pConnection );
			if (pConnection)
			{
				pConnection->Disconnect();
				pConnection->Release();
				pConnection = NULL;
			}

			pNTEntry->Lock();
			pBilink = pNTEntry->m_bilinkQueuedMsgs.GetNext();
			while (pBilink != &pNTEntry->m_bilinkQueuedMsgs)
			{
				pQueuedMsg = CONTAINING_OBJECT(pBilink,CQueuedMsg,m_bilinkQueuedMsgs);
				pQueuedMsg->m_bilinkQueuedMsgs.RemoveFromList();
				DEBUG_ONLY(pNTEntry->m_lNumQueuedMsgs--);

				pNTEntry->Unlock();
				
				DNASSERT(pQueuedMsg->GetAsyncOp() != NULL);
				DNASSERT(pQueuedMsg->GetAsyncOp()->GetHandle() != 0);

				m_pdnObject->HandleTable.Destroy( pQueuedMsg->GetAsyncOp()->GetHandle() );
				pQueuedMsg->GetAsyncOp()->Release();
				pQueuedMsg->SetAsyncOp( NULL );
				pQueuedMsg->ReturnSelfToPool();
				pQueuedMsg = NULL;

				pNTEntry->Lock();

				pBilink = pNTEntry->m_bilinkQueuedMsgs.GetNext();
			}
			pNTEntry->Unlock();
			pNTEntry->Release();
			pNTEntry = NULL;

			DNASSERT(pConnection == NULL);
		}
	}

	//
	//	Remove short-cut pointers
	//
	ClearLocalPlayer();
	ClearHostPlayer();
	ClearAllPlayersGroup();

	DPF(6,"Returning");
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::FindEntry"

HRESULT CNameTable::FindEntry(const DPNID dpnid,
							  CNameTableEntry **const ppNameTableEntry)
{
	DWORD	dwIndex;
	HRESULT	hResultCode;

	DPF(6,"Parameters: dpnid [0x%lx], ppNameTableEntry [0x%p]",dpnid,ppNameTableEntry);

	DNASSERT(ppNameTableEntry != NULL);

	if (dpnid == 0)
	{
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}

	Lock();
	dwIndex = DECODE_INDEX(dpnid);
	if ((dwIndex >= m_dwNameTableSize)
			|| !(m_NameTableArray[dwIndex].dwFlags & NAMETABLE_ARRAY_ENTRY_FLAG_VALID)
			|| (m_NameTableArray[dwIndex].pNameTableEntry == NULL))
	{
		Unlock();
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}

	if (!VERIFY_VERSION(dpnid,m_NameTableArray[dwIndex].pNameTableEntry->GetVersion()))
	{
		Unlock();
		hResultCode = DPNERR_DOESNOTEXIST;
		goto Failure;
	}

	m_NameTableArray[dwIndex].pNameTableEntry->AddRef();
	*ppNameTableEntry = m_NameTableArray[dwIndex].pNameTableEntry;

	Unlock();

	hResultCode = DPN_OK;

Exit:
	DPF(6,"hResultCode: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::FindDeletedEntry"

HRESULT	CNameTable::FindDeletedEntry(const DPNID dpnid,
									 CNameTableEntry **const ppNTEntry)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;

	DPF(6,"Parameters: dpnid [0x%lx], ppNTEntry [0x%p]",dpnid,ppNTEntry);

	DNASSERT(ppNTEntry != NULL);

	pNTEntry = NULL;
	hResultCode = DPNERR_DOESNOTEXIST;

	Lock();
	pBilink = m_bilinkDeleted.GetNext();
	while (pBilink != &m_bilinkDeleted)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkDeleted);
		if (pNTEntry->GetDPNID() == dpnid)
		{
			pNTEntry->AddRef();
			hResultCode = DPN_OK;
			break;
		}
		else
		{
			pBilink = pBilink->GetNext();
			pNTEntry = NULL;
		}
	}
	Unlock();

	if (pNTEntry)
	{
		pNTEntry->AddRef();
		*ppNTEntry = pNTEntry;
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::AddEntry"

HRESULT	CNameTable::AddEntry(CNameTableEntry *const pNTEntry)
{
	DPNID	dpnid;
	DWORD	dwIndex;
	DWORD	dwVersion;
	HRESULT	hResultCode;

	Lock();

	//
	// Create DPNID
	//

	if (GetFreeIndex(&dwIndex) != DPN_OK)
	{
		return(DPNERR_GENERIC);
	}

	dwVersion = ++m_dwVersion;
	DPF(8,"Setting new version [%ld]",m_dwVersion);

	dpnid = CONSTRUCT_DPNID(dwIndex,dwVersion);
	DNASSERT(dpnid != 0);

	pNTEntry->Lock();
	pNTEntry->SetDPNID(dpnid);
	pNTEntry->SetVersion(dwVersion);
	pNTEntry->Unlock();

	dwIndex = DECODE_INDEX(dpnid);
	hResultCode = UpdateTable(dwIndex,pNTEntry);

	Unlock();

#ifdef	DEBUG
	ValidateArray();
#endif

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::DeletePlayer"

HRESULT CNameTable::DeletePlayer(const DPNID dpnid,
								 DWORD *const pdwVersion)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	BOOL			fNotifyRelease;
	BOOL			fDecConnections;

	DPF(6,"Parameters: dpnid [0x%lx], pdwVersion [0x%p]",dpnid,pdwVersion);

	pNTEntry = NULL;
	fNotifyRelease = FALSE;
	fDecConnections = FALSE;

	if ((hResultCode = FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Player not in NameTable");
		DisplayDNError(0,hResultCode);

		//
		//	If a version is requested, we will give one back.  This might be a host migration case
		//	in which case even though the player was removed from the NameTable, we will want to
		//	send out a DESTROY_PLAYER message with an updated version number
		//
		if (pdwVersion)
		{
			if (*pdwVersion == 0)
			{
				Lock();
				*pdwVersion = ++m_dwVersion;
				DPF(8,"Setting new version [%ld]",m_dwVersion);
				Unlock();
			}
		}
		goto Failure;
	}
	DNASSERT(!pNTEntry->IsGroup());

	//
	//	Don't do anything if already disconnecting.
	//	Otherwise, set disconnecting to prevent others from cleaning up, and clean up
	//
	pNTEntry->Lock();
	if (!pNTEntry->IsDisconnecting())
	{
		pNTEntry->StartDisconnecting();
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();
		}
		if ((pNTEntry->IsCreated() || pNTEntry->IsIndicated() || pNTEntry->IsInUse()) && !pNTEntry->IsNeedToDestroy())
		{
			pNTEntry->SetNeedToDestroy();
			fNotifyRelease = TRUE;
		}
		if (	  !pNTEntry->IsCreated()
				&& pNTEntry->IsConnecting()
				&& (m_pdnObject->dwFlags & (DN_OBJECT_FLAG_CONNECTING | DN_OBJECT_FLAG_CONNECTED))
				&& (pNTEntry->GetVersion() <= m_dwConnectVersion))
		{
			fDecConnections = TRUE;
		}
		pNTEntry->Unlock();

		//
		//	Remove this player from any groups they belong to
		//
		RemoveAllGroupsFromPlayer( pNTEntry );

		//
		//	Autodestruct any groups this player owns (will also remove any players from those groups first)
		//
		if (pNTEntry->GetDPNID() != 0)
		{
			AutoDestructGroups( pNTEntry->GetDPNID() );
		}

		if (fNotifyRelease)
		{
			pNTEntry->NotifyRelease();
		}

		//
		//	Adjust player count
		//
		m_pdnObject->ApplicationDesc.DecPlayerCount();
		if (fDecConnections)
		{
			DecOutstandingConnections();
		}

		//
		//	Update version and remove from NameTable
		//
		Lock();
		pNTEntry->Lock();
		if (pNTEntry->IsNeedToDestroy())
		{
			//
			//	The DESTROY_PLAYER message has not been posted, so we will add this entry to our "deleted" list
			//	so that some future operations (get info,context,etc.) may succeed.  This entry will be removed
			//	from the list then the DESTROY_PLAYER notification is posted
			//
			pNTEntry->m_bilinkDeleted.InsertBefore(&m_bilinkDeleted);
		}
		pNTEntry->Unlock();
		ReleaseEntry(DECODE_INDEX(dpnid));
		if (pdwVersion)
		{
			if (*pdwVersion)
			{
				m_dwVersion = *pdwVersion;
			}
			else
			{
				*pdwVersion = ++m_dwVersion;
			}
			DPF(8,"Setting new version [%ld]",m_dwVersion);
		}
		Unlock();

		hResultCode = DPN_OK;
	}
	else
	{
		pNTEntry->Unlock();

		hResultCode = DPNERR_INVALIDPLAYER;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::DeleteGroup"

HRESULT CNameTable::DeleteGroup(const DPNID dpnid,
								DWORD *const pdwVersion)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	BOOL			fNotifyRelease;

	DPF(6,"Parameters: dpnid [0x%lx], pdwVersion [0x%p]",dpnid,pdwVersion);

	pNTEntry = NULL;
	fNotifyRelease = FALSE;

	if ((hResultCode = FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Player not in NameTable");
		DisplayDNError(0,hResultCode);
		return(hResultCode);
	}
	DNASSERT(pNTEntry->IsGroup() && !pNTEntry->IsAllPlayersGroup());

	//
	//	Don't do anything if already disconnecting.
	//	Otherwise, set disconnecting to prevent others from cleaning up, and clean up
	//
	pNTEntry->Lock();
	if (pNTEntry->GetDestroyReason() == 0)
	{
		//
		//	Default this if it isn't set
		//
		pNTEntry->SetDestroyReason( DPNDESTROYGROUPREASON_NORMAL );
	}
	if (!pNTEntry->IsDisconnecting())
	{
		pNTEntry->StartDisconnecting();
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();
		}
		if (pNTEntry->IsCreated() && !pNTEntry->IsNeedToDestroy())
		{
			pNTEntry->SetNeedToDestroy();
			fNotifyRelease = TRUE;
		}
		pNTEntry->Unlock();

		RemoveAllPlayersFromGroup( pNTEntry );

		if (fNotifyRelease)
		{
			pNTEntry->NotifyRelease();
		}

		//
		//	Update version and remove from NameTable
		//
		Lock();
		pNTEntry->Lock();
		if (pNTEntry->IsNeedToDestroy())
		{
			//
			//	The DESTROY_GROUP message has not been posted, so we will add this entry to our "deleted" list
			//	so that some future operations (get info,context,etc.) may succeed.  This entry will be removed
			//	from the list then the DESTROY_GROUP notification is posted
			//
			pNTEntry->m_bilinkDeleted.InsertBefore(&m_bilinkDeleted);
		}
		pNTEntry->Unlock();
		ReleaseEntry(DECODE_INDEX(dpnid));
		if (pdwVersion)
		{
			if (*pdwVersion)
			{
				m_dwVersion = *pdwVersion;
			}
			else
			{
				*pdwVersion = ++m_dwVersion;
			}
			DPF(8,"Setting new version [%ld]",m_dwVersion);
		}
		Unlock();

		hResultCode = DPN_OK;
	}
	else
	{
		pNTEntry->Unlock();

		hResultCode = DPNERR_INVALIDGROUP;
	}

	pNTEntry->Release();
	pNTEntry = NULL;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::AddPlayerToGroup"

HRESULT CNameTable::AddPlayerToGroup(CNameTableEntry *const pGroup,
									 CNameTableEntry *const pPlayer,
									 DWORD *const pdwVersion)
{
	HRESULT				hResultCode;
	CGroupMember		*pGroupMember;
	CGroupConnection	*pGroupConnection;
	CConnection			*pConnection;
	BOOL				fNotifyAdd;
	BOOL				fRemove;

	DPF(6,"Parameters: pGroup [0x%p], pPlayer [0x%p], pdwVersion [0x%p]",pGroup,pPlayer,pdwVersion);

	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

	pGroupConnection = NULL;
	pGroupMember = NULL;
	pConnection = NULL;

	if (!pGroup->IsGroup())
	{
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}
	if (pPlayer->IsGroup())
	{
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	//
	//	Create the group connection
	//
	if ((hResultCode = GroupConnectionNew(m_pdnObject,&pGroupConnection)) != DPN_OK)
	{
		DPFERR("Could not allocate name table group connection entry from FPM");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pGroupConnection->SetGroup( pGroup );

	//
	//	Create new group membership record
	//
	if ((hResultCode = GroupMemberNew(m_pdnObject,&pGroupMember)) != DPN_OK)
	{
		DPFERR("Could not get new group member");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Set group connection on group membership record
	//
	pGroupMember->SetGroupConnection(pGroupConnection);

	//
	//	Add player to group
	//
	fNotifyAdd = FALSE;
	fRemove = FALSE;
	Lock();
	pGroup->Lock();
	pPlayer->Lock();
	pGroupMember->Lock();
	if (!pGroup->IsDisconnecting() && !pPlayer->IsDisconnecting())
	{
		pGroupMember->MakeValid();
		pGroupMember->GetGroupConnection()->MakeValid();

		//
		//	Set group membership (checks for duplicates as well)
		//
		if ((hResultCode = pGroupMember->SetMembership(pGroup,pPlayer,pdwVersion)) != DPN_OK)
		{
			DPFERR("Could not set membership record");
			DisplayDNError(0,hResultCode);
			Unlock();
			pGroup->Unlock();
			pPlayer->Unlock();
			pGroupMember->Unlock();
			goto Failure;
		}
		//
		//	Generate notification (ALL_PLAYERS GROUP should never be "Created")
		//
		if (pGroup->IsCreated() && pPlayer->IsCreated())
		{
			//
			//	Add the player's connection to the group connection record
			//
			if (pPlayer->GetConnection() != NULL)
			{
				pGroupConnection->SetConnection( pPlayer->GetConnection() );
			}

			if (!pGroupMember->IsNeedToAdd() && !pGroupMember->IsAvailable() && pGroupMember->GetGroupConnection()->IsConnected())
			{
				pGroupMember->SetNeedToAdd();
				fNotifyAdd = TRUE;
			}
		}

		//
		//	Need to set up the group connection if this is the ALL_PLAYERS group
		//
		if (pGroup->IsAllPlayersGroup())
		{
			if (pPlayer->GetConnection() != NULL)
			{
				pGroupConnection->SetConnection( pPlayer->GetConnection() );
			}
		}

		//
		//	Prevent a DESTROY_PLAYER/DESTROY_GROUP from occurring until this GroupMember record is cleared
		//
		pGroup->NotifyAddRef();
		pPlayer->NotifyAddRef();
	}
	Unlock();
	pGroup->Unlock();
	pPlayer->Unlock();
	pGroupMember->Unlock();

	if (fNotifyAdd)
	{
		DNUserAddPlayerToGroup(m_pdnObject,pGroup,pPlayer);

		pGroupMember->Lock();
		pGroupMember->ClearNeedToAdd();
		pGroupMember->MakeAvailable();
		if (pGroupMember->IsNeedToRemove())
		{
			fRemove = TRUE;
		}
		pGroupMember->Unlock();
	}
	if (fRemove)
	{
		RemovePlayerFromGroup(pGroup,pPlayer,NULL);
	}

	pGroupConnection->Release();
	pGroupConnection = NULL;

	pGroupMember->Release();
	pGroupMember = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pGroupConnection)
	{
		pGroupConnection->Release();
		pGroupConnection = NULL;
	}
	if (pGroupMember)
	{
		pGroupMember->Release();
		pGroupMember = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::RemovePlayerFromGroup"

HRESULT CNameTable::RemovePlayerFromGroup(CNameTableEntry *const pGroup,
										  CNameTableEntry *const pPlayer,
										  DWORD *const pdwVersion)
{
	CGroupMember	*pGroupMember;
	CBilink			*pBilink;
	BOOL			fNotifyRemove;
	HRESULT			hResultCode;

	DPF(6,"Parameters: pGroup [0x%p], pPlayer [0x%p], pdwVersion [0x%p]",pGroup,pPlayer,pdwVersion);

	DNASSERT(pGroup != NULL);
	DNASSERT(pPlayer != NULL);

	pGroupMember = NULL;
	fNotifyRemove = FALSE;

	Lock();
	pGroup->Lock();
	pPlayer->Lock();

	//
	//	The first order of business is to locate the GroupMembership record.
	//	We will use the player's NameTable entry and scan through the
	//	group membership bilink until we find the required entry.
	//	(We're assuming that this will be faster than going the other route.)
	//
	pBilink = pPlayer->m_bilinkMembership.GetNext();
	while (pBilink != &pPlayer->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkGroups);
		if (pGroupMember->GetGroup() == pGroup)
		{
			pGroupMember->AddRef();
			break;
		}
		pGroupMember = NULL;
		pBilink = pBilink->GetNext();
	}
	if (pGroupMember == NULL)
	{
		Unlock();
		pGroup->Unlock();
		pPlayer->Unlock();
		hResultCode = DPNERR_PLAYERNOTINGROUP;
		goto Failure;
	}

	DNASSERT(pGroupMember != NULL);
	pGroupMember->Lock();

	//
	//	Ensure no one else is trying to remove this already
	//
	if (!pGroupMember->IsValid() || pGroupMember->IsNeedToRemove())
	{
		Unlock();
		pGroup->Unlock();
		pPlayer->Unlock();
		pGroupMember->Unlock();
		hResultCode = DPNERR_PLAYERNOTINGROUP;
		goto Failure;
	}
	pGroupMember->SetNeedToRemove();

	//
	//	We will only notify the application if the player is not being added to a group
	//
	if (!pGroupMember->IsNeedToAdd())
	{
		//
		//	Either this is already indicated, or is not about to be indicated, so remove it
		//	(and see if we need to generate a notification)
		//
		pGroupMember->RemoveMembership( pdwVersion );

		if (pGroupMember->IsAvailable())
		{
			pGroupMember->MakeUnavailable();
			if (!pGroup->IsAllPlayersGroup())
			{
				fNotifyRemove = TRUE;
			}
		}
	}
	Unlock();
	pGroup->Unlock();
	pPlayer->Unlock();
	pGroupMember->Unlock();

	if (fNotifyRemove)
	{
		DNUserRemovePlayerFromGroup(m_pdnObject,pGroup,pPlayer);
	}

	//
	//	Trigger a DESTROY_PLAYER/DESTROY_GROUP if this was the last member
	//
	pGroup->NotifyRelease();
	pPlayer->NotifyRelease();

	pGroupMember->Release();
	pGroupMember = NULL;

	hResultCode = DPN_OK;

Exit:
	return(hResultCode);

Failure:
	if (pGroupMember)
	{
		pGroupMember->Release();
		pGroupMember = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::RemoveAllPlayersFromGroup"

HRESULT CNameTable::RemoveAllPlayersFromGroup(CNameTableEntry *const pGroup)
{
	CNameTableEntry	**PlayerList;
	CBilink			*pBilink;
	HRESULT			hResultCode;
	DWORD			dwCount;
	DWORD			dwActual;

	DPF(6,"Parameters: pGroup [0x%p]",pGroup);

	DNASSERT(pGroup != NULL);

	PlayerList = NULL;

	//
	//	This is not an elegant solution - we will build a list of membership records and remove each one
	//
	dwCount = 0;
	dwActual = 0;
	pGroup->Lock();
	DNASSERT(pGroup->IsDisconnecting());
	pBilink = pGroup->m_bilinkMembership.GetNext();
	while (pBilink != &pGroup->m_bilinkMembership)
	{
		dwCount++;
		pBilink = pBilink->GetNext();
	}
	if (dwCount)
	{
		CGroupMember	*pGroupMember;

		pGroupMember = NULL;

		if ((PlayerList = static_cast<CNameTableEntry**>(MemoryBlockAlloc(m_pdnObject,dwCount*sizeof(CNameTableEntry*)))) == NULL)
		{
			DPFERR("Could not allocate player list");
			hResultCode = DPNERR_OUTOFMEMORY;
			DNASSERT(FALSE);
			pGroup->Unlock();
			goto Failure;
		}
		pBilink = pGroup->m_bilinkMembership.GetNext();
		while (pBilink != &pGroup->m_bilinkMembership)
		{
			pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);

			pGroupMember->Lock();
			if (pGroupMember->IsValid() && !pGroupMember->IsNeedToRemove() && pGroupMember->GetPlayer())
			{
				DNASSERT(dwActual < dwCount);
				pGroupMember->GetPlayer()->AddRef();
				PlayerList[dwActual] = pGroupMember->GetPlayer();
				dwActual++;
			}
			pGroupMember->Unlock();

			pBilink = pBilink->GetNext();
			pGroupMember = NULL;
		}

		DNASSERT(pGroupMember == NULL);
	}
	pGroup->Unlock();

	if (PlayerList)
	{
		DWORD	dw;

		for (dw = 0 ; dw < dwActual ; dw++)
		{
			DNASSERT(PlayerList[dw] != NULL);

			RemovePlayerFromGroup(pGroup,PlayerList[dw],NULL);
			PlayerList[dw]->Release();
			PlayerList[dw] = NULL;
		}

		MemoryBlockFree(m_pdnObject,PlayerList);
		PlayerList = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (PlayerList)
	{
		MemoryBlockFree(m_pdnObject,PlayerList);
		PlayerList = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::RemoveAllGroupsFromPlayer"

HRESULT CNameTable::RemoveAllGroupsFromPlayer(CNameTableEntry *const pPlayer)
{
	CNameTableEntry	**GroupList;
	CBilink			*pBilink;
	HRESULT			hResultCode;
	DWORD			dwCount;
	DWORD			dwActual;

	DPF(6,"Parameters: pPlayer [0x%p]",pPlayer);

	DNASSERT(pPlayer != NULL);

	GroupList = NULL;

	//
	//	This is not an elegant solution - we will build a list of membership records and remove each one
	//
	dwCount = 0;
	dwActual = 0;
	pPlayer->Lock();
	DNASSERT(pPlayer->IsDisconnecting());
	pBilink = pPlayer->m_bilinkMembership.GetNext();
	while (pBilink != &pPlayer->m_bilinkMembership)
	{
		dwCount++;
		pBilink = pBilink->GetNext();
	}
	if (dwCount)
	{
		CGroupMember	*pGroupMember;

		pGroupMember = NULL;

		if ((GroupList = static_cast<CNameTableEntry**>(MemoryBlockAlloc(m_pdnObject,dwCount*sizeof(CNameTableEntry*)))) == NULL)
		{
			DPFERR("Could not allocate member list");
			hResultCode = DPNERR_OUTOFMEMORY;
			DNASSERT(FALSE);
			pPlayer->Unlock();
			goto Failure;
		}
		pBilink = pPlayer->m_bilinkMembership.GetNext();
		while (pBilink != &pPlayer->m_bilinkMembership)
		{
			pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkGroups);

			pGroupMember->Lock();
			if (pGroupMember->IsValid() && !pGroupMember->IsNeedToRemove() && pGroupMember->GetGroup())
			{
				DNASSERT(dwActual < dwCount);
				pGroupMember->GetGroup()->AddRef();
				GroupList[dwActual] = pGroupMember->GetGroup();
				dwActual++;
			}
			pGroupMember->Unlock();

			pBilink = pBilink->GetNext();
			pGroupMember = NULL;
		}

		DNASSERT(pGroupMember == NULL);
	}
	pPlayer->Unlock();

	if (GroupList)
	{
		DWORD	dw;

		for (dw = 0 ; dw < dwActual ; dw++)
		{
			DNASSERT(GroupList[dw] != NULL);

			RemovePlayerFromGroup(GroupList[dw],pPlayer,NULL);
			GroupList[dw]->Release();
			GroupList[dw] = NULL;
		}

		MemoryBlockFree(m_pdnObject,GroupList);
		GroupList = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (GroupList)
	{
		MemoryBlockFree(m_pdnObject,GroupList);
		GroupList = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::IsMember"

BOOL CNameTable::IsMember(const DPNID dpnidGroup,
						  const DPNID dpnidPlayer)
{
	CNameTableEntry		*pNTEntry;
	CGroupMember		*pGroupMember;
	CBilink				*pBilink;
	BOOL				bFound;

	bFound = FALSE;

	if (FindEntry(dpnidGroup,&pNTEntry) != DPN_OK)
	{
		goto Exit;
	}

	//
	//	Is this a group ?
	//
	if (!pNTEntry->IsGroup())
	{
		pNTEntry->Release();
		pNTEntry = NULL;
		goto Exit;
	}

	pNTEntry->Lock();
	pBilink = pNTEntry->m_bilinkMembership.GetNext();
	while (pBilink != &pNTEntry->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
		if (pGroupMember->GetPlayer()->GetDPNID() == dpnidPlayer)
		{
			bFound = TRUE;
			break;
		}
		pBilink = pBilink->GetNext();
	}

	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	return(bFound);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::PackNameTable"

HRESULT CNameTable::PackNameTable(CNameTableEntry *const pTarget,
								  CPackedBuffer *const pPackedBuffer)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CBilink			*pBilinkMembership;
	CNameTableEntry	*pNTEntry;
	CGroupMember	*pGroupMember;
	DN_NAMETABLE_INFO	*pdnNTInfo;
	BOOL			bOutOfSpace;
	DWORD			dwEntryCount;
	DWORD			dwMembershipCount;
	DWORD			dwVersion;

	DNASSERT(pTarget != NULL);
	DNASSERT(pPackedBuffer != NULL);

	//
	//	PackedNameTable:
	//		<DN_NAMETABLE_INFO>
	//		<DN_NAMETABLE_ENTRY_INFO>	(DN_NAMETABLE_INFO.dwEntryCount entries)
	//		<DN_MEMBERSHIP_INFO>		(DN_NAMETABLE_INFO.dwMembershipCount entries)
	//			...
	//		<strings>
	//

	//
	//	NameTable Info
	//
	dwVersion = pTarget->GetVersion();
	bOutOfSpace = FALSE;
	pdnNTInfo = static_cast<DN_NAMETABLE_INFO*>(pPackedBuffer->GetHeadAddress());
	if ((hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DN_NAMETABLE_INFO))) != DPN_OK)
	{
		bOutOfSpace = TRUE;
	}

	//
	//	NameTableEntry Info
	//
	if (m_pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		dwEntryCount = 0;

		//
		//	Players
		//
		pBilink = m_bilinkPlayers.GetNext();
		while (pBilink != &m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			if (pNTEntry->GetVersion() <= dwVersion)
			{
				if ((hResultCode = pNTEntry->PackEntryInfo(pPackedBuffer)) != DPN_OK)
				{
					bOutOfSpace = TRUE;
				}
				dwEntryCount++;
			}
			pBilink = pBilink->GetNext();
		}

		//
		//	Groups
		//
		pBilink = m_bilinkGroups.GetNext();
		while (pBilink != &m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			if (pNTEntry->GetVersion() <= dwVersion)
			{
				if ((hResultCode = pNTEntry->PackEntryInfo(pPackedBuffer)) != DPN_OK)
				{
					bOutOfSpace = TRUE;
				}
				dwEntryCount++;
			}
			pBilink = pBilink->GetNext();
		}
	}
	else
	{
		DNASSERT(m_pLocalPlayer != NULL);

		if ((hResultCode = m_pLocalPlayer->PackEntryInfo(pPackedBuffer)) != DPN_OK)
		{
			bOutOfSpace = TRUE;
		}
		if ((hResultCode = pTarget->PackEntryInfo(pPackedBuffer)) != DPN_OK)
		{
			bOutOfSpace = TRUE;
		}
		dwEntryCount = 2;
	}

	//
	//	GroupMember Info
	//
	dwMembershipCount = 0;
	if (m_pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		pBilink = m_bilinkGroups.GetNext();
		while (pBilink != &m_bilinkGroups)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			DNASSERT(pNTEntry->IsGroup());
			if (!pNTEntry->IsAllPlayersGroup())
			{
				pBilinkMembership = pNTEntry->m_bilinkMembership.GetNext();
				while (pBilinkMembership != &pNTEntry->m_bilinkMembership)
				{
					pGroupMember = CONTAINING_OBJECT(pBilinkMembership,CGroupMember,m_bilinkPlayers);
					if (pGroupMember->GetVersion() <= dwVersion)
					{
						if ((hResultCode = pGroupMember->PackMembershipInfo(pPackedBuffer)) != DPN_OK)
						{
							bOutOfSpace = TRUE;
						}
						dwMembershipCount++;
					}
					pBilinkMembership = pBilinkMembership->GetNext();
				}
			}
			pBilink = pBilink->GetNext();
		}
	}

	if (!bOutOfSpace)
	{
		pdnNTInfo->dpnid = pTarget->GetDPNID();
		pdnNTInfo->dwVersion = dwVersion;
		pdnNTInfo->dwVersionNotUsed = 0;
		pdnNTInfo->dwEntryCount = dwEntryCount;
		pdnNTInfo->dwMembershipCount = dwMembershipCount;
	}

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::UnpackNameTableInfo"

HRESULT	CNameTable::UnpackNameTableInfo(DN_NAMETABLE_INFO *const pdnNTInfo,
										BYTE *const pBufferStart,
										DPNID *const pdpnid)
{
	HRESULT			hResultCode;
	DWORD			dwCount;
	CNameTableEntry	*pNTEntry;
	DN_NAMETABLE_ENTRY_INFO			*pdnEntryInfo;
	DN_NAMETABLE_MEMBERSHIP_INFO	*pdnMembershipInfo;

	DNASSERT(pdnNTInfo != NULL);
	DNASSERT(pBufferStart != NULL);

	//
	//	Preset outstanding connections
	//
	m_lOutstandingConnections = 0;

	//
	//	NameTable Entries
	//
	pdnEntryInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(pdnNTInfo+1);
	for (dwCount = 0 ; dwCount < pdnNTInfo->dwEntryCount ; dwCount++)
	{
		if ((hResultCode = NameTableEntryNew(m_pdnObject,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not get new NameTableEntry");
			DNASSERT(FALSE);
			return(hResultCode);
		}

		if ((hResultCode = pNTEntry->UnpackEntryInfo(pdnEntryInfo,pBufferStart)) != DPN_OK)
		{
			DPFERR("Could not unpack NameTableEntryInfo");
			DNASSERT(FALSE);
			pNTEntry->Release();
			return(hResultCode);
		}

		//
		//	Increment outstanding connection count
		//
		if (!pNTEntry->IsGroup() && (pNTEntry->GetVersion() <= pdnNTInfo->dwVersion))
		{
			pNTEntry->StartConnecting();	// This will be cleared when the player has connected or disconnected
			IncOutstandingConnections();
		}

		// Only put in NameTable if Host player
		if (m_pdnObject->dwFlags & (DN_OBJECT_FLAG_PEER | DN_OBJECT_FLAG_SERVER))
		{
			if ((hResultCode = InsertEntry(pNTEntry)) != DPN_OK)
			{
				DPFERR("Could not add NameTableEntry to NameTable");
				DNASSERT(FALSE);
				pNTEntry->Release();
				return(hResultCode);
			}
		}

		// Check for ShortCut pointers
		if (pNTEntry->GetDPNID() == pdnNTInfo->dpnid)
		{
			MakeLocalPlayer(pNTEntry);
		}
		else if (pNTEntry->IsHost())
		{
			MakeHostPlayer(pNTEntry);
		}
		else if (pNTEntry->IsAllPlayersGroup())
		{
			MakeAllPlayersGroup(pNTEntry);
		}

		pNTEntry->Release();
		pNTEntry = NULL;

		pdnEntryInfo++;
	}

	//
	//	Pass back local player's DPNID
	//
	if (pdpnid)
	{
		*pdpnid = pdnNTInfo->dpnid;
	}

	//
	//	Group Memberships
	//
	pdnMembershipInfo = reinterpret_cast<DN_NAMETABLE_MEMBERSHIP_INFO*>(pdnEntryInfo);
	for (dwCount = 0 ; dwCount < pdnNTInfo->dwMembershipCount ; dwCount++)
	{
		CNameTableEntry	*pGroup;

		pGroup = NULL;

		if ((hResultCode = m_pdnObject->NameTable.FindEntry(pdnMembershipInfo->dpnidGroup,&pGroup)) == DPN_OK)
		{
			CNameTableEntry	*pPlayer;

			pPlayer = NULL;

			if ((hResultCode = m_pdnObject->NameTable.FindEntry(pdnMembershipInfo->dpnidPlayer,&pPlayer)) == DPN_OK)
			{
				hResultCode = AddPlayerToGroup(pGroup,pPlayer,&pdnMembershipInfo->dwVersion);
				pPlayer->Release();
				pPlayer = NULL;
			}
			pGroup->Release();
			pGroup = NULL;

			DNASSERT(pPlayer == NULL);
		}
		pdnMembershipInfo++;

		DNASSERT(pGroup == NULL);
	}

	//
	//	Version
	//
	Lock();
	SetVersion(pdnNTInfo->dwVersion);
	SetConnectVersion(pdnNTInfo->dwVersion);
	Unlock();

	hResultCode = DPN_OK;
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::MakeLocalPlayer"

void CNameTable::MakeLocalPlayer(CNameTableEntry *const pNTEntry)
{
	DNASSERT(pNTEntry != NULL);
	DNASSERT(m_pLocalPlayer == NULL);

	pNTEntry->AddRef();
	pNTEntry->Lock();
	pNTEntry->MakeLocal();
	pNTEntry->Unlock();

	Lock();
	m_pLocalPlayer = pNTEntry;
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ClearLocalPlayer"

void CNameTable::ClearLocalPlayer( void )
{
	BOOL	fInform;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;

	fInform = FALSE;
	pNTEntry = NULL;
	pConnection = NULL;

	Lock();
	if (m_pLocalPlayer)
	{
		pNTEntry = m_pLocalPlayer;
		m_pLocalPlayer = NULL;

		//
		//	If the player is available, we will make it unavailable.  This will prevent other threads from using it.
		//	We will then ensure that we are the only one indicating a DESTROY_PLAYER notification.
		//
		pNTEntry->Lock();
		if (pNTEntry->GetDestroyReason() == 0)
		{
			pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
		}
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();

			if (pNTEntry->IsInUse())
			{
				//
				//	Queue destruction notification
				//
				pNTEntry->SetNeedToDestroy();
			}
			else
			{
				//
				//	Notify destruction
				//
				pNTEntry->SetInUse();
				fInform = TRUE;
			}
		}
		pNTEntry->Unlock();
	}
	Unlock();

	if (pNTEntry)
	{
		pNTEntry->GetConnectionRef(&pConnection);

/* REMOVE - This is covered by the NotifyRelease logic
		if (fInform)
		{
			if (!(m_pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
			{
				DNUserDestroyPlayer(m_pdnObject,pNTEntry);
			}
			pNTEntry->Lock();
			pNTEntry->ClearInUse();
			pNTEntry->Unlock();
		}
*/
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	//
	//	Try to disconnect
	//
	if (pConnection)
	{
		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::MakeHostPlayer"

void CNameTable::MakeHostPlayer(CNameTableEntry *const pNTEntry)
{
	BOOL	bNotify;
	DPNID	dpnid;
	PVOID	pvContext;

	DNASSERT(pNTEntry != NULL);
	DNASSERT(m_pHostPlayer == NULL);

	pNTEntry->AddRef();

	pNTEntry->Lock();
	pNTEntry->MakeHost();
	if (pNTEntry->IsAvailable())
	{
		bNotify = TRUE;
		dpnid = pNTEntry->GetDPNID();
		pvContext = pNTEntry->GetContext();
	}
	else
	{
		bNotify = FALSE;
	}
	pNTEntry->Unlock();

	Lock();
	m_pHostPlayer = pNTEntry;
	Unlock();

	if (bNotify)
	{
		// Inform user that host has migrated
		DN_UserHostMigrate(m_pdnObject,dpnid,pvContext);
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ClearHostPlayer"

void CNameTable::ClearHostPlayer( void )
{
	BOOL	fInform;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;

	fInform = FALSE;
	pNTEntry = NULL;
	pConnection = NULL;

	Lock();
	if (m_pHostPlayer)
	{
		pNTEntry = m_pHostPlayer;
		m_pHostPlayer = NULL;

		//
		//	If the player is available, we will make it unavailable.  This will prevent other threads from using it.
		//	We will then ensure that we are the only one indicating a DESTROY_PLAYER notification.
		//
		pNTEntry->Lock();
		if (pNTEntry->GetDestroyReason() == 0)
		{
			pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
		}
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();

			if (pNTEntry->IsInUse())
			{
				//
				//	Queue destruction notification
				//
				pNTEntry->SetNeedToDestroy();
			}
			else
			{
				//
				//	Notify destruction
				//
				pNTEntry->SetInUse();
				fInform = TRUE;
			}
		}
		pNTEntry->Unlock();
	}
	Unlock();

	if (pNTEntry)
	{
		pNTEntry->GetConnectionRef(&pConnection);

/* REMOVE - This is covered by the NotifyRelease logic
		if (fInform)
		{
			if (!(m_pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
			{
				DNUserDestroyPlayer(m_pdnObject,pNTEntry);
			}
			pNTEntry->Lock();
			pNTEntry->ClearInUse();
			pNTEntry->Unlock();
		}
*/
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	//
	//	Try to disconnect
	//
	if (pConnection)
	{
		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;
	}
}


//
//	Clear the HostPlayer if it has a matching DPNID
//

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ClearHostWithDPNID"

BOOL CNameTable::ClearHostWithDPNID( const DPNID dpnid )
{
	BOOL	fCleared;
	BOOL	fInform;
	CNameTableEntry	*pNTEntry;
	CConnection		*pConnection;

	fCleared = FALSE;
	fInform = FALSE;
	pNTEntry = NULL;
	pConnection = NULL;

	Lock();
	if (m_pHostPlayer)
	{
		if (m_pHostPlayer->GetDPNID() == dpnid)
		{
			pNTEntry = m_pHostPlayer;
			m_pHostPlayer = NULL;

			//
			//	If the player is available, we will make it unavailable.  This will prevent other threads from using it.
			//	We will then ensure that we are the only one indicating a DESTROY_PLAYER notification.
			//
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
			}
			if (pNTEntry->IsAvailable())
			{
				pNTEntry->MakeUnavailable();

				if (pNTEntry->IsInUse())
				{
					//
					//	Queue destruction notification
					//
					pNTEntry->SetNeedToDestroy();
				}
				else
				{
					//
					//	Notify destruction
					//
					pNTEntry->SetInUse();
					fInform = TRUE;
				}
			}
			pNTEntry->Unlock();
			fCleared = TRUE;
		}
	}
	Unlock();

	if (pNTEntry)
	{
		pNTEntry->GetConnectionRef(&pConnection);
/* REMOVE - This is covered by the NotifyRelease logic
		if (fInform)
		{
			if (!(m_pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
			{
				DNUserDestroyPlayer(m_pdnObject,pNTEntry);
			}
			pNTEntry->Lock();
			pNTEntry->ClearInUse();
			pNTEntry->Unlock();
		}
*/
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	//
	//	Try to disconnect
	//
	if (pConnection)
	{
		pConnection->Disconnect();
		pConnection->Release();
		pConnection = NULL;
	}

	return(fCleared);
}


//
//	Attempt to update the HostPlayer short-cut pointer with a new player entry.
//	This will only be performed if the new entry has a larger version than the
//	existing HostPlayer entry.
//

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::UpdateHostPlayer"

void CNameTable::UpdateHostPlayer( CNameTableEntry *const pNewHost )
{
	BOOL	fInformDelete;
	BOOL	fInformMigrate;
	DPNID	dpnid;
	PVOID	pvContext;
	CNameTableEntry	*pNTEntry;

	DNASSERT( pNewHost != NULL);

	fInformDelete = FALSE;
	fInformMigrate = FALSE;
	pNTEntry = NULL;

	Lock();

	//
	//	Clear old Host
	//
	if (m_pHostPlayer)
	{
		if (pNewHost->GetVersion() > m_pHostPlayer->GetVersion())
		{
			pNTEntry = m_pHostPlayer;
			m_pHostPlayer = NULL;

			//
			//	If the player is available, we will make it unavailable.  This will prevent other threads from using it.
			//	We will then ensure that we are the only one indicating a DESTROY_PLAYER notification.
			//
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
			}
			if (pNTEntry->IsAvailable())
			{
				pNTEntry->MakeUnavailable();

				if (pNTEntry->IsInUse())
				{
					//
					//	Queue destruction notification
					//
					pNTEntry->SetNeedToDestroy();
				}
				else
				{
					//
					//	Notify destruction
					//
					pNTEntry->SetInUse();
					fInformDelete = TRUE;
				}
			}
			pNTEntry->Unlock();
		}
	}

	//
	//	New Host player
	//
	if (m_pHostPlayer == NULL)
	{
		pNewHost->Lock();
		pNewHost->MakeHost();
		if (pNewHost->IsAvailable())
		{
			fInformMigrate = TRUE;
			dpnid = pNewHost->GetDPNID();
			pvContext = pNewHost->GetContext();
		}
		pNewHost->Unlock();
		pNewHost->AddRef();
		m_pHostPlayer = pNewHost;
	}
	Unlock();

	//
	//	User notifications
	//
	if (pNTEntry)
	{
/* REMOVE - This is covered by the NotifyRelease logic
		if (fInformDelete)
		{
			if (!(m_pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
			{
				DNUserDestroyPlayer(m_pdnObject,pNTEntry);
			}
			pNTEntry->Lock();
			pNTEntry->ClearInUse();
			pNTEntry->Unlock();
		}
*/
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	if (fInformMigrate)
	{
		DN_UserHostMigrate(m_pdnObject,dpnid,pvContext);
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::MakeAllPlayersGroup"

void CNameTable::MakeAllPlayersGroup(CNameTableEntry *const pNTEntry)
{
	DNASSERT(pNTEntry != NULL);
	DNASSERT(m_pAllPlayersGroup == NULL);

	pNTEntry->AddRef();
	pNTEntry->Lock();
	pNTEntry->MakeAllPlayersGroup();
	pNTEntry->Unlock();

	Lock();
	m_pAllPlayersGroup = pNTEntry;
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::ClearAllPlayersGroup"

void CNameTable::ClearAllPlayersGroup( void )
{
	BOOL	fInform;
	CNameTableEntry	*pNTEntry;

	fInform = FALSE;
	pNTEntry = NULL;

	Lock();
	if (m_pAllPlayersGroup)
	{
		pNTEntry = m_pAllPlayersGroup;
		pNTEntry->Lock();
		if (pNTEntry->IsAvailable())
		{
			pNTEntry->MakeUnavailable();
			fInform = TRUE;
		}
		pNTEntry->Unlock();
		m_pAllPlayersGroup = NULL;
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	Unlock();
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::PopulateConnection"

HRESULT CNameTable::PopulateConnection(CConnection *const pConnection)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	CNameTableEntry	*pAllPlayersGroup;
	CGroupMember	*pGroupMember;
	BOOL			fNotifyCreate;
	BOOL			fNotifyAddPlayerToGroup;
	BOOL			fNotifyRemovePlayerFromGroup;

	DNASSERT(pConnection != NULL);
	DNASSERT(pConnection->GetDPNID() != 0);

	pNTEntry = NULL;
	pAllPlayersGroup = NULL;
	pGroupMember = NULL;

	if ((hResultCode = FindEntry(pConnection->GetDPNID(),&pNTEntry)) != DPN_OK)
	{
		return(hResultCode);
	}
	DNASSERT(!pNTEntry->IsGroup());

	//
	//	Set the connection for this player
	//
	pNTEntry->Lock();
	if (pNTEntry->GetConnection() == NULL)
	{
		pNTEntry->SetConnection( pConnection );
	}
	DNASSERT( pNTEntry->IsConnecting() );
	DNASSERT( !pNTEntry->IsAvailable() );
	pNTEntry->StopConnecting();
	pNTEntry->MakeAvailable();
	pNTEntry->Unlock();

	//
	//	Add this player to the ALL_PLAYERS group and make the link active
	//
	if ((hResultCode = m_pdnObject->NameTable.GetAllPlayersGroupRef( &pAllPlayersGroup )) != DPN_OK)
	{
		DPFERR("Could not get ALL_PLAYERS_GROUP reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = m_pdnObject->NameTable.AddPlayerToGroup(	pAllPlayersGroup,
																pNTEntry,
																NULL)) != DPN_OK)
	{
		DPFERR("Could not add player to AllPlayersGroup");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pAllPlayersGroup->Release();
	pAllPlayersGroup = NULL;

	fNotifyCreate = FALSE;
	pNTEntry->Lock();
	if (!pNTEntry->IsDisconnecting() && !pNTEntry->IsCreated())
	{
		//
		//	We will set the entry as InUse so that any receives will get queued.
		//	We will also addref the NotifyRefCount twice.  Once for the
		//	CREATE_PLAYER notification if there was no INDICATE_CONNECT
		//	(so that a corresponding release will generate the DESTROY_PLAYER),
		//	and a second one to prevent a premature release from generating
		//	the DESTROY_PLAYER before we return from CREATE_PLAYER.  We will
		//	therefore have to release the refcount as soon as the CREATE_PLAYER
		//	returns back to us from the user (setting the context value).
		//
		DNASSERT(!pNTEntry->IsInUse());
		pNTEntry->SetInUse();
		if (!pNTEntry->IsIndicated())
		{
			pNTEntry->NotifyAddRef();
		}
		pNTEntry->NotifyAddRef();
		fNotifyCreate = TRUE;
	}
	pNTEntry->Unlock();		// Release lock during notifications (CREATE_PLAYER, CONNECT_COMPLETE?)

	if (fNotifyCreate)
	{
		if (!(m_pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT))
		{
			DNUserCreatePlayer(m_pdnObject,pNTEntry);
		}

		//
		//	Process any queued messages for this player
		//
		pNTEntry->PerformQueuedOperations();
	}

	//
	//	Create any auto-destruct groups belonging to this player
	//
	AutoCreateGroups(pNTEntry);


	pNTEntry->Lock();

	//
	//	Ensure this entry is still available (might have been deleted)
	//
	if (!pNTEntry->IsAvailable() || pNTEntry->IsDisconnecting())
	{
		pNTEntry->Unlock();
		goto Failure;
	}

	pBilink = pNTEntry->m_bilinkMembership.GetNext();
	while (pBilink != &pNTEntry->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkGroups);
		pGroupMember->AddRef();
		pNTEntry->Unlock();

		DNASSERT(pGroupMember->GetGroup() != NULL);
		DNASSERT(pGroupMember->GetPlayer() != NULL);

		fNotifyAddPlayerToGroup = FALSE;
		fNotifyRemovePlayerFromGroup = FALSE;

		pGroupMember->GetGroup()->Lock();
		pGroupMember->Lock();
		DNASSERT(pGroupMember->GetGroupConnection() != NULL);
		if (!pGroupMember->IsAvailable() && !pGroupMember->IsNeedToAdd() && !pGroupMember->GetGroupConnection()->IsConnected())
		{
			//
			//	We will only indicate this up if the group has been created
			//	We don't need to see if the player has been created since he should have been and the NotifyRefCount
			//		on the player's entry for this group member will still be there
			//
			if (	pGroupMember->GetGroup()->IsCreated()
				&&	!pGroupMember->GetGroup()->IsDisconnecting()
				&&	!pGroupMember->GetGroup()->IsAllPlayersGroup())
			{
				pGroupMember->SetNeedToAdd();
				fNotifyAddPlayerToGroup = TRUE;
			}
		}
		pGroupMember->GetGroup()->Unlock();
		pGroupMember->Unlock();

		if (fNotifyAddPlayerToGroup)
		{
			DNASSERT(pGroupMember->GetGroupConnection()->GetConnection() == NULL);
			pGroupMember->Lock();
			pGroupMember->GetGroupConnection()->Lock();
			pGroupMember->GetGroupConnection()->SetConnection(pConnection);
			pGroupMember->GetGroupConnection()->Unlock();
			pGroupMember->MakeAvailable();
			pGroupMember->Unlock();

			DNUserAddPlayerToGroup(	m_pdnObject,pGroupMember->GetGroup(),pGroupMember->GetPlayer());

			pGroupMember->Lock();
			pGroupMember->ClearNeedToAdd();
			if (pGroupMember->IsNeedToRemove())
			{
				fNotifyRemovePlayerFromGroup = TRUE;
			}
			pGroupMember->Unlock();
		}

		if (fNotifyRemovePlayerFromGroup)
		{
			DNUserRemovePlayerFromGroup(m_pdnObject,pGroupMember->GetGroup(),pGroupMember->GetPlayer());
		}

		pGroupMember->Release();
		pGroupMember = NULL;

		pNTEntry->Lock();
		//
		//	Avoid infinite loops by ensuring that we are not on a "disconnected" entry
		//
		if ((pBilink->GetNext() != &pNTEntry->m_bilinkMembership) && (pBilink->GetNext() == pBilink))
		{
			//
			//	We have an invalid entry - need to restart
			//
			pBilink = pNTEntry->m_bilinkMembership.GetNext();
		}
		else
		{
			//
			//	We either have a valid entry or we're finished
			//
			pBilink = pBilink->GetNext();
		}
	}

	pNTEntry->Unlock();

	//
	//	Reduce outstanding connections
	//
	if (pNTEntry->GetVersion() <= m_dwConnectVersion)
	{
		DecOutstandingConnections();
	}

	pNTEntry->Release();
	pNTEntry = NULL;

Exit:
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pAllPlayersGroup)
	{
		pAllPlayersGroup->Release();
		pAllPlayersGroup = NULL;
	}
	if (pGroupMember)
	{
		pGroupMember->Release();
		pGroupMember = NULL;
	}
	goto Exit;
}


//
//	This will generate ADD_PLAYER_TO_GROUP messages for all of the CREATE'd players in a group
//	(for whom a notification has not been posted)
//
#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::PopulateGroup"

HRESULT CNameTable::PopulateGroup(CNameTableEntry *const pGroup)
{
	HRESULT			hResultCode;
	BOOL			fNotifyAddPlayerToGroup;
	BOOL			fNotifyRemovePlayerFromGroup;
	CBilink			*pBilink;
	CGroupMember	*pGroupMember;
	CNameTableEntry	*pPlayer;

	DPF(6,"Parameters: pGroup [0x%p]",pGroup);

	DNASSERT(pGroup != NULL);

	pPlayer = NULL;
	pGroupMember = NULL;

	if (!pGroup->IsGroup())
	{
		hResultCode = DPNERR_INVALIDGROUP;
		goto Failure;
	}

	pGroup->Lock();
	pBilink = pGroup->m_bilinkMembership.GetNext();
	while (pBilink != &pGroup->m_bilinkMembership)
	{
		pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
		pGroupMember->AddRef();
		pGroupMember->Lock();
		DNASSERT(pGroupMember->GetGroup() != NULL);
		DNASSERT(pGroupMember->GetPlayer() != NULL);
		DNASSERT(pGroupMember->GetGroup() == pGroup);
		pGroupMember->GetPlayer()->AddRef();
		pPlayer = pGroupMember->GetPlayer();
		pGroup->Unlock();
		pGroupMember->Unlock();

		fNotifyAddPlayerToGroup = FALSE;
		fNotifyRemovePlayerFromGroup = FALSE;

		pGroup->Lock();
		pPlayer->Lock();
		pGroupMember->Lock();
		DNASSERT( pGroupMember->GetGroupConnection() != NULL );
		if (	 pPlayer->IsCreated()
			&&	!pPlayer->IsDisconnecting()
			&&	 pGroup->IsCreated()
			&&	!pGroup->IsDisconnecting()
			&&	!pGroupMember->IsAvailable()
			&&	!pGroupMember->IsNeedToAdd()
			&&	!pGroupMember->GetGroupConnection()->IsConnected() )
		{
			pGroupMember->MakeAvailable();
			pGroupMember->SetNeedToAdd();
			fNotifyAddPlayerToGroup = TRUE;
		}
		pGroup->Unlock();
		pPlayer->Unlock();
		pGroupMember->Unlock();

		if (fNotifyAddPlayerToGroup)
		{
			DNUserAddPlayerToGroup(m_pdnObject,pGroup,pPlayer);

			pGroupMember->Lock();
			pGroupMember->ClearNeedToAdd();
			if (pGroupMember->IsNeedToRemove())
			{
				fNotifyRemovePlayerFromGroup = TRUE;
			}
			pGroupMember->Unlock();
		}
		if (fNotifyRemovePlayerFromGroup)
		{
			RemovePlayerFromGroup(pGroup,pPlayer,NULL);
		}

		pPlayer->Release();
		pPlayer = NULL;
		pGroupMember->Release();
		pGroupMember = NULL;

		pGroup->Lock();
		if (pBilink->IsEmpty())
		{
			pBilink = pGroup->m_bilinkMembership.GetNext();
		}
		else
		{
			pBilink = pBilink->GetNext();
		}
	}
	pGroup->Unlock();

Exit:
	DNASSERT(pPlayer == NULL);
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pPlayer)
	{
		pPlayer->Release();
		pPlayer = NULL;
	}
	goto Exit;
}


//
//	This will generate CREATE_GROUP messages for all of the auto-destruct groups owned by a particular player
//
#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::AutoCreateGroups"

HRESULT CNameTable::AutoCreateGroups(CNameTableEntry *const pPlayer)
{
	HRESULT			hResultCode;
	BOOL			fNotify;
	CBilink			*pBilink;
	CNameTableEntry	*pGroup;

	DPF(6,"Parameters: pPlayer [0x%p]",pPlayer);

	DNASSERT(pPlayer != NULL);

	pGroup = NULL;

	if (pPlayer->IsGroup())
	{
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	Lock();

	pBilink = m_bilinkGroups.GetNext();
	while (pBilink != &m_bilinkGroups)
	{
		pGroup = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pGroup->AddRef();
		Unlock();

		fNotify = FALSE;
		pGroup->Lock();
		if (	pGroup->IsAutoDestructGroup()
			&&	(pGroup->GetOwner() == pPlayer->GetDPNID())
			&&	!pGroup->IsAvailable()
			&&	!pGroup->IsDisconnecting()	)
		{
			pGroup->MakeAvailable();
			pGroup->NotifyAddRef();
			pGroup->NotifyAddRef();
			pGroup->SetInUse();
			fNotify = TRUE;
		}
		pGroup->Unlock();

		if (fNotify)
		{
			DNASSERT(!pGroup->IsAllPlayersGroup());
			DNUserCreateGroup(m_pdnObject,pGroup);

			pGroup->PerformQueuedOperations();

			//
			//	Attempt to populate group with connected players
			//
			PopulateGroup(pGroup);
		}

		pGroup->Release();
		pGroup = NULL;

		Lock();
		if (pBilink->IsEmpty())
		{
			//
			//	We were removed from the list of groups, so re-start at the beginning
			//
			pBilink = m_bilinkGroups.GetNext();
		}
		else
		{
			pBilink = pBilink->GetNext();
		}
	}

	Unlock();

Exit:
	DNASSERT(pGroup == NULL);
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pGroup)
	{
		pGroup->Release();
		pGroup = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::AutoDestructGroups"

HRESULT CNameTable::AutoDestructGroups(const DPNID dpnid)
{
	CNameTableEntry	*pNTEntry;
	CBilink			*pBilink;

	pNTEntry = NULL;

	Lock();
	pBilink = m_bilinkGroups.GetNext();
	while (pBilink != &m_bilinkGroups)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->AddRef();

		Unlock();

		if (pNTEntry->IsAutoDestructGroup() && (pNTEntry->GetOwner() == dpnid))
		{
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( DPNDESTROYGROUPREASON_AUTODESTRUCTED );
			}
			pNTEntry->Unlock();
			DeleteGroup(pNTEntry->GetDPNID(),NULL);
		}
		pNTEntry->Release();
		pNTEntry = NULL;

		Lock();

		//
		//	Avoid infinite loops by ensuring that we are not on a "disconnected" entry
		//
		if ((pBilink->GetNext() != &m_bilinkGroups) && (pBilink->GetNext() == pBilink))
		{
			//
			//	We have an invalid entry - need to restart
			//
			pBilink = m_bilinkGroups.GetNext();
		}
		else
		{
			//
			//	We either have a valid entry or we're finished
			//
			pBilink = pBilink->GetNext();
		}
	}
	Unlock();
	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::DecOutstandingConnections"

void CNameTable::DecOutstandingConnections( void )
{
	LONG		lRefCount;

	lRefCount = InterlockedDecrement(&m_lOutstandingConnections);
	DNASSERT(lRefCount >= 0);
	if (lRefCount == 0)
	{
		CAsyncOp	*pConnectParent;

		pConnectParent = NULL;

		//
		//	Clear connect handle from DirectNetObject if we are connected
		//
		DNEnterCriticalSection(&m_pdnObject->csDirectNetObject);
		if (m_pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
		{
			DPF(5,"Clearing connection operation from DirectNetObject");
			pConnectParent = m_pdnObject->pConnectParent;
			m_pdnObject->pConnectParent = NULL;
		}
		DNLeaveCriticalSection(&m_pdnObject->csDirectNetObject);

		if (pConnectParent)
		{
			pConnectParent->Release();
			pConnectParent = NULL;
		}
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::DumpNameTable"

void CNameTable::DumpNameTable(char *const Buffer)
{
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	char			*p;
// BUGBUG: [mgere] [xbox] Removed temporarily
#if 0
	DNASSERT(Buffer != NULL);
	p = Buffer;
	sprintf(p,"(empty)");
	pBilink = m_bilinkGroups.GetNext();
	while (pBilink != &m_bilinkGroups)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->DumpEntry(p);
		p += strlen(p);
		pBilink = pBilink->GetNext();
	}
	pBilink = m_bilinkPlayers.GetNext();
	while (pBilink != &m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->DumpEntry(p);
		p += strlen(p);
		pBilink = pBilink->GetNext();
	}
#endif
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::GetLocalPlayerRef"

HRESULT CNameTable::GetLocalPlayerRef( CNameTableEntry **const ppNTEntry )
{
	HRESULT		hResultCode;

	Lock();
	if (m_pLocalPlayer)
	{
		m_pLocalPlayer->AddRef();
		*ppNTEntry = m_pLocalPlayer;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_INVALIDPLAYER;
	}
	Unlock();
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::GetHostPlayerRef"

HRESULT CNameTable::GetHostPlayerRef( CNameTableEntry **const ppNTEntry )
{
	HRESULT		hResultCode;

	Lock();
	if (m_pHostPlayer)
	{
		m_pHostPlayer->AddRef();
		*ppNTEntry = m_pHostPlayer;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_INVALIDPLAYER;
	}
	Unlock();
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTable::GetAllPlayersGroupRef"

HRESULT CNameTable::GetAllPlayersGroupRef( CNameTableEntry **const ppNTEntry )
{
	HRESULT		hResultCode;

	Lock();
	if (m_pAllPlayersGroup)
	{
		m_pAllPlayersGroup->AddRef();
		*ppNTEntry = m_pAllPlayersGroup;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_INVALIDPLAYER;
	}
	Unlock();
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\msghandler.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Peer.cpp
 *  Content:    DNET peer interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/15/00	mjn		Created
 *	01/27/00	mjn		Added support for retention of receive buffers
 *	04/08/00	mjn		Save SP with connections
 *	04/11/00	mjn		Use CAsyncOp for ENUMs
 *	04/13/00	mjn		Use Protocol Interface VTBL
 *	04/14/00	mjn		DNPICompleteListen sets status and SyncEvent
 *	04/17/00	mjn		DNPICompleteEnumQuery just sets return value of AsyncOp
 *	04/18/00	mjn		CConnection tracks connection status better
 *	04/21/00	mjn		Ensure that RECEIVEs are from a valid connection before passing up notifications
 *				mjn		Disconnect CONNECTing end points on errors
 *	04/22/00	mjn		Consume notifications when closing or disconnecting.
 *	04/26/00	mjn		Removed DN_ASYNC_OP and related functions
 *	05/23/00	mjn		Call DNConnectToPeerFailed if ExistingPlayer connect to NewPlayer fails
 *	06/14/00	mjn		Allow only one connection to Host in DNPICompleteConnect()
 *	06/21/00	mjn		Modified DNSendMessage() and DNCreateSendParent() to use protocol voice bit
 *	06/22/00	mjn		Fixed DNPIIndicateReceive() to properly handle voice messages
 *				mjn		Cleaned up DNPIIndicateConnectionTerminated()
 *	06/24/00	mjn		Fixed DNPICompleteConnect()
 *	07/08/00	mjn		Only signal protocol shutdown event if it exists
 *	07/11/00	mjn		Fixed DNPIAddressInfoXXX() routines to ENUM,LISTEN,CONNECT multiple adapters with address info
 *	07/20/00	mjn		Modified CONNECT process, cleaned up refcount problems
 *	07/24/00	mjn		Decline EnumQueries if not host or if host is migrating
 *	07/28/00	mjn		Added code to validate return value from DPNICompleteSend()
 *	07/29/00	mjn		Fix calls to DNUserConnectionTerminated()
 *	07/30/00	mjn		Use DNUserTerminateSession() rather than DNUserConnectionTerminated()
 *	07/31/00	mjn		Added hrReason to DNTerminateSession()
 *				mjn		Added dwDestroyReason to DNHostDisconnect()
 *	08/02/00	mjn		Pass received voice messages through DNReceiveUserData()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added m_bilinkActiveList to CAsyncOp
 *	08/15/00	mjn		Call DNConnectToHostFailed() when connecting player's connection to host drops
 *	08/16/00	mjn		Modified IndicateConnect() and CompleteConnect() to determine SP directly from AsyncOps
 *	08/23/00	mjn		Unregister with DPNSVR when LISTENs terminate
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/06/00	mjn		Fixed DNPIIndicateConnectionTerminated() to better handle disconnects from partially connected players
 *	09/14/00	mjn		Release Protocol refcounts in completions
 *	09/21/00	mjn		Disconnect duplicate connections to Host player in DNPICompleteConnect()
 *	09/29/00	mjn		AddRef/Release locks in DNPIIndicateReceive()
 *	09/30/00	mjn		AddRef/Release locks in DNPIIndicateEnumQuery(),DNPIIndicateEnumResponse()
 *	10/11/00	mjn		Cancel outstanding CONNECTs if one succeeds
 *	10/17/00	mjn		Fixed clean up for unreachable players
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateListenTerminated"

HRESULT DNPIIndicateListenTerminated(void *const pvUserContext,
									 void *const pvEndPtContext,
									 const HRESULT hr)
{
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;

	DPF(6,"Parameters: pvEndPtContext [0x%p], hr [0x%lx]",
			pvEndPtContext,hr);

	DNASSERT(pvUserContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateEnumQuery"

HRESULT DNPIIndicateEnumQuery(void *const pvUserContext,
							  void *const pvEndPtContext,
							  const HANDLE hCommand,
							  void *const pvEnumQueryData,
							  const DWORD dwEnumQueryDataSize)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;
	CNameTableEntry	*pLocalPlayer;
	BOOL			fReleaseLock;

	DPF(6,"Parameters: pvEndPtContext [0x%p], hCommand [0x%p], pvEnumQueryData [0x%p], dwEnumQueryDataSize [%ld]",
			pvEndPtContext,hCommand,pvEnumQueryData,dwEnumQueryDataSize);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvEndPtContext != NULL);

	pLocalPlayer = NULL;
	fReleaseLock = FALSE;

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvEndPtContext);

	//
	//	Prevent close while in this call-back
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

	//
	//	Don't perform this if host migrating
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) == DPN_OK)
	{
		if (pLocalPlayer->IsHost())
		{
#pragma TODO(minara,"The protocol should ensure that the LISTEN does not complete until this call-back returns")
#pragma TODO(minara,"As the context value (AsyncOp) needs to be valid !")
			DNProcessEnumQuery( pdnObject, pAsyncOp, reinterpret_cast<const PROTOCOL_ENUM_DATA*>( pvEnumQueryData ) );
		}
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}

	hResultCode = DPN_OK;

Exit:
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateEnumResponse"

HRESULT DNPIIndicateEnumResponse(void *const pvUserContext,
								 const HANDLE hCommand,
								 void *const pvCommandContext,
								 void *const pvEnumResponseData,
								 const DWORD dwEnumResponseDataSize)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;
	BOOL			fReleaseLock;

	DPF(6,"Parameters: hCommand [0x%p], pvCommandContext [0x%p], pvEnumResponseData [0x%p], dwEnumResponseDataSize [%ld]",
			hCommand,pvCommandContext,pvEnumResponseData,dwEnumResponseDataSize);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	fReleaseLock = FALSE;

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	//
	//	Prevent close while in this call-back
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

#pragma TODO(minara,"The protocol should ensure that the ENUM does not complete until this call-back returns")
#pragma TODO(minara,"As the context value (AsyncOp) needs to be valid !")
	DNProcessEnumResponse( pdnObject, pAsyncOp, reinterpret_cast<const PROTOCOL_ENUM_RESPONSE_DATA*>( pvEnumResponseData ) );

	hResultCode = DPN_OK;

Exit:
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}



//
//	When a new connection is indicated by the Protocol layer, we will perform some basic validation,
//	and then create a CConnection object for it
//

#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateConnect"

HRESULT DNPIIndicateConnect(void *const pvUserContext,
							void *const pvListenContext,
							const HANDLE hEndPt,
							void **const ppvEndPtContext)
{
	HRESULT				hResultCode;
	CConnection			*pConnection;
	DIRECTNETOBJECT		*pdnObject;

#pragma TODO( minara, "Decline connections to non-hosting players and peers who are not expecting them")

	DPF(6,"Parameters: pvListenContext [0x%p], hEndPt [0x%p], ppvEndPtContext [0x%p]",
			pvListenContext,hEndPt,ppvEndPtContext);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvListenContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	
	pConnection = NULL;

	//
	//	Allocate and set up a CConnection object and hand a reference to the Protocol
	//
	if ((hResultCode = ConnectionNew(pdnObject,&pConnection)) != DPN_OK)
	{
		DPFERR("Could not get new connection");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		DebugBreak();
		goto Failure;
	}
	pConnection->SetStatus( CONNECTING );
	pConnection->SetEndPt(hEndPt);
	DNASSERT( (static_cast<CAsyncOp*>(pvListenContext))->GetParent() != NULL);
	DNASSERT( (static_cast<CAsyncOp*>(pvListenContext))->GetParent()->GetSP() != NULL);
	pConnection->SetSP((static_cast<CAsyncOp*>(pvListenContext))->GetParent()->GetSP());
	pConnection->AddRef();
	*ppvEndPtContext = pConnection;

	if (pdnObject->dwFlags & (DN_OBJECT_FLAG_CLOSING | DN_OBJECT_FLAG_DISCONNECTING))
	{
		DPFERR("CONNECT indicated while closing or disconnecting");
		DNPerformDisconnect(pdnObject,pConnection,hEndPt);
		goto Failure;
	}

	DNASSERT(pdnObject->NameTable.GetLocalPlayer() != NULL);
	if (pdnObject->NameTable.GetLocalPlayer()->IsHost())
	{
		// This connect was detected by a host player
		DPF(7,"Host received connection attempt");
	}
	else
	{
		// This connect was detected by a peer player (should be expecting a connection)
		DPF(7,"Non-Host player received connection attempt");
	}

	//
	//	Add this entry to the bilink of indicated connections.  When we receive more info,
	//	or this connection is terminated, we will remove this entry from the bilink.
	//	This will enable us to clean up properly.
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	pConnection->AddRef();
	pConnection->m_bilinkIndicated.InsertBefore(&pdnObject->m_bilinkIndicated);
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	pConnection->Release();
	pConnection = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateDisconnect"

HRESULT DNPIIndicateDisconnect(void *const pvUserContext,
							   void *const pvEndPtContext)
{
	HRESULT			hResultCode;
	CConnection		*pConnection;
	DIRECTNETOBJECT	*pdnObject;
	CNameTableEntry	*pNTEntry;

	DPF(6,"Parameters: pvEndPtContext [0x%p]",
			pvEndPtContext);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvEndPtContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pConnection = static_cast<CConnection*>(pvEndPtContext);

	//
	//	Mark the connection as DISCONNECTing so that we don't use it any more
	//
	pConnection->Lock();
	pConnection->SetStatus( DISCONNECTING );
	pConnection->Unlock();

	if (pConnection->GetDPNID() == 0)
	{
		if (pdnObject->NameTable.GetLocalPlayer() && pdnObject->NameTable.GetLocalPlayer()->IsHost())
		{
			DPF(7,"Joining player has issued a disconnect to Host (local) player");
		}
		else
		{
			DPF(7,"Host has issued a disconnect to Joining (local) player");
		}
	}
	else
	{
		DNASSERT(!(pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT));

		if (pdnObject->NameTable.GetLocalPlayer() && pdnObject->NameTable.GetLocalPlayer()->IsHost())
		{
			DPF(7,"Connected player has issued a disconnect to Host (local) player");
		}
		else
		{
			DPF(7,"Connected player has issued a disconnect to local player");
		}

		//
		//	Mark this player for normal destruction since they disconnected and are playing nice
		//
		if ((hResultCode = pdnObject->NameTable.FindEntry(pConnection->GetDPNID(),&pNTEntry)) == DPN_OK)
		{
			pNTEntry->Lock();
			if (pNTEntry->GetDestroyReason() == 0)
			{
				pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
			}
			pNTEntry->Unlock();
			pNTEntry->Release();
			pNTEntry = NULL;
		}
	}

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateConnectionTerminated"

HRESULT DNPIIndicateConnectionTerminated(void *const pvUserContext,
										 void *const pvEndPtContext,
										 const HRESULT hr)
{
	HRESULT			hResultCode;
	CConnection		*pConnection;
	DIRECTNETOBJECT	*pdnObject;
	BOOL			fWasConnecting;

	DPF(6,"Parameters: pvEndPtContext [0x%p], hr [0x%lx]",pvEndPtContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvEndPtContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pConnection = static_cast<CConnection*>(pvEndPtContext);

	//
	//	pConnection should still have at least 1 reference on it at this stage since
	//	INDICATE_CONNECTION_TERMINATED is supposed to be the final release for it.
	//	All outstanding SENDs and RECEIVEs should have already been processed.
	//

	fWasConnecting = FALSE;
	pConnection->Lock();
	if (pConnection->IsConnecting())
	{
		fWasConnecting = TRUE;
	}
	pConnection->SetStatus( INVALID );
	pConnection->Unlock();

	//
	//	Remove this connection from the indicated connection list
	//
	DNEnterCriticalSection(&pdnObject->csConnectionList);
	if (!pConnection->m_bilinkIndicated.IsEmpty())
	{
		pConnection->Release();
	}
	pConnection->m_bilinkIndicated.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csConnectionList);

	//
	//	If we are a client (in client server), and the server has disconnected from us, we have to shut down
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
	{
		if (fWasConnecting)
		{
			DPF(7,"Server disconnected from local connecting client - failing connect");
		}
		else
		{
			DPF(7,"Server disconnected from local client - shutting down");

			//
			//	Only inform the user if they are IN the session
			//
			if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
			{
				DNUserTerminateSession(pdnObject,DPNERR_CONNECTIONLOST,NULL,0);
			}
			DNTerminateSession(pdnObject,DPNERR_CONNECTIONLOST);
		}
	}
	else if (pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER)
	{
		if (fWasConnecting || (pConnection->GetDPNID() == 0))
		{
			DPF(7,"Unconnected client has disconnected from server");
		}
		else
		{
			CNameTableEntry	*pNTEntry;
			DWORD			dwReason;

			pNTEntry = NULL;

			//
			//	If the destruction code has not been set, mark as CONNECTIONLOST
			//
			if ((hResultCode = pdnObject->NameTable.FindEntry(pConnection->GetDPNID(),&pNTEntry)) == DPN_OK)
			{
				pNTEntry->Lock();
				if (pNTEntry->GetDestroyReason() == 0)
				{
					pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_CONNECTIONLOST );
				}
				dwReason = pNTEntry->GetDestroyReason();
				pNTEntry->Unlock();
				pNTEntry->Release();
				pNTEntry = NULL;
			}

			DNHostDisconnect(pdnObject,pConnection->GetDPNID(),dwReason);
		}
	}
	else //	DN_OBJECT_FLAG_PEER
	{
		DNASSERT( pdnObject->dwFlags & DN_OBJECT_FLAG_PEER );

		if (fWasConnecting || (pConnection->GetDPNID() == 0))
		{
			DPF(7,"Unconnected peer has disconnected from local peer");
			CAsyncOp	*pConnectParent;

			pConnectParent = NULL;

			DNEnterCriticalSection(&pdnObject->csDirectNetObject);
			if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING)
			{
				pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_CONNECTED|DN_OBJECT_FLAG_CONNECTING|DN_OBJECT_FLAG_HOST_CONNECTED));
				if (pdnObject->pConnectParent)
				{
					pConnectParent = pdnObject->pConnectParent;
					pdnObject->pConnectParent = NULL;
				}
				if( pdnObject->pIDP8ADevice )
				{
					pdnObject->pIDP8ADevice->Release();
					pdnObject->pIDP8ADevice = NULL;
				}
				if( pdnObject->pConnectAddress )
				{
					pdnObject->pConnectAddress->Release();
					pdnObject->pConnectAddress = NULL;
				}
			}
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

			if (pConnectParent)
			{
				pConnectParent->Release();
				pConnectParent = NULL;
			}

			DNASSERT(pConnectParent == NULL);
		}
		else
		{
			CNameTableEntry	*pNTEntry;
			CNameTableEntry	*pLocalPlayer;
			DWORD			dwReason;

			pNTEntry = NULL;
			pLocalPlayer = NULL;

			//
			//	If the destruction code has not been set, mark as CONNECTIONLOST
			//
			if ((hResultCode = pdnObject->NameTable.FindEntry(pConnection->GetDPNID(),&pNTEntry)) == DPN_OK)
			{
				pNTEntry->Lock();
				if (pNTEntry->GetDestroyReason() == 0)
				{
					pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_CONNECTIONLOST );
				}
				dwReason = pNTEntry->GetDestroyReason();
				pNTEntry->Unlock();
				pNTEntry->Release();
				pNTEntry = NULL;
			}

			//
			//	Based on who we are, and who's disconnecting, we will have different behaviour
			//
			if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef(&pLocalPlayer)) == DPN_OK)
			{
				if (pLocalPlayer->IsHost())
				{
					DPF(7,"Connected peer has disconnected from Host");
					DNHostDisconnect(pdnObject,pConnection->GetDPNID(),dwReason);
				}
				else
				{
					DPF(7,"Peer has disconnected from non-Host peer");
					DNPlayerDisconnectNew(pdnObject,pConnection->GetDPNID());
				}
				pLocalPlayer->Release();
				pLocalPlayer = NULL;
			}
		}
	}

	pConnection->Release();
	pConnection = NULL;

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIIndicateReceive"

HRESULT DNPIIndicateReceive(void *const pvUserContext,
							void *const pvEndPtContext,
							void *const pvData,
							const DWORD dwDataSize,
							const HANDLE hBuffer,
							const DWORD dwFlags)
{
	HRESULT		hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	void			*pvInternalData;
	DWORD			dwInternalDataSize;
	CConnection		*pConnection;
	DWORD			*pdwMsgId;
	BOOL 			fReleaseLock;

	DPF(6,"Parameters: pvEndPtContext [0x%p], pvData [0x%p], dwDataSize [%ld], hBuffer [0x%p], dwFlags [0x%lx]",
			pvEndPtContext,pvData,dwDataSize,hBuffer,dwFlags);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvEndPtContext != NULL);
	DNASSERT(pvData != NULL);
	DNASSERT(dwDataSize != 0);
	DNASSERT(hBuffer != NULL);

	fReleaseLock = FALSE;
	
	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pConnection = static_cast<CConnection*>(pvEndPtContext);

	//
	//	Prevent close while in this call-back
	//
	if ((hResultCode = DNAddRefLock(pdnObject)) != DPN_OK)
	{
		hResultCode = DPN_OK;
		goto Failure;
	}
	fReleaseLock = TRUE;

	//
	//	Ensure that this is a valid connection
	//
	if (!pConnection->IsConnected() && !pConnection->IsConnecting())
	{
		hResultCode = DPN_OK;
		goto Failure;
	}

	pConnection->AddRef();

	if ((dwFlags & DN_SENDFLAGS_SET_USER_FLAG) && !(dwFlags & DN_SENDFLAGS_SET_USER_FLAG_TWO))
	{
		//
		//	Internal message
		//
		DPF(7,"Received INTERNAL message");

		DNASSERT(dwDataSize >= sizeof(DWORD));
		pdwMsgId = static_cast<DWORD*>(pvData);
		dwInternalDataSize = dwDataSize - sizeof(DWORD);
		if (dwInternalDataSize > 0)
		{
			pvInternalData = static_cast<void*>(static_cast<BYTE*>(pvData) + sizeof(DWORD));
		}
		else
		{
			pvInternalData = NULL;
		}

		hResultCode = DNProcessInternalOperation(	pdnObject,
													*pdwMsgId,
													pvInternalData,
													dwInternalDataSize,
													pConnection,
													hBuffer,
													NULL );
	}
	else
	{
		//
		//	User or voice message
		//
		DPF(7,"Received USER or Voice message");

		hResultCode = DNReceiveUserData(pdnObject,
										pConnection->GetDPNID(),
										static_cast<BYTE*>(pvData),
										dwDataSize,
										hBuffer,
										NULL,
										0,
										dwFlags);
	}

	//
	//	Only allow DPNERR_PENDING or DPN_OK
	//
	if (hResultCode != DPNERR_PENDING)
	{
		hResultCode = DPN_OK;
	}

	pConnection->Release();
	pConnection = NULL;

Exit:
	if (fReleaseLock)
	{
		DNDecRefLock(pdnObject);
		fReleaseLock = FALSE;
	}

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteListen"

HRESULT DNPICompleteListen(void *const pvUserContext,
						   void **const ppvCommandContext,
						   const HRESULT hr,
						   const HANDLE hEndPt)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	CAsyncOp	*pParent;
	DIRECTNETOBJECT	*pdnObject;

	DPF(6,"Parameters: ppvCommandContext [0x%p], hr [0x%lx], hEndPt [0x%p]",
			ppvCommandContext,hr,hEndPt);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(ppvCommandContext != NULL);
	DNASSERT(*ppvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(*ppvCommandContext);

	pParent = NULL;

	pAsyncOp->Lock();
	if (pAsyncOp->GetParent())
	{
		pAsyncOp->GetParent()->AddRef();
		pParent = pAsyncOp->GetParent();
	}
	pAsyncOp->Unlock();

	//
	//	Manually save hResult and set SyncEvent
	//
	DNASSERT(pAsyncOp->GetResultPointer() != NULL);
	DNASSERT(pAsyncOp->GetSyncEvent() != NULL);
	*(pAsyncOp->GetResultPointer()) = hr;
	pAsyncOp->GetSyncEvent()->Set();

	//
	//	If there was an SP parent, we will check to see if this is the last completion and then set the
	//	parent's SP listen event (if it exists)
	//
	if (pParent)
	{
		DN_LISTEN_OP_DATA	*pListenOpData;

		if (pParent->GetOpData())
		{
			pListenOpData = static_cast<DN_LISTEN_OP_DATA*>(pParent->GetOpData());
			DNASSERT( pListenOpData->dwCompleteAdapters < pListenOpData->dwNumAdapters );
			pListenOpData->dwCompleteAdapters++;
			if (pListenOpData->dwCompleteAdapters == pListenOpData->dwNumAdapters)
			{
				if (pListenOpData->pSyncEvent)
				{
					pListenOpData->pSyncEvent->Set();
					pListenOpData->pSyncEvent = NULL;
				}
			}
		}
		pParent->Release();
		pParent = NULL;
	}

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteListenTerminate"

HRESULT DNPICompleteListenTerminate(void *const pvUserContext,
									void *const pvCommandContext,
									const HRESULT hr)
{
	HRESULT		hResultCode;
	CAsyncOp	*pAsyncOp;
	BOOL		fUnregister;
	DIRECTNETOBJECT	*pdnObject;

	DPF(6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	//
	//	Indicate complete and remove from active list
	//
	pAsyncOp->Lock();
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	DNASSERT(pAsyncOp->IsChild());
	pAsyncOp->Orphan();
	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteEnumQuery"

HRESULT DNPICompleteEnumQuery(void *const pvUserContext,
							  void *const pvCommandContext,
							  const HRESULT hr)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;

	DPF(6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	//
	//	Indicate complete and remove from active list
	//
	pAsyncOp->Lock();
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	pAsyncOp->SetResult( hr );
	pAsyncOp->Orphan();
	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

	//
	//	Release Protocol reference
	//
	DNProtocolRelease(pdnObject);

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteEnumResponse"

HRESULT DNPICompleteEnumResponse(void *const pvUserContext,
								 void *const pvCommandContext,
								 const HRESULT hr)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;

	DPF(6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	if (pAsyncOp->IsChild())
	{
		DNASSERT(FALSE);
		pAsyncOp->Orphan();
	}
	if (pAsyncOp->GetHandle())
	{
		pdnObject->HandleTable.Destroy(pAsyncOp->GetHandle());
	}
	pAsyncOp->SetResult( hr );
	pAsyncOp->Release();
	pAsyncOp = NULL;

	//
	//	Release protocol reference
	//
	DNProtocolRelease(pdnObject);

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteConnect"

HRESULT DNPICompleteConnect(void *const pvUserContext,
							void *const pvCommandContext,
							const HRESULT hrProt,
							const HANDLE hEndPt,
							void **const ppvEndPtContext)
{
	HRESULT				hResultCode;
	HRESULT				hr;
	CAsyncOp			*pAsyncOp;
	CConnection			*pConnection;
	DIRECTNETOBJECT		*pdnObject;
	IDirectPlay8Address	*pIDevice;

	DPF(6,"Parameters: pvCommandContext [0x%p], hrProt [0x%lx], hEndPt [0x%p], ppvEndPtContext [0x%p]",
			pvCommandContext,hrProt,hEndPt,ppvEndPtContext);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);
	DNASSERT( (hrProt != DPN_OK) || (ppvEndPtContext != NULL) );

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);
	pConnection = NULL;
	pIDevice = NULL;

	//
	//	Re-map DPNERR_ABORTED (!)
	//
#pragma BUGBUG( minara, "Get Evan to change this so we do not have to re-map it !" )
	if (hrProt == DPNERR_ABORTED)
	{
		hr = DPNERR_USERCANCEL;
	}
	else
	{
		hr = hrProt;
	}

	//
	//	Indicate complete and remove from active list
	//
	pAsyncOp->Lock();
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	//
	//	If there is a DPNID associated with this operation, then we are an ExistingPlayer
	//	connecting with a NewPlayer.  If there is no DPNID, then we are a NewPlayer connecting
	//	to the Host.
	//

	if (pAsyncOp->GetDPNID())
	{
		DPF(7,"CONNECT completed for existing player connecting to NewPlayer");

		//
		//	We are an existing player attempting to CONNECT to a NewPlayer.
		//	If this CONNECT failed, we must inform the Host
		//
		if (hr != DPN_OK)
		{
			DPFERR("Could not CONNECT to NewPlayer");
			DisplayDNError(0,hr);
			DNConnectToPeerFailed(pdnObject,pAsyncOp->GetDPNID());
			goto Failure;
		}

		//
		//	Allocate and set up a CConnection object and hand a reference to the Protocol
		//
		DNASSERT(pAsyncOp->GetSP() != NULL);
		if ((hResultCode = ConnectionNew(pdnObject,&pConnection)) != DPN_OK)
		{
			DPFERR("Could not get new connection");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pConnection->SetStatus( CONNECTING );
		pConnection->SetEndPt(hEndPt);
		pConnection->SetSP(pAsyncOp->GetSP());
		pConnection->AddRef();
		*ppvEndPtContext = pConnection;

		//
		//	Send this player's DNID to the connecting player to enable name table entry
		//
		if ((hResultCode = DNConnectToPeer3(pdnObject,pAsyncOp->GetDPNID(),pConnection)) != DPN_OK)
		{
			DPFERR("Could not connect to NewPlayer");
			DisplayDNError(0,hr);
			DNPerformDisconnect(pdnObject,pConnection,hEndPt);
			DNConnectToPeerFailed(pdnObject,pAsyncOp->GetDPNID());
			goto Failure;
		}
	}
	else
	{
		DPF(7,"CONNECT completed for NewPlayer connecting to Host");

		//
		//	We are the NewPlayer attempting to CONNECT to the Host.
		//

		//
		//	If this CONNECT succeeded, we will cancell any other CONNECTs.
		//	If this CONNECT failed, we will set the result code on the AsyncOp
		//	and release it.
		//
		if (hr == DPN_OK)
		{
			CAsyncOp	*pParent;

			pParent = NULL;

			pAsyncOp->Lock();
			if (pAsyncOp->GetParent())
			{
				pAsyncOp->GetParent()->AddRef();
				pParent = pAsyncOp->GetParent();
			}
			pAsyncOp->Unlock();
			if (pParent)
			{
				DNCancelChildren(pdnObject,pParent);
				pParent->Release();
				pParent = NULL;
			}

			DNASSERT(pParent == NULL);
		}
		else
		{
			DPFERR("Could not CONNECT to Host");
			DisplayDNError(0,hr);
			pAsyncOp->SetResult( hr );
			goto Failure;
		}

		//
		//	Allocate and set up a CConnection object and hand a reference to the Protocol
		//
		DNASSERT(pAsyncOp->GetSP() != NULL);
		if ((hResultCode = ConnectionNew(pdnObject,&pConnection)) != DPN_OK)
		{
			DPFERR("Could not get new connection");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pConnection->SetStatus( CONNECTING );
		pConnection->SetEndPt(hEndPt);
		pConnection->SetSP(pAsyncOp->GetSP());
		pConnection->AddRef();
		*ppvEndPtContext = pConnection;

		//
		//	Ensure that this is the first CONNECT to succeed.
		//	If it isn't we will just drop the connection.
		//
		DNEnterCriticalSection(&pdnObject->csDirectNetObject);
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_CONNECTED)
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			DPFERR("Connect already established - disconnecting");
			DNPerformDisconnect(pdnObject,pConnection,hEndPt);
			hResultCode = DPN_OK;
			goto Failure;
		}
		pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_CONNECTED;
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

		// rodtoll: Modifying so we always store this information so that when we update
		// 		  lobby settings we return the device we actually connected on for clients

		/*
		//
		//	For Peer-Peer, we will need the device address we connected on so that
		//	we can CONNECT to new players later on.
		//
		if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
		{*/
			if ((hResultCode = DNGetLocalDeviceAddress(pdnObject,hEndPt,&pIDevice)) != DPN_OK)
			{
				DPFERR("Could not determine local address");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				DNPerformDisconnect(pdnObject,pConnection,hEndPt);
				goto Failure;
			}
			pIDevice->AddRef();
			pdnObject->pIDP8ADevice = pIDevice;

			pIDevice->Release();
			pIDevice = NULL;
		// }

		//
		//	Send player and application info for NewPlayer connecting to Host
		//
		if ((hResultCode = DNConnectToHost1(pdnObject,pConnection)) != DPN_OK)
		{
			DPFERR("Could not CONNECT to Host");
			DisplayDNError(0,hResultCode);
			DNPerformDisconnect(pdnObject,pConnection,hEndPt);
			goto Failure;
		}
	}
	pAsyncOp->Lock();
	pAsyncOp->SetResult( DPN_OK );
	pAsyncOp->Unlock();
	pAsyncOp->Release();
	pAsyncOp = NULL;

	pConnection->Release();
	pConnection = NULL;

	hResultCode = DPN_OK;

Exit:
	//
	//	Release protocol reference
	//
	DNProtocolRelease(pdnObject);

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pAsyncOp)
	{
		pAsyncOp->Release();
		pAsyncOp = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pIDevice)
	{
		pIDevice->Release();
		pIDevice = NULL;
	}
	goto Exit;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteDisconnect"

HRESULT DNPICompleteDisconnect(void *const pvUserContext,
							   void *const pvCommandContext,
							   const HRESULT hr)
{
	HRESULT			hResultCode;
	CAsyncOp		*pAsyncOp;
	DIRECTNETOBJECT	*pdnObject;

	DPF(6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	//
	//	If this completed successfully, we can remove the reference on the connection held by the Protocol
	//
	if (hr == DPN_OK)
	{
		pAsyncOp->Lock();
		if (pAsyncOp->GetConnection())
		{
			pAsyncOp->GetConnection()->Release();
		}
		pAsyncOp->Unlock();
	}

	pAsyncOp->SetResult( hr );
	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

	//
	//	Release Protocol reference
	//
	DNProtocolRelease(pdnObject);

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPICompleteSend"

HRESULT DNPICompleteSend(void *const pvUserContext,
						 void *const pvCommandContext,
						 const HRESULT hr)
{
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	CAsyncOp		*pAsyncOp;

	DPF(6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	//
	//	Indicate complete and remove from active list
	//
	pAsyncOp->Lock();
	pAsyncOp->SetComplete();
	pAsyncOp->Unlock();

	DNEnterCriticalSection(&pdnObject->csActiveList);
	pAsyncOp->m_bilinkActiveList.RemoveFromList();
	DNLeaveCriticalSection(&pdnObject->csActiveList);

	switch( hr )
	{
		case	DPN_OK:
		case	DPNERR_ABORTED:
#pragma TODO( minara, "remove DPNERR_ABORTED" )
		case	DPNERR_CONNECTIONLOST:
		case	DPNERR_GENERIC:	
		case	DPNERR_OUTOFMEMORY:
		case	DPNERR_TIMEDOUT:
		case	DPNERR_USERCANCEL:
			{
				break;
			}

		default:
			{
				DNASSERT(FALSE);	// unexpected return code !
				break;
			}
	}

	if (pAsyncOp->IsChild())
	{
		pAsyncOp->Orphan();
	}
	pAsyncOp->SetResult( hr );
	pAsyncOp->Release();
	pAsyncOp = NULL;

	hResultCode = DPN_OK;

	//
	//	Release Protocol reference
	//
	DNProtocolRelease(pdnObject);

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIAddressInfoConnect"

HRESULT DNPIAddressInfoConnect(void *const pvUserContext,
							   void *const pvCommandContext,
							   const HRESULT hr,
							   IDirectPlay8Address *const pHostAddress,
							   IDirectPlay8Address *const pDeviceAddress )
{
	static DWORD	dwFoo = 12;
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	CAsyncOp		*pAsyncOp;
#ifdef	DEBUG
	CHAR			DP8ABuffer[512];
	DWORD			DP8ASize;
#endif

	DPF(6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DPF(7,"hr [0x%lx]",hr);
#ifdef	DEBUG
	DP8ASize = 512;
	pHostAddress->GetURLA(DP8ABuffer,&DP8ASize);
	DPF(7,"Host address [%s]",DP8ABuffer);

	DP8ASize = 512;
	pDeviceAddress->GetURLA(DP8ABuffer,&DP8ASize);
	DPF(7,"Device address [%s]",DP8ABuffer);
#endif

	if (hr == DPN_OK)
	{
		hResultCode = DNPerformNextConnect(pdnObject,pAsyncOp,pHostAddress,pDeviceAddress);
	}

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIAddressInfoEnum"

HRESULT DNPIAddressInfoEnum(void *const pvUserContext,
							void *const pvCommandContext,
							const HRESULT hr,
							IDirectPlay8Address *const pHostAddress,
							IDirectPlay8Address *const pDeviceAddress )
{
	static DWORD	dwFoo = 11;
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	CAsyncOp		*pAsyncOp;

#ifdef	DEBUG
	CHAR			DP8ABuffer[512];
	DWORD			DP8ASize;
#endif

	DPF(6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DPF(7,"hr [0x%lx]",hr);
#ifdef	DEBUG
	DP8ASize = 512;
	pHostAddress->GetURLA(DP8ABuffer,&DP8ASize);
	DPF(7,"Host address [%s]",DP8ABuffer);

	DP8ASize = 512;
	pDeviceAddress->GetURLA(DP8ABuffer,&DP8ASize);
	DPF(7,"Device address [%s]",DP8ABuffer);
#endif

	if (hr == DPN_OK)
	{
		//
		//	Crack open next enum only if not closing
		//
		if ((hResultCode = DNAddRefLock(pdnObject)) == DPN_OK)
		{
			hResultCode = DNPerformNextEnumQuery(pdnObject,pAsyncOp,pHostAddress,pDeviceAddress);
			DNDecRefLock(pdnObject);
		}
	}

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNPIAddressInfoListen"

HRESULT DNPIAddressInfoListen(void *const pvUserContext,
							  void *const pvCommandContext,
							  const HRESULT hr,
							  IDirectPlay8Address *const pDeviceAddress )
{
	static DWORD	dwFoo = 13;
	HRESULT			hResultCode;
	DIRECTNETOBJECT	*pdnObject;
	CAsyncOp		*pAsyncOp;
#ifdef	DEBUG
	CHAR			DP8ABuffer[512];
	DWORD			DP8ASize;
#endif

	DPF(6,"Parameters: pvCommandContext [0x%p], hr [0x%lx]",
			pvCommandContext,hr);

	DNASSERT(pvUserContext != NULL);
	DNASSERT(pvCommandContext != NULL);

	pdnObject = static_cast<DIRECTNETOBJECT*>(pvUserContext);
	pAsyncOp = static_cast<CAsyncOp*>(pvCommandContext);

	DPF(7,"hr [0x%lx]",hr);
#ifdef	DEBUG
	DP8ASize = 512;
	pDeviceAddress->GetURLA(DP8ABuffer,&DP8ASize);
	DPF(7,"Device address [%s]",DP8ABuffer);
#endif

	if (hr == DPN_OK)
	{
		hResultCode = DNPerformNextListen(pdnObject,pAsyncOp,pDeviceAddress);
	}

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProtocolAddRef"

void DNProtocolAddRef(DIRECTNETOBJECT *const pdnObject)
{
	LONG	lRefCount;

	DPF(8,"Parameters: (none)");

	lRefCount = InterlockedIncrement(&pdnObject->lProtocolRefCount);

	DPF(8,"Returning");
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNProtocolRelease"

void DNProtocolRelease(DIRECTNETOBJECT *const pdnObject)
{
	LONG	lRefCount;

	DPF(8,"Parameters: (none)");

	lRefCount = InterlockedDecrement(&pdnObject->lProtocolRefCount);

	DNASSERT(lRefCount >= 0);

	if (lRefCount == 0)
	{
		DPF(9,"Signalling protocol shutdown !");
		if (pdnObject->hProtocolShutdownEvent)
		{
			pdnObject->hProtocolShutdownEvent->Set();
		}
	}

	DPF(8,"Returning");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\migration.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Migration.cpp
 *  Content:    DNET Host Migration Routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/23/99	mjn		Created
 *	12/23/99	mjn		Fixed basic host migration
 *	12/28/99	mjn		Added DNCompleteOutstandingOperations
 *	12/28/99	mjn		Added NameTable version to Host migration message
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/04/00	mjn		Added code to allow outstanding ops to complete at host migration
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/11/00	mjn		Moved connect/disconnect stuff to Connect.h
 *	01/15/00	mjn		Replaced DN_COUNT_BUFFER with CRefCountBuffer
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/17/00	mjn		Generate DN_MSGID_HOST_MIGRATE at host migration
 *	01/19/00	mjn		Auto destruct groups at host migration
 *	01/24/00	mjn		Use DNNTUpdateVersion to update NameTable version
 *	01/25/00	mjn		Send dwLatestVersion to Host at migration
 *	01/25/00	mjn		Changed Host Migration to multi-step affair
 *	01/26/00	mjn		Implemented NameTable re-sync at host migration
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/04/00	mjn		Clean up NameTable to remove old entries
 *  03/25/00    rmt     Added calls into DPNSVR modules
 *  04/04/00	rmt		Added check for DPNSVR disable flag before attempting to register w/DPNSVR
 *	04/16/00	mjn		DNSendMessage() used CAsyncOp
 *	04/18/00	mjn		CConnection tracks connection status better
 *				mjn		Fixed player count problem
 *	04/19/00	mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	04/25/00	mjn		Fixed migration process to ensure use of CAsyncOp
 *				mjn		Migration calls CoInitialize()/CoUninitialize() before registering w/ DPNSVR
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	05/04/00	mjn		Ensure local player still in session for Host migration
 *	05/16/00	mjn		Do not take locks when clearing NameTable short-cut pointers
 *	06/25/00	mjn		Ignore players older than old Host when determining new Host in DNFindNewHost()
 *	07/06/00	mjn		Fixed locking problem in CNameTable::MakeLocalPlayer,MakeHostPlayer,MakeAllPlayersGroup
 *	07/07/00	mjn		Added shut down checks to migration code.
 *	07/20/00	mjn		Cleaned up leaking RefCountBuffers and added closing tests
 *	07/21/00	mjn		Added code in DNCheckReceivedAllVersions() to skip disconnecting players
 *  07/27/00	rmt		Bug #40882 - DPLSESSION_HOSTMIGRATED status update is not sent
 *	07/31/00	mjn		Added dwDestroyReason to DNHostDisconnect()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/05/00	mjn		Added pParent to DNSendGroupMessage and DNSendMessage()
 *				mjn		Added fInternal to DNPerformChildSend()
 *	08/06/00	mjn		Added CWorkerJob
 *	08/07/00	mjn		Handle integrity check requests during host migration
 *	08/08/00	mjn		Moved DN_NAMETABLE_OP_INFO to Message.h
 *	08/11/00	mjn		Added DN_OBJECT_FLAG_HOST_MIGRATING_2 to prevent multiple threads from passing DNCheckReceivedAllVersions()
 *	08/15/00	mjn		Perform LISTEN registration with DPNSVR in PerformHostMigration3()
 *	08/24/00	mjn		Replace DN_NAMETABLE_OP with CNameTableOp
 *	09/04/00	mjn		Added CApplicationDesc
 *	09/06/00	mjn		Fixed register with DPNSVR problem
 *	09/17/00	mjn		Split CNameTable.m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *	10/12/00	mjn		Ensure proper locks taken when traversing CNameTable::m_bilinkEntries
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE



//	DNFindNewHost
//
//	Find the new host from the entries in the NameTable.
//	This is based on version number of the players in the NameTable.  The player with
//		the oldest version number (after the old Host) will be the new Host.
//
//	DPNID	*pdpnidNewHost		New Host DNID

#undef DPF_MODNAME
#define DPF_MODNAME "DNFindNewHost"

HRESULT	DNFindNewHost(DIRECTNETOBJECT *const pdnObject,
					  DPNID *const pdpnidNewHost)
{
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pHostPlayer;
	HRESULT			hResultCode;
	DWORD			dwVersionNewHost;
	DWORD			dwVersionOldHost;
	DPNID			dpnidNewHost;

	DPF(6,"Parameters: pdpnidNewHost [0x%p]",pdpnidNewHost);

	DNASSERT(pdnObject != NULL);

	pNTEntry = NULL;
	pLocalPlayer = NULL;
	pHostPlayer = NULL;

	//
	//	Seed local player as new Host
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
	dpnidNewHost = pLocalPlayer->GetDPNID();
	dwVersionNewHost = pLocalPlayer->GetVersion();
	DPF(7,"First Host Candidate: dpnid [0x%lx], dwVersion [%ld]",dpnidNewHost,dwVersionNewHost);
	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	//
	//	Determine old host player version
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) == DPN_OK)
	{
		dwVersionOldHost = pHostPlayer->GetVersion();
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	else
	{
		dwVersionOldHost = 0;
	}

	//
	//	Lock down NameTable
	//
	pdnObject->NameTable.Lock();

	// Traverse NameTable to find player with next older version
	//	TODO - we should release the NameTable CS so that leaving players get updated in NameTable
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetVersion() < dwVersionNewHost))
		{
			//
			//	There are some conditions where we might have players older than the Host in the NameTable
			//	Consider the following: P1,P2,P3,P4 (P1 is Host)
			//		- P1, P2 drop
			//		- P3 detects drop of P1 and P2
			//		- P4 detects drop of P1 only (P2 may not yet have timed out)
			//		- P3 sends HOST_MIGRATE message to P4
			//		- P4 makes P3 new Host, but P2 is still in NameTable (at this stage)
			//		- P3 drops (P2's drop sill has not been detected!)
			//	We should therefore ignore all players older than the old Host,
			//
			if (pNTEntry->GetVersion() < dwVersionOldHost)
			{
				DPFERR("Found player older than old Host ! (Have we missed a drop ?)");
			}
			else
			{
				dpnidNewHost = pNTEntry->GetDPNID();
				dwVersionNewHost = pNTEntry->GetVersion();
				DPF(7,"Better Host Candidate: dpnid [0x%lx], dwVersion [%ld]",
						dpnidNewHost,dwVersionNewHost);
			}
		}
		pNTEntry->Unlock();
		pNTEntry = NULL;
		pBilink = pBilink->GetNext();
	}

	//
	//	Unlock NameTable
	//
	pdnObject->NameTable.Unlock();

	DPF(7,"Found New Host: dpnid [0x%lx], dwVersion [%ld]",dpnidNewHost,dwVersionNewHost);

	if (pdpnidNewHost)
		*pdpnidNewHost = dpnidNewHost;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	goto Exit;
}


//	DNPerformHostMigration1
//
//	Perform host migration to become the new Host.

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformHostMigration1"

HRESULT	DNPerformHostMigration1(DIRECTNETOBJECT *const pdnObject,
								const DPNID dpnidOldHost)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	CNameTableEntry		*pLocalPlayer;
	CPendingDeletion	*pPending;
	DN_INTERNAL_MESSAGE_HOST_MIGRATE	*pInfo;

	DPF(6,"Parameters: dpnidOldHost [0x%lx]",dpnidOldHost);

	DNASSERT(pdnObject != NULL);

	pLocalPlayer = NULL;
	pRefCountBuffer = NULL;
	pPending = NULL;
	pWorkerJob = NULL;

	//
	//	Need reference on local player
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get reference on LocalPlayer");
		goto Failure;
	}

	//
	//	Flag as performing host migration - ensure we're not already running this from another thread
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_MIGRATING;
	DNASSERT(pdnObject->pNewHost == NULL);
	pLocalPlayer->AddRef();
	pdnObject->pNewHost = pLocalPlayer;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Put this on the Outstanding operation list
	//
	if ((hResultCode = PendingDeletionNew(pdnObject,&pPending)) == DPN_OK)
	{
		pPending->SetDPNID( dpnidOldHost );

		DNEnterCriticalSection(&pdnObject->csNameTableOpList);
		pPending->m_bilinkPendingDeletions.InsertBefore(&pdnObject->m_bilinkPendingDeletions);
		DNLeaveCriticalSection(&pdnObject->csNameTableOpList);

		pPending = NULL;
	}

	//
	//	Make new host
	//
	pdnObject->NameTable.UpdateHostPlayer( pLocalPlayer );

	//
	//	Update NameTable operation list version
	//
	hResultCode = DNNTPlayerSendVersion(pdnObject);

	// Only need to proceed if we're not the only player left in the session
	if ((hResultCode = DNCheckReceivedAllVersions(pdnObject)) != DPN_OK)
	{
		// Inform other players of host migration
		DPF(7,"Informing other players of host migration");
		if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_HOST_MIGRATE),
				&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not create RefCountBuffer for Host Migration");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_HOST_MIGRATE*>(pRefCountBuffer->GetBufferAddress());
		pInfo->dpnidNewHost = pLocalPlayer->GetDPNID();
		pInfo->dpnidOldHost = dpnidOldHost;

		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
		{
			DPFERR("Could not create WorkerJob for Host Migration");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
		pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_HOST_MIGRATE );
		pWorkerJob->SetSendNameTableOperationVersion( 0 );
		pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pPending)
	{
		pPending->ReturnSelfToPool();
		pPending = NULL;
	}
	goto Exit;
}


//	DNPerformHostMigration2
//
//	Resynchronize NameTables of all connected players

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformHostMigration2"

HRESULT	DNPerformHostMigration2(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CBilink			*pBilink;
	CNameTableEntry	*pLocalPlayer;
	CNameTableEntry	*pNTEntry;
	CNameTableEntry	*pNTELatest;
	CConnection		*pConnection;
	DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP	*pInfo;

	DPF(6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	pRefCountBuffer = NULL;
	pLocalPlayer = NULL;
	pNTEntry = NULL;
	pNTELatest = NULL;
	pConnection = NULL;

	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	//
	//	See if we (Host player) have the latest NameTable
	//
	pLocalPlayer->AddRef();
	pNTELatest = pLocalPlayer;
	DPF(7,"Seed latest version [%ld] - player [0x%lx]",pNTELatest->GetLatestVersion(),pNTELatest->GetDPNID());

	pdnObject->NameTable.Lock();
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetLatestVersion() > pNTELatest->GetLatestVersion()))
		{
			//
			// Only want players we can actually reach !
			//
			CConnection	*pConnection;

			pConnection = NULL;

			pNTEntry->Unlock();
			if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
			{
				if (!pConnection->IsDisconnecting() && !pConnection->IsInvalid())
				{
					pNTELatest->Release();
					pNTEntry->AddRef();
					pNTELatest = pNTEntry;

					DPF(7,"New latest version [%ld] - player [0x%lx]",
							pNTELatest->GetLatestVersion(),pNTELatest->GetDPNID());
				}
				pConnection->Release();
				pConnection = NULL;
			}
		}
		else
		{
			pNTEntry->Unlock();
		}
		pNTEntry = NULL;

		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	if (!pNTELatest->IsLocal())
	{
		// Request missing entries from player w/ latest NameTable
		DPF(7,"Host DOES NOT have latest NameTable !");
		DPF(7,"Host has [%ld], player [0x%lx] has [%ld]",pLocalPlayer->GetLatestVersion(),
				pNTELatest->GetDPNID(),pNTELatest->GetLatestVersion());

		// Create REQ
		if ((hResultCode = RefCountBufferNew(pdnObject,
				sizeof(DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP),&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not create RefCount buffer for NameTable re-sync");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP*>(pRefCountBuffer->GetBufferAddress());
		pInfo->dwVersion = pLocalPlayer->GetLatestVersion() + 1;
		pInfo->dwVersionNotUsed = 0;

		// Send REQ
		if ((hResultCode = pNTELatest->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			hResultCode = DNSendMessage(pdnObject,
										pConnection,
										DN_MSG_INTERNAL_REQ_NAMETABLE_OP,
										pNTELatest->GetDPNID(),
										pRefCountBuffer->BufferDescAddress(),
										pRefCountBuffer,
										0,
										DN_SENDFLAGS_RELIABLE,
										NULL,
										NULL);
			if (hResultCode != DPNERR_PENDING)
			{
				DPFERR("Could not send NameTable re-sync REQ");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				goto Failure;
			}
			pConnection->Release();
			pConnection = NULL;
		}

		pRefCountBuffer->Release();	// Added 19/07/00 MJN - is this needed ?
		pRefCountBuffer = NULL;
	}
	else
	{
		DPF(7,"Host has latest NameTable - proceed with Host Migration");
		hResultCode = DNPerformHostMigration3(pdnObject,NULL);
	}

	pNTELatest->Release();
	pNTELatest = NULL;

	pLocalPlayer->Release();
	pLocalPlayer = NULL;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	if (pNTELatest)
	{
		pNTELatest->Release();
		pNTELatest = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	goto Exit;
}


//	DNPerformHostMigration3
//
//	Finish host migration.
//		- perform missing NameTable operations and pass them on
//		- send pending operations
//		- inform players that host migration is complete
//		- complete (local) outstanding async operations
//		- initiate new listen (if required) to handle enums on known port
//	As they say on the TTC, "All operations have returned to normal."

#undef DPF_MODNAME
#define DPF_MODNAME "DNPerformHostMigration3"

HRESULT	DNPerformHostMigration3(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg)
{
	HRESULT				hResultCode;
	CBilink				*pBilink;
	CNameTableEntry		**PlayerList;
	CNameTableEntry		*pNTEntry;
	CConnection			*pConnection;
	CPendingDeletion	*pPending;
	DWORD				dwNameTableVersion;
	DWORD				dw;
	DWORD				dwCount;
	DWORD				dwActual;
	CNameTableOp		*pNTOp;
	DN_NAMETABLE_OP_INFO	*pInfo;
	DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP	*pAck;

	DPF(6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);

	pNTOp = NULL;
	pNTEntry = NULL;
	pConnection = NULL;
	pPending = NULL;
	PlayerList = NULL;

	//
	//	Update missing NameTable operations on Host
	//
	if (pMsg != NULL)
	{
		pAck = static_cast<DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP*>(pMsg);
		DPF(7,"Number of missing NameTable entries [%ld]",pAck->dwNumEntries);
		pInfo = reinterpret_cast<DN_NAMETABLE_OP_INFO*>(pAck+1);
		for (dw = 0; dw < pAck->dwNumEntries ; dw++)
		{
			DPF(7,"Adding missing entry [%ld] of [%ld]",dw+1,pAck->dwNumEntries);
			hResultCode = DNNTAddOperation(	pdnObject,
											pInfo->dwMsgId,
											static_cast<void*>(reinterpret_cast<BYTE*>(pMsg) + pInfo->dwOpOffset),
											pInfo->dwOpSize,
											0 );
			if (hResultCode != DPN_OK)
			{
				DPFERR("Could not add missing NameTable operation - ignore and continue");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
			}
			pInfo++;
		}
	}

	//
	//	Update missing NameTable operations on other players
	//

	//
	//	Determine player list
	//
	dwCount = 0;
	dwActual = 0;
	pdnObject->NameTable.Lock();
	dwNameTableVersion = pdnObject->NameTable.GetVersion();
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetLatestVersion() < dwNameTableVersion))
		{
			dwCount++;
		}
		pNTEntry->Unlock();
		pNTEntry = NULL;

		pBilink = pBilink->GetNext();
	}
	if (dwCount)
	{
		if ((PlayerList = static_cast<CNameTableEntry**>(DNMalloc(dwCount * sizeof(CNameTableEntry*)))) == NULL)
		{
			DPFERR("Could not allocate target list");
			DNASSERT(FALSE);
			pdnObject->NameTable.Unlock();
			hResultCode = DPN_OK;
			goto Exit;
		}
		pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			pNTEntry->Lock();
			if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetLatestVersion() < dwNameTableVersion))
			{
				DNASSERT(dwActual < dwCount);
				pNTEntry->AddRef();
				PlayerList[dwActual] = pNTEntry;
				dwActual++;
			}
			pNTEntry->Unlock();
			pNTEntry = NULL;

			pBilink = pBilink->GetNext();
		}
	}
	pdnObject->NameTable.Unlock();

	//
	//	Send missing entries to players in player list
	//
	for (dwCount = 0 ; dwCount < dwActual ; dwCount++)
	{
		//
		//	Ensure player is reachable
		//
		if ((hResultCode = PlayerList[dwCount]->GetConnectionRef( &pConnection )) == DPN_OK)
		{
			if (!pConnection->IsDisconnecting() && !pConnection->IsInvalid())
			{
				DPF(7,"Player [0x%lx] is missing entries: dwLatestVersion [%ld] should be [%ld]",
						PlayerList[dwCount]->GetDPNID(),PlayerList[dwCount]->GetLatestVersion(),dwNameTableVersion);

				// Send required entries
				for (	dw = PlayerList[dwCount]->GetLatestVersion() + 1 ; dw <= dwNameTableVersion ; dw++ )
				{
					DPF(7,"Send entry [%ld] to player [0x%lx]",dw,PlayerList[dwCount]->GetDPNID());

					// Get entry to send
					pNTOp = NULL;
					if ((hResultCode = DNNTFindOperation(pdnObject,dw,&pNTOp)) != DPN_OK)
					{
						DPFERR("Could not retrieve NameTable operation - advance to next player");
						DisplayDNError(0,hResultCode);
						break;
					}

					hResultCode = DNSendMessage(pdnObject,
												pConnection,
												pNTOp->GetMsgId(),
												PlayerList[dwCount]->GetDPNID(),
												pNTOp->GetRefCountBuffer()->BufferDescAddress(),
												pNTOp->GetRefCountBuffer(),
												0,
												DN_SENDFLAGS_RELIABLE,
												NULL,
												NULL);
					if (hResultCode != DPNERR_PENDING)
					{
						DPFERR("Could not send missing NameTable entry - advance to next player");
						DisplayDNError(0,hResultCode);
						DNASSERT(FALSE);
						break;
					}
				} // for
			} // if
			pConnection->Release();
			pConnection = NULL;
		} // if
		PlayerList[dwCount]->Release();
		PlayerList[dwCount] = NULL;
	}
	if (PlayerList != NULL)
	{
		DNFree(PlayerList);
		PlayerList = NULL;
	}

	//
	//	Host finished migration process
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~(DN_OBJECT_FLAG_HOST_MIGRATING | DN_OBJECT_FLAG_HOST_MIGRATING_2));
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Exit;
	}
	DNASSERT(pdnObject->pNewHost != NULL);	// This should be set !
	pdnObject->pNewHost->Release();
	pdnObject->pNewHost = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	//
	//	Cleanup NameTable
	//
	DPF(7,"Cleaning up NameTable");
	hResultCode = DNCleanUpNameTable(pdnObject);

	//
	//	Send pending deletions
	//
	DPF(7,"Running pending operations");
	DNEnterCriticalSection(&pdnObject->csNameTableOpList);
	pBilink = pdnObject->m_bilinkPendingDeletions.GetNext();
	while (pBilink != &pdnObject->m_bilinkPendingDeletions)
	{
		pPending = CONTAINING_OBJECT(pBilink,CPendingDeletion,m_bilinkPendingDeletions);

		pPending->m_bilinkPendingDeletions.RemoveFromList();

		DNLeaveCriticalSection(&pdnObject->csNameTableOpList);

		DNHostDisconnect(pdnObject,pPending->GetDPNID(),DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);
		pPending->ReturnSelfToPool();
		pPending = NULL;

		DNEnterCriticalSection(&pdnObject->csNameTableOpList);
		pBilink = pdnObject->m_bilinkPendingDeletions.GetNext();
	}
	DNLeaveCriticalSection(&pdnObject->csNameTableOpList);

	//
	//	Inform connected players that Host migration is complete
	//
	DPF(7,"Sending HOST_MIGRATE_COMPLETE messages");
	hResultCode = DNSendHostMigrateCompleteMessage(pdnObject);

	//
	//	Ensure outstanding operations complete
	//
	DPF(7,"Completing outstanding operations");
	hResultCode = DNCompleteOutstandingOperations(pdnObject);

	hResultCode = DPN_OK;

Exit:
	DNASSERT(pNTEntry == NULL);
	DNASSERT(pConnection == NULL);
	DNASSERT(pPending == NULL);
	DNASSERT(PlayerList == NULL);

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNProcessHostMigration1
//
//	Perform an instructed host migration

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessHostMigration1"

HRESULT	DNProcessHostMigration1(DIRECTNETOBJECT *const pdnObject,
								void *const pvMsg)
{
	HRESULT			hResultCode;
	CNameTableEntry	*pNTEntry;
	DN_INTERNAL_MESSAGE_HOST_MIGRATE	*pInfo;

	DPF(6,"Parameters: pvMsg [0x%p]",pvMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pvMsg != NULL);

	pNTEntry = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_HOST_MIGRATE*>(pvMsg);

	DPF(7,"New Host [0x%lx], Old Host [0x%lx]",pInfo->dpnidNewHost,pInfo->dpnidOldHost);

	DNASSERT(pInfo->dpnidNewHost != NULL);
	DNASSERT(pInfo->dpnidOldHost != NULL);

	//
	//	Update destruction of old host as normal - is this correct ?
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnidOldHost,&pNTEntry)) == DPN_OK)
	{
		pNTEntry->Lock();
		if (pNTEntry->GetDestroyReason() == 0)
		{
			pNTEntry->SetDestroyReason( DPNDESTROYPLAYERREASON_NORMAL );
		}
		pNTEntry->Unlock();
		pNTEntry->Release();
		pNTEntry = NULL;
	}

	//
	//	Get new host entry
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(pInfo->dpnidNewHost,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not find new host NameTableEntry");
		DisplayDNError(0,hResultCode);
		hResultCode = DPN_OK;
		goto Failure;
	}

	//
	//	Set HOST_MIGRATE status on DirectNet object
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Failure;
	}
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		DNASSERT(pdnObject->pNewHost != NULL);
		if (pdnObject->pNewHost->GetVersion() > pNTEntry->GetVersion())
		{
			DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
			hResultCode = DPN_OK;
			goto Failure;
		}
		pdnObject->pNewHost->Release();
		pdnObject->pNewHost = NULL;
	}
	pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_MIGRATING;
	DNASSERT( pdnObject->pNewHost == NULL );
	pNTEntry->AddRef();
	pdnObject->pNewHost = pNTEntry;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	// Delete old host
	pdnObject->NameTable.DeletePlayer(pInfo->dpnidOldHost,NULL);

	//
	//	Make new host
	//
	pdnObject->NameTable.UpdateHostPlayer( pNTEntry );

	//
	//	Send NameTable version to Host player
	//
	DNNTPlayerSendVersion(pdnObject);

	pNTEntry->Release();
	pNTEntry = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNProcessHostMigration2
//
//	Send Host player NameTable entries missing from its (Host's) NameTable	

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessHostMigration2"

HRESULT	DNProcessHostMigration2(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg)
{
	HRESULT			hResultCode;
	DWORD			dwAckMsgSize;
	CBilink			*pBilink;
	CNameTableEntry	*pHostPlayer;
	CConnection		*pConnection;
	CRefCountBuffer	*pRefCountBuffer;
	CPackedBuffer	PackedBuffer;
	CNameTableOp	*pNTOp;
	DN_NAMETABLE_OP_INFO					*pInfo;
	DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP	*pReq;
	DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP	*pAck;

	DPF(6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

	pHostPlayer = NULL;
	pConnection = NULL;
	pRefCountBuffer = NULL;

	pReq = static_cast<DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP*>(pMsg);

	DPF(5,"Host requested NameTable ops [%ld] to [%ld]",
			pReq->dwVersion,pdnObject->NameTable.GetVersion());

	//
	//	Determine ACK message size
	//
	pdnObject->NameTable.Lock();
	DNASSERT(pdnObject->NameTable.GetVersion() >= pReq->dwVersion);
	dwAckMsgSize = sizeof(DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP);			// Number of entries
	dwAckMsgSize +=	((pdnObject->NameTable.GetVersion() - pReq->dwVersion + 1)	// Message info
			* sizeof(DN_NAMETABLE_OP_INFO));

	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		if ((pNTOp->GetVersion() >= pReq->dwVersion) && (pNTOp->GetVersion() <= pdnObject->NameTable.GetVersion()))
		{
			DNASSERT(pNTOp->GetRefCountBuffer() != NULL);
			dwAckMsgSize += pNTOp->GetRefCountBuffer()->GetBufferSize();
		}
		pBilink = pBilink->GetNext();
	}

	//
	//	Create ACK buffer
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,dwAckMsgSize,&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not create RefCount buffer for NameTable re-sync ACK");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		pdnObject->NameTable.Unlock();
		goto Failure;
	}
	PackedBuffer.Initialize(pRefCountBuffer->GetBufferAddress(),pRefCountBuffer->GetBufferSize());
	pAck = reinterpret_cast<DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP *>(pRefCountBuffer->GetBufferAddress());

	// Header
	pAck->dwNumEntries = pdnObject->NameTable.GetVersion() - pReq->dwVersion + 1;
	PackedBuffer.AddToFront(NULL,sizeof(DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP));

	// Offset list
	pInfo = reinterpret_cast<DN_NAMETABLE_OP_INFO*>(PackedBuffer.GetHeadAddress());
	PackedBuffer.AddToFront(NULL,pAck->dwNumEntries * sizeof(DN_NAMETABLE_OP_INFO));

	// Messages
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		if ((pNTOp->GetVersion() >= pReq->dwVersion) && (pNTOp->GetVersion() <= pdnObject->NameTable.GetVersion()))
		{
			DNASSERT(pNTOp->GetRefCountBuffer() != NULL);
			if ((hResultCode = PackedBuffer.AddToBack(pNTOp->GetRefCountBuffer()->GetBufferAddress(),
					pNTOp->GetRefCountBuffer()->GetBufferSize())) != DPN_OK)
			{
				DPFERR("Could not fill NameTable re-sync ACK");
				DisplayDNError(0,hResultCode);
				DNASSERT(FALSE);
				pdnObject->NameTable.Unlock();
				goto Failure;
			}
			pInfo->dwMsgId = pNTOp->GetMsgId();
			pInfo->dwOpOffset = PackedBuffer.GetTailOffset();
			pInfo->dwOpSize = pNTOp->GetRefCountBuffer()->GetBufferSize();
			pInfo++;
		}
		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	// Send ACK buffer
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get Connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	hResultCode = DNSendMessage(pdnObject,
								pConnection,
								DN_MSG_INTERNAL_ACK_NAMETABLE_OP,
								pHostPlayer->GetDPNID(),
								pRefCountBuffer->BufferDescAddress(),
								pRefCountBuffer,
								0,
								DN_SENDFLAGS_RELIABLE,
								NULL,
								NULL);
	if (hResultCode != DPNERR_PENDING)
	{
		DPFERR("Could not send NameTable re-sync ACK");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	pRefCountBuffer->Release();		// Added 19/07/00 MJN - Is this needed ?
	pRefCountBuffer = NULL;
	pConnection->Release();
	pConnection = NULL;
	pHostPlayer->Release();
	pHostPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNProcessHostMigration3
//
//	

#undef DPF_MODNAME
#define DPF_MODNAME "DNProcessHostMigration3"

HRESULT	DNProcessHostMigration3(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT		hResultCode;

	DPF(6,"Parameters: (none)");

	// No longer in Host migration mode
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	pdnObject->dwFlags &= (~DN_OBJECT_FLAG_HOST_MIGRATING);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CLOSING)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		hResultCode = DPN_OK;
		goto Exit;
	}
	DNASSERT(pdnObject->pNewHost != NULL);		// This should be set !
	pdnObject->pNewHost->Release();
	pdnObject->pNewHost = NULL;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	// Ensure outstanding operations complete
	DPF(7,"Completing outstanding operations");
	hResultCode = DNCompleteOutstandingOperations(pdnObject);

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNCompleteOutstandingOperations
//
//	We will attempt to complete any outstanding asynchronous NameTable operations
//	(i.e. create/destroy group, add/delete player to/from group, update info).
//	If we are the Host player,
//		- try processing the request directly
//		- release the async op to generate completions
//	Otherwise
//		- resend the request to the Host

#undef DPF_MODNAME
#define DPF_MODNAME "DNCompleteOutstandingOperations"

HRESULT DNCompleteOutstandingOperations(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CAsyncOp		*pAsyncOp;
	CAsyncOp		*pSend;
	CAsyncOp		**RequestList;
	CConnection		*pConnection;
	CNameTableEntry	*pHostPlayer;
	CNameTableEntry	*pLocalPlayer;
	DN_SEND_OP_DATA	*pSendOpData;
	DWORD			dwCount;
	DWORD			dwActual;

	DPF(6,"Parameters: none");

	DNASSERT(pdnObject != NULL);

	pAsyncOp = NULL;
	pSend = NULL;
	RequestList = NULL;
	pConnection = NULL;
	pHostPlayer = NULL;
	pLocalPlayer = NULL;

	//
	//	Get Host connection
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not get host player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	if ((hResultCode = pHostPlayer->GetConnectionRef( &pConnection )) != DPN_OK)
	{
		DPFERR("Could not get host connection reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pHostPlayer->Release();
	pHostPlayer = NULL;

	//
	//	Get local player
	//
	if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
	{
		DPFERR("Could not get local player reference");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}

	dwCount = 0;
	dwActual = 0;
	DNEnterCriticalSection(&pdnObject->csAsyncOperations);

	//
	//	Determine outstanding request list size
	//
	pBilink = pdnObject->m_bilinkAsyncOps.GetNext();
	while (pBilink != &pdnObject->m_bilinkAsyncOps)
	{
		pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkAsyncOps);
		if (pAsyncOp->GetOpType() == ASYNC_OP_REQUEST)
		{
			dwCount++;
		}
		pBilink = pBilink->GetNext();
	}

	//
	//	Build outstanding request list
	//
	if (dwCount > 0)
	{
		if ((RequestList = static_cast<CAsyncOp**>(MemoryBlockAlloc(pdnObject,dwCount * sizeof(CAsyncOp*)))) == NULL)
		{
			DNLeaveCriticalSection(&pdnObject->csAsyncOperations);
			DPFERR("Could not allocate request list");
			hResultCode = DPNERR_OUTOFMEMORY;
			goto Failure;
		}

		pBilink = pdnObject->m_bilinkAsyncOps.GetNext();
		while (pBilink != &pdnObject->m_bilinkAsyncOps)
		{
			pAsyncOp = CONTAINING_OBJECT(pBilink,CAsyncOp,m_bilinkAsyncOps);
			if (pAsyncOp->GetOpType() == ASYNC_OP_REQUEST)
			{
				DNASSERT(dwActual < dwCount);

				pAsyncOp->AddRef();
				RequestList[dwActual] = pAsyncOp;
				dwActual++;
			}
			pBilink = pBilink->GetNext();
		}
	}
	DNLeaveCriticalSection(&pdnObject->csAsyncOperations);

	//
	//	Perform outstanding requests
	//

	if (RequestList)
	{
		DWORD	dw;

		for ( dw = 0 ; dw < dwActual ; dw++ )
		{
			pSendOpData = static_cast<DN_SEND_OP_DATA*>(RequestList[dw]->GetOpData());
			if (	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_CREATE_GROUP
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_DESTROY_GROUP
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_UPDATE_INFO
				||	pSendOpData->dwMsgId == DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK)
			{
				DPF(7,"Found outstanding operation: dwMsgId [0x%lx]",pSendOpData->dwMsgId);

				if (pLocalPlayer->IsHost())
				{
					hResultCode = DNHostProcessRequest(	pdnObject,
														pSendOpData->dwMsgId,
														pSendOpData->BufferDesc[1].pBufferData,
														pLocalPlayer->GetDPNID() );
				}
				else
				{
					//
					//	re-SEND REQUEST
					//
					hResultCode = DNPerformChildSend(	pdnObject,
														RequestList[dw],
														pConnection,
														0,
														&pSend,
														TRUE);
					if (hResultCode == DPNERR_PENDING)
					{
						//
						//	Reset SEND AsyncOp to complete apropriately.
						//
						pSend->SetCompletion( DNCompleteSendRequest );

						pSend->Release();
						pSend = NULL;
					}
				}
			}
			RequestList[dw]->Release();
			RequestList[dw] = NULL;
		}
		MemoryBlockFree(pdnObject,RequestList);
		RequestList = NULL;
	}

	pLocalPlayer->Release();
	pLocalPlayer = NULL;
	pConnection->Release();
	pConnection = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pConnection)
	{
		pConnection->Release();
		pConnection = NULL;
	}
	if (RequestList)
	{
		MemoryBlockFree(pdnObject,RequestList);
		RequestList = NULL;
	}
	goto Exit;
}


//	DNCheckReceivedAllVersions
//
//	Check to see if all players in the NameTable have returned their
//	NameTable versions.  If so, ensure the NameTables are re-sync'd and
//	then finish the Host migration

#undef DPF_MODNAME
#define DPF_MODNAME "DNCheckReceivedAllVersions"

HRESULT DNCheckReceivedAllVersions(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	BOOL			bNotReady;

	DPF(6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	bNotReady = FALSE;
	pdnObject->NameTable.Lock();
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while ((pBilink != &pdnObject->NameTable.m_bilinkPlayers) && (!bNotReady))
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (!pNTEntry->IsDisconnecting() && (pNTEntry->GetLatestVersion() == 0))
		{
			//
			//	Ensure that we are not including dropped/disconnected players who have yet to be processed
			//
			CConnection	*pConnection;

			pConnection = NULL;

			pNTEntry->Unlock();
			if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
			{
				if (!pConnection->IsDisconnecting() && !pConnection->IsInvalid())
				{
					DPF(7,"Player [0x%lx] has not returned dwLatestVersion",pNTEntry->GetDPNID());
					bNotReady = TRUE;	// these must all be non-zero
				}
				pConnection->Release();
				pConnection = NULL;
			}
		}
		else
		{
			pNTEntry->Unlock();
		}
		pNTEntry = NULL;

		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	if (bNotReady)
	{
		DPF(7,"All players have not responded");
		return(DPNERR_PENDING);
	}

	//
	//	Ensure only one thread runs this from here on out
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING_2)
	{
		DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
		DPF(7,"Another thread will proceed with Host Migration - returning");
		hResultCode = DPN_OK;
		goto Exit;
	}
	pdnObject->dwFlags |= DN_OBJECT_FLAG_HOST_MIGRATING_2;
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);

	DPF(7,"All players have responded - host migration stage 1 complete");
	hResultCode = DNPerformHostMigration2(pdnObject);

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNCleanUpNameTable
//
//	Clean up the NameTable.
//	There are some cases where dropped players are not properly removed from the NameTable.
//		An example is when the Host-elect drops right after the Host before it has a chance
//		to send out a HOST_MIGRATE message.  In this case, since the HOST_MIGRATE message
//		implicitly includes the DELETE_PLAYER message for the original Host, the original
//		Host player never gets removed from current players' NameTables, though it DOES get
//		marked as DISCONNECTING.
//	Delete all DISCONNECTING players with older NameTable versions than ourselves.
//	Players with newer NameTable versions imply WE are the Host player, so we will
//		take care of them later (Pending Operations)

#undef DPF_MODNAME
#define DPF_MODNAME "DNCleanUpNameTable"

HRESULT DNCleanUpNameTable(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableEntry	*pNTEntry;
	DPNID			*List;
	DWORD			dwCount;
	DWORD			dwActual;
	DWORD			dw;

	DPF(6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	List = NULL;

	//
	//	Create list of old player DPNID's
	//
	dwCount = 0;
	dwActual = 0;
	pdnObject->NameTable.Lock();
	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		pNTEntry->Lock();
		if (pNTEntry->IsDisconnecting() && (pNTEntry->GetVersion() < pdnObject->NameTable.GetLocalPlayer()->GetVersion()))
		{
			DPF(7,"Found old player [0x%lx]",pNTEntry->GetDPNID());
			dwCount++;
		}
		pNTEntry->Unlock();

		pBilink = pBilink->GetNext();
	}
	if (dwCount)
	{
		if ((List = static_cast<DPNID*>(DNMalloc(dwCount * sizeof(DPNID*)))) != NULL)
		{
			pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
			while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
			{
				pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
				pNTEntry->Lock();
				if (pNTEntry->IsDisconnecting() && (pNTEntry->GetVersion() < pdnObject->NameTable.GetLocalPlayer()->GetVersion()))
				{
					DNASSERT(dwActual < dwCount);
					List[dwActual] = pNTEntry->GetDPNID();
					dwActual++;
				}
				pNTEntry->Unlock();

				pBilink = pBilink->GetNext();
			}
		}
	}
	pdnObject->NameTable.Unlock();

	//
	//	Remove old players
	//
	if (List)
	{
		DWORD	dw;

		for (dw = 0 ; dw < dwActual ; dw++)
		{
			DPF(7,"Removing old player [0x%lx]",List[dw]);
			DNHostDisconnect(pdnObject,List[dw],DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER);
			List[dw] = 0;
		}

		DNFree(List);
		List = NULL;
	}

	hResultCode = DPN_OK;

	DNASSERT(List == NULL);

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNSendHostMigrateCompleteMessage
//
//	Send a HOST_MIGRATE_COMPLETE message to connected players

#undef DPF_MODNAME
#define DPF_MODNAME "DNSendHostMigrateCompleteMessage"

HRESULT	DNSendHostMigrateCompleteMessage(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT		hResultCode;
	CAsyncOp	*pParent;
	CBilink		*pBilink;
	CNameTableEntry	*pNTEntry;
	CConnection	*pConnection;

	DPF(6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);

	pParent = NULL;
	pNTEntry = NULL;
	pConnection = NULL;

	hResultCode = DNCreateSendParent(	pdnObject,
										DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE,
										NULL,
										DN_SENDFLAGS_RELIABLE,
										&pParent);
	if (hResultCode != DPN_OK)
	{
		DPFERR("Could not create AsyncOp");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}

	//
	//	Lock NameTable
	//
	pdnObject->NameTable.Lock();

	pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
	{
		pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
		if (!pNTEntry->IsDisconnecting() && !pNTEntry->IsLocal())
		{
			if ((hResultCode = pNTEntry->GetConnectionRef( &pConnection )) == DPN_OK)
			{
				hResultCode = DNPerformChildSend(	pdnObject,
													pParent,
													pConnection,
													0,
													NULL,
													TRUE);
				if (hResultCode != DPNERR_PENDING)
				{
					DPFERR("Could not perform part of group send - ignore and continue");
					DisplayDNError(0,hResultCode);
				}
				pConnection->Release();
				pConnection = NULL;
			}
		}

		pBilink = pBilink->GetNext();
	}

	//
	//	Unlock NameTable
	//
	pdnObject->NameTable.Unlock();

	pParent->Release();
	pParent = NULL;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);;

Failure:
	if (pParent)
	{
		pParent->Release();
		pParent = NULL;
	}
	goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\ntentry.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTEntry.cpp
 *  Content:    NameTable Entry Objects
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/10/00	mjn		Created
 *	04/06/00	mjn		Added AvailableEvent to block pre-ADD_PLAYER-notification sends
 *	05/05/00	mjn		Added GetConnectionRef()
 *	05/16/00	mjn		Better locking during User notifications
 *	06/27/00	rmt		Added COM abstraction
 *	07/22/00	mjn		Pack/Unpack DNET version in DN_NAMETABLE_ENTRY_INFO
 *	07/26/00	mjn		Fix PackInfo() to handle NULL names and data
 *  08/03/00	rmt		Bug #41386 - Getting player info when no name and/or user data returns garbage in 
 *						name / data field.
 *	09/06/00	mjn		Changed SetAddress() to return void instead of HRESULT
 *	09/13/00	mjn		Added PerformQueuedOperations()
 *	09/17/00	mjn		Added NotifyAddRef() and NotifyRelease()
 *	09/28/00	mjn		Flag AutoDestruct groups in PackInfo()
 *	10/11/00	mjn		Don't take locks in PackInfo()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


void CNameTableEntry::ReturnSelfToPool( void )
{
	m_pdnObject->m_pFPOOLNameTableEntry->Release( this );
};


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::Release"

void CNameTableEntry::Release(void)
{
	LONG	lRefCount;

	DNASSERT(m_lRefCount > 0);
	lRefCount = InterlockedDecrement(const_cast<LONG*>(&m_lRefCount));
	DPF(3,"NameTableEntry::Release [0x%p] RefCount [0x%lx]",this,lRefCount);
	if (lRefCount == 0)
	{
		DNASSERT(!(m_dwFlags & NAMETABLE_ENTRY_FLAG_AVAILABLE));

		DNASSERT(m_bilinkDeleted.IsEmpty());
		DNASSERT(m_bilinkMembership.IsEmpty());
		DNASSERT(m_bilinkConnections.IsEmpty());
		DNASSERT(m_bilinkQueuedMsgs.IsEmpty());

		if (m_pAddress)
		{
			m_pAddress->Release();
			m_pAddress = NULL;
		}
		if (m_pConnection)
		{
			m_pConnection->Release();
			m_pConnection = NULL;
		}
		if (m_pwszName)
		{
			DNFree(m_pwszName);
			m_pwszName = NULL;
		}
		if (m_pvData)
		{
			DNFree(m_pvData);
			m_pvData = NULL;
			m_dwDataSize = 0;
		}
		m_dwFlags = 0;
		m_lRefCount = 0;
		ReturnSelfToPool();
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::NotifyAddRef"

void CNameTableEntry::NotifyAddRef( void )
{
	LONG	lRefCount;

	lRefCount = InterlockedIncrement( const_cast<LONG*>(&m_lNotifyRefCount) );
	DNASSERT( lRefCount >= 0 );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::NotifyRelease"

void CNameTableEntry::NotifyRelease( void )
{
	LONG	lRefCount;

	lRefCount = InterlockedDecrement( const_cast<LONG*>(&m_lNotifyRefCount) );
	DNASSERT( lRefCount >= 0 );

	if (lRefCount == 0)
	{
		Lock();
//		DNASSERT(IsDisconnecting());
		if (IsNeedToDestroy())
		{
			Unlock();

			//
			//	Generate notifications
			//
			if (IsGroup())
			{
				if (!IsAllPlayersGroup())
				{
					DNUserDestroyGroup(m_pdnObject,this);
				}
			}
			else
			{
				if (IsIndicated() && !IsCreated())
				{
					DNUserIndicatedConnectAborted(m_pdnObject,m_pvContext);
				}
				else
				{
					DNASSERT(IsCreated());
					DNUserDestroyPlayer(m_pdnObject,this);
				}
			}

			m_pdnObject->NameTable.Lock();
			Lock();
			m_bilinkDeleted.RemoveFromList();
			m_pdnObject->NameTable.Unlock();
			ClearNeedToDestroy();
			ClearCreated();
		}
		Unlock();
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::UpdateEntryInfo"

HRESULT CNameTableEntry::UpdateEntryInfo(WCHAR *const pwszName,
										 const DWORD dwNameSize,
										 void *const pvData,
										 const DWORD dwDataSize,
										 const DWORD dwInfoFlags,
										 BOOL fNotify)
{
	PWSTR	pwszTempName;
	DWORD	dwTempNameSize;
	void	*pvTempData;
	DWORD	dwTempDataSize;

	Lock();

	if (dwInfoFlags & DPNINFO_NAME)
	{
		if (pwszName && dwNameSize)
		{
			if ((pwszTempName = static_cast<WCHAR*>(DNMalloc(dwNameSize))) == NULL)
			{
				return(DPNERR_OUTOFMEMORY);
			}
			memcpy(pwszTempName,pwszName,dwNameSize);
			dwTempNameSize = dwNameSize;
		}
		else
		{
			pwszTempName = NULL;
			dwTempNameSize = 0;
		}
		if (m_pwszName)
		{
			DNFree(m_pwszName);
		}
		m_pwszName = pwszTempName;
		m_dwNameSize = dwTempNameSize;
	}
	if (dwInfoFlags & DPNINFO_DATA)
	{
		if (pvData && dwDataSize)
		{
			if ((pvTempData = DNMalloc(dwDataSize)) == NULL)
			{
				return(DPNERR_OUTOFMEMORY);
			}
			memcpy(pvTempData,pvData,dwDataSize);
			dwTempDataSize = dwDataSize;
		}
		else
		{
			pvTempData = NULL;
			dwTempDataSize = 0;
		}
		if (m_pvData)
		{
			DNFree(m_pvData);
		}
		m_pvData = pvTempData;
		m_dwDataSize = dwTempDataSize;
	}

	// Generate notifications
	if (m_dwFlags & NAMETABLE_ENTRY_FLAG_AVAILABLE && fNotify)
	{
		DPNID dpnid = m_dpnid;
		PVOID pvContext = m_pvContext;
		DIRECTNETOBJECT* pdnObject = m_pdnObject;

		if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP)
		{
			Unlock();
			DNUserUpdateGroupInfo(pdnObject,dpnid,pvContext);
		}
		else
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_PEER)
			{
				Unlock();
				DNUserUpdatePeerInfo(pdnObject,dpnid,pvContext);
			}
			else if (m_dwFlags & NAMETABLE_ENTRY_FLAG_CLIENT && pdnObject->dwFlags & DN_OBJECT_FLAG_SERVER)
			{
				Unlock();
				DNUserUpdateClientInfo(pdnObject,dpnid,pvContext);
			}
			else if (m_dwFlags & NAMETABLE_ENTRY_FLAG_SERVER && pdnObject->dwFlags & DN_OBJECT_FLAG_CLIENT)
			{
				Unlock();
				// Clients do not get to see server's DPNID or context
				DNUserUpdateServerInfo(pdnObject,0,0);
			}
			else
			{
				Unlock();
				DNASSERT(FALSE);
			}
		}
	}
	else
	{
		Unlock();
	}

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::SetAddress"

void CNameTableEntry::SetAddress( IDirectPlay8Address *const pAddress )
{
	if (pAddress)
	{
		pAddress->AddRef();
	}

	if (m_pAddress)
	{
		m_pAddress->Release();
		m_pAddress = NULL;
	}
	m_pAddress = pAddress;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::SetConnection"

void CNameTableEntry::SetConnection( CConnection *const pConnection )
{
	if (pConnection)
	{
		pConnection->AddRef();
	}
	m_pConnection = pConnection;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::GetConnectionRef"

HRESULT	CNameTableEntry::GetConnectionRef( CConnection **const ppConnection )
{
	HRESULT		hResultCode;

	DNASSERT( ppConnection != NULL);

	Lock();
	if ( m_pConnection && !m_pConnection->IsInvalid())
	{
		m_pConnection->AddRef();
		*ppConnection = m_pConnection;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_NOCONNECTION;
	}
	Unlock();

	return( hResultCode );
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::PackInfo"

HRESULT CNameTableEntry::PackInfo(CPackedBuffer *const pPackedBuffer)
{
	HRESULT			hResultCode;
	DPN_PLAYER_INFO	*pPlayerInfo;
	DPN_GROUP_INFO	*pGroupInfo;

	DNASSERT(pPackedBuffer != NULL);

//	Lock();
	if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP)
	{
		pGroupInfo = static_cast<DPN_GROUP_INFO*>(pPackedBuffer->GetHeadAddress());
		hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DPN_GROUP_INFO));
		
		//
		//	Add data
		//
		if ((m_pvData) && (m_dwDataSize != 0))
		{
			if ((hResultCode = pPackedBuffer->AddToBack(m_pvData,m_dwDataSize)) == DPN_OK)
			{
				pGroupInfo->pvData = pPackedBuffer->GetTailAddress();
				pGroupInfo->dwDataSize = m_dwDataSize;
			}
		}
		else
		{
			if (pGroupInfo)
			{
				pGroupInfo->pvData = NULL;
				pGroupInfo->dwDataSize = 0;
			}
		}

		//
		//	Add name
		//
		if ((m_pwszName) && (m_dwNameSize != 0))
		{
			if ((hResultCode = pPackedBuffer->AddToBack(m_pwszName,m_dwNameSize)) == DPN_OK)
			{
				pGroupInfo->pwszName = static_cast<WCHAR*>(pPackedBuffer->GetTailAddress());
			}
		}
		else
		{
			if (pGroupInfo)
			{
				pGroupInfo->pwszName = NULL;
			}
		}

		//
		//	Update flags
		//
		if (hResultCode == DPN_OK)
		{
			pGroupInfo->dwSize = sizeof(DPN_GROUP_INFO);
			pGroupInfo->dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
			pGroupInfo->dwGroupFlags = 0;
			if (IsAutoDestructGroup())
			{
				pGroupInfo->dwGroupFlags |= DPNGROUP_AUTODESTRUCT;
			}
		}
	}
	else
	{
		pPlayerInfo = static_cast<DPN_PLAYER_INFO*>(pPackedBuffer->GetHeadAddress());
		hResultCode = pPackedBuffer->AddToFront(NULL,sizeof(DPN_PLAYER_INFO));

		if( !m_dwDataSize )
		{
			if( pPlayerInfo )
			{
				pPlayerInfo->pvData = NULL;
				pPlayerInfo->dwDataSize = 0;
			}
		}
		else
		{
			if ((hResultCode = pPackedBuffer->AddToBack(m_pvData,m_dwDataSize)) == DPN_OK)
			{
				pPlayerInfo->pvData = pPackedBuffer->GetTailAddress();
				pPlayerInfo->dwDataSize = m_dwDataSize;
			}
		}

		if( !m_pwszName )
		{
			if( pPlayerInfo )
			{
				pPlayerInfo->pwszName = NULL;
			}
		}
		else
		{
			if ((hResultCode = pPackedBuffer->AddToBack(m_pwszName,m_dwNameSize)) == DPN_OK)
			{
				pPlayerInfo->pwszName = static_cast<WCHAR*>(pPackedBuffer->GetTailAddress());
			}
		}
		
		if (hResultCode == DPN_OK)
		{
			pPlayerInfo->dwSize = sizeof(DPN_PLAYER_INFO);
			pPlayerInfo->dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
			pPlayerInfo->dwPlayerFlags = 0;
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_HOST)
			{
				pPlayerInfo->dwPlayerFlags |= DPNPLAYER_HOST;
			}
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_LOCAL)
			{
				pPlayerInfo->dwPlayerFlags |= DPNPLAYER_LOCAL;
			}
		}
	}
//	Unlock();

	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::PackEntryInfo"

HRESULT CNameTableEntry::PackEntryInfo(CPackedBuffer *const pPackedBuffer)
{
	DWORD			dwURLSize;
	HRESULT			hResultCode;
	DN_NAMETABLE_ENTRY_INFO			dnEntryInfo;

	DPF(6,"Attempting to pack [0x%lx]",m_dpnid);

	DNASSERT(pPackedBuffer != NULL);

	dnEntryInfo.dpnid = m_dpnid;
	dnEntryInfo.dpnidOwner = m_dpnidOwner;
	dnEntryInfo.dwFlags = m_dwFlags & (		NAMETABLE_ENTRY_FLAG_HOST
										|	NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP
										|	NAMETABLE_ENTRY_FLAG_GROUP
										|	NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT
										|	NAMETABLE_ENTRY_FLAG_PEER
										|	NAMETABLE_ENTRY_FLAG_CLIENT
										|	NAMETABLE_ENTRY_FLAG_SERVER );
	dnEntryInfo.dwVersion = m_dwVersion;
	dnEntryInfo.dwVersionNotUsed = m_dwVersionNotUsed;
	dnEntryInfo.dwDNETVersion = m_dwDNETVersion;

	// Entry name
	if (m_pwszName != NULL)
	{
		if ((hResultCode = pPackedBuffer->AddToBack(m_pwszName,m_dwNameSize)) == DPN_OK)
		{
			dnEntryInfo.dwNameOffset = pPackedBuffer->GetTailOffset();
			dnEntryInfo.dwNameSize = m_dwNameSize;
		}
	}
	else
	{
		dnEntryInfo.dwNameOffset = 0;
		dnEntryInfo.dwNameSize = 0;
	}

	// Entry data
	if (m_pvData != NULL && m_dwDataSize != 0)
	{
		if ((hResultCode = pPackedBuffer->AddToBack(m_pvData,m_dwDataSize)) == DPN_OK)
		{
			dnEntryInfo.dwDataOffset = pPackedBuffer->GetTailOffset();
			dnEntryInfo.dwDataSize = m_dwDataSize;
		}
	}
	else
	{
		dnEntryInfo.dwDataOffset = 0;
		dnEntryInfo.dwDataSize = 0;
	}

	// Entry address (URL)
	if ((m_pdnObject->dwFlags & DN_OBJECT_FLAG_PEER) && (m_pAddress != NULL))
	{
		dwURLSize = 0;
		m_pAddress->AddRef();
		hResultCode = m_pAddress->GetURLA(NULL,&dwURLSize);
		if (hResultCode != DPN_OK && hResultCode != DPNERR_BUFFERTOOSMALL)
		{
			DPFERR("Could not determine URL size");
			DisplayDNError(0,hResultCode);
			m_pAddress->Release();
			goto EXIT_PackEntry;
		}
		if (dwURLSize != 0)
		{
			if ((hResultCode = pPackedBuffer->AddToBack(NULL,dwURLSize)) == DPN_OK)
			{
				if ((hResultCode = m_pAddress->GetURLA(
						static_cast<char*>(pPackedBuffer->GetTailAddress()),&dwURLSize)) == DPN_OK)
				{
					dnEntryInfo.dwURLOffset = pPackedBuffer->GetTailOffset();
					dnEntryInfo.dwURLSize = dwURLSize;
				}
				else
				{
					DPFERR("Could not extract URL from DirectPlayAddress");
					DisplayDNError(0,hResultCode);
					m_pAddress->Release();
					goto EXIT_PackEntry;
				}
			}
		}
		else
		{
			dnEntryInfo.dwURLOffset = 0;
			dnEntryInfo.dwURLSize = 0;
		}
		m_pAddress->Release();
	}
	else
	{
		dnEntryInfo.dwURLOffset = 0;
		dnEntryInfo.dwURLSize = 0;
	}

	hResultCode = pPackedBuffer->AddToFront(&dnEntryInfo,sizeof(DN_NAMETABLE_ENTRY_INFO));

EXIT_PackEntry:

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::UnpackEntryInfo"

HRESULT CNameTableEntry::UnpackEntryInfo(DN_NAMETABLE_ENTRY_INFO *const pdnEntryInfo,
										 BYTE *const pBufferStart)
{
	HRESULT		hResultCode;
	PWSTR		pwszName;
	DWORD		dwNameSize;
	void		*pvData;
	DWORD		dwDataSize;
	IDirectPlay8Address	*pAddress;

	DNASSERT(m_pwszName == NULL);
	DNASSERT(m_pvData == NULL);
	DNASSERT(m_pAddress == NULL);

	if (pdnEntryInfo->dwNameOffset && pdnEntryInfo->dwNameSize)
	{
		pwszName = reinterpret_cast<WCHAR*>(pBufferStart + pdnEntryInfo->dwNameOffset);
		dwNameSize = pdnEntryInfo->dwNameSize;
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}

	if (pdnEntryInfo->dwDataOffset && pdnEntryInfo->dwDataSize)
	{
		pvData = static_cast<void*>(pBufferStart + pdnEntryInfo->dwDataOffset);
		dwDataSize = pdnEntryInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	// This function takes the lock internally
	UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,DPNINFO_NAME|DPNINFO_DATA, FALSE);

	pAddress = NULL;
	if (pdnEntryInfo->dwURLOffset)
	{
		hResultCode = DirectPlay8AddressCreate( IID_IDirectPlay8Address, (void **) &pAddress, NULL);
		if (hResultCode != S_OK)
		{
			DPFERR("Could not create empty DirectPlayAddress");
			DisplayDNError(0,hResultCode);
			return(DPNERR_OUTOFMEMORY);
		}
		hResultCode = pAddress->BuildFromURLA(reinterpret_cast<char*>(pBufferStart + pdnEntryInfo->dwURLOffset));
		if (hResultCode != DPN_OK)
		{
			DPFERR("Could not build URL");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			pAddress->Release();
			pAddress = NULL;
			return(hResultCode);
		}
		SetAddress(pAddress);
		pAddress->Release();
		pAddress = NULL;
	}

	m_dpnid = pdnEntryInfo->dpnid;
	m_dpnidOwner = pdnEntryInfo->dpnidOwner;
	m_dwFlags = pdnEntryInfo->dwFlags;
	m_dwDNETVersion = pdnEntryInfo->dwDNETVersion;
	m_dwVersion = pdnEntryInfo->dwVersion;
	m_dwVersionNotUsed = pdnEntryInfo->dwVersionNotUsed;

	return(DPN_OK);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::PerformQueuedOperations"

void CNameTableEntry::PerformQueuedOperations( void )
{
	HRESULT		hResultCode;
	CQueuedMsg	*pQueuedMsg;
	BOOL		fDestroy;

	DPF(6,"Parameters: (none)");

	fDestroy = FALSE;

	Lock();
	fDestroy = IsNeedToDestroy();

	//
	//	This assumes that the InUse flag is set.  We will clear it before returning.
	//
	DNASSERT( IsInUse() );

	while (!m_bilinkQueuedMsgs.IsEmpty())
	{
		pQueuedMsg = CONTAINING_OBJECT(m_bilinkQueuedMsgs.GetNext(),CQueuedMsg,m_bilinkQueuedMsgs);
		pQueuedMsg->m_bilinkQueuedMsgs.RemoveFromList();
		DEBUG_ONLY(m_lNumQueuedMsgs--);

		Unlock();

		switch (pQueuedMsg->GetOpType())
		{
			case	RECEIVE:
				{
					HRESULT		hrProcess;

					DNASSERT(pQueuedMsg->GetAsyncOp() != NULL);
					DNASSERT(pQueuedMsg->GetAsyncOp()->GetHandle() != 0);

#ifdef ENABLE_DPLAY_VOICE
					if (pQueuedMsg->IsVoiceMessage())
					{
						hrProcess = Voice_Receive(	m_pdnObject,
													GetDPNID(),
													0,
													pQueuedMsg->GetBuffer(),
													pQueuedMsg->GetBufferSize());

						NotifyRelease();

					}
					else
					{
#endif
						hrProcess = DNUserReceive(	m_pdnObject,
													this,
													pQueuedMsg->GetBuffer(),
													pQueuedMsg->GetBufferSize(),
													pQueuedMsg->GetAsyncOp()->GetHandle());
						if (pQueuedMsg->GetCompletionOp() != 0)
						{
							//
							//	Send completion message
							//
							CConnection	*pConnection;

							pConnection = NULL;
							if ((hResultCode = GetConnectionRef( &pConnection )) == DPN_OK)
							{
								hResultCode = DNSendUserProcessCompletion(	m_pdnObject,
																			pConnection,
																			pQueuedMsg->GetCompletionOp());
							}
							pConnection->Release();
							pConnection = NULL;
						}
#ifdef ENABLE_DPLAY_VOICE
					}
#endif

					//
					//	See if we can return this buffer now
					//
					if (hrProcess == DPNERR_PENDING)
					{
						pQueuedMsg->GetAsyncOp()->Release();
						pQueuedMsg->SetAsyncOp( NULL );
					}
					else
					{
						DNEnterCriticalSection(&m_pdnObject->csActiveList);
						pQueuedMsg->GetAsyncOp()->m_bilinkActiveList.RemoveFromList();
						DNLeaveCriticalSection(&m_pdnObject->csActiveList);
						pQueuedMsg->GetAsyncOp()->Lock();
						if (!pQueuedMsg->GetAsyncOp()->IsCancelled() && !pQueuedMsg->GetAsyncOp()->IsComplete())
						{
							pQueuedMsg->GetAsyncOp()->SetComplete();
							pQueuedMsg->GetAsyncOp()->Unlock();
							m_pdnObject->HandleTable.Destroy( pQueuedMsg->GetAsyncOp()->GetHandle() );
						}
						else
						{
							pQueuedMsg->GetAsyncOp()->Unlock();
						}
						pQueuedMsg->GetAsyncOp()->Release();
						pQueuedMsg->SetAsyncOp( NULL );
					}

					break;
				}
			default:
				{
					DPFERR("Invalid Queued Operation");
					DNASSERT(FALSE);
					break;
				}
		}

		//
		//	Return this queued message
		//
		pQueuedMsg->ReturnSelfToPool();
		pQueuedMsg = NULL;

		Lock();
		fDestroy = IsNeedToDestroy();
	}

	//
	//	No longer processing
	//
	ClearInUse();
	Unlock();

	DPF(6,"Returning");
}


#undef DPF_MODNAME
#define DPF_MODNAME "CNameTableEntry::DumpEntry"

void CNameTableEntry::DumpEntry(char *const pBuffer)
{
	char			*p;
	CBilink			*pBilink;
	CGroupMember	*pGroupMember;
// BUGBUG: [mgere] [xbox] Remove temporarily
#if 0
	p = pBuffer;

	sprintf(p,"[0x%lx] ver[%ld,%ld] rc[%ld] [%S]",m_dpnid,m_dwVersion,m_dwLatestVersion,m_lRefCount,m_pwszName);
	p += strlen(p);

	if (IsAvailable())
	{
		sprintf(p," (available)");
		p += strlen(p);
	}
	if (IsConnecting())
	{
		sprintf(p," (connecting)");
		p += strlen(p);
	}
	if (IsDisconnecting())
	{
		sprintf(p," (disconnecting)");
		p += strlen(p);
	}
	if (IsLocal())
	{
		sprintf(p," (local)");
		p += strlen(p);
	}
	if (IsHost())
	{
		sprintf(p," (host)");
		p += strlen(p);
	}
	if (IsGroup())
	{
		sprintf(p," (group)");
		p += strlen(p);
	}
	if (IsAllPlayersGroup())
	{
		sprintf(p," (all players group)");
		p += strlen(p);
	}
	sprintf(p,"\r\n");
	p += strlen(p);

	pBilink = m_bilinkMembership.GetNext();
	while (pBilink != &m_bilinkMembership)
	{
		if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP)
		{
			pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkPlayers);
			sprintf(p,"\t{[0x%lx] v[%ld]}",pGroupMember->GetPlayer()->GetDPNID(),pGroupMember->GetVersion());
		}
		else
		{
			pGroupMember = CONTAINING_OBJECT(pBilink,CGroupMember,m_bilinkGroups);
			sprintf(p,"\t{[0x%lx] v[%ld]}",pGroupMember->GetGroup()->GetDPNID(),pGroupMember->GetVersion());
		}
		p += strlen(p);

		pBilink = pBilink->GetNext();
	}
	sprintf(p,"\r\n");
	p += strlen(p);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\nametable.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NameTable.h
 *  Content:    NameTable Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/11/00	mjn		Created
 *	04/09/00	mjn		Track outstanding connections in NameTable
 *	05/03/00	mjn		Implemented GetHostPlayerRef, GetLocalPlayerRef, GetAllPlayersGroupRef
 *	07/20/00	mjn		Added ClearHostWithDPNID()
 *	07/30/00	mjn		Added hrReason to CNameTable::EmptyTable()
 *	08/23/00	mjn		Added CNameTableOp
 *	09/05/00	mjn		Added m_dpnidMask
 *				mjn		Removed dwIndex from InsertEntry()
 *	09/17/00	mjn		Split m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *				mjn		Changed AddPlayerToGroup and RemovePlayerFromGroup to use NameTableEntry params
 *	09/26/00	mjn		Removed locking from SetVersion(),GetNewVersion()
 *				mjn		Changed DWORD GetNewVersion(void) to void GetNewVersion( PDWORD )
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__NAMETABLE_H__
#define	__NAMETABLE_H__

#pragma BUGBUG(minara,"REMOVE THIS!")
#ifndef	VANCEO
#define	VANCEO
#endif

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//
//	NameTable
//	
//	The NameTable consists of:
//		- an array of CNameTableEntry pointers
//		- short-cuts to the LocalPlayer, Host and AllPlayersGroup
//		- a version number
//
//	There is a list running through the free entries in the NameTable array.
//	When a free entry is required, it is taken from the front of this list,
//	and when an entry is released, it is added to the end of the list.
//	If a particular entry is required, it must be properly removed from the
//	list.  This may be a little time-consuming, since the entire list may
//	need to be traversed, but this will only happen on non-Host cases and
//	is a small price to pay to keep the Host case timely.
//

//
//	DPNIDs
//
//	DPNIDs are unique identifiers for NameTable entries.  They are constructed
//	from the NameTable array index and the version number of the entry.
//	The value 0x0 is invalid.  As a result, we must prevent it from being
//	generated.  Since the DPNID is constructed from two parts, we can do
//	this by ensuring that one of the two parts is never 0.  The best
//	solution is to ensure that the NameTable array index is never 0.
//	

//
//	Locking
//
//	When locking multiple entries in the NameTable, locks should be taken
//	in order based on DPNIDs.  e.g. Locking two entries with DPNIDs 200 and
//	101, the lock for 101 should be taken before the lock for 200.  Locks for
//	groups should be taken before locks for players.
//


//**********************************************************************
// Constant definitions
//**********************************************************************

#define NAMETABLE_INDEX_MASK			0x000FFFFF
#define NAMETABLE_VERSION_MASK			0xFFF00000
#define NAMETABLE_VERSION_SHIFT			20

#define	NAMETABLE_ARRAY_ENTRY_FLAG_VALID	0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

#define	CONSTRUCT_DPNID(i,v)	(((i & NAMETABLE_INDEX_MASK) | ((v << NAMETABLE_VERSION_SHIFT) & NAMETABLE_VERSION_MASK)) ^ m_dpnidMask)
#define	DECODE_INDEX(d)			((d ^ m_dpnidMask) & NAMETABLE_INDEX_MASK)
#define	VERIFY_VERSION(d,v)		(((d ^ m_dpnidMask) & NAMETABLE_VERSION_MASK) == (v << NAMETABLE_VERSION_SHIFT))

//**********************************************************************
// Structure definitions
//**********************************************************************

typedef struct _NAMETABLE_ARRAY_ENTRY
{
	CNameTableEntry	*pNameTableEntry;
	DWORD			dwFlags;
} NAMETABLE_ARRAY_ENTRY;

typedef struct _DN_NAMETABLE_INFO
{
	DPNID	dpnid;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
	DWORD	dwEntryCount;
	DWORD	dwMembershipCount;
} DN_NAMETABLE_INFO;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for NameTable

class CNameTable
{
	STDNEWDELETE

public:
	CNameTable()				// Constructor
		{
			m_Sig[0] = 'N';
			m_Sig[1] = 'T';
			m_Sig[2] = 'B';
			m_Sig[3] = 'L';
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::~CNameTable"
	~CNameTable()
		{
		};			// Destructor

	HRESULT CNameTable::Initialize(DIRECTNETOBJECT *const pdnObject);

	void CNameTable::Deinitialize( void );

	void Lock( void )
		{
			DNEnterCriticalSection(&m_csNameTable);
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection(&m_csNameTable);
		};

	void CNameTable::ValidateArray( void );

	HRESULT CNameTable::GrowNameTable( void );

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::GetFreeIndex"
	HRESULT CNameTable::GetFreeIndex(DWORD *const pdwFreeIndex)
		{
			DNASSERT(pdwFreeIndex != NULL);

			while (m_dwNumFreeEntries == 0)
			{
				if (GrowNameTable() != DPN_OK)
				{
					return(DPNERR_OUTOFMEMORY);
				}
			}
			DNASSERT(m_dwFirstFreeEntry != 0);
			*pdwFreeIndex = m_dwFirstFreeEntry;

			return(DPN_OK);
		};

	HRESULT CNameTable::UpdateTable(const DWORD dwIndex,
									CNameTableEntry *const pNameTableEntry);

	HRESULT CNameTable::InsertEntry(CNameTableEntry *const pNameTableEntry);

	void CNameTable::ReleaseEntry(const DWORD dwIndex);

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::GetNewVersion"
	void GetNewVersion( DWORD *const pdwVersion )
		{
			DNASSERT( pdwVersion != NULL );

			*pdwVersion = ++m_dwVersion;

			DPF(8,"Setting new version [%ld]",m_dwVersion);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::SetVersion"
	void SetVersion( const DWORD dwVersion )
		{
			m_dwVersion = dwVersion;

			DPF(8,"Setting new version [%ld]",m_dwVersion);
		};

	DWORD GetVersion( void )
		{
			return(m_dwVersion);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::CreateDPNID"
	DPNID CreateDPNID( void )
		{
			DWORD	dwVersion;
			DWORD	dwIndex;
			DPNID	dpnid;

			if (GetFreeIndex(&dwIndex) != DPN_OK)
				return(0);

			dwVersion = ++m_dwVersion;

			dpnid = CONSTRUCT_DPNID(dwIndex,dwVersion);
			DNASSERT(dpnid != 0);
			return(dpnid);
		};

	void CNameTable::EmptyTable( const HRESULT hrReason );

	HRESULT CNameTable::FindEntry(const DPNID dpnid,
								  CNameTableEntry **const ppNameTableEntry);

	HRESULT	CNameTable::FindDeletedEntry(const DPNID dpnid,
										 CNameTableEntry **const ppNTEntry);

	HRESULT	CNameTable::AddEntry(CNameTableEntry *const pNTEntry);

	HRESULT CNameTable::DeletePlayer(const DPNID dpnid,
									 DWORD *const pdwVersion);

	HRESULT CNameTable::DeleteGroup(const DPNID dpnid,
									DWORD *const pdwVersion);

	HRESULT CNameTable::AddPlayerToGroup(CNameTableEntry *const pGroup,
										 CNameTableEntry *const pPlayer,
										 DWORD *const pdwVersion);

	HRESULT CNameTable::RemovePlayerFromGroup(CNameTableEntry *const pGroup,
											  CNameTableEntry *const pPlayer,
											  DWORD *const pdwVersion);

	HRESULT CNameTable::RemoveAllPlayersFromGroup(CNameTableEntry *const pGroup);

	HRESULT CNameTable::RemoveAllGroupsFromPlayer(CNameTableEntry *const pPlayer);

	BOOL CNameTable::IsMember(const DPNID dpnidGroup,
							  const DPNID dpnidPlayer);

	HRESULT CNameTable::PackNameTable(CNameTableEntry *const pTarget,
									  CPackedBuffer *const pPackedBuffer);

	HRESULT	CNameTable::UnpackNameTableInfo(DN_NAMETABLE_INFO *const pdnNTInfo,
											BYTE *const pBufferStart,
											DPNID *const pdpnid);

	CNameTableEntry *GetDefaultPlayer( void )
		{
			return(m_pDefaultPlayer);
		};

	void MakeLocalPlayer(CNameTableEntry *const pNameTableEntry);

	void CNameTable::ClearLocalPlayer( void );

	CNameTableEntry *GetLocalPlayer( void )
		{
			return(m_pLocalPlayer);
		};

	HRESULT CNameTable::GetLocalPlayerRef( CNameTableEntry **const ppNTEntry );

	void MakeHostPlayer(CNameTableEntry *const pNameTableEntry);

	void CNameTable::ClearHostPlayer( void );

	BOOL CNameTable::ClearHostWithDPNID( const DPNID dpnid );

	void CNameTable::UpdateHostPlayer( CNameTableEntry *const pNewHost );

	CNameTableEntry *GetHostPlayer( void )
		{
			return(m_pHostPlayer);
		};

	HRESULT CNameTable::GetHostPlayerRef( CNameTableEntry **const ppNTEntry );

	void MakeAllPlayersGroup(CNameTableEntry *const pNameTableEntry);

	void CNameTable::ClearAllPlayersGroup( void );

	CNameTableEntry *GetAllPlayersGroup( void )
		{
			return(m_pAllPlayersGroup);
		};

	HRESULT CNameTable::GetAllPlayersGroupRef( CNameTableEntry **const ppNTEntry );

	HRESULT CNameTable::PopulateConnection(CConnection *const pConnection);

	HRESULT CNameTable::PopulateGroup(CNameTableEntry *const pGroup);

	HRESULT CNameTable::AutoCreateGroups(CNameTableEntry *const pPlayer);

	HRESULT CNameTable::AutoDestructGroups(const DPNID dpnid);

	void CNameTable::SetLatestVersion( const DWORD dwVersion )
		{
			m_dwLatestVersion = dwVersion;
		};

	DWORD CNameTable::GetLatestVersion( void )
		{
			return( m_dwLatestVersion );
		};

	void CNameTable::SetConnectVersion(const DWORD dwVersion)
		{
			m_dwConnectVersion = dwVersion;
		};

	DWORD CNameTable::GetConnectVersion( void )
		{
			return(m_dwConnectVersion);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTable::IncOutstandingConnections"
	void IncOutstandingConnections( void )
		{
			long	lRefCount;

			lRefCount = InterlockedIncrement(&m_lOutstandingConnections);
			DNASSERT(lRefCount > 0);
		};

	void SetDPNIDMask( const DPNID dpnidMask )
		{
			m_dpnidMask = dpnidMask;
		};

	DPNID GetDPNIDMask( void )
		{
			return( m_dpnidMask );
		};

	void CNameTable::DecOutstandingConnections( void );

	void CNameTable::DumpNameTable(char *const Buffer);

	CBilink		m_bilinkPlayers;
	CBilink		m_bilinkGroups;
	CBilink		m_bilinkDeleted;
	CBilink		m_bilinkNameTableOps;

private:
	BYTE					m_Sig[4];
	DIRECTNETOBJECT			*m_pdnObject;

	DPNID					m_dpnidMask;

	CNameTableEntry			*m_pDefaultPlayer;
	CNameTableEntry			*m_pLocalPlayer;
	CNameTableEntry			*m_pHostPlayer;
	CNameTableEntry			*m_pAllPlayersGroup;

	NAMETABLE_ARRAY_ENTRY	*m_NameTableArray;
	DWORD					m_dwNameTableSize;
	DWORD					m_dwFirstFreeEntry;
	DWORD					m_dwLastFreeEntry;
	DWORD					m_dwNumFreeEntries;

	DWORD					m_dwVersion;

	DWORD					m_dwLatestVersion;	// Only used by Host in PEER

	DWORD					m_dwConnectVersion;
	LONG					m_lOutstandingConnections;

	DNCRITICAL_SECTION		m_csNameTable;
};

#undef DPF_MODNAME

#endif	// __NAMETABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\ntop.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTOp.h
 *  Content:    NameTable Operation Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/23/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__NT_OP_H__
#define	__NT_OP_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	NAMETABLE_OP_FLAG_IN_USE	0x0001

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

class CNameTableOp;
template< class CNameTableOp > class CLockedContextClassFixedPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for NameTable Operations

class CNameTableOp
{
	STDNEWDELETE

public:
	CNameTableOp()				// Constructor
		{
			m_Sig[0] = 'N';
			m_Sig[1] = 'T';
			m_Sig[2] = 'O';
			m_Sig[3] = 'P';
		};

	~CNameTableOp() { };			// Destructor

	BOOL FPMAlloc(void *const pvContext)
		{
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableOp::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);

			m_dwFlags = 0;
			m_dwMsgId = 0;
			m_dwVersion = 0;
			m_dwVersionNotUsed = 0;

			m_pRefCountBuffer = NULL;

			m_bilinkNameTableOps.Initialize();

			return(TRUE);
		};

	void FPMRelease(void *const pvContext) { };

	void FPMDealloc(void *const pvContext) { };

	void ReturnSelfToPool( void )
		{
			m_pdnObject->m_pFPOOLNameTableOp->Release( this );
		};

	void SetInUse( void )
		{
			m_dwFlags |= NAMETABLE_OP_FLAG_IN_USE;
		};

	BOOL IsInUse( void )
		{
			if (m_dwFlags & NAMETABLE_OP_FLAG_IN_USE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void SetMsgId( const DWORD dwMsgId )
		{
			m_dwMsgId = dwMsgId;
		};

	DWORD GetMsgId( void )
		{
			return( m_dwMsgId );
		};

	void SetVersion( const DWORD dwVersion )
		{
			m_dwVersion = dwVersion;
		};

	DWORD GetVersion( void )
		{
			return( m_dwVersion );
		};

	void SetRefCountBuffer( CRefCountBuffer *const pRefCountBuffer )
		{
			if (pRefCountBuffer)
			{
				pRefCountBuffer->AddRef();
			}
			m_pRefCountBuffer = pRefCountBuffer;
		};

	CRefCountBuffer *GetRefCountBuffer( void )
		{
			return( m_pRefCountBuffer );
		};

	CBilink				m_bilinkNameTableOps;

private:
	BYTE				m_Sig[4];			// Signature
	DWORD				m_dwFlags;
	DWORD				m_dwMsgId;
	DWORD				m_dwVersion;
	DWORD				m_dwVersionNotUsed;

	CRefCountBuffer		*m_pRefCountBuffer;

	DIRECTNETOBJECT		*m_pdnObject;
};

#undef DPF_MODNAME

#endif	// __NT_OP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\ntentry.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTEntry.h
 *  Content:    NameTable Entry Object Header File
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/07/00	mjn		Created
 *	04/06/00	mjn		Added AvailableEvent to block pre-ADD_PLAYER-notification sends
 *	05/05/00	mjn		Added GetConnectionRef()
 *	07/22/00	mjn		Added m_dwDNETVersion
 *	07/29/00	mjn		Added SetIndicated(),ClearIndicated(),IsIndicated()
 *	07/30/00	mjn		Added m_dwDestoyReason
 *	08/02/00	mjn		Added m_bilinkQueuedMsgs
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/08/00	mjn		Added SetCreated(),ClearCreated(),IsCreated()
 *				mjn		Added SetNeedToDestroy(),ClearNeedToDestroy(),IsNeedToDestroy()
 *	09/06/00	mjn		Changed SetAddress() to return void instead of HRESULT
 *	09/12/00	mjn		Added NAMETABLE_ENTRY_FLAG_IN_USE
 *	09/17/00	mjn		Added m_lNotifyRefCount
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__NTENTRY_H__
#define	__NTENTRY_H__

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_CORE

//**********************************************************************
// Constant definitions
//**********************************************************************

//
//	NameTable Entry Status Flags:
//
//		INDICATED		App was given an INDICATE_CONNECTION message
//
//		CREATED			App was given a CREATE_PLAYER message
//
//		AVAILABLE		The entry is available for use.
//
//		CONNECTING		The player is in the process of connecting.
//
//		DISCONNECTING	The player/group is in the process of disconnecting.
//

#define	NAMETABLE_ENTRY_FLAG_LOCAL				0x00001
#define	NAMETABLE_ENTRY_FLAG_HOST				0x00002
#define	NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP	0x00004
#define	NAMETABLE_ENTRY_FLAG_GROUP				0x00010
#define	NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST	0x00020
#define	NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT	0x00040
#define	NAMETABLE_ENTRY_FLAG_PEER				0x00100
#define NAMETABLE_ENTRY_FLAG_CLIENT				0x00200
#define	NAMETABLE_ENTRY_FLAG_SERVER				0x00400
#define	NAMETABLE_ENTRY_FLAG_CONNECTING			0x01000
#define	NAMETABLE_ENTRY_FLAG_AVAILABLE			0x02000
#define	NAMETABLE_ENTRY_FLAG_DISCONNECTING		0x04000
#define	NAMETABLE_ENTRY_FLAG_INDICATED			0x10000	//	INDICATE_CONNECT
#define NAMETABLE_ENTRY_FLAG_CREATED			0x20000	//	CREATE_PLAYER
#define	NAMETABLE_ENTRY_FLAG_NEED_TO_DESTROY	0x40000
#define	NAMETABLE_ENTRY_FLAG_IN_USE				0x80000

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CNameTableEntry > class CLockedContextClassFixedPool;

//
//	Used to pass the NameTable entries
//
typedef struct _DN_NAMETABLE_ENTRY_INFO
{
	DPNID	dpnid;
	DPNID	dpnidOwner;
	DWORD	dwFlags;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
	DWORD	dwDNETVersion;
	DWORD	dwNameOffset;
	DWORD	dwNameSize;
	DWORD	dwDataOffset;
	DWORD	dwDataSize;
	DWORD	dwURLOffset;
	DWORD	dwURLSize;
} DN_NAMETABLE_ENTRY_INFO;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for NameTable Entries

class CNameTableEntry
{
	STDNEWDELETE

public:
	CNameTableEntry()				// Constructor
		{
			m_Sig[0] = 'N';
			m_Sig[1] = 'T';
			m_Sig[2] = 'E';
			m_Sig[3] = '*';
		};

	~CNameTableEntry() { };			// Destructor

	BOOL FPMAlloc(void *const pvContext)
		{
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			if (!DNInitializeCriticalSection(&m_csEntry))
			{
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&m_csEntry,0);
			if (!DNInitializeCriticalSection(&m_csMembership))
			{
				DNDeleteCriticalSection(&m_csEntry);
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&m_csMembership,0);
			if (!DNInitializeCriticalSection(&m_csConnections))
			{
				DNDeleteCriticalSection(&m_csMembership);
				DNDeleteCriticalSection(&m_csEntry);
				return(FALSE);
			}
			DebugSetCriticalSectionRecursionCount(&m_csConnections,0);

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableEntry::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);
			m_dpnid = 0;
			m_dpnidOwner = 0;
			m_pvContext = NULL;
			m_lRefCount = 1;
			m_lNotifyRefCount = 0;
			m_dwFlags = 0;
			m_dwDNETVersion = 0;
			m_dwVersion = 0;
			m_dwVersionNotUsed = 0;
			m_dwLatestVersion = 0;
			m_dwDestroyReason = 0;
			m_pwszName = NULL;
			m_dwNameSize = 0;
			m_pvData = NULL;
			m_dwDataSize = 0;
			m_pAddress = NULL;
			m_pConnection = NULL;
			m_bilinkEntries.Initialize();
			m_bilinkDeleted.Initialize();
			m_bilinkMembership.Initialize();
			m_bilinkConnections.Initialize();
			m_bilinkQueuedMsgs.Initialize();

			return(TRUE);
		};

	void FPMRelease(void *const pvContext) { };

	void FPMDealloc(void *const pvContext)
		{
			DNDeleteCriticalSection(&m_csConnections);
			DNDeleteCriticalSection(&m_csMembership);
			DNDeleteCriticalSection(&m_csEntry);
		};

	void ReturnSelfToPool( void );

	void Lock( void )
		{
			DNEnterCriticalSection(&m_csEntry);
		};

	void Unlock( void )
		{
			DNLeaveCriticalSection(&m_csEntry);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CNameTableEntry::AddRef"
	void AddRef(void)
		{
			LONG	lRefCount;

			DNASSERT(m_lRefCount > 0);
			lRefCount = InterlockedIncrement(const_cast<LONG*>(&m_lRefCount));
			DPF(3,"NameTableEntry::AddRef [0x%p] RefCount [0x%lx]",this,lRefCount);
		};

	void Release(void);

	void CNameTableEntry::NotifyAddRef( void );

	void CNameTableEntry::NotifyRelease( void );

	void MakeLocal( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_LOCAL;
		};

	BOOL IsLocal( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_LOCAL)
				return(TRUE);

			return(FALSE);
		};

	void MakeHost( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_HOST;
		};

	BOOL IsHost( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_HOST)
				return(TRUE);

			return(FALSE);
		};

	void MakeAllPlayersGroup( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP;
		};

	BOOL IsAllPlayersGroup( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP)
				return(TRUE);

			return(FALSE);
		};

	void MakeGroup( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_GROUP;
		};

	BOOL IsGroup( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP)
				return(TRUE);

			return(FALSE);
		};

	void MakeMulticastGroup( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST;
		};

	BOOL IsMulticastGroup( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST)
				return(TRUE);

			return(FALSE);
		};

	void MakeAutoDestructGroup( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT;
		};

	BOOL IsAutoDestructGroup( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT)
				return(TRUE);

			return(FALSE);
		};

	void MakePeer( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_PEER;
		};

	BOOL IsPeer( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_PEER)
				return(TRUE);

			return(FALSE);
		};

	void MakeClient( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_CLIENT;
		};

	BOOL IsClient( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_CLIENT)
				return(TRUE);

			return(FALSE);
		};

	void MakeServer( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_SERVER;
		};

	BOOL IsServer( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_SERVER)
				return(TRUE);

			return(FALSE);
		};

	void MakeAvailable( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_AVAILABLE;
		};

	void MakeUnavailable( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_AVAILABLE);
		};

	BOOL IsAvailable( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_AVAILABLE)
				return(TRUE);

			return(FALSE);
		};

	void SetIndicated( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_INDICATED;
		};

	void ClearIndicated( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_INDICATED);
		};

	BOOL IsIndicated( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_INDICATED)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	void SetCreated( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_CREATED;
		};

	void ClearCreated( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_CREATED);
		};

	BOOL IsCreated( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_CREATED)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	void SetNeedToDestroy( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_NEED_TO_DESTROY;
		};

	void ClearNeedToDestroy( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_NEED_TO_DESTROY);
		};

	BOOL IsNeedToDestroy( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_NEED_TO_DESTROY)
			{
				return(TRUE);
			}
			return(FALSE);
		};

	void SetInUse( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_IN_USE;
		};

	void ClearInUse( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_IN_USE);
		};

	BOOL IsInUse( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_IN_USE)
			{
				return( TRUE );
			}
			return( FALSE );
		};

	void StartConnecting( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_CONNECTING;
		};

	void StopConnecting( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_CONNECTING);
		};

	BOOL IsConnecting( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_CONNECTING)
				return(TRUE);

			return(FALSE);
		};

	void CNameTableEntry::StartDisconnecting( void )
		{
			m_dwFlags |= NAMETABLE_ENTRY_FLAG_DISCONNECTING;
		};

	void StopDisconnecting( void )
		{
			m_dwFlags &= (~NAMETABLE_ENTRY_FLAG_DISCONNECTING);
		};

	BOOL IsDisconnecting( void )
		{
			if (m_dwFlags & NAMETABLE_ENTRY_FLAG_DISCONNECTING)
				return(TRUE);

			return(FALSE);
		};

	void SetDPNID(const DPNID dpnid)
		{
			m_dpnid = dpnid;
		};

	DPNID GetDPNID(void)
		{
			return(m_dpnid);
		};

	void SetContext(void *const pvContext)
		{
			m_pvContext = pvContext;
		};

	void *GetContext(void)
		{
			return(m_pvContext);
		};

	void SetDNETVersion( const DWORD dwDNETVersion )
		{
			m_dwDNETVersion = dwDNETVersion;
		};

	DWORD GetDNETVersion( void )
		{
			return( m_dwDNETVersion );
		};

	void SetVersion(const DWORD dwVersion)
		{
			m_dwVersion = dwVersion;
		};

	DWORD GetVersion( void )
		{
			return(m_dwVersion);
		};

	void SetLatestVersion(const DWORD dwLatestVersion)
		{
			m_dwLatestVersion = dwLatestVersion;
		};

	DWORD GetLatestVersion( void )
		{
			return(m_dwLatestVersion);
		};

	void SetDestroyReason( const DWORD dwReason )
		{
			m_dwDestroyReason = dwReason;
		};

	DWORD GetDestroyReason( void )
		{
			return( m_dwDestroyReason );
		};

	HRESULT CNameTableEntry::UpdateEntryInfo(WCHAR *const pwszName,
											 const DWORD dwNameSize,
											 void *const pvData,
											 const DWORD dwDataSize,
											 const DWORD dwInfoFlags,
											 BOOL fNotify);

	WCHAR *GetName( void )
		{
			return(m_pwszName);
		};

	DWORD GetNameSize( void )
		{
			return(m_dwNameSize);
		};

	void *GetData( void )
		{
			return(m_pvData);
		};

	DWORD GetDataSize( void )
		{
			return(m_dwDataSize);
		};

	void SetOwner(const DPNID dpnidOwner)
		{
			m_dpnidOwner = dpnidOwner;
		};

	DPNID GetOwner( void )
		{
			return(m_dpnidOwner);
		};

	void SetAddress( IDirectPlay8Address *const pAddress );

	IDirectPlay8Address *GetAddress( void )
		{
			return(m_pAddress);
		};

	void SetConnection( CConnection *const pConnection );

	CConnection *GetConnection( void )
		{
			return(m_pConnection);
		};

	HRESULT	CNameTableEntry::GetConnectionRef( CConnection **const ppConnection );

	HRESULT	CNameTableEntry::PackInfo(CPackedBuffer *const pPackedBuffer);

	HRESULT CNameTableEntry::PackEntryInfo(CPackedBuffer *const pPackedBuffer);

	HRESULT CNameTableEntry::UnpackEntryInfo(DN_NAMETABLE_ENTRY_INFO *const pdnEntryInfo,
											 BYTE *const pBufferStart);

	void CNameTableEntry::PerformQueuedOperations(void);

	void CNameTableEntry::DumpEntry(char *const pBuffer);

	CBilink				m_bilinkEntries;
	CBilink				m_bilinkDeleted;
	CBilink				m_bilinkMembership;
	CBilink				m_bilinkConnections;
	CBilink				m_bilinkQueuedMsgs;
	DEBUG_ONLY(LONG		m_lNumQueuedMsgs);

private:
	BYTE				m_Sig[4];
	DPNID				m_dpnid;
	DPNID				m_dpnidOwner;
	void *				m_pvContext;
	LONG	volatile	m_lRefCount;
	LONG	volatile	m_lNotifyRefCount;
	DWORD	volatile	m_dwFlags;
	DWORD				m_dwDNETVersion;
	DWORD				m_dwVersion;
	DWORD				m_dwVersionNotUsed;
	DWORD	volatile	m_dwLatestVersion;
	DWORD	volatile	m_dwDestroyReason;
	PWSTR				m_pwszName;
	DWORD				m_dwNameSize;
	void *				m_pvData;
	DWORD				m_dwDataSize;
	IDirectPlay8Address	*m_pAddress;
	CConnection			*m_pConnection;

	DIRECTNETOBJECT		*m_pdnObject;

	DNCRITICAL_SECTION	m_csEntry;
	DNCRITICAL_SECTION	m_csMembership;
	DNCRITICAL_SECTION	m_csConnections;
};

#undef DPF_MODNAME

#endif	// __NTENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\ntoplist.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTOpList.h
 *  Content:    DirectNet NameTable Operation List Header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/19/00	mjn		Created
 *	01/20/00	mjn		Added DNNTOLGetVersion,DNNTOLDestroyEntry,
 *						DNNTOLCleanUp,DNNTOLProcessOperation
 *	01/24/00	mjn		Implemented NameTable operation list version cleanup
 *	01/25/00	mjn		Added pending operation list routines DNPOAdd and DNPORun
 *	01/26/00	mjn		Added DNNTOLFindEntry
 *	07/19/00	mjn		Added DNPOCleanUp()
 *	08/28/00	mjn		Moved CPendingDeletion out
 *				mjn		Revamped NameTable operation list routines
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__NTOPLIST_H__
#define	__NTOPLIST_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DN_NAMETABLE_OP_RESYNC_INTERVAL		4

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************


//
//
//

HRESULT DNNTHostReceiveVersion(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   void *const pMsg);

HRESULT DNNTPlayerSendVersion(DIRECTNETOBJECT *const pdnObject);

HRESULT DNNTHostResyncVersion(DIRECTNETOBJECT *const pdnObject,
							  const DWORD dwVersion);

HRESULT DNNTPlayerResyncVersion(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg);

//
//
//

HRESULT DNNTGetOperationVersion(DIRECTNETOBJECT *const pdnObject,
								const DWORD dwMsgId,
								void *const pOpBuffer,
								const DWORD dwOpBufferSize,
								DWORD *const pdwVersion,
								DWORD *const pdwVersionNotUsed);

HRESULT DNNTPerformOperation(DIRECTNETOBJECT *const pdnObject,
							 const DWORD dwMsgId,
							 void *const pvBuffer);

HRESULT DNNTAddOperation(DIRECTNETOBJECT *const pdnObject,
						 const DWORD dwMsgId,
						 void *const pOpBuffer,
						 const DWORD dwOpBufferSize,
						 const HANDLE hProtocol);

HRESULT	DNNTFindOperation(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwVersion,
						  CNameTableOp **ppNTOp);

void DNNTRemoveOperations(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwOldestVersion,
						  const BOOL fRemoveAll);


//**********************************************************************
// Class prototypes
//**********************************************************************

#endif	// __NTOPLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\pendingdel.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       PendingDel.h
 *  Content:    DirectNet NameTable Pending Deletions Header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/28/00	mjn		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef	__PENDINGDEL_H__
#define	__PENDINGDEL_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif

#ifndef	CONTAINING_OBJECT
#define	CONTAINING_OBJECT(b,t,m)	(reinterpret_cast<t*>(&reinterpret_cast<BYTE*>(b)[-OFFSETOF(t,m)]))
#endif

//**********************************************************************
// Structure definitions
//**********************************************************************

template< class CPendingDeletion > class CLockedContextClassFixedPool;

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

// class for NameTable Pending Deletions

class CPendingDeletion
{
	STDNEWDELETE

public:

	CPendingDeletion()
	{
		m_Sig[0] = 'N';
		m_Sig[1] = 'T';
		m_Sig[2] = 'P';
		m_Sig[3] = 'D';
	};

	~CPendingDeletion() { };

	BOOL FPMAlloc(void *const pvContext)
		{
			m_pdnObject = static_cast<DIRECTNETOBJECT*>(pvContext);

			return(TRUE);
		};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CPendingDeletion::FPMInitialize"
	BOOL FPMInitialize(void *const pvContext)
		{
			DNASSERT(m_pdnObject == pvContext);
			m_dpnid = 0;
			m_bilinkPendingDeletions.Initialize();

			return(TRUE);
		};

	void FPMRelease(void *const pvContext) { };

	void FPMDealloc(void *const pvContext) { };

	void ReturnSelfToPool( void )
		{
			m_pdnObject->m_pFPOOLPendingDeletion->Release( this );
		};

	void SetDPNID( const DPNID dpnid )
		{
			m_dpnid = dpnid;
		};

	DPNID GetDPNID( void )
		{
			return( m_dpnid );
		};

	CBilink			m_bilinkPendingDeletions;

private:
	BYTE			m_Sig[4];
	DIRECTNETOBJECT	*m_pdnObject;
	DPNID			m_dpnid;
};

#undef DPF_MODNAME

#endif	// __PENDINGDEL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\ntoplist.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       NTOpList.cpp
 *  Content:    DirectNet NameTable Operation List
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/19/00	mjn		Created
 *	01/20/00	mjn		Added DNNTOLGetVersion,DNNTOLDestroyEntry,
 *						DNNTOLCleanUp,DNNTOLProcessOperation
 *	01/21/00	mjn		Host ACKnowledgements contain the actual op and not the REQuest
 *	01/24/00	mjn		Implemented NameTable operation list version cleanup
 *	01/25/00	mjn		Send dwLatestVersion to Host at migration
 *	01/25/00	mjn		Added pending operation list routines DNPOAdd and DNPORun
 *	01/26/00	mjn		Added DNNTOLFindEntry
 *	04/19/00	mjn		Update NameTable operations to use DN_WORKER_JOB_SEND_NAMETABLE_OPERATION
 *	05/03/00	mjn		Use GetHostPlayerRef() rather than GetHostPlayer()
 *	07/19/00	mjn		Added DNPOCleanUp()
 *	07/31/00	mjn		Change DN_MSG_INTERNAL_DELETE_PLAYER to DN_MSG_INTERNAL_DESTROY_PLAYER
 *	08/08/00	mjn		Ensure DNOLPlayerSendVersion() takes player reference correctly
 *	08/24/00	mjn		Added CNameTableOp (to replace DN_NAMETABLE_OP)
 *	09/17/00	mjn		Split CNameTable.m_bilinkEntries into m_bilinkPlayers and m_bilinkGroups
 *	09/28/00	mjn		Fixed logic error in DNNTAddOperation()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"



//	DNNTHostReceiveVersion
//
//	Update the NameTable version of a player's entry in the Host player's NameTable

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTHostReceiveVersion"

HRESULT DNNTHostReceiveVersion(DIRECTNETOBJECT *const pdnObject,
							   const DPNID dpnid,
							   void *const pMsg)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pNTEntry;
	DN_INTERNAL_MESSAGE_NAMETABLE_VERSION	*pInfo;

	DPF(6,"Parameters: dpnid [0x%lx], pMsg [0x%p]",dpnid,pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

	pNTEntry = NULL;

	pInfo = static_cast<DN_INTERNAL_MESSAGE_NAMETABLE_VERSION*>(pMsg);

	//
	//	Find player's entry in NameTable
	//
	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Player no longer in NameTable");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}

	//
	//	Update version number of entry
	//
	DPF(7,"Set player [0x%lx] dwLatestVersion [%ld]", dpnid,pInfo->dwVersion);
	pNTEntry->Lock();
	pNTEntry->SetLatestVersion(pInfo->dwVersion);
	pNTEntry->Unlock();
	pNTEntry->Release();
	pNTEntry = NULL;

	//
	//	If the host is migrating, see if we can continue
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_HOST_MIGRATING)
	{
		DNCheckReceivedAllVersions(pdnObject);
	}
	else
	{
		DWORD	dwOldestVersion;
		BOOL	fReSync;
		CBilink	*pBilink;

		//
		//	Determine the oldest version EVERYONE has updated to
		//
		fReSync = FALSE;
		dwOldestVersion = pInfo->dwVersion;
		pdnObject->NameTable.Lock();
		pBilink = pdnObject->NameTable.m_bilinkPlayers.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkPlayers)
		{
			pNTEntry = CONTAINING_OBJECT(pBilink,CNameTableEntry,m_bilinkEntries);
			pNTEntry->Lock();
			if (pNTEntry->IsAvailable() && !pNTEntry->IsHost())
			{
				if (pNTEntry->GetLatestVersion() < dwOldestVersion)
				{
					dwOldestVersion = pNTEntry->GetLatestVersion();
				}
			}
			pNTEntry->Unlock();
			pNTEntry = NULL;
			pBilink = pBilink->GetNext();
		}
		if (dwOldestVersion > pdnObject->NameTable.GetLatestVersion())
		{
			fReSync = TRUE;
		}
		pdnObject->NameTable.Unlock();

		//
		//	Resync NameTable versions of other players if required
		//
		if (fReSync)
		{
			DNNTHostResyncVersion(pdnObject,dwOldestVersion);
		}
	}

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pNTEntry)
	{
		pNTEntry->Release();
		pNTEntry = NULL;
	}
	goto Exit;
}


//	DNNTPlayerSendVersion
//
//	Send the Local player's NameTable version to the Host
//	This should only be called in Peer-to-Peer mode

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTPlayerSendVersion"

HRESULT DNNTPlayerSendVersion(DIRECTNETOBJECT *const pdnObject)
{
	HRESULT				hResultCode;
	CNameTableEntry		*pHostPlayer;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_NAMETABLE_VERSION	*pInfo;

	DPF(6,"Parameters: (none)");

	DNASSERT(pdnObject != NULL);
	DNASSERT(pdnObject->dwFlags & DN_OBJECT_FLAG_PEER);
	DNASSERT(pdnObject->NameTable.GetLocalPlayer() != NULL);

	pHostPlayer = NULL;
	pRefCountBuffer = NULL;
	pWorkerJob = NULL;

	//
	//	Get Host player reference
	//
	if ((hResultCode = pdnObject->NameTable.GetHostPlayerRef( &pHostPlayer )) != DPN_OK)
	{
		DPFERR("Could not find Host player");
		DisplayDNError(0,hResultCode);
		hResultCode = DPNERR_NOHOSTPLAYER;
		goto Failure;
	}

	//
	//	Host player updates entry directly
	//
	if (pHostPlayer->IsLocal())
	{
		DWORD	dwVersion;

		pdnObject->NameTable.Lock();
		dwVersion = pdnObject->NameTable.GetVersion();
		pdnObject->NameTable.Unlock();

		DPF(7,"Set Host player dwLatestVersion [%ld]",dwVersion);
		pHostPlayer->Lock();
		pHostPlayer->SetLatestVersion(dwVersion);
		pHostPlayer->Unlock();

	}
	else
	{
		//
		//	Create message and send to Host player
		//
		if ((hResultCode = RefCountBufferNew(pdnObject,
				sizeof(DN_INTERNAL_MESSAGE_NAMETABLE_VERSION),&pRefCountBuffer)) != DPN_OK)
		{
			DPFERR("Could not allocate space for RefCount buffer");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pInfo = reinterpret_cast<DN_INTERNAL_MESSAGE_NAMETABLE_VERSION*>(pRefCountBuffer->GetBufferAddress());
		pdnObject->NameTable.Lock();
		pInfo->dwVersion = pdnObject->NameTable.GetVersion();
		pInfo->dwVersionNotUsed = 0;
		pdnObject->NameTable.Unlock();

		DPF(7,"Send Local player dwLatestVersion [%ld]",pInfo->dwVersion);

		//
		//	Send message to host player
		//
		if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
		{
			DPFERR("Could not create worker job");
			DisplayDNError(0,hResultCode);
			DNASSERT(FALSE);
			goto Failure;
		}
		pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_VERSION );
		pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

		DNQueueWorkerJob(pdnObject,pWorkerJob);
		pWorkerJob = NULL;

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	pHostPlayer->Release();
	pHostPlayer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pHostPlayer)
	{
		pHostPlayer->Release();
		pHostPlayer = NULL;
	}
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	goto Exit;
}


//	DNNTHostResyncVersion
//
//	Re-sync of the NameTable operation lists based on lowest common version number

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTHostResyncVersion"

HRESULT DNNTHostResyncVersion(DIRECTNETOBJECT *const pdnObject,
							  const DWORD dwVersion)
{
	HRESULT				hResultCode;
	CRefCountBuffer		*pRefCountBuffer;
	CWorkerJob			*pWorkerJob;
	DN_INTERNAL_MESSAGE_RESYNC_VERSION	*pInfo;

	DPF(6,"Parameters: dwVersion [%ld]",dwVersion);

	DNASSERT(pdnObject != NULL);

	pWorkerJob = NULL;
	pRefCountBuffer = NULL;

	//
	//	Create re-sync message
	//
	if ((hResultCode = RefCountBufferNew(pdnObject,sizeof(DN_INTERNAL_MESSAGE_RESYNC_VERSION),&pRefCountBuffer)) != DPN_OK)
	{
		DPFERR("Could not allocate RefCount buffer");
		DisplayDNError(0,hResultCode);
		DNASSERT(FALSE);
		goto Failure;
	}
	pInfo = (DN_INTERNAL_MESSAGE_RESYNC_VERSION *)(pRefCountBuffer->GetBufferAddress());
	pInfo->dwVersion = dwVersion;
	pInfo->dwVersionNotUsed = 0;

	//
	//	Hand this to worker thread
	//
	if ((hResultCode = WorkerJobNew(pdnObject,&pWorkerJob)) != DPN_OK)
	{
		DPFERR("Could not allocate new worker thread job");
		DisplayDNError(0,hResultCode);
		goto Failure;
	}
	pWorkerJob->SetJobType( WORKER_JOB_SEND_NAMETABLE_OPERATION );
	pWorkerJob->SetSendNameTableOperationMsgId( DN_MSG_INTERNAL_RESYNC_VERSION );
	pWorkerJob->SetSendNameTableOperationVersion( 0 );
	pWorkerJob->SetSendNameTableOperationDPNIDExclude( 0 );
	pWorkerJob->SetRefCountBuffer( pRefCountBuffer );

	DNQueueWorkerJob(pdnObject,pWorkerJob);
	pWorkerJob = NULL;

	pRefCountBuffer->Release();
	pRefCountBuffer = NULL;

	hResultCode = DPN_OK;

Exit:
	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pWorkerJob)
	{
		pWorkerJob->ReturnSelfToPool();
		pWorkerJob = NULL;
	}
	goto Exit;
}


//	DNNTPlayerResyncVersion
//
//	Re-sync of the NameTable operation list from Host player

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTPlayerResyncVersion"

HRESULT DNNTPlayerResyncVersion(DIRECTNETOBJECT *const pdnObject,
								void *const pMsg)
{
	HRESULT		hResultCode;
	DN_INTERNAL_MESSAGE_RESYNC_VERSION	*pInfo;

	DPF(6,"Parameters: pMsg [0x%p]",pMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(pMsg != NULL);

	pInfo = static_cast<DN_INTERNAL_MESSAGE_RESYNC_VERSION*>(pMsg);

	DPF(5,"Instructed to clean up NameTable operation list dwVersion < [%ld]",
			pInfo->dwVersion);
	DNNTRemoveOperations(pdnObject,pInfo->dwVersion,FALSE);

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//	DNNTGetOperationVersion
//
//	Find the version number of a NameTable Operation

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTGetOperationVersion"

HRESULT DNNTGetOperationVersion(DIRECTNETOBJECT *const pdnObject,
								const DWORD dwMsgId,
								void *const pOpBuffer,
								const DWORD dwOpBufferSize,
								DWORD *const pdwVersion,
								DWORD *const pdwVersionNotUsed)
{
	HRESULT	hResultCode;

	DPF(6,"Parameters: dwMsgId [0x%lx], pOpBuffer [0x%p], dwOpBufferSize [%ld], pdwVersion [0x%p]",
			dwMsgId,pOpBuffer,dwOpBufferSize,pdwVersion);

	DNASSERT(pdwVersion != NULL);
	DNASSERT(pdwVersionNotUsed != NULL);

	hResultCode = DPN_OK;
	switch (dwMsgId)
	{
	case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
		{
			*pdwVersion = static_cast<DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT *>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_ADD_PLAYER:
		{
			*pdwVersion = static_cast<DN_NAMETABLE_ENTRY_INFO *>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<DN_NAMETABLE_ENTRY_INFO *>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_DESTROY_PLAYER:
		{
			*pdwVersion = static_cast<DN_INTERNAL_MESSAGE_DESTROY_PLAYER *>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<DN_INTERNAL_MESSAGE_DESTROY_PLAYER *>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_CREATE_GROUP:
		{
			*pdwVersion = (reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>((static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(pOpBuffer)) + 1))->dwVersion;
			*pdwVersionNotUsed = (reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>((static_cast<DN_INTERNAL_MESSAGE_CREATE_GROUP*>(pOpBuffer)) + 1))->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_DESTROY_GROUP:
		{
			*pdwVersion = static_cast<DN_INTERNAL_MESSAGE_DESTROY_GROUP*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<DN_INTERNAL_MESSAGE_DESTROY_GROUP*>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
		{
			*pdwVersion = static_cast<DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP*>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:
		{
			*pdwVersion = static_cast<DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP*>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	case DN_MSG_INTERNAL_UPDATE_INFO:
		{
			*pdwVersion = static_cast<DN_INTERNAL_MESSAGE_UPDATE_INFO*>(pOpBuffer)->dwVersion;
			*pdwVersionNotUsed = static_cast<DN_INTERNAL_MESSAGE_UPDATE_INFO*>(pOpBuffer)->dwVersionNotUsed;
			break;
		}
	default:
		{
			DPFERR("Invalid MessageID");
			DNASSERT(FALSE);
			hResultCode = DPNERR_UNSUPPORTED;
		}
	}
	if (hResultCode == DPN_OK)
	{
		DPF(7,"*pdwVersion = [%ld]",*pdwVersion);
	}

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNNTPerformOperation"

HRESULT DNNTPerformOperation(DIRECTNETOBJECT *const pdnObject,
							 const DWORD dwMsgId,
							 void *const pvBuffer)
{
	HRESULT		hResultCode;

	DPF(6,"Parameters: dwMsgId [0x%lx], pvBuffer [0x%p]",dwMsgId,pvBuffer);

	switch (dwMsgId)
	{
	case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
		{
			DPF(7,"Perform DN_MSG_INTERNAL_INSTRUCT_CONNECT");
			if ((hResultCode = DNConnectToPeer2(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Instructed connect failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_ADD_PLAYER:
		{
			DPF(7,"Perform DN_MSG_INTERNAL_ADD_PLAYER");
			if ((hResultCode = DNConnectToPeer1(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Add player failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_DESTROY_PLAYER:
		{
			DPF(7,"Perform DN_MSG_INTERNAL_DESTROY_PLAYER");
			if ((hResultCode = DNInstructedDisconnect(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Destroy player failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_CREATE_GROUP:
		{
			DPF(7,"Perform DN_MSG_INTERNAL_CREATE_GROUP");
			if ((hResultCode = DNProcessCreateGroup(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Create group failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_DESTROY_GROUP:
		{
			DPF(7,"Perform DN_MSG_INTERNAL_DESTROY_GROUP");
			if ((hResultCode = DNProcessDestroyGroup(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Destroy group failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
		{
			DPF(7,"Perform DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP");
			if ((hResultCode = DNProcessAddPlayerToGroup(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Add player to group failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:
		{
			DPF(7,"Perform DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP");
			if ((hResultCode = DNProcessDeletePlayerFromGroup(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Remove player from group failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	case DN_MSG_INTERNAL_UPDATE_INFO:
		{
			DPF(7,"Perform DN_MSG_INTERNAL_UPDATE_INFO");
			if ((hResultCode = DNProcessUpdateInfo(pdnObject,pvBuffer)) != DPN_OK)
			{
				DPFERR("Update info failed");
				DisplayDNError(0,hResultCode);
			}
			break;
		}
	default:
		{
			DPFERR("Invalid MessageID");
			DNASSERT(FALSE);
			return(DPNERR_UNSUPPORTED);
		}
	}

	hResultCode = DPN_OK;

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNNTAddOperation
//
//	Add an operation to the NameTable operation list

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTAddOperation"

HRESULT DNNTAddOperation(DIRECTNETOBJECT *const pdnObject,
						 const DWORD dwMsgId,
						 void *const pOpBuffer,
						 const DWORD dwOpBufferSize,
						 const HANDLE hProtocol)
{
	HRESULT			hResultCode;
	CRefCountBuffer	*pRefCountBuffer;
	CNameTableOp	*pNTOp;
	BOOL			fReSync;

	DPF(4,"Parameters: dwMsgId [0x%lx], pOpBuffer [0x%p], dwOpBufferSize [%ld], hProtocol [0x%lx]",
			dwMsgId,pOpBuffer,dwOpBufferSize,hProtocol);

	pRefCountBuffer = NULL;
	pNTOp = NULL;
	fReSync = FALSE;

	//
	//	We will only need to worry about maintaining the operation list in PEER mode.
	//	Otherwise, just perform the operation
	//
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_PEER)
	{
		DWORD			dwVersion;
		DWORD			dwVersionNotUsed;
		BOOL			fFound;
		BOOL			fImmediate;
		CBilink			*pBilink;
		CNameTableOp	*pCurrent;

		dwVersion = 0;
		dwVersionNotUsed = 0;

		//
		//	Get version of this operation
		//
		if ((hResultCode = DNNTGetOperationVersion(	pdnObject,
													dwMsgId,
													pOpBuffer,
													dwOpBufferSize,
													&dwVersion,
													&dwVersionNotUsed)) != DPN_OK)
		{
			DPFERR("Could not determine operation version");
			DisplayDNError(0,hResultCode);
			hResultCode = DPN_OK;
			goto Failure;
		}

		//
		//	Create NameTableOp
		//
		if ((hResultCode = NameTableOpNew(pdnObject,&pNTOp)) != DPN_OK)
		{
			DPFERR("Could not create NameTableOp");
			DisplayDNError(0,hResultCode);
			hResultCode = DPN_OK;
			goto Failure;
		}

		//
		//	Keep operation in a RefCountBuffer.  If a protocol buffer was supplied (with handle)
		//	we will just release the buffer when we're done with it.  Otherwise, we will need
		//	to copy the buffer supplied.
		//
		if (hProtocol)
		{
			if ((hResultCode = RefCountBufferNew(pdnObject,0,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				hResultCode = DPN_OK;
				goto Failure;
			}
			pRefCountBuffer->SetBufferDesc(	static_cast<BYTE*>(pOpBuffer),
											dwOpBufferSize,
											DNFreeProtocolBuffer,
											hProtocol);
		}
		else
		{
			if ((hResultCode = RefCountBufferNew(pdnObject,dwOpBufferSize,&pRefCountBuffer)) != DPN_OK)
			{
				DPFERR("Could not create RefCountBuffer");
				DisplayDNError(0,hResultCode);
				hResultCode = DPN_OK;
				goto Failure;
			}
			memcpy(pRefCountBuffer->GetBufferAddress(),pOpBuffer,dwOpBufferSize);
		}

		pNTOp->SetMsgId(dwMsgId);
		pNTOp->SetRefCountBuffer(pRefCountBuffer);
		pNTOp->SetVersion(dwVersion);

		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;

		//
		//	Insert into the NameTableOp list
		//
		fFound = FALSE;
		fImmediate = FALSE;
		pdnObject->NameTable.Lock();
		pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
		{
			pCurrent = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
			if (dwVersion < pCurrent->GetVersion())
			{
				pNTOp->m_bilinkNameTableOps.InsertBefore(&pCurrent->m_bilinkNameTableOps);
				fFound = TRUE;
				break;
			}
			pBilink = pBilink->GetNext();
		}
		if (!fFound)
		{
			pNTOp->m_bilinkNameTableOps.InsertBefore(&pdnObject->NameTable.m_bilinkNameTableOps);
		}

		pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
		while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
		{
			pCurrent = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
			if (pCurrent->GetVersion() > pdnObject->NameTable.GetVersion())
			{
				DPF(8,"Current [%ld], NameTable [%ld], InUse [%ld]",pCurrent->GetVersion(),
						pdnObject->NameTable.GetVersion(),pCurrent->IsInUse());
				if ((pCurrent->GetVersion() == (pdnObject->NameTable.GetVersion() + 1))
						&& !pCurrent->IsInUse())
				{
					pCurrent->SetInUse();
					if ((pCurrent->GetVersion() % DN_NAMETABLE_OP_RESYNC_INTERVAL) == 0)
					{
						fReSync = TRUE;
					}
					pdnObject->NameTable.Unlock();

					hResultCode = DNNTPerformOperation(	pdnObject,
														pCurrent->GetMsgId(),
														pCurrent->GetRefCountBuffer()->GetBufferAddress() );

					pdnObject->NameTable.Lock();
				}
				else
				{
					//
					//	Once we find an operation that we won't perform, there is no point continuing
					//
					break;
				}
			}
			pBilink = pBilink->GetNext();
		}
		pdnObject->NameTable.Unlock();

		//
		//	Send a re-sync to the host if required
		//
		if (fReSync)
		{
			DPF(5,"Send NameTable version re-sync to Host");
			DNNTPlayerSendVersion(pdnObject);
		}

		//
		//	We will keep the operation buffer (if specified) so return DPNERR_PENDING
		//
		if (hProtocol)
		{
			hResultCode = DPNERR_PENDING;
		}
		else
		{
			hResultCode = DPN_OK;
		}
	}
	else
	{
		DNNTPerformOperation(pdnObject,dwMsgId,pOpBuffer);

		//
		//	We will not need to keep the operation buffer so return DPN_OK
		//
		hResultCode = DPN_OK;
	}

Exit:
	DPF(4,"Returning: [0x%lx]",hResultCode);
	return( hResultCode);

Failure:
	if (pRefCountBuffer)
	{
		pRefCountBuffer->Release();
		pRefCountBuffer = NULL;
	}
	if (pNTOp)
	{
		pNTOp->ReturnSelfToPool();
		pNTOp = NULL;
	}
	goto Exit;
}


//	DNNTFindOperation
//
//	Find a NameTable Operation

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTFindOperation"

HRESULT	DNNTFindOperation(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwVersion,
						  CNameTableOp **ppNTOp)
{
	HRESULT			hResultCode;
	CBilink			*pBilink;
	CNameTableOp	*pNTOp;

	DPF(6,"Parameters: dwVersion [%ld = 0x%lx], ppNTOp [0x%p]",dwVersion,dwVersion,ppNTOp);

	DNASSERT(ppNTOp != NULL);

	hResultCode = DPNERR_DOESNOTEXIST;
	pdnObject->NameTable.Lock();
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		if (pNTOp->GetVersion() == dwVersion)
		{
			*ppNTOp = pNTOp;
			hResultCode = DPN_OK;
			break;
		}
		else if (pNTOp->GetVersion() > dwVersion)
		{
			//
			//	Passed where it could have been, so there is no point in continuing
			//
			break;
		}
		pBilink = pBilink->GetNext();
	}
	pdnObject->NameTable.Unlock();

	DPF(6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//	DNNTRemoveOperations
//
//	Remove NameTable Operations

#undef DPF_MODNAME
#define DPF_MODNAME "DNNTRemoveOperations"

void DNNTRemoveOperations(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwOldestVersion,
						  const BOOL fRemoveAll)
{
	CBilink			*pBilink;
	CNameTableOp	*pNTOp;

	DPF(4,"Parameters: dwOldestVersion [%ld = 0x%lx], fRemoveAll [%ld]",dwOldestVersion,dwOldestVersion,fRemoveAll);

	DNASSERT(pdnObject != NULL);

	pdnObject->NameTable.Lock();
	pBilink = pdnObject->NameTable.m_bilinkNameTableOps.GetNext();
	while (pBilink != &pdnObject->NameTable.m_bilinkNameTableOps)
	{
		pNTOp = CONTAINING_OBJECT(pBilink,CNameTableOp,m_bilinkNameTableOps);
		pBilink = pBilink->GetNext();

		if (fRemoveAll || (pNTOp->GetVersion() < dwOldestVersion))
		{
			pNTOp->m_bilinkNameTableOps.RemoveFromList();
			if (pNTOp->GetRefCountBuffer())
			{
				pNTOp->GetRefCountBuffer()->Release();
				pNTOp->SetRefCountBuffer( NULL );
			}
			pNTOp->ReturnSelfToPool();
		}
	}
	pdnObject->NameTable.Unlock();

	DPF(4,"Returning");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\pools.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Pools.cpp
 *  Content:	Fixed Pool Wrappers
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/12/00	mjn		Created
 *	01/19/00	mjn		Added SyncEventNew()
 *	01/31/00	mjn		Added Internal FPM's for RefCountBuffers
 *	02/29/00	mjn		Added ConnectionNew()
 *	04/08/00	mjn		Added AsyncOpNew()
 *	07/28/00	mjn		Track outstanding CConnection objects
 *	07/30/00	mjn		Added PendingDeletionNew()
 *	07/31/00	mjn		Added QueuedMsgNew()
 *  08/05/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	08/06/00	mjn		Added CWorkerJob
 *	08/23/00	mjn		Added CNameTableOp
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// RefCountBufferNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//				const DWORD	dwBufferSize		- Size of buffer (may be 0)
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "RefCountBufferNew"

HRESULT RefCountBufferNew(DIRECTNETOBJECT *const pdnObject,
						  const DWORD dwBufferSize,
						  CRefCountBuffer **const ppNewRefCountBuffer)
{
	CRefCountBuffer	*pRCBuffer;
	HRESULT			hResultCode;

	DPF(8,"Parameters: dwBufferSize [%ld], ppNewRefCountBuffer [0x%p]",
			dwBufferSize,ppNewRefCountBuffer);

	pRCBuffer = pdnObject->m_pFPOOLRefCountBuffer->Get(pdnObject);
	if (pRCBuffer != NULL)
	{
		if ((hResultCode = pRCBuffer->Initialize(pdnObject->m_pFPOOLRefCountBuffer,
				MemoryBlockAlloc,MemoryBlockFree,(PVOID)pdnObject,dwBufferSize)) != DPN_OK)
		{
			DPFERR("Could not initialize");
			DisplayDNError(0,hResultCode);
			pRCBuffer->Release();
			hResultCode = DPNERR_OUTOFMEMORY;
		}
		else
		{
			*ppNewRefCountBuffer = pRCBuffer;
			hResultCode = DPN_OK;
		}
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPF(8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
// SyncEventNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "SyncEventNew"

HRESULT SyncEventNew(DIRECTNETOBJECT *const pdnObject,
					 CSyncEvent **const ppNewSyncEvent)
{
	CSyncEvent		*pSyncEvent;
	HRESULT			hResultCode;

	DPF(8,"Parameters: ppNewSyncEvent [0x%p]",ppNewSyncEvent);

	pSyncEvent = pdnObject->m_pFPOOLSyncEvent->Get(pdnObject->m_pFPOOLSyncEvent);
	if (pSyncEvent != NULL)
	{
		*ppNewSyncEvent = pSyncEvent;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPF(8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}


//**********************************************************************
// ------------------------------
// ConnectionNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "ConnectionNew"

HRESULT ConnectionNew(DIRECTNETOBJECT *const pdnObject,
					  CConnection **const ppNewConnection)
{
	CConnection		*pConnection;
	HRESULT			hResultCode;

	DPF(8,"Parameters: ppNewConnection [0x%p]",ppNewConnection);

	pConnection = pdnObject->m_pFPOOLConnection->Get(pdnObject);
	if (pConnection != NULL)
	{
		*ppNewConnection = pConnection;
		hResultCode = DPN_OK;

		//
		//	Add this to the bilink of outstanding CConnections
		//
		DNEnterCriticalSection(&pdnObject->csAsyncOperations);
		pConnection->m_bilinkConnections.InsertBefore(&pdnObject->m_bilinkConnections);
		DNLeaveCriticalSection(&pdnObject->csAsyncOperations);
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPF(8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// GroupConnectionNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "GroupConnectionNew"

HRESULT GroupConnectionNew(DIRECTNETOBJECT *const pdnObject,
						   CGroupConnection **const ppNewGroupConnection)
{
	CGroupConnection	*pGroupConnection;
	HRESULT				hResultCode;

	DPF(8,"Parameters: ppNewGroupConnection [0x%p]",ppNewGroupConnection);

	pGroupConnection = pdnObject->m_pFPOOLGroupConnection->Get(pdnObject);
	if (pGroupConnection != NULL)
	{
		*ppNewGroupConnection = pGroupConnection;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPF(8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// GroupMemberNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "GroupMemberNew"

HRESULT GroupMemberNew(DIRECTNETOBJECT *const pdnObject,
					   CGroupMember **const ppNewGroupMember)
{
	CGroupMember	*pGroupMember;
	HRESULT			hResultCode;

	DPF(8,"Parameters: ppNewGroupMember [0x%p]",ppNewGroupMember);

	pGroupMember = pdnObject->m_pFPOOLGroupMember->Get(pdnObject);
	if (pGroupMember != NULL)
	{
		*ppNewGroupMember = pGroupMember;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPF(8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// NameTableEntryNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "NameTableEntryNew"

HRESULT NameTableEntryNew(DIRECTNETOBJECT *const pdnObject,
						  CNameTableEntry **const ppNewNameTableEntry)
{
	CNameTableEntry	*pNewNameTableEntry;
	HRESULT			hResultCode;

	DPF(8,"Parameters: ppNewNameTableEntry [0x%p]",ppNewNameTableEntry);

	pNewNameTableEntry = pdnObject->m_pFPOOLNameTableEntry->Get(pdnObject);
	if (pNewNameTableEntry != NULL)
	{
		*ppNewNameTableEntry = pNewNameTableEntry;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPF(8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// AsyncOpNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "AsyncOpNew"

HRESULT AsyncOpNew(DIRECTNETOBJECT *const pdnObject,
				   CAsyncOp **const ppNewAsyncOp)
{
	CAsyncOp		*pAsyncOp;
	HRESULT			hResultCode;

	DPF(8,"Parameters: ppNewAsyncOp [0x%p]",ppNewAsyncOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewAsyncOp != NULL);

	pAsyncOp = pdnObject->m_pFPOOLAsyncOp->Get(pdnObject);
	if (pAsyncOp != NULL)
	{
		*ppNewAsyncOp = pAsyncOp;
		hResultCode = DPN_OK;

		//
		//	Add this to the bilink of outstanding AsyncOps
		//
		DNEnterCriticalSection(&pdnObject->csAsyncOperations);
		pAsyncOp->m_bilinkAsyncOps.InsertBefore(&pdnObject->m_bilinkAsyncOps);
		DNLeaveCriticalSection(&pdnObject->csAsyncOperations);
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPF(8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// PendingDeletionNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "PendingDeletionNew"

HRESULT PendingDeletionNew(DIRECTNETOBJECT *const pdnObject,
						   CPendingDeletion **const ppNewPendingDeletion)
{
	CPendingDeletion	*pPendingDeletion;
	HRESULT				hResultCode;

	DPF(8,"Parameters: ppNewPendingDeletion [0x%p]",ppNewPendingDeletion);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewPendingDeletion != NULL);

	pPendingDeletion = pdnObject->m_pFPOOLPendingDeletion->Get(pdnObject);
	if (pPendingDeletion != NULL)
	{
		*ppNewPendingDeletion = pPendingDeletion;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPF(8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// QueuedMsgNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "QueuedMsgNew"

HRESULT QueuedMsgNew(DIRECTNETOBJECT *const pdnObject,
					 CQueuedMsg **const ppNewQueuedMsg)
{
	CQueuedMsg	*pQueuedMsg;
	HRESULT				hResultCode;

	DPF(8,"Parameters: ppNewQueuedMsg [0x%p]",ppNewQueuedMsg);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewQueuedMsg != NULL);

	pQueuedMsg = pdnObject->m_pFPOOLQueuedMsg->Get(pdnObject);
	if (pQueuedMsg != NULL)
	{
		*ppNewQueuedMsg = pQueuedMsg;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPF(8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// WorkerJobNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "WorkerJobNew"

HRESULT WorkerJobNew(DIRECTNETOBJECT *const pdnObject,
					 CWorkerJob **const ppNewWorkerJob)
{
	CWorkerJob	*pWorkerJob;
	HRESULT				hResultCode;

	DPF(8,"Parameters: ppNewWorkerJob [0x%p]",ppNewWorkerJob);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewWorkerJob != NULL);

	pWorkerJob = pdnObject->m_pFPOOLWorkerJob->Get(pdnObject);
	if (pWorkerJob != NULL)
	{
		*ppNewWorkerJob = pWorkerJob;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPF(8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}



//**********************************************************************
// ------------------------------
// NameTableOpNew
//
// Entry:		DIRECTNETOBJECT *const pdnObject
//
// Exit:		Error Code:	DN_OK
//							DNERR_OUTOFMEMORY
// ------------------------------

#undef DPF_MODNAME
#define DPF_MODNAME "NameTableOpNew"

HRESULT NameTableOpNew(DIRECTNETOBJECT *const pdnObject,
					   CNameTableOp **const ppNewNameTableOp)
{
	CNameTableOp	*pNameTableOp;
	HRESULT			hResultCode;

	DPF(8,"Parameters: ppNewNameTableOp [0x%p]",ppNewNameTableOp);

	DNASSERT(pdnObject != NULL);
	DNASSERT(ppNewNameTableOp != NULL);

	pNameTableOp = pdnObject->m_pFPOOLNameTableOp->Get(pdnObject);
	if (pNameTableOp != NULL)
	{
		*ppNewNameTableOp = pNameTableOp;
		hResultCode = DPN_OK;
	}
	else
	{
		hResultCode = DPNERR_OUTOFMEMORY;
	}

	DPF(8,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\paramval.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       paramval.h
 *  Content:    DirectPlat8 Parameter Validation helper routines
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/28/00    rmt     Created
 *  04/17/00    rmt     More param validation
 *	04/19/00	mjn		Changed DN_RemoveClientFromGroup to DN_ValidateRemoveClientFromGroup (wrong function name)
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2  
 *	08/04/00	mjn		Added dwFlags to DN_ValidateGetConnectionInfoHelper()
 *
 ***************************************************************************/
#ifndef __PARAMVAL_H
#define __PARAMVAL_H

#define DN_CHECK_LOCALHOST( x ) (x->NameTable.GetLocalPlayer() == x->NameTable.GetHostPlayer())

extern BOOL IsValidDirectPlay8Object( LPVOID lpvObject );

extern HRESULT DN_ValidateDestroyPlayer(PVOID pInterface,
							  const DPNID dnid,
							  const void *const pvDestroyData,
							  const DWORD dwDestroyDataSize,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateReturnBuffer(PVOID pInterface,
							 const DPNHANDLE hBufferHandle,
							 const DWORD dwFlags);

extern HRESULT DN_ValidateGetPlayerContext(PVOID pInterface,
								 const DPNID dpnid,
								 PVOID *const ppvPlayerContext,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateGetGroupContext(PVOID pInterface,
								const DPNID dpnid,
								PVOID *const ppvGroupContext,
								const DWORD dwFlags);

extern HRESULT DN_ValidateRegisterLobby(PVOID pInterface,
							  const DPNHANDLE dpnhLobbyConnection, 	
							  VOID *const pIDP8LobbiedApplication,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateTerminateSession(PVOID pInterface,
								 void *const pvTerminateData,
								 const DWORD dwTerminateDataSize,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateGetHostAddress(PVOID pInterface,
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress,
							   const DWORD dwFlags);


extern HRESULT DN_ValidateGetClientAddress(IDirectPlay8Server *pInterface,
								 const DPNID dpnid,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateGetClientInfo(IDirectPlay8Server *pInterface,
							  const DPNID dpnid,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateSetServerInfo(IDirectPlay8Server *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateSetPeerInfo( IDirectPlay8Peer *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateGetPeerInfo(IDirectPlay8Peer *pInterface,
							const DPNID dpnid,
							DPN_PLAYER_INFO *const pdpnPlayerInfo,
							DWORD *const pdwSize,
							const DWORD dwFlags);

extern HRESULT DN_ValidateGetPeerAddress(IDirectPlay8Peer *pInterface,
										 const DPNID dpnid,
										 IDirectPlay8Address **const ppAddress,
										 const DWORD dwFlags);

extern HRESULT DN_ValidateGetServerAddress(IDirectPlay8Client *pInterface,
										   IDirectPlay8Address **const ppAddress,
										   const DWORD dwFlags);

extern HRESULT DN_ValidateGetHostSendQueueInfo(IDirectPlay8Client *pInterface,
									 DWORD *const pdwNumMsgs,
									 DWORD *const pdwNumBytes,
									 const DWORD dwFlags );

extern HRESULT DN_ValidateGetServerInfo(IDirectPlay8Client *pInterface,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags);

extern HRESULT  DN_ValidateSetClientInfo(IDirectPlay8Client *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  const PVOID pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateGetConnectionInfoHelper(PVOID pv,
												  const DPNID dpnid,
												  DPN_CONNECTION_INFO *const pdpConnectionInfo,
												  BOOL fServerPlayer,
												  const DWORD dwFlags);

extern HRESULT DN_ValidateSetCaps(PVOID pv,
						const DPN_CAPS *const pdnCaps,
						const DWORD dwFlags);

extern HRESULT DN_ValidateGetCaps(PVOID pv,
								  DPN_CAPS *const pdnCaps,
								  const DWORD dwFlags);

extern HRESULT DN_ValidateGetSPCaps(PVOID pv,
									const GUID * const pguidSP,
									DPN_SP_CAPS *const pdnSPCaps,
									const DWORD dwFlags);

extern HRESULT DN_ValidateSetSPCaps(PVOID pv,
									const GUID * const pguidSP,
									const DPN_SP_CAPS *const pdnSPCaps,
									const DWORD dwFlags);

extern HRESULT DN_ValidateEnumHosts( PVOID pv,
						   DPN_APPLICATION_DESC *const pApplicationDesc,
                           IDirectPlay8Address *const pAddrHost,
						   IDirectPlay8Address *const pDeviceInfo,
						   PVOID const pUserEnumData,
						   const DWORD dwUserEnumDataSize,
						   const DWORD dwRetryCount,
						   const DWORD dwRetryInterval,
						   const DWORD dwTimeOut,
						   PVOID const pvAsyncContext,
						   DPNHANDLE *const pAsyncHandle,
						   const DWORD dwFlags );

HRESULT DN_ValidateRemoveClientFromGroup(PVOID pInterface,
									  const DPNID dpnidGroup,
									  const DPNID dpnidClient,
									  PVOID const pvAsyncContext,
									  DPNHANDLE *const phAsyncHandle,
									  const DWORD dwFlags);						

extern HRESULT DN_ValidateEnumGroupMembers(PVOID pInterface,
								 const DPNID dpnid,
								 DPNID *const prgdpnid,
								 DWORD *const pcdpnid,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateEnumClientsAndGroups(PVOID pInterface,
									 DPNID *const prgdpnid,
									 DWORD *const pcdpnid,
									 const DWORD dwFlags);

extern HRESULT DN_ValidateGetGroupInfo(PVOID pv,
							 const DPNID dpnid,
							 DPN_GROUP_INFO *const pdpnGroupInfo,
							 DWORD *const pdwSize,
							 const DWORD dwFlags);

extern HRESULT DN_ValidateSetGroupInfo( PVOID pv,
							  const DPNID dpnid,
							  DPN_GROUP_INFO *const pdpnGroupInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags);

extern HRESULT DN_ValidateAddClientToGroup(PVOID pInterface,
								 const DPNID dpnidGroup,
								 const DPNID dpnidClient,
								 PVOID const pvAsyncContext,
								 DPNHANDLE *const phAsyncHandle,
								 const DWORD dwFlags);

extern HRESULT DN_ValidateRemoveClientFromGroup(PVOID pInterface,
									  const DPNID dpnidGroup,
									  const DPNID dpnidClient,
									  PVOID const pvAsyncContext,
									  DPNHANDLE *const phAsyncHandle,
									  const DWORD dwFlags);

extern HRESULT DN_ValidateDestroyGroup(PVOID pInterface,
							 const DPNID dpnidGroup,
							 PVOID const pvAsyncContext,
							 DPNHANDLE *const phAsyncHandle,
							 const DWORD dwFlags);

extern HRESULT DN_ValidateCreateGroup(PVOID pInterface,
							const DPN_GROUP_INFO *const pdpnGroupInfo,
							void *const pvGroupContext,
							void *const pvAsyncContext,
							DPNHANDLE *const phAsyncHandle,
							const DWORD dwFlags);

extern HRESULT DN_ValidateHost( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnAppDesc,
                        IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,
  					    const DPN_SECURITY_DESC *const pdnSecurity,
  					    const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
					    void *const pvPlayerContext, const DWORD dwFlags);

extern HRESULT DN_ValidateEnumServiceProviders( PVOID pInterface,
									  const GUID *const pguidServiceProvider,
									  const GUID *const pguidApplication,
									  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
									  DWORD *const pcbEnumData,
									  DWORD *const pcReturned,
									  const DWORD dwFlags );

extern HRESULT DN_ValidateCancelAsyncOperation(PVOID pvInterface,
									 const DPNHANDLE hAsyncOp,
									 const DWORD dwFlags );

extern HRESULT DN_ValidateConnect( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnAppDesc, IDirectPlay8Address *const pHostAddr,
            					   IDirectPlay8Address *const pDeviceInfo, const DPN_SECURITY_DESC *const pdnSecurity,
  						           const DPN_SECURITY_CREDENTIALS *const pdnCredentials, const void *const pvUserConnectData,
                                   const DWORD dwUserConnectDataSize, void *const pvPlayerContext,
          						   void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags);

extern HRESULT DN_ValidateGetSendQueueInfo(PVOID pInterface, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes,const DWORD dwFlags);

extern HRESULT DN_ValidateSetApplicationDesc( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnApplicationDesc, const DWORD dwFlags);

extern HRESULT DN_ValidateGetApplicationDesc( PVOID pInterface, DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags );

extern HRESULT DN_ValidateSendParams( PVOID pv, const DPN_BUFFER_DESC *const pBufferDesc, const DWORD cBufferDesc, const DWORD dwTimeOut,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags);

extern HRESULT DN_ValidBufferDescs( const DPN_BUFFER_DESC * const pbBufferDesc, const DWORD cBufferCount );

extern HRESULT DN_ValidConnectAppDesc( const DPN_APPLICATION_DESC * const pdnAppDesc );

extern HRESULT DN_ValidHostAppDesc( const DPN_APPLICATION_DESC * const pdnAppDesc );

extern HRESULT DN_ValidPlayerInfo( const DPN_PLAYER_INFO * const pdnPlayerInfo, BOOL fSet);

extern HRESULT DN_ValidGroupInfo( const DPN_GROUP_INFO * const pdnGroupInfo, BOOL fSet );

extern HRESULT DN_ValidSecurityCredentials( const DPN_SECURITY_CREDENTIALS * const pdnCredentials );

extern HRESULT DN_ValidSecurityDesc( const DPN_SECURITY_DESC * const pdnValidSecurityDesc );

extern HRESULT DN_ValidSPCaps( const DPN_SP_CAPS * const pdnSPCaps );

extern HRESULT DN_ValidConnectionInfo( const PDPN_CONNECTION_INFO * const pdnConnectionInfo );

extern HRESULT DN_ValidCaps( const DPN_CAPS * const pdnCaps );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\paramval.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       paramval.cpp
 *  Content:    DirectPlat8 Parameter Validation helper routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/28/00    rmt     Created
 *  04/13/2000  rmt     More parameter validation
 *  04/17/00    rmt     More param validation
 *              rmt     Added DPF_MODNAMES
 *  04/18/00    rmt     Fix: Bug #32669
 *  04/21/00	rmt	Fix: Bug #33056 Param validation preventing read-only buffers
 *  04/25/00    rmt     Fix: Bug #33190 and fixed param validation to allow nodpnsvr flag
 *	04/28/00	mjn		Allow NULL Device Address in DN_ValidateConnect()
 *	05/03/00	mjn		Added DPNENUMSERVICEPROVIDERS_ALL flag
 *	05/31/00	mjn		Added operation specific SYNC flags
 *				mjn		Fix EnumHosts param validation for timeout and enum period
 *	06/12/00	mjn		Removed validation of DPNSEND_ENCRYPTED,DPNSEND_SIGNED,DPNGROUP_MULTICAST,DPNENUM_GROUP_MULTICAST flags
 *	06/27/00	mjn		Allow priorities to be specified to GetSendQueueInfo() API calls
 *				mjn		Added DPNSEND_NONSEQUENTIAL flag to Send/SendTo
 *				mjn		Allow mix-n-match of priorities in GetSendQueueInfo() API call
 *	07/09/00	mjn		Ensure non-null addresses specified to Host
 *  07/12/00	rmt		Bug #39018 - Need param validation on RegisterLobby() API call
 *  07/19/00	aarono	Bug #39751 - fix parameter validation for CancelAsyncOperation
 *	07/20/00	mjn		Fix validation of pvApplicationReservedData in DN_ValidHostAppDesc()
 *	07/26/00	mjn		Fix param validation for Connect(),SendTo(),DestroyGroup(),AddPlayerToGroup()
 *						RemovePlayerFromGroup(),SetGroupInfo()
 *	07/31/00	mjn		Require dwFlags for DN_ValidateEnumClientsAndGroups()
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2
 *	08/04/00	mjn		Added dwFlags to DN_ValidateGetConnectionInfoHelper()
 *	08/05/00	mjn		Allow NULL Host address to EnumHosts()
 *  08/08/00	rmt		Minor parameter validation error
 *	08/20/00	mjn		Prevent 0 length send buffer
 *	09/04/00	mjn		Ensure pvReservedData in application descriptions is NULL
 *  09/16/00	rmt		Bug #45175 - DPLAY8: [A/V] Param validation prevents non-null async handle w/ no complete
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

#ifdef ENABLE_DPLAY_VOICE
extern IDirectPlayVoiceTransport DN_VoiceTbl;
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateDestroyPlayer"
HRESULT DN_ValidateDestroyPlayer(PVOID pInterface,
							  const DPNID dnid,
							  const void *const pvDestroyData,
							  const DWORD dwDestroyDataSize,
							  const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get player context for all players group" );
        return DPNERR_INVALIDPLAYER;
    }

    if( dwDestroyDataSize > 0 &&
        (pvDestroyData == NULL || !DNVALID_READPTR( pvDestroyData, dwDestroyDataSize  ) ) )
    {
        DPFERR( "Invalid pointer specified for destroy data" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified for destroy player" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateReturnBuffer"
HRESULT DN_ValidateReturnBuffer(PVOID pInterface,
							 const DPNHANDLE hBufferHandle,
							 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( hBufferHandle == NULL )
    {
        DPFERR( "Invalid handle specified" );
        return DPNERR_INVALIDHANDLE;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetPlayerContext"
HRESULT DN_ValidateGetPlayerContext(PVOID pInterface,
								 const DPNID dpnid,
								 PVOID *const ppvPlayerContext,
								 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get player context for all players group" );
        return DPNERR_INVALIDPLAYER;
    }

    if( ppvPlayerContext == NULL ||
        !DNVALID_WRITEPTR( ppvPlayerContext, sizeof( PVOID ) ) )
    {
        DPFERR( "Invalid pointer specified for player context" );
        return DPNERR_INVALIDPOINTER;
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetGroupContext"
HRESULT DN_ValidateGetGroupContext(PVOID pInterface,
								const DPNID dpnid,
								PVOID *const ppvGroupContext,
								const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get group context for all players group" );
        return DPNERR_INVALIDGROUP;
    }

    if( ppvGroupContext == NULL ||
        !DNVALID_WRITEPTR( ppvGroupContext, sizeof( PVOID ) ) )
    {
        DPFERR( "Invalid pointer specified for group context" );
        return DPNERR_INVALIDPOINTER;
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateRegisterLobby"
HRESULT DN_ValidateRegisterLobby(PVOID pInterface,
							  const DPNHANDLE dpnhLobbyConnection,
							  VOID *const pIDP8LobbiedApplication,
							  const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

	if( dwFlags == 0 )
	{
		DPFERR( "You must specify either DPNLOBBY_REGISTER or DPNLOBBY_UNREGISTER" );
		return DPNERR_INVALIDFLAGS;
	}

	if( (dwFlags & DPNLOBBY_REGISTER) &&
		(dwFlags & DPNLOBBY_UNREGISTER) )
	{
		DPFERR( "You cannot specify both register and UNREGISTER" );
		return DPNERR_INVALIDPARAM;
	}

    if( dwFlags & ~(DPNLOBBY_REGISTER | DPNLOBBY_UNREGISTER) )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

	if( dwFlags & DPNLOBBY_REGISTER )
	{
	    if( dpnhLobbyConnection == 0 )
	    {
	    	DPF( 0, "Invalid handle" );
	    	return DPNERR_INVALIDHANDLE;
	    }
	}
	else
	{
		if( dpnhLobbyConnection != 0 || pIDP8LobbiedApplication != NULL )
		{
			DPF( 0, "When unregistering you must specify 0 for handle and NULL for lobbiedapp" );
			return DPNERR_INVALIDPARAM;
		}
	}

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateTerminateSession"
HRESULT DN_ValidateTerminateSession(PVOID pInterface,
								 void *const pvTerminateData,
								 const DWORD dwTerminateDataSize,
								 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dwTerminateDataSize > 0 &&
        (pvTerminateData == NULL || !DNVALID_READPTR( pvTerminateData, dwTerminateDataSize ) ) )
    {
        DPFERR( "Invalid pointer specified for terminate data" );
        return DPNERR_INVALIDPOINTER;
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetHostAddress"
HRESULT DN_ValidateGetHostAddress(PVOID pInterface,
							   IDirectPlay8Address **const prgpAddress,
							   DWORD *const pcAddress,
							   const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( pcAddress == NULL || !DNVALID_WRITEPTR( pcAddress, sizeof( DWORD ) ) )
    {
        DPF( 0, "Invalid pointer specified for address count" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pcAddress > 0 &&
         (prgpAddress == NULL || !DNVALID_WRITEPTR( prgpAddress, sizeof( IDirectPlay8Address * ) * (*pcAddress) ) ) )
    {
        DPFERR( "Invalid pointer specified for address" );
        return DPNERR_INVALIDPOINTER;
    }

   	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetClientAddress"
HRESULT DN_ValidateGetClientAddress(IDirectPlay8Server *pInterface,
								 const DPNID dpnid,
								 IDirectPlay8Address **const ppAddress,
								 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get client address for ALL" );
        return DPNERR_INVALIDPLAYER;
    }

    if( ppAddress == NULL || !DNVALID_WRITEPTR( ppAddress, sizeof( IDirectPlay8Address * ) ) )
    {
        DPFERR( "Invalid pointer specified for address" );
        return DPNERR_INVALIDPOINTER;
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetClientInfo"
HRESULT DN_ValidateGetClientInfo(IDirectPlay8Server *pInterface,
							  const DPNID dpnid,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get client info for ALL" );
        return DPNERR_INVALIDPLAYER;
    }

    if( pdwSize == NULL || !DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
    {
        DPFERR( "Error validating size param, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pdwSize &&
        (pdpnPlayerInfo == NULL || !DNVALID_WRITEPTR( pdpnPlayerInfo, *pdwSize ) ) )
    {
        DPFERR( "Error validating player info buffer, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdpnPlayerInfo != NULL )
    {
        if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, FALSE ) ) )
        {
            DPFERR( "Error validating player info" );
            return hResultCode;
        }
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetServerInfo"
HRESULT DN_ValidateSetServerInfo(IDirectPlay8Server *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, TRUE ) ) )
    {
        DPFERR( "Error validating player info" );
        return hResultCode;
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle specified" );
        return( DPNERR_INVALIDPOINTER );
    }

   if( dwFlags )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetPeerInfo"
HRESULT DN_ValidateSetPeerInfo( IDirectPlay8Peer *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, TRUE ) ) )
    {
        DPFERR( "Error validating player info" );
        return hResultCode;
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle specified" );
        return( DPNERR_INVALIDPOINTER );
    }

   if( dwFlags )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }

    return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetPeerInfo"
HRESULT DN_ValidateGetPeerInfo(IDirectPlay8Peer *pInterface,
							const DPNID dpnid,
							DPN_PLAYER_INFO *const pdpnPlayerInfo,
							DWORD *const pdwSize,
							const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get peer info for ALL" );
        return DPNERR_INVALIDPLAYER;
    }

    if( pdwSize == NULL || !DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
    {
        DPFERR( "Error validating size param, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pdwSize &&
        (pdpnPlayerInfo == NULL || !DNVALID_WRITEPTR( pdpnPlayerInfo, *pdwSize ) ) )
    {
        DPFERR( "Error validating player info buffer, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdpnPlayerInfo != NULL )
    {
        if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, FALSE ) ) )
        {
            DPFERR( "Error validating player info" );
            return hResultCode;
        }
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetPeerAddress"
HRESULT DN_ValidateGetPeerAddress(IDirectPlay8Peer *pInterface,
							   const DPNID dpnid,
							   IDirectPlay8Address **const ppAddress,
							   const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot get peer address for ALL" );
        return DPNERR_INVALIDPLAYER;
    }

    if( ppAddress == NULL || !DNVALID_WRITEPTR( ppAddress, sizeof( IDirectPlay8Address * ) ) )
    {
        DPFERR( "Invalid pointer specified for address" );
        return DPNERR_INVALIDPOINTER;
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return DPNERR_INVALIDFLAGS;
	}

    return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetServerAddress"
HRESULT DN_ValidateGetServerAddress(IDirectPlay8Client *pInterface,
									IDirectPlay8Address **const ppAddress,
									const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( ppAddress == NULL || !DNVALID_WRITEPTR( ppAddress, sizeof( IDirectPlay8Address * ) ) )
    {
        DPFERR( "Invalid pointer specified for address" );
        return DPNERR_INVALIDPOINTER;
    }

     if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

   return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetHostSendQueueInfo"
HRESULT DN_ValidateGetHostSendQueueInfo(IDirectPlay8Client *pInterface,
									 DWORD *const pdwNumMsgs,
									 DWORD *const pdwNumBytes,
									 const DWORD dwFlags )
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

	if( pdwNumMsgs != NULL &&
	    !DNVALID_WRITEPTR( pdwNumMsgs, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid num messages specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pdwNumBytes != NULL &&
	    !DNVALID_WRITEPTR( pdwNumBytes, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid num bytes specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pdwNumBytes == NULL && pdwNumMsgs == NULL )
	{
	    DPFERR("Must request at least one of num bytes and num messages" );
	    return( DPNERR_INVALIDPARAM );
	}

    if( dwFlags & ~(DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_LOW | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL) )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetServerInfo"
HRESULT DN_ValidateGetServerInfo(IDirectPlay8Client *pInterface,
							  DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  DWORD *const pdwSize,
							  const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( pdwSize == NULL || !DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
    {
        DPFERR( "Error validating size param, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( *pdwSize &&
        (pdpnPlayerInfo == NULL || !DNVALID_WRITEPTR( pdpnPlayerInfo, *pdwSize ) ) )
    {
        DPFERR( "Error validating player info buffer, invalid pointer" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdpnPlayerInfo != NULL )
    {
        if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, FALSE ) ) )
        {
            DPFERR( "Error validating player info" );
            return hResultCode;
        }
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return DPNERR_INVALIDFLAGS;
    }

    return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetClientInfo"
HRESULT  DN_ValidateSetClientInfo(IDirectPlay8Client *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  const PVOID pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( FAILED( hResultCode = DN_ValidPlayerInfo( pdpnPlayerInfo, TRUE ) ) )
    {
        DPFERR("Error validating player info" );
        return hResultCode;
    }

    if( dwFlags )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetConnectionInfoHelper"
HRESULT DN_ValidateGetConnectionInfoHelper(PVOID pv,
										   const DPNID dpnid,
										   DPN_CONNECTION_INFO *const pdpConnectionInfo,
										   BOOL fServerPlayer,
										   const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    if( pdpConnectionInfo == NULL ||
        !DNVALID_WRITEPTR( pdpConnectionInfo, sizeof( DPN_CONNECTION_INFO ) ) )
    {
        DPF( 0, "Invalid pointer for connection info" );
        return(DPNERR_INVALIDPOINTER);
    }

    if( pdpConnectionInfo->dwSize != sizeof( DPN_CONNECTION_INFO ) )
    {
        DPF( 0, "Invalid size on connection info structure" );
        return(DPNERR_INVALIDPARAM);
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}
	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetSPCaps"
HRESULT DN_ValidateGetSPCaps(PVOID pv,
							 const GUID * const pguidSP,
							 DPN_SP_CAPS *const pdnSPCaps,
							 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPF( 0, "Invalid object" );
	    return(DPNERR_INVALIDOBJECT);
    }

    if( pdnSPCaps == NULL ||
        !DNVALID_WRITEPTR( pdnSPCaps, sizeof( DPN_SP_CAPS ) ) )
    {
        DPF( 0, "Invalid pointer for caps" );
	    return(DPNERR_INVALIDPOINTER);
    }

    if( pdnSPCaps->dwSize != sizeof( DPN_SP_CAPS ) )
    {
        DPF( 0, "Invalid size on SP caps structure" );
        return(DPNERR_INVALIDPARAM);
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

    return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetSPCaps"
HRESULT DN_ValidateSetSPCaps(PVOID pv,
							 const GUID * const pguidSP,
							 const DPN_SP_CAPS *const pdnSPCaps,
							 const DWORD dwFlags)
{
    HRESULT hr;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPF( 0, "Invalid object" );
        return(DPNERR_INVALIDOBJECT);
    }

	if(dwFlags){
		DPF( 0, "Invalid Flags specified, must be zero" );
		return DPNERR_INVALIDFLAGS;
	}

    hr = DN_ValidSPCaps( pdnSPCaps );

    if( FAILED( hr ) )
    {
        DPF( 0, "Error validating caps structure hr=[0x%lx]", hr );
        return( hr );
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetCaps"
HRESULT DN_ValidateGetCaps(PVOID pv,
						   DPN_CAPS *const pdnCaps,
						   const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPF( 0, "Invalid object" );
        return(DPNERR_INVALIDOBJECT);
    }

    if( pdnCaps == NULL ||
        !DNVALID_WRITEPTR( pdnCaps, sizeof( DPN_CAPS ) ) )
    {
        DPF( 0, "Invalid pointer for caps" );
        return(DPNERR_INVALIDPOINTER);
    }

    if( pdnCaps->dwSize != sizeof( DPN_CAPS ) )
    {
        DPF( 0, "Invalid size on caps structure" );
        return(DPNERR_INVALIDPARAM);
    }

	if (dwFlags != 0)
	{
		DPFERR("Invalid flags specified");
		return(DPNERR_INVALIDFLAGS);
	}

    return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetCaps"
HRESULT DN_ValidateSetCaps( PVOID pv,
						    const DPN_CAPS *const pdnCaps,
						    const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPF( 0, "Invalid object" );
        return DPNERR_INVALIDOBJECT;
    }

    hResultCode = DN_ValidCaps( pdnCaps );

    if( FAILED( hResultCode ) )
    {
        DPF( 0, "Error validating caps structure hr=0x%x", hResultCode );
        return(hResultCode);
    }

    if( dwFlags != 0 )
    {
        DPF( 0, "Invalid flags specified" );
        return(DPNERR_INVALIDFLAGS);
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateEnumHosts"
HRESULT DN_ValidateEnumHosts( PVOID pv,
							  DPN_APPLICATION_DESC *const pApplicationDesc,
							  IDirectPlay8Address *const pAddrHost,
							  IDirectPlay8Address *const pDeviceInfo,
							  PVOID const pUserEnumData,
							  const DWORD dwUserEnumDataSize,
							  const DWORD dwRetryCount,
							  const DWORD dwRetryInterval,
							  const DWORD dwTimeOut,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const pAsyncHandle,
							  const DWORD dwFlags )
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( pApplicationDesc == NULL ||
        !DNVALID_READPTR( pApplicationDesc, sizeof( DPN_APPLICATION_DESC ) ) )
    {
        DPFERR( "Invalid pointer for app desc specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( pApplicationDesc->dwSize != sizeof( DPN_APPLICATION_DESC ) )
    {
        DPFERR( "Invalid size for application desc" );
        return( DPNERR_INVALIDPARAM );
    }

    if( pApplicationDesc->dwFlags != 0 || pApplicationDesc->dwMaxPlayers != 0 || pApplicationDesc->dwCurrentPlayers != 0 ||
        pApplicationDesc->pvReservedData != NULL || pApplicationDesc->dwReservedDataSize != 0 ||
        pApplicationDesc->pvApplicationReservedData != NULL || pApplicationDesc->dwApplicationReservedDataSize != 0 )
    {
        DPFERR( "Can only specify dwSize and guidInstance and guidApplication in call to EnumHosts" );
        return DPNERR_INVALIDPARAM;
    }

	if (pAddrHost != NULL)
	{
		if( !DNVALID_READPTR( pAddrHost, sizeof( IDirectPlay8Address * ) ) )
		{
			DPFERR( "Invalid pointer specified for host address" );
			return( DPNERR_INVALIDPOINTER );
		}
	}

    if( pDeviceInfo == NULL || !DNVALID_READPTR( pDeviceInfo, sizeof ( IDirectPlay8Address * ) ) )
    {
        DPFERR("Invalid pointer for device address" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwUserEnumDataSize > 0 &&
        (pUserEnumData == NULL || !DNVALID_READPTR( pUserEnumData, dwUserEnumDataSize ) ) )
    {
        DPFERR( "Invalid pointer specified for user enum data" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( pAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( pAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR( "You must specify a valid pointer to an async handle" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags & ~(DPNENUMHOSTS_NOBROADCASTFALLBACK ) )
    {
        DPF( 0, "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

        if( pAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateEnumGroupMembers"
HRESULT DN_ValidateEnumGroupMembers(PVOID pInterface,
								 const DPNID dpnid,
								 DPNID *const prgdpnid,
								 DWORD *const pcdpnid,
								 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR("Cannot enumerate all players group" );
        return DPNERR_INVALIDGROUP;
    }

    if( pcdpnid == NULL ||
        !DNVALID_WRITEPTR( pcdpnid, sizeof( DWORD ) ) )
    {
        DPFERR("Invalid count param specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( *pcdpnid > 0 &&
        (prgdpnid == NULL || !DNVALID_WRITEPTR( prgdpnid, *pcdpnid ) ) )
    {
        DPFERR("Invalid pointer specified for buffer" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateEnumClientsAndGroups"
HRESULT DN_ValidateEnumClientsAndGroups(PVOID pInterface,
										DPNID *const prgdpnid,
										DWORD *const pcdpnid,
										const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( pcdpnid == NULL ||
        !DNVALID_WRITEPTR( pcdpnid, sizeof( DWORD ) ) )
    {
        DPFERR("Invalid count param specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( *pcdpnid > 0 &&
        (prgdpnid == NULL || !DNVALID_WRITEPTR( prgdpnid, *pcdpnid ) ) )
    {
        DPFERR("Invalid pointer specified for buffer" );
        return( DPNERR_INVALIDPOINTER );
    }

	if (dwFlags == 0)
	{
		DPFERR("Flags must be specified");
		return( DPNERR_INVALIDPARAM );
	}

    if (dwFlags & ~(DPNENUM_GROUPS | DPNENUM_PLAYERS))
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetGroupInfo"
HRESULT DN_ValidateGetGroupInfo(PVOID pv,
							 const DPNID dpnid,
							 DPN_GROUP_INFO *const pdpnGroupInfo,
							 DWORD *const pdwSize,
							 const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR("Cannot get group info for all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( pdwSize == NULL ||
        !DNVALID_WRITEPTR( pdwSize, sizeof( DWORD ) ) )
    {
        DPFERR("Invalid pdwSize parameter specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    // Only validate group info pointer if size is > 0
    if( *pdwSize > 0 )
    {
        if( pdpnGroupInfo == NULL ||
            !DNVALID_WRITEPTR( pdpnGroupInfo, *pdwSize ) )
        {
            DPFERR("Invalid pointer specified for group info" );
            return( DPNERR_INVALIDPOINTER );
        }

        if( FAILED( hResultCode = DN_ValidGroupInfo( pdpnGroupInfo, FALSE ) ) )
        {
            DPFERR("Error validating group info parameter" );
            return( hResultCode );
        }
    }

    if( dwFlags != 0 )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetGroupInfo"
HRESULT DN_ValidateSetGroupInfo( PVOID pv,
							  const DPNID dpnid,
							  DPN_GROUP_INFO *const pdpnGroupInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnid == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot remove from all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( FAILED( hResultCode = DN_ValidGroupInfo( pdpnGroupInfo, TRUE ) ) )
    {
        DPFERR( "Error validating group info structure" );
        return(hResultCode);
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }

    return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateRemoveClientFromGroup"
HRESULT DN_ValidateRemoveClientFromGroup(PVOID pInterface,
									  const DPNID dpnidGroup,
									  const DPNID dpnidClient,
									  PVOID const pvAsyncContext,
									  DPNHANDLE *const phAsyncHandle,
									  const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnidGroup == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot remove from all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( dpnidClient == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot specify all players group as client to remove" );
        return( DPNERR_INVALIDPARAM );
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateAddClientToGroup"
HRESULT DN_ValidateAddClientToGroup(PVOID pInterface,
								 const DPNID dpnidGroup,
								 const DPNID dpnidClient,
								 PVOID const pvAsyncContext,
								 DPNHANDLE *const phAsyncHandle,
								 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnidGroup == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot add from all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( dpnidClient == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot specify all players group as client to add" );
        return( DPNERR_INVALIDPLAYER );
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateDestroyGroup"
HRESULT DN_ValidateDestroyGroup(PVOID pInterface,
							 const DPNID dpnidGroup,
							 PVOID const pvAsyncContext,
							 DPNHANDLE *const phAsyncHandle,
							 const DWORD dwFlags)
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( dpnidGroup == DPNID_ALL_PLAYERS_GROUP )
    {
        DPFERR( "Cannot destroy all players group" );
        return( DPNERR_INVALIDGROUP );
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags )
    {
        DPFERR("Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateCreateGroup"
HRESULT DN_ValidateCreateGroup(PVOID pInterface,
							const DPN_GROUP_INFO *const pdpnGroupInfo,
							void *const pvGroupContext,
							void *const pvAsyncContext,
							DPNHANDLE *const phAsyncHandle,
							const DWORD dwFlags)
{
    HRESULT hResultCode;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( FAILED( hResultCode = DN_ValidGroupInfo( pdpnGroupInfo, TRUE ) ) )
    {
        DPFERR("Invalid group info structure" );
        return( DPNERR_INVALIDPARAM );
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof( DPNHANDLE ) ) )
    {
        DPFERR("Invalid async handle specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }

	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateHost"
HRESULT DN_ValidateHost( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnAppDesc,
                 IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,
    		     const DPN_SECURITY_DESC *const pdnSecurity,
  				 const DPN_SECURITY_CREDENTIALS *const pdnCredentials,
				 void *const pvPlayerContext, const DWORD dwFlags)
{
    HRESULT hResultCode;
	GUID guidSP;
	DWORD dwTmpPort;
	DWORD dwPortType;
	DWORD dwPortSize;

    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    if( FAILED( hResultCode = DN_ValidHostAppDesc( pdnAppDesc ) ) )
    {
        DPFERR("Invalid host app desc specified");
        return( hResultCode );
    }

    if( prgpDeviceInfo == NULL || cDeviceInfo == 0 )
    {
        DPFERR("You MUST specify a device address");
        return( DPNERR_INVALIDDEVICEADDRESS );
    }
    else
    {
        if( cDeviceInfo > 0 &&
            !DNVALID_READPTR( prgpDeviceInfo, sizeof( IDirectPlay8Address * ) * cDeviceInfo ) )
        {
            DPFERR("Invalid pointer specified for device info" );
            return( DPNERR_INVALIDPOINTER );
        }

    	// ensure SPs are specified in addresses
    	for (DWORD dw = 0 ; dw < cDeviceInfo ; dw++)
    	{
			if ( prgpDeviceInfo[dw] == NULL )
			{
				DPFERR( "Null device address interface pointer specified" );
				return( DPNERR_INVALIDDEVICEADDRESS );
			}

    		dwPortType = DPNA_DATATYPE_DWORD;
    		dwPortSize = sizeof( DWORD );
			// Check to ensure it's not using the default DPNSVR port
			if( SUCCEEDED( hResultCode = IDirectPlay8Address_GetComponentByName( prgpDeviceInfo[dw], DPNA_KEY_PORT, &dwTmpPort, &dwPortSize, &dwPortType ) ) )
			{
				if( dwTmpPort == DPNA_DPNSVR_PORT )
				{
					DPFERR( "Cannot use the DPNSVR port in device addresses" );
					DPFERR( "This port is reserved for DPNSVR" );
					return( DPNERR_INVALIDDEVICEADDRESS );
				}
			}    		
    	}
    }

    if( FAILED( hResultCode = DN_ValidSecurityDesc( pdnSecurity ) ) )
    {
        DPFERR("Error validating reserved param" );
        return( hResultCode );
    }

    if( FAILED( hResultCode = DN_ValidSecurityCredentials(pdnCredentials) ) )
    {
        DPFERR("Error validating reserved param" );
        return( hResultCode );
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateEnumServiceProviders"
HRESULT DN_ValidateEnumServiceProviders( PVOID pInterface,
									  const GUID *const pguidServiceProvider,
									  const GUID *const pguidApplication,
									  DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,
									  DWORD *const pcbEnumData,
									  DWORD *const pcReturned,
									  const DWORD dwFlags )
{
    if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( pguidApplication != NULL &&
	    !DNVALID_READPTR( pguidApplication, sizeof( GUID ) ) )
	{
	    DPFERR("Invalid application GUID specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pcbEnumData == NULL ||
	    !DNVALID_READPTR( pcbEnumData, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid enum data pointer" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pcReturned == NULL ||
	    !DNVALID_READPTR( pcReturned, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid retuned count" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( *pcbEnumData > 0 &&
	    (pSPInfoBuffer == NULL || !DNVALID_WRITEPTR(pSPInfoBuffer,*pcbEnumData) ) )
	{
	    DPFERR("Invalid enum buffer specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( dwFlags & (~(DPNENUMSERVICEPROVIDERS_ALL)) )
	{
	    DPFERR("Invalid flags specified" );
	    return( DPNERR_INVALIDFLAGS );
	}

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateCancelAsyncOperation"
HRESULT DN_ValidateCancelAsyncOperation(PVOID pvInterface, const DPNHANDLE hAsyncOp, const DWORD dwFlags )
{
	if( !IsValidDirectPlay8Object( pvInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( dwFlags )
	{
		if( hAsyncOp )
		{
			DPFERR("Invalid parameter, hAsyncOp specified with flags");
			return ( DPNERR_INVALIDPARAM );
		}

		// make sure only correct bits are set, AND only 1 bit is set.
		if(  ( dwFlags != ( dwFlags & ( DPNCANCEL_ALL_OPERATIONS | DPNCANCEL_CONNECT | DPNCANCEL_ENUM | DPNCANCEL_SEND ) ) ) ||
			( ( ( dwFlags - 1 ) & dwFlags ) != 0 ) )
		{
		    DPFERR("Invalid flags specified" );
		    return( DPNERR_INVALIDFLAGS );
		}
	}
	else
	{
		if( hAsyncOp == NULL)
		{
		    DPFERR("Invalid handle specified" );
		    return( DPNERR_INVALIDHANDLE );
		}
	}
	return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateConnect"
HRESULT DN_ValidateConnect( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnAppDesc, IDirectPlay8Address *const pHostAddr,
            					   IDirectPlay8Address *const pDeviceInfo, const DPN_SECURITY_DESC *const pdnSecurity,
  						           const DPN_SECURITY_CREDENTIALS *const pdnCredentials, const void *const pvUserConnectData,
                                   const DWORD dwUserConnectDataSize, void *const pvPlayerContext,
          						   void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
{
    HRESULT hResultCode;

	if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

    hResultCode = DN_ValidConnectAppDesc( pdnAppDesc );

    if( FAILED( hResultCode ) )
    {
        DPF(0, "Invalid connect app desc hr=[0x%lx]", hResultCode );
        return( hResultCode );
    }

	if( pHostAddr == NULL ||
	    !DNVALID_READPTR( pHostAddr, sizeof( IDirectPlay8Address * ) ) )
	{
	    DPFERR("Invalid host address specified" );
	    return( DPNERR_INVALIDHOSTADDRESS );
	}

	//
	//	Allow a NULL Device Address (we will copy the SP from the Host address
	//
	if( pDeviceInfo != NULL)
	{
		if ( !DNVALID_READPTR( pDeviceInfo, sizeof( IDirectPlay8Address * ) ) )
		{
			DPFERR("Invalid device address specified" );
			return( hResultCode );
		}

		DWORD dwTmpPort;
		DWORD dwDataType;
		DWORD dwDataSize;

		dwDataType = DPNA_DATATYPE_DWORD;
		dwDataSize = sizeof( DWORD );

		// Check to ensure it's not using the default DPNSVR port
		if( SUCCEEDED( hResultCode = IDirectPlay8Address_GetComponentByName( pDeviceInfo, DPNA_KEY_PORT, &dwTmpPort, &dwDataSize, &dwDataType ) ) )
		{
			if( dwTmpPort == DPNA_DPNSVR_PORT )
			{
				DPFERR( "Cannot use the DPNSVR port in device addresses" );
				DPFERR( "This port is reserved for DPNSVR" );
				return( DPNERR_INVALIDDEVICEADDRESS );
			}
		}
	}

    if( FAILED( hResultCode = DN_ValidSecurityDesc(pdnSecurity) ) )
    {
        DPFERR(" Invalid reserved specified" );
        return( hResultCode );
    }

    if( FAILED( hResultCode = DN_ValidSecurityCredentials(pdnCredentials) ) )
    {
        DPFERR( "Invalid reserved2 specified" );
        return( hResultCode );
    }

    if( dwUserConnectDataSize > 0 &&
        (pvUserConnectData == NULL || !DNVALID_READPTR( pvUserConnectData, dwUserConnectDataSize ) ) )
    {
        DPFERR( "Invalid pointer specified for connect data" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( pvUserConnectData != NULL && dwUserConnectDataSize == 0 )
    {
        DPFERR( "Non NULL connect data with datasize = 0 is invalid" );
        return( DPNERR_INVALIDPARAM );
    }

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof(DPNHANDLE) ) )
    {
        DPFERR( "Invalid handle specified" );
        return( DPNERR_INVALIDPOINTER );
    }

    if( dwFlags )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle w/async ops" );
            return( DPNERR_INVALIDPARAM );
        }
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetSendQueueInfo"
HRESULT DN_ValidateGetSendQueueInfo(PVOID pInterface, DWORD *const pdwNumMsgs, DWORD *const pdwNumBytes,const DWORD dwFlags)
{
	if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( pdwNumMsgs != NULL &&
	    !DNVALID_WRITEPTR( pdwNumMsgs, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid num messages specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pdwNumBytes != NULL &&
	    !DNVALID_WRITEPTR( pdwNumBytes, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid num bytes specified" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( pdwNumBytes == NULL && pdwNumMsgs == NULL )
	{
	    DPFERR("Must request at least one of num bytes and num messages" );
	    return( DPNERR_INVALIDPARAM );
	}

    if( dwFlags & ~(DPNGETSENDQUEUEINFO_PRIORITY_HIGH | DPNGETSENDQUEUEINFO_PRIORITY_LOW | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL) )
    {
        DPFERR( "Invalid flags specified" );
        return( DPNERR_INVALIDFLAGS );
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateGetApplicationDesc"
HRESULT DN_ValidateGetApplicationDesc( PVOID pInterface, DPN_APPLICATION_DESC *const pAppDescBuffer, DWORD *const pcbDataSize, const DWORD dwFlags )
{
	if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( pcbDataSize == NULL ||
	    !DNVALID_WRITEPTR( pcbDataSize, sizeof( DWORD ) ) )
	{
	    DPFERR("Invalid pointer specified for data size" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( *pcbDataSize > 0 &&
	    (pAppDescBuffer == NULL || !DNVALID_WRITEPTR( pAppDescBuffer, *pcbDataSize ) ) )
	{
	    DPFERR( "Invalid pointer specified for app description buffer" );
	    return( DPNERR_INVALIDPOINTER );
	}

	if( *pcbDataSize > 0 &&
	    pAppDescBuffer->dwSize != sizeof( DPN_APPLICATION_DESC ) )
	{
	    DPFERR("Invalid size specified" );
	    return(DPNERR_INVALIDPARAM);
	}

	if( dwFlags != 0 )
	{
	    DPFERR( "Invalid flags specified" );
	    return( DPNERR_INVALIDFLAGS );
	}
	
    return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSetApplicationDesc"
HRESULT DN_ValidateSetApplicationDesc( PVOID pInterface, const DPN_APPLICATION_DESC *const pdnApplicationDesc, const DWORD dwFlags)
{
    HRESULT hResultCode;

	if( !IsValidDirectPlay8Object( pInterface ) )
    {
        DPFERR("Invalid object specified " );
	    return( DPNERR_INVALIDOBJECT );
    }

	if( FAILED( hResultCode = DN_ValidHostAppDesc(pdnApplicationDesc) ) )
	{
	    DPF(0,"Invalid app desc specified hr=[0x%lx]", hResultCode );
	    return( hResultCode );
	}

	if( dwFlags != 0 )
	{
	    DPFERR( "Invalid flags specified" );
	    return( DPNERR_INVALIDFLAGS );
	}
	
    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidateSendParams"
HRESULT DN_ValidateSendParams( PVOID pv,
                               const DPN_BUFFER_DESC *const pBufferDesc,
							   const DWORD cBufferDesc,
                               const DWORD dwTimeOut,
							   void *const pvAsyncContext,
                               DPNHANDLE *const phAsyncHandle,
							   const DWORD dwFlags )
{
    HRESULT hResultCode;

	if( !IsValidDirectPlay8Object( pv ) )
    {
        DPFERR("Invalid object specified " );
	    return(DPNERR_INVALIDOBJECT);
    }

    if( FAILED( hResultCode = DN_ValidBufferDescs( pBufferDesc, cBufferDesc ) ) )
    {
        DPFERR( "Invalid buffer descs specified" );
        return( hResultCode );
    }

	if (pBufferDesc->dwBufferSize == 0)
	{
		DPFERR( "Cannot specify 0 data size" );
		return(DPNERR_INVALIDPARAM);
	}

    if( phAsyncHandle != NULL &&
        !DNVALID_WRITEPTR( phAsyncHandle, sizeof(DPNHANDLE) ) )
    {
        DPFERR("Invalid async handle specified" );
        return(DPNERR_INVALIDPOINTER);
    }

	if ((dwFlags & DPNSEND_NOCOPY) && (dwFlags & DPNSEND_NOCOMPLETE))
	{
	    DPFERR( "Cannot specify NOCOPY and NOCOMPLETE" );
		return(DPNERR_INVALIDFLAGS);
	}

	if ((dwFlags & DPNSEND_COMPLETEONPROCESS) && (dwFlags & DPNSEND_NOCOMPLETE))
	{
	    DPFERR("Cannot specify complete on process AND NOCOMPLETE" );
		return(DPNERR_INVALIDFLAGS);
	}

	if ((dwFlags & DPNSEND_COMPLETEONPROCESS) && !(dwFlags & DPNSEND_GUARANTEED))
	{
	    DPFERR("Cannot specify COMEPLETEONPROCESS without guaranteed" );
		return(DPNERR_INVALIDFLAGS);
	}

    // Guaranteed asyncs MUST get a complete
	if ((dwFlags & DPNSEND_GUARANTEED) && 
	    (dwFlags & DPNSEND_NOCOMPLETE) )
	{
	    DPFERR("Async, guaranteed sends must get a completion" );
	    return(DPNERR_INVALIDFLAGS);
	}

	// Cannot specify high AND low priority
	if ((dwFlags & DPNSEND_PRIORITY_HIGH) && (dwFlags & DPNSEND_PRIORITY_LOW))
	{
		DPFERR("Cannot specify high AND low priority");
		return(DPNERR_INVALIDFLAGS);
	}

   	if( dwFlags & ~(
					  DPNSEND_NOCOPY
					| DPNSEND_NOCOMPLETE
					| DPNSEND_COMPLETEONPROCESS
					| DPNSEND_GUARANTEED
					| DPNSEND_NONSEQUENTIAL
					| DPNSEND_NOLOOPBACK
					| DPNSEND_PRIORITY_LOW
					| DPNSEND_PRIORITY_HIGH) )
	{
	    DPFERR( "Invalid flags specified" );
	    DPF_RETURN( DPNERR_INVALIDFLAGS );
	}

        if( phAsyncHandle == NULL )
        {
            DPFERR( "You MUST specify a valid async handle if op async and/or has a completion" );
            return( DPNERR_INVALIDPARAM );
        }

   	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidBufferDescs"
HRESULT DN_ValidBufferDescs( const DPN_BUFFER_DESC * const pbBufferDesc, const DWORD cBufferDesc )
{
    if( cBufferDesc == 0 )
    {
        DPFERR( "You must specify at least one buffer desc" );
        return DPNERR_INVALIDPARAM;
    }

    if( cBufferDesc != 1 )
    {
        DPFERR( "Only one buffer at a time is currently supported" );
        return DPNERR_INVALIDPARAM;
    }

    if( pbBufferDesc == NULL ||
       !DNVALID_READPTR( pbBufferDesc, cBufferDesc*sizeof( DPN_BUFFER_DESC ) ) )
    {
        DPF( 0, "Invalid buffer for buffer description" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pbBufferDesc->dwBufferSize > 0 &&
       (pbBufferDesc->pBufferData == NULL || !DNVALID_READPTR( pbBufferDesc->pBufferData, pbBufferDesc->dwBufferSize ) ) )
    {
        DPF( 0, "Invalid pBuffer Data" );
        return DPNERR_INVALIDPOINTER;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidConnectAppDesc"
HRESULT DN_ValidConnectAppDesc( const DPN_APPLICATION_DESC * const pdnAppDesc )
{
    if( pdnAppDesc == NULL ||
       !DNVALID_READPTR( pdnAppDesc, sizeof( DPN_APPLICATION_DESC ) ) )
    {
        DPF( 0, "Invalid pointer for app description" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnAppDesc->dwSize != sizeof( DPN_APPLICATION_DESC ) )
    {
        DPF( 0, "Invalid size for app description" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdnAppDesc->pwszSessionName != NULL &&
        !DNVALID_STRING_W( pdnAppDesc->pwszSessionName ) )
    {
        DPF( 0, "Invalid session name specified" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdnAppDesc->pwszPassword != NULL &&
       !DNVALID_STRING_W( pdnAppDesc->pwszPassword ) )
    {
        DPF( 0, "Invalid session desc" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdnAppDesc->dwReservedDataSize != 0 || pdnAppDesc->pvReservedData != NULL )
    {
        DPF( 0, "Invalid pointer for specified reserved data" );
        return DPNERR_INVALIDPARAM;
    }

	return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidHostAppDesc"
HRESULT DN_ValidHostAppDesc( const DPN_APPLICATION_DESC * const pdnAppDesc )
{
    if( pdnAppDesc == NULL ||
       !DNVALID_READPTR( pdnAppDesc, sizeof( DPN_APPLICATION_DESC ) ) )
    {
        DPF( 0, "Invalid pointer for app description" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnAppDesc->dwSize != sizeof( DPN_APPLICATION_DESC ) )
    {
        DPF( 0, "Invalid size for app description" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdnAppDesc->dwFlags & ~(DPNSESSION_CLIENT_SERVER | DPNSESSION_MIGRATE_HOST | DPNSESSION_REQUIREPASSWORD) )
    {
        DPF( 0, "Invalid flag specified" );
        return DPNERR_INVALIDFLAGS;
    }

    if( (pdnAppDesc->dwFlags & DPNSESSION_CLIENT_SERVER) &&
       (pdnAppDesc->dwFlags & DPNSESSION_MIGRATE_HOST) )
    {
        DPF( 0, "Cannot have host migration with client/server" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdnAppDesc->guidApplication == GUID_NULL )
    {
        DPFERR( "You must specify a valid GUID for your application GUID" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdnAppDesc->pwszSessionName != NULL &&
       !DNVALID_STRING_W( pdnAppDesc->pwszSessionName ) )
    {
        DPF( 0, "Invalid session name" );
        return DPNERR_INVALIDSTRING;
    }

    if( pdnAppDesc->dwFlags & DPNSESSION_REQUIREPASSWORD )
    {
        if( pdnAppDesc->pwszPassword == NULL )
        {
            DPFERR( "Must specify a password w/the requirepassword flag." );
            return DPNERR_INVALIDPARAM;
        }

        if( !DNVALID_STRING_W( pdnAppDesc->pwszPassword ) )
        {
            DPF( 0, "Invalid password specified." );
            return DPNERR_INVALIDSTRING;
        }
    }
    else
    {
        if( pdnAppDesc->pwszPassword != NULL )
        {
            DPFERR( "Cannot specify a password without the requirepassword flag" );
            return DPNERR_INVALIDPARAM;
        }
    }



    if( pdnAppDesc->dwReservedDataSize != 0 || pdnAppDesc->pvReservedData != NULL )
    {
        DPF( 0, "Invalid pointer for specified reserved data" );
        return DPNERR_INVALIDPARAM;
    }

    if( pdnAppDesc->dwApplicationReservedDataSize != 0 &&
       !DNVALID_WRITEPTR( pdnAppDesc->pvApplicationReservedData, pdnAppDesc->dwApplicationReservedDataSize ) )
    {
        DPF( 0, "Invalid pointer for application reserved data" );
        return DPNERR_INVALIDPARAM;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidPlayerInfo"
HRESULT DN_ValidPlayerInfo( const DPN_PLAYER_INFO * const pdnPlayerInfo, BOOL fSet )
{
   if( pdnPlayerInfo == NULL ||
       !DNVALID_READPTR( pdnPlayerInfo, sizeof( DPN_PLAYER_INFO ) ) )
    {
        DPF( 0, "Invalid pointer for player info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnPlayerInfo->dwSize != sizeof( DPN_PLAYER_INFO ) )
    {
        DPF( 0, "Invalid size for player info" );
        return DPNERR_INVALIDPARAM;
    }

    if( fSet )
    {
        if( pdnPlayerInfo->dwInfoFlags & ~(DPNINFO_NAME | DPNINFO_DATA) )
        {
            DPFERR("Invalid info flags specified" );
            return DPNERR_INVALIDFLAGS;
        }

        if( pdnPlayerInfo->dwInfoFlags & DPNINFO_NAME )
        {
            if( pdnPlayerInfo->pwszName != NULL && !DNVALID_STRING_W( pdnPlayerInfo->pwszName ) )
            {
                DPFERR("Invalid string specified for name" );
                return DPNERR_INVALIDSTRING;
            }
        }
        else
        {
            if( pdnPlayerInfo->pwszName != NULL )
            {
                DPFERR( "You must specify DPNINFO_NAME to set name" );
                return DPNERR_INVALIDSTRING;
            }
        }

        if( pdnPlayerInfo->dwInfoFlags & DPNINFO_DATA )
        {
            if( pdnPlayerInfo->dwDataSize > 0 &&
                (pdnPlayerInfo->pvData == NULL || !DNVALID_READPTR( pdnPlayerInfo->pvData, pdnPlayerInfo->dwDataSize )  ) )
            {
                DPFERR("Invalid pointer specified for data" );
                return DPNERR_INVALIDPOINTER;
            }
        }
        else
        {
            if( pdnPlayerInfo->pvData != NULL )
            {
                DPFERR("You must specify DPNINFO_DATA if you want to set data" );
                return DPNERR_INVALIDPARAM;
            }
        }

        if( pdnPlayerInfo->dwPlayerFlags != 0  )
        {
            DPFERR( "Invalid player flags specified" );
            return DPNERR_INVALIDFLAGS;
        }
    }

    return DPN_OK;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidGroupInfo"
HRESULT DN_ValidGroupInfo( const DPN_GROUP_INFO * const pdnGroupInfo, BOOL fSet )
{
   if( pdnGroupInfo == NULL ||
       !DNVALID_READPTR( pdnGroupInfo, sizeof( DPN_GROUP_INFO ) ) )
    {
        DPF( 0, "Invalid pointer for group info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnGroupInfo->dwSize != sizeof( DPN_GROUP_INFO ) )
    {
        DPF( 0, "Invalid size for group info" );
        return DPNERR_INVALIDPARAM;
    }

    if( fSet )
    {
        if( pdnGroupInfo->dwInfoFlags & ~(DPNINFO_NAME | DPNINFO_DATA) )
        {
            DPFERR("Invalid info flags specified" );
            return DPNERR_INVALIDFLAGS;
        }

        if( pdnGroupInfo->dwInfoFlags & DPNINFO_NAME )
        {
            if( pdnGroupInfo->pwszName != NULL && !DNVALID_STRING_W( pdnGroupInfo->pwszName ) )
            {
                DPFERR("Invalid string specified for name" );
                return DPNERR_INVALIDSTRING;
            }
        }
        else
        {
            if( pdnGroupInfo->pwszName != NULL )
            {
                DPFERR( "You must specify DPNINFO_NAME to set name" );
                return DPNERR_INVALIDSTRING;
            }
        }

        if( pdnGroupInfo->dwInfoFlags & DPNINFO_DATA )
        {
            if( pdnGroupInfo->dwDataSize > 0 &&
                (pdnGroupInfo->pvData == NULL || !DNVALID_READPTR( pdnGroupInfo->pvData, pdnGroupInfo->dwDataSize )  ) )
            {
                DPFERR("Invalid pointer specified for data" );
                return DPNERR_INVALIDPOINTER;
            }
        }
        else
        {
            if( pdnGroupInfo->pvData != NULL )
            {
                DPFERR("You must specify DPNINFO_DATA if you want to set data" );
                return DPNERR_INVALIDPARAM;
            }
        }

        if( pdnGroupInfo->dwGroupFlags & ~(DPNGROUP_AUTODESTRUCT /* | DPNGROUP_MULTICAST */ ) )
        {
            DPFERR( "Invalid group flags specified" );
            return DPNERR_INVALIDFLAGS;
        }
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidSecurityCredentials"
HRESULT DN_ValidSecurityCredentials( const DPN_SECURITY_CREDENTIALS * const pdnCredentials )
{
	if( pdnCredentials != NULL )
	{
		DPFERR( "Invalid value for reserved field" );
		return DPNERR_INVALIDPOINTER;
	}

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidSecurityDesc"
HRESULT DN_ValidSecurityDesc( const DPN_SECURITY_DESC * const pdnValidSecurityDesc )
{
	if( pdnValidSecurityDesc != NULL )
	{
		DPFERR( "Invalid value for reserved field" );
		return DPNERR_INVALIDPOINTER;
	}

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "IsValidDirectPlay8Object"
BOOL IsValidDirectPlay8Object( LPVOID lpvObject )
{
// BUGBUG: [mgere] [xbox] Revisit this.  For now just return TRUE.
/*
	INTERFACE_LIST *pIntList = (INTERFACE_LIST *) lpvObject;
	
	if( !DNVALID_READPTR( lpvObject, sizeof( INTERFACE_LIST ) ) )
	{
		DPF( 0, "Invalid object pointer" );
		return FALSE;
	}

	if( pIntList->lpVtbl != &DN_ClientVtbl &&
	   pIntList->lpVtbl != &DN_PeerVtbl &&
	   pIntList->lpVtbl != &DN_ServerVtbl &&
	   pIntList->lpVtbl != &DN_VoiceTbl &&
       pIntList->lpVtbl != &DN_ProtocolVtbl &&
       pIntList->lpVtbl != &SPMessagesVtbl
	   )
	{
		DPF( 0, "Invalid object - bad vtable" );
		return FALSE;
	}

	if( pIntList->iid != IID_IDirectPlay8Client &&
	   pIntList->iid != IID_IDirectPlay8Server &&
	   pIntList->iid != IID_IDirectPlay8Peer &&
       pIntList->iid != IID_IDirectPlay8Protocol &&
       pIntList->iid != IID_IDP8SPCallback )
	{
		DPF( 0, "Invalid object - bad iid" );
		return FALSE;
	}

	if( pIntList->pObject == NULL ||
	   !DNVALID_READPTR( pIntList->pObject, sizeof( OBJECT_DATA ) ) )
	{
		DPF( 0, "Invalid object" );
		return FALSE;
	}

	DIRECTNETOBJECT *pdn = (DIRECTNETOBJECT *) GET_OBJECT_FROM_INTERFACE( lpvObject );

	if( pdn == NULL ||
	   !DNVALID_READPTR( pdn, sizeof( DIRECTNETOBJECT ) ) )
	{
		DPF( 0, "Invalid object" );
		return FALSE;
	}
*/
	return TRUE;

}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidSPCaps"
HRESULT DN_ValidSPCaps( const DPN_SP_CAPS * const pdnSPCaps )
{
    if( pdnSPCaps == NULL ||
       !DNVALID_READPTR( pdnSPCaps, sizeof( DPN_SP_CAPS ) ) )
    {
        DPF( 0, "Invalid pointer for SP caps" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnSPCaps->dwSize != sizeof( DPN_SP_CAPS ) )
    {
        DPF( 0, "Invalid structure size" );
        return DPNERR_INVALIDPARAM;
    }

	if ( pdnSPCaps->dwBuffersPerThread == 0 )
	{
		DPF( 0, "Invalid buffers per thread setting!" );
		return 	DPNERR_INVALIDPARAM;
	}

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidConnectionInfo"
HRESULT DN_ValidConnectionInfo( const DPN_CONNECTION_INFO * const pdnConnectionInfo )
{
    if( pdnConnectionInfo == NULL ||
       !DNVALID_READPTR( pdnConnectionInfo, sizeof( DPN_CONNECTION_INFO ) ) )
    {
        DPF( 0, "Invalid pointer for connection info" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnConnectionInfo->dwSize != sizeof( DPN_CONNECTION_INFO ) )
    {
        DPF( 0, "Invalid structure size" );
        return DPNERR_INVALIDPARAM;
    }

    return DPN_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DN_ValidCaps"
HRESULT DN_ValidCaps( const DPN_CAPS * const pdnCaps )
{
    if( pdnCaps == NULL ||
       !DNVALID_READPTR( pdnCaps, sizeof( DPN_CAPS ) ) )
    {
        DPF( 0, "Invalid pointer for caps" );
        return DPNERR_INVALIDPOINTER;
    }

    if( pdnCaps->dwSize != sizeof( DPN_CAPS ) )
    {
        DPF( 0, "Invalid structure size" );
        return DPNERR_INVALIDPARAM;
    }

    return DPN_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dplay\core\peer.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Peer.cpp
 *  Content:    DNET peer interface routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/21/99	mjn		Created
 *  12/23/99	mjn		Hand all NameTable update sends from Host to worker thread
 *	12/28/99	mjn		Disconnect handling happens when disconnect finishes instead of starts
 *	12/28/99	mjn		Moved Async Op stuff to Async.h
 *	01/04/00	mjn		Added code to allow outstanding ops to complete at host migration
 *	01/06/00	mjn		Moved NameTable stuff to NameTable.h
 *	01/11/00	mjn		Moved connect/disconnect stuff to Connect.h
 *	01/14/00	mjn		Added pvUserContext to Host API call
 *	01/16/00	mjn		Moved User callback stuff to User.h
 *	01/22/00	mjn		Implemented DestroyClient in API
 *	01/28/00	mjn		Implemented ReturnBuffer in API
 *	02/01/00	mjn		Implemented GetCaps and SetCaps in API
 *	02/01/00	mjn		Implement Player/Group context values
 *	02/15/00	mjn		Implement INFO flags in SetInfo and return context in GetInfo
 *	02/17/00	mjn		Implemented GetPlayerContext and GetGroupContext
 *  03/17/00    rmt     Added new caps functions
 *	04/04/00	mjn		Added TerminateSession to API
 *	04/05/00	mjn		Modified DestroyClient
 *	04/06/00	mjn		Added GetPeerAddress to API
 *				mjn		Added GetHostAddress to API
 *  04/17/00    rmt     Added more parameter validation
 *              rmt     Removed required for connection from Get/SetInfo / GetAddress
 *	04/19/00	mjn		SendTo API call accepts a range of DPN_BUFFER_DESCs and a count
 *	04/24/00	mjn		Updated Group and Info operations to use CAsyncOp's
 *	05/31/00	mjn		Added operation specific SYNC flags
 *	06/23/00	mjn		Removed dwPriority from SendTo() API call
 *	07/09/00	mjn		Cleaned up DN_SetPeerInfo()
 *  07/09/00	rmt		Bug #38323 - RegisterLobby needs a DPNHANDLE parameter.
 *  07/21/00    RichGr  IA64: Use %p format specifier for 32/64-bit pointers.
 *  08/03/00	rmt		Bug #41244 - Wrong return codes -- part 2
 *	09/13/00	mjn		Fixed return value from DN_GetPeerAddress() if peer not found
 *	10/11/00	mjn		Take locks for CNameTableEntry::PackInfo()
 *				mjn		Check deleted list in DN_GetPeerInfo()
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncorei.h"

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************


ULONG WINAPI IDirectPlay8Peer_AddRef(LPDIRECTPLAY8PEER pDirectPlay8Peer)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->AddRef();
}
ULONG WINAPI IDirectPlay8Peer_Release(LPDIRECTPLAY8PEER pDirectPlay8Peer)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->Release();
}

HRESULT WINAPI IDirectPlay8Peer_Initialize(LPDIRECTPLAY8PEER pDirectPlay8Peer, LPVOID const lpvUserContext, const PFNDPNMESSAGEHANDLER lpfn, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_Initialize(NULL, lpvUserContext,lpfn,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_EnumServiceProviders(LPDIRECTPLAY8PEER pDirectPlay8Peer, const GUID *const pvoid,const GUID *const pguidApplication,DPN_SERVICE_PROVIDER_INFO *const pSPInfoBuffer,DWORD *const pcbEnumData,DWORD *const pcReturned,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_EnumServiceProviders(NULL, pvoid,pguidApplication,pSPInfoBuffer,pcbEnumData,pcReturned,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_CancelAsyncOperation(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNHANDLE hAsyncHandle, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_CancelAsyncOperation(NULL, hAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_Connect(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address *const pHostAddr,IDirectPlay8Address *const pDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,const void *const pvUserConnectData,const DWORD dwUserConnectDataSize,void *const pvPlayerContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_Connect(NULL, pdnAppDesc,pHostAddr,pDeviceInfo,pdnSecurity,pdnCredentials,pvUserConnectData,dwUserConnectDataSize,pvPlayerContext,pvAsyncContext,phAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_SendTo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dnid, const DPN_BUFFER_DESC *const prgBufferDesc,const DWORD cBufferDesc,const DWORD dwTimeOut, void *const pvAsyncContext, DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_SendTo(NULL, dnid,prgBufferDesc,cBufferDesc,dwTimeOut,pvAsyncContext,phAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_GetSendQueueInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,DWORD *const lpdwNumMsgs, DWORD *const lpdwNumBytes, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_GetSendQueueInfo(NULL, dpnid,lpdwNumMsgs,lpdwNumBytes,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_Host(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_APPLICATION_DESC *const pdnAppDesc,IDirectPlay8Address **const prgpDeviceInfo,const DWORD cDeviceInfo,const DPN_SECURITY_DESC *const pdnSecurity,const DPN_SECURITY_CREDENTIALS *const pdnCredentials,void *const pvPlayerContext,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_Host(NULL, pdnAppDesc,prgpDeviceInfo,cDeviceInfo,pdnSecurity,pdnCredentials,pvPlayerContext,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_GetApplicationDesc(LPDIRECTPLAY8PEER pDirectPlay8Peer, DPN_APPLICATION_DESC *const pAppDescBuffer,DWORD *const lpcbDataSize,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_GetApplicationDesc(NULL, pAppDescBuffer,lpcbDataSize,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_SetApplicationDesc(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_APPLICATION_DESC *const lpad, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_SetApplicationDesc(NULL, lpad,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_CreateGroup(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_GROUP_INFO *const pdpnGroupInfo,void *const pvGroupContext,void *const pvAsyncContext,DPNHANDLE *const phAsyncHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_CreateGroup(NULL, pdpnGroupInfo,pvGroupContext,pvAsyncContext,phAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_DestroyGroup(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID idGroup ,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_DestroyGroup(NULL, idGroup,pvUserContext,lpAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_AddPlayerToGroup(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID idGroup, const DPNID idClient ,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_AddClientToGroup(NULL, idGroup,idClient,pvUserContext,lpAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_RemovePlayerFromGroup(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID idGroup, const DPNID idClient,PVOID const pvUserContext,DPNHANDLE *const lpAsyncHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_RemoveClientFromGroup(NULL, idGroup,idClient,pvUserContext,lpAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_SetGroupInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_SetGroupInfo(NULL, dpnid,pdpnGroupInfo,pvAsyncContext,phAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_GetGroupInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,DPN_GROUP_INFO *const pdpnGroupInfo,DWORD *const pdwSize,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_GetGroupInfo(NULL, dpnid,pdpnGroupInfo,pdwSize,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_EnumPlayersAndGroups(LPDIRECTPLAY8PEER pDirectPlay8Peer, DPNID *const lprgdnid, DWORD *const lpcdnid, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_EnumClientsAndGroups(NULL, lprgdnid,lpcdnid,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_EnumGroupMembers(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dnid, DPNID *const lprgdnid, DWORD *const lpcdnid, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_EnumGroupMembers(NULL, dnid,lprgdnid,lpcdnid,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_SetPeerInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_PLAYER_INFO *const pdpnPlayerInfo,PVOID const pvAsyncContext,DPNHANDLE *const phAsyncHandle, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_SetPeerInfo(NULL, pdpnPlayerInfo,pvAsyncContext,phAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_GetPeerInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,DPN_PLAYER_INFO *const pdpnPlayerInfo,DWORD *const pdwSize,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_GetPeerInfo(NULL, dpnid,pdpnPlayerInfo,pdwSize,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_GetPeerAddress(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,IDirectPlay8Address **const pAddress,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_GetPeerAddress(NULL, dpnid,pAddress,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_GetLocalHostAddresses(LPDIRECTPLAY8PEER pDirectPlay8Peer, IDirectPlay8Address **const prgpAddress, DWORD *const pcAddress,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_GetHostAddress(NULL, prgpAddress,pcAddress,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_Close(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_Close(NULL, dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_EnumHosts(LPDIRECTPLAY8PEER pDirectPlay8Peer, PDPN_APPLICATION_DESC const pApplicationDesc,IDirectPlay8Address *const pAddrHost,IDirectPlay8Address *const pDeviceInfo,PVOID const pUserEnumData,const DWORD dwUserEnumDataSize,const DWORD dwRetryCount,const DWORD dwRetryInterval,const DWORD dwTimeOut,PVOID const pvUserContext,DPNHANDLE *const pAsyncHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_EnumHosts(NULL, pApplicationDesc,pAddrHost,pDeviceInfo,pUserEnumData,dwUserEnumDataSize,dwRetryCount,dwRetryInterval,dwTimeOut,pvUserContext,pAsyncHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_DestroyPeer(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dnid,const void *const pvDestroyData,const DWORD dwDestroyDataSize,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_DestroyPlayer(NULL, dnid,pvDestroyData,dwDestroyDataSize,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_ReturnBuffer(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNHANDLE hBufferHandle,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_ReturnBuffer(NULL, hBufferHandle,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_GetPlayerContext(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,PVOID *const ppvPlayerContext,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_GetPlayerContext(NULL, dpnid,ppvPlayerContext,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_GetGroupContext(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid,PVOID *const ppvGroupContext,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_GetGroupContext(NULL, dpnid,ppvGroupContext,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_GetCaps(LPDIRECTPLAY8PEER pDirectPlay8Peer, DPN_CAPS *const pdnCaps,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_GetCaps(NULL, pdnCaps,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_SetCaps(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPN_CAPS *const pdnCaps,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_SetCaps(NULL, pdnCaps,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_SetSPCaps(LPDIRECTPLAY8PEER pDirectPlay8Peer, const GUID *const pvoid, const DPN_SP_CAPS *const pdpspCaps, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_SetSPCaps(NULL, pvoid,pdpspCaps,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_GetSPCaps(LPDIRECTPLAY8PEER pDirectPlay8Peer, const GUID *const pvoid, DPN_SP_CAPS *const pdpspCaps,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_GetSPCaps(NULL, pvoid,pdpspCaps,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_GetConnectionInfo(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNID dpnid, DPN_CONNECTION_INFO *const pdpConnectionInfo,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_GetConnectionInfo(NULL, dpnid,pdpConnectionInfo,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_RegisterLobby(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DPNHANDLE dpnHandle,PVOID const pIDP8LobbiedApplication,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_RegisterLobby(NULL, dpnHandle,pIDP8LobbiedApplication,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_TerminateSession(LPDIRECTPLAY8PEER pDirectPlay8Peer, void *const pvTerminateData,const DWORD dwTerminateDataSize,const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_TerminateSession(NULL, pvTerminateData,dwTerminateDataSize,dwFlags);
}

HRESULT WINAPI IDirectPlay8Peer_DumpNameTable(LPDIRECTPLAY8PEER pDirectPlay8Peer, char *const Buffer)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DN_DumpNameTable(NULL, Buffer);
}

HRESULT WINAPI IDirectPlay8Peer_DoWork(LPDIRECTPLAY8PEER pDirectPlay8Peer, const DWORD dwFlags)
{
    return DIRECTNETOBJECT::GetDirectPlay8Peer(pDirectPlay8Peer)->DoWork(dwFlags);
}



//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//	DN_SetPeerInfo
//
//	Set the info for the local player (peer) and propagate to other players

#undef DPF_MODNAME
#define DPF_MODNAME "DN_SetPeerInfo"

HRESULT DIRECTNETOBJECT::DN_SetPeerInfo( IDirectPlay8Peer *pInterface,
							  const DPN_PLAYER_INFO *const pdpnPlayerInfo,
							  PVOID const pvAsyncContext,
							  DPNHANDLE *const phAsyncHandle,
							  const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	HRESULT				hResultCode;
	DPNHANDLE			hAsyncOp;
	PWSTR				pwszName;
	DWORD				dwNameSize;
	PVOID				pvData;
	DWORD				dwDataSize;
	CNameTableEntry		*pLocalPlayer;
	BOOL				fConnected;

	DPF(2,"Parameters: pInterface [0x%p], pdpnPlayerInfo [0x%p], pvAsyncContext [0x%p], phAsyncHandle [%p], dwFlags [0x%lx]",
			pInterface,pdpnPlayerInfo,pvAsyncContext,phAsyncHandle,dwFlags);
    	
	RIP_ON_NOT_TRUE( "SetPeerInfo() Error validating params", SUCCEEDED( DN_ValidateSetPeerInfo( pInterface , pdpnPlayerInfo, pvAsyncContext, phAsyncHandle, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "SetPeerInfo() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

	pLocalPlayer = NULL;

	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_NAME) && (pdpnPlayerInfo->pwszName))
	{
		pwszName = pdpnPlayerInfo->pwszName;
		dwNameSize = (wcslen(pwszName) + 1) * sizeof(WCHAR);
	}
	else
	{
		pwszName = NULL;
		dwNameSize = 0;
	}
	if ((pdpnPlayerInfo->dwInfoFlags & DPNINFO_DATA) && (pdpnPlayerInfo->pvData) && (pdpnPlayerInfo->dwDataSize))
	{
		pvData = pdpnPlayerInfo->pvData;
		dwDataSize = pdpnPlayerInfo->dwDataSize;
	}
	else
	{
		pvData = NULL;
		dwDataSize = 0;
	}

	//
	//	If we are connected, we will update our entry if we are the Host, or request the Host to update us.
	//	Otherwise, we will just update the DefaultPlayer.
	//
	DNEnterCriticalSection(&pdnObject->csDirectNetObject);
	if (pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED)
	{
		fConnected = TRUE;
	}
	else
	{
		fConnected = FALSE;
	}
	DNLeaveCriticalSection(&pdnObject->csDirectNetObject);
	if (fConnected)
	{
		if ((hResultCode = pdnObject->NameTable.GetLocalPlayerRef( &pLocalPlayer )) != DPN_OK)
		{
			DPFERR( "Could not get local player reference" );
			DisplayDNError(0,hResultCode);
			goto Failure;
		}

		if (pLocalPlayer->IsHost())
		{
			DPF(3,"Host is updating peer info");

			hResultCode = DNHostUpdateInfo(	pdnObject,
											pLocalPlayer->GetDPNID(),
											pwszName,
											dwNameSize,
											pvData,
											dwDataSize,
											pdpnPlayerInfo->dwInfoFlags,
											pvAsyncContext,
											pLocalPlayer->GetDPNID(),
											0,
											&hAsyncOp,
											dwFlags );
			if ((hResultCode != DPN_OK) && (hResultCode != DPNERR_PENDING))
			{
				DPFERR("Could not request host to update group");
			}
			else
			{
					DPF(3,"Async Handle [0x%lx]",hAsyncOp);
					*phAsyncHandle = hAsyncOp;

					//
					//	Release Async HANDLE since this operation has already completed (!)
					//
					pdnObject->HandleTable.Destroy( hAsyncOp );
					hAsyncOp = 0;
			}
		}
		else
		{
			DPF(3,"Request host to update group info");

			hResultCode = DNRequestUpdateInfo(	pdnObject,
												pLocalPlayer->GetDPNID(),
												pwszName,
												dwNameSize,
												pvData,
												dwDataSize,
												pdpnPlayerInfo->dwInfoFlags,
												pvAsyncContext,
												&hAsyncOp,
												dwFlags);
			if (hResultCode != DPN_OK && hResultCode != DPNERR_PENDING)
			{
				DPFERR("Could not request host to update group info");
			}
			else
			{
					DPF(3,"Async Handle [0x%lx]",hAsyncOp);
					*phAsyncHandle = hAsyncOp;
			}
		}

		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	else
	{
		DNASSERT(pdnObject->NameTable.GetDefaultPlayer() != NULL);

		// This function takes the lock internally
		pdnObject->NameTable.GetDefaultPlayer()->UpdateEntryInfo(pwszName,dwNameSize,pvData,dwDataSize,pdpnPlayerInfo->dwInfoFlags, FALSE);

		hResultCode = DPN_OK;
	}

Exit:
	DPF(2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pLocalPlayer)
	{
		pLocalPlayer->Release();
		pLocalPlayer = NULL;
	}
	goto Exit;
}


//	DN_GetPeerInfo
//
//	Retrieve peer info from the local nametable.

#undef DPF_MODNAME
#define DPF_MODNAME "DN_GetPeerInfo"

HRESULT DIRECTNETOBJECT::DN_GetPeerInfo(IDirectPlay8Peer *pInterface,
							const DPNID dpnid,
							DPN_PLAYER_INFO *const pdpnPlayerInfo,
							DWORD *const pdwSize,
							const DWORD dwFlags)
{
	DIRECTNETOBJECT		*pdnObject = this;
	CNameTableEntry		*pNTEntry;
	HRESULT				hResultCode;
	CPackedBuffer		packedBuffer;

	DPF(2,"Parameters: dpnid [0x%lx], pdpnPlayerInfo [0x%p], dwFlags [0x%lx]",
			dpnid,pdpnPlayerInfo,dwFlags);

	RIP_ON_NOT_TRUE( "GetPeerInfo() Error validating params", SUCCEEDED( DN_ValidateGetPeerInfo( pInterface , dpnid, pdpnPlayerInfo, pdwSize, dwFlags ) ) );
    	RIP_ON_NOT_TRUE( "GetPeerInfo() Object is not initialized", pdnObject->dwFlags & DN_OBJECT_FLAG_INITIALIZED );

    	if( pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTING )
    	{
    	    DPFERR("Object is connecting / starting to host" );
    	    DPF_RETURN(DPNERR_CONNECTING);
    	}

    	if( !(pdnObject->dwFlags & DN_OBJECT_FLAG_CONNECTED) &&
    	   !(pdnObject->dwFlags & DN_OBJECT_FLAG_DISCONNECTING) )
    	{
    	    DPFERR("You must be connected / disconnecting to use this function" );
    	    DPF_RETURN(DPNERR_NOCONNECTION);
    	}	    	

	pNTEntry = NULL;

	if ((hResultCode = pdnObject->NameTable.FindEntry(dpnid,&pNTEntry)) != DPN_OK)
	{
		DPFERR("Could not retrieve name table entry");
		DisplayDNError(0,hResultCode);

		//
		//	Try deleted list
		//
		if ((hResultCode = pdnObject->NameTable.FindDeletedEntry(dpnid,&pNTEntry)) != DPN_OK)
		{
			DPFERR("Could not find player in deleted list either");
			DisplayDNError(0,hResultCode);
			hResultCode = DPNERR_INVALIDPLAYER;
			goto Failure;
		}
	}
	packedBuffer.Initialize(pdpnPlayerInfo,*pdwSize);

	pNTEntry->Lock();
	if (pNTEntry->IsGroup())
	{
	    DPFERR( "Specified ID is invalid" );
		pNTEntry->Unlock();
		hResultCode = DPNERR_INVALIDPLAYER;
		goto Failure;
	}
